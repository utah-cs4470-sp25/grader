global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: db `a`, 0
const1: dq 1
const2: dq 614
const3: db `non-positive loop bound`, 0
const4: dq 798
const5: dq 19
const6: dq 150
const7: db `overflow computing array size`, 0
const8: dq 864
const9: db `negative array index`, 0
const10: db `index too large`, 0
const11: dq 953
const12: dq 876
const13: dq 471
const14: db `divide by zero`, 0
const15: dq 835
const16: dq 523
const17: dq 925
const18: dq 666
const19: dq 910
const20: dq 499
const21: dq 76.03
const22: dq 30.64
const23: dq 20.55
const24: dq 209
const25: dq 970
const26: dq 431
const27: dq 454
const28: dq 51
const29: dq 201
const30: dq 650
const31: dq 419
const32: dq 887
const33: db `mod by zero`, 0
const34: dq 80.35
const35: dq 29.35
const36: dq 874
const37: dq 264
const38: dq 196
const39: dq 66.67
const40: dq 77
const41: dq 249
const42: dq 977
const43: dq 642
const44: dq 266
const45: dq 0
const46: dq 71.6
const47: dq 65.08
const48: dq 4.65
const49: dq 51.39
const50: dq 34.38
const51: dq 3.28
const52: dq 76.65
const53: dq 68.7
const54: dq 16.69
const55: dq 43.77
const56: dq 64.74
const57: dq 380
const58: dq 559
const59: dq 849
const60: dq 277
const61: dq 633
const62: dq 799
const63: dq 567
const64: dq 14.01
const65: dq 87.69
const66: dq 853
const67: dq 88
const68: dq 389
const69: dq 428
const70: dq 675
const71: dq 832
const72: dq 3
const73: dq 95.57
const74: dq 570
const75: dq 952
const76: dq 55.33
const77: dq 96.6
const78: dq 35.56
const79: dq 52.18
const80: dq 151
const81: dq 48.35
const82: dq 99.39
const83: dq 88.33
const84: dq 989
const85: dq 298
const86: dq 659
const87: dq 211
const88: dq 793
const89: dq 126
const90: dq 173
const91: dq 726
const92: dq 923
const93: dq 613
const94: dq 236
const95: dq 390
const96: dq 87.36
const97: dq 95.37
const98: dq 934
const99: dq 591
const100: dq 20.89
const101: dq 51.8
const102: dq 246
const103: dq 33.39
const104: dq 171
const105: dq 586
const106: dq 901
const107: dq 595
const108: dq 10.75
const109: dq 212
const110: dq 651
const111: dq 598
const112: dq 764
const113: dq 325
const114: dq 862
const115: dq 883
const116: dq 106
const117: dq 60
const118: dq 395
const119: dq 239
const120: dq 731
const121: dq 871
const122: dq 52
const123: dq 202
const124: dq 397
const125: dq 822
const126: dq 16
const127: dq 5.99
const128: dq 58.78
const129: dq 76.11
const130: dq 75.08
const131: dq 85.1
const132: dq 63.51
const133: dq 54.18
const134: dq 63.82
const135: dq 66
const136: dq 44
const137: dq 42.28
const138: dq 528
const139: dq 147
const140: dq 84.16
const141: dq 91.03
const142: dq 75.02
const143: dq 16.9
const144: dq 51.54
const145: dq 237
const146: dq 73.69
const147: dq 70.61
const148: db `e`, 0
const149: dq 950
const150: dq 58.04
const151: dq 16.74
const152: dq 48.19
const153: dq 50.25
const154: dq 73.4
const155: dq 754
const156: dq 979
const157: dq 22.69
const158: dq 76.74
const159: dq 929
const160: dq 895
const161: dq 962
const162: dq 530
const163: dq 765
const164: dq 721
const165: dq 519
const166: dq 904
const167: dq 646
const168: dq 63.33
const169: dq 17.18
const170: dq 29.66
const171: dq 75.94
const172: dq 71.54
const173: dq 60.85
const174: dq 611
const175: dq 870
const176: dq 556
const177: dq 96
const178: dq 305
const179: dq 969
const180: dq 89
const181: dq 780
const182: dq 79.88
const183: dq 22.92
const184: dq 66.04
const185: dq 99.16
const186: dq 503
const187: dq 458
const188: dq 813
const189: dq 480
const190: dq 510
const191: dq 669
const192: dq 671
const193: dq 749
const194: dq 142
const195: dq 751
const196: dq 72
const197: dq 7
const198: dq 605
const199: dq 187
const200: dq 10
const201: dq 477
const202: dq 439
const203: dq 513
const204: dq 971
const205: dq 712
const206: dq 547
const207: dq 326
const208: dq 940
const209: dq 67
const210: dq 657
const211: dq 644
const212: dq 903
const213: dq 890
const214: dq 279
const215: dq 84
const216: dq 752
const217: dq 235
const218: dq 718
const219: dq 930
const220: dq 176
const221: dq 24
const222: dq 722
const223: dq 576
const224: dq 927
const225: dq 868
const226: dq 117
const227: dq 309
const228: dq 159
const229: dq 772
const230: dq 178
const231: dq 63
const232: dq 550
const233: dq 11
const234: dq 21.22
const235: dq 33.67
const236: dq 638
const237: dq 545
const238: dq 123
const239: dq 261
const240: dq 301
const241: dq 909
const242: dq 138
const243: dq 738
const244: dq 814
const245: dq 238
const246: dq 259
const247: dq 321
const248: dq 607
const249: dq 57
const250: dq 888
const251: dq 365
const252: dq 856
const253: dq 941
const254: dq 165
const255: dq 160
const256: dq 647
const257: dq 978
const258: dq 317
const259: dq 221
const260: dq 270
const261: dq 975
const262: dq 526
const263: dq 116
const264: dq 972
const265: dq 696
const266: dq 21
const267: dq 399
const268: dq 623
const269: dq 205
const270: dq 562
const271: dq 99
const272: dq 737
const273: dq 273
const274: dq 565
const275: dq 907
const276: dq 999
const277: dq 109
const278: dq 612
const279: dq 711
const280: dq 70
const281: dq 796
const282: dq 335
const283: dq 220
const284: dq 269
const285: dq 131
const286: dq 296
const287: dq 381
const288: dq 134
const289: dq 139
const290: dq 770
const291: dq 886
const292: dq 881
const293: dq 36
const294: dq 948
const295: dq 386
const296: dq 268
const297: dq 831
const298: dq 533
const299: dq 462
const300: dq 750
const301: dq 566
const302: dq 15
const303: dq 440
const304: dq 245
const305: dq 496
const306: dq 12
const307: dq 997
const308: dq 127
const309: dq 968
const310: dq 378
const311: dq 281
const312: dq 46
const313: dq 488
const314: dq 189
const315: dq 694
const316: dq 226
const317: dq 878
const318: dq 782
const319: dq 618
const320: dq 21.44
const321: dq 40.56
const322: dq 812
const323: dq 522
const324: dq 845
const325: dq 11.18
const326: dq 511
const327: dq 58.67
const328: dq 21.91
const329: dq 58.41
const330: dq 590
const331: dq 60.25
const332: dq 70.87
const333: dq 98.43
const334: dq 315
const335: dq 230
const336: dq 276
const337: dq 278
const338: dq 960
const339: dq 169
const340: dq 451
const341: dq 41.58
const342: dq 50.56
const343: dq 66.82
const344: dq 49.59
const345: dq 827
const346: dq 604
const347: dq 128
const348: dq 172
const349: dq 908
const350: dq 540
const351: dq 359
const352: dq 225
const353: dq 283
const354: dq 69.65
const355: dq 20.32
const356: dq 70.21
const357: dq 43.27
const358: dq 4.27
const359: dq 99.82
const360: dq 34.79
const361: dq 7.82
const362: dq 68.65
const363: dq 56.1
const364: dq 65.87
const365: dq 86.04
const366: dq 50.06
const367: dq 508
const368: dq 73.86
const369: dq 0.05
const370: dq 85.47
const371: dq 809
const372: dq 47.37
const373: dq 77.64
const374: dq 931
const375: dq 452
const376: dq 192
const377: dq 307
const378: dq 885
const379: dq 841
const380: dq 900
const381: dq 817
const382: dq 360
const383: dq 8
const384: dq 897
const385: dq 470
const386: dq 483
const387: dq 867
const388: dq 303
const389: dq 492
const390: dq 677
const391: dq 183
const392: dq 84.07
const393: dq 50.66
const394: dq 50.46
const395: dq 40.23
const396: dq 67.8
const397: dq 937
const398: dq 81.05
const399: dq 92.94
const400: dq 4.66
const401: dq 10.35
const402: dq 39.24
const403: dq 198
const404: dq 957
const405: dq 1.87
const406: dq 93.83
const407: dq 27.9
const408: dq 20.3
const409: dq 4.01
const410: dq 85.52
const411: dq 8.01
const412: dq 46.53
const413: dq 730
const414: dq 816
const415: dq 609
const416: dq 697
const417: dq 306
const418: dq 223
const419: dq 518
const420: dq 152
const421: dq 654
const422: dq 706
const423: dq 457
const424: dq 641
const425: dq 935
const426: dq 62
const427: dq 410
const428: dq 91.08
const429: dq 11.77
const430: dq 57.13
const431: dq 53.86
const432: dq 57.4
const433: dq 94.99
const434: dq 74.94
const435: dq 86.41
const436: dq 40.09
const437: dq 60.96
const438: dq 94.26
const439: dq 27.86
const440: dq 338
const441: dq 396
const442: dq 87
const443: dq 331
const444: dq 958
const445: dq 119
const446: dq 820
const447: dq 687
const448: dq 757
const449: dq 917
const450: dq 986
const451: dq 103
const452: dq 702
const453: dq 122
const454: dq 843
const455: dq 334
const456: dq 242
const457: dq 603
const458: dq 884
const459: dq 25
const460: dq 704
const461: dq 265
const462: dq 71.97
const463: dq 94.45
const464: dq 1000
const465: dq 936
const466: dq 319
const467: dq 75.14
const468: dq 81.03
const469: dq 72.08
const470: dq 17.28
const471: dq 29.53
const472: dq 78
const473: dq 38.63
const474: dq 86.13
const475: dq 174
const476: dq 52.33
const477: dq 15.17
const478: dq 57.23
const479: dq 56.02
const480: dq 88.36
const481: dq 43.64
const482: dq 197
const483: dq 37.72
const484: dq 93.92
const485: dq 110
const486: dq 7.37
const487: dq 3.86
const488: dq 77.75
const489: dq 11.61
const490: dq 83.7
const491: dq 24.08
const492: dq 86
const493: dq 71.13
const494: dq 29.33
const495: dq 41.37
const496: dq 45.45
const497: dq 75.31
const498: dq 19.93
const499: dq 93.52
const500: dq 64.4
const501: dq 267
const502: dq 417
const503: dq 43.61
const504: dq 98.59
const505: dq 44.73
const506: db `n`, 0
const507: dq 355
const508: dq 35.25
const509: dq 51.69
const510: dq 24.83
const511: dq 320
const512: dq 57.82
const513: dq 52.11
const514: dq 67.21
const515: dq 54.14
const516: dq 90.8
const517: dq 60.34
const518: dq 5.88
const519: dq 11.51
const520: dq 94.42
const521: dq 758
const522: dq 177
const523: dq 68
const524: dq 241
const525: dq 670
const526: dq 186
const527: dq 700
const528: dq 95.22
const529: dq 40.8
const530: dq 289
const531: dq 337
const532: dq 9.96
const533: dq 293
const534: dq 863
const535: dq 869
const536: dq 35.47
const537: dq 753
const538: dq 418
const539: dq 444
const540: dq 549
const541: dq 322
const542: dq 85
const543: dq 569
const544: dq 902
const545: dq 629
const546: dq 188
const547: dq 254
const548: dq 41
const549: dq 602
const550: dq 756
const551: dq 501
const552: dq 224
const553: dq 455
const554: dq 107
const555: dq 672
const556: dq 125
const557: dq 213
const558: dq 49
const559: dq 113
const560: dq 146
const561: dq 9.41
const562: dq 894
const563: dq 32
const564: dq 446
const565: dq 729
const566: dq 926
const567: dq 240
const568: dq 781
const569: dq 636
const570: dq 536
const571: dq 705
const572: dq 97.1
const573: dq 26.04
const574: dq 56.07
const575: dq 91.42
const576: dq 36.85
const577: dq 29.76
const578: dq 20.65
const579: dq 89.53
const580: dq 87.94
const581: dq 27.93
const582: dq 97.0
const583: dq 74.1
const584: dq 21.67
const585: dq 719
const586: dq 285
const587: dq 662
const588: dq 361
const589: dq 680
const590: dq 990
const591: dq 915
const592: dq 946
const593: dq 808
const594: dq 376
const595: dq 17
const596: dq 400
const597: dq 840
const598: dq 38.42
const599: dq 12.92
const600: dq 57.51
const601: dq 62.07
const602: dq 59.15
const603: dq 45.57
const604: dq 14.05
const605: dq 46.05
const606: dq 56.03
const607: dq 5.7
const608: dq 95
const609: dq 40
const610: dq 163
const611: dq 574
const612: dq 859
const613: dq 592
const614: dq 558
const615: dq 436
const616: dq 944
const617: dq 517
const618: dq 203
const619: dq 844
const620: dq 22
const621: dq 373
const622: dq 71
const623: dq 811
const624: dq 15.67
const625: dq 84.47
const626: dq 2.87
const627: dq 60.64
const628: dq 20.73
const629: dq 17.45
const630: dq 442
const631: dq 50
const632: dq 121
const633: dq 275
const634: dq 96.19
const635: dq 30
const636: dq 905
const637: dq 823
const638: dq 358
const639: dq 286
const640: dq 384
const641: dq 824
const642: dq 531
const643: dq 349
const644: dq 341
const645: dq 733
const646: dq 747
const647: dq 409
const648: dq 599
const649: dq 593
const650: dq 421
const651: db `e.png`, 0
const652: dq 129
const653: dq 59
const654: dq 219
const655: dq 482
const656: dq 48
const657: dq 785
const658: dq 76.93
const659: dq 2.64
const660: dq 893
const661: dq 760
const662: dq 858
const663: dq 640
const664: dq 39.16
const665: dq 31.77
const666: dq 233
const667: dq 521
const668: dq 200
const669: dq 140
const670: dq 31
const671: dq 62.04
const672: dq 80.81
const673: dq 94.27
const674: dq 23.4
const675: dq 889
const676: dq 39.72
const677: dq 50.09
const678: dq 81.19
const679: dq 87.85
const680: dq 85.49
const681: dq 682
const682: dq 524
const683: dq 1.83
const684: dq 11.85
const685: dq 36.48
const686: dq 9.01
const687: dq 527
const688: dq 251
const689: dq 663
const690: dq 735
const691: dq 594
const692: dq 797
const693: dq 466
const694: dq 425
const695: dq 36.13
const696: dq 68.52
const697: dq 763
const698: dq 348
const699: dq 996
const700: dq 157
const701: dq 328
const702: dq 263
const703: dq 299
const704: dq 368
const705: dq 104
const706: dq 800
const707: dq 27
const708: dq 98
const709: dq 83
const710: dq 981
const711: dq 773
const712: dq 382
const713: dq 794
const714: dq 372
const715: dq 768
const716: dq 387
const717: dq 703
const718: dq 14
const719: dq 509
const720: dq 63.31
const721: dq 5.96
const722: dq 353
const723: dq 6
const724: dq 64
const725: dq 660
const726: dq 956
const727: db `g`, 0
const728: dq 548
const729: dq 193
const730: dq 579
const731: dq 520
const732: dq 906
const733: dq 787
const734: dq 310
const735: dq 767
const736: dq 427
const737: dq 82
const738: dq 55
const739: dq 64.04
const740: dq 74.75
const741: dq 571
const742: dq 9
const743: dq 356
const744: dq 875
const745: dq 695
const746: dq 806
const747: dq 290
const748: dq 391
const749: dq 919
const750: dq 339
const751: dq 596
const752: dq 575
const753: dq 47
const754: dq 272
const755: dq 546
const756: dq 347
const757: dq 29.21
const758: dq 42.24
const759: dq 920
const760: dq 873
const761: dq 434
const762: dq 833
const763: dq 256
const764: dq 826
const765: dq 145
const766: dq 69
const767: dq 76.67
const768: dq 41.11
const769: dq 76.69
const770: dq 31.18
const771: dq 63.16
const772: dq 69.87
const773: dq 78.26
const774: dq 77.85
const775: dq 99.55
const776: dq 17.48
const777: dq 77.66
const778: dq 88.75
const779: dq 34.46
const780: dq 33.95
const781: dq 954
const782: dq 686
const783: dq 17.51
const784: dq 993
const785: dq 538
const786: dq 472
const787: dq 542
const788: dq 207
const789: dq 739
const790: dq 63.58
const791: dq 55.58
const792: dq 330
const793: dq 648
const794: dq 413
const795: dq 717
const796: dq 632
const797: dq 243
const798: dq 75
const799: dq 48.15
const800: dq 88.82
const801: dq 99.62
const802: dq 37.49
const803: dq 947
const804: dq 959
const805: dq 52.21
const806: dq 600
const807: dq 248
const808: dq 51.11
const809: dq 11.46
const810: dq 786
const811: dq 280
const812: dq 551
const813: dq 392
const814: dq 955
const815: dq 95.52
const816: dq 49.18
const817: dq 43.06
const818: dq 91
const819: dq 101
const820: dq 557
const821: dq 206
const822: dq 190
const823: dq 699
const824: dq 23
const825: dq 29.05
const826: dq 344
const827: dq 688
const828: dq 231
const829: dq 218
const830: dq 175
const831: dq 502
const832: dq 643
const833: dq 500
const834: dq 26
const835: dq 162
const836: dq 506
const837: dq 715
const838: dq 99.03
const839: db `k`, 0
const840: dq 461
const841: dq 3.68
const842: dq 3.44
const843: dq 72.23
const844: dq 93.16
const845: dq 802
const846: dq 26.84
const847: dq 49.11
const848: dq 59.03
const849: dq 67.41
const850: dq 481
const851: dq 854
const852: dq 684
const853: dq 39.87
const854: dq 31.69
const855: dq 45.68
const856: dq 41.1
const857: dq 84.79
const858: dq 635
const859: dq 93.0
const860: dq 51.33
const861: dq 71.12
const862: dq 18.92
const863: dq 97.73
const864: db `(BoolType)`, 0
const865: dq 7.2
const866: dq 75.01
const867: dq 115
const868: dq 407
const869: dq 11.0
const870: dq 300
const871: dq 912
const872: dq 465
const873: dq 13.47
const874: dq 313
const875: dq 11.83
const876: dq 51.58
const877: dq 79.58
const878: dq 85.3
const879: dq 18.27
const880: dq 60.14
const881: dq 76.75
const882: dq 736
const883: dq 11.66
const884: dq 597
const885: dq 155
const886: dq 168
const887: dq 53.0
const888: dq 90
const889: dq 329
const890: dq 2.21
const891: dq 46.95
const892: dq 33.7
const893: dq 20.71
const894: dq 41.25
const895: dq 939
const896: dq 438
const897: dq 624
const898: dq 77.36
const899: dq 584
const900: dq 627
const901: dq 216
const902: dq 838
const903: dq 24.02
const904: dq 51.3
const905: dq 801
const906: dq 791
const907: dq 829
const908: dq 0.01
const909: dq 96.04
const910: dq 82.44
const911: dq 97.32
const912: dq 49.0
const913: dq 80.01
const914: dq 713
const915: dq 963
const916: dq 191
const917: dq 291
const918: dq 683
const919: dq 608
const920: dq 489
const921: dq 724
const922: dq 766
const923: dq 497
const924: dq 880
const925: dq 81
const926: dq 274
const927: dq 433
const928: dq 615
const929: dq 96.46
const930: dq 70.72
const931: dq 57.36
const932: dq 90.45
const933: dq 60.09
const934: dq 92.11
const935: dq 48.81
const936: dq 976
const937: dq 9.68
const938: dq 53.29
const939: dq 362
const940: dq 505
const941: dq 943
const942: dq 485
const943: dq 430
const944: dq 628
const945: dq 38.58
const946: dq 778
const947: dq 9.97
const948: dq 71.45
const949: dq 8.75
const950: dq 95.39
const951: dq 837
const952: dq 327
const953: dq 37
const954: dq 2.45
const955: dq 82.78
const956: dq 52.29
const957: dq 19.13
const958: dq 137
const959: dq 215
const960: dq 973
const961: dq 805
const962: dq 32.18
const963: dq 89.3
const964: dq 18.74
const965: dq 725
const966: dq 79.99
const967: dq 16.96
const968: dq 810
const969: dq 314
const970: dq 164
const971: db `h`, 0
const972: dq 304
const973: dq 62.97
const974: dq 75.78
const975: dq 1.92
const976: dq 13
const977: dq 271
const978: dq 4
const979: dq 23.65
const980: dq 9.84
const981: dq 98.14
const982: dq 830
const983: dq 96.64
const984: dq 67.03
const985: dq 9.99
const986: dq 539
const987: dq 655
const988: dq 714
const989: dq 716
const990: dq 161
const991: dq 8.18
const992: dq 34.97
const993: dq 4.99
const994: dq 100
const995: dq 495
const996: dq 447
const997: dq 32.55
const998: dq 24.87
const999: dq 24.88
const1000: dq 49.77
const1001: dq 14.35
const1002: dq 79.2
const1003: dq 87.48
const1004: dq 59.37
const1005: dq 537
const1006: dq 167
const1007: dq 848
const1008: dq 583
const1009: dq 324
const1010: dq 29
const1011: dq 229
const1012: dq 616
const1013: dq 66.75
const1014: dq 60.41
const1015: dq 10.72
const1016: dq 71.34
const1017: dq 20.08
const1018: dq 32.98
const1019: db `l`, 0
const1020: dq 404
const1021: dq 426
const1022: dq 311
const1023: dq 560
const1024: dq 949
const1025: dq 561
const1026: dq 552
const1027: dq 74
const1028: dq 89.81
const1029: dq 83.9
const1030: dq 25.54
const1031: dq 46.57
const1032: dq 332
const1033: dq 693
const1034: dq 374
const1035: dq 54.89
const1036: dq 31.68
const1037: dq 914
const1038: dq 181
const1039: dq 401
const1040: dq 255
const1041: dq 637
const1042: dq 65.14
const1043: dq 88.15
const1044: dq 37.25
const1045: dq 50.67
const1046: dq 85.74
const1047: dq 71.57
const1048: dq 69.18
const1049: dq 13.71
const1050: dq 55.17
const1051: dq 0.14
const1052: dq 819
const1053: dq 658
const1054: dq 988
const1055: dq 143
const1056: dq 39
const1057: dq 951
const1058: dq 180
const1059: dq 667
const1060: dq 56
const1061: dq 8.83
const1062: dq 4.86
const1063: dq 2.46
const1064: dq 149
const1065: dq 656
const1066: dq 388
const1067: dq 673
const1068: dq 118
const1069: dq 587
const1070: dq 921
const1071: dq 141
const1072: dq 493
const1073: dq 144
const1074: dq 516
const1075: dq 369
const1076: dq 911
const1077: dq 723
const1078: dq 554
const1079: dq 626
const1080: dq 490
const1081: dq 645
const1082: dq 847
const1083: dq 92
const1084: dq 744
const1085: dq 94
const1086: dq 877
const1087: dq 741
const1088: dq 443
const1089: dq 945
const1090: dq 71.48
const1091: dq 27.33
const1092: dq 415
const1093: dq 58
const1094: dq 420
const1095: dq 3.25
const1096: dq 83.18
const1097: dq 21.11
const1098: dq 398
const1099: dq 974
const1100: dq 27.88
const1101: dq 112
const1102: dq 85.64
const1103: dq 48.92
const1104: dq 28.95
const1105: dq 34
const1106: dq 377
const1107: dq 244
const1108: dq 783
const1109: dq 891
const1110: dq 28.36
const1111: dq 631
const1112: dq 585
const1113: dq 27.77
const1114: dq 54.04
const1115: dq 90.34
const1116: dq 86.26
const1117: dq 63.88
const1118: dq 25.12
const1119: dq 507
const1120: dq 815
const1121: dq 857
const1122: dq 408
const1123: dq 351
const1124: dq 96.55
const1125: dq 20
const1126: dq 234
const1127: dq 478
const1128: dq 79
const1129: dq 204
const1130: dq 66.93
const1131: db `q`, 0
const1132: dq 85.21
const1133: dq 52.86
const1134: dq 87.72
const1135: dq 38
const1136: dq 37.64
const1137: db `s.png`, 0
const1138: dq 795
const1139: dq 51.85
const1140: dq 2.9
const1141: db `t.png`, 0
const1142: dq 182
const1143: dq 649
const1144: dq 260
const1145: db `N`, 0
const1146: dq 463
const1147: dq 411
const1148: dq 984
const1149: dq 44.19
const1150: dq 68.82
const1151: dq 69.16
const1152: dq 363
const1153: db `K`, 0
const1154: dq 437
const1155: db `M`, 0
const1156: dq 71.02
const1157: dq 28
const1158: dq 23.0
const1159: dq 19.42
const1160: dq 31.1
const1161: dq 28.65
const1162: dq 13.59
const1163: dq 16.51
const1164: db `aa`, 0
const1165: dq 51.67
const1166: db `D.png`, 0

section .text
b:
_b:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const148] ; 'e'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump235:
	sub rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const149] ; 950
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump236
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump236:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 950 
	jno .jump237
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump237:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump238: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump239:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump240
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump240:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump241:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump242
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump242:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump243
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump243:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- e)) 
	jno .jump244
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump244:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump245
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump245:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump246
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump246:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump247: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const150] ; 58.04
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const151] ; 16.74
	push rax
	mov rax, [rel const152] ; 48.19
	push rax
	mov rax, [rel const153] ; 50.25
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const154] ; 73.4
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump247 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump247 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump247 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump247 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump238 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump248
	mov rax, [rel const155] ; 754
	push rax
	jmp .jump249
.jump248:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump250
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump251
.jump250:
	mov rax, [rel const156] ; 979
	push rax
.jump251:
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
.jump249:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump252
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump252:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! false) then 754 else (- (- (if a then d else 979)))) 
	jno .jump253
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump253:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump254: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const157] ; 22.69
	push rax
	mov rax, [rel const158] ; 76.74
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump255
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump257
	mov rax, [rel const159] ; 929
	push rax
	jmp .jump258
.jump257:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump258:
	jmp .jump256
.jump255:
	mov rax, [rel const160] ; 895
	push rax
.jump256:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump259:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump260:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump261
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump261:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump262
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump262:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump263:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump264:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump265:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump266: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const161] ; 962
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump266 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump266 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump267:
	; Computing bound for 'g'
	mov rax, [rel const162] ; 530
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump268
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump268:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump269:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump270: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump270 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump270 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump270 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump271
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump271:
	; Computing bound for 'f'
	mov rax, [rel const163] ; 765
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump272:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump273: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump273 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump273 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump274:
	cmp rax, [rsp + 16]
	jl .jump275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump275:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump276:
	cmp rax, [rsp + 24]
	jl .jump277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump277:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump278:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump279:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump280
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump281
.jump280:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump281:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump282
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump282:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const164] ; 721
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump283
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump283:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump284 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	; Computing bound for 'f'
	mov rax, [rel const165] ; 519
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump286
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump286:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump287: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const166] ; 904
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump287 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump287 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump287 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump287 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump288
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump288:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump289: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump289 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump289 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump289 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump289 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump290
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump290:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump291:
	; Computing bound for 'f'
	mov rax, [rel const167] ; 646
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump292
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump292:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 646 
	jno .jump293
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump293:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump294
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump294:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : (sum[f : 519, g : (sum[f : 721] e), h : (if a then e else e), i : d] 904), g : (array[f : e, g : d] 962)[(sum[f : 765, g : e] e), (sum[f : e, g : 530, h : e] g)], h : (- e), i : e] i) 
	jno .jump295
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump295:
	imul rdi, [rsp + 0 + 24] ; multiply by (if (76.74 <= 22.69) then (if a then 929 else e) else 895) 
	jno .jump296
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump296:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump297: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const168] ; 63.33
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const169] ; 17.18
	push rax
	mov rax, [rel const170] ; 29.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const171] ; 75.94
	push rax
	mov rax, [rel const172] ; 71.54
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const173] ; 60.85
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump297 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump297 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump297 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump297 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump254 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump298
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump298:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump299
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump299:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump300: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump301
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump302
.jump301:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump302:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump303
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump303:
	; Computing bound for 'h'
	mov rax, [rel const174] ; 611
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump304:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump305
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump306
.jump305:
	mov rax, [rel const175] ; 870
	push rax
.jump306:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump307:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const176] ; 556
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump308
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump308:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump309:
	; Computing bound for 'f'
	mov rax, [rel const177] ; 96
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump310
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump310:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump311: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const178] ; 305
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump311 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump311 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump311 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump311 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump312
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump312:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump313
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump313:
	push rax
	pop rax
	cmp rax, 0
	je .jump314
	mov rax, [rel const179] ; 969
	push rax
	jmp .jump315
.jump314:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump315:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump316:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump317: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump317 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump317 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump317 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump317 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump318:
	; Computing bound for 'h'
	mov rax, [rel const180] ; 89
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump319
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump320
.jump319:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump321:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump320:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump322
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump322:
	; Computing bound for 'g'
	mov rax, [rel const181] ; 780
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump323:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump324
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump324:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump325
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump325:
	imul rdi, [rsp + 0 + 8] ; multiply by 780 
	jno .jump326
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump326:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (e == 89) then d else ((- d) % (- e))) 
	jno .jump327
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump327:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[f : (if (a && true) then 969 else e), g : (sum[f : (e * 96), g : d, h : (556 + d), i : (if a then d else 870)] 305), h : 611, i : (if true then d else e)] f) 
	jno .jump328
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump328:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump329: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const182] ; 79.88
	push rax
	mov rax, [rel const183] ; 22.92
	push rax
	mov rax, [rel const184] ; 66.04
	push rax
	mov rax, [rel const185] ; 99.16
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump329 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump329 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump329 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump329 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump300 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const186] ; 503
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump330
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump330:
	; Computing bound for 'e'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump331
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump331:
	; Computing bound for 'f'
	mov rax, [rel const187] ; 458
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump332:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump333
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump334
.jump333:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump334:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump335
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump335:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then d else d) 
	jno .jump336
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump336:
	imul rdi, [rsp + 0 + 8] ; multiply by 458 
	jno .jump337
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump337:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d) 
	jno .jump338
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump338:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump339: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump340:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump339 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump339 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump339 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump341
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump341:
	push rax
	pop rax
	cmp rax, 0
	je .jump342
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump343
.jump342:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump343:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump344
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump345
.jump344:
	mov rax, [rel const188] ; 813
	push rax
.jump345:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const113] ; 325
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump346
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump346:
	; Computing bound for 'e'
	mov rax, [rel const189] ; 480
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump347:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump348: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump348 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump348 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump349
	mov rax, [rel const190] ; 510
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump350
.jump349:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump350:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump351:
	cmp rax, [rsp + 24]
	jl .jump352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump352:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump353:
	cmp rax, [rsp + 32]
	jl .jump354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump354:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump355:
	cmp rax, [rsp + 40]
	jl .jump356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump356:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump357:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump358: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump358 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump358 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump359:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump360
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump360:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump361
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump362
.jump361:
	mov rax, [rel const191] ; 669
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump362:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump363:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump364: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const192] ; 671
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump364 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump364 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump364 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump365
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump365:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const193] ; 749
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump366
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump366:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump367:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump368: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump368 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump369
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump369:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump370: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const194] ; 142
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump370 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump371:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump372
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump372:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump373:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump374: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump375:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump376
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump376:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump377:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump378:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump379:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump380:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump381: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump381 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump381 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump381 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const195] ; 751
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump382:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump383
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump383:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump384:
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump385:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump386
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump386:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump387:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump388:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump389:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump390:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump391: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump391 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump391 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump391 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump392
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump392:
	cmp rax, [rsp + 24]
	jl .jump393
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump393:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump394
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump394:
	cmp rax, [rsp + 32]
	jl .jump395
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump395:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump396
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump396:
	cmp rax, [rsp + 40]
	jl .jump397
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump397:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump398
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump398:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump399: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump399 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump399 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump399 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump400
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump400:
	cmp rax, [rsp + 24]
	jl .jump401
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump401:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump402
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump402:
	cmp rax, [rsp + 32]
	jl .jump403
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump403:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump404
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump404:
	cmp rax, [rsp + 40]
	jl .jump405
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump405:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump374 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump374 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump374 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump374 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump406:
	cmp rax, [rsp + 8]
	jl .jump407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump407:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const1] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump408
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump410
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump411
.jump410:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const196] ; 72
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump412
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump412:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump413: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump414:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump415
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump415:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump416: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump416 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump416 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump413 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump417:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump418
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump418:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump419: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const197] ; 7
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump419 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump419 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump420
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump420:
	; Computing bound for 'g'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump421
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump422
.jump421:
	mov rax, [rel const198] ; 605
	push rax
.jump422:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump423:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump424: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump424 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump424 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump425
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const199] ; 187
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump426:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump427:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump428: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const200] ; 10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump428 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump429:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump430
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump430:
	; Computing bound for 'g'
	mov rax, [rel const201] ; 477
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump431:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 477 
	jno .jump432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump432:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- d)) 
	jno .jump433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump433:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[g : (d / 187)] 10) 
	jno .jump434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump434:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump435: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump436
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
.jump436:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump435 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump435 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump435 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const202] ; 439
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump437
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump437:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump438:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump439
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump439:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump440
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump440:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump441
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump441:
	imul rdi, [rsp + 0 + 16] ; multiply by 439 
	jno .jump442
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump442:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump443: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump443 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump443 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump443 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const203] ; 513
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump444
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump444:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump445:
	cmp rax, [rsp + 24]
	jl .jump446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump446:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump447:
	cmp rax, [rsp + 32]
	jl .jump448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump448:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump449:
	cmp rax, [rsp + 40]
	jl .jump450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump450:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump451:
	; Computing bound for 'i'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump452
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const204] ; 971
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump454:
	; Computing bound for 'g'
	mov rax, [rel const205] ; 712
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump455
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump455:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump456: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump456 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump456 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump453
.jump452:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump453:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump457
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump457:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump458
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump459
.jump458:
	mov rax, [rel const206] ; 547
	push rax
.jump459:
	mov rax, [rel const207] ; 326
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump460:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump461
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump462
.jump461:
	mov rax, [rel const208] ; 940
	push rax
.jump462:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump463
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump463:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump464: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const209] ; 67
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump465
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump465:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump466: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump466 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump464 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump464 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump464 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump464 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump467
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump469:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump470: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump470 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump468
.jump467:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump468:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump471
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump471:
	cmp rax, [rsp + 24]
	jl .jump472
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump472:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump473
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump473:
	cmp rax, [rsp + 32]
	jl .jump474
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump474:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump475
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump475:
	cmp rax, [rsp + 40]
	jl .jump476
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump476:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump425:
	push rax
.jump411:
	jmp .jump409
.jump408:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const210] ; 657
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
.jump409:
	pop rax
	cmp rax, 0
	je .jump477
	sub rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump479
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump481
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump483
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump483:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump484
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump484:
	push rax
	pop rax
	cmp rax, 0
	je .jump485
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump486
.jump485:
	mov rax, [rel const211] ; 644
	push rax
.jump486:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump487:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump488
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump488:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d) 
	jno .jump489
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump489:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (f || true) then (- d) else 644) 
	jno .jump490
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump490:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d) 
	jno .jump491
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump491:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump492: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump492 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump492 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump492 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump482
.jump481:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump493
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump493:
	; Computing bound for 'h'
	mov rax, [rel const212] ; 903
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump494:
	; Computing bound for 'g'
	mov rax, [rel const213] ; 890
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump495
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump495:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 890) 
	jno .jump496
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump496:
	imul rdi, [rsp + 0 + 8] ; multiply by 903 
	jno .jump497
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump497:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d) 
	jno .jump498
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump498:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump499: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump499 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump499 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump499 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump482:
	jmp .jump480
.jump479:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump500
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump502
	mov rax, [rel const214] ; 279
	push rax
	jmp .jump503
.jump502:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump503:
	jmp .jump501
.jump500:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const215] ; 84
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump501:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump504
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump504:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump505
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump505:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump506: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const216] ; 752
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump507:
	cqo
	idiv r10
	push rax
	mov rax, [rel const217] ; 235
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump506 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump508:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump509
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const218] ; 718
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump510
.jump509:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump511
	mov rax, [rel const219] ; 930
	push rax
	mov rax, [rel const220] ; 176
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump513:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump512
.jump511:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump514
	mov rax, [rel const221] ; 24
	push rax
	jmp .jump515
.jump514:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump515:
.jump512:
.jump510:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump516
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump516:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then (718 - d) else (if false then (176 % 930) else (if a then 24 else d))) 
	jno .jump517
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump517:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[g : d] (235 * (g / 752))) 
	jno .jump518
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump518:
	imul rdi, [rsp + 0 + 16] ; multiply by (if f then (if false then 279 else (- d)) else (- (84 * d))) 
	jno .jump519
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump519:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump520: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump521:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- g) 
	jno .jump522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump522:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump523: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump524:
	cmp rax, [rsp + 8]
	jl .jump525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump525:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump523 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump520 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump520 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump520 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump480:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump526
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const222] ; 722
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump528:
	; Computing bound for 'h'
	mov rax, [rel const223] ; 576
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump529
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump529:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump530:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump531: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump531 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump531 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump531 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump527
.jump526:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump532
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump533
.jump532:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump534
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump535
.jump534:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump535:
.jump533:
.jump527:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump536:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const29] ; 201
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump537:
	cmp rax, [rsp + 24]
	jl .jump538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump538:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump539:
	cmp rax, [rsp + 32]
	jl .jump540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump540:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump541:
	cmp rax, [rsp + 40]
	jl .jump542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump542:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	jmp .jump478
.jump477:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const224] ; 927
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump543:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const191] ; 669
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump544:
	; Computing bound for 'h'
	mov rax, [rel const225] ; 868
	push rax
	mov rax, [rel const226] ; 117
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump545
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump547
	mov rax, [rel const227] ; 309
	push rax
	jmp .jump548
.jump547:
	mov rax, [rel const228] ; 159
	push rax
.jump548:
	jmp .jump546
.jump545:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump549:
	; Computing bound for 'i'
	mov rax, [rel const229] ; 772
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump550
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump550:
	; Computing bound for 'h'
	mov rax, [rel const230] ; 178
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump551:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump552
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump552:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump553: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump553 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump553 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump553 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump553 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump546:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const231] ; 63
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump554
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump554:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump555: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump556
	mov rax, [rel const232] ; 550
	push rax
	jmp .jump557
.jump556:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump557:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump555 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const233] ; 11
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump558
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump558:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump559: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const234] ; 21.22
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump559 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const235] ; 33.67
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump560
	mov rax, [rel const236] ; 638
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump561
.jump560:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump562
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump564:
	cqo
	idiv r10
	push rax
	jmp .jump563
.jump562:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump563:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump565
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump565:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump566: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const237] ; 545
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump567:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 545 
	jno .jump568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump568:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump569: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump569 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump570
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump570:
	cmp rax, [rsp + 8]
	jl .jump571
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump571:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump566 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump561:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump572
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump572:
	; Computing bound for 'g'
	mov rax, [rel const238] ; 123
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump573
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const239] ; 261
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump575:
	; Computing bound for 'h'
	mov rax, [rel const238] ; 123
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump576
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump576:
	; Computing bound for 'g'
	mov rax, [rel const240] ; 301
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump577:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 301) 
	jno .jump578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump578:
	imul rdi, [rsp + 0 + 8] ; multiply by 123 
	jno .jump579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump579:
	imul rdi, [rsp + 0 + 16] ; multiply by 261 
	jno .jump580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump580:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump581: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump581 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump581 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump581 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump574
.jump573:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump582:
	; Computing bound for 'h'
	mov rax, [rel const241] ; 909
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump583:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump584:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump585:
	imul rdi, [rsp + 0 + 8] ; multiply by 909 
	jno .jump586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump586:
	imul rdi, [rsp + 0 + 16] ; multiply by (d + d) 
	jno .jump587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump587:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump588: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump588 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump588 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump588 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump574:
	mov rax, [rel const242] ; 138
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const243] ; 738
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump589
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump589:
	cmp rax, [rsp + 24]
	jl .jump590
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump590:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump591
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump591:
	cmp rax, [rsp + 32]
	jl .jump592
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump592:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump593
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump593:
	cmp rax, [rsp + 40]
	jl .jump594
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump594:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump595
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump595:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump596:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by ((if false then (array[g : (- 301), h : 123, i : 261] h) else (array[g : d, h : 909, i : (d + d)] h))[738, d, 138] % 123) 
	jno .jump597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump597:
imul rdi, [rsp + 0 + 8] ; multiply by ((if (33.67 >= (sum[g : 11] 21.22)) then (- 638) else (sum[g : (if (! false) then (d / d) else d)] (array[h : 545] g)[g])) - ((sum[g : (d + 63)] ((- d) - (if a then 550 else d))) + (if (117 >= 868) then (if true then 309 else 159) else (sum[g : d, h : 178, i : 772, j : d] (- g))))) 
	jno .jump598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump598:
	imul rdi, [rsp + 0 + 16] ; multiply by (669 * ((d % 927) + (- d))) 
	jno .jump599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump599:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump600: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump601
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump602
.jump601:
	mov rax, [rel const1] ; True
	push rax
.jump602:
	pop rax
	cmp rax, 0
	je .jump603
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump604
.jump603:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump604:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump605:
	cmp rax, [rsp + 8]
	jl .jump606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump606:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump600 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump600 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump600 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const244] ; 814
	push rax
	mov rax, [rel const245] ; 238
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump607
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump609
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump609:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump610:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump611
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump612
.jump611:
	mov rax, [rel const246] ; 259
	push rax
.jump612:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump613
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump613:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if f then d else 259) 
	jno .jump614
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump614:
	imul rdi, [rsp + 0 + 8] ; multiply by (- d) 
	jno .jump615
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump615:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump616
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump616:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump617: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump617 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump617 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump617 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump608
.jump607:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump618
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump618:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump619
	mov rax, [rel const247] ; 321
	push rax
	jmp .jump620
.jump619:
	mov rax, [rel const248] ; 607
	push rax
.jump620:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump621:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const249] ; 57
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump622
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump622:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (57 + d) 
	jno .jump623
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump623:
	imul rdi, [rsp + 0 + 8] ; multiply by (if f then 321 else 607) 
	jno .jump624
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump624:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump625
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump625:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump626: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const250] ; 888
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump626 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump626 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump626 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump608:
	mov rax, [rel const251] ; 365
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const252] ; 856
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump627:
	cmp rax, [rsp + 24]
	jl .jump628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump628:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump629:
	cmp rax, [rsp + 32]
	jl .jump630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump630:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump631:
	cmp rax, [rsp + 40]
	jl .jump632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump632:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump633:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump634: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const253] ; 941
	push rax
	mov rax, [rel const254] ; 165
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump635
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump637
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump639
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump640
.jump639:
	mov rax, [rel const205] ; 712
	push rax
.jump640:
	jmp .jump638
.jump637:
	mov rax, [rel const255] ; 160
	push rax
.jump638:
	jmp .jump636
.jump635:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump636:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump634 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const45] ; False
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump641
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump642
.jump641:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump642:
	pop rax
	cmp rax, 0
	je .jump643
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump645
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump645:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump646:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump647
	mov rax, [rel const221] ; 24
	push rax
	jmp .jump648
.jump647:
	mov rax, [rel const256] ; 647
	push rax
.jump648:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump649:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const27] ; 454
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump650
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump650:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump651:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (454 % d) 
	jno .jump652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump652:
	imul rdi, [rsp + 0 + 8] ; multiply by (if a then 24 else 647) 
	jno .jump653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump653:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump654:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump655:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump656: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump656 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump656 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump656 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump656 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump644
.jump643:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const257] ; 978
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump657
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump657:
	; Computing bound for 'i'
	mov rax, [rel const258] ; 317
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump658:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump659
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump659:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const259] ; 221
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump660
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump660:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump661:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump662
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump662:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump663:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump664: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump664 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump664 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump664 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump664 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump665:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : d, h : d, i : d, j : 221] i) 
	jno .jump666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump666:
	imul rdi, [rsp + 0 + 8] ; multiply by (d - d) 
	jno .jump667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump667:
	imul rdi, [rsp + 0 + 16] ; multiply by 317 
	jno .jump668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump668:
	imul rdi, [rsp + 0 + 24] ; multiply by (- 978) 
	jno .jump669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump669:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump670: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump670 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump670 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump670 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump670 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump644:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump671
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump673
	mov rax, [rel const260] ; 270
	push rax
	jmp .jump674
.jump673:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump674:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump675:
	; Computing bound for 'i'
	mov rax, [rel const238] ; 123
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump676
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump676:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump677:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const261] ; 975
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump678
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump678:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump679: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump679 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump679 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump679 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump679 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump672
.jump671:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const262] ; 526
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump672:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump680
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump682
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump682:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump683:
	; Computing bound for 'g'
	mov rax, [rel const263] ; 116
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump684
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump684:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump685: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump685 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump685 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump685 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump681
.jump680:
	mov rax, [rel const84] ; 989
	push rax
.jump681:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const264] ; 972
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump686:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump687 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const265] ; 696
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump688
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump688:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump689:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump690:
	imul rdi, [rsp + 0 + 8] ; multiply by 696 
	jno .jump691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump691:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump692: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump692 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump692 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const80] ; 151
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const266] ; 21
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump693
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump693:
	cmp rax, [rsp + 16]
	jl .jump694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump694:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump695:
	cmp rax, [rsp + 24]
	jl .jump696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump696:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump697:
	cmp rax, [rsp + 32]
	jl .jump698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump698:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump699:
	cmp rax, [rsp + 40]
	jl .jump700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump700:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump701:
	cmp rax, [rsp + 48]
	jl .jump702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump702:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump703:
	cmp rax, [rsp + 56]
	jl .jump704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump704:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump705
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump707
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump707:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump708
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump710
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump710:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump711
	mov rax, [rel const267] ; 399
	push rax
	mov rax, [rel const268] ; 623
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump713
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const269] ; 205
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump714
.jump713:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump715
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump715:
	push rax
.jump714:
	jmp .jump712
.jump711:
	mov rax, [rel const270] ; 562
	push rax
	mov rax, [rel const31] ; 419
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump716
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump716:
	push rax
.jump712:
	jmp .jump709
.jump708:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump709:
	pop rax
	cmp rax, 0
	je .jump717
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump718
.jump717:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump718:
	jmp .jump706
.jump705:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump706:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump719
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump719:
	cmp rax, [rsp + 24]
	jl .jump720
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump720:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump721
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump721:
	cmp rax, [rsp + 32]
	jl .jump722
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump722:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump723
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump723:
	cmp rax, [rsp + 40]
	jl .jump724
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump724:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump478:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump725
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const271] ; 99
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump727
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump727:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump728: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump728 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump726
.jump725:
	mov rax, [rel const272] ; 737
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
.jump726:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump729:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (if f then (sum[g : 99] g) else (- (- 737)))) 
	jno .jump730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump730:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump731: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump732
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump732:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump733
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump734
.jump733:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump734:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump736
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump736:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump737:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump738:
	imul rdi, [rsp + 0 + 8] ; multiply by (- g) 
	jno .jump739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump739:
	imul rdi, [rsp + 0 + 16] ; multiply by (if a then d else d) 
	jno .jump740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump740:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump741:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump742: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump742 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump742 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump742 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump742 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const1] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump743
	mov rax, [rel const254] ; 165
	push rax
	jmp .jump744
.jump743:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump745:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump746
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump746:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump747: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump747 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump747 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump744:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump748
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump748:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump749
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump749:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump750:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump751
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump751:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump752:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump753
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump753:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump754: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump754 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump754 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump754 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump754 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump755
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump755:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const273] ; 273
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump756
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump756:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump757:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump758: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const274] ; 565
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump758 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump758 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump759:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump760: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump760 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump760 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump761:
	cmp rax, [rsp + 32]
	jl .jump762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump762:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump763:
	cmp rax, [rsp + 40]
	jl .jump764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump764:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump765:
	cmp rax, [rsp + 48]
	jl .jump766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump766:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump767:
	cmp rax, [rsp + 56]
	jl .jump768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump768:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump769
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const57] ; 380
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump771
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump771:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump772
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump772:
	cqo
	idiv r10
	push rax
	jmp .jump770
.jump769:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump773
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump773:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump774: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump774 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump770:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump731 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const275] ; 907
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump775
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump777
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump777:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump778:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump779: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump779 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump779 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump776
.jump775:
	mov rax, [rel const241] ; 909
	push rax
	pop rax
	neg rax
	push rax
.jump776:
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump780
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump782
	mov rax, [rel const276] ; 999
	push rax
	jmp .jump783
.jump782:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump783:
	jmp .jump781
.jump780:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump784
	mov rax, [rel const1] ; True
	push rax
	jmp .jump785
.jump784:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump785:
	pop rax
	cmp rax, 0
	je .jump786
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump788
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump789
.jump788:
	mov rax, [rel const45] ; False
	push rax
.jump789:
	jmp .jump787
.jump786:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump787:
	pop rax
	cmp rax, 0
	je .jump790
	mov rax, [rel const277] ; 109
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump791
.jump790:
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump792
	mov rax, [rel const278] ; 612
	push rax
	jmp .jump793
.jump792:
	mov rax, [rel const279] ; 711
	push rax
	pop rax
	neg rax
	push rax
.jump793:
.jump791:
.jump781:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump794:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump795
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump795:
	cmp rax, [rsp + 8]
	jl .jump796
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump796:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump797
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump797:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump798
	mov rax, [rel const41] ; 249
	push rax
	jmp .jump799
.jump798:
	mov rax, [rel const80] ; 151
	push rax
.jump799:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump800
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump800:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const280] ; 70
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump801
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump801:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump802: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const281] ; 796
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump802 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump803:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : (- 70)] 796) 
	jno .jump804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump804:
	imul rdi, [rsp + 0 + 8] ; multiply by (if f then 249 else 151) 
	jno .jump805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump805:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump806: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump806 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump806 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const282] ; 335
	push rax
	mov rax, [rel const283] ; 220
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump807:
	cmp rax, [rsp + 16]
	jl .jump808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump808:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump809:
	cmp rax, [rsp + 24]
	jl .jump810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump810:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump811
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const284] ; 269
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const285] ; 131
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump813
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump813:
	; Computing bound for 'h'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump814
	mov rax, [rel const286] ; 296
	push rax
	mov rax, [rel const287] ; 381
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump816
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump816:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump815
.jump814:
	mov rax, [rel const288] ; 134
	push rax
.jump815:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump817:
	; Computing bound for 'g'
	mov rax, [rel const289] ; 139
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump818
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump818:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump819: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump819 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump819 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump819 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump820
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
.jump820:
	push rax
	pop rax
	cmp rax, 0
	je .jump821
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const290] ; 770
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump823
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump823:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump822
.jump821:
	mov rax, [rel const291] ; 886
	push rax
.jump822:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump824:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump825
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump825:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump826: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump827
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump829
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump830
.jump829:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump830:
	pop rax
	neg rax
	push rax
	jmp .jump828
.jump827:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump828:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump826 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump826 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump831
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump833
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump833:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump834
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump834:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump835: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump835 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump832
.jump831:
	mov rax, [rel const292] ; 881
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const293] ; 36
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump832:
	mov rax, [rel const294] ; 948
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump836:
	cmp rax, [rsp + 8]
	jl .jump837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump837:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump838:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump839:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump840
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump840:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump841: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump842
	mov rax, [rel const295] ; 386
	push rax
	jmp .jump843
.jump842:
	mov rax, [rel const296] ; 268
	push rax
.jump843:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump841 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump841 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump844
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump844:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump845:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const297] ; 831
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump846:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump847: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const298] ; 533
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump847 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump848
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump848:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump849: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const299] ; 462
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump849 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump849 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump849 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump849 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump812
.jump811:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump850
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump851
.jump850:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump851:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump852
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump852:
	; Computing bound for 'i'
	mov rax, [rel const300] ; 750
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump853:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump854:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump855: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump855 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump856
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump856:
	; Computing bound for 'g'
	mov rax, [rel const272] ; 737
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump857:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 737 
	jno .jump858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump858:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[g : d] d) 
	jno .jump859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump859:
	imul rdi, [rsp + 0 + 16] ; multiply by 750 
	jno .jump860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump860:
	imul rdi, [rsp + 0 + 24] ; multiply by (if f then d else (- d)) 
	jno .jump861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump861:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump862: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump863:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump864
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump864:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump865:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump866:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump867:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump868:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump869: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump870
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump870:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump871
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump871:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump872: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const301] ; 566
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump872 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump869 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump869 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump869 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump862 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump862 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump862 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump862 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const302] ; 15
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump873
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump873:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump874:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump875: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump875 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump875 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump876:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump877: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump877 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump878:
	cmp rax, [rsp + 32]
	jl .jump879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump879:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump880:
	cmp rax, [rsp + 40]
	jl .jump881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump881:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump882:
	cmp rax, [rsp + 48]
	jl .jump883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump883:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump884:
	cmp rax, [rsp + 56]
	jl .jump885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump885:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump886
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const303] ; 440
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump888:
	; Computing bound for 'g'
	mov rax, [rel const304] ; 245
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump889
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump889:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 245 
	jno .jump890
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump890:
	imul rdi, [rsp + 0 + 8] ; multiply by 440 
	jno .jump891
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump891:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump892: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump892 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump892 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const6] ; 150
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump893
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump893:
	cmp rax, [rsp + 16]
	jl .jump894
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump894:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump895
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump895:
	cmp rax, [rsp + 24]
	jl .jump896
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump896:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump887
.jump886:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump897
	mov rax, [rel const305] ; 496
	push rax
	jmp .jump898
.jump897:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump899
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump900
.jump899:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump900:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump901
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump901:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump898:
.jump887:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump902
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const306] ; 12
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump904:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump905:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump906:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump907
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump907:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump908:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump909
	mov rax, [rel const307] ; 997
	push rax
	jmp .jump910
.jump909:
	mov rax, [rel const308] ; 127
	push rax
.jump910:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const309] ; 968
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump911
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump911:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump912: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump912 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump913:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump914
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump914:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump915: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const310] ; 378
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump915 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump915 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump915 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump915 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump903
.jump902:
	mov rax, [rel const311] ; 281
	push rax
	mov rax, [rel const312] ; 46
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump916:
	cqo
	idiv r10
	push rax
	mov rax, [rel const313] ; 488
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump917
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump918
.jump917:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const314] ; 189
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump919:
	cqo
	idiv r10
	push rax
.jump918:
.jump903:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const90] ; 173
	push rax
	mov rax, [rel const315] ; 694
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump920:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump921
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump921:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump922:
	; Computing bound for 'g'
	mov rax, [rel const316] ; 226
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump923
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump923:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (d * 226) 
	jno .jump924
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump924:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump925
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump925:
	imul rdi, [rsp + 0 + 16] ; multiply by (694 % 173) 
	jno .jump926
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump926:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump927: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump927 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump927 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump927 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const317] ; 878
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump928
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump928:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump929:
	; Computing bound for 'h'
	mov rax, [rel const318] ; 782
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump930
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump930:
	; Computing bound for 'g'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump931
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump932
.jump931:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump932:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump933:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump934: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const319] ; 618
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump934 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump934 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump934 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump934 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const320] ; 21.44
	push rax
	mov rax, [rel const321] ; 40.56
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump935
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump936
.jump935:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump936:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump937:
	cmp rax, [rsp + 24]
	jl .jump938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump938:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump939:
	cmp rax, [rsp + 32]
	jl .jump940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump940:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump941:
	cmp rax, [rsp + 40]
	jl .jump942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump942:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump943:
	cmp rax, [rsp + 24]
	jl .jump944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump944:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump945:
	cmp rax, [rsp + 32]
	jl .jump946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump946:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump947:
	cmp rax, [rsp + 40]
	jl .jump948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump948:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump812:
	mov rax, [rel const322] ; 812
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump949:
	cmp rax, [rsp + 8]
	jl .jump950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump950:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump951:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (a != (array[g : (sum[g : (- 70)] 796), h : (if f then 249 else 151)] (! (! true)))[(- 220), 335]) then [(- (sum[g : (sum[g : (- 831)] (- 533)), h : d, i : (sum[g : d, h : d] (if a then 386 else 268)), j : d] 462)), (if f then (array[g : d] d) else [36, d, 881])[948], (sum[g : (- d), h : (if ((! false) || f) then (770 % d) else 886)] (if (! (! a)) then (- (if a then g else g)) else d)), (sum[g : (- 139), h : (if false then (- (381 / 296)) else 134), i : (- ((d - 131) * (- 269)))] (- h))] else (array[g : 737, h : (sum[g : d] d), i : 750, j : (if f then d else (- d))] (array[k : i, l : j, m : d] (array[n : d] 566)))[(- (- d)), (- (sum[g : d] g)), d, ((sum[g : d, h : d] d) + (- (- 15)))][(- (array[g : (d * 226), h : d, i : (694 % 173)] d)[d, (if (40.56 >= 21.44) then d else (- d)), (sum[g : (if true then d else d), h : 782, i : d, j : 878] (- 618))]), (if (! f) then (sum[g : ((sum[g : 968] d) % (if a then 997 else 127)), h : (- (- d)), i : (d / (d % d)), j : 12] 378) else (if (488 != (46 / 281)) then (- d) else (189 / d))), (if false then ((array[g : 245, h : 440] g)[150, (- d)] - d) else (if false then 496 else (d % (if a then d else d))))])[812] 
	jno .jump952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump952:
imul rdi, [rsp + 0 + 8] ; multiply by (- (array[g : (- (if f then (sum[g : 99] g) else (- (- 737))))] (if (array[h : d, i : (- g), j : (if a then d else d), k : d] false)[(sum[h : (sum[h : g, i : 273] 565), i : (sum[h : d, i : g, j : g, k : d] j)] i), g, (g / (g % d)), (if (a != true) then 165 else (sum[h : d, i : d] i))] then (((d % g) + (380 * d)) / d) else (sum[h : d] h)))[(d / (if ((if false then (sum[g : d, h : d] d) else (- 909)) <= 907) then (if a then 999 else (- (d + d))) else (if (if (if f then true else f) then (if a then f else false) else (! f)) then (- (- 109)) else (if (a == false) then 612 else (- 711)))))]) 
	jno .jump953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump953:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump954: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const323] ; 522
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump955
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump955:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump956:
	; Computing bound for 'i'
	mov rax, [rel const324] ; 845
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump957:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 845 
	jno .jump958
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump958:
	imul rdi, [rsp + 0 + 8] ; multiply by (522 % d) 
	jno .jump959
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump959:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump960: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump961
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump961:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump962:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump963
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump963:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump964
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump964:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump965
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump965:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump966
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump966:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump967: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const325] ; 11.18
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump967 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump967 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump967 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump960 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump960 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const326] ; 511
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump968
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump968:
	cmp rax, [rsp + 16]
	jl .jump969
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump969:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump970
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump970:
	cmp rax, [rsp + 24]
	jl .jump971
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump971:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump972
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump973
.jump972:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump973:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump974
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump974:
	cmp rax, [rsp + 24]
	jl .jump975
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump975:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump976
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump976:
	cmp rax, [rsp + 32]
	jl .jump977
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump977:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump978
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump978:
	cmp rax, [rsp + 40]
	jl .jump979
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump979:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const327] ; 58.67
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump980
	mov rax, [rel const328] ; 21.91
	push rax
	mov rax, [rel const329] ; 58.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump980:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump981
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump981:
	push rax
	pop rax
	cmp rax, 0
	je .jump982
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump984:
	; Computing bound for 'j'
	mov rax, [rel const330] ; 590
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump985
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump985:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump986:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- g) 
	jno .jump987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump987:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 590) 
	jno .jump988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump988:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump989:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump990: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const331] ; 60.25
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump990 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump990 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump990 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump991
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump992
.jump991:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump992:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump993
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump993:
	cmp rax, [rsp + 24]
	jl .jump994
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump994:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump995
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump995:
	cmp rax, [rsp + 32]
	jl .jump996
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump996:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump997
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump997:
	cmp rax, [rsp + 40]
	jl .jump998
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump998:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump999:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1000
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1000:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1001:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1002: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1002 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1002 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1002 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1003:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1004:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1005: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const332] ; 70.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1005 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1005 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump983
.jump982:
	mov rax, [rel const333] ; 98.43
	push rax
.jump983:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1006
	mov rax, [rel const1] ; True
	push rax
	jmp .jump1007
.jump1006:
	mov rax, [rel const1] ; True
	push rax
.jump1007:
	pop rax
	cmp rax, 0
	je .jump1008
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1010
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump1010:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const232] ; 550
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump1009
.jump1008:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1011
	mov rax, [rel const334] ; 315
	push rax
	jmp .jump1012
.jump1011:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump1012:
.jump1009:
	mov rax, [rel const85] ; 298
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1013
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump1013:
	cqo
	idiv r10
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1014
	mov rax, [rel const335] ; 230
	push rax
	jmp .jump1015
.jump1014:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1016:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1017
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1017:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1018:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1019: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1019 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1019 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1019 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1015:
	mov rax, [rel const336] ; 276
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1020
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1022
	mov rax, [rel const337] ; 278
	push rax
	jmp .jump1023
.jump1022:
	mov rax, [rel const26] ; 431
	push rax
.jump1023:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1024
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump1024:
	push rax
	pop rax
	cmp rax, 0
	je .jump1025
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1027
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1027:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1028: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1028 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump1026
.jump1025:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1029
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump1030
.jump1029:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1030:
.jump1026:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1031
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1031:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const338] ; 960
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1032:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1033
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1033:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1034:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1035: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1035 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1035 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1035 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1036
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1036:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1037:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1038:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[i : d, j : h, k : (960 - h)] (- i)) 
	jno .jump1039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1039:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1040: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1041:
	; Computing bound for 'k'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1042
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump1043
.jump1042:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump1043:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1044
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1044:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1045: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1045 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1045 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1040 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1040 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1046
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1046:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1047:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1048:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1049:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1050: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1050 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1050 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1051:
	cmp rax, [rsp + 16]
	jl .jump1052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1052:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1053:
	cmp rax, [rsp + 24]
	jl .jump1054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1054:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1055:
	cmp rax, [rsp + 16]
	jl .jump1056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1056:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1057:
	cmp rax, [rsp + 24]
	jl .jump1058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1058:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1059:
	; Computing bound for 'j'
	mov rax, [rel const339] ; 169
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1060
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1060:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1061:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1062: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1063:
	; Computing bound for 'n'
	mov rax, [rel const340] ; 451
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1064
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1064:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1065:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1066: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const341] ; 41.58
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1066 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1066 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1066 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1062 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1062 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1062 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1062 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump1021
.jump1020:
	mov rax, [rel const342] ; 50.56
	push rax
	mov rax, [rel const343] ; 66.82
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1067
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1067:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1068:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1069
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1069:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1070
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1070:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1071
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1071:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump1072
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1072:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1073: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const344] ; 49.59
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1073 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1073 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1073 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1074
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1074:
	; Computing bound for 'j'
	mov rax, [rel const345] ; 827
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1075:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1076
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1076:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1077: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1077 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1077 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1077 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1078
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1078:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1079:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1080: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1080 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1080 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1081:
	cmp rax, [rsp + 24]
	jl .jump1082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1082:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1083:
	cmp rax, [rsp + 32]
	jl .jump1084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1084:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1085:
	cmp rax, [rsp + 40]
	jl .jump1086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1086:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1021:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump954 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump954 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 104 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 24
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 136 ; Local variables
	pop rbp
	ret

d:
_d:
	push rbp
	mov rbp, rsp
	sub rsp, 24
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1087
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const346] ; 604
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1089
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1089:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 604 
	jno .jump1090
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1090:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1091: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1092:
	; Computing bound for 'h'
	mov rax, [rel const347] ; 128
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1093
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1093:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1094:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1095: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const348] ; 172
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1095 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1096
	mov rax, [rel const349] ; 908
	push rax
	jmp .jump1097
.jump1096:
	call _d
	push rax
.jump1097:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1098
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1098:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1099: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const243] ; 738
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1099 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1100:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1101:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const350] ; 540
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1102:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1103: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const337] ; 278
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1103 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1104
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1104:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1105
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1105:
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1106:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1107: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1107 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1107 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1108:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1109
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1109:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1110: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1110 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1110 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1111
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1111:
	; Computing bound for 'h'
	mov rax, [rel const31] ; 419
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1112:
	; Computing bound for 'g'
	mov rax, [rel const351] ; 359
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1113
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1113:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1114
	mov rax, [rel const45] ; False
	push rax
	jmp .jump1115
.jump1114:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1115:
	pop rax
	cmp rax, 0
	je .jump1116
	mov rax, [rel const253] ; 941
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1117
.jump1116:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const352] ; 225
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1118
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1118:
	; Computing bound for 'g'
	mov rax, [rel const353] ; 283
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1119:
	; Computing bound for 'f'
	mov rax, [rel const236] ; 638
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1120
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1120:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1121: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1121 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1121 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1121 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1117:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1122:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1123: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1123 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1123 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1123 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1123 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1124:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1125
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1125:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1126: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1126 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1126 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1126 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1126 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1127
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1127:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : (- d()), g : (sum[f : (if (if c then false else c) then (- 941) else (sum[f : 638, g : 283, h : 225] h)), g : 359, h : (- (d() * 419)), i : (sum[f : (- d()), g : (sum[f : d(), g : e] f)] (- f))] i), h : (- (sum[f : 540] 278)), i : d()] g) 
	jno .jump1128
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1128:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[f : ((if c then 908 else d()) + (sum[f : d()] 172))] 738) 
	jno .jump1129
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1129:
	imul rdi, [rsp + 0 + 16] ; multiply by 128 
	jno .jump1130
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1130:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump1131
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1131:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1132: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1133
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1133:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1134:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1135
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1135:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1136
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1136:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1137
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1137:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump1138
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1138:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1139: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1140:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1141: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const354] ; 69.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1141 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1139 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1139 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1139 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1142:
	cmp rax, [rsp + 24]
	jl .jump1143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1143:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1144:
	cmp rax, [rsp + 32]
	jl .jump1145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1145:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1146:
	cmp rax, [rsp + 40]
	jl .jump1147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1147:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1148:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1149:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1150: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const355] ; 20.32
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1150 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1151
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1151:
	cmp rax, [rsp + 8]
	jl .jump1152
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1152:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1153
	mov rax, [rel const356] ; 70.21
	push rax
	mov rax, [rel const357] ; 43.27
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump1154
.jump1153:
	mov rax, [rel const358] ; 4.27
	push rax
.jump1154:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1155
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1157
	mov rax, [rel const359] ; 99.82
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump1158
.jump1157:
	mov rax, [rel const360] ; 34.79
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1158:
	jmp .jump1156
.jump1155:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1159:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1160: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const361] ; 7.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1160 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump1156:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1132 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1132 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1132 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1132 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1091 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump1088
.jump1087:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const302] ; 15
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1161
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1161:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 15 
	jno .jump1162
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1162:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1163: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1164:
	; Computing bound for 'h'
	mov rax, [rel const191] ; 669
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1165:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1166
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1166:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1167:
	; Computing bound for 'f'
	mov rax, [rel const135] ; 66
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1168
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1168:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 66 
	jno .jump1169
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1169:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump1170
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1170:
	imul rdi, [rsp + 0 + 16] ; multiply by (e % 669) 
	jno .jump1171
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1171:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump1172
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1172:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1173: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1174
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1174:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1175:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1176
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1176:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1177: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1178
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1178:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1179: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1179 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1180:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1181
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1181:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1182: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const362] ; 68.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1182 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1182 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1177 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1177 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1177 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	mov rax, [rel const363] ; 56.1
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1183
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1185
	mov rax, [rel const364] ; 65.87
	push rax
	jmp .jump1186
.jump1185:
	mov rax, [rel const365] ; 86.04
	push rax
.jump1186:
	jmp .jump1184
.jump1183:
	mov rax, [rel const366] ; 50.06
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1184:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1187
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1187:
	; Computing bound for 'j'
	mov rax, [rel const367] ; 508
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1188:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1189: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const368] ; 73.86
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1189 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1189 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const369] ; 0.05
	push rax
	mov rax, [rel const370] ; 85.47
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1190
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1191
.jump1190:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1192
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump1193
.jump1192:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump1193:
.jump1191:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1194:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1195
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1195:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1196
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1196:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1197:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1198
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1198:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1199:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump1200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1200:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1201:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1202:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump1203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1203:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1204: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const371] ; 809
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1204 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1204 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1204 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1204 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1205:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1206:
	cmp rax, [rsp + 32]
	jl .jump1207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1207:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1208:
	cmp rax, [rsp + 40]
	jl .jump1209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1209:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1210:
	cmp rax, [rsp + 48]
	jl .jump1211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1211:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1212:
	cmp rax, [rsp + 56]
	jl .jump1213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1213:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1214:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1215: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const372] ; 47.37
	push rax
	mov rax, [rel const373] ; 77.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1215 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1215 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1215 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1173 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1173 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1173 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1173 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1163 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1088:
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1216
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const259] ; 221
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1218:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1219:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const374] ; 931
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1220
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1222:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1223
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1223:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump1224
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1224:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1225
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1225:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1226: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const375] ; 452
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1226 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1226 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1221
.jump1220:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const376] ; 192
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1227:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1228
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1228:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1229
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1229:
	imul rdi, [rsp + 0 + 8] ; multiply by 192 
	jno .jump1230
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1230:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1231: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1231 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1231 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1221:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1232
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1232:
	cmp rax, [rsp + 16]
	jl .jump1233
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1233:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1234
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1234:
	cmp rax, [rsp + 24]
	jl .jump1235
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1235:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1236
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1236:
	; Computing bound for 'i'
	mov rax, [rel const253] ; 941
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1237:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const377] ; 307
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1238
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1239
.jump1238:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1239:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1240
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1240:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1241: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1241 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1241 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1241 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1241 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1242
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1242:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1243:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1244: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1244 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1244 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1245:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1246: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const378] ; 885
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1246 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1247
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1247:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1248:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump1249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1249:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1250: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1251
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1251:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1252
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1252:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1253:
	; Computing bound for 'j'
	mov rax, [rel const379] ; 841
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1254
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1254:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1255:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1256: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1256 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1256 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1256 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1256 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1257:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1258
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1258:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1259
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1259:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[i : g, j : 841, k : f, l : h] i) 
	jno .jump1260
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1260:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump1261
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1261:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1262: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1263:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1262 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1262 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1262 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1250 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const380] ; 900
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1264
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1264:
	cmp rax, [rsp + 8]
	jl .jump1265
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1265:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const381] ; 817
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const382] ; 360
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1266
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1267
.jump1266:
	mov rax, [rel const383] ; 8
	push rax
.jump1267:
	mov rax, [rel const249] ; 57
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1268
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1268:
	cmp rax, [rsp + 24]
	jl .jump1269
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1269:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1270
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1270:
	cmp rax, [rsp + 32]
	jl .jump1271
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1271:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1272
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1272:
	cmp rax, [rsp + 40]
	jl .jump1273
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1273:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1274
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1274:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1275:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1276
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1276:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1277:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1278
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1278:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1279
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1279:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1280
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1280:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump1281
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1281:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1282: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1282 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1282 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1282 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const384] ; 897
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const385] ; 470
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1283
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump1284
.jump1283:
	mov rax, [rel const386] ; 483
	push rax
.jump1284:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1285:
	cmp rax, [rsp + 24]
	jl .jump1286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1286:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1287:
	cmp rax, [rsp + 32]
	jl .jump1288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1288:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1289:
	cmp rax, [rsp + 40]
	jl .jump1290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1290:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const387] ; 867
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1291:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1292: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1292 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1293:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1294: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const388] ; 303
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1294 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1295
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1295:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1296:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1297: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const312] ; 46
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1297 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1297 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1297 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1297 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1298:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1299:
	; Computing bound for 'i'
	mov rax, [rel const389] ; 492
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1300
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1300:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1301
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1301:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1302:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1303:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1304:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1305: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1305 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1305 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1306:
	cmp rax, [rsp + 16]
	jl .jump1307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1307:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1308:
	cmp rax, [rsp + 24]
	jl .jump1309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1309:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1310:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (- (array[h : f, i : f] h)[f, f])) 
	jno .jump1311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1311:
	imul rdi, [rsp + 0 + 8] ; multiply by 492 
	jno .jump1312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1312:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (- f)) 
	jno .jump1313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1313:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1314: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1315
	mov rax, [rel const311] ; 281
	push rax
	jmp .jump1316
.jump1315:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1316:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1314 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1314 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1314 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1317:
	; Computing bound for 'i'
	mov rax, [rel const390] ; 677
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1318
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1318:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rel const198] ; 605
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1319:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1320: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1321:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1322
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1322:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1323
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1323:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1324:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1325
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1325:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1326
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1326:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump1327
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1327:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump1328
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1328:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1329: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1329 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1329 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1329 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1330
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1330:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1331:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1332
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1332:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1333: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1333 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1333 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1333 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1334:
	cmp rax, [rsp + 24]
	jl .jump1335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1335:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1336:
	cmp rax, [rsp + 32]
	jl .jump1337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1337:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1338:
	cmp rax, [rsp + 40]
	jl .jump1339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1339:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1340:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1341: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1342:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1343
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1343:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1344:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1345: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1345 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1345 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1345 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1341 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1341 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1320 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1320 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1320 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1346
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1346:
	cmp rax, [rsp + 24]
	jl .jump1347
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1347:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1348
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1348:
	cmp rax, [rsp + 32]
	jl .jump1349
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1349:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1350
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1350:
	cmp rax, [rsp + 40]
	jl .jump1351
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1351:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1352
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1352:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (array[h : (- (- (array[h : f, i : f] h)[f, f])), i : 492, j : (- (- f))] (d() + (if (g != i) then 281 else f)))[(- (sum[h : (- (- (605 - d()))), i : 677, j : d()] (sum[k : (array[k : i, l : j, m : g] i)[(sum[k : j, l : i, m : j] m), (- g), g], l : (- (h / h))] (sum[m : g, n : g, o : f] d())))), (- g), d()] 
	jno .jump1353
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1353:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[h : (- f), i : (sum[h : ((sum[h : (- 867)] f) - (- (array[h : f, i : g, j : g] i)[(if c then g else 483), (470 * g), (- 897)]))] 303), j : g, k : (array[h : (- f)] (array[i : g, j : (sum[i : g, j : 841, k : f, l : h] i), k : d()] (f / d())))[(- (- 900))][(- (- (57 + (if c then f else 8)))), 360, (f - 817)]] 46) 
	jno .jump1354
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1354:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[h : (sum[h : g, i : (sum[h : (if (307 != g) then f else g), i : 941, j : (if (931 != d()) then (array[h : d(), i : g] 452) else (array[h : g, i : 192] i))[f, (d() * d())], k : g] f)] f)] 885) 
	jno .jump1355
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1355:
	imul rdi, [rsp + 0 + 24] ; multiply by 221 
	jno .jump1356
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1356:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1357: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1358
	sub rsp, 24
	; Moving 24 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1359
.jump1358:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1360
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump1361
.jump1360:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump1361:
	pop rax
	cmp rax, 0
	je .jump1362
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1364:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1365
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1365:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1366:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1367: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1367 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1367 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1367 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump1363
.jump1362:
	mov rax, [rel const391] ; 183
	push rax
.jump1363:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1368
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1368:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1369:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- h) 
	jno .jump1370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1370:
imul rdi, [rsp + 0 + 8] ; multiply by (if (if false then (j <= d()) else (h != j)) then (sum[l : k, m : d(), n : f] j) else 183) 
	jno .jump1371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1371:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1372: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1373
	mov rax, [rel const392] ; 84.07
	push rax
	mov rax, [rel const393] ; 50.66
	push rax
	mov rax, [rel const394] ; 50.46
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const395] ; 40.23
	push rax
	mov rax, [rel const396] ; 67.8
	push rax
	jmp .jump1374
.jump1373:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const397] ; 937
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1375:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump1376: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const398] ; 81.05
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1376 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1377
	mov rax, [rel const399] ; 92.94
	push rax
	jmp .jump1378
.jump1377:
	mov rax, [rel const400] ; 4.66
	push rax
.jump1378:
	mov rax, [rel const401] ; 10.35
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const402] ; 39.24
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1374:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1372 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1372 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1359:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1379:
	; Computing bound for 'm'
	mov rax, [rel const403] ; 198
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1380
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1380:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1381:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1382: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1382 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1382 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1382 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1383:
	cmp rax, [rsp + 16]
	jl .jump1384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1384:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1385:
	cmp rax, [rsp + 24]
	jl .jump1386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1386:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1357 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1357 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1357 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1357 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1217
.jump1216:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1387
	mov rax, [rel const45] ; False
	push rax
	jmp .jump1388
.jump1387:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump1389
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump1389:
	push rax
	pop rax
	cmp rax, 0
	je .jump1390
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1392
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1392:
	; Computing bound for 'h'
	mov rax, [rel const404] ; 957
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1393:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1394: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const405] ; 1.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1394 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1394 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const406] ; 93.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const407] ; 27.9
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump1391
.jump1390:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1395
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1397
	mov rax, [rel const408] ; 20.3
	push rax
	mov rax, [rel const409] ; 4.01
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump1398
.jump1397:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump1398:
	pop rax
	cmp rax, 0
	je .jump1399
	mov rax, [rel const410] ; 85.52
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const411] ; 8.01
	push rax
	mov rax, [rel const412] ; 46.53
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump1400
.jump1399:
	mov rax, [rel const1] ; True
	push rax
.jump1400:
	jmp .jump1396
.jump1395:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1401:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1402
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1402:
	; Computing bound for 'i'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1403:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1404
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1404:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1405
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1405:
	imul rdi, [rsp + 0 + 8] ; multiply by (- d()) 
	jno .jump1406
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1406:
	imul rdi, [rsp + 0 + 16] ; multiply by (f + d()) 
	jno .jump1407
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1407:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump1408
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1408:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1409: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1409 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1409 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1409 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1409 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1410
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1410:
	cmp rax, [rsp + 32]
	jl .jump1411
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1411:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1412
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1412:
	cmp rax, [rsp + 40]
	jl .jump1413
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1413:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1414
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1414:
	cmp rax, [rsp + 48]
	jl .jump1415
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1415:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1416
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1416:
	cmp rax, [rsp + 56]
	jl .jump1417
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1417:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1396:
.jump1391:
.jump1388:
	pop rax
	cmp rax, 0
	je .jump1418
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1420
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1422
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1424:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1425
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1425:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1426:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1427: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1427 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1427 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1427 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const413] ; 730
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump1423
.jump1422:
	mov rax, [rel const45] ; False
	push rax
.jump1423:
	pop rax
	cmp rax, 0
	jne .jump1428
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1429:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const414] ; 816
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump1428:
	push rax
	pop rax
	cmp rax, 0
	je .jump1430
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1432
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1432:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1433:
	; Computing bound for 'i'
	mov rax, [rel const415] ; 609
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1434
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1434:
	; Computing bound for 'h'
	mov rax, [rel const416] ; 697
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1435:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 697 
	jno .jump1436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1436:
	imul rdi, [rsp + 0 + 8] ; multiply by 609 
	jno .jump1437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1437:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump1438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1438:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump1439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1439:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1440: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1440 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1440 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1440 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1440 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const417] ; 306
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1441
	call _d
	push rax
	jmp .jump1442
.jump1441:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1442:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const418] ; 223
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1443:
	cmp rax, [rsp + 32]
	jl .jump1444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1444:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1445:
	cmp rax, [rsp + 40]
	jl .jump1446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1446:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1447:
	cmp rax, [rsp + 48]
	jl .jump1448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1448:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1449:
	cmp rax, [rsp + 56]
	jl .jump1450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1450:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1451:
	; Computing bound for 'j'
	mov rax, [rel const419] ; 518
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const420] ; 152
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1452
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1452:
	cmp rax, [rsp + 8]
	jl .jump1453
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1453:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1454
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1454:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1455:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const421] ; 654
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1456
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump1457
.jump1456:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1458
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump1459
.jump1458:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump1459:
.jump1457:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1460
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1460:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (654 != g) then g else (if c then d() else d())) 
	jno .jump1461
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1461:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1462
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1462:
	imul rdi, [rsp + 0 + 16] ; multiply by [152, g, f, 518][f] 
	jno .jump1463
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1463:
imul rdi, [rsp + 0 + 24] ; multiply by (array[h : 697, i : 609, j : d(), k : d()] j)[(223 - g), g, (if a then d() else g), 306] 
	jno .jump1464
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1464:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1465: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1466
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1466:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1467:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1468
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1468:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1469
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1469:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1470:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1471: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const422] ; 706
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1471 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1471 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1472:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : h, m : h] 706) 
	jno .jump1473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1473:
	imul rdi, [rsp + 0 + 8] ; multiply by (- j) 
	jno .jump1474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1474:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1475:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump1476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1476:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1477: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1478
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1478:
	cmp rax, [rsp + 16]
	jl .jump1479
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1479:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1480
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1480:
	cmp rax, [rsp + 24]
	jl .jump1481
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1481:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1477 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1477 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1477 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1477 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1465 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1465 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1465 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1465 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const69] ; 428
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1482
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1484:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1485: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const338] ; 960
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1485 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1483
.jump1482:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1486:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1487
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1487:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1488:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1489
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1489:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1490
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1490:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump1491
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1491:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump1492
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1492:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump1493
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1493:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1494: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1494 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1494 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1494 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1494 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1495
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1495:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1496: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1496 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const337] ; 278
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1497
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump1498
.jump1497:
	mov rax, [rel const423] ; 457
	push rax
.jump1498:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1499
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1499:
	cmp rax, [rsp + 32]
	jl .jump1500
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1500:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1501
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1501:
	cmp rax, [rsp + 40]
	jl .jump1502
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1502:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1503
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1503:
	cmp rax, [rsp + 48]
	jl .jump1504
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1504:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1505
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1505:
	cmp rax, [rsp + 56]
	jl .jump1506
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1506:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1483:
	mov rax, [rel const424] ; 641
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1507
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump1507:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const88] ; 793
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1508
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1508:
	cmp rax, [rsp + 32]
	jl .jump1509
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1509:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1510
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1510:
	cmp rax, [rsp + 40]
	jl .jump1511
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1511:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1512
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1512:
	cmp rax, [rsp + 48]
	jl .jump1513
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1513:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1514
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1514:
	cmp rax, [rsp + 56]
	jl .jump1515
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1515:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1431
.jump1430:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1516:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1517
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1517:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1518:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- g) 
	jno .jump1519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1519:
	imul rdi, [rsp + 0 + 8] ; multiply by (g % d()) 
	jno .jump1520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1520:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1521: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1521 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1521 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1522
	mov rax, [rel const425] ; 935
	push rax
	jmp .jump1523
.jump1522:
	mov rax, [rel const378] ; 885
	push rax
.jump1523:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1524:
	cmp rax, [rsp + 16]
	jl .jump1525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1525:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1526:
	cmp rax, [rsp + 24]
	jl .jump1527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1527:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1528:
	; Computing bound for 'j'
	mov rax, [rel const426] ; 62
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1529
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1529:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1530
	mov rax, [rel const427] ; 410
	push rax
	jmp .jump1531
.jump1530:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1531:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1532
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump1532:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1533:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1534
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1534:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1535: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1535 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1536:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1537: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1537 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1538
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1538:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : (sum[h : (- g)] g)] f) 
	jno .jump1539
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1539:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (g % (if c then 410 else g))) 
	jno .jump1540
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1540:
	imul rdi, [rsp + 0 + 16] ; multiply by 62 
	jno .jump1541
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1541:
imul rdi, [rsp + 0 + 24] ; multiply by (array[h : (- g), i : (g % d())] (- g))[(if a then 935 else 885), g] 
	jno .jump1542
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1542:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1543: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const428] ; 91.08
	push rax
	mov rax, [rel const429] ; 11.77
	push rax
	mov rax, [rel const430] ; 57.13
	push rax
	mov rax, [rel const431] ; 53.86
	push rax
	mov rax, [rel const432] ; 57.4
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const433] ; 94.99
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const434] ; 74.94
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1543 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1543 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1543 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1543 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1431:
	jmp .jump1421
.jump1420:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1544:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1545
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1545:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump1546
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1546:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1547
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1547:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1548: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1549
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1549:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1550
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1550:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1551:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1552: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1552 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1552 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1553:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1554
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1554:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1555:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1556:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump1557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1557:
imul rdi, [rsp + 0 + 16] ; multiply by (- (sum[j : d(), k : g] h)) 
	jno .jump1558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1558:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump1559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1559:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1560: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const435] ; 86.41
	push rax
	mov rax, [rel const436] ; 40.09
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	mov rax, [rel const437] ; 60.96
	push rax
	mov rax, [rel const438] ; 94.26
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const439] ; 27.86
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1560 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1560 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1560 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1560 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1548 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1548 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const88] ; 793
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1561:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1562
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1562:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1563: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1563 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1563 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1564
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1564:
	; Computing bound for 'j'
	mov rax, [rel const440] ; 338
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1565:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1566:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1567
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1567:
	; Computing bound for 'h'
	mov rax, [rel const441] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1568:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1569: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1569 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1569 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1569 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1570
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1570:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1571:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1572: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1572 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1572 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1572 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1572 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1573:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1574:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1575
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1575:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1576:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1577: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1577 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1577 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1577 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1578
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1578:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const417] ; 306
	push rax
	mov rax, [rel const442] ; 87
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1579
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1579:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1580:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1581:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1582: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1582 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1583:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1584:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1585: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1585 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1585 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1585 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1585 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1586:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1587: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1587 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1587 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1587 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1588
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1588:
	cmp rax, [rsp + 16]
	jl .jump1589
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1589:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1590
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1590:
	cmp rax, [rsp + 24]
	jl .jump1591
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1591:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1421:
	jmp .jump1419
.jump1418:
	mov rax, [rel const45] ; False
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1592
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1592:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1593
	mov rax, [rel const4] ; 798
	push rax
	jmp .jump1594
.jump1593:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1594:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1595:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if c then 798 else g) 
	jno .jump1596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1596:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f) 
	jno .jump1597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1597:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1598: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1598 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1598 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1599:
	cmp rax, [rsp + 16]
	jl .jump1600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1600:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1601:
	cmp rax, [rsp + 24]
	jl .jump1602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1602:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1603
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1605:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump1606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1606:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1607: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1608:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1609
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1609:
	; Computing bound for 'i'
	mov rax, [rel const121] ; 871
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1610:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 871 
	jno .jump1611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1611:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1612:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1613:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1614: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1614 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1614 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1614 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1615
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1615:
	cmp rax, [rsp + 24]
	jl .jump1616
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1616:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1617
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1617:
	cmp rax, [rsp + 32]
	jl .jump1618
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1618:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1619
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1619:
	cmp rax, [rsp + 40]
	jl .jump1620
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1620:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1621
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1621:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const443] ; 331
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1622
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1622:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 331 
	jno .jump1623
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1623:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1624: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1624 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1625:
	cmp rax, [rsp + 8]
	jl .jump1626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1626:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1627:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1628
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1628:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1629:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1630:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1631:
imul rdi, [rsp + 0 + 16] ; multiply by (array[i : 331] d())[(- d())] 
	jno .jump1632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1632:
imul rdi, [rsp + 0 + 24] ; multiply by (array[i : 871, j : f, k : h] i)[g, f, (- f)] 
	jno .jump1633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1633:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1634: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1635
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1635:
	cmp rax, [rsp + 16]
	jl .jump1636
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1636:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1637
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1637:
	cmp rax, [rsp + 24]
	jl .jump1638
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1638:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1634 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1634 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1634 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1634 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1607 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1639:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1640:
	; Computing bound for 'h'
	mov rax, [rel const92] ; 923
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1641
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1641:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1642: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1642 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1642 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1643
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1643:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : 923, i : d()] f) 
	jno .jump1644
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1644:
	imul rdi, [rsp + 0 + 8] ; multiply by (- d()) 
	jno .jump1645
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1645:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1646: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1647
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1647:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1648:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1649:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1650:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1651 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1651 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1646 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1646 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const444] ; 958
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1652
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1652:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1653: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const4] ; 798
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1653 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const445] ; 119
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1654
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1654:
	cmp rax, [rsp + 16]
	jl .jump1655
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1655:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1656
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1656:
	cmp rax, [rsp + 24]
	jl .jump1657
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1657:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1658:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1659
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1660
.jump1659:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1660:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1661
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1661:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1662:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1663
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1663:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1664: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1664 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1664 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1664 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1664 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1665
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1665:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const446] ; 820
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1666
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1666:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1667:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1668: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1668 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1668 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1669:
	; Computing bound for 'i'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump1670
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump1670:
	push rax
	pop rax
	cmp rax, 0
	je .jump1671
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1672
.jump1671:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const447] ; 687
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump1672:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1673
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1673:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1674:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1675: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1675 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1675 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1675 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1675 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1676
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1676:
	cmp rax, [rsp + 16]
	jl .jump1677
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1677:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1678
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1678:
	cmp rax, [rsp + 24]
	jl .jump1679
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1679:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1680
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1680:
	cmp rax, [rsp + 8]
	jl .jump1681
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1681:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1604
.jump1603:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1682:
	; Computing bound for 'j'
	mov rax, [rel const448] ; 757
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1683
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1683:
	; Computing bound for 'i'
	mov rax, [rel const449] ; 917
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1684:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1685
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1685:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1686: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1686 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1686 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1686 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1686 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1687
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1687:
	; Computing bound for 'i'
	mov rax, [rel const177] ; 96
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1688:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1689
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1689:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d()) 
	jno .jump1690
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1690:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 96) 
	jno .jump1691
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1691:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[h : g, i : 917, j : 757, k : g] h) 
	jno .jump1692
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1692:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1693: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1694
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump1695
.jump1694:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1695:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1693 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1693 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1693 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const450] ; 986
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1696:
	cmp rax, [rsp + 24]
	jl .jump1697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1697:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1698:
	cmp rax, [rsp + 32]
	jl .jump1699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1699:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1700:
	cmp rax, [rsp + 40]
	jl .jump1701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1701:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1702
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1703
.jump1702:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1704
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1704:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1705:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1706
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1706:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1707: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1707 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1707 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1707 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1708:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1709
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1709:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1710:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1711: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1711 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1711 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1711 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1712
	mov rax, [rel const12] ; 876
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const451] ; 103
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1714
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump1714:
	cqo
	idiv r10
	push rax
	jmp .jump1713
.jump1712:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1713:
.jump1703:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1715:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1716
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1718
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1718:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1719:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1720: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const452] ; 702
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1720 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1720 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1721:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1722
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1722:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1723:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1724
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1724:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1725: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1725 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1725 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1725 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1725 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const453] ; 122
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1726
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1726:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1727: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1727 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1728:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump1717
.jump1716:
	mov rax, [rel const454] ; 843
	push rax
.jump1717:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1729:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1730:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1731
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1733:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1734
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1735
.jump1734:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1735:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1736
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1736:
	; Computing bound for 'i'
	mov rax, [rel const88] ; 793
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1737:
	; Computing bound for 'h'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1738
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump1739
.jump1738:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1739:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1740
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1740:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then d() else f) 
	jno .jump1741
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1741:
	imul rdi, [rsp + 0 + 8] ; multiply by 793 
	jno .jump1742
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1742:
	imul rdi, [rsp + 0 + 16] ; multiply by (if c then f else g) 
	jno .jump1743
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1743:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump1744
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1744:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1745: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1745 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1745 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1745 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1745 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1732
.jump1731:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const455] ; 334
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1746
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1746:
	; Computing bound for 'h'
	mov rax, [rel const456] ; 242
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1747:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1748: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const205] ; 712
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1748 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1748 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1749:
	; Computing bound for 'j'
	mov rax, [rel const457] ; 603
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1750
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1750:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1751:
	; Computing bound for 'h'
	mov rax, [rel const458] ; 884
	push rax
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1752
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1752:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() + 884) 
	jno .jump1753
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1753:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1754
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1754:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 603) 
	jno .jump1755
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1755:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[h : 242, i : 334] 712) 
	jno .jump1756
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1756:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1757: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1757 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1757 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1757 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1757 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1732:
	mov rax, [rel const459] ; 25
	push rax
	mov rax, [rel const460] ; 704
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1758:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1759
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1759:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1760: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const461] ; 265
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1761:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1762: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1762 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1760 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1763
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1763:
	cmp rax, [rsp + 32]
	jl .jump1764
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1764:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1765
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1765:
	cmp rax, [rsp + 40]
	jl .jump1766
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1766:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1767
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1767:
	cmp rax, [rsp + 48]
	jl .jump1768
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1768:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1769
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1769:
	cmp rax, [rsp + 56]
	jl .jump1770
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1770:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1771
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1771:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if a then (array[h : (if false then d() else f), i : 793, j : (if c then f else g), k : f] i) else (array[h : (d() + 884), i : f, j : (- 603), k : (sum[h : 242, i : 334] 712)] g))[d(), (sum[h : f] (sum[i : (- 265)] (- i))), (- (d() / (- 704))), 25] 
	jno .jump1772
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1772:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1773
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1773:
imul rdi, [rsp + 0 + 16] ; multiply by (if (g > (- f)) then ((sum[h : 122] d()) % (sum[h : g, i : g, j : g, k : (sum[h : g, i : d()] 702)] (- k))) else 843) 
	jno .jump1774
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1774:
imul rdi, [rsp + 0 + 24] ; multiply by (if (array[h : (- d()), i : (- 96), j : (sum[h : g, i : 917, j : 757, k : g] h)] (if a then a else c))[(- 986), f, g] then f else (if ((sum[h : f, i : g, j : f] i) > (sum[h : d(), i : g, j : g] g)) then (103 / (- 876)) else f)) 
	jno .jump1775
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1775:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1776: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1777
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1777:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1778:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1779: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1780
	mov rax, [rel const462] ; 71.97
	push rax
	jmp .jump1781
.jump1780:
	mov rax, [rel const463] ; 94.45
	push rax
.jump1781:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1779 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1779 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1782
	mov rax, [rel const464] ; 1000
	push rax
	jmp .jump1783
.jump1782:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump1783:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1784:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1785
	mov rax, [rel const465] ; 936
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1786
.jump1785:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1787
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump1788
.jump1787:
	mov rax, [rel const466] ; 319
	push rax
.jump1788:
.jump1786:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1789
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1789:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1790:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1791:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1792
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1792:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1793:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1794: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1794 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1794 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1794 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1795
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1795:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1796: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1797
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1797:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1798:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1799: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const467] ; 75.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1799 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1799 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1796 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1796 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1796 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1796 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1800
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1800:
	push rax
	pop rax
	cmp rax, 0
	je .jump1801
	mov rax, [rel const468] ; 81.03
	push rax
	mov rax, [rel const469] ; 72.08
	push rax
	mov rax, [rel const470] ; 17.28
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1803:
	cmp rax, [rsp + 8]
	jl .jump1804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1804:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1802
.jump1801:
	mov rax, [rel const471] ; 29.53
	push rax
.jump1802:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1805
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1807:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1808
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1808:
	; Computing bound for 'm'
	mov rax, [rel const472] ; 78
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1809:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1810
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1810:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1811: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const473] ; 38.63
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1811 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1811 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1811 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1811 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump1806
.jump1805:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1812:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1813
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1813:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1814:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1815
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1815:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1816: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const474] ; 86.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1816 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1816 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1816 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1816 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump1806:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1817
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1817:
	; Computing bound for 'n'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1818
	call _d
	push rax
	jmp .jump1819
.jump1818:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump1819:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1820:
	; Computing bound for 'm'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1821
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump1822
.jump1821:
	mov rax, [rel const475] ; 174
	push rax
.jump1822:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1823
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1823:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1824:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1825: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const476] ; 52.33
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1825 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1825 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1825 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1825 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1776 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1776 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1776 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1776 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1604:
.jump1419:
.jump1217:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1826
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1827
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump1827:
	push rax
	pop rax
	cmp rax, 0
	je .jump1828
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1830
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1830:
	push rax
	pop rax
	cmp rax, 0
	je .jump1831
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1831:
	push rax
	jmp .jump1829
.jump1828:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1829:
	pop rax
	cmp rax, 0
	je .jump1832
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1834
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1834:
	; Computing bound for 'm'
	mov rax, [rel const316] ; 226
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1835:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 226 
	jno .jump1836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1836:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump1837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1837:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1838: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const477] ; 15.17
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1838 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1838 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1839:
	cmp rax, [rsp + 16]
	jl .jump1840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1840:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1841:
	cmp rax, [rsp + 24]
	jl .jump1842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1842:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1843:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1844: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const478] ; 57.23
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1844 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump1833
.jump1832:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1845
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump1846
.jump1845:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1847
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1847:
	push rax
.jump1846:
	pop rax
	xor rax, 1
	push rax
.jump1833:
	pop rax
.jump1826:
	push rax
	pop rax
	cmp rax, 0
	je .jump1848
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1850
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1850:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1851
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump1851:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1852:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1853: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const479] ; 56.02
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const480] ; 88.36
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1853 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1853 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	mov rax, [rel const481] ; 43.64
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1854
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1854:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1855:
	; Computing bound for 'n'
	mov rax, [rel const482] ; 197
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1856
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1856:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1857:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1858: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1858 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1858 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1858 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1858 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1859:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1860
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1860:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1861:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1862: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const483] ; 37.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1862 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1862 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1862 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const484] ; 93.92
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump1849
.jump1848:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1863
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1865
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1865:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1866
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1866:
	; Computing bound for 'm'
	mov rax, [rel const485] ; 110
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1867:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 110 
	jno .jump1868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1868:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump1869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1869:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1870: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1870 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1870 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1871:
	cmp rax, [rsp + 16]
	jl .jump1872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1872:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1873:
	cmp rax, [rsp + 24]
	jl .jump1874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1874:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1875:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1876
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1876:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- l) 
	jno .jump1877
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1877:
imul rdi, [rsp + 0 + 8] ; multiply by (array[m : 110, n : d()] k)[k, l] 
	jno .jump1878
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1878:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump1879
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1879:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1880: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const486] ; 7.37
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1880 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1880 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1880 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1881:
	cmp rax, [rsp + 24]
	jl .jump1882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1882:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1883:
	cmp rax, [rsp + 32]
	jl .jump1884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1884:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1885:
	cmp rax, [rsp + 40]
	jl .jump1886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1886:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1864
.jump1863:
	mov rax, [rel const487] ; 3.86
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1887
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1889:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1890: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const488] ; 77.75
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1890 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump1888
.jump1887:
	mov rax, [rel const489] ; 11.61
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1888:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1891
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1893
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1893:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1894:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1895: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const490] ; 83.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1895 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1895 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump1892
.jump1891:
	mov rax, [rel const491] ; 24.08
	push rax
.jump1892:
	mov rax, [rel const436] ; 40.09
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1896
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1896:
	; Computing bound for 'n'
	mov rax, [rel const492] ; 86
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1897:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1898
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1898:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1899: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const493] ; 71.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1899 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1899 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1899 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const494] ; 29.33
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump1864:
.jump1849:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1900:
	cmp rax, [rsp + 8]
	jl .jump1901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1901:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const495] ; 41.37
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1902
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1902:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1903:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1904
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1904:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1905:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1906: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1907:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1908
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1908:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1909:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1910
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1910:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump1911: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1912
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1914
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1914:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1915:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1916
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1916:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1917:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump1918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1918:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump1919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1919:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump1920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1920:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump1921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1921:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump1922: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const496] ; 45.45
	push rax
	mov rax, [rel const497] ; 75.31
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1922 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1922 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1922 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1922 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1913
.jump1912:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1923
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1923:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1924:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump1925
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1925:
	push rax
	pop rax
	cmp rax, 0
	je .jump1926
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	jmp .jump1927
.jump1926:
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
.jump1927:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1928
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1928:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1929:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump1930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1930:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (c || c) then q else q) 
	jno .jump1931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1931:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump1932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1932:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump1933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1933:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump1934: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const498] ; 19.93
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1934 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1934 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1934 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1934 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1913:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1935
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump1936
.jump1935:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1936:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1937:
	cmp rax, [rsp + 32]
	jl .jump1938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1938:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1939:
	cmp rax, [rsp + 40]
	jl .jump1940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1940:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1941:
	cmp rax, [rsp + 48]
	jl .jump1942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1942:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1943:
	cmp rax, [rsp + 56]
	jl .jump1944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1944:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1911 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1911 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1911 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1911 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1906 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1906 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1906 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1906 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1945
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1947:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1948
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1948:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1949:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1950
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1950:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1951
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1951:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump1952
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1952:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump1953
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1953:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump1954
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1954:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1955: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const499] ; 93.52
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1955 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1955 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1955 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1955 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1946
.jump1945:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1956:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1957:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1958
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1958:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1959:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1960
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1960:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1961:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1962: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1962 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1962 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1962 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1962 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1963:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1964:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1965
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1965:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1966: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1966 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1966 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1967
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1967:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[m : d(), n : j] g) 
	jno .jump1968
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1968:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[m : i, n : k, o : f, p : j] i) 
	jno .jump1969
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1969:
	imul rdi, [rsp + 0 + 16] ; multiply by (- k) 
	jno .jump1970
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1970:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump1971
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump1971:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1972: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1973:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump1974: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const500] ; 64.4
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1974 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1972 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1972 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1972 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1972 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1946:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1975
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump1976
.jump1975:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1976:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1977
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1977:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1978:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1979
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1979:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1980:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1981:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1982:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump1983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1983:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump1984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1984:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1985: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1985 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1985 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1985 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1985 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1986:
	cmp rax, [rsp + 32]
	jl .jump1987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1987:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1988:
	cmp rax, [rsp + 40]
	jl .jump1989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1989:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1990:
	cmp rax, [rsp + 48]
	jl .jump1991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1991:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1992:
	cmp rax, [rsp + 56]
	jl .jump1993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1993:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1994
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1994:
	cmp rax, [rsp + 32]
	jl .jump1995
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1995:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1996
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1996:
	cmp rax, [rsp + 40]
	jl .jump1997
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1997:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1998
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump1998:
	cmp rax, [rsp + 48]
	jl .jump1999
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump1999:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2000
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2000:
	cmp rax, [rsp + 56]
	jl .jump2001
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2001:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 40
	; Moving 40 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 64 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2002:
	cmp rax, [rsp + 32]
	jl .jump2003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2003:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2004:
	cmp rax, [rsp + 40]
	jl .jump2005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2005:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2006:
	cmp rax, [rsp + 48]
	jl .jump2007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2007:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2008:
	cmp rax, [rsp + 56]
	jl .jump2009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2009:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const501] ; 267
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2010
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump2010:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2011
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2013
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump2014
.jump2013:
	mov rax, [rel const45] ; False
	push rax
.jump2014:
	pop rax
	cmp rax, 0
	je .jump2015
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2017:
	; Computing bound for 'o'
	mov rax, [rel const502] ; 417
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2018
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2018:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2019:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2020: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const503] ; 43.61
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2020 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2020 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2020 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2016
.jump2015:
	mov rax, [rel const504] ; 98.59
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2016:
	mov rax, [rel const505] ; 44.73
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2012
.jump2011:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2021
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2023
	mov rax, [rel const45] ; False
	push rax
	jmp .jump2024
.jump2023:
	mov rax, [rel const45] ; False
	push rax
.jump2024:
	jmp .jump2022
.jump2021:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
.jump2022:
	pop rax
	cmp rax, 0
	je .jump2025
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump2026
.jump2025:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump2026:
.jump2012:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2027
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2028
.jump2027:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump2028:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2029
	lea rdi, [rel const506] ; 'n'
	call _fail_assertion
.jump2029:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump2030
	lea rdi, [rel const506] ; 'n'
	call _fail_assertion
.jump2030:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2031
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2033
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2035
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2035:
	cmp rax, [rsp + 8]
	jl .jump2036
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2036:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2037
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2037:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2038:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump2039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2039:
	imul rdi, [rsp + 0 + 8] ; multiply by [f][j] 
	jno .jump2040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2040:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2041: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2042:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2043
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2043:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2044
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2044:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2045: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2045 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2046:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[p : l] l) 
	jno .jump2047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2047:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2048:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump2049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2049:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2050: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2050 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2050 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2050 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2041 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2041 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2051:
	cmp rax, [rsp + 8]
	jl .jump2052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2052:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2034
.jump2033:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const507] ; 355
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2053
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2053:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2054:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump2055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2055:
	imul rdi, [rsp + 0 + 8] ; multiply by 355 
	jno .jump2056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2056:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2057: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const508] ; 35.25
	push rax
	mov rax, [rel const509] ; 51.69
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const510] ; 24.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2058
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2060:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2061
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2061:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2062
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2062:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2063
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2063:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2064: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2065
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2065:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2066:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2067
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2067:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2068
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2068:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2069
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2069:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2070
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2070:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2071: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2071 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2071 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2071 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2064 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2064 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2059
.jump2058:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2072:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2073
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2073:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2074
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2074:
	imul rdi, [rsp + 0 + 8] ; multiply by (- l) 
	jno .jump2075
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2075:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2076: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2077
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2077:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2078:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2079
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2079:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump2080
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2080:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2081
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2081:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2082
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2082:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2083: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2083 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2083 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2083 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2076 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2076 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2059:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2084
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2084:
	cmp rax, [rsp + 16]
	jl .jump2085
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2085:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2086
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2086:
	cmp rax, [rsp + 24]
	jl .jump2087
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2087:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2057 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2057 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2034:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const511] ; 320
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2088
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2088:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 320 
	jno .jump2089
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2089:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2090: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2091
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2092
.jump2091:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2093:
	cqo
	idiv r10
	push rax
.jump2092:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2090 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2094:
	cmp rax, [rsp + 8]
	jl .jump2095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2095:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2096:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2097
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2097:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2098: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2098 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2098 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2099:
	cmp rax, [rsp + 16]
	jl .jump2100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2100:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2101:
	cmp rax, [rsp + 24]
	jl .jump2102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2102:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2032
.jump2031:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2103
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2105
	mov rax, [rel const1] ; True
	push rax
	jmp .jump2106
.jump2105:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump2106:
	pop rax
	cmp rax, 0
	je .jump2107
	mov rax, [rel const512] ; 57.82
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2108
.jump2107:
	mov rax, [rel const513] ; 52.11
	push rax
	mov rax, [rel const514] ; 67.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2109
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2111
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2111:
	; Computing bound for 'p'
	mov rax, [rel const387] ; 867
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2112:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2113
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2113:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2114:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2115: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const515] ; 54.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2115 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2115 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2115 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2115 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump2110
.jump2109:
	mov rax, [rel const516] ; 90.8
	push rax
.jump2110:
.jump2108:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2116
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2118:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2119
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2119:
	; Computing bound for 'o'
	mov rax, [rel const441] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2120:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2121:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2122
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2122:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2123:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2124: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2124 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2124 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2124 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2125
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2125:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2126: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2126 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2126 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2126 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2126 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump2117
.jump2116:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2127
	mov rax, [rel const517] ; 60.34
	push rax
	jmp .jump2128
.jump2127:
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump2128:
.jump2117:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2129
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const518] ; 5.88
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2131
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2133
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2133:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2134:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump2135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2135:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- j)) 
	jno .jump2136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2136:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2137: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2138:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2139
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2139:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2140:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2141:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2142:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2143:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2144: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2145
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump2146
.jump2145:
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump2146:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2144 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2144 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2144 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2137 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2137 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2132
.jump2131:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2147
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2148
.jump2147:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2148:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2149
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2149:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2150
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2150:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2151:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2152
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2152:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2153: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2153 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2153 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2153 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2154:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[n : i, o : k, p : j] p) 
	jno .jump2155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2155:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! c) then d() else f) 
	jno .jump2156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2156:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2157: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2158
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2160:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2161
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2161:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2162:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2163:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2164:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump2165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2165:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2166: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2166 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2166 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2166 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2159
.jump2158:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2167:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2168
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2168:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2169:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2170:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2171:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2172:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2173: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2173 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2173 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2173 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2159:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2157 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2157 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2132:
	jmp .jump2130
.jump2129:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2174
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2176
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2176:
	; Computing bound for 'n'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2177
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump2178
.jump2177:
	call _d
	push rax
.jump2178:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2179:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! true) then k else d()) 
	jno .jump2180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2180:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2181:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2182: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2183
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2185:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2186
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2186:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2187:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2188:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump2189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2189:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2190:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2191: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2191 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2191 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2191 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2184
.jump2183:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2192:
	; Computing bound for 'q'
	mov rax, [rel const28] ; 51
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2193
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2193:
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2194:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2195:
	imul rdi, [rsp + 0 + 8] ; multiply by 51 
	jno .jump2196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2196:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump2197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2197:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2198: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2198 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2198 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2198 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2184:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2182 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2182 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2175
.jump2174:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2199
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2199:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2200:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2201:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump2202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2202:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2203: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2204:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2205
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2205:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2206:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2207:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump2208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2208:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump2209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2209:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2210: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2210 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2210 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2210 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2203 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2203 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2175:
.jump2130:
	jmp .jump2104
.jump2103:
	mov rax, [rel const519] ; 11.51
	push rax
	mov rax, [rel const520] ; 94.42
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2211
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const521] ; 758
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2213
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2213:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2214:
	; Computing bound for 'o'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2215
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump2216
.jump2215:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump2216:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2217
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2217:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2218:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump2219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2219:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then j else j) 
	jno .jump2220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2220:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump2221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2221:
	imul rdi, [rsp + 0 + 24] ; multiply by 758 
	jno .jump2222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2222:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2223: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2224
	mov rax, [rel const290] ; 770
	push rax
	jmp .jump2225
.jump2224:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump2225:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2226:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2227
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2227:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump2228
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2228:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then 770 else i) 
	jno .jump2229
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2229:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2230: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2231
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2231:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2232:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2233
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2233:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2234
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2234:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump2235
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2235:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump2236
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2236:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2237: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2237 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2237 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2237 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2230 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2230 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2223 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2223 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2223 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2223 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2212
.jump2211:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2238
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2238:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2239:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2240:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2241: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2241 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2242
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2242:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2243:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2244:
imul rdi, [rsp + 0 + 8] ; multiply by (f + (sum[n : j] f)) 
	jno .jump2245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2245:
	imul rdi, [rsp + 0 + 16] ; multiply by (- k) 
	jno .jump2246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2246:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump2247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2247:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2248: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2249:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2250:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2251
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2251:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2252
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2252:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2253: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2254
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2254:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2255:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2256
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2256:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2257
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2257:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2258
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2258:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump2259
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2259:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2260: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2260 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2260 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2260 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2253 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2253 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2248 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2248 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2248 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2248 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2212:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2261:
	; Computing bound for 'p'
	mov rax, [rel const522] ; 177
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2262
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2262:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2263:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2264:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2265
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2265:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (j / (- j)) 
	jno .jump2266
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2266:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2267
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2267:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 177) 
	jno .jump2268
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2268:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump2269
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2269:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2270: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const523] ; 68
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2271
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2271:
	; Computing bound for 't'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2272:
	; Computing bound for 's'
	mov rax, [rel const524] ; 241
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2273
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2273:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2274:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump2275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2275:
	imul rdi, [rsp + 0 + 8] ; multiply by 241 
	jno .jump2276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2276:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump2277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2277:
	imul rdi, [rsp + 0 + 24] ; multiply by 68 
	jno .jump2278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2278:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2279: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2279 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2279 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2279 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2279 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const525] ; 670
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2280:
	cmp rax, [rsp + 32]
	jl .jump2281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2281:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2282:
	cmp rax, [rsp + 40]
	jl .jump2283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2283:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2284:
	cmp rax, [rsp + 48]
	jl .jump2285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2285:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2286:
	cmp rax, [rsp + 56]
	jl .jump2287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2287:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2270 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2270 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2270 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2270 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2288:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2289:
	; Computing bound for 'n'
	mov rax, [rel const449] ; 917
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2290
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2290:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 917 
	jno .jump2291
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2291:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2292
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2292:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2293: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2293 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2293 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2294
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2294:
	cmp rax, [rsp + 16]
	jl .jump2295
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2295:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2296
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2296:
	cmp rax, [rsp + 24]
	jl .jump2297
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2297:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2298
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2298:
	cmp rax, [rsp + 32]
	jl .jump2299
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2299:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2300
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2300:
	cmp rax, [rsp + 40]
	jl .jump2301
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2301:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2302
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2302:
	cmp rax, [rsp + 48]
	jl .jump2303
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2303:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2304
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2304:
	cmp rax, [rsp + 56]
	jl .jump2305
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2305:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2306:
	cmp rax, [rsp + 32]
	jl .jump2307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2307:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2308:
	cmp rax, [rsp + 40]
	jl .jump2309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2309:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2310:
	cmp rax, [rsp + 48]
	jl .jump2311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2311:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2312:
	cmp rax, [rsp + 56]
	jl .jump2313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2313:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2104:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2314
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const526] ; 186
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump2315
.jump2314:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump2315:
	pop rax
	cmp rax, 0
	je .jump2316
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump2317
.jump2316:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump2317:
	pop rax
	cmp rax, 0
	je .jump2318
	call _d
	push rax
	jmp .jump2319
.jump2318:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2320
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2320:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2321:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2322:
	imul rdi, [rsp + 0 + 8] ; multiply by (- i) 
	jno .jump2323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2323:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2324: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2325
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump2326
.jump2325:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump2326:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2327:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2324 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2324 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2328
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2329
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump2330
.jump2329:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump2330:
	pop rax
.jump2328:
	push rax
	pop rax
	cmp rax, 0
	je .jump2331
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump2332
.jump2331:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2333
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump2333:
	cqo
	idiv r10
	push rax
.jump2332:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2334:
	cmp rax, [rsp + 16]
	jl .jump2335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2335:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2336:
	cmp rax, [rsp + 24]
	jl .jump2337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2337:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2319:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2338:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2339
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2339:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2340: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2340 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2340 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2341
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2341:
	; Computing bound for 'o'
	mov rax, [rel const527] ; 700
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2342:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2343
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2343:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2344
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2344:
	imul rdi, [rsp + 0 + 8] ; multiply by 700 
	jno .jump2345
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2345:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump2346
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2346:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2347: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2347 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2347 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2347 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _d
	push rax
	mov rax, [rel const307] ; 997
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2348
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2348:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2349:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2350: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2350 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2350 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2351:
	cmp rax, [rsp + 24]
	jl .jump2352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2352:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2353:
	cmp rax, [rsp + 32]
	jl .jump2354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2354:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2355:
	cmp rax, [rsp + 40]
	jl .jump2356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2356:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2357:
	cmp rax, [rsp + 16]
	jl .jump2358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2358:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2359:
	cmp rax, [rsp + 24]
	jl .jump2360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2360:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2032:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2361
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2362
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2362:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2363:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2364
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2364:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2365
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2365:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2366
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2366:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump2367
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2367:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2368: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const528] ; 95.22
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2368 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2368 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2368 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2369:
	cmp rax, [rsp + 24]
	jl .jump2370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2370:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2371:
	cmp rax, [rsp + 32]
	jl .jump2372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2372:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2373:
	cmp rax, [rsp + 40]
	jl .jump2374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2374:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump2361:
	push rax
	pop rax
	cmp rax, 0
	je .jump2375
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2377
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2379
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump2380
.jump2379:
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump2380:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2381
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump2382
.jump2381:
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump2382:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2383
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2383:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2384:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2385
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2385:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2386:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2387: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const529] ; 40.8
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2387 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2387 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2387 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2387 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2388
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const530] ; 289
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2390
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2390:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2391:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2392:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2393
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2393:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2394:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2395:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- p) / g) 
	jno .jump2396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2396:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2397:
	imul rdi, [rsp + 0 + 24] ; multiply by (j - 289) 
	jno .jump2398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2398:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2399: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2400:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2401
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2401:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2402:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2403
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2403:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2404
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2404:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump2405
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2405:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2406
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2406:
	imul rdi, [rsp + 0 + 24] ; multiply by t 
	jno .jump2407
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2407:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2408: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2409
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2409:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2410
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2410:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump2411: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2411 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2408 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2408 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2408 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2408 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2412
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2412:
	cmp rax, [rsp + 32]
	jl .jump2413
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2413:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2414
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2414:
	cmp rax, [rsp + 40]
	jl .jump2415
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2415:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2416
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2416:
	cmp rax, [rsp + 48]
	jl .jump2417
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2417:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2418
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2418:
	cmp rax, [rsp + 56]
	jl .jump2419
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2419:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2399 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2399 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2399 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2399 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2389
.jump2388:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2420
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2420:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2421:
	; Computing bound for 's'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2422:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2423:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2424: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2424 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2425
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2425:
	cmp rax, [rsp + 8]
	jl .jump2426
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2426:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2427
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2427:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2428
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump2429
.jump2428:
	call _d
	push rax
.jump2429:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2430:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then p else d()) 
	jno .jump2431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2431:
imul rdi, [rsp + 0 + 8] ; multiply by (array[r : l] g)[(- k)] 
	jno .jump2432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2432:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump2433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2433:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2434:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2435: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2436:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2437:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2438: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2439
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2439:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2440:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2441
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2441:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2442:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump2443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2443:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump2444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2444:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump2445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2445:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump2446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2446:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump2447: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2447 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2447 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2447 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2447 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2448:
	; Computing bound for 'y'
	mov rax, [rel const531] ; 337
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2449
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2449:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2450:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2451
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2451:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump2452: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2452 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2452 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2452 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2452 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2453:
	cmp rax, [rsp + 32]
	jl .jump2454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2454:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2455:
	cmp rax, [rsp + 40]
	jl .jump2456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2456:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2457:
	cmp rax, [rsp + 48]
	jl .jump2458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2458:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2459:
	cmp rax, [rsp + 56]
	jl .jump2460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2460:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2438 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2435 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2435 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2435 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2435 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2389:
	jmp .jump2378
.jump2377:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const531] ; 337
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2461
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2461:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 337 
	jno .jump2462
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2462:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2463: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const532] ; 9.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2464
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2466:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const533] ; 293
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2467
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2467:
	; Computing bound for 't'
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2468:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2469
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2469:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2470
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2470:
	imul rdi, [rsp + 0 + 8] ; multiply by (i * d()) 
	jno .jump2471
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2471:
	imul rdi, [rsp + 0 + 16] ; multiply by (293 - k) 
	jno .jump2472
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2472:
	imul rdi, [rsp + 0 + 24] ; multiply by (- j) 
	jno .jump2473
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2473:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump2474: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2475
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2475:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2476
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2476:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump2477: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2477 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2474 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2474 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2474 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2474 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2465
.jump2464:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const534] ; 863
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2478:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2479
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2479:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2480
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump2481
.jump2480:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2481:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2482:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2483:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2484
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2484:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump2485: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2485 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2485 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2486
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2486:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[s : j, t : o] l) 
	jno .jump2487
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2487:
	imul rdi, [rsp + 0 + 8] ; multiply by (if a then j else f) 
	jno .jump2488
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2488:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2489
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2489:
	imul rdi, [rsp + 0 + 24] ; multiply by 863 
	jno .jump2490
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2490:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump2491: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2492
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2492:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2493
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2493:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump2494: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2494 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2491 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2491 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2491 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2491 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2465:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2463 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2495:
	cmp rax, [rsp + 8]
	jl .jump2496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2496:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2378:
	jmp .jump2376
.jump2375:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2497
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump2498
.jump2497:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2499
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2499:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2500:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2501: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2501 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2501 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const535] ; 869
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2502:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2503
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2503:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2504:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2505
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2505:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2506: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2506 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2506 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2506 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2506 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2507
	mov rax, [rel const45] ; False
	push rax
	jmp .jump2508
.jump2507:
	mov rax, [rel const536] ; 35.47
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump2508:
.jump2498:
	pop rax
	cmp rax, 0
	je .jump2509
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2511
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2511:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2512:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2513
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2513:
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2514:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2515:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2516:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump2517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2517:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2518:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2519: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2520
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2520:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2521:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2522: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2522 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2522 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2523:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2524
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2524:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2525:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2526
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2526:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump2527
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2527:
	imul rdi, [rsp + 0 + 8] ; multiply by (u * l) 
	jno .jump2528
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2528:
	imul rdi, [rsp + 0 + 16] ; multiply by (- l) 
	jno .jump2529
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2529:
imul rdi, [rsp + 0 + 24] ; multiply by (- (sum[v : q, w : i] l)) 
	jno .jump2530
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2530:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2531: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2532
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2532:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2533
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2533:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump2534: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2534 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2531 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2531 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2531 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2531 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2519 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2519 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2519 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2519 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2510
.jump2509:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2535
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2535:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2536
	mov rax, [rel const45] ; False
	push rax
	jmp .jump2537
.jump2536:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump2537:
	pop rax
	cmp rax, 0
	je .jump2538
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2539
.jump2538:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump2539:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2540:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2541
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2541:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2542
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump2543
.jump2542:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump2543:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2544:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2545
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2545:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2546: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2547
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump2547:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2546 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2546 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2546 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2546 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2548:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2549
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2549:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2550:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2551:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2552:
imul rdi, [rsp + 0 + 16] ; multiply by ((sum[r : l, s : (if a then q else o), t : j, u : q] (s / i)) * (if (if c then false else c) then (- o) else o)) 
	jno .jump2553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2553:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump2554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2554:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2555: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2556:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2557
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2557:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2558:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2559
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2559:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2560
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2560:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2561
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2561:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump2562
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2562:
	imul rdi, [rsp + 0 + 24] ; multiply by (- s) 
	jno .jump2563
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2563:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2564: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 64 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2565:
	cmp rax, [rsp + 32]
	jl .jump2566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2566:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2567:
	cmp rax, [rsp + 40]
	jl .jump2568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2568:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2569:
	cmp rax, [rsp + 48]
	jl .jump2570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2570:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2571:
	cmp rax, [rsp + 56]
	jl .jump2572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2572:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2573:
	cmp rax, [rsp + 16]
	jl .jump2574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2574:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2575:
	cmp rax, [rsp + 24]
	jl .jump2576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2576:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rdi, 128
	call _jpl_alloc
	; Moving 128 bytes from rsp to rax 
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 128
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2564 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2564 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2564 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2564 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2555 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2555 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2555 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2555 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2510:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2577
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2577:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2578: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2578 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2579:
	cmp rax, [rsp + 32]
	jl .jump2580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2580:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2581:
	cmp rax, [rsp + 40]
	jl .jump2582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2582:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2583:
	cmp rax, [rsp + 48]
	jl .jump2584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2584:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2585:
	cmp rax, [rsp + 56]
	jl .jump2586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2586:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2376:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2587:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2588
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2588:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2589:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2590
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2590:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2591:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2592:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2593
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2593:
	; Computing bound for 'r'
	mov rax, [rel const211] ; 644
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2594:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2595: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2596
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2598:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2599:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2600:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump2601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2601:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump2602: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2602 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2602 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2597
.jump2596:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2603
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2603:
	; Computing bound for 'u'
	mov rax, [rel const537] ; 753
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2604:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 753 
	jno .jump2605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2605:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2606:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump2607: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2607 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2607 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2597:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2608:
	cmp rax, [rsp + 16]
	jl .jump2609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2609:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2610:
	cmp rax, [rsp + 24]
	jl .jump2611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2611:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2595 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2595 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2595 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2612
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2612:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2613: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2613 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2613 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2613 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2613 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2614
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2614:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2615:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2616
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2616:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2617: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2617 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2617 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2617 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2618:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2619
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2619:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2620: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2620 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2620 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2620 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2620 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2621:
	cmp rax, [rsp + 32]
	jl .jump2622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2622:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2623:
	cmp rax, [rsp + 40]
	jl .jump2624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2624:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2625:
	cmp rax, [rsp + 48]
	jl .jump2626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2626:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2627:
	cmp rax, [rsp + 56]
	jl .jump2628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2628:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2629
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2629:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2630:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2631
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2631:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2632: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2632 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2632 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2632 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add rsp, 144 ; Local variables
	pop rbp
	ret

f:
_f:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3442
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3444
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3444:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3445:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3446
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3447
.jump3446:
	mov rax, [rel const688] ; 251
	push rax
.jump3447:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3448
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3448:
	; Computing bound for 'g'
	mov rax, [rel const689] ; 663
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3449
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump3449:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3450:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (f() % (- 663)) 
	jno .jump3451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3451:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! a) then f() else 251) 
	jno .jump3452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3452:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump3453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3453:
	imul rdi, [rsp + 0 + 24] ; multiply by (- (- f())) 
	jno .jump3454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3454:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3455: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3456:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3457
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3457:
	; Computing bound for 'k'
	mov rax, [rel const32] ; 887
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3458:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 887 
	jno .jump3459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3459:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3460:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump3461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3461:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3462: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3462 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3462 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3462 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3455 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3455 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3455 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3455 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	mov rax, [rel const642] ; 531
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3463
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3464
.jump3463:
	mov rax, [rel const690] ; 735
	push rax
	mov rax, [rel const691] ; 594
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
.jump3464:
	pop rax
	cmp rax, 0
	je .jump3465
	call _f
	push rax
	jmp .jump3466
.jump3465:
	call _d
	push rax
	pop rax
	neg rax
	push rax
.jump3466:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const692] ; 797
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3467:
	; Computing bound for 'h'
	mov rax, [rel const196] ; 72
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3468
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3468:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3469:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3470:
	imul rdi, [rsp + 0 + 8] ; multiply by 72 
	jno .jump3471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3471:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 797) 
	jno .jump3472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3472:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3473: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3473 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3473 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3473 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const552] ; 224
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3474
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3474:
	cmp rax, [rsp + 24]
	jl .jump3475
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3475:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3476
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3476:
	cmp rax, [rsp + 32]
	jl .jump3477
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3477:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3478
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3478:
	cmp rax, [rsp + 40]
	jl .jump3479
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3479:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3480:
	cmp rax, [rsp + 32]
	jl .jump3481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3481:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3482:
	cmp rax, [rsp + 40]
	jl .jump3483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3483:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3484:
	cmp rax, [rsp + 48]
	jl .jump3485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3485:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3486:
	cmp rax, [rsp + 56]
	jl .jump3487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3487:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3488
	mov rax, [rel const693] ; 466
	push rax
	jmp .jump3489
.jump3488:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3489:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3490
	mov rax, [rel const450] ; 986
	push rax
	jmp .jump3491
.jump3490:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3491:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3492
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3492:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3493: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3494:
	; Computing bound for 'h'
	mov rax, [rel const694] ; 425
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3495
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3495:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3496: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3496 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3496 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3493 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3497
	call _f
	push rax
	jmp .jump3498
.jump3497:
	call _f
	push rax
.jump3498:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const695] ; 36.13
	push rax
	mov rax, [rel const696] ; 68.52
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3499
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3500
.jump3499:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
.jump3500:
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3501:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3502: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3502 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3503:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3504
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3504:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3505
	call _f
	push rax
	jmp .jump3506
.jump3505:
	call _f
	push rax
	pop rax
	neg rax
	push rax
.jump3506:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3507:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then f() else (- f())) 
	jno .jump3508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3508:
imul rdi, [rsp + 0 + 8] ; multiply by (f() / (sum[g : d()] d())) 
	jno .jump3509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3509:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3510: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3511
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump3512
.jump3511:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump3512:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3510 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3510 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const697] ; 763
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3513
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3513:
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3514:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3515
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3515:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3516
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3516:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump3517
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3517:
	imul rdi, [rsp + 0 + 16] ; multiply by 763 
	jno .jump3518
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3518:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3519: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3519 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3519 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3519 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3520:
	cmp rax, [rsp + 24]
	jl .jump3521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3521:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3522:
	cmp rax, [rsp + 32]
	jl .jump3523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3523:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3524:
	cmp rax, [rsp + 40]
	jl .jump3525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3525:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3526:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const698] ; 348
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3527:
	cmp rax, [rsp + 16]
	jl .jump3528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3528:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3529:
	cmp rax, [rsp + 24]
	jl .jump3530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3530:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3531:
	cmp rax, [rsp + 24]
	jl .jump3532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3532:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3533:
	cmp rax, [rsp + 32]
	jl .jump3534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3534:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3535:
	cmp rax, [rsp + 40]
	jl .jump3536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3536:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3443
.jump3442:
	mov rax, [rel const45] ; False
	push rax
.jump3443:
	pop rax
	cmp rax, 0
	je .jump3537
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const186] ; 503
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3538:
	; Computing bound for 'h'
	mov rax, [rel const699] ; 996
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3539
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3539:
	; Computing bound for 'g'
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3540:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3541: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3541 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3541 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3541 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3542
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3542:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3543:
	; Computing bound for 'h'
	mov rax, [rel const621] ; 373
	push rax
	mov rax, [rel const700] ; 157
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3544
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3544:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3545:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3546:
	imul rdi, [rsp + 0 + 8] ; multiply by (157 * 373) 
	jno .jump3547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3547:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump3548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3548:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[g : (f() + f()), h : 996, i : 503] i) 
	jno .jump3549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3549:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3550: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3551:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3552
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3552:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3553
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3553:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3554: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3554 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3555:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[k : d()] g) 
	jno .jump3556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3556:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3557:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump3558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3558:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3559: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3560
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3560:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3559 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3559 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3559 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3550 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3550 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3550 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3550 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const701] ; 328
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3561:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3562
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3562:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3563
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3563:
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3564:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3565
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3565:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3566: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const702] ; 263
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3566 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3566 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3566 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3567:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3568: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3569
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3569:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3570:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3571
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3571:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3572:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3573: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3573 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3573 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3573 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3573 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3568 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3568 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3568 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3574
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3574:
	cmp rax, [rsp + 8]
	jl .jump3575
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3575:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const703] ; 299
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3576
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3576:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3577: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const704] ; 368
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3578
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3578:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3579:
	; Computing bound for 'h'
	mov rax, [rel const705] ; 104
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3580
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3580:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3581: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3581 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3581 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3581 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3577 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const640] ; 384
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3582:
	; Computing bound for 'g'
	mov rax, [rel const202] ; 439
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3583:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 439 
	jno .jump3584
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3584:
	imul rdi, [rsp + 0 + 8] ; multiply by 384 
	jno .jump3585
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3585:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3586: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3587
	mov rax, [rel const706] ; 800
	push rax
	jmp .jump3588
.jump3587:
	call _f
	push rax
.jump3588:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3586 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3586 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3589
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3589:
	; Computing bound for 'i'
	mov rax, [rel const707] ; 27
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3590
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3590:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3591:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3592
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3592:
	; Computing bound for 'g'
	mov rax, [rel const631] ; 50
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3593:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3594: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3594 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3594 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3594 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3594 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const118] ; 395
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3595
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3595:
	cmp rax, [rsp + 16]
	jl .jump3596
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3596:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3597
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3597:
	cmp rax, [rsp + 24]
	jl .jump3598
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3598:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3599:
	cmp rax, [rsp + 32]
	jl .jump3600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3600:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3601:
	cmp rax, [rsp + 40]
	jl .jump3602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3602:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3603:
	cmp rax, [rsp + 48]
	jl .jump3604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3604:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3605:
	cmp rax, [rsp + 56]
	jl .jump3606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3606:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3607
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3608
.jump3607:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3608:
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3609
	mov rax, [rel const145] ; 237
	push rax
	jmp .jump3610
.jump3609:
	mov rax, [rel const708] ; 98
	push rax
	pop rax
	neg rax
	push rax
.jump3610:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3611
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3611:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3612
	mov rax, [rel const709] ; 83
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3613
.jump3612:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3614
	mov rax, [rel const670] ; 31
	push rax
	jmp .jump3615
.jump3614:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3616
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3617
.jump3616:
	mov rax, [rel const287] ; 381
	push rax
.jump3617:
.jump3615:
.jump3613:
	pop rax
	neg rax
	push rax
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3618
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3619
.jump3618:
	mov rax, [rel const616] ; 944
	push rax
.jump3619:
	mov rax, [rel const710] ; 981
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3620:
	cmp rax, [rsp + 24]
	jl .jump3621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3621:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3622:
	cmp rax, [rsp + 32]
	jl .jump3623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3623:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3624:
	cmp rax, [rsp + 40]
	jl .jump3625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3625:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3626
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump3626:
	push rax
	pop rax
.jump3537:
	push rax
	pop rax
	cmp rax, 0
	je .jump3627
	mov rax, [rel const711] ; 773
	push rax
	jmp .jump3628
.jump3627:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const189] ; 480
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3629
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3629:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3630:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3631:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3632
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3632:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3633:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3634:
	imul rdi, [rsp + 0 + 8] ; multiply by (d() / f()) 
	jno .jump3635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3635:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump3636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3636:
	imul rdi, [rsp + 0 + 24] ; multiply by 480 
	jno .jump3637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3637:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3638: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3639:
	; Computing bound for 'm'
	mov rax, [rel const712] ; 382
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3640
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3640:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3641:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3642
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3642:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump3643
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3643:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump3644
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3644:
	imul rdi, [rsp + 0 + 16] ; multiply by 382 
	jno .jump3645
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3645:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump3646
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3646:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3647: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3647 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3647 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3647 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3647 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3648:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3649:
	; Computing bound for 'k'
	mov rax, [rel const713] ; 794
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3650:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3651 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3651 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3651 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3652
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3652:
	cmp rax, [rsp + 32]
	jl .jump3653
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3653:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3654
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3654:
	cmp rax, [rsp + 40]
	jl .jump3655
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3655:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3656
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3656:
	cmp rax, [rsp + 48]
	jl .jump3657
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3657:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3658
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3658:
	cmp rax, [rsp + 56]
	jl .jump3659
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3659:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3638 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3638 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3638 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3638 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const714] ; 372
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3660
	call _d
	push rax
	jmp .jump3661
.jump3660:
	call _f
	push rax
.jump3661:
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3662
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3664
	mov rax, [rel const715] ; 768
	push rax
	jmp .jump3665
.jump3664:
	call _d
	push rax
.jump3665:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3666:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3667
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3667:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3668: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3668 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3668 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump3663
.jump3662:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3669:
	; Computing bound for 'h'
	mov rax, [rel const197] ; 7
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3670
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3670:
	; Computing bound for 'g'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3671
	call _d
	push rax
	jmp .jump3672
.jump3671:
	call _d
	push rax
.jump3672:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3673:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3674: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const716] ; 387
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3674 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3674 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3674 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3663:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3675
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3676
.jump3675:
	mov rax, [rel const524] ; 241
	push rax
.jump3676:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3677
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3677:
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3678:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3679
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3679:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3680
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3680:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump3681
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3681:
	imul rdi, [rsp + 0 + 16] ; multiply by (if a then f() else 241) 
	jno .jump3682
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3682:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3683: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3683 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3683 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3683 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3684
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3684:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3685: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3685 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3686:
	cmp rax, [rsp + 24]
	jl .jump3687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3687:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3688:
	cmp rax, [rsp + 32]
	jl .jump3689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3689:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3690:
	cmp rax, [rsp + 40]
	jl .jump3691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3691:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3692
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3694
	call _f
	push rax
	jmp .jump3695
.jump3694:
	mov rax, [rel const717] ; 703
	push rax
.jump3695:
	pop rax
	neg rax
	push rax
	jmp .jump3693
.jump3692:
	mov rax, [rel const541] ; 322
	push rax
.jump3693:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3696:
	cmp rax, [rsp + 32]
	jl .jump3697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3697:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3698:
	cmp rax, [rsp + 40]
	jl .jump3699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3699:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3700:
	cmp rax, [rsp + 48]
	jl .jump3701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3701:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3702:
	cmp rax, [rsp + 56]
	jl .jump3703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3703:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const718] ; 14
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3704:
	cmp rax, [rsp + 8]
	jl .jump3705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3705:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const719] ; 509
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3628:
	pop rax
	add rsp, 0 ; Local variables
	pop rbp
	ret
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3706
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3708
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3710
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3710:
	; Computing bound for 'h'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3711:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3712
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3712:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3713
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3713:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- (- d()))) 
	jno .jump3714
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3714:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump3715
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3715:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3716: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3717:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3718:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3719: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3719 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3716 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3716 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3716 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3709
.jump3708:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3720
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3720:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3721
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3721:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3722: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3723:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3724
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3724:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const166] ; 904
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3725
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3725:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3726:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3727
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3727:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3728: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3728 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3728 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3728 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3729:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : f(), i : g, j : 904] i) 
	jno .jump3730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3730:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump3731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3731:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump3732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3732:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3733: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3733 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3733 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3733 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3722 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3734:
	cmp rax, [rsp + 8]
	jl .jump3735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3735:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3709:
	call _f
	push rax
	mov rax, [rel const720] ; 63.31
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const346] ; 604
	push rax
	call _f
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3736
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3736:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3737:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3738
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3739
.jump3738:
	mov rax, [rel const543] ; 569
	push rax
.jump3739:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3740
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3740:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3741:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3742:
	imul rdi, [rsp + 0 + 8] ; multiply by (if c then d() else 569) 
	jno .jump3743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3743:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump3744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3744:
	imul rdi, [rsp + 0 + 24] ; multiply by (f() - 604) 
	jno .jump3745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3745:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3746: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const721] ; 5.96
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3746 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3746 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3746 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3746 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3747
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3747:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3748:
	; Computing bound for 'g'
	mov rax, [rel const653] ; 59
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3749
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3749:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3750: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3750 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3750 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3750 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3751
	mov rax, [rel const475] ; 174
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3752
.jump3751:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3753
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3754
.jump3753:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3754:
.jump3752:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3755
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3755:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3756: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3756 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3757
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3757:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3758:
	cmp rax, [rsp + 32]
	jl .jump3759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3759:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3760:
	cmp rax, [rsp + 40]
	jl .jump3761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3761:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3762:
	cmp rax, [rsp + 48]
	jl .jump3763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3763:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3764:
	cmp rax, [rsp + 56]
	jl .jump3765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3765:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3766
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3768:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3769: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3769 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump3767
.jump3766:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3770
	mov rax, [rel const722] ; 353
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3772
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3773
.jump3772:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3773:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3774
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3774:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3775
	call _f
	push rax
	jmp .jump3776
.jump3775:
	mov rax, [rel const199] ; 187
	push rax
.jump3776:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3777:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3778
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3778:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3779: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3780:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3781: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3781 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3779 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3779 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3779 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump3771
.jump3770:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3771:
.jump3767:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const723] ; 6
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3782
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3782:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3783: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const724] ; 64
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3784
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3786:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3787:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3788: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3788 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3785
.jump3784:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const725] ; 660
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3789
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3791:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3792:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3793: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3793 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3790
.jump3789:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const726] ; 956
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3794:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 956 
	jno .jump3795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3795:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3796: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3796 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3790:
.jump3785:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3797
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3797:
	cmp rax, [rsp + 8]
	jl .jump3798
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3798:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3783 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3799:
	cmp rax, [rsp + 24]
	jl .jump3800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3800:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3801:
	cmp rax, [rsp + 32]
	jl .jump3802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3802:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3803:
	cmp rax, [rsp + 40]
	jl .jump3804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3804:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3707
.jump3706:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3805
	mov rax, [rel const194] ; 142
	push rax
	jmp .jump3806
.jump3805:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3806:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3807
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3807:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then 142 else d()) 
	jno .jump3808
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3808:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3809: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3809 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3707:
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3810
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3810:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3811:
	cmp rax, [rsp + 8]
	jl .jump3812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3812:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3813
	lea rdi, [rel const727] ; 'g'
	call _fail_assertion
.jump3813:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rel const728] ; 548
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3814:
	; Computing bound for 'i'
	mov rax, [rel const284] ; 269
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3815
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3815:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3816
	mov rax, [rel const729] ; 193
	push rax
	jmp .jump3817
.jump3816:
	call _d
	push rax
.jump3817:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3818:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3819
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3819:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3820
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3820:
	imul rdi, [rsp + 0 + 8] ; multiply by (if c then 193 else d()) 
	jno .jump3821
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3821:
	imul rdi, [rsp + 0 + 16] ; multiply by 269 
	jno .jump3822
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3822:
	imul rdi, [rsp + 0 + 24] ; multiply by (548 + f()) 
	jno .jump3823
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3823:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3824: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3824 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3824 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3824 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3824 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _d
	push rax
	mov rax, [rel const730] ; 579
	push rax
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3825
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3825:
	cmp rax, [rsp + 32]
	jl .jump3826
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3826:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3827
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3827:
	cmp rax, [rsp + 40]
	jl .jump3828
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3828:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3829
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3829:
	cmp rax, [rsp + 48]
	jl .jump3830
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3830:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3831
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3831:
	cmp rax, [rsp + 56]
	jl .jump3832
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3832:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3833
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3834
.jump3833:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3835
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3837
	mov rax, [rel const731] ; 520
	push rax
	jmp .jump3838
.jump3837:
	mov rax, [rel const732] ; 906
	push rax
.jump3838:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3839:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3840
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3840:
	; Computing bound for 'h'
	mov rax, [rel const319] ; 618
	push rax
	mov rax, [rel const733] ; 787
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3841
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump3841:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3842:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3843
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3843:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3844: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3845
	call _d
	push rax
	jmp .jump3846
.jump3845:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump3846:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3844 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3844 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3844 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3844 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump3836
.jump3835:
	mov rax, [rel const734] ; 310
	push rax
	mov rax, [rel const735] ; 767
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3847:
	cqo
	idiv r10
	push rax
.jump3836:
.jump3834:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3848
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3848:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3849
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3850
.jump3849:
	mov rax, [rel const89] ; 126
	push rax
.jump3850:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3851
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3851:
	; Computing bound for 'h'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3852:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3853
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3853:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3854: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3854 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3854 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3854 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3855:
	; Computing bound for 'h'
	mov rax, [rel const736] ; 427
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3856
	call _d
	push rax
	jmp .jump3857
.jump3856:
	call _d
	push rax
.jump3857:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3858:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3859
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3859:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const397] ; 937
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3860
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3860:
	; Computing bound for 'g'
	mov rax, [rel const737] ; 82
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3861:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 82 
	jno .jump3862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3862:
	imul rdi, [rsp + 0 + 8] ; multiply by 937 
	jno .jump3863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3863:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3864: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const738] ; 55
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3864 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3864 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3865:
	cmp rax, [rsp + 16]
	jl .jump3866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3866:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3867:
	cmp rax, [rsp + 24]
	jl .jump3868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3868:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3869:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[g : 82, h : 937] 55)[f(), d()] 
	jno .jump3870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3870:
	imul rdi, [rsp + 0 + 8] ; multiply by ((if a then d() else d()) / 427) 
	jno .jump3871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3871:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[g : f(), h : (- d()), i : (if c then d() else 126)] f()) 
	jno .jump3872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3872:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump3873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3873:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3874: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3875:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3876: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3876 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3874 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3874 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3874 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3874 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const739] ; 64.04
	push rax
	mov rax, [rel const740] ; 74.75
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3877
	mov rax, [rel const741] ; 571
	push rax
	jmp .jump3878
.jump3877:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const742] ; 9
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3879
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3879:
	; Computing bound for 'g'
	mov rax, [rel const445] ; 119
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3880:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3881: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3882:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3883
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3883:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3884:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3885
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3885:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3886: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3886 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3886 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3886 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3886 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3881 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3881 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump3878:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3887:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3888: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3888 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3889
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3889:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3890
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const349] ; 908
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3892
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3892:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3893:
	; Computing bound for 'h'
	mov rax, [rel const743] ; 356
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3894
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3894:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3895:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3896: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3896 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3896 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3896 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3896 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump3891
.jump3890:
	call _f
	push rax
.jump3891:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3897:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3898: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3898 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3898 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3899:
	cmp rax, [rsp + 32]
	jl .jump3900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3900:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3901:
	cmp rax, [rsp + 40]
	jl .jump3902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3902:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3903:
	cmp rax, [rsp + 48]
	jl .jump3904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3904:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3905:
	cmp rax, [rsp + 56]
	jl .jump3906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3906:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	call _d
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3907
	call _f
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const744] ; 875
	push rax
	mov rax, [rel const745] ; 695
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3909:
	cmp rax, [rsp + 8]
	jl .jump3910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3910:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3908
.jump3907:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const746] ; 806
	push rax
	call _d
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3911
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3911:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3912: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const112] ; 764
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3912 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3908:
	mov rax, [rel const747] ; 290
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3913:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	mov rax, [rel const748] ; 391
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3914
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3914:
	cqo
	idiv r10
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3915
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3915:
	cmp rax, [rsp + 8]
	jl .jump3916
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3916:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3917
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3917:
	; Computing bound for 'g'
	mov rax, [rel const749] ; 919
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3918
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3919
.jump3918:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const750] ; 339
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3920:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3921: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const751] ; 596
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3921 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3919:
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3922:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3923: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3924:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3925: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3926
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3926:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3927:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3928: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3928 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3928 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3925 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3929
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3929:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3930:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3931:
	; Computing bound for 'k'
	mov rax, [rel const752] ; 575
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3932
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3932:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3933:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3934: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3934 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3934 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3934 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3935
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3935:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3936
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3936:
	; Computing bound for 'j'
	mov rax, [rel const753] ; 47
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3937:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3938: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const723] ; 6
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3938 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3938 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3939:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3940: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3940 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3940 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3940 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3940 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3923 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3923 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3923 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3941
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump3941:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3942:
	cmp rax, [rsp + 8]
	jl .jump3943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3943:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3944
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3946
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3946:
	; Computing bound for 'i'
	mov rax, [rel const754] ; 272
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3947:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3948
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3949
.jump3948:
	mov rax, [rel const755] ; 546
	push rax
.jump3949:
	call _f
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3950
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3950:
	; Computing bound for 'g'
	call _d
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const756] ; 347
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3951:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3952
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3952:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3953: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3953 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3953 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3954:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by ((sum[g : d(), h : 347] d()) + d()) 
	jno .jump3955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3955:
	imul rdi, [rsp + 0 + 8] ; multiply by (f() + (if a then d() else 546)) 
	jno .jump3956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3956:
	imul rdi, [rsp + 0 + 16] ; multiply by 272 
	jno .jump3957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3957:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump3958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3958:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3959: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3960
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3962:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3963
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3963:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3964:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3965
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3965:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3966
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3966:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3967
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3967:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3968
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3968:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump3969
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3969:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3970: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const757] ; 29.21
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3970 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3970 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3970 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3970 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3961
.jump3960:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3971:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3972
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3972:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3973:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3974
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3974:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3975
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3975:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump3976
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3976:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3977
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3977:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump3978
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3978:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3979: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const758] ; 42.24
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3979 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3979 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3979 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3979 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3961:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3959 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3959 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3959 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3959 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3980
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3980:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3981
	call _d
	push rax
	jmp .jump3982
.jump3981:
	mov rax, [rel const759] ; 920
	push rax
.jump3982:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3983:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3984:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3985
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3985:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3986:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump3987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3987:
	imul rdi, [rsp + 0 + 8] ; multiply by (f() / d()) 
	jno .jump3988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3988:
	imul rdi, [rsp + 0 + 16] ; multiply by (if a then d() else 920) 
	jno .jump3989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3989:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump3990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3990:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3991: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3991 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3991 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3991 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3991 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3992
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3994:
	cqo
	idiv r10
	push rax
	jmp .jump3993
.jump3992:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3995:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3996
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3996:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3997:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3998: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3998 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3998 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3998 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3993:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const450] ; 986
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3999:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4000
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4000:
	; Computing bound for 'g'
	mov rax, [rel const272] ; 737
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4001:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4002: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const760] ; 873
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4002 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4002 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4002 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4003
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4003:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4004:
	cmp rax, [rsp + 32]
	jl .jump4005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4005:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4006:
	cmp rax, [rsp + 40]
	jl .jump4007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4007:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4008:
	cmp rax, [rsp + 48]
	jl .jump4009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4009:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4010:
	cmp rax, [rsp + 56]
	jl .jump4011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4011:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4012
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump4012:
	push rax
	pop rax
	cmp rax, 0
	je .jump4013
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const475] ; 174
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4015
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4015:
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4016:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4017
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4017:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4018: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4018 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4018 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4018 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump4014
.jump4013:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const569] ; 636
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4019
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4019:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4020
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4020:
	; Computing bound for 'h'
	mov rax, [rel const761] ; 434
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4021:
	; Computing bound for 'g'
	mov rax, [rel const762] ; 833
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4022
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4022:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4023: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4023 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4023 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4023 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4024:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4025: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4025 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4025 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump4014:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4026:
	cmp rax, [rsp + 32]
	jl .jump4027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4027:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4028:
	cmp rax, [rsp + 40]
	jl .jump4029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4029:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4030:
	cmp rax, [rsp + 48]
	jl .jump4031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4031:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4032:
	cmp rax, [rsp + 56]
	jl .jump4033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4033:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4034
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4034:
	push rax
	pop rax
	cmp rax, 0
	je .jump4035
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4036
.jump4035:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump4036:
	call _f
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4037:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4038
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4038:
	; Computing bound for 'g'
	mov rax, [rel const763] ; 256
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4039:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 256 
	jno .jump4040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4040:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4041:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump4042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4042:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4043: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4043 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4043 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4043 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4044
	mov rax, [rel const764] ; 826
	push rax
	jmp .jump4045
.jump4044:
	mov rax, [rel const91] ; 726
	push rax
.jump4045:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4046
	mov rax, [rel const765] ; 145
	push rax
	jmp .jump4047
.jump4046:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump4047:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4048
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4048:
	cmp rax, [rsp + 24]
	jl .jump4049
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4049:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4050
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4050:
	cmp rax, [rsp + 32]
	jl .jump4051
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4051:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4052
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4052:
	cmp rax, [rsp + 40]
	jl .jump4053
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4053:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4054:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const766] ; 69
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4055:
	cmp rax, [rsp + 32]
	jl .jump4056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4056:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4057:
	cmp rax, [rsp + 40]
	jl .jump4058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4058:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4059:
	cmp rax, [rsp + 48]
	jl .jump4060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4060:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4061:
	cmp rax, [rsp + 56]
	jl .jump4062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4062:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4063
	sub rsp, 8 ; Add alignment
	mov rax, [rel const767] ; 76.67
	push rax
	mov rax, [rel const768] ; 41.11
	push rax
	mov rax, [rel const769] ; 76.69
	push rax
	mov rax, [rel const770] ; 31.18
	push rax
	mov rax, [rel const771] ; 63.16
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4064
.jump4063:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const772] ; 69.87
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4065
	mov rax, [rel const773] ; 78.26
	push rax
	jmp .jump4066
.jump4065:
	mov rax, [rel const774] ; 77.85
	push rax
.jump4066:
	mov rax, [rel const775] ; 99.55
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump4064:
	mov rax, [rel const776] ; 17.48
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const777] ; 77.66
	push rax
	mov rax, [rel const778] ; 88.75
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const779] ; 34.46
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const780] ; 33.95
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4067:
	; Computing bound for 'h'
	mov rax, [rel const781] ; 954
	push rax
	call _d
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4068
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4068:
	; Computing bound for 'g'
	mov rax, [rel const782] ; 686
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4069:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,,,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 686 
	jno .jump4070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4070:
	imul rdi, [rsp + 0 + 8] ; multiply by (d() - 954) 
	jno .jump4071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4071:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump4072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4072:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4073: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4074
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4074:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4075:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4076:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4077:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump4078: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4079:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4080
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4080:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4081:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4082
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4082:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump4083
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4083:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4084
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4084:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump4085
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4085:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump4086
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4086:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4087: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const783] ; 17.51
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4087 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4087 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4087 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4087 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4078 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4078 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4073 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4073 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4073 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4088
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4090
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump4091
.jump4090:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump4091:
	jmp .jump4089
.jump4088:
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
.jump4089:
	pop rax
	cmp rax, 0
	je .jump4092
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4094
	call _f
	push rax
	jmp .jump4095
.jump4094:
	call _d
	push rax
.jump4095:
	pop rax
	neg rax
	push rax
	jmp .jump4093
.jump4092:
	mov rax, [rel const784] ; 993
	push rax
.jump4093:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4096
	call _f
	push rax
	jmp .jump4097
.jump4096:
	call _d
	push rax
.jump4097:
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4098
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4098:
	cmp rax, [rsp + 24]
	jl .jump4099
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4099:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4100
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4100:
	cmp rax, [rsp + 32]
	jl .jump4101
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4101:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4102
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4102:
	cmp rax, [rsp + 40]
	jl .jump4103
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4103:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4104
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const539] ; 444
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4106
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4106:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4107:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4108: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4108 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4108 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump4105
.jump4104:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4109
	mov rax, [rel const785] ; 538
	push rax
	jmp .jump4110
.jump4109:
	call _d
	push rax
.jump4110:
.jump4105:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4111:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const306] ; 12
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4112
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4112:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() * (12 * f())) 
	jno .jump4113
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4113:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4114
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4114:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4115: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4115 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4115 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4116
	call _f
	push rax
	mov rax, [rel const90] ; 173
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4118
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4118:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump4117
.jump4116:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4119
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4119:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4120:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4121
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4121:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4122:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4123:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4124:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump4125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4125:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump4126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4126:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4127: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4127 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4127 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4127 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4127 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const786] ; 472
	push rax
	mov rax, [rel const36] ; 874
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4128:
	cmp rax, [rsp + 32]
	jl .jump4129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4129:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4130:
	cmp rax, [rsp + 40]
	jl .jump4131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4131:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4132:
	cmp rax, [rsp + 48]
	jl .jump4133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4133:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4134:
	cmp rax, [rsp + 56]
	jl .jump4135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4135:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4117:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4136
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4136:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4137:
	; Computing bound for 'h'
	mov rax, [rel const787] ; 542
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4138
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4138:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4139:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4140: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4140 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4140 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4140 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4140 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4141:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4142
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4142:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4143
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4143:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[g : f(), h : 542, i : d(), j : d()] h) 
	jno .jump4144
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4144:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4145: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4145 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4145 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4146
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4146:
	cmp rax, [rsp + 16]
	jl .jump4147
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4147:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4148
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4148:
	cmp rax, [rsp + 24]
	jl .jump4149
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4149:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4150
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4150:
	cmp rax, [rsp + 16]
	jl .jump4151
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4151:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4152
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4152:
	cmp rax, [rsp + 24]
	jl .jump4153
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4153:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4154
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4154:
	cmp rax, [rsp + 16]
	jl .jump4155
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4155:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4156
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4156:
	cmp rax, [rsp + 24]
	jl .jump4157
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4157:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4158:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4159
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4159:
	; Computing bound for 'h'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4160:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4161
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4162
.jump4161:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4163
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4164
.jump4163:
	mov rax, [rel const788] ; 207
	push rax
.jump4164:
.jump4162:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4165
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4165:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then d() else (if c then f() else 207)) 
	jno .jump4166
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4166:
	imul rdi, [rsp + 0 + 8] ; multiply by (- d()) 
	jno .jump4167
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4167:
	imul rdi, [rsp + 0 + 16] ; multiply by (f() % f()) 
	jno .jump4168
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4168:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4169: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const385] ; 470
	push rax
	pop rax
	neg rax
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4170:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4169 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4169 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4169 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const789] ; 739
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4171:
	cmp rax, [rsp + 24]
	jl .jump4172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4172:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4173:
	cmp rax, [rsp + 32]
	jl .jump4174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4174:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4175:
	cmp rax, [rsp + 40]
	jl .jump4176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4176:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rel const383] ; 8
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4177
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4177:
	cmp rax, [rsp + 16]
	jl .jump4178
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4178:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4179
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4179:
	cmp rax, [rsp + 24]
	jl .jump4180
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4180:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const790] ; 63.58
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const791] ; 55.58
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4181
	mov rax, [rel const792] ; 330
	push rax
	pop rax
	neg rax
	push rax
	call _f
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump4182
.jump4181:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const194] ; 142
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4183
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump4183:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4184:
	; Computing bound for 'i'
	mov rax, [rel const91] ; 726
	push rax
	call _d
	push rax
	mov rax, [rel const793] ; 648
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4185:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4186
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4186:
	; Computing bound for 'h'
	mov rax, [rel const794] ; 413
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4187:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4188
	call _d
	push rax
	jmp .jump4189
.jump4188:
	mov rax, [rel const526] ; 186
	push rax
.jump4189:
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4190
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4190:
	cmp rax, [rsp + 8]
	jl .jump4191
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4191:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4192
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4192:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4193: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4193 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4193 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4193 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4193 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump4182:
	mov rax, [rel const795] ; 717
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const796] ; 632
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4194
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4194:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4195: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const261] ; 975
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4195 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4196
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4196:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4197:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4198:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const475] ; 174
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4199:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4200
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4200:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4201
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4201:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4202:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4203: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4203 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4203 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4204:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4205:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4206: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4207
	call _d
	push rax
	jmp .jump4208
.jump4207:
	call _d
	push rax
.jump4208:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4206 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4209
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4209:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4210: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4210 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4210 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4210 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4210 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4211
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4211:
	; Computing bound for 'g'
	mov rax, [rel const797] ; 243
	push rax
	mov rax, [rel const798] ; 75
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4212
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4212:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4213:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4214: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4214 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4214 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4214 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4214 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4215:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4216
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4218
	mov rax, [rel const799] ; 48.15
	push rax
	jmp .jump4219
.jump4218:
	mov rax, [rel const800] ; 88.82
	push rax
.jump4219:
	jmp .jump4217
.jump4216:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const25] ; 970
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4220:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4221
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4221:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4222:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4223: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const801] ; 99.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4223 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4223 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4223 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump4217:
	mov rax, [rel const802] ; 37.49
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4224
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4225
.jump4224:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const621] ; 373
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4226:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4227
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4227:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4228:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4229:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4230:
	imul rdi, [rsp + 0 + 16] ; multiply by 373 
	jno .jump4231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4231:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4232: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4232 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4232 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4232 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const282] ; 335
	push rax
	mov rax, [rel const803] ; 947
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4233
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump4233:
	cqo
	idiv r10
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4234
	mov rax, [rel const109] ; 212
	push rax
	jmp .jump4235
.jump4234:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump4235:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4236
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4236:
	cmp rax, [rsp + 24]
	jl .jump4237
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4237:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4238
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4238:
	cmp rax, [rsp + 32]
	jl .jump4239
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4239:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4240
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4240:
	cmp rax, [rsp + 40]
	jl .jump4241
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4241:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4242
	call _d
	push rax
	jmp .jump4243
.jump4242:
	mov rax, [rel const804] ; 959
	push rax
	pop rax
	neg rax
	push rax
.jump4243:
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump4225:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4244
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4244:
	; Computing bound for 'g'
	call _f
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rel const32] ; 887
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4245:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4246
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4246:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4247: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4248
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4248:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4249:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4250:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4251: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4251 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4251 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4251 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4247 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4247 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4252
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump4252:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4253:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4254: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4254 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4254 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4254 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4255
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4255:
	cmp rax, [rsp + 32]
	jl .jump4256
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4256:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4257
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4257:
	cmp rax, [rsp + 40]
	jl .jump4258
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4258:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4259
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4259:
	cmp rax, [rsp + 48]
	jl .jump4260
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4260:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4261
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4261:
	cmp rax, [rsp + 56]
	jl .jump4262
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4262:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump3945
.jump3944:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump3945:
	pop rax
	cmp rax, 0
	jne .jump4263
	lea rdi, [rel const727] ; 'g'
	call _fail_assertion
.jump4263:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4264
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4266
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4267
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4268
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump4268:
	push rax
	pop rax
.jump4267:
	push rax
	pop rax
	cmp rax, 0
	je .jump4269
	mov rax, [rel const1] ; True
	push rax
	jmp .jump4270
.jump4269:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump4270:
	pop rax
.jump4266:
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4271
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4273
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4273:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rel const161] ; 962
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4274
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4274:
	push rax
	pop rax
	cmp rax, 0
	je .jump4275
	mov rax, [rel const804] ; 959
	push rax
	jmp .jump4276
.jump4275:
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump4276:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4277:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if ((d() < (962 - d())) && a) then 959 else (((- d()) + (- f())) * f())) 
	jno .jump4278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4278:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4279:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4280: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4281
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const715] ; 768
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4283
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4283:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4284 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4285:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4286
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4286:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4287
	call _f
	push rax
	jmp .jump4288
.jump4287:
	call _f
	push rax
.jump4288:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4289:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (if c then f() else f())) 
	jno .jump4290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4290:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4291:
imul rdi, [rsp + 0 + 16] ; multiply by (- (sum[i : 768] f())) 
	jno .jump4292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4292:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4293: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const805] ; 52.21
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4293 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4293 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4293 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4282
.jump4281:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4294
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump4295
.jump4294:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump4295:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const806] ; 600
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4296:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4297
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4297:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4298: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4298 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4298 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4299
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4299:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4300:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4301
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4301:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rel const807] ; 248
	push rax
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4302:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by ((d() + 248) + f()) 
	jno .jump4303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4303:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4304:
imul rdi, [rsp + 0 + 16] ; multiply by ((sum[i : g, j : 600] j) % (if c then g else h)) 
	jno .jump4305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4305:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4306: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4307
	mov rax, [rel const808] ; 51.11
	push rax
	jmp .jump4308
.jump4307:
	mov rax, [rel const809] ; 11.46
	push rax
.jump4308:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4306 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4306 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4306 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4282:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4280 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4280 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4272
.jump4271:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const810] ; 786
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4309
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4309:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4310
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4310:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4311:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4312:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4313:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4314: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4314 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4314 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const305] ; 496
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4315:
	cmp rax, [rsp + 16]
	jl .jump4316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4316:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4317:
	cmp rax, [rsp + 24]
	jl .jump4318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4318:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4319
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const391] ; 183
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4321
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4321:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4322
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4322:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4323:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4324
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4324:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4325: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const811] ; 280
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4325 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4325 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4325 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4326:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : d(), h : d(), i : d()] 280) 
	jno .jump4327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4327:
	imul rdi, [rsp + 0 + 8] ; multiply by (183 - d()) 
	jno .jump4328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4328:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4329: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const389] ; 492
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4329 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4329 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4320
.jump4319:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4330
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4330:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4331
	call _f
	push rax
	jmp .jump4332
.jump4331:
	call _f
	push rax
.jump4332:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4333:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if c then f() else f()) 
	jno .jump4334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4334:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f()) 
	jno .jump4335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4335:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4336 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4336 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4320:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const85] ; 298
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4337:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4338
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4338:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4339
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4339:
	imul rdi, [rsp + 0 + 8] ; multiply by 298 
	jno .jump4340
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4340:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4341: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4341 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4341 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const205] ; 712
	push rax
	mov rax, [rel const812] ; 551
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4342
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4342:
	cmp rax, [rsp + 16]
	jl .jump4343
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4343:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4344
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4344:
	cmp rax, [rsp + 24]
	jl .jump4345
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4345:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const813] ; 392
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4346:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4347
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4347:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4348: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4348 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4349:
	cmp rax, [rsp + 16]
	jl .jump4350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4350:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4351:
	cmp rax, [rsp + 24]
	jl .jump4352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4352:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4353:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if (array[g : f(), h : f()] c)[496, d()] then (array[g : (sum[g : d(), h : d(), i : d()] 280), h : (183 - d())] 492) else (array[g : (if c then f() else f()), h : (- f())] d()))[(- (sum[g : (f() / 392)] f())), (- (array[g : d(), h : 298] h)[551, 712])] 
	jno .jump4354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4354:
	imul rdi, [rsp + 0 + 8] ; multiply by 786 
	jno .jump4355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4355:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4356: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4357
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4357:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4358:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4359
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4360
.jump4359:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump4360:
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4361
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4361:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4362:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4363: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const814] ; 955
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4363 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4363 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4363 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4363 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4364:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4365
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4365:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4366:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4367:
	imul rdi, [rsp + 0 + 8] ; multiply by (- ((- h) - h)) 
	jno .jump4368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4368:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[i : g, j : (d() * (if c then d() else d())), k : g, l : g] 955) 
	jno .jump4369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4369:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4370: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const815] ; 95.52
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4371
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4371:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4372:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4373
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4373:
	; Computing bound for 'm'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4374:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4375
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4375:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4376: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const816] ; 49.18
	push rax
	mov rax, [rel const817] ; 43.06
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4376 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4376 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4376 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4376 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4370 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4370 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4370 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4356 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4356 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4272:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4377
	call _d
	push rax
	jmp .jump4378
.jump4377:
	call _f
	push rax
	pop rax
	neg rax
	push rax
.jump4378:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4379:
	cmp rax, [rsp + 16]
	jl .jump4380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4380:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4381:
	cmp rax, [rsp + 24]
	jl .jump4382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4382:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4265
.jump4264:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4383
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const818] ; 91
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4385
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4385:
	; Computing bound for 'h'
	mov rax, [rel const819] ; 101
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4386:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4387:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4388
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4389
.jump4388:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump4389:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4390
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4390:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then d() else f()) 
	jno .jump4391
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4391:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4392
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4392:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4393: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4393 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4393 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const820] ; 557
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const821] ; 206
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4394
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4394:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4395:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4396
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4396:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4397: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4397 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4397 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4397 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4398:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4399
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4399:
	cmp rax, [rsp + 16]
	jl .jump4400
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4400:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4401
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4401:
	cmp rax, [rsp + 24]
	jl .jump4402
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4402:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4403
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4403:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4404: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4404 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4404 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4404 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4405:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4406:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4407
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4407:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4408
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4408:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4409
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4409:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4410: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4410 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4410 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const822] ; 190
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4411
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4411:
	cmp rax, [rsp + 16]
	jl .jump4412
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4412:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4413
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4413:
	cmp rax, [rsp + 24]
	jl .jump4414
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4414:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4415
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4417:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4418
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4418:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4419:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4420:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4421:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump4422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4422:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4423: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4424
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump4424:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4423 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4423 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4423 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4416
.jump4415:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4425:
	; Computing bound for 'h'
	mov rax, [rel const80] ; 151
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4426
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4426:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4427:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4428:
	imul rdi, [rsp + 0 + 8] ; multiply by 151 
	jno .jump4429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4429:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump4430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4430:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4431: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	mov rax, [rel const823] ; 699
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4432
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4432:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4431 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4431 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4431 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4416:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4433
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4434
.jump4433:
	mov rax, [rel const711] ; 773
	push rax
	call _f
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump4434:
	call _f
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4435:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4436: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4436 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4437:
	cqo
	idiv r10
	push rax
	mov rax, [rel const705] ; 104
	push rax
	mov rax, [rel const526] ; 186
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4438
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4438:
	cmp rax, [rsp + 24]
	jl .jump4439
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4439:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4440
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4440:
	cmp rax, [rsp + 32]
	jl .jump4441
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4441:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4442
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4442:
	cmp rax, [rsp + 40]
	jl .jump4443
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4443:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4444
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4444:
	; Computing bound for 'g'
	call _f
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4445:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4446
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4446:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4447:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4448: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4448 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4448 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4448 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4449:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4450: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4450 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4451:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4452: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4452 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4452 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4452 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4453
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4453:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4454:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4455
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4456
.jump4455:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4457:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const824] ; 23
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4458
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4458:
	; Computing bound for 'g'
	mov rax, [rel const643] ; 349
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4459:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4460: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	mov rax, [rel const789] ; 739
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4460 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4460 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4460 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump4456:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4461
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4461:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (if ((- (- f())) == f()) then f() else (sum[g : ((- f()) * 349), h : ((- (- 23)) - d()), i : f()] (739 + f()))) 
	jno .jump4462
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4462:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4463
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4463:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[g : ((sum[g : ((sum[g : f(), h : f(), i : d()] g) + d())] (f() - f())) - f()), h : (if (array[g : d(), h : d()] a)[f(), (- 190)] then (array[g : f(), h : f(), i : f()] (g / h)) else (array[g : f(), h : 151, i : d()] (699 % d())))[186, 104, (((sum[g : d()] d()) + f()) / (if a then f() else (f() - 773)))], i : (sum[g : (array[g : (if a then d() else f()), h : d()] g)[((sum[g : f(), h : d(), i : 206] f()) / d()), (- 557)], h : 101, i : 91] d())] i) 
	jno .jump4464
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4464:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4465: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const825] ; 29.05
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4465 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4465 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4465 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4384
.jump4383:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4466
	call _f
	push rax
	jmp .jump4467
.jump4466:
	call _f
	push rax
.jump4467:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4468:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4469
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4469:
	; Computing bound for 'h'
	mov rax, [rel const826] ; 344
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4470:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4471
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4471:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4472
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4472:
	imul rdi, [rsp + 0 + 8] ; multiply by 344 
	jno .jump4473
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4473:
	imul rdi, [rsp + 0 + 16] ; multiply by (d() * f()) 
	jno .jump4474
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4474:
	imul rdi, [rsp + 0 + 24] ; multiply by (if false then f() else f()) 
	jno .jump4475
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4475:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4476: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4476 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4476 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4476 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4476 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const827] ; 688
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4477
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4477:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const482] ; 197
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4478
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4478:
	cmp rax, [rsp + 32]
	jl .jump4479
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4479:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4480
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4480:
	cmp rax, [rsp + 40]
	jl .jump4481
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4481:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4482
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4482:
	cmp rax, [rsp + 48]
	jl .jump4483
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4483:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4484
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4484:
	cmp rax, [rsp + 56]
	jl .jump4485
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4485:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4486
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4488:
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4489
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4489:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4490:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4491:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4492:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump4493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4493:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4494: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4495
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4495:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4496:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4497
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4497:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4498:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4499:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4500:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4501:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump4502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4502:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump4503: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4503 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4503 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4503 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4503 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4494 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4494 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4494 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const828] ; 231
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4504:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4505: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const319] ; 618
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4505 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _f
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4506
	mov rax, [rel const829] ; 218
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4507
.jump4506:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump4507:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4508
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4508:
	cmp rax, [rsp + 24]
	jl .jump4509
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4509:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4510
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4510:
	cmp rax, [rsp + 32]
	jl .jump4511
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4511:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4512
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4512:
	cmp rax, [rsp + 40]
	jl .jump4513
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4513:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4487
.jump4486:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4514:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4515
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4515:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4516
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4516:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4517
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4517:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4518: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4519
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4519:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4520:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4521
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4521:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4522:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4523:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4524:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4525:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump4526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4526:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump4527: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4527 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4527 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4527 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4527 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4518 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4518 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4528
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4528:
	cmp rax, [rsp + 16]
	jl .jump4529
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4529:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4530
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4530:
	cmp rax, [rsp + 24]
	jl .jump4531
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4531:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4487:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const315] ; 694
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4532
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4532:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4533
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4533:
	; Computing bound for 'i'
	mov rax, [rel const830] ; 175
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4534:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4535
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4536
.jump4535:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump4536:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4537
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4537:
	; Computing bound for 'g'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4538:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4539:
	imul rdi, [rsp + 0 + 8] ; multiply by (if c then f() else f()) 
	jno .jump4540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4540:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 175) 
	jno .jump4541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4541:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump4542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4542:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4543: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4544
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	jmp .jump4545
.jump4544:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump4545:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4543 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4543 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4543 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4543 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const88] ; 793
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4546:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4547
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4548
.jump4547:
	mov rax, [rel const831] ; 502
	push rax
.jump4548:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4549
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4549:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4550: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4550 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4550 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4551
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4551:
	; Computing bound for 'i'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4552:
	; Computing bound for 'h'
	mov rax, [rel const244] ; 814
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4553
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4553:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4554:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4555: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4555 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4555 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4555 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4555 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4556:
	cmp rax, [rsp + 32]
	jl .jump4557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4557:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4558:
	cmp rax, [rsp + 40]
	jl .jump4559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4559:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4560:
	cmp rax, [rsp + 48]
	jl .jump4561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4561:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4562:
	cmp rax, [rsp + 56]
	jl .jump4563
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4563:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4564:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4565: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4565 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4565 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4566
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4566:
	cmp rax, [rsp + 32]
	jl .jump4567
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4567:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4568
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4568:
	cmp rax, [rsp + 40]
	jl .jump4569
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4569:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4570
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4570:
	cmp rax, [rsp + 48]
	jl .jump4571
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4571:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4572
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4572:
	cmp rax, [rsp + 56]
	jl .jump4573
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4573:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4574
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4574:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4575
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4575:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4576:
	; Computing bound for 'g'
	mov rax, [rel const832] ; 643
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4577
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4577:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 643 
	jno .jump4578
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4578:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4579
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4579:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump4580
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4580:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4581: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4582:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4583:
	; Computing bound for 'j'
	mov rax, [rel const700] ; 157
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4584:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump4585: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4585 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4585 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4585 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4581 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4581 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4581 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4586
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4586:
	; Computing bound for 'i'
	mov rax, [rel const833] ; 500
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4587:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const834] ; 26
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4588:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4589: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4589 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4590
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4590:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4591
	mov rax, [rel const835] ; 162
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump4592
.jump4591:
	call _f
	push rax
	mov rax, [rel const836] ; 506
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4593
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4593:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump4592:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4594:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4595: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4595 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4595 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4595 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4595 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4596
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4598
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4599
.jump4598:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump4599:
	pop rax
	neg rax
	push rax
	jmp .jump4597
.jump4596:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4600
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4601
.jump4600:
	mov rax, [rel const105] ; 586
	push rax
	call _f
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump4601:
.jump4597:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4602
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4602:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4603:
	; Computing bound for 'h'
	mov rax, [rel const652] ; 129
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4604
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4604:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4605:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4606: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4606 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4606 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4606 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4606 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4607:
	cmp rax, [rsp + 24]
	jl .jump4608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4608:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4609:
	cmp rax, [rsp + 32]
	jl .jump4610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4610:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4611:
	cmp rax, [rsp + 40]
	jl .jump4612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4612:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4613:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const214] ; 279
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4614:
	cmp rax, [rsp + 8]
	jl .jump4615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4615:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4616:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4617
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4617:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by ([279][f()] / d()) 
	jno .jump4618
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4618:
imul rdi, [rsp + 0 + 8] ; multiply by (- (array[g : 643, h : d(), i : d()] (sum[j : 157, k : g, l : h] h))[(f() + (sum[g : d(), h : (- 129), i : d(), j : d()] f())), (if false then (- (if false then f() else f())) else (if c then f() else (f() * 586))), (sum[g : (if (! a) then (d() * 162) else (506 % f())), h : (- (sum[g : 26] d())), i : 500, j : (- (- d()))] (g * f()))]) 
	jno .jump4619
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4619:
imul rdi, [rsp + 0 + 16] ; multiply by (if (array[g : d(), h : 344, i : (d() * f()), j : (if false then f() else f())] (! true))[197, (d() % (- f())), (- f()), 688] then (array[g : f(), h : f(), i : d()] (array[j : i, k : h, l : g, m : d()] i))[(if false then (- 218) else d()), f(), (sum[g : 231] (f() + 618))] else (array[g : f(), h : f()] (array[i : h, j : d(), k : g, l : g] g))[d(), d()])[f(), (- d()), (- d()), (sum[g : (array[g : f(), h : (if c then f() else f()), i : (- 175), j : d()] (if true then h else d()))[(sum[g : d(), h : 814, i : (- f()), j : d()] d()), (sum[g : (if c then d() else 502), h : (f() + 793)] f()), ((- f()) + d()), f()], h : 694] d())] 
	jno .jump4620
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4620:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump4621: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4622:
	; Computing bound for 'k'
	mov rax, [rel const837] ; 715
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4623
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4623:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4624
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4624:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump4625: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4625 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4626:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump4627: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4628
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4628:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4629
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4629:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4630:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4631: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const838] ; 99.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4631 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4631 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4627 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4627 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4627 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4621 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4621 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4621 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4384:
.jump4265:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4632
	lea rdi, [rel const839] ; 'k'
	call _fail_assertion
.jump4632:
	sub rsp, 24
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4633
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4635:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4636
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4636:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4637
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4637:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4638:
	; Computing bound for 'k'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4639
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4641:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4642: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4642 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump4640
.jump4639:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump4640:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4643
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4643:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4644: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const337] ; 278
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4644 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4644 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4644 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4645:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rel const255] ; 160
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4646
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump4646:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4647:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4648:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4649:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4650:
	; Computing bound for 'k'
	mov rax, [rel const840] ; 461
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4651:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4652
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4652:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4653: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4653 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4653 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4653 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4653 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4654
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4654:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const793] ; 648
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4655:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4656
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4656:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4657: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4658
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4658:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4659
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4659:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4657 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4657 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4657 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4657 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4660
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4662
	call _f
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4663
.jump4662:
	call _d
	push rax
.jump4663:
	jmp .jump4661
.jump4660:
	call _d
	push rax
	pop rax
	neg rax
	push rax
.jump4661:
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4664
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4664:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4665:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4666:
imul rdi, [rsp + 0 + 8] ; multiply by ((if c then (if (! true) then (- f()) else d()) else (- d())) * (sum[k : f(), l : (648 - (f() - j)), m : (sum[k : (j % 461), l : j, m : j, n : j] j), n : (- (160 / d()))] (h % (f() % k)))) 
	jno .jump4667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4667:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[k : (if true then (sum[k : f()] d()) else (- j)), l : i, m : f()] 278) 
	jno .jump4668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4668:
	imul rdi, [rsp + 0 + 24] ; multiply by (d() / f()) 
	jno .jump4669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4669:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4670: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const841] ; 3.68
	push rax
	mov rax, [rel const842] ; 3.44
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const843] ; 72.23
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const844] ; 93.16
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4671:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4672
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4672:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4673:
	; Computing bound for 'o'
	mov rax, [rel const845] ; 802
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4674
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4674:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4675: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const846] ; 26.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4675 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4675 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4675 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4675 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4676
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4676:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4677
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4677:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4678: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const847] ; 49.11
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4678 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4679:
	cmp rax, [rsp + 8]
	jl .jump4680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4680:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const72] ; 3
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4681
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4683
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4683:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4684:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4685:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4686
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4686:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4687:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4688: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4688 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4688 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4688 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4689
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4689:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4690:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4691: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const848] ; 59.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4691 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4691 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4691 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4691 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump4682
.jump4681:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4692
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4692:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4693: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4694:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4695: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const849] ; 67.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4695 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4693 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump4682:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4670 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4670 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4670 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4670 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4634
.jump4633:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4696
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const850] ; 481
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4698
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4698:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4699:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4700
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4700:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4701:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4702: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4702 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4702 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4702 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4702 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4703:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4704
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4704:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4705:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4706:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4707:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[k : j, l : d(), m : h, n : 481] l) 
	jno .jump4708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4708:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4709: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4709 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4709 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4709 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4697
.jump4696:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const648] ; 599
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4710:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4711
	mov rax, [rel const851] ; 854
	push rax
	jmp .jump4712
.jump4711:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump4712:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4713
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4713:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4714:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4715:
	imul rdi, [rsp + 0 + 8] ; multiply by (if a then 854 else h) 
	jno .jump4716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4716:
	imul rdi, [rsp + 0 + 16] ; multiply by 599 
	jno .jump4717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4717:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4718: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4718 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4718 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4718 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4697:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4719
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4719:
	cmp rax, [rsp + 24]
	jl .jump4720
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4720:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4721
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4721:
	cmp rax, [rsp + 32]
	jl .jump4722
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4722:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4723
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4723:
	cmp rax, [rsp + 40]
	jl .jump4724
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4724:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4725
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4725:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4726:
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4727
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4727:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4728:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4729:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4730:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4731:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump4732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4732:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump4733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4733:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4734:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4735: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4735 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4735 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4735 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4735 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const645] ; 733
	push rax
	mov rax, [rel const63] ; 567
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4736:
	cmp rax, [rsp + 32]
	jl .jump4737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4737:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4738:
	cmp rax, [rsp + 40]
	jl .jump4739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4739:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4740:
	cmp rax, [rsp + 48]
	jl .jump4741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4741:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4742:
	cmp rax, [rsp + 56]
	jl .jump4743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4743:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4744:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4745
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4745:
	push rax
	pop rax
	cmp rax, 0
	je .jump4746
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4747
.jump4746:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump4747:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4748
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4748:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4749:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4750:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (c && c) then i else f()) 
	jno .jump4751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4751:
imul rdi, [rsp + 0 + 16] ; multiply by (array[k : i, l : f(), m : f(), n : h] d())[(- h), 567, 733, i] 
	jno .jump4752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4752:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4753: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4754
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4754:
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4755:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4756
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4756:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4757:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4758:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4759:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump4760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4760:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump4761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4761:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4762: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4762 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4762 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4762 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4762 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const852] ; 684
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4763
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4763:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4764:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4765: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4765 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4765 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4766:
	cmp rax, [rsp + 32]
	jl .jump4767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4767:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4768:
	cmp rax, [rsp + 40]
	jl .jump4769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4769:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4770:
	cmp rax, [rsp + 48]
	jl .jump4771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4771:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4772:
	cmp rax, [rsp + 56]
	jl .jump4773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4773:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4753 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4753 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4753 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4774
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4774:
	cmp rax, [rsp + 24]
	jl .jump4775
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4775:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4776
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4776:
	cmp rax, [rsp + 32]
	jl .jump4777
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4777:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4778
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4778:
	cmp rax, [rsp + 40]
	jl .jump4779
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4779:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4780
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4780:
	; Computing bound for 'k'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4781:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f()) 
	jno .jump4782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4782:
imul rdi, [rsp + 0 + 8] ; multiply by (array[k : i, l : (if (c && c) then i else f()), m : (array[k : i, l : f(), m : f(), n : h] d())[(- h), 567, 733, i]] (array[n : j, o : i, p : d(), q : l] m)[f(), k, (sum[n : f(), o : j] d()), 684])[d(), j, i] 
	jno .jump4783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4783:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump4784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4784:
imul rdi, [rsp + 0 + 24] ; multiply by (if true then (array[k : h, l : d(), m : (sum[k : j, l : d(), m : h, n : 481] l)] f()) else (array[k : i, l : (if a then 854 else h), m : 599] j))[h, (- f()), (- h)] 
	jno .jump4785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4785:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump4786: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const853] ; 39.87
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const854] ; 31.69
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4787:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4788
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4788:
	; Computing bound for 'p'
	mov rax, [rel const283] ; 220
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4789:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4790
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4790:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4791
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4791:
	imul rdi, [rsp + 0 + 8] ; multiply by 220 
	jno .jump4792
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4792:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump4793
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4793:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump4794
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4794:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4795: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const855] ; 45.68
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4795 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4795 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4795 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4795 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4796
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4796:
	cmp rax, [rsp + 32]
	jl .jump4797
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4797:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4798
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4798:
	cmp rax, [rsp + 40]
	jl .jump4799
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4799:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4800
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4800:
	cmp rax, [rsp + 48]
	jl .jump4801
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4801:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4802
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4802:
	cmp rax, [rsp + 56]
	jl .jump4803
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4803:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4804
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4804:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4805:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4806
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4806:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4807:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4808: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4809:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4810
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4810:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4811:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump4812: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const856] ; 41.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4812 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4812 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4812 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4808 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4808 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4808 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4808 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const857] ; 84.79
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4786 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4786 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4786 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4786 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4634:
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4813
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump4813:
	push rax
	pop rax
	cmp rax, 0
	je .jump4814
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4816
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4818
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4820
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4820:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4821:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4822
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4822:
	; Computing bound for 'l'
	mov rax, [rel const858] ; 635
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4823:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4824: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4825:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4826
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4826:
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4827:
	; Computing bound for 'n'
	mov rax, [rel const135] ; 66
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4828
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4828:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4829: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4829 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4829 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4829 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4829 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4824 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4824 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4830:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4831
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4831:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4832:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4833:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4834:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4835: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const750] ; 339
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4835 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4836
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4836:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4837: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4837 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4837 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4838
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4838:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4839: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4839 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4839 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4839 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4839 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4840
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4840:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4841: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4841 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4841 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4841 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4842:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4843
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4843:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4844
	call _d
	push rax
	jmp .jump4845
.jump4844:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4846
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4848
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4848:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4849: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const538] ; 418
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4849 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump4847
.jump4846:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4850
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4850:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4851:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4852: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4852 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4852 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump4847:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4853
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4854
.jump4853:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump4854:
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump4845:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4855:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (if a then d() else ((if a then i else h) * (if (! a) then (sum[l : d()] 418) else (sum[l : h, m : f()] i)))) 
	jno .jump4856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4856:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4857:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[l : (sum[l : (sum[l : (sum[l : j] 339), m : j] f()), m : f(), n : f(), o : (sum[l : 635, m : (- j)] (sum[n : 66, o : f(), p : j, q : i] m))] n), m : i, n : d()] d()) 
	jno .jump4858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4858:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4859: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4860
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4860:
	; Computing bound for 'o'
	mov rax, [rel const117] ; 60
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4861:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4862: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4862 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4862 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4863:
	cmp rax, [rsp + 16]
	jl .jump4864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4864:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4865:
	cmp rax, [rsp + 24]
	jl .jump4866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4866:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4859 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4859 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4859 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4819
.jump4818:
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump4819:
	jmp .jump4817
.jump4816:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4867:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4868
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4868:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4869:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4870:
	imul rdi, [rsp + 0 + 8] ; multiply by (- j) 
	jno .jump4871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4871:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump4872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4872:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4873: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4874
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4876
	mov rax, [rel const859] ; 93.0
	push rax
	jmp .jump4877
.jump4876:
	mov rax, [rel const860] ; 51.33
	push rax
.jump4877:
	jmp .jump4875
.jump4874:
	mov rax, [rel const861] ; 71.12
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4878
	mov rax, [rel const862] ; 18.92
	push rax
	jmp .jump4879
.jump4878:
	mov rax, [rel const863] ; 97.73
	push rax
.jump4879:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4875:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4873 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4873 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4873 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4817:
	jmp .jump4815
.jump4814:
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump4815:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4880:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add rsp, 88 ; Local variables
	pop rbp
	ret

g:
_g:
	push rbp
	mov rbp, rsp
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4881:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4882: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4883:
	; Computing bound for 'o'
	mov rax, [rel const765] ; 145
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4884
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4884:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4885:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4886: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4886 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4886 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4886 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4887
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4887:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4888:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4889:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[n : f(), o : 145, p : i] o) 
	jno .jump4890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4890:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4891: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4891 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4891 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4892:
	cmp rax, [rsp + 16]
	jl .jump4893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4893:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4894:
	cmp rax, [rsp + 24]
	jl .jump4895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4895:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4882 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	mov rax, [rel const865] ; 7.2
	push rax
	mov rax, [rel const866] ; 75.01
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4896
	mov rax, [rel const553] ; 455
	push rax
	jmp .jump4897
.jump4896:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4898
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4898:
	; Computing bound for 'm'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4899:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4900: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4901:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4902
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4902:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4903: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4903 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4903 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4900 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4900 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4904:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4905
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4905:
	; Computing bound for 'n'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4906
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump4907
.jump4906:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump4907:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4908
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4908:
	; Computing bound for 'n'
	mov rax, [rel const867] ; 115
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4909:
	; Computing bound for 'm'
	mov rax, [rel const192] ; 671
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4910
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4910:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4911: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4911 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4911 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4911 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4912:
	cmp rax, [rsp + 8]
	jl .jump4913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4913:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4914:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4915
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4915:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4916: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4917
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4917:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4918:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump4919: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4919 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4919 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4916 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4916 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4916 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4916 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump4897:
	call _f
	push rax
	mov rax, [rel const868] ; 407
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4920
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4922
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4924
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4924:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump4925
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4925:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4926: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4927:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4928
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4928:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4929:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4930:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4931:
	imul rdi, [rsp + 0 + 16] ; multiply by (d() + d()) 
	jno .jump4932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4932:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4933: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4934
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4934:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4935:
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4936
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4936:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4937:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4938:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump4939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4939:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump4940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4940:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump4941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4941:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump4942: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const869] ; 11.0
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4942 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4942 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4942 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4942 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4933 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4933 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4933 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const560] ; 146
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4943
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4943:
	cmp rax, [rsp + 24]
	jl .jump4944
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4944:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4945
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4945:
	cmp rax, [rsp + 32]
	jl .jump4946
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4946:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4947
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump4947:
	cmp rax, [rsp + 40]
	jl .jump4948
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump4948:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4926 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const870] ; 300
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4949:
	cmp rax, [rsp + 8]
	jl .jump4950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4950:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4923
.jump4922:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4951
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump4952
.jump4951:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump4952:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4953
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const871] ; 912
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4955
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4955:
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4956:
	; Computing bound for 'n'
	mov rax, [rel const872] ; 465
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4957:
	; Computing bound for 'm'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4958:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d()) 
	jno .jump4959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4959:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 465) 
	jno .jump4960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4960:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump4961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4961:
	imul rdi, [rsp + 0 + 24] ; multiply by 912 
	jno .jump4962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4962:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4963: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const873] ; 13.47
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4963 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4963 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4963 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4963 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4964:
	cmp rax, [rsp + 8]
	jl .jump4965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4965:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4954
.jump4953:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4966
	call _d
	push rax
	jmp .jump4967
.jump4966:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump4967:
	pop rax
	neg rax
	push rax
	mov rax, [rel const874] ; 313
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4968
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4970
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4970:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4971
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump4971:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4972:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4973:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4974
	call _d
	push rax
	jmp .jump4975
.jump4974:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump4975:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4976:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then d() else (i - i)) 
	jno .jump4977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4977:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4978:
	imul rdi, [rsp + 0 + 16] ; multiply by (d() % i) 
	jno .jump4979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4979:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump4980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4980:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4981: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4982
	mov rax, [rel const875] ; 11.83
	push rax
	jmp .jump4983
.jump4982:
	mov rax, [rel const876] ; 51.58
	push rax
.jump4983:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4981 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4981 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4981 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4981 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4969
.jump4968:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4984
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4984:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4985
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4985:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4986:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4987
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4987:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4988: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4988 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4988 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4988 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4989:
	; Computing bound for 'n'
	mov rax, [rel const845] ; 802
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4990
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4990:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4991:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump4992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4992:
	imul rdi, [rsp + 0 + 8] ; multiply by 802 
	jno .jump4993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4993:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[m : (- d()), n : f(), o : i] (n - f())) 
	jno .jump4994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4994:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump4995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4995:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4996: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4997:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4998
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4998:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4999
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump4999:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5000
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5000:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5001: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const877] ; 79.58
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5001 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5001 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5002
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5002:
	cmp rax, [rsp + 16]
	jl .jump5003
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5003:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5004
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5004:
	cmp rax, [rsp + 24]
	jl .jump5005
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5005:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4996 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4996 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4996 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4996 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4969:
.jump4954:
.jump4923:
	jmp .jump4921
.jump4920:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const650] ; 421
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5006
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5006:
	; Computing bound for 'n'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5007
	call _f
	push rax
	jmp .jump5008
.jump5007:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5008:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5009:
	; Computing bound for 'm'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5010
	mov rax, [rel const453] ; 122
	push rax
	jmp .jump5011
.jump5010:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump5012
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5012:
	push rax
	pop rax
	cmp rax, 0
	je .jump5013
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5015
	mov rax, [rel const352] ; 225
	push rax
	jmp .jump5016
.jump5015:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump5016:
	jmp .jump5014
.jump5013:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump5014:
.jump5011:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5017
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5017:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5018: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5019:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5020: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const878] ; 85.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5020 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const879] ; 18.27
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5021
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5023
	mov rax, [rel const238] ; 123
	push rax
	jmp .jump5024
.jump5023:
	mov rax, [rel const387] ; 867
	push rax
.jump5024:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5025:
	cqo
	idiv r10
	push rax
	jmp .jump5022
.jump5021:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5026
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5027
.jump5026:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump5027:
.jump5022:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5018 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5018 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5018 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5028
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const595] ; 17
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5030
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5030:
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5031:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5032:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5033: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5033 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5034
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5034:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5035:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump5036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5036:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[m : d()] f()) 
	jno .jump5037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5037:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump5038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5038:
	imul rdi, [rsp + 0 + 24] ; multiply by (- 17) 
	jno .jump5039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5039:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5040: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5041
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5043
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5043:
	cmp rax, [rsp + 8]
	jl .jump5044
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5044:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5042
.jump5041:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5045
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump5045:
	push rax
.jump5042:
	pop rax
	cmp rax, 0
	je .jump5046
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5048:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5049
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5049:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5050:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5051
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5051:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (m + d()) 
	jno .jump5052
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5052:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump5053
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5053:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5054
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5054:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump5055
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5055:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5056: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5057
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5057:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump5058: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const880] ; 60.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5058 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5056 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5056 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5056 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5056 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5047
.jump5046:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5059:
	; Computing bound for 's'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5060
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5060:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5061
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump5062
.jump5061:
	call _f
	push rax
.jump5062:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5063:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5064
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5064:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump5065
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5065:
	imul rdi, [rsp + 0 + 8] ; multiply by (if a then n else f()) 
	jno .jump5066
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5066:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5067
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5067:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump5068
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5068:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5069: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5070
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5070:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5071:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump5072: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const881] ; 76.75
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5072 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5072 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5069 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5069 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5069 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5069 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5047:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5040 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5040 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5040 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5040 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5073
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5074
.jump5073:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5074:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5075
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5075:
	cmp rax, [rsp + 8]
	jl .jump5076
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5076:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	call _d
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5077
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5077:
	cmp rax, [rsp + 8]
	jl .jump5078
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5078:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5079:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5080
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5080:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5081:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5082: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5082 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5082 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5082 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5083
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5083:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5084: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5085
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5087:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump5086
.jump5085:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
.jump5086:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5084 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5088:
	cmp rax, [rsp + 32]
	jl .jump5089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5089:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5090:
	cmp rax, [rsp + 40]
	jl .jump5091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5091:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5092:
	cmp rax, [rsp + 48]
	jl .jump5093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5093:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5094:
	cmp rax, [rsp + 56]
	jl .jump5095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5095:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5029
.jump5028:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5096
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5098
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5099
.jump5098:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5100
	mov rax, [rel const177] ; 96
	push rax
	jmp .jump5101
.jump5100:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5101:
.jump5099:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5102
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5102:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if c then i else (if c then 96 else i)) 
	jno .jump5103
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5103:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5104: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5105:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5106
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5106:
	; Computing bound for 'o'
	mov rax, [rel const527] ; 700
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5107:
	; Computing bound for 'n'
	mov rax, [rel const882] ; 736
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5108:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5109
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5109:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() / 736) 
	jno .jump5110
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5110:
	imul rdi, [rsp + 0 + 8] ; multiply by 700 
	jno .jump5111
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5111:
	imul rdi, [rsp + 0 + 16] ; multiply by (i + d()) 
	jno .jump5112
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5112:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump5113
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5113:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5114: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5115
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5115:
	; Computing bound for 's'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5116:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5117
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5117:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump5118: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const883] ; 11.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5118 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5118 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5118 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5114 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5114 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5114 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5114 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5104 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5119
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const884] ; 597
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5121
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5121:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5122
	mov rax, [rel const793] ; 648
	push rax
	jmp .jump5123
.jump5122:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5123:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5124:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5125
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5125:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const885] ; 155
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5126:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5127: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5127 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5127 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5127 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5127 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump5120
.jump5119:
	call _f
	push rax
.jump5120:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5128:
	cmp rax, [rsp + 8]
	jl .jump5129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5129:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5097
.jump5096:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5130:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5131
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5131:
	; Computing bound for 'o'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5132
	call _d
	push rax
	jmp .jump5133
.jump5132:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5133:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5134:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5135
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5135:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const175] ; 870
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5136
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5136:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const836] ; 506
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5137
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5137:
	; Computing bound for 'm'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5138:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5139: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5139 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5139 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5140:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5141
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5141:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5142: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5143:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5144
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5144:
	; Computing bound for 'q'
	mov rax, [rel const886] ; 168
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5145:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5146
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5146:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5147
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5147:
	imul rdi, [rsp + 0 + 8] ; multiply by 168 
	jno .jump5148
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5148:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5149
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5149:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump5150
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5150:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5151: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5151 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5151 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5151 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5151 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _d
	push rax
	mov rax, [rel const795] ; 717
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5152
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5152:
	cmp rax, [rsp + 32]
	jl .jump5153
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5153:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5154
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5154:
	cmp rax, [rsp + 40]
	jl .jump5155
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5155:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5156
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5156:
	cmp rax, [rsp + 48]
	jl .jump5157
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5157:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5158
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5158:
	cmp rax, [rsp + 56]
	jl .jump5159
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5159:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5142 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5142 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5142 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5160:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[m : (d() * (- i)), n : (sum[m : (- f()), n : (- 506)] d()), o : 870] (array[p : d(), q : 168, r : i, s : o] p)[m, m, (- 717), d()]) 
	jno .jump5161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5161:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump5162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5162:
	imul rdi, [rsp + 0 + 16] ; multiply by (f() * (if true then d() else i)) 
	jno .jump5163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5163:
	imul rdi, [rsp + 0 + 24] ; multiply by (i / f()) 
	jno .jump5164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5164:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5165: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const887] ; 53.0
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5165 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5165 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5165 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5165 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5097:
.jump5029:
.jump4921:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5166
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5168
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump5169
.jump5168:
	mov rax, [rel const84] ; 989
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5170
	mov rax, [rel const85] ; 298
	push rax
	jmp .jump5171
.jump5170:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump5171:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump5169:
	pop rax
	xor rax, 1
	push rax
	jmp .jump5167
.jump5166:
	mov rax, [rel const523] ; 68
	push rax
	mov rax, [rel const888] ; 90
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5172
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5174
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump5175
.jump5174:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump5175:
	jmp .jump5173
.jump5172:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const889] ; 329
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5176
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5176:
	push rax
.jump5173:
	pop rax
	xor rax, 1
	push rax
.jump5167:
	pop rax
	cmp rax, 0
	je .jump5177
	call _d
	push rax
	jmp .jump5178
.jump5177:
	mov rax, [rel const353] ; 283
	push rax
.jump5178:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5179:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5180:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump5181: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5181 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5181 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5182:
	cmp rax, [rsp + 32]
	jl .jump5183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5183:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5184:
	cmp rax, [rsp + 40]
	jl .jump5185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5185:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5186:
	cmp rax, [rsp + 48]
	jl .jump5187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5187:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5188:
	cmp rax, [rsp + 56]
	jl .jump5189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5189:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5190
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5192
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5192:
	push rax
	pop rax
	cmp rax, 0
	je .jump5193
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5195:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5196
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5196:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5197:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5198:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5199:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump5200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5200:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5201: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5201 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5201 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5201 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5194
.jump5193:
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump5194:
	jmp .jump5191
.jump5190:
	mov rax, [rel const890] ; 2.21
	push rax
	mov rax, [rel const891] ; 46.95
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5202
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump5203
.jump5202:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5204
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump5205
.jump5204:
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump5205:
.jump5203:
.jump5191:
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5206
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5207
.jump5206:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump5207:
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5208
	mov rax, [rel const892] ; 33.7
	push rax
	jmp .jump5209
.jump5208:
	mov rax, [rel const893] ; 20.71
	push rax
	mov rax, [rel const894] ; 41.25
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump5209:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5210
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const545] ; 629
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5212
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5212:
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5213
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5213:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5214:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5215
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5215:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5216
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5216:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump5217
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5217:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5218
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5218:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5219: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5219 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5219 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5219 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _f
	push rax
	mov rax, [rel const160] ; 895
	push rax
	mov rax, [rel const895] ; 939
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5220
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump5221
.jump5220:
	mov rax, [rel const1] ; True
	push rax
.jump5221:
	pop rax
	cmp rax, 0
	je .jump5222
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump5223
.jump5222:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5223:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5224:
	cmp rax, [rsp + 24]
	jl .jump5225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5225:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5226:
	cmp rax, [rsp + 32]
	jl .jump5227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5227:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5228:
	cmp rax, [rsp + 40]
	jl .jump5229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5229:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5230:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const896] ; 438
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5231:
	; Computing bound for 'p'
	mov rax, [rel const1] ; 1
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5232
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5232:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5233:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5234
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5234:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5235
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5235:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump5236
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5236:
	imul rdi, [rsp + 0 + 16] ; multiply by 1 
	jno .jump5237
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5237:
	imul rdi, [rsp + 0 + 24] ; multiply by 438 
	jno .jump5238
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5238:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5239: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5239 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5239 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5239 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5239 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 40
	call _jpl_alloc
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5240
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump5240:
	push rax
	pop rax
	cmp rax, 0
	je .jump5241
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5243:
	; Computing bound for 'o'
	mov rax, [rel const548] ; 41
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5244
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5244:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5245:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5246: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5246 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5246 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5246 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump5242
.jump5241:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5242:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5247
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5247:
	cmp rax, [rsp + 8]
	jl .jump5248
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5248:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5249
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5250
.jump5249:
	mov rax, [rel const897] ; 624
	push rax
.jump5250:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5251:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then i else 624) 
	jno .jump5252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5252:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5253: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5254
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5254:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5255:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump5256: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5256 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5256 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5253 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5257
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5257:
	cmp rax, [rsp + 8]
	jl .jump5258
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5258:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5259
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump5259:
	cqo
	idiv r10
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5260
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5260:
	cmp rax, [rsp + 32]
	jl .jump5261
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5261:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5262
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5262:
	cmp rax, [rsp + 40]
	jl .jump5263
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5263:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5264
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5264:
	cmp rax, [rsp + 48]
	jl .jump5265
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5265:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5266
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5266:
	cmp rax, [rsp + 56]
	jl .jump5267
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5267:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5268
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5268:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by [(array[n : i, o : d(), p : 1, q : 438] i)][(if (a && true) then (sum[n : f(), o : 41, p : d()] n) else i)][f(), (d() / d()), (array[n : (if true then i else 624)] (sum[o : d(), p : d()] p))[i], f()] 
	jno .jump5269
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5269:
imul rdi, [rsp + 0 + 8] ; multiply by (array[n : d(), o : d(), p : d()] i)[(if (if false then a else true) then (- i) else i), (939 * 895), f()] 
	jno .jump5270
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5270:
	imul rdi, [rsp + 0 + 16] ; multiply by 629 
	jno .jump5271
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5271:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5272: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5273
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5273:
	; Computing bound for 'q'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5274:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5275:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5276:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5277: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5277 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5277 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const734] ; 310
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5278
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5278:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5279:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5280
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5280:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5281: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5281 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5281 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5281 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5282:
	cmp rax, [rsp + 16]
	jl .jump5283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5283:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5284:
	cmp rax, [rsp + 24]
	jl .jump5285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5285:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5286:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5287: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5287 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5272 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5272 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5272 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5211
.jump5210:
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5288
	mov rax, [rel const15] ; 835
	push rax
	jmp .jump5289
.jump5288:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5289:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5290:
	cmp rax, [rsp + 8]
	jl .jump5291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5291:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5292
	call _f
	push rax
	jmp .jump5293
.jump5292:
	mov rax, [rel const734] ; 310
	push rax
.jump5293:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5294:
	cmp rax, [rsp + 8]
	jl .jump5295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5295:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5296
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5298
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump5299
.jump5298:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5299:
	pop rax
	cmp rax, 0
	je .jump5300
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5301
.jump5300:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump5301:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5302
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5302:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5303:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump5304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5304:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (if c then c else c) then d() else d()) 
	jno .jump5305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5305:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5306: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const566] ; 926
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5307
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5307:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5308 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5309:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5310
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5310:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5311:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5312:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump5313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5313:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[p : 926] i) 
	jno .jump5314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5314:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5315: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const898] ; 77.36
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5315 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5315 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5315 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5306 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5306 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5297
.jump5296:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5316
	mov rax, [rel const899] ; 584
	push rax
	jmp .jump5317
.jump5316:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const900] ; 627
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5318:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5319: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5319 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump5317:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5320
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5320:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5321:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5322:
imul rdi, [rsp + 0 + 8] ; multiply by (if a then 584 else (sum[n : 627] i)) 
	jno .jump5323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5323:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5324: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5325:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5326
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5326:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5327:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5328:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump5329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5329:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5330:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5331: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5332
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5332:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5333:
	; Computing bound for 't'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5334
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5334:
	; Computing bound for 's'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump5336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5336 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5336 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5336 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5336 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5331 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5331 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5331 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5324 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5324 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5297:
	mov rax, [rel const272] ; 737
	push rax
	mov rax, [rel const901] ; 216
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5337:
	cmp rax, [rsp + 16]
	jl .jump5338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5338:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5339:
	cmp rax, [rsp + 24]
	jl .jump5340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5340:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5211:
	mov rax, [rel const902] ; 838
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5341:
	cmp rax, [rsp + 24]
	jl .jump5342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5342:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5343:
	cmp rax, [rsp + 32]
	jl .jump5344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5344:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5345:
	cmp rax, [rsp + 40]
	jl .jump5346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5346:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5347
	mov rax, [rel const903] ; 24.02
	push rax
	mov rax, [rel const904] ; 51.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump5347:
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5348
	mov rax, [rel const592] ; 946
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5350:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const905] ; 801
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5351:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5352
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5352:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5353:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5354
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5354:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5355: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5355 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5355 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5355 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5355 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5356
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5358
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5358:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() - d()) 
	jno .jump5359
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5359:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5360: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5360 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5357
.jump5356:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const738] ; 55
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5361
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5361:
	; Computing bound for 'p'
	mov rax, [rel const906] ; 791
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5362:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5363
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5363:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5364:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5365:
	imul rdi, [rsp + 0 + 8] ; multiply by (d() * d()) 
	jno .jump5366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5366:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 791) 
	jno .jump5367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5367:
	imul rdi, [rsp + 0 + 24] ; multiply by (55 - d()) 
	jno .jump5368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5368:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5369: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5369 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5369 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5369 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5369 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5370:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5371: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5371 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5372
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump5373
.jump5372:
	mov rax, [rel const45] ; False
	push rax
.jump5373:
	pop rax
	cmp rax, 0
	je .jump5374
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump5375
.jump5374:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5375:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const907] ; 829
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5376
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump5376:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5377:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5378: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const730] ; 579
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5378 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5379:
	cmp rax, [rsp + 32]
	jl .jump5380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5380:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5381:
	cmp rax, [rsp + 40]
	jl .jump5382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5382:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5383:
	cmp rax, [rsp + 48]
	jl .jump5384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5384:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5385:
	cmp rax, [rsp + 56]
	jl .jump5386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5386:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5357:
	jmp .jump5349
.jump5348:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5387
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5388
.jump5387:
	mov rax, [rel const287] ; 381
	push rax
	pop rax
	neg rax
	push rax
.jump5388:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5389
	mov rax, [rel const4] ; 798
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump5390
.jump5389:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5390:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5391
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5391:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if (i < i) then (d() - 798) else i) - (if a then f() else (- 381))) 
	jno .jump5392
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5392:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5393: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5394:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump5395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5395 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const711] ; 773
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5396:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5393 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5349:
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5397:
	cmp rax, [rsp + 8]
	jl .jump5398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5398:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5399:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5400: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5401
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5401:
	push rax
	pop rax
	cmp rax, 0
	je .jump5402
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump5403
.jump5402:
	mov rax, [rel const908] ; 0.01
	push rax
	mov rax, [rel const909] ; 96.04
	push rax
	mov rax, [rel const910] ; 82.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5404
	mov rax, [rel const911] ; 97.32
	push rax
	jmp .jump5405
.jump5404:
	mov rax, [rel const912] ; 49.0
	push rax
.jump5405:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump5403:
	mov rax, [rel const913] ; 80.01
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5400 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 8 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5406:
	cmp rax, [rsp + 8]
	jl .jump5407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5407:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5408:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5409:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5410: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5411
	mov rax, [rel const641] ; 824
	push rax
	jmp .jump5412
.jump5411:
	call _f
	push rax
.jump5412:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5410 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5413
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5413:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5414:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5415: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5415 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5415 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5415 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5416
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const914] ; 713
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5418:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5419
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5421:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5422
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5422:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5423: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5423 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5423 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump5420
.jump5419:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump5420:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5424
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5424:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5425:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5426: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5426 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5426 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5427:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5428
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5428:
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5429
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5429:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5430
	mov rax, [rel const196] ; 72
	push rax
	jmp .jump5431
.jump5430:
	call _f
	push rax
.jump5431:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5432:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5433:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5434: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5434 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5435
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5435:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[n : d()] i) 
	jno .jump5436
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5436:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (i == i) then 72 else f()) 
	jno .jump5437
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5437:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5438
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5438:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5439: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5440
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5441
.jump5440:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5441:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5439 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5439 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5439 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const303] ; 440
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5442
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5442:
	; Computing bound for 'p'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5443:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5444
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5444:
	; Computing bound for 'n'
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (f() + d()) 
	jno .jump5446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5446:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump5447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5447:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump5448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5448:
	imul rdi, [rsp + 0 + 24] ; multiply by 440 
	jno .jump5449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5449:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5450: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5450 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5450 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5450 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5450 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const851] ; 854
	push rax
	mov rax, [rel const301] ; 566
	push rax
	mov rax, [rel const915] ; 963
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5451:
	cmp rax, [rsp + 32]
	jl .jump5452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5452:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5453:
	cmp rax, [rsp + 40]
	jl .jump5454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5454:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5455:
	cmp rax, [rsp + 48]
	jl .jump5456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5456:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5457:
	cmp rax, [rsp + 56]
	jl .jump5458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5458:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5459:
	cmp rax, [rsp + 24]
	jl .jump5460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5460:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5461:
	cmp rax, [rsp + 32]
	jl .jump5462
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5462:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5463:
	cmp rax, [rsp + 40]
	jl .jump5464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5464:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5465:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5466:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5467:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5468
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5468:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const746] ; 806
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5469
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5469:
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5470:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5471
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5471:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5472:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump5473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5473:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump5474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5474:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5475:
	imul rdi, [rsp + 0 + 24] ; multiply by 806 
	jno .jump5476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5476:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5477: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5477 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5477 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5477 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5477 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const916] ; 191
	push rax
	mov rax, [rel const917] ; 291
	push rax
	mov rax, [rel const126] ; 16
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5478
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5478:
	; Computing bound for 'p'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5479:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5480
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5480:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5481:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5482: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5482 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5482 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5482 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5482 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5483:
	cmp rax, [rsp + 32]
	jl .jump5484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5484:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5485:
	cmp rax, [rsp + 40]
	jl .jump5486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5486:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5487:
	cmp rax, [rsp + 48]
	jl .jump5488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5488:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5489:
	cmp rax, [rsp + 56]
	jl .jump5490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5490:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5491:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5492: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5492 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5492 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5492 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5493
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5493:
	; Computing bound for 'o'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5494:
	; Computing bound for 'n'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5495
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump5496
.jump5495:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5497
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump5497:
	push rax
	pop rax
	cmp rax, 0
	je .jump5498
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5499
.jump5498:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5499:
.jump5496:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5500
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5500:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5501: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5502
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5503:
	cmp rax, [rsp + 24]
	jl .jump5504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5504:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5505:
	cmp rax, [rsp + 32]
	jl .jump5506
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5506:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5507:
	cmp rax, [rsp + 40]
	jl .jump5508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5508:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump5502:
	push rax
	pop rax
	cmp rax, 0
	je .jump5509
	mov rax, [rel const918] ; 683
	push rax
	jmp .jump5510
.jump5509:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump5510:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5501 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5501 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5501 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5501 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5511
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5511:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5512: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5512 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5512 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5512 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5512 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5513
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5513:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[n : (sum[n : (if false then (- i) else (if (a && true) then d() else i)), o : (- d()), p : (sum[n : (array[n : f(), o : d(), p : d(), q : 806] n)[(sum[n : i, o : i, p : f(), q : f()] q), 16, 291, 191], o : i, p : i] d()), q : i] (if ((! a) || l[i, q, p]) then 683 else q)), o : (array[n : (sum[n : d()] i), o : (if (i == i) then 72 else f()), p : d()] (if a then d() else i))[d(), ((- f()) - d()), (array[n : (f() + d()), o : f(), p : f(), q : 440] f())[963, 566, 854, i]], p : d(), q : (- (sum[n : i, o : (if (true != c) then (sum[n : d(), o : d()] d()) else f())] o))] p) 
	jno .jump5514
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5514:
	imul rdi, [rsp + 0 + 8] ; multiply by 713 
	jno .jump5515
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5515:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5516: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5516 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5516 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5517
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5517:
	cmp rax, [rsp + 16]
	jl .jump5518
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5518:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5519
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5519:
	cmp rax, [rsp + 24]
	jl .jump5520
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5520:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5417
.jump5416:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5521
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5523:
	; Computing bound for 'p'
	mov rax, [rel const919] ; 608
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5524
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5524:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5525
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5525:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5526: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5526 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5527:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5528:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5529: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5529 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5530
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5530:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5531: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5532:
	cmp rax, [rsp + 24]
	jl .jump5533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5533:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5534:
	cmp rax, [rsp + 32]
	jl .jump5535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5535:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5536:
	cmp rax, [rsp + 40]
	jl .jump5537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5537:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5538
	call _f
	push rax
	jmp .jump5539
.jump5538:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5540
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5540:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump5541: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5541 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump5539:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5531 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5531 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5531 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5531 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const920] ; 489
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump5522
.jump5521:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5522:
	pop rax
	cmp rax, 0
	je .jump5542
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const921] ; 724
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5544:
	; Computing bound for 'n'
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const871] ; 912
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5545
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5545:
	cmp rax, [rsp + 8]
	jl .jump5546
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5546:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5547
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const922] ; 766
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5549:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5550
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5550:
	; Computing bound for 'o'
	mov rax, [rel const923] ; 497
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5551:
	; Computing bound for 'n'
	mov rax, [rel const316] ; 226
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5552
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5552:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 226 
	jno .jump5553
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5553:
	imul rdi, [rsp + 0 + 8] ; multiply by 497 
	jno .jump5554
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5554:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5555
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5555:
	imul rdi, [rsp + 0 + 24] ; multiply by 766 
	jno .jump5556
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5556:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5557: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const687] ; 527
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5558
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5558:
	; Computing bound for 's'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5559:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5560
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5560:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5561
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5561:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump5562
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5562:
	imul rdi, [rsp + 0 + 16] ; multiply by 527 
	jno .jump5563
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5563:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump5564: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5564 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5564 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5564 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5557 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5557 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5557 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5557 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5565
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5565:
	cmp rax, [rsp + 8]
	jl .jump5566
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5566:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5567
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump5567:
	cqo
	idiv r10
	push rax
	mov rax, [rel const644] ; 341
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5568:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5569
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5569:
	; Computing bound for 'n'
	mov rax, [rel const916] ; 191
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5570:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5571: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const924] ; 880
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5571 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5571 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5571 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5572
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5572:
	cmp rax, [rsp + 32]
	jl .jump5573
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5573:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5574
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5574:
	cmp rax, [rsp + 40]
	jl .jump5575
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5575:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5576
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5576:
	cmp rax, [rsp + 48]
	jl .jump5577
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5577:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5578
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5578:
	cmp rax, [rsp + 56]
	jl .jump5579
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5579:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5548
.jump5547:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5580
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5580:
	; Computing bound for 'p'
	mov rax, [rel const925] ; 81
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5581:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5582
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5582:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5583:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5584: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5584 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5584 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5584 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5584 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5585:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5586
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5586:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5587
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5587:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[n : d(), o : f(), p : 81, q : i] i) 
	jno .jump5588
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5588:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5589: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5590
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5590:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5591:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5592
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5592:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5593
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5593:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump5594
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5594:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump5595
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5595:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5596: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5596 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5596 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5596 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5589 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5589 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	mov rax, [rel const926] ; 274
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5597
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5597:
	cmp rax, [rsp + 16]
	jl .jump5598
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5598:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5599
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5599:
	cmp rax, [rsp + 24]
	jl .jump5600
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5600:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5548:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5601
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5601:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5602:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5603
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5603:
	; Computing bound for 'o'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5604
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5604:
	push rax
	pop rax
	cmp rax, 0
	je .jump5605
	mov rax, [rel const426] ; 62
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump5606
.jump5605:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5607
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5607:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5608: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5608 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump5606:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5609:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5610:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5611
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5611:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5612:
	; Computing bound for 'n'
	mov rax, [rel const748] ; 391
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5613
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5613:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 391 
	jno .jump5614
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5614:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump5615
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5615:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5616
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5616:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump5617
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5617:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5618: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const927] ; 433
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5618 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5618 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5618 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5618 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const784] ; 993
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5619:
	; Computing bound for 'o'
	mov rax, [rel const268] ; 623
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5620
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5620:
	; Computing bound for 'n'
	mov rax, [rel const446] ; 820
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5621:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5622: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5622 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5622 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5622 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5623
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5623:
	cmp rax, [rsp + 32]
	jl .jump5624
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5624:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5625
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5625:
	cmp rax, [rsp + 40]
	jl .jump5626
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5626:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5627
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5627:
	cmp rax, [rsp + 48]
	jl .jump5628
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5628:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5629
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5629:
	cmp rax, [rsp + 56]
	jl .jump5630
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5630:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5631
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5631:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5632: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5632 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5632 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5632 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5633:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5634: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5634 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5634 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const928] ; 615
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5635:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5636
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump5637
.jump5636:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5637:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5638
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5638:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5639:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5640: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5641
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5641:
	; Computing bound for 'q'
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5642
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump5642:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5643:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5644: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const559] ; 113
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5645:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5646
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5646:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump5647: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const620] ; 22
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5647 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5647 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5644 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5644 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5640 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5640 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5640 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5648
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5648:
	cmp rax, [rsp + 24]
	jl .jump5649
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5649:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5650
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5650:
	cmp rax, [rsp + 32]
	jl .jump5651
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5651:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5652
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5652:
	cmp rax, [rsp + 40]
	jl .jump5653
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5653:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5654
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5654:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if k[(- 912)] then (array[n : 226, o : 497, p : d(), q : 766] (array[r : q, s : f(), t : 527] d()))[(sum[n : (- 191), o : (i + d()), p : d()] (880 * n)), (- (- i)), 341, (h[i] / i)] else (array[n : d(), o : (sum[n : d(), o : f(), p : 81, q : i] i)] (array[p : i, q : n, r : n] d()))[(- 274), d()])[(sum[n : d(), o : (- (if a then (- d()) else i)), p : (- 615)] (sum[q : (p % d()), r : i] (d() * (sum[s : q, t : 113] 22)))), (sum[n : (sum[n : (array[n : 391, o : d(), p : i, q : d()] 433)[d(), d(), (sum[n : 820, o : 623, p : 993] n), i], o : (if (false && a) then (- 62) else (sum[n : i] i)), p : (i % d())] (p - o)), o : d()] n), f()] 
	jno .jump5655
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5655:
	imul rdi, [rsp + 0 + 8] ; multiply by 724 
	jno .jump5656
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5656:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5657: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5658
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5660
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const929] ; 96.46
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5661
.jump5660:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump5661:
	mov rax, [rel const930] ; 70.72
	push rax
	mov rax, [rel const931] ; 57.36
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump5659
.jump5658:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5662
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump5663
.jump5662:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump5663:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5664
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump5666
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5667
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5667:
	push rax
	pop rax
.jump5666:
	push rax
	jmp .jump5665
.jump5664:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5665:
	pop rax
	cmp rax, 0
	je .jump5668
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5670:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5671:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5672: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const190] ; 510
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5672 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5673
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5673:
	; Computing bound for 'q'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5674:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5675
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5675:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5676: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5677
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump5678
.jump5677:
	mov rax, [rel const932] ; 90.45
	push rax
.jump5678:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5676 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5676 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5676 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5676 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const933] ; 60.09
	push rax
	mov rax, [rel const173] ; 60.85
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const934] ; 92.11
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const935] ; 48.81
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5669
.jump5668:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5679
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5679:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5680:
	; Computing bound for 'p'
	mov rax, [rel const936] ; 976
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5681
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5681:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5682: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const937] ; 9.68
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5682 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5682 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5682 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5683:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5684
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5684:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5685
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump5685:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5686:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5687 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5687 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5687 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const938] ; 53.29
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5688:
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5689:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5690: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5690 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5691
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5691:
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5692:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5693: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5693 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5693 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5693 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump5669:
.jump5659:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5657 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5657 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5543
.jump5542:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5694:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5695
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5695:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5696
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5696:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump5697
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5697:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump5698: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5699
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5699:
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5700:
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5701:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5702
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5702:
	; Computing bound for 'p'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5703
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5703:
	; Computing bound for 'r'
	mov rax, [rel const93] ; 613
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5704:
	; Computing bound for 'q'
	mov rax, [rel const939] ; 362
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5705
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5705:
	; Computing bound for 'p'
	mov rax, [rel const459] ; 25
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5706:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 25 
	jno .jump5707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5707:
	imul rdi, [rsp + 0 + 8] ; multiply by 362 
	jno .jump5708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5708:
	imul rdi, [rsp + 0 + 16] ; multiply by 613 
	jno .jump5709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5709:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump5710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5710:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5711: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5711 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5711 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5711 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5711 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5712:
	cmp rax, [rsp + 32]
	jl .jump5713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5713:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5714:
	cmp rax, [rsp + 40]
	jl .jump5715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5715:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5716:
	cmp rax, [rsp + 48]
	jl .jump5717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5717:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5718:
	cmp rax, [rsp + 56]
	jl .jump5719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5719:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5720:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5721: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5721 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5721 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5721 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5722
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5722:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5723
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5725
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5725:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5726:
	; Computing bound for 'p'
	mov rax, [rel const940] ; 505
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5727
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5727:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5728: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5728 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5728 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5728 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump5724
.jump5723:
	mov rax, [rel const941] ; 943
	push rax
.jump5724:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5729:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (m <= m) then (sum[p : 505, q : i, r : i] q) else 943) 
	jno .jump5730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5730:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[p : (array[p : 25, q : 362, r : 613, s : d()] p)[i, n, f(), n], q : (- f()), r : f()] i) 
	jno .jump5731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5731:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5732:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump5733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5733:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5734: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5735
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5735:
	cmp rax, [rsp + 16]
	jl .jump5736
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5736:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5737
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5737:
	cmp rax, [rsp + 24]
	jl .jump5738
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5738:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5739
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump5740
.jump5739:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
.jump5740:
	mov rax, [rel const262] ; 526
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5741
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump5742
.jump5741:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
.jump5742:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5743
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5744
.jump5743:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5744:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5734 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5734 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5734 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5734 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5745
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5747
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump5748
.jump5747:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5749:
	; Computing bound for 'q'
	mov rax, [rel const530] ; 289
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5750
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5750:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5751:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5752: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5753:
	cmp rax, [rsp + 8]
	jl .jump5754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5754:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5752 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5752 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5752 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump5748:
	jmp .jump5746
.jump5745:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5746:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5755
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5755:
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5756:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5757
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5757:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5758:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5759:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5760:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump5761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5761:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump5762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5762:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5763: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5764:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5765
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5765:
	; Computing bound for 't'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5766:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5767:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5768:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump5769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5769:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump5770: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5770 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5770 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5770 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5763 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5763 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5763 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5763 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const6] ; 150
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5771:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump5772: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const942] ; 485
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5772 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5773:
	cqo
	idiv r10
	push rax
	call _d
	push rax
	mov rax, [rel const277] ; 109
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const943] ; 430
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5774
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump5774:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const215] ; 84
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5775:
	cmp rax, [rsp + 32]
	jl .jump5776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5776:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5777:
	cmp rax, [rsp + 40]
	jl .jump5778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5778:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5779:
	cmp rax, [rsp + 48]
	jl .jump5780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5780:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5781:
	cmp rax, [rsp + 56]
	jl .jump5782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5782:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5783:
	cmp rax, [rsp + 8]
	jl .jump5784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5784:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5785:
	cmp rax, [rsp + 24]
	jl .jump5786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5786:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5787:
	cmp rax, [rsp + 32]
	jl .jump5788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5788:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5789:
	cmp rax, [rsp + 40]
	jl .jump5790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5790:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5791:
	cmp rax, [rsp + 32]
	jl .jump5792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5792:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5793:
	cmp rax, [rsp + 40]
	jl .jump5794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5794:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5795:
	cmp rax, [rsp + 48]
	jl .jump5796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5796:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5797:
	cmp rax, [rsp + 56]
	jl .jump5798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5798:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5698 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5698 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5543:
.jump5417:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const944] ; 628
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5799:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5800
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5800:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5801:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5802
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5802:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5803:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5804:
	imul rdi, [rsp + 0 + 8] ; multiply by (- o) 
	jno .jump5805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5805:
	imul rdi, [rsp + 0 + 16] ; multiply by (d() + o) 
	jno .jump5806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5806:
	imul rdi, [rsp + 0 + 24] ; multiply by (d() / 628) 
	jno .jump5807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5807:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump5808: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5808 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5808 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5808 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5808 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5809
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5809:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5810:
	; Computing bound for 'w'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5811:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5812: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5812 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5813
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5813:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[w : t] u) 
	jno .jump5814
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5814:
	imul rdi, [rsp + 0 + 8] ; multiply by (- r) 
	jno .jump5815
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5815:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5816
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5816:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5817: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5818:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5819
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5819:
	; Computing bound for 'z'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5820:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5821: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5821 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5821 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5821 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5817 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5817 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5817 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5822:
	cmp rax, [rsp + 8]
	jl .jump5823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5823:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5824
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump5825
.jump5824:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump5825:
	pop rax
	cmp rax, 0
	je .jump5826
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump5827
.jump5826:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump5827:
	mov rax, [rel const803] ; 947
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5828:
	cmp rax, [rsp + 24]
	jl .jump5829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5829:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5830:
	cmp rax, [rsp + 32]
	jl .jump5831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5831:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5832:
	cmp rax, [rsp + 40]
	jl .jump5833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5833:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5834:
	; Computing bound for 'w'
	mov rax, [rel const616] ; 944
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5835
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5835:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 944 
	jno .jump5836
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5836:
	imul rdi, [rsp + 0 + 8] ; multiply by (- ((- s) * f())) 
	jno .jump5837
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5837:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5838: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5838 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5838 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5839
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5839:
	cmp rax, [rsp + 16]
	jl .jump5840
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5840:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5841
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5841:
	cmp rax, [rsp + 24]
	jl .jump5842
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5842:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5843
	mov rax, [rel const1] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5845
	mov rax, [rel const531] ; 337
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump5846
.jump5845:
	mov rax, [rel const945] ; 38.58
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5847:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5848
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5848:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5849:
	; Computing bound for 'w'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5850
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5850:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5851: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5851 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5851 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5851 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5851 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5852
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5852:
	push rax
.jump5846:
	pop rax
	cmp rax, 0
	jne .jump5853
	call _f
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5854
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump5855
.jump5854:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump5855:
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5856
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5856:
	push rax
	pop rax
.jump5853:
	push rax
	pop rax
	cmp rax, 0
	je .jump5857
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5859
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5859:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5860
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5860:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5861: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	mov rax, [rel const946] ; 778
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5862:
	; Computing bound for 'z'
	mov rax, [rel const940] ; 505
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5863
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5863:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5864:
	; Computing bound for 'x'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5865
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5865:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5866
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5866:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5867
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5867:
	imul rdi, [rsp + 0 + 16] ; multiply by 505 
	jno .jump5868
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5868:
	imul rdi, [rsp + 0 + 24] ; multiply by 778 
	jno .jump5869
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5869:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump5870: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5871:
	cmp rax, [rsp + 32]
	jl .jump5872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5872:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5873:
	cmp rax, [rsp + 40]
	jl .jump5874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5874:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5875:
	cmp rax, [rsp + 48]
	jl .jump5876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5876:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5877:
	cmp rax, [rsp + 56]
	jl .jump5878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5878:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5870 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5870 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5870 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5870 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5861 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5879
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5881
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5883
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5883:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5884
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5884:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5885: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5885 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5882
.jump5881:
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
.jump5882:
	jmp .jump5880
.jump5879:
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
.jump5880:
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 2
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5886:
	cmp rax, [rsp + 8]
	jl .jump5887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5887:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5858
.jump5857:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5888
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5890:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5891
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5891:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5892
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5892:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump5893
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5893:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5894: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5894 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5894 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5895
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5895:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5896:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5897:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5898:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5899: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5899 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5899 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5900:
	cmp rax, [rsp + 16]
	jl .jump5901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5901:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5902:
	cmp rax, [rsp + 24]
	jl .jump5903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5903:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const947] ; 9.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5904
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5905
.jump5904:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump5905:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5906
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5906:
	cmp rax, [rsp + 16]
	jl .jump5907
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5907:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5908
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5908:
	cmp rax, [rsp + 24]
	jl .jump5909
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5909:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5910
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5910:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[w : p, x : r] t)[(if (9.97 > m) then r else d()), (array[w : p, x : s] w)[r, t]] 
	jno .jump5911
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5911:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5912: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const948] ; 71.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5913
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5914
.jump5913:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5915:
	; Computing bound for 'z'
	mov rax, [rel const530] ; 289
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5916
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5916:
	; Computing bound for 'y'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5917:
	; Computing bound for 'x'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5918
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5918:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump5919
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5919:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump5920
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5920:
	imul rdi, [rsp + 0 + 16] ; multiply by 289 
	jno .jump5921
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5921:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump5922
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5922:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump5923: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5923 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5923 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5923 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5923 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5924
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5924:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5925:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5926
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5926:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump5927: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 16], 1
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5927 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5927 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5927 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5928
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5928:
	cmp rax, [rsp + 32]
	jl .jump5929
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5929:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5930
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5930:
	cmp rax, [rsp + 40]
	jl .jump5931
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5931:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5932
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5932:
	cmp rax, [rsp + 48]
	jl .jump5933
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5933:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5934
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5934:
	cmp rax, [rsp + 56]
	jl .jump5935
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5935:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5914:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5912 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5889
.jump5888:
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5936:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5937:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5938
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5938:
	; Computing bound for 'w'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5939:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump5940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5940:
	imul rdi, [rsp + 0 + 8] ; multiply by (p / u) 
	jno .jump5941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5941:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5942:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5943: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5943 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5943 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5943 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5944
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5944:
	cmp rax, [rsp + 24]
	jl .jump5945
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5945:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5946
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5946:
	cmp rax, [rsp + 32]
	jl .jump5947
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5947:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5948
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5948:
	cmp rax, [rsp + 40]
	jl .jump5949
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5949:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5950
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5952:
	cmp rax, [rsp + 24]
	jl .jump5953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5953:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5954:
	cmp rax, [rsp + 32]
	jl .jump5955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5955:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5956:
	cmp rax, [rsp + 40]
	jl .jump5957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5957:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5951
.jump5950:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5951:
	pop rax
	cmp rax, 0
	je .jump5958
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5959
.jump5958:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5960
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5960:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5961:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5962
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5962:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5963:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5964:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5965:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5966:
	imul rdi, [rsp + 0 + 24] ; multiply by t 
	jno .jump5967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5967:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5968: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5969
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump5970
.jump5969:
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump5970:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5968 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5968 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5968 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5968 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5959:
	mov rdi, 120
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 120 bytes from rsp to rax 
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 120
	push rax
	mov rax, 3
	push rax
.jump5889:
.jump5858:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5971:
	cmp rax, [rsp + 8]
	jl .jump5972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5972:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5844
.jump5843:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5973:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5974:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,][,,,][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- p) 
	jno .jump5975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5975:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5976:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump5977: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5978:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5979
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump5979:
	cmp rax, [rsp + 8]
	jl .jump5980
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump5980:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5981
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5981:
	; Computing bound for 'y'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5982:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,][,,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump5983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5983:
	imul rdi, [rsp + 0 + 8] ; multiply by [t, w, u][o] 
	jno .jump5984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5984:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5985:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump5986: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5987:
	cmp rax, [rsp + 8]
	jl .jump5988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5988:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5989
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5991
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5991:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5992:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5993
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5993:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump5994
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5994:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5995
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5995:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5996
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump5996:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5997: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5997 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5997 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5997 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5990
.jump5989:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5998
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5998:
	; Computing bound for 'C'
	mov rax, [rel const417] ; 306
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5999:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6000
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6000:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump6001
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6001:
	imul rdi, [rsp + 0 + 8] ; multiply by 306 
	jno .jump6002
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6002:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump6003
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6003:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6004: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6004 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6004 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6004 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5990:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5986 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5986 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5986 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5977 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5977 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6005:
	cmp rax, [rsp + 16]
	jl .jump6006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6006:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6007:
	cmp rax, [rsp + 24]
	jl .jump6008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6008:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6009
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6009:
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6010
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6010:
	; Computing bound for 'x'
	mov rax, [rel const900] ; 627
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6011:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6012
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6012:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump6013: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6013 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6013 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6013 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6014:
	; Computing bound for 'x'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6015
	mov rax, [rel const949] ; 8.75
	push rax
	mov rax, [rel const950] ; 95.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump6016
.jump6015:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump6016:
	pop rax
	cmp rax, 0
	je .jump6017
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump6018
.jump6017:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6018:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6019
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6019:
	; Computing bound for 'w'
	mov rax, [rel const951] ; 837
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6020:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump6021: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6021 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6021 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6021 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6021 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump6022
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6023
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump6024
.jump6023:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6025
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6025:
	push rax
.jump6024:
	pop rax
.jump6022:
	push rax
	pop rax
	cmp rax, 0
	je .jump6026
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump6027
.jump6026:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6028:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump6027:
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6029
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6029:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6030:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const98] ; 934
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6031:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6032
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6032:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6033:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump6034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6034:
	imul rdi, [rsp + 0 + 8] ; multiply by (934 % o) 
	jno .jump6035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6035:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump6036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6036:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump6037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6037:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump6038: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6038 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6038 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6038 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6038 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6039:
	cqo
	idiv r10
	push rax
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6040:
	cmp rax, [rsp + 32]
	jl .jump6041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6041:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6042:
	cmp rax, [rsp + 40]
	jl .jump6043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6043:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6044:
	cmp rax, [rsp + 48]
	jl .jump6045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6045:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6046:
	cmp rax, [rsp + 56]
	jl .jump6047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6047:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6048:
	cmp rax, [rsp + 24]
	jl .jump6049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6049:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6050:
	cmp rax, [rsp + 32]
	jl .jump6051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6051:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6052:
	cmp rax, [rsp + 40]
	jl .jump6053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6053:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6054:
	cmp rax, [rsp + 24]
	jl .jump6055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6055:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6056:
	cmp rax, [rsp + 32]
	jl .jump6057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6057:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6058:
	cmp rax, [rsp + 40]
	jl .jump6059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6059:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5844:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6060:
	; Computing bound for 'D'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6061
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump6062
.jump6061:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump6062:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6063:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6064
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6064:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6065:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6066
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6066:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump6067
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6067:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump6068
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6068:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if a then x else y) % d()) 
	jno .jump6069
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6069:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump6070
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6070:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6071: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6072:
	cmp rax, [rsp + 32]
	jl .jump6073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6073:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6074:
	cmp rax, [rsp + 40]
	jl .jump6075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6075:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6076:
	cmp rax, [rsp + 48]
	jl .jump6077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6077:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6078:
	cmp rax, [rsp + 56]
	jl .jump6079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6079:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6071 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6071 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6071 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6071 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	mov rax, [rel const456] ; 242
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6080
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6080:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6081:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6082
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6082:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6083:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6084:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump6085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6085:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump6086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6086:
	imul rdi, [rsp + 0 + 24] ; multiply by 242 
	jno .jump6087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6087:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6088: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6089:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- t) 
	jno .jump6090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6090:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6091: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 152 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6092:
	cmp rax, [rsp + 32]
	jl .jump6093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6093:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6094:
	cmp rax, [rsp + 40]
	jl .jump6095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6095:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6096:
	cmp rax, [rsp + 48]
	jl .jump6097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6097:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6098:
	cmp rax, [rsp + 56]
	jl .jump6099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6099:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6091 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6088 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6088 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6088 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6088 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6100:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6101
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6101:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6102:
	; Computing bound for 'B'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6103
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6104
.jump6103:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump6104:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6105
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6105:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (f() != d()) then d() else r) 
	jno .jump6106
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6106:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump6107
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6107:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump6108
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6108:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump6109
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6109:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6110: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6111
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6111:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6112:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6113
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6113:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump6114
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6114:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump6115
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6115:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump6116
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6116:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6117: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6117 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6117 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6117 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6118
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6118:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6119:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6120
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6120:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump6121
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6121:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump6122
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6122:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6123
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6123:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6124: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6124 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6124 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6124 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6110 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6110 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6110 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6110 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 120
	call _jpl_alloc
	; Moving 120 bytes from rsp to rax 
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 120
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6125
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6125:
	cmp rax, [rsp + 8]
	jl .jump6126
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6126:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6127
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6128
.jump6127:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6129
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6129:
	; Computing bound for 'D'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6130:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6131
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump6132
.jump6131:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump6132:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6133
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6133:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6134:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6135:
	imul rdi, [rsp + 0 + 8] ; multiply by (if c then s else x) 
	jno .jump6136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6136:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d()) 
	jno .jump6137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6137:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump6138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6138:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6139: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6140:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6141
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6141:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump6142
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6142:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump6143
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6143:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6144: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const952] ; 327
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6144 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6144 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6139 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6139 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6139 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6139 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6145:
	cmp rax, [rsp + 32]
	jl .jump6146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6146:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6147:
	cmp rax, [rsp + 40]
	jl .jump6148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6148:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6149:
	cmp rax, [rsp + 48]
	jl .jump6150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6150:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6151:
	cmp rax, [rsp + 56]
	jl .jump6152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6152:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const953] ; 37
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6153:
	cmp rax, [rsp + 16]
	jl .jump6154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6154:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6155:
	cmp rax, [rsp + 24]
	jl .jump6156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6156:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6128:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6157
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6157:
	cmp rax, [rsp + 32]
	jl .jump6158
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6158:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6159
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6159:
	cmp rax, [rsp + 40]
	jl .jump6160
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6160:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6161
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6161:
	cmp rax, [rsp + 48]
	jl .jump6162
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6162:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6163
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6163:
	cmp rax, [rsp + 56]
	jl .jump6164
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6164:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6165
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6165:
	cmp rax, [rsp + 8]
	jl .jump6166
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6166:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6167
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6167:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6168
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6168:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6169: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6169 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 152 ; Local variables
	pop rbp
	ret
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const954] ; 2.45
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const955] ; 82.78
	push rax
	mov rax, [rel const956] ; 52.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6170
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump6170:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6171
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump6172
.jump6171:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6173
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump6174
.jump6173:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump6174:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6175
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6175:
	; Computing bound for 'B'
	mov rax, [rel const160] ; 895
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6176:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6177: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6178
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump6179
.jump6178:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump6179:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6177 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6177 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const957] ; 19.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump6172:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6180
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6182
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6182:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump6183
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6183:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6184: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6185:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6186
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6186:
	; Computing bound for 'D'
	mov rax, [rel const958] ; 137
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6187:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6188
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6188:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6189
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6189:
	imul rdi, [rsp + 0 + 8] ; multiply by 137 
	jno .jump6190
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6190:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump6191
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6191:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump6192
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6192:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump6193: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6193 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6193 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6193 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6193 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6184 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6194:
	cmp rax, [rsp + 8]
	jl .jump6195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6195:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6196
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump6197
.jump6196:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump6197:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6198
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6198:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6199
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6199:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6200: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6200 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6201:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6202: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6202 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6202 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump6203
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6203:
	push rax
	pop rax
	cmp rax, 0
	je .jump6204
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6205
.jump6204:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6206:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump6207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6207:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6208: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6208 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump6205:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6209
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6209:
	cmp rax, [rsp + 8]
	jl .jump6210
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6210:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6211:
	cmp rax, [rsp + 32]
	jl .jump6212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6212:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6213:
	cmp rax, [rsp + 40]
	jl .jump6214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6214:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6215:
	cmp rax, [rsp + 48]
	jl .jump6216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6216:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6217:
	cmp rax, [rsp + 56]
	jl .jump6218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6218:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6219:
	; Computing bound for 'B'
	mov rax, [rel const109] ; 212
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6220
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6220:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (t - (- 212)) 
	jno .jump6221
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6221:
imul rdi, [rsp + 0 + 8] ; multiply by (array[B : y] (array[C : x, D : 137, E : z, F : i] t))[u][f(), (if (false || a) then h else (array[B : A] t))[(- d())], (sum[B : (sum[B : d()] t), C : A] u), (if c then r else u)] 
	jno .jump6222
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6222:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6223: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6224
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
.jump6224:
	push rax
	pop rax
	cmp rax, 0
	je .jump6225
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump6226
.jump6225:
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump6226:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6223 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6223 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6181
.jump6180:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	mov rax, [rel const289] ; 139
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6227:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6228
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6228:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6229:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	mov rax, [rel const787] ; 542
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6230:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6231
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6231:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6232:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6233
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6233:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6234: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6234 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6234 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6234 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6234 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6235
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6235:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[][,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[B : (- x), C : u, D : p, E : 542] A) 
	jno .jump6236
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6236:
	imul rdi, [rsp + 0 + 8] ; multiply by (- A) 
	jno .jump6237
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6237:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump6238
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6238:
	imul rdi, [rsp + 0 + 24] ; multiply by 139 
	jno .jump6239
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6239:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6240: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6241
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6243
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6245
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6245:
	; Computing bound for 'F'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6246:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump6247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6247:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump6248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6248:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6249: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6249 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6249 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6244
.jump6243:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6250:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6251:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump6252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6252:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump6253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6253:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6254: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6254 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6254 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6244:
	jmp .jump6242
.jump6241:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	mov rax, [rel const15] ; 835
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6255
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6255:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6256:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump6257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6257:
	imul rdi, [rsp + 0 + 8] ; multiply by 835 
	jno .jump6258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6258:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6259: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6259 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6259 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6242:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6240 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6240 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6240 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6240 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6260
	mov rax, [rel const959] ; 215
	push rax
	jmp .jump6261
.jump6260:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump6261:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6262:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6263
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6265
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6267
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump6268
.jump6267:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump6268:
	jmp .jump6266
.jump6265:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump6266:
	jmp .jump6264
.jump6263:
	mov rax, [rel const75] ; 952
	push rax
.jump6264:
	mov rax, [rel const895] ; 939
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6269
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6269:
	cmp rax, [rsp + 32]
	jl .jump6270
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6270:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6271
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6271:
	cmp rax, [rsp + 40]
	jl .jump6272
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6272:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6273
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6273:
	cmp rax, [rsp + 48]
	jl .jump6274
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6274:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6275
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6275:
	cmp rax, [rsp + 56]
	jl .jump6276
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6276:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6181:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6277
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6277:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6278
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6278:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6279:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6280
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6280:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6281: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6281 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6281 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6281 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6282:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6283: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6284:
	; Computing bound for 'D'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6285
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6285:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump6286: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6286 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6286 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6283 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6283 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6287
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6289
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6290
	mov rax, [rel const1] ; True
	push rax
	jmp .jump6291
.jump6290:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump6291:
	pop rax
.jump6289:
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6292
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump6292:
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6293
	mov rax, [rel const960] ; 973
	push rax
	jmp .jump6294
.jump6293:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump6294:
	jmp .jump6288
.jump6287:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump6288:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6295
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6295:
	cmp rax, [rsp + 16]
	jl .jump6296
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6296:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6297
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6297:
	cmp rax, [rsp + 24]
	jl .jump6298
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6298:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6299:
	; Computing bound for 'C'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6300
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6300:
	; Computing bound for 'B'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6301:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6302:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump6303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6303:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump6304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6304:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6305: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6306
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6306:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6307:
	; Computing bound for 'F'
	mov rax, [rel const40] ; 77
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6308
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6308:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6309:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump6310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6310:
	imul rdi, [rsp + 0 + 8] ; multiply by 77 
	jno .jump6311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6311:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump6312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6312:
	imul rdi, [rsp + 0 + 24] ; multiply by B 
	jno .jump6313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6313:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6314: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6315:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6316
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6316:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump6317
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6317:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6318
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6318:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump6319: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6320
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump6321
.jump6320:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
.jump6321:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6319 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6319 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6314 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6314 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6314 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6314 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6322:
	cmp rax, [rsp + 32]
	jl .jump6323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6323:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6324:
	cmp rax, [rsp + 40]
	jl .jump6325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6325:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6326:
	cmp rax, [rsp + 48]
	jl .jump6327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6327:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6328:
	cmp rax, [rsp + 56]
	jl .jump6329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6329:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6330:
	cmp rax, [rsp + 16]
	jl .jump6331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6331:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6332:
	cmp rax, [rsp + 24]
	jl .jump6333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6333:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6305 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6305 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6305 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6334
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6334:
	cmp rax, [rsp + 8]
	jl .jump6335
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6335:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6336
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump6337
.jump6336:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump6337:
	pop rax
	cmp rax, 0
	jne .jump6338
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6339
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump6341
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6341:
	push rax
	jmp .jump6340
.jump6339:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump6340:
	pop rax
	cmp rax, 0
	je .jump6342
	mov rax, [rel const45] ; False
	push rax
	jmp .jump6343
.jump6342:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	mov rax, [rel const961] ; 805
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6344:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6345
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6345:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump6346
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6346:
	imul rdi, [rsp + 0 + 8] ; multiply by 805 
	jno .jump6347
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6347:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6348: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const962] ; 32.18
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6348 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6348 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6349
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6349:
	cmp rax, [rsp + 16]
	jl .jump6350
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6350:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6351
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6351:
	cmp rax, [rsp + 24]
	jl .jump6352
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6352:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const963] ; 89.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump6343:
	pop rax
.jump6338:
	push rax
	pop rax
	cmp rax, 0
	je .jump6353
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump6354
.jump6353:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump6354:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6355
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6355:
	cmp rax, [rsp + 24]
	jl .jump6356
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6356:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6357
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6357:
	cmp rax, [rsp + 32]
	jl .jump6358
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6358:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6359
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6359:
	cmp rax, [rsp + 40]
	jl .jump6360
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6360:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6361
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6361:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump6362
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6362:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6363: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6364:
	; Computing bound for 'E'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6365
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6365:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6366:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6367
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6367:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump6368
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6368:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump6369
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6369:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6370
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6370:
	imul rdi, [rsp + 0 + 24] ; multiply by t 
	jno .jump6371
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6371:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump6372: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const964] ; 18.74
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6372 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6372 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6372 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6372 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6363 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6373:
	cmp rax, [rsp + 8]
	jl .jump6374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6374:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6375
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6375:
	push rax
	pop rax
	cmp rax, 0
	je .jump6376
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6377
.jump6376:
	mov rax, [rel const45] ; False
	push rax
.jump6377:
	pop rax
	cmp rax, 0
	je .jump6378
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump6379
.jump6378:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const965] ; 725
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6380
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6380:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6381: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6381 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump6379:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6382:
	cmp rax, [rsp + 32]
	jl .jump6383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6383:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6384:
	cmp rax, [rsp + 40]
	jl .jump6385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6385:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6386:
	cmp rax, [rsp + 48]
	jl .jump6387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6387:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6388:
	cmp rax, [rsp + 56]
	jl .jump6389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6389:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const966] ; 79.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6390
	mov rax, [rel const967] ; 16.96
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6392:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const330] ; 590
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6393
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6393:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6394:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6395
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6396
.jump6395:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	mov rax, [rel const284] ; 269
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6397:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6398
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6398:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6399: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const953] ; 37
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6399 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6399 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump6396:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6400
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6400:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6401: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6402:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6403
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6403:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6404:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump6405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6405:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump6406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6406:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump6407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6407:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump6408: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6408 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6408 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6408 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6401 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6401 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6401 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6401 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6409
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	jmp .jump6410
.jump6409:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6411:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6412
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6412:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6413:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6414: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6414 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6414 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6414 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6415
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6415:
	; Computing bound for 'C'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6416
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6418
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump6419
.jump6418:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump6419:
	jmp .jump6417
.jump6416:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6420
	mov rax, [rel const968] ; 810
	push rax
	jmp .jump6421
.jump6420:
	mov rax, [rel const548] ; 41
	push rax
.jump6421:
.jump6417:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6422:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6423
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6423:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump6424
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6424:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! true) then (if c then r else y) else (if c then 810 else 41)) 
	jno .jump6425
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6425:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[B : r, C : t, D : (- f())] t) 
	jno .jump6426
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6426:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6427: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6427 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6427 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6427 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6428:
	cmp rax, [rsp + 24]
	jl .jump6429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6429:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6430:
	cmp rax, [rsp + 32]
	jl .jump6431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6431:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6432:
	cmp rax, [rsp + 40]
	jl .jump6433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6433:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump6410:
	jmp .jump6391
.jump6390:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6434
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6436
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6438
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump6439
.jump6438:
	mov rax, [rel const45] ; False
	push rax
.jump6439:
	pop rax
	cmp rax, 0
	je .jump6440
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const969] ; 314
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6442
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6442:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 314 
	jno .jump6443
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6443:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6444 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump6441
.jump6440:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6441:
	jmp .jump6437
.jump6436:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6445
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6445:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6446:
	; Computing bound for 'B'
	mov rax, [rel const741] ; 571
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6447
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6447:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 571 
	jno .jump6448
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6448:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump6449
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6449:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump6450
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6450:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump6451: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6451 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6451 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6451 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6452:
	cmp rax, [rsp + 24]
	jl .jump6453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6453:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6454:
	cmp rax, [rsp + 32]
	jl .jump6455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6455:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6456:
	cmp rax, [rsp + 40]
	jl .jump6457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6457:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6437:
	jmp .jump6435
.jump6434:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6458
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6459
.jump6458:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6459:
.jump6435:
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6460:
	cmp rax, [rsp + 8]
	jl .jump6461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6461:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6391:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 152 ; Local variables
	pop rbp
	ret

h:
_h:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6463
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const619] ; 844
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6465:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 844 
	jno .jump6466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6466:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6467: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6468
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6468:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump6469: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const207] ; 326
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6469 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6467 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6470:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6471
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6471:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6472: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6472 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6472 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6473
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6473:
	cmp rax, [rsp + 8]
	jl .jump6474
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6474:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6475
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6475:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6476:
	; Computing bound for 'k'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6477
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6478
.jump6477:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const60] ; 277
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6479:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump6478:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6480
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6480:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6481
	call _f
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump6482
.jump6481:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const613] ; 592
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6483
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6483:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6484:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6485
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6485:
	; Computing bound for 'j'
	mov rax, [rel const114] ; 862
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6486:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 862 
	jno .jump6487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6487:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump6488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6488:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6489:
	imul rdi, [rsp + 0 + 24] ; multiply by 592 
	jno .jump6490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6490:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6491: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6491 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6491 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6491 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6491 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6492
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6493
.jump6492:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump6493:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6494
	mov rax, [rel const972] ; 304
	push rax
	jmp .jump6495
.jump6494:
	mov rax, [rel const541] ; 322
	push rax
.jump6495:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6496:
	cmp rax, [rsp + 32]
	jl .jump6497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6497:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6498:
	cmp rax, [rsp + 40]
	jl .jump6499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6499:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6500:
	cmp rax, [rsp + 48]
	jl .jump6501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6501:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6502:
	cmp rax, [rsp + 56]
	jl .jump6503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6503:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6482:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6504:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (! a) then (- f()) else (array[j : 862, k : d(), l : f(), m : 592] m)[(if i then 304 else 322), d(), d(), (if a then d() else f())]) 
	jno .jump6505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6505:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! true) then f() else (277 % f())) 
	jno .jump6506
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6506:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6507:
imul rdi, [rsp + 0 + 24] ; multiply by (array[j : 844] (sum[k : j] 326))[(sum[j : d(), k : d()] k)] 
	jno .jump6508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6508:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6509: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const973] ; 62.97
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6510:
	cmp rax, [rsp + 16]
	jl .jump6511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6511:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6512:
	cmp rax, [rsp + 24]
	jl .jump6513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6513:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6514
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6514:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6515:
	; Computing bound for 'n'
	mov rax, [rel const914] ; 713
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6516
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6516:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6517: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6517 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6517 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6517 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6518:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6519
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6519:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6520: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const974] ; 75.78
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6520 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6520 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const975] ; 1.92
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6509 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6509 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6509 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6509 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6521:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6522
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump6522:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6523:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6524
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6524:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6525: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6525 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6525 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6526
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6526:
	; Computing bound for 'k'
	mov rax, [rel const976] ; 13
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6527:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6528
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const977] ; 271
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6530:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6531: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const715] ; 768
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6531 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump6529
.jump6528:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump6529:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6532
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6532:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (! i) then (sum[j : (- 271)] (- 768)) else d()) 
	jno .jump6533
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6533:
	imul rdi, [rsp + 0 + 8] ; multiply by 13 
	jno .jump6534
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6534:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[j : f(), k : (f() / f())] (- k)) 
	jno .jump6535
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6535:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump6536
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6536:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6537: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const978] ; 4
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6538
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6538:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6539:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6540
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6540:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6541: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6542
	mov rax, [rel const979] ; 23.65
	push rax
	jmp .jump6543
.jump6542:
	mov rax, [rel const980] ; 9.84
	push rax
.jump6543:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6541 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6541 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6541 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const981] ; 98.14
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const295] ; 386
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6544
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6544:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6545:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6546
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump6547
.jump6546:
	mov rax, [rel const982] ; 830
	push rax
.jump6547:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6548
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6548:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6549: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6550:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6551
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6551:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6552:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump6553: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const983] ; 96.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6553 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6553 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6553 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6549 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6549 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6549 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6554
	mov rax, [rel const984] ; 67.03
	push rax
	jmp .jump6555
.jump6554:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const111] ; 598
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6556:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6557
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6557:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6558:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6559
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6559:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6560: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const985] ; 9.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6560 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6560 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6560 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6560 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump6555:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6537 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6537 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6537 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6537 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 80
	call _jpl_alloc
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	jmp .jump6464
.jump6463:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const413] ; 730
	push rax
	call _f
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6561
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6561:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6562:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6563
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6563:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rel const675] ; 889
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6564
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump6564:
	cqo
	idiv r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6565
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump6565:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6566:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() % (889 / d())) 
	jno .jump6567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6567:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump6568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6568:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6569:
	imul rdi, [rsp + 0 + 24] ; multiply by (f() - 730) 
	jno .jump6570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6570:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6571: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6572:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6573
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6573:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6574:
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6575
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6575:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6576
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6576:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump6577
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6577:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump6578
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6578:
	imul rdi, [rsp + 0 + 24] ; multiply by (- f()) 
	jno .jump6579
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6579:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6580: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6581:
	cmp rax, [rsp + 16]
	jl .jump6582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6582:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6583:
	cmp rax, [rsp + 24]
	jl .jump6584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6584:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6580 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6580 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6580 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6580 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6571 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6571 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6571 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6571 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6585
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const263] ; 116
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6587:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6588
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6588:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6589:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6590:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump6591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6591:
	imul rdi, [rsp + 0 + 16] ; multiply by 116 
	jno .jump6592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6592:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6593: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6593 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6593 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6593 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump6586
.jump6585:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6594:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6595
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6595:
	; Computing bound for 'j'
	mov rax, [rel const986] ; 539
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6596:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 539 
	jno .jump6597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6597:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump6598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6598:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6599:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6600: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6600 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6600 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6600 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6586:
	mov rax, [rel const823] ; 699
	push rax
	mov rax, [rel const987] ; 655
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6601
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const279] ; 711
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump6602
.jump6601:
	mov rax, [rel const566] ; 926
	push rax
	pop rax
	neg rax
	push rax
.jump6602:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6603
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6603:
	cmp rax, [rsp + 24]
	jl .jump6604
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6604:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6605
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6605:
	cmp rax, [rsp + 32]
	jl .jump6606
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6606:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6607
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6607:
	cmp rax, [rsp + 40]
	jl .jump6608
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6608:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const845] ; 802
	push rax
	call _f
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6609
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6609:
	; Computing bound for 'l'
	mov rax, [rel const752] ; 575
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6610:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6611:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6612
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6612:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6613:
	; Computing bound for 'j'
	mov rax, [rel const719] ; 509
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6614
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6614:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6615: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6615 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6615 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6615 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6615 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6616
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6616:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rel const271] ; 99
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6617:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6618: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6618 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6618 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6618 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6618 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6619
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6620
.jump6619:
	mov rax, [rel const988] ; 714
	push rax
	pop rax
	neg rax
	push rax
.jump6620:
	pop rax
	neg rax
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6621:
	cmp rax, [rsp + 32]
	jl .jump6622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6622:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6623:
	cmp rax, [rsp + 40]
	jl .jump6624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6624:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6625:
	cmp rax, [rsp + 48]
	jl .jump6626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6626:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6627:
	cmp rax, [rsp + 56]
	jl .jump6628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6628:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6629:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump6630
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6630:
	push rax
	pop rax
	cmp rax, 0
	je .jump6631
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6633:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6634
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6634:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6635: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const302] ; 15
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6635 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6635 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump6632
.jump6631:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump6632:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6636
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6636:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6637:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6638:
	; Computing bound for 'k'
	mov rax, [rel const989] ; 716
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6639
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6639:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6640:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6641:
	imul rdi, [rsp + 0 + 8] ; multiply by 716 
	jno .jump6642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6642:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6643:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6644: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const990] ; 161
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6644 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6644 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6644 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6645
	mov rax, [rel const231] ; 63
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6647:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump6646
.jump6645:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump6646:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6648
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6648:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6649: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6649 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6650:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6651
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6651:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump6652
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6652:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump6653
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6653:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6654: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6654 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6654 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6655
	call _f
	push rax
	jmp .jump6656
.jump6655:
	call _f
	push rax
.jump6656:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6657
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6657:
	cmp rax, [rsp + 16]
	jl .jump6658
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6658:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6659
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6659:
	cmp rax, [rsp + 24]
	jl .jump6660
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6660:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6661
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6661:
	cmp rax, [rsp + 24]
	jl .jump6662
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6662:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6663
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6663:
	cmp rax, [rsp + 32]
	jl .jump6664
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6664:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6665
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6665:
	cmp rax, [rsp + 40]
	jl .jump6666
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6666:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6667
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6667:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (array[j : d(), k : 716, l : f()] 161)[(array[j : f(), k : d()] f())[(f() * f()), (if false then f() else f())], (sum[j : f()] f()), (if i then (f() % 63) else d())] 
	jno .jump6668
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6668:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump6669
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6669:
imul rdi, [rsp + 0 + 16] ; multiply by (if ((! c) || a) then (sum[j : (- d()), k : d()] 15) else d()) 
	jno .jump6670
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6670:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump6671
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6671:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6672: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const991] ; 8.18
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6673:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6674
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6674:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6675:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump6676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6676:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6677:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6678:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6679: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6679 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6679 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6679 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6680:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump6681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6681:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump6682: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6682 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const992] ; 34.97
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const993] ; 4.99
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6672 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6672 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6672 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6672 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const994] ; 100
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6683
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6683:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6684
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump6684:
	push rax
	pop rax
	cmp rax, 0
	je .jump6685
	call _d
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump6686
.jump6685:
	call _d
	push rax
.jump6686:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6687:
	; Computing bound for 'k'
	mov rax, [rel const551] ; 501
	push rax
	pop rax
	neg rax
	push rax
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6688
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6688:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const889] ; 329
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6689
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6689:
	; Computing bound for 'l'
	mov rax, [rel const995] ; 495
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6690:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6691:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6692
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6692:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6693
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6693:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6694: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const996] ; 447
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6694 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6694 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6694 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6694 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6695:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[j : d(), k : (- (d() % d())), l : (- (- 495)), m : (- (- 329))] 447) 
	jno .jump6696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6696:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- (f() - f())) + (- 501)) 
	jno .jump6697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6697:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (i || false) then (- d()) else d()) 
	jno .jump6698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6698:
	imul rdi, [rsp + 0 + 24] ; multiply by 100 
	jno .jump6699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6699:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6700: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6701
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6703
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6705
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6705:
	cmp rax, [rsp + 16]
	jl .jump6706
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6706:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6707
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6707:
	cmp rax, [rsp + 24]
	jl .jump6708
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6708:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6704
.jump6703:
	mov rax, [rel const997] ; 32.55
	push rax
	mov rax, [rel const998] ; 24.87
	push rax
	mov rax, [rel const999] ; 24.88
	push rax
	mov rax, [rel const1000] ; 49.77
	push rax
.jump6704:
	jmp .jump6702
.jump6701:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6709
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6710
.jump6709:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump6710:
	pop rax
	cmp rax, 0
	je .jump6711
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6713
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6713:
	cmp rax, [rsp + 16]
	jl .jump6714
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6714:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6715
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6715:
	cmp rax, [rsp + 24]
	jl .jump6716
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6716:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6712
.jump6711:
	mov rax, [rel const1001] ; 14.35
	push rax
	mov rax, [rel const1002] ; 79.2
	push rax
	mov rax, [rel const1003] ; 87.48
	push rax
	mov rax, [rel const1004] ; 59.37
	push rax
.jump6712:
.jump6702:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6700 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6700 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6700 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6700 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1005] ; 537
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6717
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6717:
	; Computing bound for 'j'
	mov rax, [rel const682] ; 524
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6718:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6719: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6719 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6719 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6720:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6721
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6721:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6722:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6723:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6724
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6724:
	; Computing bound for 'k'
	mov rax, [rel const714] ; 372
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6725:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6726
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6726:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6727: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6727 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6727 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6727 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6727 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6728
	mov rax, [rel const1] ; True
	push rax
	jmp .jump6729
.jump6728:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump6729:
	pop rax
	cmp rax, 0
	je .jump6730
	call _d
	push rax
	jmp .jump6731
.jump6730:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6732
	call _f
	push rax
	jmp .jump6733
.jump6732:
	call _d
	push rax
.jump6733:
.jump6731:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6734:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6735
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6735:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by ((if (if a then true else i) then d() else (if a then f() else d())) / (- (sum[j : f(), k : 372, l : f(), m : f()] f()))) 
	jno .jump6736
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6736:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump6737
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6737:
	imul rdi, [rsp + 0 + 16] ; multiply by (- f()) 
	jno .jump6738
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6738:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[j : 524, k : ((- 537) * d())] k) 
	jno .jump6739
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6739:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump6740: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6741:
	cmp rax, [rsp + 16]
	jl .jump6742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6742:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6743:
	cmp rax, [rsp + 24]
	jl .jump6744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6744:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6740 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6740 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6740 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6740 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 160
	call _jpl_alloc
	; Moving 160 bytes from rsp to rax 
		mov r10, [rsp + 152]
		mov [rax + 152], r10
		mov r10, [rsp + 144]
		mov [rax + 144], r10
		mov r10, [rsp + 136]
		mov [rax + 136], r10
		mov r10, [rsp + 128]
		mov [rax + 128], r10
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160
	push rax
	mov rax, 4
	push rax
.jump6464:
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6745
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6746
.jump6745:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump6746:
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6747:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6748
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump6748:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6749:
	; Computing bound for 'm'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6750:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6751:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6752
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6752:
	; Computing bound for 'l'
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6753:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (f() * d()) 
	jno .jump6754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6754:
	imul rdi, [rsp + 0 + 8] ; multiply by (d() % d()) 
	jno .jump6755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6755:
	imul rdi, [rsp + 0 + 16] ; multiply by (- k) 
	jno .jump6756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6756:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6757: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6757 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6757 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6757 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const239] ; 261
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6758
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6758:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6759: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6759 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const829] ; 218
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6760
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6760:
	cmp rax, [rsp + 24]
	jl .jump6761
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6761:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6762
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6762:
	cmp rax, [rsp + 32]
	jl .jump6763
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6763:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6764
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6764:
	cmp rax, [rsp + 40]
	jl .jump6765
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6765:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6766
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6766:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6767
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump6767:
	push rax
	pop rax
	cmp rax, 0
	je .jump6768
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6769
.jump6768:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6770
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6771
.jump6770:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump6771:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6772
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6772:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6773
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6773:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6774:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6775
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6775:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6776:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6777: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6777 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6777 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6777 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6777 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6778:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6779
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6779:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6780: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6780 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6780 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6780 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump6769:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6781:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6782: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const646] ; 747
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6783
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump6783:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6782 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6782 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6782 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6784
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6784:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : (if (a && true) then k else (sum[l : d(), m : (sum[l : d(), m : f(), n : f(), o : f()] f()), n : (if c then k else d())] d())), m : (array[l : (f() * d()), m : (d() % d()), n : (- k)] (- k))[(- 218), (sum[l : 261] k), (- f())], n : ((d() / (if i then d() else k)) % d())] (- (747 % k))) 
	jno .jump6785
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6785:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6786: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const229] ; 772
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6787
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6788
.jump6787:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump6788:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6789:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6790
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6790:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump6791: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6792
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6792:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump6793: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6793 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6791 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6791 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6786 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const885] ; 155
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6794:
	cmp rax, [rsp + 8]
	jl .jump6795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6795:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6796:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6797
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6797:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6798:
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6799:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6800:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6801: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6801 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6802
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6804
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6804:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6805:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6806
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6806:
	; Computing bound for 'l'
	mov rax, [rel const1006] ; 167
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6807:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 167 
	jno .jump6808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6808:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump6809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6809:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump6810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6810:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump6811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6811:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6812: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const189] ; 480
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6812 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6812 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6812 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6812 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6803
.jump6802:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6813
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6813:
	; Computing bound for 'n'
	mov rax, [rel const1007] ; 848
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6814:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6815
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6815:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6816:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6817:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump6818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6818:
	imul rdi, [rsp + 0 + 16] ; multiply by 848 
	jno .jump6819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6819:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump6820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6820:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6821: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6821 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6821 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6821 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6821 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6803:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6822:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6823
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6824
.jump6823:
	call _f
	push rax
.jump6824:
	mov rax, [rel const709] ; 83
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const652] ; 129
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6825:
	; Computing bound for 'n'
	mov rax, [rel const1008] ; 583
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6826
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6826:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6827:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6828
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6828:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6829: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6829 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6829 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6829 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6829 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6830
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6830:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6831
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6832
.jump6831:
	call _f
	push rax
.jump6832:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6833:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6834
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6835
.jump6834:
	mov rax, [rel const1009] ; 324
	push rax
.jump6835:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6836
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6836:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6837:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6838: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6838 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6838 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6838 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6838 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6839:
	cmp rax, [rsp + 32]
	jl .jump6840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6840:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6841:
	cmp rax, [rsp + 40]
	jl .jump6842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6842:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6843:
	cmp rax, [rsp + 48]
	jl .jump6844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6844:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6845:
	cmp rax, [rsp + 56]
	jl .jump6846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6846:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6847:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6848
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6850
	mov rax, [rel const793] ; 648
	push rax
	jmp .jump6851
.jump6850:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump6851:
	pop rax
	neg rax
	push rax
	jmp .jump6849
.jump6848:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6852:
	cqo
	idiv r10
	push rax
.jump6849:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6853
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6853:
	; Computing bound for 'l'
	mov rax, [rel const668] ; 200
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6854:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6855: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1010] ; 29
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6855 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6855 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6855 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6856
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6856:
	cmp rax, [rsp + 8]
	jl .jump6857
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6857:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6858:
	; Computing bound for 'n'
	mov rax, [rel const988] ; 714
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6859
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6860
.jump6859:
	call _f
	push rax
.jump6860:
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6861
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6861:
	; Computing bound for 'm'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6862
	call _f
	push rax
	jmp .jump6863
.jump6862:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump6863:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6864:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6865:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6866: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6866 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6867
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6867:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : d()] (- k)) 
	jno .jump6868
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6868:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! false) then f() else k) 
	jno .jump6869
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6869:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if a then k else f()) * 714) 
	jno .jump6870
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6870:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump6871
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6871:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6872: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6872 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6872 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6872 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6872 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6873
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6873:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6874:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6875:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6876
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6876:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6877: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6877 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6877 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6877 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6878
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6880:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6881:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6882: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6882 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump6879
.jump6878:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6883:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6884:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6885: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6885 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump6879:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6886
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6886:
	cmp rax, [rsp + 8]
	jl .jump6887
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6887:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6888
	mov rax, [rel const45] ; False
	push rax
	jmp .jump6889
.jump6888:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump6889:
	pop rax
	cmp rax, 0
	je .jump6890
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6891
.jump6890:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6892
	mov rax, [rel const1011] ; 229
	push rax
	jmp .jump6893
.jump6892:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump6893:
.jump6891:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6894
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6894:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6895
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6895:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6896:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6897
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6897:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6898: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const254] ; 165
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6898 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6898 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6898 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6899
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump6899:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6900:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6901
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6901:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6902:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6903: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6903 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6903 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6903 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6903 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6904
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6904:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6905:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6906
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6906:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6907:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6908:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump6909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6909:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump6910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6910:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump6911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6911:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6912: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6912 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6912 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6912 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6912 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1012] ; 616
	push rax
	mov rax, [rel const485] ; 110
	push rax
	mov rax, [rel const323] ; 522
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6913:
	cmp rax, [rsp + 32]
	jl .jump6914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6914:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6915:
	cmp rax, [rsp + 40]
	jl .jump6916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6916:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6917:
	cmp rax, [rsp + 48]
	jl .jump6918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6918:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6919:
	cmp rax, [rsp + 56]
	jl .jump6920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6920:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6921:
	; Computing bound for 'n'
	mov rax, [rel const691] ; 594
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6922
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6922:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6923:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6924
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6924:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6925: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6925 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6925 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6925 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6925 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6926
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6926:
	cmp rax, [rsp + 32]
	jl .jump6927
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6927:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6928
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6928:
	cmp rax, [rsp + 40]
	jl .jump6929
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6929:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6930
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6930:
	cmp rax, [rsp + 48]
	jl .jump6931
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6931:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6932
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6932:
	cmp rax, [rsp + 56]
	jl .jump6933
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6933:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6934
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6934:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump6935: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6936:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6937
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6937:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6938:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6939:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6940:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump6941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6941:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6942: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6942 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6942 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6942 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6943:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6944
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6944:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump6945
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6945:
	imul rdi, [rsp + 0 + 8] ; multiply by (n + m) 
	jno .jump6946
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6946:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6947: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6948
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6950
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6950:
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump6949
.jump6948:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump6951
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6951:
	push rax
	pop rax
	cmp rax, 0
	je .jump6952
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6954
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6954:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6955
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6955:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump6956: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6956 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump6953
.jump6952:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6957:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump6958
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6958:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump6959: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6959 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump6953:
.jump6949:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6947 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6947 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6960
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6960:
	cmp rax, [rsp + 16]
	jl .jump6961
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6961:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6962
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6962:
	cmp rax, [rsp + 24]
	jl .jump6963
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6963:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6964
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6966
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6966:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6967
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump6967:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6968: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6968 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6969
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6969:
	; Computing bound for 'q'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6970:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6971
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6971:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6972: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6972 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6972 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6972 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6973:
	cmp rax, [rsp + 8]
	jl .jump6974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6974:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6975:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6976
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6976:
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6977:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump6978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6978:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump6979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6979:
imul rdi, [rsp + 0 + 16] ; multiply by (array[p : k] m)[(sum[p : l, q : d(), r : f()] p)] 
	jno .jump6980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6980:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6981: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6981 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6981 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6981 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const867] ; 115
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6982
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6982:
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6983:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6984
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6984:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6985:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6986: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6986 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6986 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6986 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6986 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6987
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6987:
	cmp rax, [rsp + 24]
	jl .jump6988
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6988:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6989
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6989:
	cmp rax, [rsp + 32]
	jl .jump6990
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6990:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6991
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6991:
	cmp rax, [rsp + 40]
	jl .jump6992
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump6992:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6965
.jump6964:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6993
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump6993:
	push rax
	pop rax
	cmp rax, 0
	je .jump6994
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6996:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump6997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6997:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump6998: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6998 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump6995
.jump6994:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump6995:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6999
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump6999:
	cmp rax, [rsp + 8]
	jl .jump7000
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7000:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6965:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7001
	mov rax, [rel const1013] ; 66.75
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1014] ; 60.41
	push rax
	mov rax, [rel const1015] ; 10.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump7002
.jump7001:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7003
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump7003:
	push rax
.jump7002:
	pop rax
	cmp rax, 0
	je .jump7004
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7006
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7007
.jump7006:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump7007:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7008
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7008:
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7009:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7010
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7010:
	; Computing bound for 'p'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7011:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7012:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump7013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7013:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump7014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7014:
	imul rdi, [rsp + 0 + 24] ; multiply by (if (! a) then d() else m) 
	jno .jump7015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7015:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump7016: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7016 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7016 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7016 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7016 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7005
.jump7004:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7017
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7017:
	; Computing bound for 'r'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7018:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7019
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7019:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7020:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump7021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7021:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7022:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d()) 
	jno .jump7023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7023:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump7024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7024:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump7025: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7026
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump7026:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7027:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (s % l) 
	jno .jump7028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7028:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7029: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7029 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7025 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7025 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7025 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7025 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump7005:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7030:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7031
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7031:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump7032: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1016] ; 71.34
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7032 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7032 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1017] ; 20.08
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7033
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7035
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7035:
	cmp rax, [rsp + 8]
	jl .jump7036
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7036:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump7034
.jump7033:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump7034:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7037:
	cmp rax, [rsp + 32]
	jl .jump7038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7038:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7039:
	cmp rax, [rsp + 40]
	jl .jump7040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7040:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7041:
	cmp rax, [rsp + 48]
	jl .jump7042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7042:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7043:
	cmp rax, [rsp + 56]
	jl .jump7044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7044:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6935 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6935 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6935 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6935 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1018] ; 32.98
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump7045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1019] ; 'l'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7045:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7046
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const106] ; 901
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7048
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7048:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const113] ; 325
	push rax
	mov rax, [rel const952] ; 327
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7049
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7051
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const563] ; 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7053
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7053:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7054
	mov rax, [rel const689] ; 663
	push rax
	jmp .jump7055
.jump7054:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump7055:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7056:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7057
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7057:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump7058
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7058:
	imul rdi, [rsp + 0 + 8] ; multiply by (if i then 663 else k) 
	jno .jump7059
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7059:
	imul rdi, [rsp + 0 + 16] ; multiply by 32 
	jno .jump7060
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7060:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7061: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1020] ; 404
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7061 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7061 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7061 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump7052
.jump7051:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7062
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7062:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7063:
	; Computing bound for 'l'
	mov rax, [rel const1021] ; 426
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7064
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7064:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 426) 
	jno .jump7065
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7065:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump7066
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7066:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump7067
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7067:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7068: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7069
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7070
.jump7069:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump7070:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7068 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7068 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7068 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump7052:
	jmp .jump7050
.jump7049:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7071
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const193] ; 749
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7073
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7073:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7074
	mov rax, [rel const5] ; 19
	push rax
	jmp .jump7075
.jump7074:
	call _f
	push rax
.jump7075:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7076:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7077
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7077:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d()) 
	jno .jump7078
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7078:
	imul rdi, [rsp + 0 + 8] ; multiply by (if c then 19 else f()) 
	jno .jump7079
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7079:
	imul rdi, [rsp + 0 + 16] ; multiply by 749 
	jno .jump7080
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7080:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7081: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7081 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7081 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7081 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump7072
.jump7071:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7082
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7082:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7083:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7084
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7084:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump7085
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7085:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump7086
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7086:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump7087
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7087:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7088: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const870] ; 300
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7088 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7088 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7088 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump7072:
.jump7050:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const18] ; 666
	push rax
	mov rax, [rel const821] ; 206
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7089:
	cmp rax, [rsp + 24]
	jl .jump7090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7090:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7091:
	cmp rax, [rsp + 32]
	jl .jump7092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7092:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7093:
	cmp rax, [rsp + 40]
	jl .jump7094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7094:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7095:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const1022] ; 311
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7096
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7096:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7097:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7098: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7098 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7098 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7099
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump7100
.jump7099:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump7100:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7101
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7101:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7102: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7102 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7102 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7102 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7103:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : (if (! ((d() == (sum[l : d(), m : 311] d())) == i)) then (- d()) else k), m : (if ((327 == 325) != c) then (if true then (array[l : k, m : (if i then 663 else k), n : 32] 404) else (array[l : (- 426), m : f(), n : k] (if a then d() else l))) else (if i then (array[l : (- d()), m : (if c then 19 else f()), n : 749] n) else (array[l : k, m : d(), n : d()] 300)))[206, 666, k], n : 901] f()) 
	jno .jump7104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7104:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7105: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7106
	call _d
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump7107
.jump7106:
	call _d
	push rax
	pop rax
	neg rax
	push rax
.jump7107:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7108:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7109
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7109:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7110: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const533] ; 293
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7111
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7111:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7112: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7112 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7110 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7110 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7113
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7113:
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7114:
	; Computing bound for 'n'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump7115
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7116
.jump7115:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const535] ; 869
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7117:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7118:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7119
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7119:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7120:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7121: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7121 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7121 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7121 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump7116:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7122
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7122:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7123:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7124: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const255] ; 160
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7124 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7124 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7124 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7124 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7125
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7127
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7129
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump7130
.jump7129:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump7130:
	pop rax
	cmp rax, 0
	je .jump7131
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7133:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7134
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7134:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump7135
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7135:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump7136
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7136:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7137: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7137 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7137 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump7132
.jump7131:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7138:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7139
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7139:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump7140
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7140:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump7141
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7141:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7142: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const201] ; 477
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7142 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7142 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump7132:
	jmp .jump7128
.jump7127:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const1023] ; 560
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7143
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7143:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7144: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7144 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7145:
	; Computing bound for 'm'
	mov rax, [rel const1024] ; 949
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7146
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7146:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 949 
	jno .jump7147
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7147:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[m : 560] m) 
	jno .jump7148
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7148:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7149: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7149 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7149 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump7128:
	jmp .jump7126
.jump7125:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const592] ; 946
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7150:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 946 
	jno .jump7151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7151:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7152: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7153
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7153:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7154:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump7155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7155:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump7156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7156:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump7157: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7157 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7157 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7152 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7158:
	cqo
	idiv r10
	push rax
	call _f
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7159
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7159:
	cmp rax, [rsp + 8]
	jl .jump7160
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7160:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7126:
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7161
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7163:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump7162
.jump7161:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7164
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const834] ; 26
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7166:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7167
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7167:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7168:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7169: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const836] ; 506
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7169 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7169 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7169 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump7165
.jump7164:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump7165:
.jump7162:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump7170
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
.jump7170:
	push rax
	pop rax
	cmp rax, 0
	je .jump7171
	mov rax, [rel const921] ; 724
	push rax
	jmp .jump7172
.jump7171:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump7172:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7173
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7173:
	cmp rax, [rsp + 16]
	jl .jump7174
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7174:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7175
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7175:
	cmp rax, [rsp + 24]
	jl .jump7176
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7176:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7105 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump7047
.jump7046:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7177:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump7178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7178:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump7179: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7180
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7182:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7183
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7183:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7184: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7184 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7184 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7185
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7185:
	cmp rax, [rsp + 8]
	jl .jump7186
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7186:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump7181
.jump7180:
	mov rax, [rel const1025] ; 561
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7187
	mov rax, [rel const1026] ; 552
	push rax
	jmp .jump7188
.jump7187:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump7188:
.jump7181:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7179 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7189
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7189:
	cmp rax, [rsp + 8]
	jl .jump7190
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7190:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7047:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7191
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7191:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7192:
	; Computing bound for 'o'
	mov rax, [rel const1027] ; 74
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7193
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7193:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 74 
	jno .jump7194
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7194:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump7195
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7195:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump7196
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7196:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7198
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump7198:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7197 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7197 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7197 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const501] ; 267
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7199:
	cmp rax, [rsp + 24]
	jl .jump7200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7200:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7201:
	cmp rax, [rsp + 32]
	jl .jump7202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7202:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7203:
	cmp rax, [rsp + 40]
	jl .jump7204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7204:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7205
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7206
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7208
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7209
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7209:
	cmp rax, [rsp + 8]
	jl .jump7210
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7210:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump7208:
	push rax
	jmp .jump7207
.jump7206:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump7207:
	pop rax
.jump7205:
	push rax
	pop rax
	cmp rax, 0
	je .jump7211
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7213
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7215
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7216
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump7217
.jump7216:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump7217:
	pop rax
	cmp rax, 0
	je .jump7218
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7219
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump7220
.jump7219:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump7220:
	pop rax
.jump7218:
	push rax
	pop rax
	cmp rax, 0
	je .jump7221
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump7222
.jump7221:
	mov rax, [rel const1028] ; 89.81
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1029] ; 83.9
	push rax
	mov rax, [rel const1030] ; 25.54
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump7222:
	pop rax
.jump7215:
	push rax
	jmp .jump7214
.jump7213:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const681] ; 682
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7223
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7223:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 682 
	jno .jump7224
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7224:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7225: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1031] ; 46.57
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7225 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7226:
	cmp rax, [rsp + 8]
	jl .jump7227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7227:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const1032] ; 332
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7228:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7229
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7229:
	; Computing bound for 'o'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7230:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d()) 
	jno .jump7231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7231:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f()) 
	jno .jump7232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7232:
	imul rdi, [rsp + 0 + 16] ; multiply by 332 
	jno .jump7233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7233:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7234: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7235
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump7236
.jump7235:
	mov rax, [rel const1] ; True
	push rax
.jump7236:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7234 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7234 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7234 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7237
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7238
.jump7237:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
.jump7238:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const191] ; 669
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7239
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7239:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 669 
	jno .jump7240
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7240:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7241: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7241 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump7214:
	pop rax
	cmp rax, 0
	je .jump7242
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7244
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7245
.jump7244:
	mov rax, [rel const615] ; 436
	push rax
.jump7245:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7246
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7248
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7248:
	; Computing bound for 'p'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7249:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7250:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7251
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7251:
	imul rdi, [rsp + 0 + 8] ; multiply by (- d()) 
	jno .jump7252
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7252:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump7253
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7253:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7254: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7255:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7256
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7256:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7257:
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7258
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7258:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7259
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7259:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7260
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7260:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump7261
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7261:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump7262
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7262:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump7263: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7263 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7263 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7263 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7263 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7254 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7254 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7254 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7264:
	cmp rax, [rsp + 8]
	jl .jump7265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7265:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump7247
.jump7246:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7266
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7267
.jump7266:
	mov rax, [rel const1033] ; 693
	push rax
.jump7267:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7268
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7268:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7269
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump7270
.jump7269:
	call _d
	push rax
.jump7270:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const423] ; 457
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7271:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7272:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7273
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7274
.jump7273:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump7274:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7275
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7275:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then d() else n) 
	jno .jump7276
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7276:
	imul rdi, [rsp + 0 + 8] ; multiply by ((457 % n) + (if c then k else d())) 
	jno .jump7277
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7277:
	imul rdi, [rsp + 0 + 16] ; multiply by (if c then f() else 693) 
	jno .jump7278
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7278:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7279: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const542] ; 85
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7280:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7281
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7281:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7282:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump7283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7283:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump7284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7284:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 85) 
	jno .jump7285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7285:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump7286: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	mov rax, [rel const1034] ; 374
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7287
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7287:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7288:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7289
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7289:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7290:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump7291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7291:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump7292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7292:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump7293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7293:
	imul rdi, [rsp + 0 + 24] ; multiply by 374 
	jno .jump7294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7294:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7295: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const232] ; 550
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7295 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7295 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7295 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7295 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7286 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7286 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7286 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7279 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7279 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7279 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7296:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7297: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7297 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7298
	mov rax, [rel const1035] ; 54.89
	push rax
	mov rax, [rel const1036] ; 31.68
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7300
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump7301
.jump7300:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump7301:
	jmp .jump7299
.jump7298:
	mov rax, [rel const936] ; 976
	push rax
.jump7299:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7302:
	cmp rax, [rsp + 24]
	jl .jump7303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7303:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7304:
	cmp rax, [rsp + 32]
	jl .jump7305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7305:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7306:
	cmp rax, [rsp + 40]
	jl .jump7307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7307:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7247:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7308:
	cmp rax, [rsp + 24]
	jl .jump7309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7309:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7310:
	cmp rax, [rsp + 32]
	jl .jump7311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7311:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7312:
	cmp rax, [rsp + 40]
	jl .jump7313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7313:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump7243
.jump7242:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7314
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7314:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7315:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7316
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7316:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7317
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7317:
	; Computing bound for 'o'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7318:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7319: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7320:
	; Computing bound for 'q'
	mov rax, [rel const501] ; 267
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7321
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7321:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump7322: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7322 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7322 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7319 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7319 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7323:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : d(), p : f()] (sum[q : 267, r : d()] d())) 
	jno .jump7324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7324:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7325:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump7326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7326:
	imul rdi, [rsp + 0 + 24] ; multiply by (d() + k) 
	jno .jump7327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7327:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7328: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7329:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7330
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7330:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7331
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7331:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump7332
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7332:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7333: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7333 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7333 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7334
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7334:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7335
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7335:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7336 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7337:
	cmp rax, [rsp + 8]
	jl .jump7338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7338:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7339
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7339:
	cmp rax, [rsp + 16]
	jl .jump7340
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7340:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7341
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7341:
	cmp rax, [rsp + 24]
	jl .jump7342
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7342:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7343
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7345:
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7346:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7347: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7347 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7348
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7348:
	; Computing bound for 't'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump7349
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump7350
.jump7349:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump7350:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7351:
	; Computing bound for 's'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7352
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7352:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (o - f()) 
	jno .jump7353
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7353:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then n else n) 
	jno .jump7354
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7354:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[s : r] r) 
	jno .jump7355
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7355:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump7356
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7356:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7357: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7357 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7357 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7357 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7357 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7344
.jump7343:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7358:
	; Computing bound for 'u'
	mov rax, [rel const850] ; 481
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7359
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7359:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7360:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7361
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7361:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7362
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7362:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump7363
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7363:
	imul rdi, [rsp + 0 + 16] ; multiply by 481 
	jno .jump7364
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7364:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump7365
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7365:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7366: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7366 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7366 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7366 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7366 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7367
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7367:
	; Computing bound for 'u'
	mov rax, [rel const632] ; 121
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7368:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7369
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7369:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7370:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump7371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7371:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump7372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7372:
	imul rdi, [rsp + 0 + 16] ; multiply by 121 
	jno .jump7373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7373:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump7374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7374:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7375: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7375 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7375 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7375 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7375 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 80
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7376
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7376:
	cmp rax, [rsp + 8]
	jl .jump7377
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7377:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7344:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7328 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7328 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7328 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7328 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const961] ; 805
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7378
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7378:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7379: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7380:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7381
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7381:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump7382: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7382 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7382 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7379 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7383:
	cmp rax, [rsp + 32]
	jl .jump7384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7384:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7385:
	cmp rax, [rsp + 40]
	jl .jump7386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7386:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7387:
	cmp rax, [rsp + 48]
	jl .jump7388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7388:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7389:
	cmp rax, [rsp + 56]
	jl .jump7390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7390:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7243:
	jmp .jump7212
.jump7211:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7391
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7391:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7392
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7394
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7394:
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7395:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump7396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7396:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump7397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7397:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7398: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7398 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7398 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump7393
.jump7392:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7399
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7399:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7400:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump7401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7401:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump7402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7402:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7403: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7403 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7403 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump7393:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7404:
	cmp rax, [rsp + 16]
	jl .jump7405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7405:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7406:
	cmp rax, [rsp + 24]
	jl .jump7407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7407:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7408
	mov rax, [rel const1037] ; 914
	push rax
	jmp .jump7409
.jump7408:
	call _d
	push rax
.jump7409:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7410:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7411
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7411:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7412:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump7413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7413:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7414:
imul rdi, [rsp + 0 + 16] ; multiply by (if (if c then (array[o : f(), p : f()] c) else (array[o : k, p : d()] i))[d(), f()] then 914 else d()) 
	jno .jump7415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7415:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump7416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7416:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7417: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7418:
	; Computing bound for 't'
	mov rax, [rel const1038] ; 181
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7419
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7419:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7420:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump7421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7421:
	imul rdi, [rsp + 0 + 8] ; multiply by 181 
	jno .jump7422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7422:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump7423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7423:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump7424: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7425
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump7426
.jump7425:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump7426:
	pop rax
	cmp rax, 0
	je .jump7427
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7429
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7429:
	; Computing bound for 'x'
	mov rax, [rel const1039] ; 401
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7430:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7431
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7431:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7432:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7433:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump7434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7434:
	imul rdi, [rsp + 0 + 16] ; multiply by 401 
	jno .jump7435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7435:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump7436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7436:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump7437: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7437 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7437 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7437 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7437 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7428
.jump7427:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7438
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7440
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7440:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7441:
	; Computing bound for 'w'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7442
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7442:
	; Computing bound for 'v'
	mov rax, [rel const1040] ; 255
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7443:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 255 
	jno .jump7444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7444:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump7445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7445:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump7446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7446:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump7447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7447:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump7448: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7448 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7448 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7448 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7448 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7439
.jump7438:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7449
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7449:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7450:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7451
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7451:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7452:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7453:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7454:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump7455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7455:
	imul rdi, [rsp + 0 + 24] ; multiply by t 
	jno .jump7456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7456:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump7457: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7457 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7457 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7457 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7457 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump7439:
.jump7428:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7424 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7424 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7424 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7417 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7417 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7417 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7417 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7458
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7460:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7461
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7461:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7462
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7462:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7463: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7463 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7463 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7463 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump7459
.jump7458:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump7459:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7464
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7464:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7465:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7466
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7466:
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7467
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7467:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump7468
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7468:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7469: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7469 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7470:
	cmp rax, [rsp + 8]
	jl .jump7471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7471:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7472:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump7473: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7473 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7473 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7473 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7473 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7474:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7475:
	cmp rax, [rsp + 32]
	jl .jump7476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7476:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7477:
	cmp rax, [rsp + 40]
	jl .jump7478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7478:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7479:
	cmp rax, [rsp + 48]
	jl .jump7480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7480:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7481:
	cmp rax, [rsp + 56]
	jl .jump7482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7482:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const415] ; 609
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7483
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump7483:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7484:
	cmp rax, [rsp + 24]
	jl .jump7485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7485:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7486:
	cmp rax, [rsp + 32]
	jl .jump7487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7487:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7488:
	cmp rax, [rsp + 40]
	jl .jump7489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7489:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7212:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7490:
	; Computing bound for 'u'
	mov rax, [rel const1009] ; 324
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7491
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7491:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7492
	call _f
	push rax
	jmp .jump7493
.jump7492:
	call _f
	push rax
.jump7493:
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7494:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- (if a then f() else f()))) 
	jno .jump7495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7495:
	imul rdi, [rsp + 0 + 8] ; multiply by 324 
	jno .jump7496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7496:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump7497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7497:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7498: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7498 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7498 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7498 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7499:
	; Computing bound for 'v'
	mov rax, [rel const120] ; 731
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7500
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7500:
	; Computing bound for 'u'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7501:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7502
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7502:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump7503
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7503:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump7504
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7504:
	imul rdi, [rsp + 0 + 16] ; multiply by 731 
	jno .jump7505
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7505:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump7506
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7506:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7507: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7508
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7508:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump7509
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7509:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump7510: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7510 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7507 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7507 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7507 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7507 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7511
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7511:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7512:
	; Computing bound for 'u'
	mov rax, [rel const251] ; 365
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7513
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7513:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7514:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump7515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7515:
	imul rdi, [rsp + 0 + 8] ; multiply by 365 
	jno .jump7516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7516:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump7517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7517:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump7518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7518:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7519: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7519 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7519 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7519 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7519 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 80
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7520
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7522:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7523
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7523:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7524
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7524:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump7525
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7525:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7526: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const120] ; 731
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7526 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7526 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump7521
.jump7520:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7527:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7528
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7528:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump7529
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7529:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump7530
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7530:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7531: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7531 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7531 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump7521:
	call _d
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7532:
	; Computing bound for 'u'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7533
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7533:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7534:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump7535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7535:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump7536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7536:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump7537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7537:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7538: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7538 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7538 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7538 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7539
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7539:
	cmp rax, [rsp + 24]
	jl .jump7540
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7540:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7541
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7541:
	cmp rax, [rsp + 32]
	jl .jump7542
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7542:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7543
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7543:
	cmp rax, [rsp + 40]
	jl .jump7544
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7544:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7545
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7545:
	cmp rax, [rsp + 16]
	jl .jump7546
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7546:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7547
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7547:
	cmp rax, [rsp + 24]
	jl .jump7548
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7548:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7549
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7549:
	cmp rax, [rsp + 8]
	jl .jump7550
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7550:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7551
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7551:
	cmp rax, [rsp + 32]
	jl .jump7552
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7552:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7553
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7553:
	cmp rax, [rsp + 40]
	jl .jump7554
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7554:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7555
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7555:
	cmp rax, [rsp + 48]
	jl .jump7556
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7556:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7557
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7557:
	cmp rax, [rsp + 56]
	jl .jump7558
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7558:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7559:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump7560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7560:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7561: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7561 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7562
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7562:
	cmp rax, [rsp + 8]
	jl .jump7563
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7563:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7564
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7564:
	; Computing bound for 'v'
	mov rax, [rel const67] ; 88
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7565:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7566
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7566:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7567:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump7568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7568:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7569:
	imul rdi, [rsp + 0 + 16] ; multiply by 88 
	jno .jump7570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7570:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump7571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7571:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7572: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7573:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump7574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7574:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump7575: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7575 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7572 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7572 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7572 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7572 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7576
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7576:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7577:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump7578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7578:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump7579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7579:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7580: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7580 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7580 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7581:
	cmp rax, [rsp + 16]
	jl .jump7582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7582:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7583:
	cmp rax, [rsp + 24]
	jl .jump7584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7584:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7585
	call _f
	push rax
	jmp .jump7586
.jump7585:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7587
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7587:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7588:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump7589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7589:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump7590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7590:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7591: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7592:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7593
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7593:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7594:
	; Computing bound for 'v'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7595
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7595:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump7596
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7596:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump7597
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7597:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump7598
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7598:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump7599
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7599:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump7600: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7600 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7600 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7600 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7600 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const812] ; 551
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7601
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7601:
	cmp rax, [rsp + 32]
	jl .jump7602
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7602:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7603
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7603:
	cmp rax, [rsp + 40]
	jl .jump7604
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7604:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7605
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7605:
	cmp rax, [rsp + 48]
	jl .jump7606
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7606:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7607
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7607:
	cmp rax, [rsp + 56]
	jl .jump7608
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7608:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7609
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump7610
.jump7609:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7611:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump7610:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7591 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7591 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const114] ; 862
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7612:
	cmp rax, [rsp + 8]
	jl .jump7613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7613:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7614:
	cmp rax, [rsp + 16]
	jl .jump7615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7615:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7616:
	cmp rax, [rsp + 24]
	jl .jump7617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7617:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7586:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const700] ; 157
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7618:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,,,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 157) 
	jno .jump7619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7619:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7620: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7621
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7623
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7623:
	; Computing bound for 'u'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7624:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump7625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7625:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump7626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7626:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7627: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 88 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7627 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7627 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump7622
.jump7621:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7628
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7628:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7629:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump7630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7630:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump7631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7631:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7632: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 88 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7632 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7632 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump7622:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7620 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7633
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7633:
	cmp rax, [rsp + 8]
	jl .jump7634
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7634:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7635
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7635:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7636
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7638
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump7639
.jump7638:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump7639:
	pop rax
	neg rax
	push rax
	jmp .jump7637
.jump7636:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump7637:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7640:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7641
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7641:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump7642: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7642 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7642 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7642 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7643
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7643:
	cmp rax, [rsp + 16]
	jl .jump7644
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7644:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7645
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7645:
	cmp rax, [rsp + 24]
	jl .jump7646
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7646:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1041] ; 637
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const285] ; 131
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7647
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7647:
	cmp rax, [rsp + 32]
	jl .jump7648
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7648:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7649
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7649:
	cmp rax, [rsp + 40]
	jl .jump7650
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7650:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7651
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7651:
	cmp rax, [rsp + 48]
	jl .jump7652
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7652:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7653
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7653:
	cmp rax, [rsp + 56]
	jl .jump7654
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7654:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7655:
	cmp rax, [rsp + 32]
	jl .jump7656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7656:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7657:
	cmp rax, [rsp + 40]
	jl .jump7658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7658:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7659:
	cmp rax, [rsp + 48]
	jl .jump7660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7660:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7661:
	cmp rax, [rsp + 56]
	jl .jump7662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7662:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7663
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7665
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7665:
	; Computing bound for 'w'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7666:
	; Computing bound for 'v'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7667
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7667:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7668:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump7669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7669:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump7670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7670:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump7671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7671:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump7672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7672:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7673: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7674:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7675
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7675:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7676:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump7677: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1042] ; 65.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7677 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7677 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7677 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7678
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump7679
.jump7678:
	mov rax, [rel const1043] ; 88.15
	push rax
.jump7679:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7680:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7681
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7681:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7682:
	; Computing bound for 'y'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7683
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7683:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump7684: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1044] ; 37.25
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7684 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7684 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7684 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7684 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1045] ; 50.67
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7673 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7673 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7673 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7673 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7685:
	cmp rax, [rsp + 32]
	jl .jump7686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7686:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7687:
	cmp rax, [rsp + 40]
	jl .jump7688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7688:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7689:
	cmp rax, [rsp + 48]
	jl .jump7690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7690:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7691:
	cmp rax, [rsp + 56]
	jl .jump7692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7692:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump7664
.jump7663:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7693
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump7694
.jump7693:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump7694:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump7695
	mov rax, [rel const1] ; True
	push rax
	jmp .jump7696
.jump7695:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump7696:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7697
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7699:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7700:
	cmp rax, [rsp + 16]
	jl .jump7701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7701:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7702:
	cmp rax, [rsp + 24]
	jl .jump7703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7703:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump7698
.jump7697:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7704
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7706:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7707: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7707 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump7705
.jump7704:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1046] ; 85.74
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump7705:
	mov rax, [rel const1047] ; 71.57
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1048] ; 69.18
	push rax
.jump7698:
.jump7664:
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7708
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump7709
.jump7708:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump7709:
	pop rax
	cmp rax, 0
	je .jump7710
	mov rax, [rel const748] ; 391
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump7711
.jump7710:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7712
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump7713
.jump7712:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7714
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump7715
.jump7714:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump7715:
	pop rax
	neg rax
	push rax
.jump7713:
.jump7711:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7716
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7716:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7717:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7718
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7718:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7719:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7720: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7720 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7720 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7720 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7720 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7721:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7722
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7722:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7723:
	; Computing bound for 'u'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7724
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7724:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump7725: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1049] ; 13.71
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7725 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7725 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7725 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7725 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const749] ; 919
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7726
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7728
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7728:
	cmp rax, [rsp + 16]
	jl .jump7729
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7729:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7730
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7730:
	cmp rax, [rsp + 24]
	jl .jump7731
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7731:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump7727
.jump7726:
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rel const242] ; 138
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7732
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7732:
	cmp rax, [rsp + 16]
	jl .jump7733
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7733:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7734
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7734:
	cmp rax, [rsp + 24]
	jl .jump7735
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7735:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7727:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	add rsp, 104 ; Local variables
	pop rbp
	ret

t:
_t:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9122
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9122:
	; Computing bound for 'A'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9123:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9124
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9124:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9125:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump9126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9126:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump9127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9127:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump9128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9128:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump9129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9129:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump9130: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9130 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9130 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9130 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9130 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9131:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9132
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9132:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump9133
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9133:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump9134
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9134:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump9135: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9136
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9136:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9137:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump9138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9138:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump9139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9139:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9140: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9140 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9140 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1142] ; 182
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9141:
	cmp rax, [rsp + 16]
	jl .jump9142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9142:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9143:
	cmp rax, [rsp + 24]
	jl .jump9144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9144:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9135 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9135 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9145
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9145:
	cmp rax, [rsp + 16]
	jl .jump9146
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9146:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9147
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9147:
	cmp rax, [rsp + 24]
	jl .jump9148
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9148:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9149
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9149:
	push rax
	pop rax
	cmp rax, 0
	je .jump9150
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9152
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9154:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9155
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9155:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9156:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump9157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9157:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump9158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9158:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump9159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9159:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9160: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9160 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9160 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9160 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9161
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9161:
	cmp rax, [rsp + 24]
	jl .jump9162
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9162:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9163
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9163:
	cmp rax, [rsp + 32]
	jl .jump9164
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9164:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9165
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9165:
	cmp rax, [rsp + 40]
	jl .jump9166
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9166:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9167
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9169
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump9170
.jump9169:
	call _d
	push rax
.jump9170:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9171:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9172
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9172:
	; Computing bound for 'K'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9173:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9174
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump9175
.jump9174:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump9175:
	pop rax
	cmp rax, 0
	je .jump9176
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump9177
.jump9176:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump9178
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump9179
.jump9178:
	call _d
	push rax
.jump9179:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9180:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9181
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9181:
	; Computing bound for 'K'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9182:
	; Computing bound for 'J'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9183:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9184
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9184:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9185:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9186: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9186 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9186 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9186 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9187
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9187:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9188: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9188 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9188 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9188 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9188 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump9177:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9189
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9189:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof void[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if (if r then (! false) else (! c)) then F else (sum[J : (sum[J : x, K : m, L : o] H), K : f(), L : w, M : (if false then s else d())] z)) 
	jno .jump9190
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9190:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump9191
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9191:
	imul rdi, [rsp + 0 + 16] ; multiply by (- C) 
	jno .jump9192
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9192:
	imul rdi, [rsp + 0 + 24] ; multiply by (if r then E else d()) 
	jno .jump9193
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9193:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9194: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9195
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9195:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9196:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9197
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9197:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9198
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9198:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump9199
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9199:
	imul rdi, [rsp + 0 + 16] ; multiply by K 
	jno .jump9200
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9200:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump9201: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 16], 1
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9201 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9201 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9201 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9194 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9194 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9194 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9194 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9168
.jump9167:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9202
	call _d
	push rax
	jmp .jump9203
.jump9202:
	mov rax, [rel const307] ; 997
	push rax
.jump9203:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9204:
	; Computing bound for 'K'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9205
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9205:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9206:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof void[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9207:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump9208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9208:
	imul rdi, [rsp + 0 + 16] ; multiply by (if c then d() else 997) 
	jno .jump9209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9209:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9210: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9211
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9211:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9212:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9213
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9213:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9214:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof void[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump9215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9215:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump9216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9216:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump9217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9217:
	imul rdi, [rsp + 0 + 24] ; multiply by H 
	jno .jump9218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9218:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump9219: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9220:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9221
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9221:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9222:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump9223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9223:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump9224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9224:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump9225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9225:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump9226: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9226 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9226 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9226 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9219 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9219 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9219 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9219 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9210 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9210 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9210 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9227
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9227:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9228:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump9229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9229:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump9230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9230:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9231: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9231 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9231 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9232
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump9233
.jump9232:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump9233:
	call _t
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump9234
	sub rsp, 40
	; Moving 40 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9236
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9236:
	cmp rax, [rsp + 32]
	jl .jump9237
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9237:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9238
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9238:
	cmp rax, [rsp + 40]
	jl .jump9239
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9239:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9240
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9240:
	cmp rax, [rsp + 48]
	jl .jump9241
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9241:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9242
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9242:
	cmp rax, [rsp + 56]
	jl .jump9243
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9243:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9235
.jump9234:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9244
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump9245
.jump9244:
	mov rax, [rel const1143] ; 649
	push rax
.jump9245:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9246:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9247
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9247:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9248:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9249
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9249:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9250: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9250 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9250 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9250 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9250 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump9235:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9251
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9251:
	cmp rax, [rsp + 24]
	jl .jump9252
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9252:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9253
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9253:
	cmp rax, [rsp + 32]
	jl .jump9254
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9254:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9255
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9255:
	cmp rax, [rsp + 40]
	jl .jump9256
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9256:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9168:
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9257:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9258: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9258 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _d
	push rax
	mov rax, [rel const348] ; 172
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9259
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9259:
	cmp rax, [rsp + 32]
	jl .jump9260
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9260:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9261
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9261:
	cmp rax, [rsp + 40]
	jl .jump9262
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9262:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9263
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9263:
	cmp rax, [rsp + 48]
	jl .jump9264
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9264:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9265
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9265:
	cmp rax, [rsp + 56]
	jl .jump9266
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9266:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9153
.jump9152:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9267:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof void[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump9268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9268:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9269: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9270:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9271
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9271:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump9272
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9272:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump9273
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9273:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9274: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9274 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9274 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9275
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9275:
	cmp rax, [rsp + 16]
	jl .jump9276
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9276:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9277
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9277:
	cmp rax, [rsp + 24]
	jl .jump9278
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9278:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9279
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9279:
	; Computing bound for 'L'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9280:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9281
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9281:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump9282
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9282:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump9283
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9283:
imul rdi, [rsp + 0 + 16] ; multiply by (array[K : B, L : z] C)[H, C] 
	jno .jump9284
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9284:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9285: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const45] ; False
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9285 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9285 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9285 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9269 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9286
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9286:
	cmp rax, [rsp + 8]
	jl .jump9287
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9287:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9153:
	jmp .jump9151
.jump9150:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9288:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9289
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9289:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9290:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump9291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9291:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump9292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9292:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump9293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9293:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump9294: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9295
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9295:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9296:
	; Computing bound for 'N'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9297:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9298
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9298:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9299:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9300
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9300:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump9301: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9301 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9301 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9301 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9301 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9302
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9302:
	; Computing bound for 'M'
	mov rax, [rel const1144] ; 260
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9303:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 260) 
	jno .jump9304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9304:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[M : (- w), N : l, O : (- m), P : K] G) 
	jno .jump9305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9305:
	imul rdi, [rsp + 0 + 16] ; multiply by J 
	jno .jump9306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9306:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump9307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9307:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump9308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9309
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9311:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9312
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9312:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9313:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9314
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9314:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9315
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9315:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump9316
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9316:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump9317
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9317:
	imul rdi, [rsp + 0 + 24] ; multiply by F 
	jno .jump9318
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9318:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump9319: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9319 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9319 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9319 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9319 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9310
.jump9309:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9320:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9321
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9321:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9322:
	; Computing bound for 'Q'
	mov rax, [rel const316] ; 226
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9323
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9323:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 226 
	jno .jump9324
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9324:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump9325
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9325:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump9326
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9326:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump9327
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9327:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump9328: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9328 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9328 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9328 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9328 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump9310:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9308 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9308 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9308 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9308 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9329
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9329:
	cmp rax, [rsp + 32]
	jl .jump9330
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9330:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9331
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9331:
	cmp rax, [rsp + 40]
	jl .jump9332
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9332:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9333
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9333:
	cmp rax, [rsp + 48]
	jl .jump9334
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9334:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9335
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9335:
	cmp rax, [rsp + 56]
	jl .jump9336
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9336:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9337
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9337:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9338
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9338:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump9339: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9339 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9340:
	cmp rax, [rsp + 8]
	jl .jump9341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9341:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9342:
	cmp rax, [rsp + 32]
	jl .jump9343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9343:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9344:
	cmp rax, [rsp + 40]
	jl .jump9345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9345:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9346:
	cmp rax, [rsp + 48]
	jl .jump9347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9347:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9348:
	cmp rax, [rsp + 56]
	jl .jump9349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9349:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9350:
	cmp rax, [rsp + 32]
	jl .jump9351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9351:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9352:
	cmp rax, [rsp + 40]
	jl .jump9353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9353:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9354:
	cmp rax, [rsp + 48]
	jl .jump9355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9355:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9356:
	cmp rax, [rsp + 56]
	jl .jump9357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9357:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9294 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9294 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9294 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump9151:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump9358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1145] ; 'N'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9358:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9359
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump9359:
	push rax
	pop rax
	cmp rax, 0
	jne .jump9360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1145] ; 'N'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9360:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump9361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1145] ; 'N'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9361:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	add rsp, 120 ; Local variables
	pop rbp
	ret

z:
_z:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9428
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9430
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9430:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- y) 
	jno .jump9431
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9431:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9432: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9433
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9433:
	push rax
	pop rax
	cmp rax, 0
	je .jump9434
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9436:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9437
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9437:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9438:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9439
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9439:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump9440
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9440:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump9441
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9441:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump9442
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9442:
	imul rdi, [rsp + 0 + 24] ; multiply by A 
	jno .jump9443
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9443:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9445
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump9446
.jump9445:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump9446:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9444 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9444 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9444 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9444 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9435
.jump9434:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9447
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9449:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9450
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9450:
	; Computing bound for 'G'
	mov rax, [rel const1146] ; 463
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9451:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9452
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9452:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump9453
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9453:
	imul rdi, [rsp + 0 + 8] ; multiply by 463 
	jno .jump9454
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9454:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump9455
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9455:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump9456
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9456:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9457: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9457 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9457 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9457 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9457 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9448
.jump9447:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9458:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9459
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9459:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9460:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9461
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9461:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump9462
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9462:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump9463
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9463:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump9464
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9464:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump9465
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9465:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9466: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9466 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9466 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9466 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9466 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump9448:
.jump9435:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9432 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump9429
.jump9428:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9467
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9467:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump9468
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9468:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9469: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9470
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9472:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9473
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9473:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9474:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9475
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9475:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump9476
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9476:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump9477
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9477:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump9478
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9478:
	imul rdi, [rsp + 0 + 24] ; multiply by v 
	jno .jump9479
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9479:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9480: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9480 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9480 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9480 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9480 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9471
.jump9470:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump9481
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9483:
	; Computing bound for 'H'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9484
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9484:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9485:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9486
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9486:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump9487
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9487:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump9488
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9488:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump9489
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9489:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump9490
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9490:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9491: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9491 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9491 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9491 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9491 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9482
.jump9481:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	mov rax, [rel const1147] ; 411
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9492:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9493
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9493:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9494:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9495
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9495:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump9496
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9496:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump9497
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9497:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump9498
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9498:
	imul rdi, [rsp + 0 + 24] ; multiply by 411 
	jno .jump9499
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9499:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump9500: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9500 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9500 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9500 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9500 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump9482:
.jump9471:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9469 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump9429:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9501
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9503:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9504
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9504:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump9505
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9505:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump9506
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9506:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9507: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9507 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9507 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump9502
.jump9501:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9508:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9509
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9509:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump9510
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9510:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump9511
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9511:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9512: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9512 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9512 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump9502:
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const1148] ; 984
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9513
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9513:
	cmp rax, [rsp + 16]
	jl .jump9514
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9514:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9515
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9515:
	cmp rax, [rsp + 24]
	jl .jump9516
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9516:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9517
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9517:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9518
	mov rax, [rel const193] ; 749
	push rax
	jmp .jump9519
.jump9518:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9520
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump9521
.jump9520:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump9521:
	pop rax
	cmp rax, 0
	je .jump9522
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump9523
.jump9522:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump9523:
.jump9519:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9524:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9525
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9525:
	; Computing bound for 'E'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9526:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9527: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9527 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9527 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9527 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9527 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9528:
	cmp rax, [rsp + 8]
	jl .jump9529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9529:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9530
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9530:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9531:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9532: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9532 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9532 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9533:
	cmp rax, [rsp + 32]
	jl .jump9534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9534:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9535:
	cmp rax, [rsp + 40]
	jl .jump9536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9536:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9537:
	cmp rax, [rsp + 48]
	jl .jump9538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9538:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9539:
	cmp rax, [rsp + 56]
	jl .jump9540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9540:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9541
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9543
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9545
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump9546
.jump9545:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump9546:
	jmp .jump9544
.jump9543:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
.jump9544:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9547:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9548
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9548:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump9549
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9549:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump9550
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9550:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9551: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9552
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9552:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9553:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump9554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9554:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump9555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9555:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump9556: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9556 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9556 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9551 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9551 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9557
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump9558
.jump9557:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump9558:
	pop rax
	neg rax
	push rax
	pop rdi
	pop rsi
	call _z
	add rsp, 24
	add rsp, 8
	push rax
	pop rax
	cmp rax, 0
	jne .jump9559
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump9559:
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _z
	add rsp, 24
	add rsp, 8
	push rax
	pop rax
	cmp rax, 0
	je .jump9560
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9560:
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump9542
.jump9541:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump9561
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9561:
	push rax
	pop rax
	cmp rax, 0
	je .jump9562
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9564
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9564:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9565:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9566
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9566:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9567:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9568:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump9569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9569:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump9570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9570:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump9571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9571:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9572: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9572 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9572 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9572 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9572 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const731] ; 520
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9573:
	cmp rax, [rsp + 32]
	jl .jump9574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9574:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9575:
	cmp rax, [rsp + 40]
	jl .jump9576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9576:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9577:
	cmp rax, [rsp + 48]
	jl .jump9578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9578:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9579:
	cmp rax, [rsp + 56]
	jl .jump9580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9580:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9563
.jump9562:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump9563:
	pop rax
	cmp rax, 0
	je .jump9581
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9583:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9584:
	; Computing bound for 'E'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9585
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9585:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump9586
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9586:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump9587
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9587:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump9588
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9588:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9589: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump9590
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9592:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump9593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9593:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump9594: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 0], 1
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9594 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump9591
.jump9590:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9595:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump9596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9596:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump9597: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 0], 1
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9597 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump9591:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9589 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9589 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9589 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump9582
.jump9581:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9598:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9599:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9600
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9600:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump9601
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9601:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump9602
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9602:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump9603
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9603:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9604: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9605
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9607:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump9608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9608:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump9609: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 0], 1
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9609 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump9606
.jump9605:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9610:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9611:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump9612: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 0], 1
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9612 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump9606:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9604 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9604 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9604 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump9582:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9613:
	; Computing bound for 'G'
	mov rax, [rel const381] ; 817
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9614
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9614:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9615:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9616
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9616:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9617: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9617 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9617 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9617 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9617 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9618
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9618:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9619:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump9620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9620:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[E : o, F : s, G : 817, H : v] o) 
	jno .jump9621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9621:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9622: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9622 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9622 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9623
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump9623:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9624:
	cmp rax, [rsp + 16]
	jl .jump9625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9625:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9626:
	cmp rax, [rsp + 24]
	jl .jump9627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9627:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9628:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump9629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9629:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump9630: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9630 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9631
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9631:
	cmp rax, [rsp + 8]
	jl .jump9632
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9632:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9633:
	cmp rax, [rsp + 24]
	jl .jump9634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9634:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9635:
	cmp rax, [rsp + 32]
	jl .jump9636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9636:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9637:
	cmp rax, [rsp + 40]
	jl .jump9638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9638:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9639:
	cmp rax, [rsp + 8]
	jl .jump9640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9640:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9542:
	sub rsp, 16
	; Moving 16 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9641
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9641:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9642:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- l) 
	jno .jump9643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9643:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump9644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9644:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9645: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9646
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9646:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9647:
	; Computing bound for 'K'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9648:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9649:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9650: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9650 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9650 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9650 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9651:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9652: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9652 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9653
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9653:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9654:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9655
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9655:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9656: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9656 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9656 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9656 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9657:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9658
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9658:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9659:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9660
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9660:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump9661
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9661:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump9662
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9662:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump9663
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9663:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[K : w, L : l, M : (sum[K : (sum[K : (s / d()), L : l, M : I] F)] n)] l) 
	jno .jump9664
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9664:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9665: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9666
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9666:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9667:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump9668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9668:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump9669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9669:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump9670: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const114] ; 862
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9671
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9673
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9675
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9675:
	cmp rax, [rsp + 16]
	jl .jump9676
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9676:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9677
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9677:
	cmp rax, [rsp + 24]
	jl .jump9678
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9678:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9674
.jump9673:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9679
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump9680
.jump9679:
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
.jump9680:
.jump9674:
	jmp .jump9672
.jump9671:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9681
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9683
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9683:
	cmp rax, [rsp + 16]
	jl .jump9684
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9684:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9685
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9685:
	cmp rax, [rsp + 24]
	jl .jump9686
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9686:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9682
.jump9681:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9687
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump9688
.jump9687:
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
.jump9688:
.jump9682:
.jump9672:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9670 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9670 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9665 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9665 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9665 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9665 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9689
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9689:
	cmp rax, [rsp + 32]
	jl .jump9690
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9690:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9691
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9691:
	cmp rax, [rsp + 40]
	jl .jump9692
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9692:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9693
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9693:
	cmp rax, [rsp + 48]
	jl .jump9694
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9694:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9695
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9695:
	cmp rax, [rsp + 56]
	jl .jump9696
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9696:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9645 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9645 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9697
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump9698
.jump9697:
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
.jump9698:
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9699
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9701
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump9702
.jump9701:
	mov rax, [rel const45] ; False
	push rax
.jump9702:
	pop rax
	cmp rax, 0
	je .jump9703
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump9704
.jump9703:
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump9704:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9705:
	; Computing bound for 'I'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9706
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9706:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump9707
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9707:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (if p then a else false) then l else (- n)) 
	jno .jump9708
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9708:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9709: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9709 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9709 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9710
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9710:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9711: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9712
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9712:
	cmp rax, [rsp + 8]
	jl .jump9713
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9713:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9711 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9714
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9714:
	cmp rax, [rsp + 16]
	jl .jump9715
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9715:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9716
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9716:
	cmp rax, [rsp + 24]
	jl .jump9717
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9717:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9718
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9718:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9719:
	; Computing bound for 'J'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9720
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9720:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9721:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump9722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9722:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump9723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9723:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump9724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9724:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump9725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9725:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9726: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9726 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9726 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9726 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9726 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const386] ; 483
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9727:
	cmp rax, [rsp + 32]
	jl .jump9728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9728:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9729:
	cmp rax, [rsp + 40]
	jl .jump9730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9730:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9731:
	cmp rax, [rsp + 48]
	jl .jump9732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9732:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9733:
	cmp rax, [rsp + 56]
	jl .jump9734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9734:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9735
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump9735:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump9700
.jump9699:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump9700:
	pop rax
	cmp rax, 0
	je .jump9736
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9738
	mov rax, [rel const1149] ; 44.19
	push rax
	jmp .jump9739
.jump9738:
	mov rax, [rel const327] ; 58.67
	push rax
.jump9739:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9740
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9740:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9741:
	; Computing bound for 'I'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9742
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9742:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9743: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1150] ; 68.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9743 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9743 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9743 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1151] ; 69.16
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9744
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9744:
	cmp rax, [rsp + 8]
	jl .jump9745
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9745:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9746
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9748
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump9749
.jump9748:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9750:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9751
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9751:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9752
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump9753
.jump9752:
	call _d
	push rax
.jump9753:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9754:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof void[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then F else d()) 
	jno .jump9755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9755:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump9756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9756:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump9757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9757:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9758: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9759
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9759:
	; Computing bound for 'N'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9760:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9761
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9761:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9762:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump9763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9763:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump9764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9764:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump9765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9765:
	imul rdi, [rsp + 0 + 24] ; multiply by m 
	jno .jump9766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9766:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump9767: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9767 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9767 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9767 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9767 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9758 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9758 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9758 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9768
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9768:
	cmp rax, [rsp + 32]
	jl .jump9769
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9769:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9770
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9770:
	cmp rax, [rsp + 40]
	jl .jump9771
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9771:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9772
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9772:
	cmp rax, [rsp + 48]
	jl .jump9773
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9773:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9774
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9774:
	cmp rax, [rsp + 56]
	jl .jump9775
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9775:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9776
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9776:
	cmp rax, [rsp + 24]
	jl .jump9777
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9777:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9778
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9778:
	cmp rax, [rsp + 32]
	jl .jump9779
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9779:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9780
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9780:
	cmp rax, [rsp + 40]
	jl .jump9781
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9781:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9782
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump9783
.jump9782:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump9783:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9784
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9784:
	cmp rax, [rsp + 32]
	jl .jump9785
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9785:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9786
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9786:
	cmp rax, [rsp + 40]
	jl .jump9787
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9787:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9788
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9788:
	cmp rax, [rsp + 48]
	jl .jump9789
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9789:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9790
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9790:
	cmp rax, [rsp + 56]
	jl .jump9791
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9791:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9749:
	jmp .jump9747
.jump9746:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9792
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9794
	sub rsp, 16
	; Moving 16 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump9795
.jump9794:
	sub rsp, 16
	; Moving 16 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump9795:
	jmp .jump9793
.jump9792:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9796
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9798
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9798:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump9799
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9799:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9800: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9800 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump9797
.jump9796:
	mov rax, [rel const1] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump9797:
.jump9793:
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9801
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9801:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump9802
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9802:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump9803: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9803 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const1152] ; 363
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9804:
	cmp rax, [rsp + 8]
	jl .jump9805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9805:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9806:
	cmp rax, [rsp + 32]
	jl .jump9807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9807:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9808:
	cmp rax, [rsp + 40]
	jl .jump9809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9809:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9810:
	cmp rax, [rsp + 48]
	jl .jump9811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9811:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9812:
	cmp rax, [rsp + 56]
	jl .jump9813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9813:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9814:
	cmp rax, [rsp + 8]
	jl .jump9815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9815:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
.jump9747:
	jmp .jump9737
.jump9736:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump9737:
	call _t
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	add rsp, 48 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1153] ; 'K'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9816:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9817
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump9818
.jump9817:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump9818:
	pop rax
	cmp rax, 0
	je .jump9819
	sub rsp, 16
	; Moving 16 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump9820
.jump9819:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9821
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9821:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump9822
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9822:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9823: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9823 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump9820:
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9824:
	cmp rax, [rsp + 8]
	jl .jump9825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9825:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9826
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9828
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9830:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9831
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9831:
	; Computing bound for 'M'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9832:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9833
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9833:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9834:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9835:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump9836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9836:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump9837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9837:
	imul rdi, [rsp + 0 + 24] ; multiply by (A / w) 
	jno .jump9838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9838:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9839: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9839 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9839 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9839 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9839 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9840:
	cmp rax, [rsp + 32]
	jl .jump9841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9841:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9842:
	cmp rax, [rsp + 40]
	jl .jump9843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9843:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9844:
	cmp rax, [rsp + 48]
	jl .jump9845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9845:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9846:
	cmp rax, [rsp + 56]
	jl .jump9847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9847:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9829
.jump9828:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9848
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9848:
	; Computing bound for 'K'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9849:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump9850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9850:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump9851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9851:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9852: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9852 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9852 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9853
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump9854
.jump9853:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump9854:
	pop rax
	cmp rax, 0
	jne .jump9855
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9855:
	push rax
	pop rax
	cmp rax, 0
	je .jump9856
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump9857
.jump9856:
	call _d
	push rax
	pop rax
	neg rax
	push rax
.jump9857:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9858:
	cmp rax, [rsp + 16]
	jl .jump9859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9859:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9860:
	cmp rax, [rsp + 24]
	jl .jump9861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9861:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9829:
	jmp .jump9827
.jump9826:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9862
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump9863
.jump9862:
	mov rax, [rel const1] ; True
	push rax
.jump9863:
	pop rax
	cmp rax, 0
	jne .jump9864
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9864:
	push rax
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9865
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9865:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9866:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump9867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9867:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump9868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9868:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9869: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9869 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9869 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	call _t
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9870
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump9871
.jump9870:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9872
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9872:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9873:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump9874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9874:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump9875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9875:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9876: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9876 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9876 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	call _t
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump9877
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9879
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9879:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9880:
	; Computing bound for 'L'
	mov rax, [rel const1154] ; 437
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9881
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9881:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9882:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump9883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9883:
	imul rdi, [rsp + 0 + 8] ; multiply by 437 
	jno .jump9884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9884:
	imul rdi, [rsp + 0 + 16] ; multiply by (- n) 
	jno .jump9885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9885:
	imul rdi, [rsp + 0 + 24] ; multiply by I 
	jno .jump9886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9886:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9887: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9887 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9887 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9887 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9887 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump9878
.jump9877:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9888
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9888:
	; Computing bound for 'M'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9889:
	; Computing bound for 'L'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9890:
	; Computing bound for 'L'
	mov rax, [rel const852] ; 684
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9891
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9891:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9892:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9893: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9893 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9893 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9893 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9894
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9894:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9895:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump9896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9896:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[K : H, L : 684, M : x] f()) 
	jno .jump9897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9897:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump9898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9898:
	imul rdi, [rsp + 0 + 24] ; multiply by m 
	jno .jump9899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9899:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9900: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9900 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9900 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9900 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9900 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump9878:
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9901
	call _d
	push rax
	jmp .jump9902
.jump9901:
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
.jump9902:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const507] ; 355
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9903:
	cmp rax, [rsp + 32]
	jl .jump9904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9904:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9905:
	cmp rax, [rsp + 40]
	jl .jump9906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9906:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9907:
	cmp rax, [rsp + 48]
	jl .jump9908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9908:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9909:
	cmp rax, [rsp + 56]
	jl .jump9910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9910:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9871:
.jump9827:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9911:
	; Computing bound for 'K'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9912:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9913
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9913:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9914
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9914:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump9915
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9915:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9916: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	mov rax, [rel const104] ; 171
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9917
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9917:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9918:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9919
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9919:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump9920
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9920:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump9921
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9921:
	imul rdi, [rsp + 0 + 16] ; multiply by 171 
	jno .jump9922
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9922:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump9923: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9923 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9923 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9923 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9916 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9916 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9924
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9924:
	cmp rax, [rsp + 16]
	jl .jump9925
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9925:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9926
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9926:
	cmp rax, [rsp + 24]
	jl .jump9927
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9927:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const525] ; 670
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9928
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9928:
	cmp rax, [rsp + 24]
	jl .jump9929
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9929:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9930
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9930:
	cmp rax, [rsp + 32]
	jl .jump9931
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9931:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9932
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9932:
	cmp rax, [rsp + 40]
	jl .jump9933
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9933:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9934
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9934:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[K : s, L : l] (array[M : y, N : n, O : 171] w))[I, A][670, H, l] 
	jno .jump9935
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9935:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump9936
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9936:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9937: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9938
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9938:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9939:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump9940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9940:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump9941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9941:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump9942: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9942 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9942 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9937 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9937 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9943
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump9944
.jump9943:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _z
	add rsp, 24
	add rsp, 8
	push rax
	pop rdi
	call _h
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9945:
	cmp rax, [rsp + 8]
	jl .jump9946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9946:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9944:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9947
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump9948
.jump9947:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump9948:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9949:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9950
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9950:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump9951: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const485] ; 110
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9951 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9951 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rdi
	pop rsi
	call _z
	add rsp, 24
	add rsp, 8
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _z
	add rsp, 24
	add rsp, 8
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump9952
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump9953
.jump9952:
	mov rax, [rel const1] ; True
	push rax
.jump9953:
	pop rax
	cmp rax, 0
	jne .jump9954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1153] ; 'K'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9954:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 72 ; Local variables
	pop rbp
	ret

A:
_A:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9955
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9955:
	; Computing bound for 'I'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9956
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9956:
	; Computing bound for 'G'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9957:
	; Computing bound for 'G'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9958
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9958:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9959:
	; Computing bound for 'H'
	mov rax, [rel const714] ; 372
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9960
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9960:
	; Computing bound for 'G'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9961
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9961:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump9962: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 0], 1
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9962 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9963:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump9964: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9964 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9964 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9964 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9964 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9965:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump9966: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9967
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9967:
	cmp rax, [rsp + 8]
	jl .jump9968
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9968:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9966 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9966 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9969:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump9970: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9970 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9970 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9971:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9972:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9973:
	; Computing bound for 'G'
	mov rax, [rel const738] ; 55
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9974:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 55) 
	jno .jump9975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9975:
	imul rdi, [rsp + 0 + 8] ; multiply by (C / l) 
	jno .jump9976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9976:
imul rdi, [rsp + 0 + 16] ; multiply by (- (sum[G : (sum[G : (sum[G : (sum[G : w] C), H : 372, I : l, J : n] d()), H : y] [s][G]), H : w] m)) 
	jno .jump9977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9977:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump9978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9978:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump9979: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9979 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9979 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9979 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9979 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 48 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 48 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9980
	lea rdi, [rel const1155] ; 'M'
	call _fail_assertion
.jump9980:
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const90] ; 173
	push rax
	mov rax, [rel const1156] ; 71.02
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _A
	add rsp, 24
	add rsp, 16
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9981:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9982
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9982:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9983:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump9984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9984:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump9985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9985:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump9986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9986:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump9987: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9987 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9987 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9987 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9988:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump9989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9989:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump9990: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9990 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9991
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9991:
	cmp rax, [rsp + 8]
	jl .jump9992
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9992:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9993
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump9994
.jump9993:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9995:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9996:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9997
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9997:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() / o) 
	jno .jump9998
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9998:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump9999
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9999:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump10000: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10001
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10003:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump10004
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10004:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump10005: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 0], 1
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10005 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump10002
.jump10001:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10006
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10006:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump10007
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10007:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump10008: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 0], 1
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10008 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump10002:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10000 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10000 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10009
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10009:
	cmp rax, [rsp + 16]
	jl .jump10010
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10010:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10011
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10011:
	cmp rax, [rsp + 24]
	jl .jump10012
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10012:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9994:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10013:
	; Computing bound for 'S'
	mov rax, [rel const274] ; 565
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10014
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10014:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by 565 
	jno .jump10015
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10015:
	imul rdi, [rsp + 0 + 8] ; multiply by P 
	jno .jump10016
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10016:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump10017: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10017 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10017 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10018
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10018:
	cmp rax, [rsp + 16]
	jl .jump10019
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10019:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10020
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10020:
	cmp rax, [rsp + 24]
	jl .jump10021
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10021:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10022
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump10023
.jump10022:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10024
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10024:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by R 
	jno .jump10025
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10025:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump10026: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10026 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump10023:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 96 ; Local variables
	pop rbp
	ret

C:
_C:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10027
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10027:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10028:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump10029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10029:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10030:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10031: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10031 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10031 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10032
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10032:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10033:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10034
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10034:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10035:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump10036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10036:
	imul rdi, [rsp + 0 + 8] ; multiply by I 
	jno .jump10037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10037:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump10038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10038:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump10039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10039:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10040: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10040 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10040 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10040 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10040 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10041
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10043:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10044
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10044:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump10045
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10045:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump10046
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10046:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10047: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10047 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10047 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10042
.jump10041:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10048:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10049
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10049:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump10050
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10050:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10051
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10051:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10052: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10052 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10052 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump10042:
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10053
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10053:
	cmp rax, [rsp + 16]
	jl .jump10054
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10054:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10055
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10055:
	cmp rax, [rsp + 24]
	jl .jump10056
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10056:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10057:
	cmp rax, [rsp + 8]
	jl .jump10058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10058:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10059:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10060
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10060:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10061: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10061 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10061 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10062:
	cmp rax, [rsp + 32]
	jl .jump10063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10063:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10064:
	cmp rax, [rsp + 40]
	jl .jump10065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10065:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10066:
	cmp rax, [rsp + 48]
	jl .jump10067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10067:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10068:
	cmp rax, [rsp + 56]
	jl .jump10069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10069:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	call _t
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10070
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10072
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10074
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10074:
	; Computing bound for 'N'
	mov rax, [rel const644] ; 341
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10075:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10076
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10076:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10077:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (n * s) 
	jno .jump10078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10078:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10079:
	imul rdi, [rsp + 0 + 16] ; multiply by 341 
	jno .jump10080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10080:
	imul rdi, [rsp + 0 + 24] ; multiply by I 
	jno .jump10081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10081:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10082: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10083:
	; Computing bound for 'P'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10084
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10084:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump10085
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10085:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump10086
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10086:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump10087: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10087 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10087 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10082 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10082 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10082 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10082 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump10088
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump10088:
	push rax
	pop rax
	cmp rax, 0
	je .jump10089
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	jmp .jump10090
.jump10089:
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump10090:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump10091
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump10091:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10092:
	cmp rax, [rsp + 32]
	jl .jump10093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10093:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10094:
	cmp rax, [rsp + 40]
	jl .jump10095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10095:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10096:
	cmp rax, [rsp + 48]
	jl .jump10097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10097:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10098:
	cmp rax, [rsp + 56]
	jl .jump10099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10099:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10073
.jump10072:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10100
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10100:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10101:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10102
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10102:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump10103
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10103:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10104
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10104:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump10105
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10105:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10106: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10107:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10108
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10108:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump10109
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10109:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump10110
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10110:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump10111: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10111 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10111 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10106 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10106 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10106 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10112:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump10113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10113:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10114: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1157] ; 28
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10114 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10115
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10115:
	cmp rax, [rsp + 8]
	jl .jump10116
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10116:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10117:
	cmp rax, [rsp + 24]
	jl .jump10118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10118:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10119:
	cmp rax, [rsp + 32]
	jl .jump10120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10120:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10121:
	cmp rax, [rsp + 40]
	jl .jump10122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10122:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10073:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10123
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10125:
	; Computing bound for 'M'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10126
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10126:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10127:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump10128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10128:
	imul rdi, [rsp + 0 + 8] ; multiply by (F * d()) 
	jno .jump10129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10129:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump10130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10130:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10131: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10131 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10131 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10131 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10132
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10132:
	; Computing bound for 'L'
	mov rax, [rel const397] ; 937
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10133:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10134: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10134 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10134 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10135
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10135:
	cmp rax, [rsp + 24]
	jl .jump10136
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10136:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10137
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10137:
	cmp rax, [rsp + 32]
	jl .jump10138
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10138:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10139
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10139:
	cmp rax, [rsp + 40]
	jl .jump10140
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10140:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10124
.jump10123:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10141:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10142
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10142:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10143
	call _f
	push rax
	jmp .jump10144
.jump10143:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
.jump10144:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10145:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10146
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10146:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (- o) 
	jno .jump10147
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10147:
	imul rdi, [rsp + 0 + 8] ; multiply by (if r then f() else v) 
	jno .jump10148
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10148:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump10149
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10149:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump10150
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10150:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10151: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10151 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10151 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10151 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10151 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10152
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump10153
.jump10152:
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump10153:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10154
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10154:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10155:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10156: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10156 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10156 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10157
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10157:
	cmp rax, [rsp + 32]
	jl .jump10158
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10158:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10159
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10159:
	cmp rax, [rsp + 40]
	jl .jump10160
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10160:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10161
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10161:
	cmp rax, [rsp + 48]
	jl .jump10162
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10162:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10163
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10163:
	cmp rax, [rsp + 56]
	jl .jump10164
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10164:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10124:
	call _t
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump10165
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10167
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10169
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10169:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10170:
	; Computing bound for 'M'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10171
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10171:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10172:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10173:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump10174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10174:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump10175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10175:
	imul rdi, [rsp + 0 + 24] ; multiply by B 
	jno .jump10176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10176:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10177: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 200 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10177 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10177 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10177 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10177 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump10168
.jump10167:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10178
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10178:
	; Computing bound for 'N'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10179:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10180:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10181:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump10182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10182:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump10183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10183:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump10184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10184:
	imul rdi, [rsp + 0 + 24] ; multiply by F 
	jno .jump10185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10185:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10186: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 200 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10186 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10186 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10186 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10186 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump10168:
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10187:
	cmp rax, [rsp + 8]
	jl .jump10188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10188:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10166
.jump10165:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10189
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10189:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10190:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[,,,][,,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump10191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10191:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump10192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10192:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10193: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10194:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump10195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10195:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump10196: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	mov rax, [rel const6] ; 150
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10197
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10197:
	; Computing bound for 'Q'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10198:
	; Computing bound for 'P'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10199
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10199:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10200:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump10201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10201:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump10202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10202:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump10203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10203:
	imul rdi, [rsp + 0 + 24] ; multiply by 150 
	jno .jump10204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10204:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump10205: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10205 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10205 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10205 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10205 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'N'
	add qword [rsp + 0], 1
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10196 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10193 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10193 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10206
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump10206:
	push rax
	pop rax
	cmp rax, 0
	je .jump10207
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump10208
.jump10207:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump10208:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10209:
	cmp rax, [rsp + 16]
	jl .jump10210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10210:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10211:
	cmp rax, [rsp + 24]
	jl .jump10212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10212:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10213:
	cmp rax, [rsp + 8]
	jl .jump10214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10214:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10166:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10215:
	cmp rax, [rsp + 32]
	jl .jump10216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10216:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10217:
	cmp rax, [rsp + 40]
	jl .jump10218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10218:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10219:
	cmp rax, [rsp + 48]
	jl .jump10220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10220:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10221:
	cmp rax, [rsp + 56]
	jl .jump10222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10222:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10071
.jump10070:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10223:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10224
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10224:
	; Computing bound for 'M'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10225:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10226
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10226:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump10227
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10227:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump10228
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10228:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump10229
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10229:
	imul rdi, [rsp + 0 + 24] ; multiply by m 
	jno .jump10230
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10230:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10231: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10231 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10231 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10231 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10231 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10232
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10232:
	cmp rax, [rsp + 32]
	jl .jump10233
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10233:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10234
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10234:
	cmp rax, [rsp + 40]
	jl .jump10235
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10235:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10236
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10236:
	cmp rax, [rsp + 48]
	jl .jump10237
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10237:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10238
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10238:
	cmp rax, [rsp + 56]
	jl .jump10239
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10239:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10240
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10240:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10241:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10242
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10242:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump10243
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10243:
	imul rdi, [rsp + 0 + 8] ; multiply by (J + l) 
	jno .jump10244
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10244:
imul rdi, [rsp + 0 + 16] ; multiply by (array[L : x, M : d(), N : o, O : m] M)[o, l, s, K] 
	jno .jump10245
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10245:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump10246: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump10247
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10249:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump10250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10250:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump10251: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump10252
	sub rsp, 40
	; Moving 40 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 200 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump10253
.jump10252:
	sub rsp, 40
	; Moving 40 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 200 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
.jump10253:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10251 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10254
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10254:
	cmp rax, [rsp + 8]
	jl .jump10255
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10255:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10248
.jump10247:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10256:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump10257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10257:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump10258: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10259
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10259:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10260:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10261
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10261:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump10262
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10262:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10263
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10263:
	imul rdi, [rsp + 0 + 16] ; multiply by H 
	jno .jump10264
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10264:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump10265: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10265 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10265 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10265 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10258 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	mov rax, [rel const982] ; 830
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10266:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10267
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10267:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump10268: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10268 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10268 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10269
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10269:
	cmp rax, [rsp + 8]
	jl .jump10270
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10270:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10271
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10271:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump10272: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10272 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10273
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10273:
	cmp rax, [rsp + 24]
	jl .jump10274
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10274:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10275
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10275:
	cmp rax, [rsp + 32]
	jl .jump10276
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10276:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10277
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10277:
	cmp rax, [rsp + 40]
	jl .jump10278
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10278:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10248:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10246 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10246 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10246 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10279:
	cmp rax, [rsp + 24]
	jl .jump10280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10280:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10281:
	cmp rax, [rsp + 32]
	jl .jump10282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10282:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10283:
	cmp rax, [rsp + 40]
	jl .jump10284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10284:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10071:
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10285:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10286
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10286:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10287:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump10288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10288:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10289:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump10290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10290:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10291: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10292:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10293
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10293:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump10294
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10294:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump10295
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10295:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump10296: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10297
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10297:
	; Computing bound for 'aa'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10298:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump10299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10299:
	imul rdi, [rsp + 0 + 8] ; multiply by R 
	jno .jump10300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10300:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
.jump10301: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 8], 1
	; Compare ab to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10301 ; If ab < bound, next iter
	mov qword [rsp + 8], 0 ; ab = 0
	add qword [rsp + 0], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10301 ; If aa < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Z'
	add qword [rsp + 8], 1
	; Compare Z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10296 ; If Z < bound, next iter
	mov qword [rsp + 8], 0 ; Z = 0
	add qword [rsp + 0], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10296 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10302
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10302:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10303:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10304
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10304:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10305:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10306:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump10307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10307:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump10308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10308:
	imul rdi, [rsp + 0 + 24] ; multiply by S 
	jno .jump10309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10309:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump10310: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 24], 1
	; Compare ab to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10310 ; If ab < bound, next iter
	mov qword [rsp + 24], 0 ; ab = 0
	add qword [rsp + 16], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10310 ; If aa < bound, next iter
	mov qword [rsp + 16], 0 ; aa = 0
	add qword [rsp + 8], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10310 ; If Z < bound, next iter
	mov qword [rsp + 8], 0 ; Z = 0
	add qword [rsp + 0], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10310 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10311
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10311:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump10312: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'Y'
	add qword [rsp + 0], 1
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10312 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10313:
	cmp rax, [rsp + 32]
	jl .jump10314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10314:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10315:
	cmp rax, [rsp + 40]
	jl .jump10316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10316:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10317:
	cmp rax, [rsp + 48]
	jl .jump10318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10318:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10319:
	cmp rax, [rsp + 56]
	jl .jump10320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10320:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10321:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump10322: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10323
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10323:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10324:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump10325: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10325 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10325 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'Y'
	add qword [rsp + 0], 1
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10322 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1158] ; 23.0
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _z
	add rsp, 24
	add rsp, 8
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 16], 1
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10291 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10291 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10291 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump10326
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10328
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10330
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump10332
	mov rax, [rel const45] ; False
	push rax
	jmp .jump10333
.jump10332:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump10333:
	jmp .jump10331
.jump10330:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump10331:
	pop rax
	cmp rax, 0
	je .jump10334
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10336:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump10337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10337:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10338: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10338 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rdi, 64
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 4
	push rax
	jmp .jump10335
.jump10334:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10339:
	cmp rax, [rsp + 32]
	jl .jump10340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10340:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10341:
	cmp rax, [rsp + 40]
	jl .jump10342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10342:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10343:
	cmp rax, [rsp + 48]
	jl .jump10344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10344:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10345:
	cmp rax, [rsp + 56]
	jl .jump10346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10346:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10347:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by k[S, I, o, R] 
	jno .jump10348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10348:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10349: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10350
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10350:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10351
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10351:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump10352: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 0], 1
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10352 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10349 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump10335:
	jmp .jump10329
.jump10328:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10353
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
.jump10353:
	push rax
	pop rax
	cmp rax, 0
	je .jump10354
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10356:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (U * n) 
	jno .jump10357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10357:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10358: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10359
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10359:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump10360
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10360:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump10361: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 0], 1
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10361 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10358 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump10355
.jump10354:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	mov rax, [rel const89] ; 126
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10362:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 126 
	jno .jump10363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10363:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10364: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10364 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump10355:
.jump10329:
	jmp .jump10327
.jump10326:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10365:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10366
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10366:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10367:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10368
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10368:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[][] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10369
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10369:
	imul rdi, [rsp + 0 + 8] ; multiply by (S * U) 
	jno .jump10370
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10370:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump10371
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10371:
	imul rdi, [rsp + 0 + 24] ; multiply by (H + d()) 
	jno .jump10372
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10372:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10373: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10374
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10374:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump10375
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10375:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump10376: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'Z'
	add qword [rsp + 0], 1
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10376 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10373 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10373 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10373 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10373 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10377
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10377:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10378:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10379: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10379 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10379 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10380
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10380:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10381: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10381 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10382
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10382:
	cmp rax, [rsp + 32]
	jl .jump10383
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10383:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10384
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10384:
	cmp rax, [rsp + 40]
	jl .jump10385
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10385:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10386
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10386:
	cmp rax, [rsp + 48]
	jl .jump10387
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10387:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10388
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10388:
	cmp rax, [rsp + 56]
	jl .jump10389
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10389:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10327:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10390
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10390:
	cmp rax, [rsp + 8]
	jl .jump10391
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10391:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10392
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10394:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10395
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10395:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump10396
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10396:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump10397
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10397:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10398: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10399
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10401
	mov rax, [rel const1159] ; 19.42
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump10402
.jump10401:
	mov rax, [rel const1160] ; 31.1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump10402:
	jmp .jump10400
.jump10399:
	mov rax, [rel const1161] ; 28.65
	push rax
.jump10400:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10398 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10398 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10393
.jump10392:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump10403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10403:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10404:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10405
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump10406
.jump10405:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump10406:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10407
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump10408
.jump10407:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump10408:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10409
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10409:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if D then n else m) - (if (j <= j) then w else M)) 
	jno .jump10410
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10410:
	imul rdi, [rsp + 0 + 8] ; multiply by (- ((v % m) - v)) 
	jno .jump10411
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10411:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10412: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10413
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump10414
.jump10413:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10415
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10415:
	; Computing bound for 'Z'
	mov rax, [rel const636] ; 905
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10416:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10417
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10417:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10418:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump10419: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const470] ; 17.28
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10419 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10419 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10419 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10419 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump10414:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10412 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10412 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump10393:
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10420
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10420:
	cmp rax, [rsp + 16]
	jl .jump10421
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10421:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10422
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10422:
	cmp rax, [rsp + 24]
	jl .jump10423
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10423:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump10424
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump10425
.jump10424:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump10425:
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10426
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump10426:
	push rax
	pop rax
	cmp rax, 0
	jne .jump10427
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump10427:
	push rax
	pop rax
	cmp rax, 0
	je .jump10428
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump10429
.jump10428:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10430:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10431
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10431:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10432:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by H 
	jno .jump10433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10433:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump10434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10434:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump10435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10435:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10436: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10437
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump10438
.jump10437:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump10438:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 16], 1
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10436 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10436 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10436 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10439
	sub rsp, 8 ; Add alignment
	mov rax, [rel const45] ; False
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump10440
.jump10439:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
.jump10440:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10441
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump10442
.jump10441:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10443
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10443:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump10444
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10444:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10445: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10445 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump10442:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10446
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10448:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10449
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10449:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10450:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10451
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10451:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump10452
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10452:
	imul rdi, [rsp + 0 + 8] ; multiply by J 
	jno .jump10453
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10453:
	imul rdi, [rsp + 0 + 16] ; multiply by R 
	jno .jump10454
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10454:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump10455
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10455:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10456: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1162] ; 13.59
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10456 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10456 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10456 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10456 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10457
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10457:
	cmp rax, [rsp + 32]
	jl .jump10458
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10458:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10459
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10459:
	cmp rax, [rsp + 40]
	jl .jump10460
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10460:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10461
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10461:
	cmp rax, [rsp + 48]
	jl .jump10462
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10462:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10463
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10463:
	cmp rax, [rsp + 56]
	jl .jump10464
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10464:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10447
.jump10446:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10465:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by H 
	jno .jump10466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10466:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10467: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10467 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10468
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10468:
	cmp rax, [rsp + 8]
	jl .jump10469
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10469:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10447:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump10429:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1163] ; 16.51
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump10470
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10472
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10472:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10473
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump10474
.jump10473:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10475
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump10476
.jump10475:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump10476:
.jump10474:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10477:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then U else (if p then w else S)) 
	jno .jump10478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10478:
	imul rdi, [rsp + 0 + 8] ; multiply by U 
	jno .jump10479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10479:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10480: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10481
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump10482
.jump10481:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
.jump10482:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10480 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10480 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10483:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10484
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10484:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump10485
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10485:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump10486
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10486:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10487: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10488
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump10489
.jump10488:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump10489:
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10487 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10487 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10490
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10490:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10491:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by R 
	jno .jump10492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10492:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump10493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10493:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10494: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10494 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10494 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 72
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 72 bytes from rsp to rax 
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72
	push rax
	mov rax, 3
	push rax
	jmp .jump10471
.jump10470:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10495
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10497
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10497:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump10498
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10498:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump10499: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	mov rax, [rel const819] ; 101
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10500:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10501
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10501:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump10502
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10502:
	imul rdi, [rsp + 0 + 8] ; multiply by 101 
	jno .jump10503
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10503:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump10504: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 8], 1
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10504 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10504 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10499 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump10496
.jump10495:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10505
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump10506
.jump10505:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
.jump10506:
	pop rax
	cmp rax, 0
	je .jump10507
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10509
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump10510
.jump10509:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump10510:
	jmp .jump10508
.jump10507:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump10508:
.jump10496:
.jump10471:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 56]
	call _C
	add rsp, 16
	add rsp, 40
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 128 ; Local variables
	pop rbp
	ret
	sub rsp, 40
	; Moving 40 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump10511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1164] ; 'aa'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10511:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10512:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump10513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10513:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
.jump10514: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 0], 1
	; Compare aa to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10514 ; If aa < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10515
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10517
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10517:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10518: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'ab'
	add qword [rsp + 0], 1
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10518 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10519:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10520
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10520:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump10521
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10521:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[ab : P] s) 
	jno .jump10522
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10522:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10523: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10523 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10523 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10516
.jump10515:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10524
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10526:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by Y 
	jno .jump10527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10527:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10528: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 0], 1
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10528 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10529
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10529:
	cmp rax, [rsp + 8]
	jl .jump10530
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10530:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10531
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10533:
	; Computing bound for 'ab'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10534
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10534:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump10535
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10535:
	imul rdi, [rsp + 0 + 8] ; multiply by Z 
	jno .jump10536
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10536:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10537: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10538
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10538:
	; Computing bound for 'af'
	mov rax, [rel const723] ; 6
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10539:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10540
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10540:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10541:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10542:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump10543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10543:
	imul rdi, [rsp + 0 + 16] ; multiply by 6 
	jno .jump10544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10544:
	imul rdi, [rsp + 0 + 24] ; multiply by P 
	jno .jump10545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10545:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10546: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10547:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10548
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10548:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump10549
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10549:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump10550
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10550:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
.jump10551: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ai'
	add qword [rsp + 8], 1
	; Compare ai to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10551 ; If ai < bound, next iter
	mov qword [rsp + 8], 0 ; ai = 0
	add qword [rsp + 0], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10551 ; If ah < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ag'
	add qword [rsp + 24], 1
	; Compare ag to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10546 ; If ag < bound, next iter
	mov qword [rsp + 24], 0 ; ag = 0
	add qword [rsp + 16], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10546 ; If af < bound, next iter
	mov qword [rsp + 16], 0 ; af = 0
	add qword [rsp + 8], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10546 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10546 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10552:
	cmp rax, [rsp + 32]
	jl .jump10553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10553:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10554:
	cmp rax, [rsp + 40]
	jl .jump10555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10555:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10556:
	cmp rax, [rsp + 48]
	jl .jump10557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10557:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10558:
	cmp rax, [rsp + 56]
	jl .jump10559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10559:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10537 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10537 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10532
.jump10531:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10560:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10561
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10561:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump10562
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10562:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10563
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10563:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10564: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10565
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10565:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10566:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump10567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10567:
	imul rdi, [rsp + 0 + 8] ; multiply by W 
	jno .jump10568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10568:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10569: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 8], 1
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10569 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10569 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10570:
	cmp rax, [rsp + 8]
	jl .jump10571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10571:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10564 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10564 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump10532:
	jmp .jump10525
.jump10524:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10572
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10574:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10575
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10575:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10576
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10576:
	imul rdi, [rsp + 0 + 8] ; multiply by M 
	jno .jump10577
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10577:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10578: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10579
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10579:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10580:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump10581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10581:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump10582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10582:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10583: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10584:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10585
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10585:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ac 
	jno .jump10586
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10586:
	imul rdi, [rsp + 0 + 8] ; multiply by ae 
	jno .jump10587
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10587:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump10588: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ag'
	add qword [rsp + 8], 1
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10588 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10588 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ae'
	add qword [rsp + 8], 1
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10583 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10583 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10589:
	cmp rax, [rsp + 16]
	jl .jump10590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10590:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10591:
	cmp rax, [rsp + 24]
	jl .jump10592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10592:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10578 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10578 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10573
.jump10572:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10593:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump10594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10594:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10595: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 0], 1
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10595 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10596
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10596:
	cmp rax, [rsp + 8]
	jl .jump10597
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10597:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10598
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10600:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10601
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10601:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump10602
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10602:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump10603
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10603:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10604: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump10605
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10607
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10607:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10608:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump10609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10609:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump10610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10610:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10611: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 8], 1
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10611 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10611 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10606
.jump10605:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10612
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10612:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10613:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump10614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10614:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump10615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10615:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10616: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 8], 1
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10616 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10616 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump10606:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10604 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10604 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10599
.jump10598:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10617:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10618
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10618:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump10619
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10619:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump10620
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10620:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10621: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1165] ; 51.67
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10622
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10624
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10624:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10625:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by U 
	jno .jump10626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10626:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump10627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10627:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10628: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 8], 1
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10628 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10628 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump10623
.jump10622:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10629
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10629:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10630:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by U 
	jno .jump10631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10631:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump10632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10632:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump10633: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 8], 1
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10633 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10633 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump10623:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10621 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10621 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump10599:
.jump10573:
.jump10525:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10634
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10634:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10635:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump10636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10636:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10637
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10637:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10638:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump10639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10639:
	imul rdi, [rsp + 0 + 8] ; multiply by (O % v) 
	jno .jump10640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10640:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump10641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10641:
	imul rdi, [rsp + 0 + 24] ; multiply by H 
	jno .jump10642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10642:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10643: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10644
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10646
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10648:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10649:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10650:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump10651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10651:
	imul rdi, [rsp + 0 + 8] ; multiply by ac 
	jno .jump10652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10652:
	imul rdi, [rsp + 0 + 16] ; multiply by N 
	jno .jump10653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10653:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump10654: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10654 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10654 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10654 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump10647
.jump10646:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10655:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10656
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10656:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10657:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump10658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10658:
	imul rdi, [rsp + 0 + 8] ; multiply by Y 
	jno .jump10659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10659:
	imul rdi, [rsp + 0 + 16] ; multiply by M 
	jno .jump10660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10660:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump10661: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10661 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10661 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10661 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump10647:
	jmp .jump10645
.jump10644:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10662:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10663
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10663:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10664:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump10665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10665:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump10666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10666:
	imul rdi, [rsp + 0 + 16] ; multiply by (- o) 
	jno .jump10667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10667:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump10668: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10668 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10668 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10668 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump10645:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 24], 1
	; Compare ae to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump10643 ; If ae < bound, next iter
	mov qword [rsp + 24], 0 ; ae = 0
	add qword [rsp + 16], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump10643 ; If ad < bound, next iter
	mov qword [rsp + 16], 0 ; ad = 0
	add qword [rsp + 8], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump10643 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump10643 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10669:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10670
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10670:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump10671: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10671 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10671 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10672:
	cmp rax, [rsp + 32]
	jl .jump10673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10673:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10674:
	cmp rax, [rsp + 40]
	jl .jump10675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10675:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10676:
	cmp rax, [rsp + 48]
	jl .jump10677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10677:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump10678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10678:
	cmp rax, [rsp + 56]
	jl .jump10679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10679:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10680:
	cmp rax, [rsp + 24]
	jl .jump10681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10681:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10682:
	cmp rax, [rsp + 32]
	jl .jump10683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10683:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump10684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10684:
	cmp rax, [rsp + 40]
	jl .jump10685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10685:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10686
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10686:
	cmp rax, [rsp + 16]
	jl .jump10687
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10687:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10688
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10688:
	cmp rax, [rsp + 24]
	jl .jump10689
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10689:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10516:
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 240 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp ; end of jpl_main prelude
	lea rdi, [rel const0] ; 'a'
	sub rsp, 8 ; Add alignment
	call _print
	add rsp, 8 ; Remove alignment
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const2] ; 614
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const4] ; 798
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4:
	; Computing bound for 'b'
	mov rax, [rel const5] ; 19
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5:
	; Computing bound for 'a'
	mov rax, [rel const6] ; 150
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump7: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump11
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump11:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump12
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump12:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump13
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump13:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump14
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump14:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump15
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump15:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump16: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump16 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump16 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump16 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump16 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump17
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump17:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump18:
	; Computing bound for 'd'
	mov rax, [rel const8] ; 864
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump19:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump20: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump20 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump20 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump20 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump21
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump21:
	cmp rax, [rsp + 32]
	jl .jump22
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump22:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump23
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump23:
	cmp rax, [rsp + 40]
	jl .jump24
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump24:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump25
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump25:
	cmp rax, [rsp + 48]
	jl .jump26
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump26:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump27
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump27:
	cmp rax, [rsp + 56]
	jl .jump28
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump28:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump29
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump29:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const11] ; 953
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump30
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump30:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const12] ; 876
	push rax
	mov rax, [rel const13] ; 471
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump31
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump31:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump32
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump32:
	; Computing bound for 'c'
	mov rax, [rel const15] ; 835
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump33
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump33:
	; Computing bound for 'b'
	mov rax, [rel const16] ; 523
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump34
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump34:
	; Computing bound for 'a'
	mov rax, [rel const17] ; 925
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump35
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump35:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump36: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump36 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump36 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump36 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump36 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump37
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump37:
	; Computing bound for 'b'
	mov rax, [rel const18] ; 666
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump38
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump38:
	; Computing bound for 'a'
	mov rax, [rel const19] ; 910
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump39
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump39:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump40: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const20] ; 499
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump40 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump40 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump40 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump40 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump41
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump41:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump42: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump43
	mov rax, [rel const21] ; 76.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump44
.jump43:
	mov rax, [rel const22] ; 30.64
	push rax
	mov rax, [rel const23] ; 20.55
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump44:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump42 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump42 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump42 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2
.jump1:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const24] ; 209
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump45
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump45:
	; Computing bound for 'a'
	mov rax, [rel const25] ; 970
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump46
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump46:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 970 
	jno .jump47
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump47:
	imul rdi, [rsp + 0 + 8] ; multiply by 209 
	jno .jump48
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump48:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump49: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; 431
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump49 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump49 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const27] ; 454
	push rax
	mov rax, [rel const28] ; 51
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump50
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump50:
	cmp rax, [rsp + 16]
	jl .jump51
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump51:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump52
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump52:
	cmp rax, [rsp + 24]
	jl .jump53
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump53:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump54
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump54:
	; Computing bound for 'c'
	mov rax, [rel const29] ; 201
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump55
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump55:
	; Computing bound for 'b'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump56
	mov rax, [rel const30] ; 650
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump57
.jump56:
	mov rax, [rel const31] ; 419
	push rax
	mov rax, [rel const32] ; 887
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump58
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump58:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump57:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump59
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump59:
	; Computing bound for 'a'
	mov rax, [rel const34] ; 80.35
	push rax
	mov rax, [rel const35] ; 29.35
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump60
	mov rax, [rel const36] ; 874
	push rax
	jmp .jump61
.jump60:
	mov rax, [rel const37] ; 264
	push rax
.jump61:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump62
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump62:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (29.35 >= 80.35) then 874 else 264) 
	jno .jump63
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump63:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then (- 650) else (887 % 419)) 
	jno .jump64
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump64:
	imul rdi, [rsp + 0 + 16] ; multiply by 201 
	jno .jump65
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump65:
imul rdi, [rsp + 0 + 24] ; multiply by (array[a : 970, b : 209] 431)[51, 454] 
	jno .jump66
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump66:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump67: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump68
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump68:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump69
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump69:
	; Computing bound for 'e'
	mov rax, [rel const38] ; 196
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump70
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump70:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump71: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const39] ; 66.67
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump71 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump71 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump71 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump67 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump67 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump67 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump67 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const40] ; 77
	push rax
	mov rax, [rel const41] ; 249
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const42] ; 977
	push rax
	mov rax, [rel const43] ; 642
	push rax
	mov rax, [rel const44] ; 266
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump72
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump72:
	cmp rax, [rsp + 32]
	jl .jump73
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump73:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump74
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump74:
	cmp rax, [rsp + 40]
	jl .jump75
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump75:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump76
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump76:
	cmp rax, [rsp + 48]
	jl .jump77
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump77:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump78
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump78:
	cmp rax, [rsp + 56]
	jl .jump79
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump79:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump80
	mov rax, [rel const46] ; 71.6
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const47] ; 65.08
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const48] ; 4.65
	push rax
	mov rax, [rel const49] ; 51.39
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump82
	mov rax, [rel const50] ; 34.38
	push rax
	jmp .jump83
.jump82:
	mov rax, [rel const51] ; 3.28
	push rax
.jump83:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump81
.jump80:
	mov rax, [rel const52] ; 76.65
	push rax
	mov rax, [rel const53] ; 68.7
	push rax
	mov rax, [rel const54] ; 16.69
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump84
	mov rax, [rel const55] ; 43.77
	push rax
	jmp .jump85
.jump84:
	mov rax, [rel const56] ; 64.74
	push rax
.jump85:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump81:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump86
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump87
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump89
	mov rax, [rel const57] ; 380
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump90
.jump89:
	mov rax, [rel const58] ; 559
	push rax
	mov rax, [rel const59] ; 849
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump91
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump91:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump90:
	mov rax, [rel const60] ; 277
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump92
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const61] ; 633
	push rax
	mov rax, [rel const17] ; 925
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump94
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump94:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump95: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const62] ; 799
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump95 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump93
.jump92:
	mov rax, [rel const63] ; 567
	push rax
.jump93:
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump88
.jump87:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const64] ; 14.01
	push rax
	mov rax, [rel const65] ; 87.69
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump96
	mov rax, [rel const66] ; 853
	push rax
	jmp .jump97
.jump96:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const67] ; 88
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump98
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump98:
	; Computing bound for 'b'
	mov rax, [rel const68] ; 389
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump99
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump99:
	; Computing bound for 'a'
	mov rax, [rel const69] ; 428
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump100
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump100:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump101: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump101 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump101 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump101 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const70] ; 675
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump102
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump102:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump97:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump103:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump104: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump105
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump105:
	; Computing bound for 'c'
	mov rax, [rel const71] ; 832
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump106:
	; Computing bound for 'b'
	mov rax, [rel const72] ; 3
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump107
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump107:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 3 
	jno .jump108
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump108:
	imul rdi, [rsp + 0 + 8] ; multiply by 832 
	jno .jump109
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump109:
	imul rdi, [rsp + 0 + 16] ; multiply by a 
	jno .jump110
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump110:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump111: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const73] ; 95.57
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump111 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump111 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump111 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump112
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump112:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump113: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const74] ; 570
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump113 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const75] ; 952
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump114:
	cmp rax, [rsp + 24]
	jl .jump115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump115:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump116:
	cmp rax, [rsp + 32]
	jl .jump117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump117:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump118:
	cmp rax, [rsp + 40]
	jl .jump119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump119:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump104 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const76] ; 55.33
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const77] ; 96.6
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const78] ; 35.56
	push rax
	mov rax, [rel const79] ; 52.18
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const80] ; 151
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump120:
	cmp rax, [rsp + 8]
	jl .jump121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump121:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump88:
	pop rax
	cmp rax, 0
	je .jump122
	mov rax, [rel const81] ; 48.35
	push rax
	mov rax, [rel const82] ; 99.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump124
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump124:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump125
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump126
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump126:
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump125:
	push rax
	jmp .jump123
.jump122:
	mov rax, [rel const45] ; False
	push rax
.jump123:
	pop rax
.jump86:
	push rax
	pop rax
	cmp rax, 0
	jne .jump127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const0] ; 'a'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump127:
	mov rax, [rel const83] ; 88.33
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const84] ; 989
	push rax
	mov rax, [rel const85] ; 298
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const86] ; 659
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const87] ; 211
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump128:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump129
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump129:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const88] ; 793
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump130:
	; Computing bound for 'b'
	mov rax, [rel const89] ; 126
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump131
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump131:
	; Computing bound for 'a'
	mov rax, [rel const90] ; 173
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump132:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump133: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump134
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump134:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump135: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const91] ; 726
	push rax
	mov rax, [rel const87] ; 211
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump135 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump133 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump133 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump133 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump136
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump136:
	; Computing bound for 'a'
	mov rax, [rel const92] ; 923
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump137:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump138: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump139:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump138 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump138 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump140:
	; Computing bound for 'a'
	mov rax, [rel const93] ; 613
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const94] ; 236
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const95] ; 390
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump141
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump141:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump142: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump143:
	; Computing bound for 'f'
	mov rax, [rel const96] ; 87.36
	push rax
	mov rax, [rel const97] ; 95.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump144
	mov rax, [rel const98] ; 934
	push rax
	jmp .jump145
.jump144:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump146:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump147: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const99] ; 591
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump147 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump148:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump145:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump149:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump150:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump151
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump151:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump152: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const100] ; 20.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump152 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump152 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump152 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump152 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump142 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump142 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump142 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const101] ; 51.8
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const102] ; 246
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump153:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump154: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const103] ; 33.39
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump154 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const93] ; 613
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump155:
	; Computing bound for 'b'
	mov rax, [rel const104] ; 171
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump156
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump156:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const105] ; 586
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump157
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump157:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump158: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump158 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const106] ; 901
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const107] ; 595
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump159
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump159:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump160:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump161: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump162
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump162:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump163
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump163:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump164:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump165: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump166:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump167
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump167:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump168: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump168 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump168 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump165 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump165 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump169:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump170
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump170:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump171: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump172:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump173
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump173:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump174:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump175
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump175:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump176
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump176:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump177
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump177:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump178
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump178:
	imul rdi, [rsp + 0 + 24] ; multiply by a 
	jno .jump179
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump179:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump180: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const108] ; 10.75
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump180 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump180 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump180 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump180 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump181
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump181:
	cmp rax, [rsp + 32]
	jl .jump182
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump182:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump183
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump183:
	cmp rax, [rsp + 40]
	jl .jump184
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump184:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump185
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump185:
	cmp rax, [rsp + 48]
	jl .jump186
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump186:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump187
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump187:
	cmp rax, [rsp + 56]
	jl .jump188
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump188:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump171 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump171 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump171 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump161 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump161 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump161 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const62] ; 799
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump189
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump189:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 799) 
	jno .jump190
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump190:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump191: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const109] ; 212
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump191 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const110] ; 651
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump192:
	cmp rax, [rsp + 8]
	jl .jump193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump193:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const111] ; 598
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump194
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump194:
	; Computing bound for 'b'
	mov rax, [rel const112] ; 764
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump195:
	; Computing bound for 'a'
	mov rax, [rel const113] ; 325
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump196
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump196:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump197 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump197 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump197 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const114] ; 862
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const115] ; 883
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump198:
	cmp rax, [rsp + 8]
	jl .jump199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump199:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump200
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump202
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const116] ; 106
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump203
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump203:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump204: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const117] ; 60
	push rax
	mov rax, [rel const118] ; 395
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump205:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump204 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const119] ; 239
	push rax
	mov rax, [rel const120] ; 731
	push rax
	mov rax, [rel const94] ; 236
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump206
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump206:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump207:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump202:
	push rax
	pop rax
	cmp rax, 0
	je .jump208
	mov rax, [rel const121] ; 871
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const122] ; 52
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump210:
	; Computing bound for 'b'
	mov rax, [rel const123] ; 202
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump211
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump211:
	; Computing bound for 'a'
	mov rax, [rel const124] ; 397
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump212:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump213: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump213 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump213 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump213 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump209
.jump208:
	mov rax, [rel const125] ; 822
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const126] ; 16
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump214
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump214:
	push rax
	pop rax
	cmp rax, 0
	je .jump215
	mov rax, [rel const50] ; 34.38
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const127] ; 5.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump215:
	push rax
.jump209:
	pop rax
	cmp rax, 0
	je .jump216
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump218
	mov rax, [rel const128] ; 58.78
	push rax
	jmp .jump219
.jump218:
	mov rax, [rel const129] ; 76.11
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump219:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const130] ; 75.08
	push rax
	mov rax, [rel const131] ; 85.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const132] ; 63.51
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const133] ; 54.18
	push rax
	mov rax, [rel const134] ; 63.82
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump217
.jump216:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump220
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const135] ; 66
	push rax
	mov rax, [rel const136] ; 44
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump222:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump223
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump223:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump224: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump225:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump226
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump226:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump227: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const137] ; 42.28
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump227 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump227 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump224 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump221
.jump220:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump228
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const138] ; 528
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump229
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump229:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump230: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump230 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const139] ; 147
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump228:
	push rax
	pop rax
	cmp rax, 0
	je .jump231
	mov rax, [rel const140] ; 84.16
	push rax
	mov rax, [rel const141] ; 91.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const142] ; 75.02
	push rax
	mov rax, [rel const143] ; 16.9
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const144] ; 51.54
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const145] ; 237
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump233:
	cmp rax, [rsp + 8]
	jl .jump234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump234:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump232
.jump231:
	mov rax, [rel const146] ; 73.69
	push rax
.jump232:
.jump221:
.jump217:
	jmp .jump201
.jump200:
	mov rax, [rel const147] ; 70.61
	push rax
.jump201:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2633
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2635
	mov rax, [rel const538] ; 418
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump2636
.jump2635:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2637
	mov rax, [rel const286] ; 296
	push rax
	jmp .jump2638
.jump2637:
	call _d
	push rax
.jump2638:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const218] ; 718
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2639:
	; Computing bound for 'e'
	mov rax, [rel const539] ; 444
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2640
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2640:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 444 
	jno .jump2641
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2641:
	imul rdi, [rsp + 0 + 8] ; multiply by 718 
	jno .jump2642
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2642:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2643: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2643 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2643 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	mov rax, [rel const227] ; 309
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2644:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2645
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2645:
	cmp rax, [rsp + 16]
	jl .jump2646
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2646:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2647
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2647:
	cmp rax, [rsp + 24]
	jl .jump2648
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2648:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2649
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump2649:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump2636:
	pop rax
	neg rax
	push rax
	jmp .jump2634
.jump2633:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2650
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump2651
.jump2650:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2651:
	pop rax
	cmp rax, 0
	je .jump2652
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2653
.jump2652:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2654
	mov rax, [rel const540] ; 549
	push rax
	mov rax, [rel const541] ; 322
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump2655
.jump2654:
	mov rax, [rel const542] ; 85
	push rax
	pop rax
	neg rax
	push rax
.jump2655:
	mov rax, [rel const18] ; 666
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump2653:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2656
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2656:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2657
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2659
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2659:
	; Computing bound for 'e'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2660:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d()) 
	jno .jump2661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2661:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2662:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2663: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2663 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2663 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2658
.jump2657:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const302] ; 15
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2664
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2664:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2665
	call _d
	push rax
	jmp .jump2666
.jump2665:
	call _d
	push rax
.jump2666:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2667:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then d() else d()) 
	jno .jump2668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2668:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 15) 
	jno .jump2669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2669:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2670: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2670 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2670 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2658:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2671
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump2672
.jump2671:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2673
	mov rax, [rel const543] ; 569
	push rax
	jmp .jump2674
.jump2673:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2674:
	pop rax
	neg rax
	push rax
.jump2672:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2675
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2675:
	; Computing bound for 'g'
	mov rax, [rel const544] ; 902
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2676:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2677:
	; Computing bound for 'e'
	mov rax, [rel const545] ; 629
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2678
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2678:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 629 
	jno .jump2679
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2679:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2680
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2680:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2681: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const546] ; 188
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2681 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2681 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2682
	mov rax, [rel const4] ; 798
	push rax
	jmp .jump2683
.jump2682:
	call _d
	push rax
.jump2683:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2684:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2685
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2685:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2686: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2686 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2686 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2687
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2687:
	cmp rax, [rsp + 16]
	jl .jump2688
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2688:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2689
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2689:
	cmp rax, [rsp + 24]
	jl .jump2690
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2690:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2691
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2691:
	; Computing bound for 'e'
	mov rax, [rel const547] ; 254
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2692:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2693: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2694
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2696:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2697
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2697:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2698:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2699: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2699 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2699 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2699 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2695
.jump2694:
	mov rax, [rel const263] ; 116
	push rax
.jump2695:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2693 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2693 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2693 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2693 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2700:
	cmp rax, [rsp + 16]
	jl .jump2701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2701:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2702:
	cmp rax, [rsp + 24]
	jl .jump2703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2703:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2704:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2705: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2705 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2705 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2634:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2706:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2707
	mov rax, [rel const44] ; 266
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2709
	mov rax, [rel const548] ; 41
	push rax
	jmp .jump2710
.jump2709:
	mov rax, [rel const549] ; 602
	push rax
.jump2710:
	jmp .jump2708
.jump2707:
	mov rax, [rel const550] ; 756
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump2708:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2711:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2712
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2714
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump2715
.jump2714:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump2715:
	jmp .jump2713
.jump2712:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2713:
	pop rax
	cmp rax, 0
	je .jump2716
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2718:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2719:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2720: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2720 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2721
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2721:
	; Computing bound for 'f'
	mov rax, [rel const551] ; 501
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2722:
	; Computing bound for 'e'
	mov rax, [rel const544] ; 902
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2723
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2723:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 902 
	jno .jump2724
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2724:
	imul rdi, [rsp + 0 + 8] ; multiply by 501 
	jno .jump2725
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2725:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[e : d()] d()) 
	jno .jump2726
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2726:
	imul rdi, [rsp + 0 + 24] ; multiply by (- d()) 
	jno .jump2727
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2727:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2728: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2728 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2728 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2728 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2728 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2717
.jump2716:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const552] ; 224
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2729:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2730:
	; Computing bound for 'f'
	mov rax, [rel const553] ; 455
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2731
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2731:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2732:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2733: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2733 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2733 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2733 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2733 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2734:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2735
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2735:
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2736:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2737
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2737:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2738
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2738:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2739
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2739:
	imul rdi, [rsp + 0 + 16] ; multiply by (d() + d()) 
	jno .jump2740
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2740:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[e : d(), f : 455, g : d(), h : 224] h) 
	jno .jump2741
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2741:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2742: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2742 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2742 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2742 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2742 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2717:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2743
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2743:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2744:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2745:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2746:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2747: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2747 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2747 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const190] ; 510
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2748:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2749
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2749:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2750: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2751
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2751:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2752: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2752 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2750 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2750 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2753:
	cmp rax, [rsp + 16]
	jl .jump2754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2754:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2755:
	cmp rax, [rsp + 24]
	jl .jump2756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2756:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const554] ; 107
	push rax
	mov rax, [rel const80] ; 151
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rel const555] ; 672
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2757:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2758
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2759
.jump2758:
	mov rax, [rel const556] ; 125
	push rax
.jump2759:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2760
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2760:
	; Computing bound for 'f'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2761:
	; Computing bound for 'e'
	mov rax, [rel const335] ; 230
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2762
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2762:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2763: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const30] ; 650
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2763 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2763 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2763 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2763 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2764:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2765
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2765:
	cmp rax, [rsp + 32]
	jl .jump2766
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2766:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2767
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2767:
	cmp rax, [rsp + 40]
	jl .jump2768
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2768:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2769
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2769:
	cmp rax, [rsp + 48]
	jl .jump2770
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2770:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2771
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2771:
	cmp rax, [rsp + 56]
	jl .jump2772
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2772:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2773
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2773:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const26] ; 431
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2774
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2774:
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2775:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2776
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2776:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2777: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2777 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2777 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2777 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const85] ; 298
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2778:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2779
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2780
.jump2779:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2780:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2781
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2781:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2782:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2783: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2783 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2783 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2783 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const88] ; 793
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2784:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2785: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const557] ; 213
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2785 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2785 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2785 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2786
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2786:
	; Computing bound for 'g'
	mov rax, [rel const558] ; 49
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2787:
	; Computing bound for 'f'
	mov rax, [rel const559] ; 113
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2788
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2788:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2789
	mov rax, [rel const293] ; 36
	push rax
	jmp .jump2790
.jump2789:
	mov rax, [rel const560] ; 146
	push rax
.jump2790:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2791:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2792: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const561] ; 9.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2792 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2792 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2792 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2792 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const153] ; 50.25
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2793
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2795
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2795:
	; Computing bound for 'e'
	mov rax, [rel const562] ; 894
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2796:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 894 
	jno .jump2797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2797:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2798:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2799: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2799 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2799 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2794
.jump2793:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2800:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2801
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2801:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2802: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const563] ; 32
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2802 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2802 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2803
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2803:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2804:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2805:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[e : d(), f : d()] 32) 
	jno .jump2806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2806:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2807: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2808
	mov rax, [rel const459] ; 25
	push rax
	jmp .jump2809
.jump2808:
	mov rax, [rel const564] ; 446
	push rax
.jump2809:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2807 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2807 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2794:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const565] ; 729
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2810
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2812
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2813
.jump2812:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2813:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump2811
.jump2810:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2811:
	pop rax
	cmp rax, 0
	je .jump2814
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2816
	call _d
	push rax
	jmp .jump2817
.jump2816:
	call _d
	push rax
	pop rax
	neg rax
	push rax
.jump2817:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2818
	mov rax, [rel const1] ; True
	push rax
	jmp .jump2819
.jump2818:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump2819:
	pop rax
	cmp rax, 0
	je .jump2820
	mov rax, [rel const566] ; 926
	push rax
	jmp .jump2821
.jump2820:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2821:
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump2815
.jump2814:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2822
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump2823
.jump2822:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump2823:
	pop rax
	cmp rax, 0
	je .jump2824
	call _d
	push rax
	jmp .jump2825
.jump2824:
	call _d
	push rax
.jump2825:
	mov rax, [rel const567] ; 240
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2826:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump2815:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2827:
	cmp rax, [rsp + 16]
	jl .jump2828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2828:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2829:
	cmp rax, [rsp + 24]
	jl .jump2830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2830:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2831:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2832
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2832:
	; Computing bound for 'e'
	mov rax, [rel const568] ; 781
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2833:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2834: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2834 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2834 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2834 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const148] ; 'e'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2835:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2836
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2838:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2839
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2839:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2840
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2840:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2841
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2841:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2842: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2843
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump2844
.jump2843:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump2844:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2845
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2845:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rel const569] ; 636
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2846
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2848
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump2849
.jump2848:
	mov rax, [rel const570] ; 536
	push rax
.jump2849:
	jmp .jump2847
.jump2846:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2850
	call _d
	push rax
	jmp .jump2851
.jump2850:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2852
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2852:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2853: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2853 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump2851:
.jump2847:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2854
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const42] ; 977
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2856:
	cqo
	idiv r10
	push rax
	mov rax, [rel const350] ; 540
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2857:
	cqo
	idiv r10
	push rax
	jmp .jump2855
.jump2854:
	mov rax, [rel const460] ; 704
	push rax
.jump2855:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2858:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by ((if (d() == e) then (540 / (977 / e)) else 704) + (if (! (636 > d())) then (if (! c) then (d() + d()) else 536) else (if false then d() else (sum[g : e] g)))) 
	jno .jump2859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2859:
	imul rdi, [rsp + 0 + 8] ; multiply by (if c then e else e) 
	jno .jump2860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2860:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2861: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2862
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2864:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2865: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const571] ; 705
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2866
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2866:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2867: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const572] ; 97.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2867 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2865 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const573] ; 26.04
	push rax
	mov rax, [rel const574] ; 56.07
	push rax
	mov rax, [rel const575] ; 91.42
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const576] ; 36.85
	push rax
	mov rax, [rel const577] ; 29.76
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2863
.jump2862:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2868
	mov rax, [rel const578] ; 20.65
	push rax
	jmp .jump2869
.jump2868:
	mov rax, [rel const579] ; 89.53
	push rax
.jump2869:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump2870
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump2870:
	push rax
	pop rax
	cmp rax, 0
	je .jump2871
	mov rax, [rel const580] ; 87.94
	push rax
	jmp .jump2872
.jump2871:
	mov rax, [rel const581] ; 27.93
	push rax
.jump2872:
	mov rax, [rel const582] ; 97.0
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2873
	mov rax, [rel const583] ; 74.1
	push rax
	jmp .jump2874
.jump2873:
	mov rax, [rel const584] ; 21.67
	push rax
.jump2874:
.jump2863:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2861 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2861 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2842 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2842 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2837
.jump2836:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const585] ; 719
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2875
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2875:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2876
	mov rax, [rel const160] ; 895
	push rax
	jmp .jump2877
.jump2876:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const586] ; 285
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2878
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2878:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2879: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2880
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2881
.jump2880:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2881:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2879 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump2877:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2882:
	; Computing bound for 'f'
	mov rax, [rel const587] ; 662
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2883
	call _d
	push rax
	jmp .jump2884
.jump2883:
	call _d
	push rax
.jump2884:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2885:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2886
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2886:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2887:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2888:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- (if false then d() else d())) / 662) 
	jno .jump2889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2889:
imul rdi, [rsp + 0 + 16] ; multiply by (if a then 895 else (sum[e : 285] (if c then d() else d()))) 
	jno .jump2890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2890:
	imul rdi, [rsp + 0 + 24] ; multiply by 719 
	jno .jump2891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2891:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2892: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2892 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2892 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2892 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2892 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2893
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2895:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2896
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2896:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump2897
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2897:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2898
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2898:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2899: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2899 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2899 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const419] ; 518
	push rax
	mov rax, [rel const135] ; 66
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2900
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2900:
	cmp rax, [rsp + 16]
	jl .jump2901
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2901:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2902
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2902:
	cmp rax, [rsp + 24]
	jl .jump2903
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2903:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2894
.jump2893:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2904
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump2905
.jump2904:
	mov rax, [rel const45] ; False
	push rax
.jump2905:
.jump2894:
	pop rax
	cmp rax, 0
	je .jump2906
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const588] ; 361
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2908:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const589] ; 680
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2909
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2909:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const267] ; 399
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2910
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2910:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2911: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2911 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2912:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2913: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2913 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2913 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2913 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2907
.jump2906:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2907:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2914
	mov rax, [rel const451] ; 103
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump2915
.jump2914:
	mov rax, [rel const220] ; 176
	push rax
.jump2915:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const590] ; 990
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2916:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2917:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2918
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2918:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2919: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2919 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2919 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2920
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2920:
	; Computing bound for 'e'
	mov rax, [rel const304] ; 245
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2921:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 245 
	jno .jump2922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2922:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[e : d(), f : d()] e) 
	jno .jump2923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2923:
	imul rdi, [rsp + 0 + 16] ; multiply by 990 
	jno .jump2924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2924:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2925: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2925 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2925 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2925 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const591] ; 915
	push rax
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2926
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2926:
	cmp rax, [rsp + 24]
	jl .jump2927
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2927:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2928
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2928:
	cmp rax, [rsp + 32]
	jl .jump2929
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2929:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2930
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2930:
	cmp rax, [rsp + 40]
	jl .jump2931
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2931:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2932
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump2932:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const592] ; 946
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2933:
	; Computing bound for 'g'
	mov rax, [rel const593] ; 808
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2934
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2934:
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2935:
	; Computing bound for 'e'
	mov rax, [rel const91] ; 726
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2936
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2936:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 726 
	jno .jump2937
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2937:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump2938
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2938:
	imul rdi, [rsp + 0 + 16] ; multiply by 808 
	jno .jump2939
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2939:
	imul rdi, [rsp + 0 + 24] ; multiply by 946 
	jno .jump2940
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2940:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2941: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const247] ; 321
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2941 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2941 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2941 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2941 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const594] ; 376
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const90] ; 173
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2942
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2942:
	cmp rax, [rsp + 32]
	jl .jump2943
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2943:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2944
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2944:
	cmp rax, [rsp + 40]
	jl .jump2945
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2945:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2946
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2946:
	cmp rax, [rsp + 48]
	jl .jump2947
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2947:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2948
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump2948:
	cmp rax, [rsp + 56]
	jl .jump2949
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump2949:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const455] ; 334
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2950
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const87] ; 211
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2952:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2953
	mov rax, [rel const595] ; 17
	push rax
	jmp .jump2954
.jump2953:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump2954:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2955
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2955:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2956: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2956 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2956 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2951
.jump2950:
	mov rax, [rel const596] ; 400
	push rax
.jump2951:
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2957:
	cmp rax, [rsp + 32]
	jl .jump2958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2958:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2959:
	cmp rax, [rsp + 40]
	jl .jump2960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2960:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2961:
	cmp rax, [rsp + 48]
	jl .jump2962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2962:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2963:
	cmp rax, [rsp + 56]
	jl .jump2964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2964:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2965:
	; Computing bound for 'e'
	mov rax, [rel const597] ; 840
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2966
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2966:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 840 
	jno .jump2967
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2967:
imul rdi, [rsp + 0 + 8] ; multiply by (array[e : d(), f : ((- (if false then d() else d())) / 662), g : (if a then 895 else (sum[e : 285] (if c then d() else d()))), h : 719] g)[d(), (if (334 < (array[e : 726, f : d(), g : 808, h : 946] 321)[173, (- d()), (- d()), 376]) then (sum[e : (- (if c then 17 else d())), f : 211] e) else 400), ((array[e : 245, f : (sum[e : d(), f : d()] e), g : 990] g)[d(), d(), 915] % (- (if c then (- 103) else 176))), (if (if (! a) then (array[e : d(), f : d()] a)[66, 518] else (if a then c else false)) then (sum[e : (sum[e : (- 399)] d()), f : (680 * (- d())), g : (d() + (- 361))] (- f)) else d())] 
	jno .jump2968
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump2968:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2969: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2970
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2972:
	cmp rax, [rsp + 8]
	jl .jump2973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2973:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2971
.jump2970:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2971:
	pop rax
	cmp rax, 0
	je .jump2974
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2975
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2975:
	; Computing bound for 'g'
	mov rax, [rel const281] ; 796
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2976:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 796 
	jno .jump2977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2977:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2978:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2979: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2979 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2979 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2980
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump2981
.jump2980:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump2981:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2982
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2982:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2983: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2983 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2984:
	cmp rax, [rsp + 16]
	jl .jump2985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2985:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2986:
	cmp rax, [rsp + 24]
	jl .jump2987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2987:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2988
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump2989
.jump2988:
	mov rax, [rel const1] ; True
	push rax
.jump2989:
	pop rax
.jump2974:
	push rax
	pop rax
	cmp rax, 0
	je .jump2990
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2992
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2993
.jump2992:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump2993:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2994
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2994:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2995
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump2996
.jump2995:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump2996:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2997:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (a != a) then (- (- d())) else e) 
	jno .jump2998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2998:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (if a then d() else e)) 
	jno .jump2999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2999:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3000: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const598] ; 38.42
	push rax
	mov rax, [rel const599] ; 12.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const600] ; 57.51
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3001:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3002: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const601] ; 62.07
	push rax
	mov rax, [rel const602] ; 59.15
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3002 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3003:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3004: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3005:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3006: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const603] ; 45.57
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3006 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3004 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3000 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3000 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2991
.jump2990:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3007
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump3008
.jump3007:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump3008:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3009
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3009:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3010:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- e)) 
	jno .jump3011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3011:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (d() == d()) then f else f) 
	jno .jump3012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3012:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3013: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const604] ; 14.05
	push rax
	mov rax, [rel const605] ; 46.05
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3014:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3015
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3015:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3016:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3017: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const606] ; 56.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3017 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3017 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3017 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3018
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3018:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rel const273] ; 273
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3019:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3020: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const607] ; 5.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3020 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3020 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3013 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3013 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2991:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2969 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2969 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2837:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3021
	mov rax, [rel const608] ; 95
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3023
	call _d
	push rax
	jmp .jump3024
.jump3023:
	mov rax, [rel const346] ; 604
	push rax
.jump3024:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3025:
	; Computing bound for 'e'
	mov rax, [rel const609] ; 40
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3026
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3026:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3027: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const610] ; 163
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3027 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3027 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3028
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3028:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3029:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3030
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3030:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rel const237] ; 545
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3031:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (545 - d()) 
	jno .jump3032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3032:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3033:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d()) 
	jno .jump3034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3034:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3035: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const449] ; 917
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3035 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3035 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3035 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3036
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3038:
	; Computing bound for 'e'
	mov rax, [rel const611] ; 574
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3039
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3039:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3040: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3040 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3040 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump3037
.jump3036:
	mov rax, [rel const612] ; 859
	push rax
.jump3037:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const280] ; 70
	push rax
	mov rax, [rel const613] ; 592
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3041:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3042
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3042:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3043: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3043 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3043 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3044
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3044:
	cmp rax, [rsp + 24]
	jl .jump3045
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3045:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3046
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3046:
	cmp rax, [rsp + 32]
	jl .jump3047
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3047:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3048
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3048:
	cmp rax, [rsp + 40]
	jl .jump3049
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3049:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3050
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3050:
	cqo
	idiv r10
	push rax
	jmp .jump3022
.jump3021:
	mov rax, [rel const45] ; 0
	push rax
	pop rax
	neg rax
	push rax
.jump3022:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3051:
	cmp rax, [rsp + 8]
	jl .jump3052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3052:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3053
	call _d
	push rax
	jmp .jump3054
.jump3053:
	mov rax, [rel const231] ; 63
	push rax
.jump3054:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3055:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3056
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const614] ; 558
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3058:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3059
	mov rax, [rel const615] ; 436
	push rax
	jmp .jump3060
.jump3059:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3060:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3061
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3061:
	; Computing bound for 'e'
	mov rax, [rel const616] ; 944
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3062:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3063: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const617] ; 517
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3063 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3063 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3063 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump3057
.jump3056:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3064
	mov rax, [rel const534] ; 863
	push rax
	jmp .jump3065
.jump3064:
	mov rax, [rel const387] ; 867
	push rax
.jump3065:
.jump3057:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3066
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3066:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if a then (sum[e : 944, f : (if a then 436 else d()), g : 558] (e * 517)) else (if a then 863 else 867)) 
	jno .jump3067
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3067:
	imul rdi, [rsp + 0 + 8] ; multiply by (if [a, c][d()] then d() else 63) 
	jno .jump3068
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3068:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3069: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const618] ; 203
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3070
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3070:
	cmp rax, [rsp + 8]
	jl .jump3071
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3071:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3072
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3072:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3073: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3073 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3069 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3069 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const619] ; 844
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3074:
	; Computing bound for 'e'
	mov rax, [rel const620] ; 22
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3075
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3075:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3076: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3076 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3076 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3077
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3077:
	cmp rax, [rsp + 16]
	jl .jump3078
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3078:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3079
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3079:
	cmp rax, [rsp + 24]
	jl .jump3080
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3080:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3081
	mov rax, [rel const621] ; 373
	push rax
	jmp .jump3082
.jump3081:
	mov rax, [rel const622] ; 71
	push rax
.jump3082:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const623] ; 811
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3083:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3084
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3084:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3085:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3086: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const298] ; 533
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3087
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3087:
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3088:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3089: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const624] ; 15.67
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3089 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3089 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3086 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3086 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3086 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const625] ; 84.47
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const626] ; 2.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const627] ; 60.64
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const628] ; 20.73
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3090
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3090:
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3091:
	; Computing bound for 'e'
	mov rax, [rel const69] ; 428
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3092
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3092:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 428 
	jno .jump3093
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3093:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3094
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3094:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump3095
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3095:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3096: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const629] ; 17.45
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3096 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3096 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3096 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3097
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3097:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3098
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3098:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3099: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3099 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3100:
	; Computing bound for 'f'
	mov rax, [rel const630] ; 442
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3101
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3101:
	; Computing bound for 'e'
	mov rax, [rel const177] ; 96
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3102:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3103: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const631] ; 50
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3103 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3103 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3103 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3103 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const632] ; 121
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const633] ; 275
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3104:
	cmp rax, [rsp + 24]
	jl .jump3105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3105:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3106:
	cmp rax, [rsp + 32]
	jl .jump3107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3107:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3108:
	cmp rax, [rsp + 40]
	jl .jump3109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3109:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const634] ; 96.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3110
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3112
	mov rax, [rel const613] ; 592
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3114:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3115
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3115:
	; Computing bound for 'f'
	mov rax, [rel const635] ; 30
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3116:
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3117
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3117:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3118
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3118:
	imul rdi, [rsp + 0 + 8] ; multiply by 30 
	jno .jump3119
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3119:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump3120
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3120:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump3121
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3121:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3122: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3122 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3122 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3122 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3122 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	mov rax, [rel const296] ; 268
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3123
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3123:
	cmp rax, [rsp + 32]
	jl .jump3124
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3124:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3125
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3125:
	cmp rax, [rsp + 40]
	jl .jump3126
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3126:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3127
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3127:
	cmp rax, [rsp + 48]
	jl .jump3128
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3128:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3129
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3129:
	cmp rax, [rsp + 56]
	jl .jump3130
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3130:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3131
	call _d
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3132
.jump3131:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3133
	call _d
	push rax
	jmp .jump3134
.jump3133:
	mov rax, [rel const636] ; 905
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3134:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3135
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3137:
	; Computing bound for 'e'
	mov rax, [rel const637] ; 823
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3138
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3138:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3139: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3139 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3139 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump3136
.jump3135:
	mov rax, [rel const638] ; 358
	push rax
.jump3136:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3140
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3140:
	cqo
	idiv r10
	push rax
.jump3132:
	jmp .jump3113
.jump3112:
	mov rax, [rel const43] ; 642
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
.jump3113:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3141:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3142: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3143:
	; Computing bound for 'g'
	mov rax, [rel const2] ; 614
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3144
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3144:
	; Computing bound for 'f'
	mov rax, [rel const253] ; 941
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3145
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3145:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3146:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3147: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3147 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3147 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3147 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3148:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3149
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3149:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3150
	mov rax, [rel const114] ; 862
	push rax
	jmp .jump3151
.jump3150:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3151:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3152
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3152:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3153:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3154
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3154:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3155
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3155:
	imul rdi, [rsp + 0 + 8] ; multiply by (- e) 
	jno .jump3156
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3156:
	imul rdi, [rsp + 0 + 16] ; multiply by (if a then 862 else d()) 
	jno .jump3157
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3157:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3158: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3159
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump3160
.jump3159:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump3160:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3158 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3158 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3158 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3161
	mov rax, [rel const639] ; 286
	push rax
	jmp .jump3162
.jump3161:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const640] ; 384
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3163
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3163:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3164:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3165
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3165:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3166: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3166 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3166 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3166 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3162:
	mov rax, [rel const619] ; 844
	push rax
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3167:
	cmp rax, [rsp + 24]
	jl .jump3168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3168:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3169:
	cmp rax, [rsp + 32]
	jl .jump3170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3170:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3171:
	cmp rax, [rsp + 40]
	jl .jump3172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3172:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3173:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3174: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3174 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3174 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3142 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump3111
.jump3110:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3175
	mov rax, [rel const221] ; 24
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3177:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump3176
.jump3175:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3178:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3179
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3179:
	; Computing bound for 'e'
	mov rax, [rel const75] ; 952
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3180:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3181: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3181 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3181 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3181 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3176:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3182
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3182:
	; Computing bound for 'e'
	mov rax, [rel const641] ; 824
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3183:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3184: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3184 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3184 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3185:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3186: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3187
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3187:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3188
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3188:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3189: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const642] ; 531
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3189 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3190:
	; Computing bound for 'f'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3191
	mov rax, [rel const643] ; 349
	push rax
	mov rax, [rel const644] ; 341
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump3192
.jump3191:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3193:
	; Computing bound for 'h'
	mov rax, [rel const645] ; 733
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3194
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3194:
	; Computing bound for 'g'
	mov rax, [rel const646] ; 747
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3195:
	; Computing bound for 'f'
	mov rax, [rel const441] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3196
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3196:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const647] ; 409
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3198
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3198:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3197 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3197 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3197 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3197 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump3192:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3199
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3199:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3200: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3201:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3202
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3202:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3203:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3204
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3204:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3205: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3206
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3206:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const443] ; 331
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3207:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3208
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3208:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3209:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump3210: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3211
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump3212
.jump3211:
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
.jump3212:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3210 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3210 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3210 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3210 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3205 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3205 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3205 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3205 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3200 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3200 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3200 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3213
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3213:
	push rax
	pop rax
	cmp rax, 0
	jne .jump3214
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3215
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3215:
	push rax
	pop rax
.jump3214:
	push rax
	pop rax
	cmp rax, 0
	je .jump3216
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3218:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3219:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3220: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3220 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3217
.jump3216:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3221:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3222:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3223: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const648] ; 599
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3223 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3217:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const649] ; 593
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3224:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const6] ; 150
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3225:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3226
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3226:
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3227:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3228: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3228 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3228 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3228 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3229
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3229:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3230: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const650] ; 421
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3231
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3231:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3232:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3233
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3233:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3234: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3234 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3234 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3234 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3230 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3230 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const255] ; 160
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3235:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3236
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3236:
	cmp rax, [rsp + 8]
	jl .jump3237
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3237:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3186 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3111:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3238
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3238:
	cmp rax, [rsp + 16]
	jl .jump3239
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3239:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3240
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3240:
	cmp rax, [rsp + 24]
	jl .jump3241
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3241:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const651] ; 'e.png'
	call _write_image
	add rsp, 24
	sub rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3242
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump3243
.jump3242:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump3243:
	pop rax
	cmp rax, 0
	je .jump3244
	mov rax, [rel const192] ; 671
	push rax
	call _d
	push rax
	mov rax, [rel const114] ; 862
	push rax
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump3245
.jump3244:
	mov rax, [rel const652] ; 129
	push rax
	call _d
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump3245:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const653] ; 59
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3246:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3247
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3247:
	cmp rax, [rsp + 8]
	jl .jump3248
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3248:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const593] ; 808
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3249
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3250
.jump3249:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3250:
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3251
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3251:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by ((d() * ((if false then d() else d()) - 808)) + (if (if a then c else c) then [862, d(), 671] else [d(), 129])[(59 / d())]) 
	jno .jump3252
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3252:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3253: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3253 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const654] ; 219
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3254:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3255
	mov rax, [rel const176] ; 556
	push rax
	jmp .jump3256
.jump3255:
	mov rax, [rel const196] ; 72
	push rax
	mov rax, [rel const655] ; 482
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3256:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3257:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3258: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3258 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3259
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3259:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3260: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const656] ; 48
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3260 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3260 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3261
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3261:
	; Computing bound for 'e'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3262:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3263: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3264:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3265
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3265:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3266: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const657] ; 785
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3266 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3266 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3263 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3263 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3267:
	cmp rax, [rsp + 8]
	jl .jump3268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3268:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3269
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3271:
	; Computing bound for 'f'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3272
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3273
.jump3272:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3273:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3274
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3274:
	; Computing bound for 'e'
	mov rax, [rel const285] ; 131
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3275:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3276: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3277
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump3278
.jump3277:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump3278:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3276 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3276 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3276 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3279
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3281
	call _d
	push rax
	jmp .jump3282
.jump3281:
	mov rax, [rel const543] ; 569
	push rax
	mov rax, [rel const534] ; 863
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump3282:
	jmp .jump3280
.jump3279:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3283
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3284
.jump3283:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump3284:
	pop rax
	cmp rax, 0
	je .jump3285
	call _d
	push rax
	jmp .jump3286
.jump3285:
	call _d
	push rax
	pop rax
	neg rax
	push rax
.jump3286:
.jump3280:
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3287
	call _d
	push rax
	mov rax, [rel const279] ; 711
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3289
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump3289:
	cqo
	idiv r10
	push rax
	jmp .jump3288
.jump3287:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3290
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3290:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3291: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3291 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3288:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3292:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3293
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3293:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by ((- (if a then (711 / d()) else (sum[e : d()] d()))) / ((if a then (if c then d() else (863 + 569)) else (if (if c then a else a) then d() else (- d()))) - (- (sum[e : 131, f : (if false then d() else d()), g : d()] (if false then f else g))))) 
	jno .jump3294
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3294:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3295: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3296:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3297
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3297:
	; Computing bound for 'g'
	mov rax, [rel const658] ; 76.93
	push rax
	mov rax, [rel const659] ; 2.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3298
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3299
.jump3298:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump3299:
	pop rax
	cmp rax, 0
	je .jump3300
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3302
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3302:
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3303:
	; Computing bound for 'f'
	mov rax, [rel const230] ; 178
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3304
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3304:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 178 
	jno .jump3305
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3305:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3306
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3306:
	imul rdi, [rsp + 0 + 16] ; multiply by (- e) 
	jno .jump3307
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3307:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3308 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3308 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3308 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3301
.jump3300:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3309:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3310
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3310:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3311:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3312
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump3313
.jump3312:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump3313:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3314
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3314:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then e else e) 
	jno .jump3315
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3315:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3316
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3316:
	imul rdi, [rsp + 0 + 16] ; multiply by (e / e) 
	jno .jump3317
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3317:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3318: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const660] ; 893
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3319:
	; Computing bound for 'i'
	mov rax, [rel const559] ; 113
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3320
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3320:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3321: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3321 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3321 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3318 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3318 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3318 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3301:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3322
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3324
	mov rax, [rel const661] ; 760
	push rax
	jmp .jump3325
.jump3324:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump3325:
	jmp .jump3323
.jump3322:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3326
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump3327
.jump3326:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump3327:
.jump3323:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3328
	mov rax, [rel const595] ; 17
	push rax
	jmp .jump3329
.jump3328:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3330:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump3329:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3331
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const662] ; 858
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3333
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3333:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3334:
	; Computing bound for 'f'
	mov rax, [rel const663] ; 640
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3335
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3336 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3336 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3336 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump3332
.jump3331:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump3332:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3337:
	cmp rax, [rsp + 24]
	jl .jump3338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3338:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3339:
	cmp rax, [rsp + 32]
	jl .jump3340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3340:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3341:
	cmp rax, [rsp + 40]
	jl .jump3342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3342:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3343:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3344
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3345
.jump3344:
	mov rax, [rel const664] ; 39.16
	push rax
	mov rax, [rel const665] ; 31.77
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump3345:
	pop rax
	cmp rax, 0
	je .jump3346
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const666] ; 233
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3348
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3348:
	; Computing bound for 'g'
	mov rax, [rel const621] ; 373
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3349:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3350
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3350:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3351
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3351:
	imul rdi, [rsp + 0 + 8] ; multiply by 373 
	jno .jump3352
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3352:
	imul rdi, [rsp + 0 + 16] ; multiply by 233 
	jno .jump3353
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3353:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3354: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3354 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3354 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3354 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3355
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump3356
.jump3355:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump3356:
	mov rax, [rel const667] ; 521
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3357:
	cmp rax, [rsp + 24]
	jl .jump3358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3358:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3359:
	cmp rax, [rsp + 32]
	jl .jump3360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3360:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3361:
	cmp rax, [rsp + 40]
	jl .jump3362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3362:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3347
.jump3346:
	mov rax, [rel const186] ; 503
	push rax
.jump3347:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3363:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3364:
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3365
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3365:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3366:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3367:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3368:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump3369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3369:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3370: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3370 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3370 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3370 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rel const229] ; 772
	push rax
	mov rax, [rel const668] ; 200
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3371:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3372
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3372:
	cmp rax, [rsp + 24]
	jl .jump3373
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3373:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3374
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3374:
	cmp rax, [rsp + 32]
	jl .jump3375
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3375:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3376
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3376:
	cmp rax, [rsp + 40]
	jl .jump3377
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3377:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3378
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3380:
	; Computing bound for 'f'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3381
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3381:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3382: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3382 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3382 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const420] ; 152
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3383:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump3379
.jump3378:
	mov rax, [rel const669] ; 140
	push rax
.jump3379:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3384
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3384:
	; Computing bound for 'g'
	mov rax, [rel const670] ; 31
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3385:
	; Computing bound for 'f'
	mov rax, [rel const228] ; 159
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3386
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3386:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3387: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const587] ; 662
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3387 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3387 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3387 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3387 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3388
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3388:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : (- 159), g : 31, h : (if (array[f : e, g : d(), h : e] c)[(200 / 772), d(), e] then ((- 152) % (sum[f : d(), g : e] g)) else 140), i : (if (if c then a else (31.77 <= 39.16)) then (array[f : e, g : 373, h : 233] h)[521, (if c then e else d()), (- d())] else 503)] 662) 
	jno .jump3389
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3389:
imul rdi, [rsp + 0 + 8] ; multiply by (if (if (2.64 <= 76.93) then a else c) then (array[f : 178, g : d(), h : (- e)] d()) else (array[f : (if a then e else e), g : e, h : (e / e)] (sum[i : 113, j : 893] j)))[(- (if a then (sum[f : 640, g : e, h : 858] d()) else e)), (if c then 17 else ((- d()) % d())), (if true then (if (! a) then 760 else e) else (if c then e else (- e)))] 
	jno .jump3390
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3390:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump3391
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3391:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump3392
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3392:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3393: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const671] ; 62.04
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3394
	mov rax, [rel const672] ; 80.81
	push rax
	jmp .jump3395
.jump3394:
	mov rax, [rel const673] ; 94.27
	push rax
.jump3395:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3396
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3396:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3397
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3397:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3398: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const674] ; 23.4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3398 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const675] ; 889
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3399:
	cmp rax, [rsp + 8]
	jl .jump3400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3400:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	mov rax, [rel const676] ; 39.72
	push rax
	mov rax, [rel const677] ; 50.09
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3401
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3403
	mov rax, [rel const678] ; 81.19
	push rax
	jmp .jump3404
.jump3403:
	mov rax, [rel const679] ; 87.85
	push rax
.jump3404:
	jmp .jump3402
.jump3401:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const126] ; 16
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3405:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3406
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3406:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3407:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3408: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const680] ; 85.49
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3408 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3408 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3408 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3402:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3393 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3393 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3393 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3393 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3295 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3270
.jump3269:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3409
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3409:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump3410
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3410:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump3411: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3412:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const681] ; 682
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3413:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3414:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3415: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3415 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3416
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3416:
	; Computing bound for 'f'
	mov rax, [rel const682] ; 524
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3417:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3418: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3418 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3418 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3418 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3419
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3419:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : (- 524), g : (sum[f : d()] d()), h : (- 682)] g) 
	jno .jump3420
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3420:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump3421
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump3421:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3422: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3423
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3423:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3424:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3425
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3425:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3426:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (f + (- g)) 
	jno .jump3427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3427:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3428:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump3429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3429:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump3430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3430:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3431: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const683] ; 1.83
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3432
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3432:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3433:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3434: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const684] ; 11.85
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3434 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3434 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3435:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3436
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3436:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3437: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const685] ; 36.48
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3437 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3437 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const686] ; 9.01
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3431 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3431 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3431 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3431 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3422 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3422 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	push rax
	mov rax, [rel const687] ; 527
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3438
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3438:
	cmp rax, [rsp + 16]
	jl .jump3439
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3439:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3440
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump3440:
	cmp rax, [rsp + 24]
	jl .jump3441
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump3441:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3411 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3270:
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; True
	push rax
	lea rdi, [rel const864] ; '(BoolType)'
	lea rsi, [rsp]
	call _show
	add rsp, 8
	add rsp, 8 ; Remove alignment
	mov rax, [rel const970] ; 164
	push rax
	mov rax, [rel const72] ; 3
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump6462
	lea rdi, [rel const971] ; 'h'
	call _fail_assertion
.jump6462:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7736
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7736:
	; Computing bound for 'j'
	mov rax, [rel const661] ; 760
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7737:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7738
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7738:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f()) 
	jno .jump7739
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7739:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 760) 
	jno .jump7740
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7740:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump7741
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7741:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7742: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1050] ; 55.17
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7742 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7742 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7742 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const109] ; 212
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7743
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump7744
.jump7743:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump7744:
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7745:
	cmp rax, [rsp + 24]
	jl .jump7746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7746:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7747:
	cmp rax, [rsp + 32]
	jl .jump7748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7748:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7749:
	cmp rax, [rsp + 40]
	jl .jump7750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7750:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1051] ; 0.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7751
	call _f
	push rax
	jmp .jump7752
.jump7751:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7753:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump7754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7754:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7755: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const710] ; 981
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7755 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const1052] ; 819
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7756
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7756:
	cmp rax, [rsp + 8]
	jl .jump7757
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7757:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7758
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7758:
	; Computing bound for 'i'
	mov rax, [rel const258] ; 317
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7759:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 317) 
	jno .jump7760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7760:
imul rdi, [rsp + 0 + 8] ; multiply by (array[i : f()] 981)[819] 
	jno .jump7761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7761:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7762: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1053] ; 658
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7762 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7762 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7763
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7765
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const1054] ; 988
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7767
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7767:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 988 
	jno .jump7768
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7768:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7769: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7769 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump7766
.jump7765:
	call _d
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump7766:
	jmp .jump7764
.jump7763:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7770
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	mov rax, [rel const167] ; 646
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump7771
.jump7770:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const530] ; 289
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7772
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7772:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 289 
	jno .jump7773
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7773:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7774: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const522] ; 177
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7774 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump7771:
.jump7764:
	mov rax, [rel const288] ; 134
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7775:
	cmp rax, [rsp + 8]
	jl .jump7776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7776:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7777:
	cmp rax, [rsp + 16]
	jl .jump7778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7778:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7779:
	cmp rax, [rsp + 24]
	jl .jump7780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7780:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7752:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7781:
	; Computing bound for 'j'
	mov rax, [rel const1055] ; 143
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7782
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7782:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7783:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7784:
	imul rdi, [rsp + 0 + 8] ; multiply by 143 
	jno .jump7785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7785:
imul rdi, [rsp + 0 + 16] ; multiply by (if (! (0.14 == (array[i : (- f()), j : (- 760), k : d()] 55.17)[(- f()), (if c then d() else f()), 212])) then f() else (array[i : (- 317), j : (array[i : f()] 981)[819]] 658)[(if (f() != d()) then (if (a == c) then (array[i : 988] d()) else [d()]) else (if c then [646, f(), f(), d()] else (array[i : 289] 177)))[134], d()]) 
	jno .jump7786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7786:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7787: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7787 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7787 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7787 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7788
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7790
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump7792
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump7792:
	push rax
	pop rax
	cmp rax, 0
	je .jump7793
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7795:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump7796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7796:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7797: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7797 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump7794
.jump7793:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7798:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7799:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7800: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7800 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump7794:
	jmp .jump7791
.jump7790:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump7791:
	jmp .jump7789
.jump7788:
	mov rax, [rel const1056] ; 39
	push rax
	mov rax, [rel const1057] ; 951
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7801:
	cqo
	idiv r10
	push rax
	mov rax, [rel const155] ; 754
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7802
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump7803
.jump7802:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const1] ; True
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump7803:
.jump7789:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7804:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7805
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7805:
	; Computing bound for 'j'
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7806
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump7806:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7807:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7808
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7808:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- f()) * f()) 
	jno .jump7809
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7809:
	imul rdi, [rsp + 0 + 8] ; multiply by (f() % d()) 
	jno .jump7810
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7810:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump7811
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7811:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump7812
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7812:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7813: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7814
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7814:
	; Computing bound for 'n'
	mov rax, [rel const748] ; 391
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7815:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7816
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7816:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump7817
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7817:
	imul rdi, [rsp + 0 + 8] ; multiply by 391 
	jno .jump7818
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7818:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump7819
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7819:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7820: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7820 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7820 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7820 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7813 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7813 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7813 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7813 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const858] ; 635
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7821
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7823:
	; Computing bound for 'k'
	mov rax, [rel const218] ; 718
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7824
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7824:
	; Computing bound for 'j'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7825:
	; Computing bound for 'i'
	mov rax, [rel const1058] ; 180
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7826
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7826:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7827: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7827 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7827 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7827 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7827 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump7822
.jump7821:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump7822:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7828:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7829
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7829:
	cmp rax, [rsp + 32]
	jl .jump7830
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7830:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7831
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7831:
	cmp rax, [rsp + 40]
	jl .jump7832
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7832:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7833
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7833:
	cmp rax, [rsp + 48]
	jl .jump7834
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7834:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7835
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7835:
	cmp rax, [rsp + 56]
	jl .jump7836
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7836:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const397] ; 937
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7837:
	; Computing bound for 'j'
	mov rax, [rel const1059] ; 667
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7838
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7838:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7839:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7840:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 667) 
	jno .jump7841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7841:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d()) 
	jno .jump7842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7842:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7843: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7843 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7843 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7843 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const188] ; 813
	push rax
	mov rax, [rel const710] ; 981
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7844:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const160] ; 895
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7845
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7845:
	cmp rax, [rsp + 24]
	jl .jump7846
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7846:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7847
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7847:
	cmp rax, [rsp + 32]
	jl .jump7848
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7848:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7849
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7849:
	cmp rax, [rsp + 40]
	jl .jump7850
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7850:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7851
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump7851:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7852:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7853
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7853:
	cmp rax, [rsp + 24]
	jl .jump7854
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7854:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7855
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7855:
	cmp rax, [rsp + 32]
	jl .jump7856
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7856:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7857
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7857:
	cmp rax, [rsp + 40]
	jl .jump7858
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7858:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7859
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7859:
	cmp rax, [rsp + 8]
	jl .jump7860
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7860:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump7861
	mov rax, [rel const45] ; False
	push rax
	jmp .jump7862
.jump7861:
	mov rax, [rel const45] ; False
	push rax
.jump7862:
	pop rax
	cmp rax, 0
	je .jump7863
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const346] ; 604
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7865:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 604 
	jno .jump7866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7866:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7867: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7867 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump7864
.jump7863:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const1060] ; 56
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7868:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 56 
	jno .jump7869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7869:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7870: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7870 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump7864:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const378] ; 885
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7871:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7872
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7872:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7873: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7873 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7873 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7874
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7874:
	cmp rax, [rsp + 8]
	jl .jump7875
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7875:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7876
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump7876:
	push rax
	pop rax
	cmp rax, 0
	je .jump7877
	mov rax, [rel const45] ; False
	push rax
	jmp .jump7878
.jump7877:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump7878:
	pop rax
	cmp rax, 0
	je .jump7879
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7881
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump7881:
	push rax
	mov rax, [rel const1061] ; 8.83
	push rax
	mov rax, [rel const1062] ; 4.86
	push rax
	mov rax, [rel const1063] ; 2.46
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7882
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7884
	mov rax, [rel const868] ; 407
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump7884:
	push rax
	pop rax
	cmp rax, 0
	je .jump7885
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7887
	call _f
	push rax
	jmp .jump7888
.jump7887:
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump7888:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7889:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7890
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7890:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7891
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7891:
	; Computing bound for 'j'
	mov rax, [rel const1064] ; 149
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7892:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7893
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7893:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7894
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7894:
	imul rdi, [rsp + 0 + 8] ; multiply by 149 
	jno .jump7895
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7895:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump7896
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7896:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7897: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7897 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7897 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7897 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7898
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7898:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7899:
	; Computing bound for 'j'
	mov rax, [rel const1065] ; 656
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7900
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7900:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7901:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7902: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7902 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7902 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7902 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7902 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const943] ; 430
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7903:
	cmp rax, [rsp + 24]
	jl .jump7904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7904:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7905:
	cmp rax, [rsp + 32]
	jl .jump7906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7906:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7907:
	cmp rax, [rsp + 40]
	jl .jump7908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7908:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7909:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const537] ; 753
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7910:
	; Computing bound for 'i'
	mov rax, [rel const1066] ; 388
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7911
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7911:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7912: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7912 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7912 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7913
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7913:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[i : 388, j : 753] f()) 
	jno .jump7914
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7914:
imul rdi, [rsp + 0 + 8] ; multiply by (array[i : d(), j : 149, k : f()] f())[430, d(), (sum[i : d(), j : 656, k : d(), l : f()] f())] 
	jno .jump7915
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7915:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump7916
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7916:
	imul rdi, [rsp + 0 + 24] ; multiply by (if a then f() else (d() + f())) 
	jno .jump7917
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7917:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7918: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7919
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	jmp .jump7920
.jump7919:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
.jump7920:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7918 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7918 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7918 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7918 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7886
.jump7885:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const121] ; 871
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7921:
	; Computing bound for 'k'
	mov rax, [rel const1067] ; 673
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7922
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7922:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7923:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const192] ; 671
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7924:
	cqo
	idiv r10
	push rax
	mov rax, [rel const569] ; 636
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7925:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7926
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7926:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- 636) / (671 / f())) 
	jno .jump7927
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7927:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump7928
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7928:
	imul rdi, [rsp + 0 + 16] ; multiply by 673 
	jno .jump7929
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7929:
	imul rdi, [rsp + 0 + 24] ; multiply by 871 
	jno .jump7930
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7930:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7931: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7931 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7931 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7931 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7931 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump7886:
	jmp .jump7883
.jump7882:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7932:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const667] ; 521
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7933:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7934
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7934:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7935:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7936
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7936:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7937: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const566] ; 926
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7937 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7937 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7937 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7937 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7938
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7938:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rel const597] ; 840
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7939:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7940
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7940:
	; Computing bound for 'i'
	mov rax, [rel const13] ; 471
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7941:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7942: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7942 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7942 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7943
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7943:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof void[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by ((sum[i : 471, j : f()] j) + d()) 
	jno .jump7944
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7944:
	imul rdi, [rsp + 0 + 8] ; multiply by (840 + d()) 
	jno .jump7945
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7945:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[i : d(), j : d(), k : (d() + f()), l : (- 521)] (- 926)) 
	jno .jump7946
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7946:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump7947
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7947:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7948: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7949
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7949:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1068] ; 118
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7950
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump7950:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7951:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7952
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7952:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7953:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump7954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7954:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump7955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7955:
	imul rdi, [rsp + 0 + 16] ; multiply by (118 % k) 
	jno .jump7956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7956:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump7957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7957:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump7958: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7958 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7958 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7958 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7958 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7948 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7948 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7948 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7948 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7959
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const382] ; 360
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7961
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7961:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7962: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7962 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump7960
.jump7959:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7963
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7963:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7964:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7965
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7965:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7966:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7967: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7967 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7967 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7967 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7967 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
.jump7960:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump7968
	call _d
	push rax
	jmp .jump7969
.jump7968:
	mov rax, [rel const282] ; 335
	push rax
.jump7969:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7970:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	call _d
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7971:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7972
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7972:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7973:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7974: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const326] ; 511
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7974 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7974 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7974 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7975
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7975:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7976: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7976 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump7977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7977:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7978
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7978:
	cmp rax, [rsp + 32]
	jl .jump7979
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7979:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7980
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7980:
	cmp rax, [rsp + 40]
	jl .jump7981
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7981:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7982
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7982:
	cmp rax, [rsp + 48]
	jl .jump7983
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7983:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7984
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump7984:
	cmp rax, [rsp + 56]
	jl .jump7985
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump7985:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump7883:
	jmp .jump7880
.jump7879:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump7986
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump7986:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7987
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7989:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7990
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7990:
	; Computing bound for 'j'
	mov rax, [rel const1069] ; 587
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7991:
	; Computing bound for 'i'
	mov rax, [rel const1070] ; 921
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7992
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7992:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by 921 
	jno .jump7993
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7993:
	imul rdi, [rsp + 0 + 8] ; multiply by 587 
	jno .jump7994
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7994:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump7995
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7995:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump7996
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump7996:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7997: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7997 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7997 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7997 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7997 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7988
.jump7987:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const669] ; 140
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7998
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump7998:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump7999: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7999 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8000:
	; Computing bound for 'k'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8001
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8002
.jump8001:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8003:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8004
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8004:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rel const533] ; 293
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8005:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8006
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8006:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8007: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8007 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8007 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8007 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8007 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump8002:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8008
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8008:
	; Computing bound for 'j'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const1071] ; 141
	push rax
	mov rax, [rel const689] ; 663
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8009:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8010
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8011
.jump8010:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const1072] ; 493
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8012
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8012:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8013: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const179] ; 969
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8013 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8014:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump8011:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8015
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8015:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
imul rdi, [rsp + 0 + 0] ; multiply by (if a then f() else ((sum[i : 493] 969) % (- f()))) 
	jno .jump8016
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8016:
	imul rdi, [rsp + 0 + 8] ; multiply by (- ((663 + 141) + (- d()))) 
	jno .jump8017
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8017:
imul rdi, [rsp + 0 + 16] ; multiply by (if (! (! false)) then f() else (sum[i : d(), j : (293 - f()), k : f(), l : f()] k)) 
	jno .jump8018
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8018:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[i : 140] d()) 
	jno .jump8019
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8019:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8020: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8021
	mov rax, [rel const45] ; False
	push rax
	jmp .jump8022
.jump8021:
	mov rax, [rel const1] ; True
	push rax
.jump8022:
	pop rax
	cmp rax, 0
	je .jump8023
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	push rax
	jmp .jump8024
.jump8023:
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rdi
	call _h
	push rax
.jump8024:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8020 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8020 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8020 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8020 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump7988:
.jump7880:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8025
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8025:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8026:
	; Computing bound for 'j'
	mov rax, [rel const1073] ; 144
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8027
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8027:
	; Computing bound for 'i'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump8028
	call _d
	push rax
	jmp .jump8029
.jump8028:
	mov rax, [rel const66] ; 853
	push rax
.jump8029:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8030:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then d() else 853) 
	jno .jump8031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8031:
	imul rdi, [rsp + 0 + 8] ; multiply by 144 
	jno .jump8032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8032:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump8033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8033:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump8034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8034:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8035: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8035 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8035 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8035 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8035 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const1074] ; 516
	push rax
	mov rax, [rel const895] ; 939
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8036:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const311] ; 281
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8037
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8037:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8038
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8038:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8039:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8040: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8040 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8040 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8041:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8042
	mov rax, [rel const227] ; 309
	push rax
	jmp .jump8043
.jump8042:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump8043:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8044
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8044:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8045: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1075] ; 369
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8045 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8045 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8045 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8046:
	cmp rax, [rsp + 32]
	jl .jump8047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8047:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8048:
	cmp rax, [rsp + 40]
	jl .jump8049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8049:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8050:
	cmp rax, [rsp + 48]
	jl .jump8051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8051:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8052:
	cmp rax, [rsp + 56]
	jl .jump8053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8053:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8054
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const1076] ; 911
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8056
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8056:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 911 
	jno .jump8057
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8057:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8058: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8059
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8061:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8062
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8062:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8063
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8063:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump8064
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8064:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8065: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8065 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8065 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump8060
.jump8059:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8066:
	; Computing bound for 'j'
	mov rax, [rel const705] ; 104
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8067
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8067:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 104 
	jno .jump8068
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8068:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8069
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8069:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8070: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8070 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8070 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump8060:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8058 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8055
.jump8054:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8071
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8071:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() * f()) 
	jno .jump8072
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8072:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8073: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8074:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8075
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8075:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8076
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8076:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8077
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8077:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8078: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const636] ; 905
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8078 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8078 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8073 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump8055:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const571] ; 705
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8079
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8079:
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const1075] ; 369
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8080
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8080:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 369 
	jno .jump8081
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8081:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8082: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1077] ; 723
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8082 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8083
	call _d
	push rax
	jmp .jump8084
.jump8083:
	call _f
	push rax
.jump8084:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8085:
	cmp rax, [rsp + 8]
	jl .jump8086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8086:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8087:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8088: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8089:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8088 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8088 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8090:
	cmp rax, [rsp + 8]
	jl .jump8091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8091:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1078] ; 554
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8092
	mov rax, [rel const1079] ; 626
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump8093
.jump8092:
	mov rax, [rel const1080] ; 490
	push rax
	mov rax, [rel const28] ; 51
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8094:
	cqo
	idiv r10
	push rax
.jump8093:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8095
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8095:
	; Computing bound for 'i'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8096:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8097:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (if (554 == f()) then (- 626) else (51 / 490))) 
	jno .jump8098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8098:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8099: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8099 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8099 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const255] ; 160
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8100
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8100:
	; Computing bound for 'k'
	mov rax, [rel const1081] ; 645
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8101:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8102
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8102:
	; Computing bound for 'i'
	mov rax, [rel const296] ; 268
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8103:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8104: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8104 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8104 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8104 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8104 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8105:
	; Computing bound for 'k'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8106
	mov rax, [rel const871] ; 912
	push rax
	jmp .jump8107
.jump8106:
	mov rax, [rel const1082] ; 847
	push rax
	pop rax
	neg rax
	push rax
.jump8107:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8108
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8108:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8109:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const724] ; 64
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8110:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8111: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8111 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8112
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8112:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8113: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8113 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8113 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8113 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8113 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8114:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8115:
	cmp rax, [rsp + 16]
	jl .jump8116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8116:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8117:
	cmp rax, [rsp + 24]
	jl .jump8118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8118:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8119:
	cmp rax, [rsp + 16]
	jl .jump8120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8120:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8121:
	cmp rax, [rsp + 24]
	jl .jump8122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8122:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8123
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8123:
	; Computing bound for 'i'
	mov rax, [rel const1083] ; 92
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8124:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8125: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8126
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8126:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8127: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8127 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8128:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const662] ; 858
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8129:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 858 
	jno .jump8130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8130:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8131: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8131 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8132
	mov rax, [rel const253] ; 941
	push rax
	jmp .jump8133
.jump8132:
	mov rax, [rel const294] ; 948
	push rax
.jump8133:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8134
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8134:
	cmp rax, [rsp + 8]
	jl .jump8135
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8135:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8136
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8136:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8137: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8137 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8137 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8125 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8125 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8138:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8139:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8140: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8140 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const1084] ; 744
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8141
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8141:
	cmp rax, [rsp + 32]
	jl .jump8142
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8142:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8143
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8143:
	cmp rax, [rsp + 40]
	jl .jump8144
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8144:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8145
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8145:
	cmp rax, [rsp + 48]
	jl .jump8146
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8146:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8147
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8147:
	cmp rax, [rsp + 56]
	jl .jump8148
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8148:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8149
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8149:
	; Computing bound for 'i'
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8150:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (f() * f()) 
	jno .jump8151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8151:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8152:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8153: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8154
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump8155
.jump8154:
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump8155:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8153 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8153 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8156:
	; Computing bound for 'i'
	mov rax, [rel const1085] ; 94
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8157
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8157:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- 94)) 
	jno .jump8158
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8158:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f()) 
	jno .jump8159
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8159:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8160: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8160 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8160 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8161:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8162: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8162 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8163
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8163:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8164:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8165:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[i : (- f())] (- i)) 
	jno .jump8166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8166:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8167: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8167 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8167 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 72
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 72 bytes from rsp to rax 
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72
	push rax
	mov rax, 3
	push rax
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8168:
	cmp rax, [rsp + 8]
	jl .jump8169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8169:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8170:
	cmp rax, [rsp + 16]
	jl .jump8171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8171:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8172:
	cmp rax, [rsp + 24]
	jl .jump8173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8173:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8174
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8176:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8177:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8178
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8178:
	; Computing bound for 'j'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8179:
	; Computing bound for 'i'
	mov rax, [rel const44] ; 266
	push rax
	mov rax, [rel const1086] ; 877
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8180:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8181: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8181 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8181 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8181 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8181 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8182
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8182:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8183
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8183:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8184:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8185:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8186:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8187: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8188:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8189: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8189 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8187 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8187 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8190
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8190:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const926] ; 274
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8191
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8191:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8192:
	; Computing bound for 'i'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8193
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8193:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8194: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const299] ; 462
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8194 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8194 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8194 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8195:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8196: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8196 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8196 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8197:
	cmp rax, [rsp + 16]
	jl .jump8198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8198:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8199:
	cmp rax, [rsp + 24]
	jl .jump8200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8200:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8201:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8202
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8203
.jump8202:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8203:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8204
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8204:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8205: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8205 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8205 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8205 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	jmp .jump8175
.jump8174:
	mov rax, [rel const1087] ; 741
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8206
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8208:
	; Computing bound for 'j'
	mov rax, [rel const952] ; 327
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8209
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8209:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8210
	call _f
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8212:
	cmp rax, [rsp + 8]
	jl .jump8213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8213:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump8211
.jump8210:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8214:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8215
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8215:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8216:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8217
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8218
.jump8217:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump8218:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8219
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8219:
	; Computing bound for 'i'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8220:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8221: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8221 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8221 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8221 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8221 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump8211:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8222:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump8223: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1088] ; 443
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8223 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8223 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8223 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump8207
.jump8206:
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8224
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump8225
.jump8224:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump8225:
	pop rax
	cmp rax, 0
	je .jump8226
	mov rax, [rel const314] ; 189
	push rax
	jmp .jump8227
.jump8226:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8228
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8229
.jump8228:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump8229:
.jump8227:
	pop rax
	neg rax
	push rax
.jump8207:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump8175:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	sub rsp, 8 ; Add alignment
	mov rax, [rel const748] ; 391
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8230
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const813] ; 392
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8232
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8232:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8233:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8234
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8234:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8235:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8236: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8236 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8236 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8236 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8236 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const807] ; 248
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8237
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump8237:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8238:
	; Computing bound for 'k'
	mov rax, [rel const1089] ; 945
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8239
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8239:
	; Computing bound for 'j'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8240
	mov rax, [rel const107] ; 595
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump8241
.jump8240:
	mov rax, [rel const534] ; 863
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump8241:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8242:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then (- 595) else (d() * 863)) 
	jno .jump8243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8243:
	imul rdi, [rsp + 0 + 8] ; multiply by 945 
	jno .jump8244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8244:
imul rdi, [rsp + 0 + 16] ; multiply by (248 / (sum[j : f(), k : d(), l : d(), m : 392] d())) 
	jno .jump8245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8245:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8246: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8246 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8246 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8246 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump8231
.jump8230:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8247
	mov rax, [rel const31] ; 419
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump8248
.jump8247:
	mov rax, [rel const1080] ; 490
	push rax
.jump8248:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8249:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8250:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8251:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8252:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8253:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (! c) then (- 419) else 490) 
	jno .jump8254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8254:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8255: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1090] ; 71.48
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8255 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8255 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8255 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump8231:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8256:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8257:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8258: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8258 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8259:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8260:
	; Computing bound for 'j'
	mov rax, [rel const554] ; 107
	push rax
	mov rax, [rel const905] ; 801
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8261
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8261:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8262: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8262 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8262 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8263
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8263:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[j : (801 + 107), k : f()] j) 
	jno .jump8264
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8264:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8265
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8265:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8266: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8266 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8266 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const804] ; 959
	push rax
	mov rax, [rel const215] ; 84
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8267
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8267:
	cmp rax, [rsp + 16]
	jl .jump8268
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8268:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8269
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8269:
	cmp rax, [rsp + 24]
	jl .jump8270
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8270:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1091] ; 27.33
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8271
	call _f
	push rax
	mov rax, [rel const28] ; 51
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const268] ; 623
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	call _f
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const1092] ; 415
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8273:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 415 
	jno .jump8274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8274:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8275: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8275 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const104] ; 171
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8276
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8276:
	cmp rax, [rsp + 8]
	jl .jump8277
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8277:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump8272
.jump8271:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8278
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8280
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8280:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8281:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8282: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const248] ; 607
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8282 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8282 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump8279
.jump8278:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump8279:
.jump8272:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const1093] ; 58
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8283:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 58 
	jno .jump8284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8284:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8285: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const547] ; 254
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8286
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8286:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8287:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8288
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8288:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8289
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8289:
	imul rdi, [rsp + 0 + 8] ; multiply by (j * j) 
	jno .jump8290
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8290:
	imul rdi, [rsp + 0 + 16] ; multiply by 254 
	jno .jump8291
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8291:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8292: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8292 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8292 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8292 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8285 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8293:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8294
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8294:
	; Computing bound for 'j'
	mov rax, [rel const1094] ; 420
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8295:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8296: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8296 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8296 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8296 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8297
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8297:
	cmp rax, [rsp + 8]
	jl .jump8298
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8298:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8299
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8299:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8300:
	; Computing bound for 'j'
	mov rax, [rel const552] ; 224
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8301:
	cqo
	idiv r10
	push rax
	call _f
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8302
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8302:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8303: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8303 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8303 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8303 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8304:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[j : (f() - (f() / 224)), k : f(), l : f()] l) 
	jno .jump8305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8305:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8306: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1095] ; 3.25
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const520] ; 94.42
	push rax
	mov rax, [rel const1096] ; 83.18
	push rax
	mov rax, [rel const1097] ; 21.11
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8306 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8307:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8308
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8308:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8309
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8309:
	; Computing bound for 'k'
	mov rax, [rel const455] ; 334
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8310:
	; Computing bound for 'j'
	mov rax, [rel const976] ; 13
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8311
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8311:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8312: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8312 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8312 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8312 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8313:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8314
	mov rax, [rel const156] ; 979
	push rax
	jmp .jump8315
.jump8314:
	call _d
	push rax
.jump8315:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8316
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8316:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if a then 979 else d()) + (- f())) 
	jno .jump8317
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8317:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[j : 13, k : 334, l : f()] j) 
	jno .jump8318
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8318:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump8319
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8319:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump8320
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8320:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8321: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rdi
	call _h
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8321 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8321 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8321 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8321 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const285] ; 131
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const61] ; 633
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8322
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump8322:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8323
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8323:
	cmp rax, [rsp + 32]
	jl .jump8324
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8324:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8325
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8325:
	cmp rax, [rsp + 40]
	jl .jump8326
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8326:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8327
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8327:
	cmp rax, [rsp + 48]
	jl .jump8328
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8328:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8329
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8329:
	cmp rax, [rsp + 56]
	jl .jump8330
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8330:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8331
	mov rax, [rel const318] ; 782
	push rax
	pop rax
	neg rax
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	jmp .jump8332
.jump8331:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8333
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8335
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8336
.jump8335:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump8336:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8337
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8337:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if c then f() else f()) 
	jno .jump8338
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8338:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8339: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8339 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8334
.jump8333:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8340
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8341
.jump8340:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8341:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8342
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8342:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then f() else d()) 
	jno .jump8343
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8343:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8344: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8344 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump8334:
.jump8332:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8345
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8345:
	push rax
	pop rax
	cmp rax, 0
	jne .jump8346
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8346:
	push rax
	pop rax
	cmp rax, 0
	je .jump8347
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump8348
.jump8347:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump8349
	mov rax, [rel const45] ; False
	push rax
	jmp .jump8350
.jump8349:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump8350:
.jump8348:
	pop rax
	cmp rax, 0
	je .jump8351
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump8352
.jump8351:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8353:
	; Computing bound for 'k'
	mov rax, [rel const252] ; 856
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8354
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8354:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8355:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8356:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 856) 
	jno .jump8357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8357:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump8358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8358:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8359: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8360
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8360:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8359 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8359 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8359 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; True
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8361
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8361:
	push rax
	pop rax
	cmp rax, 0
	je .jump8362
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8364
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8364:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8365
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8365:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8366: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const888] ; 90
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8366 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8363
.jump8362:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8367
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8367:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8368
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8368:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8369: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1098] ; 398
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8369 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump8363:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
.jump8352:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const940] ; 505
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8370:
	; Computing bound for 'l'
	mov rax, [rel const31] ; 419
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8371
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8371:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8372
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8374
	call _d
	push rax
	jmp .jump8375
.jump8374:
	mov rax, [rel const1099] ; 974
	push rax
.jump8375:
	jmp .jump8373
.jump8372:
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump8373:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8376:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8377
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8377:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8378: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8378 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8378 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8378 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8378 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8379
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8379:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8380:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8381: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8381 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8381 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump8382
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump8382:
	push rax
	mov rax, [rel const1100] ; 27.88
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8383:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8384: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8384 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8385
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump8385:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8386
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump8387
.jump8386:
	mov rax, [rel const45] ; False
	push rax
.jump8387:
	pop rax
	cmp rax, 0
	je .jump8388
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump8389
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8389:
	push rax
	pop rax
.jump8388:
	push rax
	pop rax
	cmp rax, 0
	je .jump8390
	mov rax, [rel const75] ; 952
	push rax
	call _f
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8392
	mov rax, [rel const201] ; 477
	push rax
	jmp .jump8393
.jump8392:
	call _f
	push rax
.jump8393:
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump8391
.jump8390:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8394
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8394:
	push rax
	pop rax
	cmp rax, 0
	je .jump8395
	mov rax, [rel const612] ; 859
	push rax
	jmp .jump8396
.jump8395:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8396:
.jump8391:
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8397
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8399:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1101] ; 112
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8400:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8401
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8401:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8402:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8403:
	imul rdi, [rsp + 0 + 8] ; multiply by (112 % d()) 
	jno .jump8404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8404:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump8405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8405:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8406: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1102] ; 85.64
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1049] ; 13.71
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8406 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8406 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8406 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const1103] ; 48.92
	push rax
	mov rax, [rel const1104] ; 28.95
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8407
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const298] ; 533
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8409:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8410
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8410:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8411:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8412:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8413:
	imul rdi, [rsp + 0 + 16] ; multiply by 533 
	jno .jump8414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8414:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8415: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8416
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump8417
.jump8416:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump8417:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8415 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8415 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8415 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump8408
.jump8407:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8418:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8419
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8419:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8420:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8421:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump8422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8422:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump8423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8423:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8424: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8424 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8424 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8424 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump8408:
	mov rax, [rel const1023] ; 560
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const1105] ; 34
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8425
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8425:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8426
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8426:
	; Computing bound for 'k'
	mov rax, [rel const851] ; 854
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8427:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8428
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8428:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8429
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8429:
	imul rdi, [rsp + 0 + 8] ; multiply by 854 
	jno .jump8430
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8430:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump8431
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8431:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8432: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8432 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8432 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8432 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const1066] ; 388
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8433
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8433:
	; Computing bound for 'j'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8434:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8435: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const166] ; 904
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8435 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8435 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const716] ; 387
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8436:
	cmp rax, [rsp + 24]
	jl .jump8437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8437:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8438:
	cmp rax, [rsp + 32]
	jl .jump8439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8439:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8440:
	cmp rax, [rsp + 40]
	jl .jump8441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8441:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8442:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8443:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8444
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8444:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8445: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8446
	mov rax, [rel const698] ; 348
	push rax
	jmp .jump8447
.jump8446:
	call _f
	push rax
.jump8447:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8445 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8445 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8448
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8448:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8449: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8450
	mov rax, [rel const1098] ; 398
	push rax
	jmp .jump8451
.jump8450:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
.jump8451:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8449 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8449 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8449 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const422] ; 706
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8452
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8452:
	; Computing bound for 'k'
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8453:
	; Computing bound for 'j'
	mov rax, [rel const1069] ; 587
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8454
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8454:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8455: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8455 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8455 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8455 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8456:
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8457
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8457:
	; Computing bound for 'j'
	mov rax, [rel const86] ; 659
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8458:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8459: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8459 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8459 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8459 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8460
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8460:
	cmp rax, [rsp + 24]
	jl .jump8461
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8461:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8462
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8462:
	cmp rax, [rsp + 32]
	jl .jump8463
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8463:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8464
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8464:
	cmp rax, [rsp + 40]
	jl .jump8465
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8465:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	mov rax, [rel const212] ; 903
	push rax
	call _d
	push rax
	mov rax, [rel const1106] ; 377
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8466
	call _d
	push rax
	mov rax, [rel const1107] ; 244
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump8467
.jump8466:
	call _f
	push rax
.jump8467:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8468
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8468:
	cmp rax, [rsp + 24]
	jl .jump8469
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8469:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8470
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8470:
	cmp rax, [rsp + 32]
	jl .jump8471
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8471:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8472
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8472:
	cmp rax, [rsp + 40]
	jl .jump8473
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8473:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump8398
.jump8397:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8474:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8475:
	; Computing bound for 'l'
	mov rax, [rel const1108] ; 783
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8476
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8476:
	; Computing bound for 'k'
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8477
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump8477:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const897] ; 624
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8478
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump8478:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8479:
	; Computing bound for 'j'
	mov rax, [rel const521] ; 758
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8480
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8480:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8481: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8482
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8482:
	; Computing bound for 'o'
	mov rax, [rel const300] ; 750
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8483
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump8483:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8484:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8485
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8485:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump8486: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8486 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8486 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8486 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8481 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8481 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8481 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8481 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8487
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8487:
	; Computing bound for 'l'
	mov rax, [rel const722] ; 353
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8488:
	; Computing bound for 'k'
	mov rax, [rel const1109] ; 891
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8489
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8489:
	; Computing bound for 'j'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8490:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8491: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8492:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8493
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8493:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8494:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump8495: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8495 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8495 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8495 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8491 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8491 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8491 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8491 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8496:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8497
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump8498
.jump8497:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump8498:
	pop rax
	cmp rax, 0
	je .jump8499
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump8500
.jump8499:
	mov rax, [rel const425] ; 935
	push rax
.jump8500:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8501
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8501:
	; Computing bound for 'j'
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8502
	call _d
	push rax
	jmp .jump8503
.jump8502:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8504
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8504:
	; Computing bound for 'j'
	mov rax, [rel const650] ; 421
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8505:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8506: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8506 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8506 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump8503:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8507:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if (f() >= d()) then d() else (sum[j : 421, k : d()] j)) 
	jno .jump8508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8508:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (if a then c else c) then (d() * d()) else 935) 
	jno .jump8509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8509:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[j : d(), k : 891, l : 353, m : (- d())] (sum[n : d(), o : d(), p : k] o)) 
	jno .jump8510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8510:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8511: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8512
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump8513
.jump8512:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump8513:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8511 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8511 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8511 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8514
	mov rax, [rel const45] ; False
	push rax
	jmp .jump8515
.jump8514:
	mov rax, [rel const45] ; False
	push rax
.jump8515:
	pop rax
	cmp rax, 0
	je .jump8516
	mov rax, [rel const45] ; False
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8518
	mov rax, [rel const45] ; False
	push rax
	jmp .jump8519
.jump8518:
	mov rax, [rel const45] ; False
	push rax
.jump8519:
	mov rax, [rel const1110] ; 28.36
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rax, [rel const45] ; False
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump8517
.jump8516:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump8517:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const160] ; 895
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8520
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8520:
	; Computing bound for 'k'
	mov rax, [rel const1111] ; 631
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8521:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8522
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8522:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8523
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8523:
	imul rdi, [rsp + 0 + 8] ; multiply by 631 
	jno .jump8524
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8524:
	imul rdi, [rsp + 0 + 16] ; multiply by 895 
	jno .jump8525
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8525:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8526: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8526 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8526 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8526 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const1112] ; 585
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8527
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8527:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8528:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8529
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8529:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8530: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const199] ; 187
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8530 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8530 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8530 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8531:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8532
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8532:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8533:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8534
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8534:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8535: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8535 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8535 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8535 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8535 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8536:
	cmp rax, [rsp + 24]
	jl .jump8537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8537:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8538:
	cmp rax, [rsp + 32]
	jl .jump8539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8539:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8540:
	cmp rax, [rsp + 40]
	jl .jump8541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8541:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8542
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8542:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8543
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8543:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8544: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8544 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8545:
	cmp rax, [rsp + 8]
	jl .jump8546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8546:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8547
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8549
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8549:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8550
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8550:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8551: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8552
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8553
.jump8552:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8553:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8551 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8548
.jump8547:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8554
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8556
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8556:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8557
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8557:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8558: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8558 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8555
.jump8554:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8559
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8559:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8560
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8560:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8561: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8561 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump8555:
.jump8548:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump8562
	mov rax, [rel const1113] ; 27.77
	push rax
	jmp .jump8563
.jump8562:
	mov rax, [rel const1114] ; 54.04
	push rax
.jump8563:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1115] ; 90.34
	push rax
	mov rax, [rel const1116] ; 86.26
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8564:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8565
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8565:
	; Computing bound for 'k'
	mov rax, [rel const735] ; 767
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8566:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8567
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8567:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8568: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8568 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8568 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8568 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8568 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8569
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8569:
	; Computing bound for 'k'
	mov rax, [rel const716] ; 387
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8570:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8571
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8571:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8572
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8572:
	imul rdi, [rsp + 0 + 8] ; multiply by 387 
	jno .jump8573
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8573:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[j : f(), k : 767, l : f(), m : d()] l) 
	jno .jump8574
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8574:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump8575: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1117] ; 63.88
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1118] ; 25.12
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8575 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8575 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8575 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8576
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
.jump8576:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8577
	mov rax, [rel const458] ; 884
	push rax
	jmp .jump8578
.jump8577:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8578:
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8579:
	cmp rax, [rsp + 24]
	jl .jump8580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8580:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8581:
	cmp rax, [rsp + 32]
	jl .jump8582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8582:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8583:
	cmp rax, [rsp + 40]
	jl .jump8584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8584:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump8398:
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8585:
	; Computing bound for 'l'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8586
	mov rax, [rel const1119] ; 507
	push rax
	jmp .jump8587
.jump8586:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8587:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8588
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8588:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const794] ; 413
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8589
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8589:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8590:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8591:
	imul rdi, [rsp + 0 + 8] ; multiply by 413 
	jno .jump8592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8592:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8593: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8593 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8593 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const414] ; 816
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8594:
	cmp rax, [rsp + 16]
	jl .jump8595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8595:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8596:
	cmp rax, [rsp + 24]
	jl .jump8597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8597:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8598:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (array[k : f(), l : 413] f())[d(), (- 816)] 
	jno .jump8599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8599:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! false) then 507 else d()) 
	jno .jump8600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8600:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump8601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8601:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8602: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump8603
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8603:
	push rax
	pop rax
	cmp rax, 0
	je .jump8604
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump8605
.jump8604:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump8606
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8606:
	push rax
.jump8605:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8602 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8602 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8602 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const1] ; True
	push rax
	mov rax, [rel const1] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8607
	mov rax, [rel const588] ; 361
	push rax
	jmp .jump8608
.jump8607:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8609
	call _d
	push rax
	jmp .jump8610
.jump8609:
	call _d
	push rax
.jump8610:
.jump8608:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8611:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (true == true) then 361 else (if a then d() else d())) 
	jno .jump8612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8612:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8613: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8614
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8614:
	; Computing bound for 'n'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8615:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8616
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8616:
	; Computing bound for 'l'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8617:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8618:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8619:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump8620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8620:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump8621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8621:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8622: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8622 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8622 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8622 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8622 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8623
	mov rax, [rel const743] ; 356
	push rax
	jmp .jump8624
.jump8623:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8624:
	call _d
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8625:
	cmp rax, [rsp + 32]
	jl .jump8626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8626:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8627:
	cmp rax, [rsp + 40]
	jl .jump8628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8628:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8629:
	cmp rax, [rsp + 48]
	jl .jump8630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8630:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8631:
	cmp rax, [rsp + 56]
	jl .jump8632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8632:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8613 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8633:
	cmp rax, [rsp + 8]
	jl .jump8634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8634:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8635:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8636
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8636:
	; Computing bound for 'k'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8637:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8638: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8638 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8638 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8638 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8639
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8639:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[k : f(), l : f(), m : f()] l) 
	jno .jump8640
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8640:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8641: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const792] ; 330
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8642:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 330 
	jno .jump8643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8643:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8644: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8644 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8641 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const647] ; 409
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8645:
	cmp rax, [rsp + 8]
	jl .jump8646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8646:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8647
	mov rax, [rel const296] ; 268
	push rax
	call _f
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump8648
.jump8647:
	mov rax, [rel const1120] ; 815
	push rax
.jump8648:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8649:
	; Computing bound for 'm'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8650:
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8651
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8651:
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8652:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8653:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- f())) 
	jno .jump8654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8654:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump8655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8655:
imul rdi, [rsp + 0 + 24] ; multiply by (if (j == g((array[k : (sum[k : f(), l : f(), m : f()] l)] (array[l : 330] f()))[(- 409)], h([a, c, c, c][(- d())]), (array[k : (if (true == true) then 361 else (if a then d() else d()))] (array[l : d(), m : f(), n : f(), o : k] false)[k, k, d(), (if false then 356 else d())]), (array[k : (array[k : f(), l : 413] f())[d(), (- 816)], l : (if (! false) then 507 else d()), m : d()] (if (true || c) then (j != j) else (true && a))))) then (f() * 268) else 815) 
	jno .jump8656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8656:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8657: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8658
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump8658:
	push rax
	pop rax
	cmp rax, 0
	je .jump8659
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump8660
.jump8659:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump8660:
	pop rax
	cmp rax, 0
	je .jump8661
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump8662
.jump8661:
	call _d
	push rax
.jump8662:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8663:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8664
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8664:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8665:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8666
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8666:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8667: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1077] ; 723
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8667 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8668:
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const425] ; 935
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8669:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8670
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8670:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8671
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8671:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8672:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8673
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8673:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8674: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8674 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8674 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8674 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8675:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : n, p : k, q : n] f()) 
	jno .jump8676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8676:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8677:
	imul rdi, [rsp + 0 + 16] ; multiply by 935 
	jno .jump8678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8678:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8679: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8679 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8679 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8679 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rel const244] ; 814
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8680
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8680:
	cmp rax, [rsp + 8]
	jl .jump8681
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8681:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8682
	mov rax, [rel const1121] ; 857
	push rax
	jmp .jump8683
.jump8682:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump8683:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8684
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8684:
	cmp rax, [rsp + 24]
	jl .jump8685
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8685:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8686
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8686:
	cmp rax, [rsp + 32]
	jl .jump8687
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8687:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8688
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8688:
	cmp rax, [rsp + 40]
	jl .jump8689
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8689:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8690
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8690:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,][,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[o : (sum[o : n, p : k, q : n] f()), p : f(), q : 935] o)[l, (if false then 857 else m), [l, 814, f(), k][k]] 
	jno .jump8691
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8691:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[o : (f() / k)] (- 723)) 
	jno .jump8692
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8692:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump8693
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8693:
	imul rdi, [rsp + 0 + 24] ; multiply by (if (if (c && true) then a else a) then m else d()) 
	jno .jump8694
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8694:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8695: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8696
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8696:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8697:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8698
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8698:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8699:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump8700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8700:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump8701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8701:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump8702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8702:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump8703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8703:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump8704: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8705:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8706
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8706:
	; Computing bound for 'x'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8707
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	jmp .jump8708
.jump8707:
	mov rax, [rel const135] ; 66
	push rax
.jump8708:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8709:
	; Computing bound for 'w'
	mov rax, [rel const1122] ; 408
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8710
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8710:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (p * 408) 
	jno .jump8711
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8711:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then o else 66) 
	jno .jump8712
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8712:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump8713
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8713:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump8714
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8714:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump8715: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8715 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8715 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8715 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8715 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8704 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8704 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8704 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8704 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8695 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8695 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8695 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8695 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8716
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8718:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8719
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8719:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8720
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8720:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8721:
	; Computing bound for 'p'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8722
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8722:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8723:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8724 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8724 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8724 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8724 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8725:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8726
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8726:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump8727
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8727:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[o : l, p : d(), q : m, r : k] d()) 
	jno .jump8728
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8728:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump8729
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8729:
	imul rdi, [rsp + 0 + 24] ; multiply by (d() * m) 
	jno .jump8730
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8730:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8731: ; Begin body of loop
	; Compute loop body
	call _d
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8731 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8731 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8731 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8731 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump8717
.jump8716:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8732:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8733
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8733:
	; Computing bound for 'p'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8734:
	; Computing bound for 'o'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8735
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8735:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8736
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8736:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8737
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8737:
	imul rdi, [rsp + 0 + 16] ; multiply by (n + k) 
	jno .jump8738
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8738:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump8739
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8739:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8740: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8740 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8740 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8740 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8740 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump8717:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const200] ; 10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8741
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8741:
	cmp rax, [rsp + 32]
	jl .jump8742
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8742:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8743
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8743:
	cmp rax, [rsp + 40]
	jl .jump8744
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8744:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8745
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8745:
	cmp rax, [rsp + 48]
	jl .jump8746
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8746:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8747
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8747:
	cmp rax, [rsp + 56]
	jl .jump8748
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8748:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8749
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump8750
.jump8749:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8751
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8751:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8752:
	; Computing bound for 'o'
	mov rax, [rel const867] ; 115
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8753
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8753:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8754: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8754 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8754 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8754 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8755:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
.jump8750:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8756
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8756:
	cmp rax, [rsp + 32]
	jl .jump8757
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8757:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8758
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8758:
	cmp rax, [rsp + 40]
	jl .jump8759
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8759:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8760
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8760:
	cmp rax, [rsp + 48]
	jl .jump8761
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8761:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8762
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8762:
	cmp rax, [rsp + 56]
	jl .jump8763
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8763:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const292] ; 881
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8764
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8765
.jump8764:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump8765:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const126] ; 16
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8766
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8766:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8767:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump8768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8768:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- 16)) 
	jno .jump8769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8769:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8770: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8771:
	; Computing bound for 'q'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8772
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8772:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8773
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8773:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump8774
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8774:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8775: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8775 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8775 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8776
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8776:
	cmp rax, [rsp + 16]
	jl .jump8777
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8777:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8778
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8778:
	cmp rax, [rsp + 24]
	jl .jump8779
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8779:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8770 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8770 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8780:
	cmp rax, [rsp + 16]
	jl .jump8781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8781:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8782:
	cmp rax, [rsp + 24]
	jl .jump8783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8783:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8784
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8784:
	cmp rax, [rsp + 32]
	jl .jump8785
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8785:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8786
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8786:
	cmp rax, [rsp + 40]
	jl .jump8787
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8787:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8788
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8788:
	cmp rax, [rsp + 48]
	jl .jump8789
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8789:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8790
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8790:
	cmp rax, [rsp + 56]
	jl .jump8791
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8791:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8657 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8657 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8657 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8657 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const996] ; 447
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8792:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8793: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8794
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8794:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8795:
	; Computing bound for 'l'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump8796
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump8797
.jump8796:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump8797:
	pop rax
	cmp rax, 0
	je .jump8798
	mov rax, [rel const1123] ; 351
	push rax
	jmp .jump8799
.jump8798:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8799:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8800
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8800:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8801: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8801 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8801 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8801 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8802
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8802:
	; Computing bound for 'n'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8803:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8804
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8804:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8805:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8806: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1124] ; 96.55
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8806 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8806 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8806 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8806 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8807
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const765] ; 145
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8809:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8810:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8811
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8811:
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8812:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8813:
	imul rdi, [rsp + 0 + 8] ; multiply by (f() / d()) 
	jno .jump8814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8814:
	imul rdi, [rsp + 0 + 16] ; multiply by 145 
	jno .jump8815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8815:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8816: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8817
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8817:
	; Computing bound for 'o'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8818:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8819: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8819 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8819 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8816 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8816 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8816 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump8808
.jump8807:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const1125] ; 20
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8820
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8820:
	; Computing bound for 'l'
	mov rax, [rel const1120] ; 815
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8821:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8822: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8822 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8822 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8823:
	; Computing bound for 'm'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8824
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8824:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8825
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8825:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8826: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8826 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8827:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : f()] d()) 
	jno .jump8828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8828:
	imul rdi, [rsp + 0 + 8] ; multiply by f() 
	jno .jump8829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8829:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[l : 815, m : 20] m) 
	jno .jump8830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8830:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump8831: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8832
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8832:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8833:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump8834: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8834 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8834 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8831 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8831 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8831 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump8808:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8835
	mov rax, [rel const1126] ; 234
	push rax
	jmp .jump8836
.jump8835:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8836:
	mov rax, [rel const1127] ; 478
	push rax
	mov rax, [rel const45] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump8837
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8837:
	push rax
	pop rax
	cmp rax, 0
	je .jump8838
	mov rax, [rel const1128] ; 79
	push rax
	jmp .jump8839
.jump8838:
	mov rax, [rel const827] ; 688
	push rax
	pop rax
	neg rax
	push rax
	call _d
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8840:
	cqo
	idiv r10
	push rax
.jump8839:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8841
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8841:
	cmp rax, [rsp + 24]
	jl .jump8842
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8842:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8843
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8843:
	cmp rax, [rsp + 32]
	jl .jump8844
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8844:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8845
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump8845:
	cmp rax, [rsp + 40]
	jl .jump8846
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump8846:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8793 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8847
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const525] ; 670
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8849
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8849:
	; Computing bound for 'm'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8850:
	; Computing bound for 'l'
	mov rax, [rel const227] ; 309
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8851
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8851:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8852
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8852:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8853: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const759] ; 920
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8853 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8854:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[k : d()] 920) 
	jno .jump8855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8855:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 309) 
	jno .jump8856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8856:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump8857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8857:
	imul rdi, [rsp + 0 + 24] ; multiply by 670 
	jno .jump8858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8858:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8859: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8860
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump8861
.jump8860:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump8861:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8859 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8859 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8859 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8859 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8862
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8864:
	; Computing bound for 'k'
	mov rax, [rel const301] ; 566
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8865
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8865:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8866: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8866 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8866 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump8863
.jump8862:
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
.jump8863:
	call _f
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8867:
	cmp rax, [rsp + 32]
	jl .jump8868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8868:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8869:
	cmp rax, [rsp + 40]
	jl .jump8870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8870:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8871:
	cmp rax, [rsp + 48]
	jl .jump8872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8872:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8873:
	cmp rax, [rsp + 56]
	jl .jump8874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8874:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1129] ; 204
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8875
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8877
	mov rax, [rel const1] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump8879
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
.jump8879:
	push rax
	jmp .jump8878
.jump8877:
	call _d
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1079] ; 626
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump8878:
	pop rax
	cmp rax, 0
	je .jump8880
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8882
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8882:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- d())) 
	jno .jump8883
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8883:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8884: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8884 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8881
.jump8880:
	call _d
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	call _f
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8885:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8886: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const545] ; 629
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8886 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8887
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump8887:
	cqo
	idiv r10
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump8881:
	jmp .jump8876
.jump8875:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const201] ; 477
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8888
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8888:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8889: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8889 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8890:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8891
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8891:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by ((- (sum[k : 477] f())) / f()) 
	jno .jump8892
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8892:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8893: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1130] ; 66.93
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8894
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump8895
.jump8894:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump8895:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8893 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump8876:
	jmp .jump8848
.jump8847:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8896
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8896:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump8897
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8897:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump8898: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8898 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump8848:
	call _f
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8899:
	cmp rax, [rsp + 8]
	jl .jump8900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8900:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8901:
	cmp rax, [rsp + 32]
	jl .jump8902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8902:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8903:
	cmp rax, [rsp + 40]
	jl .jump8904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8904:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump8905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8905:
	cmp rax, [rsp + 48]
	jl .jump8906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8906:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump8907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8907:
	cmp rax, [rsp + 56]
	jl .jump8908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8908:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump8909
	lea rdi, [rel const1131] ; 'q'
	call _fail_assertion
.jump8909:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8910
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8910:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8911:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump8912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8912:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump8913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8913:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8914: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8915:
	; Computing bound for 's'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8916
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8916:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8917
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8917:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump8918
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8918:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump8919: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8920
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8920:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8921:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump8922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8922:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump8923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8923:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump8924: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8924 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8924 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8919 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8919 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8914 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8914 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump8925
	call _f
	push rax
	jmp .jump8926
.jump8925:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump8926:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8927:
	cmp rax, [rsp + 16]
	jl .jump8928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8928:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8929:
	cmp rax, [rsp + 24]
	jl .jump8930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8930:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8931
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8933:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8934
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8934:
	; Computing bound for 'q'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8935:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8936: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8936 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8936 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8936 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump8932
.jump8931:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump8932:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8937
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8937:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8938
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8938:
	; Computing bound for 'q'
	mov rax, [rel const120] ; 731
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8939:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8940: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8940 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8940 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8941:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8942
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8942:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8943:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8944: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump8944 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump8944 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump8944 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump8944 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1132] ; 85.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8945
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8947:
	; Computing bound for 'q'
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump8948
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8949
.jump8948:
	mov rax, [rel const442] ; 87
	push rax
.jump8949:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8950
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8950:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8951: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8951 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8951 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump8946
.jump8945:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump8946:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8952:
	cmp rax, [rsp + 16]
	jl .jump8953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8953:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8954:
	cmp rax, [rsp + 24]
	jl .jump8955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8955:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8956:
	cmp rax, [rsp + 16]
	jl .jump8957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8957:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8958:
	cmp rax, [rsp + 24]
	jl .jump8959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8959:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1133] ; 52.86
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8960
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8960:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8961:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8962: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8962 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8962 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1134] ; 87.72
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8963
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump8964
.jump8963:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump8964:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const13] ; 471
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const33] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8965:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	call _d
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8966
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8966:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8967:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (n * m) 
	jno .jump8968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8968:
	imul rdi, [rsp + 0 + 8] ; multiply by (d() + (f() % 471)) 
	jno .jump8969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8969:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump8970: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const1135] ; 38
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8971:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8972
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8972:
	; Computing bound for 's'
	mov rax, [rel const747] ; 290
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8973:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 290 
	jno .jump8974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8974:
	imul rdi, [rsp + 0 + 8] ; multiply by (- n) 
	jno .jump8975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8975:
	imul rdi, [rsp + 0 + 16] ; multiply by 38 
	jno .jump8976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8976:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump8977: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1136] ; 37.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8977 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8977 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8977 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; True
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8978
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump8979
.jump8978:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const45] ; False
	push rax
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
.jump8979:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8980
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const201] ; 477
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8982
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8982:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 477 
	jno .jump8983
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump8983:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump8984: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump8984 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump8981
.jump8980:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump8981:
	call _g
	add rsp, 16
	add rsp, 8
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8970 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump8970 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8985
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump8986
.jump8985:
	call _d
	push rax
.jump8986:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump8987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8987:
	cmp rax, [rsp + 16]
	jl .jump8988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8988:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump8989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8989:
	cmp rax, [rsp + 24]
	jl .jump8990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8990:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const1137] ; 's.png'
	call _write_image
	add rsp, 24
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump8991
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8993:
	; Computing bound for 'u'
	mov rax, [rel const1138] ; 795
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8994
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump8994:
	; Computing bound for 't'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump8995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8995:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump8996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8996:
	imul rdi, [rsp + 0 + 8] ; multiply by 795 
	jno .jump8997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8997:
	imul rdi, [rsp + 0 + 16] ; multiply by d() 
	jno .jump8998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8998:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump8999: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9000
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const1139] ; 51.85
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9002
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump9003
.jump9002:
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
.jump9003:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9004
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9004:
	; Computing bound for 'w'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9005:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump9006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9006:
	imul rdi, [rsp + 0 + 8] ; multiply by (if ((i != 51.85) != (! false)) then u else t) 
	jno .jump9007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9007:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump9008: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9008 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9008 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump9001
.jump9000:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9009
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9009:
	; Computing bound for 'w'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9010:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump9011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9011:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump9012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9012:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump9013: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9014
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9016:
	; Computing bound for 'y'
	mov rax, [rel const549] ; 602
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9017
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9017:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 602 
	jno .jump9018
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9018:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump9019
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9019:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump9020: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9020 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9020 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9021
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9021:
	cmp rax, [rsp + 16]
	jl .jump9022
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9022:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9023
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9023:
	cmp rax, [rsp + 24]
	jl .jump9024
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9024:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9015
.jump9014:
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump9015:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9013 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9013 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump9001:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump8999 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump8999 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump8999 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump8992
.jump8991:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9025:
	; Computing bound for 'u'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9026
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9026:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9027
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9029
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9029:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9030:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump9031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9031:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump9032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9032:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump9033: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9034:
	; Computing bound for 'v'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9035
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9035:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump9036
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9036:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump9037
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9037:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump9038: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9038 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9038 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9033 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9033 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9039:
	cmp rax, [rsp + 16]
	jl .jump9040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9040:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9041:
	cmp rax, [rsp + 24]
	jl .jump9042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9042:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9043
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9043:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9044:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9045
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9045:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9046:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump9047: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const45] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9048
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump9049
.jump9048:
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
.jump9049:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9047 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9047 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9047 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9047 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9050:
	cmp rax, [rsp + 16]
	jl .jump9051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9051:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9052:
	cmp rax, [rsp + 24]
	jl .jump9053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9053:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9028
.jump9027:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9054
	sub rsp, 40
	; Moving 40 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump9055
.jump9054:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9056:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9057
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9057:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9058:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9059
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9059:
	; Computing bound for 't'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9060:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f() 
	jno .jump9061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9061:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump9062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9062:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump9063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9063:
	imul rdi, [rsp + 0 + 24] ; multiply by (f() / f()) 
	jno .jump9064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9064:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump9065: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9065 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9065 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9065 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9065 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump9055:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9066:
	cmp rax, [rsp + 32]
	jl .jump9067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9067:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9068:
	cmp rax, [rsp + 40]
	jl .jump9069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9069:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9070:
	cmp rax, [rsp + 48]
	jl .jump9071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9071:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9072:
	cmp rax, [rsp + 56]
	jl .jump9073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9073:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump9028:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9074:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if c then (array[t : m, u : o] (array[v : f(), w : s] s))[o, m][(sum[t : m, u : o, v : o, w : l] (if (! false) then f() else v)), o] else (if a then k else (array[t : f(), u : n, v : o, w : (f() / f())] d()))[l, (- d()), f(), n]) 
	jno .jump9075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9075:
	imul rdi, [rsp + 0 + 8] ; multiply by (n - d()) 
	jno .jump9076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9076:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump9077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9077:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump9078: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1140] ; 2.9
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9079
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9081
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9081:
	; Computing bound for 'y'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9082:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9083
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9083:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9084:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump9085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9085:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump9086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9086:
	imul rdi, [rsp + 0 + 16] ; multiply by f() 
	jno .jump9087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9087:
	imul rdi, [rsp + 0 + 24] ; multiply by d() 
	jno .jump9088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9088:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump9089: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 96
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9089 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9089 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9089 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9089 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9090:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9091
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9091:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9092:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump9093: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9094
	lea rdi, [rel const14] ; 'divide by zero'
	call _fail_assertion
.jump9094:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9093 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9093 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9093 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9095:
	cmp rax, [rsp + 32]
	jl .jump9096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9096:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9097:
	cmp rax, [rsp + 40]
	jl .jump9098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9098:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9099:
	cmp rax, [rsp + 48]
	jl .jump9100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9100:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump9101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9101:
	cmp rax, [rsp + 56]
	jl .jump9102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9102:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9080
.jump9079:
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	call _jpl_alloc
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9103:
	cmp rax, [rsp + 8]
	jl .jump9104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9104:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9105:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	call _d
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9106
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9106:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (d() * t) 
	jno .jump9107
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9107:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump9108
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9108:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump9109: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const641] ; 824
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9110:
	cmp rax, [rsp + 16]
	jl .jump9111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9111:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9112:
	cmp rax, [rsp + 24]
	jl .jump9113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9113:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9109 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9109 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 96
	call _jpl_alloc
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 4
	push rax
.jump9080:
	call _d
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9114:
	cmp rax, [rsp + 8]
	jl .jump9115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9115:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump9078 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump9078 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump9078 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump8992:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9116
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9116:
	cmp rax, [rsp + 24]
	jl .jump9117
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9117:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9118
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9118:
	cmp rax, [rsp + 32]
	jl .jump9119
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9119:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump9120
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9120:
	cmp rax, [rsp + 40]
	jl .jump9121
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9121:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const1141] ; 't.png'
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9362
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9362:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9363:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9364
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9364:
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const724] ; 64
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9365
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9365:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9366
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9366:
	push rax
	pop rax
	cmp rax, 0
	je .jump9367
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9367:
	push rax
	pop rax
	cmp rax, 0
	je .jump9368
	mov rax, [rel const1] ; True
	push rax
	pop rax
.jump9368:
	push rax
	pop rax
	cmp rax, 0
	je .jump9369
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump9370
.jump9369:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump9370:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9371:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9372: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9372 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9372 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9373
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9375
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump9376
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9376:
	push rax
	pop rax
.jump9375:
	push rax
	pop rax
	cmp rax, 0
	je .jump9377
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const788] ; 207
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9379:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9380
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9380:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump9381
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9381:
	imul rdi, [rsp + 0 + 8] ; multiply by 207 
	jno .jump9382
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9382:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9383: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9383 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9383 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump9378
.jump9377:
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump9384
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9386:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9387
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9387:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump9388
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9388:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump9389
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9389:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9390: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9390 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9390 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump9385
.jump9384:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9391:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9392
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9392:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump9393
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9393:
	imul rdi, [rsp + 0 + 8] ; multiply by d() 
	jno .jump9394
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump9394:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9395 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump9395 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump9385:
.jump9378:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9396
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
.jump9396:
	push rax
	pop rax
	cmp rax, 0
	je .jump9397
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9399
	call _f
	push rax
	jmp .jump9400
.jump9399:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump9400:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9401:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9402: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump9403
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump9404
.jump9403:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump9404:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9402 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump9398
.jump9397:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump9398:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump9405
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9405:
	cmp rax, [rsp + 16]
	jl .jump9406
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9406:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump9407
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump9407:
	cmp rax, [rsp + 24]
	jl .jump9408
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump9408:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump9374
.jump9373:
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump9374:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9409
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9411
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump9412
.jump9411:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump9412:
	jmp .jump9410
.jump9409:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump9413
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump9414
.jump9413:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump9414:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9415
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9415:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9416: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9417:
	; Computing bound for 'x'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9418
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9418:
	; Computing bound for 'w'
	call _f
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9419:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9420
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump9420:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump9421: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const819] ; 101
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9421 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9421 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9421 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9421 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump9416 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump9410:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9422:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if ((if c then (if (p || (p || r)) then (array[u : s, v : 207] (i / i)) else (if true then (array[u : l, v : d()] j) else (array[u : m, v : d()] i)))[(if (c && p) then (sum[u : (if r then f() else o)] (if r then m else n)) else l), l] else (- q.b)) != (sum[u : (if (((p && p) && a) && true) then l else s), v : 64] j)) then (if (m != o) then m else m) else (sum[u : (if (! (n == m)) then n else f())] (sum[v : (- m), w : f(), x : f(), y : m] (- 101)))) 
	jno .jump9423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9423:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump9424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9424:
	imul rdi, [rsp + 0 + 16] ; multiply by (m + (- s)) 
	jno .jump9425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9425:
	imul rdi, [rsp + 0 + 24] ; multiply by f() 
	jno .jump9426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9426:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump9427: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const803] ; 947
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump9427 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump9427 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump9427 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump9427 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	lea rdi, [rsp]
	sub rsp, 8 ; Add alignment
	lea rsi, [rel const1166] ; 'D.png'
	call _read_image
	add rsp, 8 ; Remove alignment
	mov rax, [rel const1] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump10690
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10692:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10693
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10693:
	; Computing bound for 'E'
	mov rax, [rel const271] ; 99
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10694:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 99 
	jno .jump10695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10695:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump10696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10696:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump10697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10697:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump10698: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10698 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10698 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10698 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump10691
.jump10690:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10699
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10701:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10702
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10702:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump10703
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10703:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump10704
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10704:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump10705: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10706
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10706:
	; Computing bound for 'H'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10707
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10707:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10708:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump10709: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10709 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10709 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10710:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10711
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10711:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump10712
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10712:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[G : s, H : v] E) 
	jno .jump10713
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10713:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump10714
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10714:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump10715: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const927] ; 433
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10716
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10716:
	cmp rax, [rsp + 16]
	jl .jump10717
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10717:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10718
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10718:
	cmp rax, [rsp + 24]
	jl .jump10719
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10719:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'I'
	add qword [rsp + 16], 1
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10715 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10715 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10715 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10705 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10705 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10720
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10720:
	cmp rax, [rsp + 16]
	jl .jump10721
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10721:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10722
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10722:
	cmp rax, [rsp + 24]
	jl .jump10723
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10723:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump10700
.jump10699:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	call _d
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10724:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump10725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10725:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump10726: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10727
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	mov rax, [rel const414] ; 816
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10729:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10730:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump10731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10731:
	imul rdi, [rsp + 0 + 8] ; multiply by 816 
	jno .jump10732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10732:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump10733: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump10733 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump10733 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _h
	add rsp, 8 ; Remove alignment
	push rax
	call _t
	add rsp, 8
	add rsp, 24
	push rax
	jmp .jump10728
.jump10727:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump10734
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump10735
	mov rax, [rel const45] ; False
	push rax
	pop rax
.jump10735:
	push rax
	pop rax
.jump10734:
	push rax
.jump10728:
	pop rax
	cmp rax, 0
	je .jump10736
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	mov rax, [rel const349] ; 908
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10738
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10738:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10739:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump10740: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10740 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10741:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10742
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10742:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump10743
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10743:
imul rdi, [rsp + 0 + 8] ; multiply by ((sum[F : l] l) * B) 
	jno .jump10744
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10744:
	imul rdi, [rsp + 0 + 16] ; multiply by 908 
	jno .jump10745
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10745:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump10746: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10747
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10747:
	cmp rax, [rsp + 16]
	jl .jump10748
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10748:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10749
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10749:
	cmp rax, [rsp + 24]
	jl .jump10750
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10750:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10746 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10746 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10746 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump10737
.jump10736:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10751
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10751:
	; Computing bound for 'G'
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10752:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	call _d
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10753
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10753:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d() 
	jno .jump10754
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10754:
	imul rdi, [rsp + 0 + 8] ; multiply by (f() + f()) 
	jno .jump10755
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10755:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump10756
	lea rdi, [rel const7] ; 'overflow computing array size'
	call _fail_assertion
.jump10756:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump10757: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump10758
	sub rsp, 24
	; Moving 24 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump10759
.jump10758:
	sub rsp, 24
	; Moving 24 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
.jump10759:
	mov rax, [rel const306] ; 12
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const193] ; 749
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10760
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10760:
	cmp rax, [rsp + 16]
	jl .jump10761
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10761:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump10762
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10762:
	cmp rax, [rsp + 24]
	jl .jump10763
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10763:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump10757 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump10757 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump10757 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump10737:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump10726 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump10700:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump10764
	lea rdi, [rel const9] ; 'negative array index'
	call _fail_assertion
.jump10764:
	cmp rax, [rsp + 8]
	jl .jump10765
	lea rdi, [rel const10] ; 'index too large'
	call _fail_assertion
.jump10765:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10691:
	add rsp, 256 ; Local variables
	pop r12 ; begin jpl_main postlude
	pop rbp
	ret

