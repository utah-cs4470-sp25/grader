global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 19.64
const1: dq 0
const2: dq 41.05
const3: dq 53.42
const4: dq 4.41
const5: dq 213
const6: db `non-positive loop bound`, 0
const7: dq 615
const8: dq 653
const9: dq 73.88
const10: dq 66.06
const11: dq 1
const12: dq 332
const13: dq 629
const14: dq 375
const15: dq 792
const16: dq 267
const17: dq 12
const18: dq 379
const19: dq 582
const20: dq 546
const21: dq 811
const22: dq 131
const23: dq 876
const24: dq 319
const25: dq 531
const26: db `overflow computing array size`, 0
const27: dq 337
const28: dq 599
const29: dq 158
const30: dq 164
const31: dq 958
const32: dq 190
const33: dq 263
const34: dq 373
const35: dq 698
const36: dq 803
const37: dq 587
const38: dq 985
const39: dq 520
const40: dq 872
const41: dq 903
const42: dq 180
const43: dq 497
const44: dq 719
const45: dq 809
const46: dq 289
const47: dq 56
const48: dq 326
const49: dq 24
const50: dq 858
const51: dq 983
const52: dq 906
const53: db `negative array index`, 0
const54: db `index too large`, 0
const55: dq 49
const56: dq 960
const57: dq 694
const58: dq 726
const59: dq 196
const60: dq 778
const61: dq 752
const62: dq 609
const63: dq 361
const64: db `divide by zero`, 0
const65: dq 355
const66: dq 76
const67: dq 302
const68: dq 414
const69: dq 555
const70: dq 185
const71: dq 444
const72: dq 264
const73: dq 768
const74: dq 357
const75: dq 716
const76: dq 953
const77: dq 748
const78: dq 705
const79: dq 741
const80: dq 441
const81: dq 105
const82: dq 329
const83: dq 488
const84: dq 636
const85: dq 769
const86: dq 579
const87: dq 316
const88: dq 933
const89: dq 891
const90: dq 682
const91: dq 684
const92: dq 919
const93: dq 917
const94: dq 697
const95: dq 162
const96: dq 80
const97: dq 325
const98: dq 407
const99: dq 672
const100: dq 62.65
const101: dq 73.76
const102: dq 58.7
const103: dq 65.64
const104: dq 1000
const105: dq 479
const106: dq 810
const107: dq 314
const108: dq 280
const109: dq 366
const110: dq 274
const111: dq 844
const112: dq 765
const113: dq 871
const114: dq 245
const115: dq 104
const116: dq 945
const117: dq 261
const118: dq 656
const119: dq 293
const120: dq 833
const121: dq 981
const122: dq 125
const123: dq 184
const124: dq 424
const125: dq 613
const126: dq 168
const127: dq 282
const128: dq 397
const129: dq 68
const130: dq 662
const131: dq 849
const132: dq 739
const133: dq 515
const134: dq 311
const135: dq 281
const136: dq 108
const137: dq 570
const138: dq 861
const139: dq 211
const140: dq 767
const141: dq 539
const142: dq 394
const143: dq 458
const144: dq 147
const145: dq 209
const146: dq 117
const147: dq 728
const148: dq 32
const149: dq 607
const150: dq 463
const151: db `mod by zero`, 0
const152: dq 230
const153: dq 505
const154: dq 801
const155: dq 349
const156: dq 523
const157: dq 780
const158: dq 622
const159: dq 110
const160: dq 581
const161: dq 855
const162: dq 954
const163: dq 543
const164: dq 115
const165: dq 169
const166: dq 126
const167: dq 916
const168: dq 65
const169: dq 419
const170: dq 111
const171: dq 787
const172: dq 442
const173: dq 51
const174: dq 970
const175: dq 469
const176: dq 600
const177: dq 644
const178: dq 511
const179: dq 491
const180: dq 160
const181: dq 16
const182: dq 324
const183: dq 649
const184: dq 412
const185: dq 5.43
const186: dq 735
const187: dq 335
const188: dq 910
const189: dq 492
const190: dq 121
const191: dq 255
const192: dq 406
const193: dq 63.34
const194: dq 44.72
const195: dq 473
const196: dq 595
const197: dq 137
const198: dq 246
const199: dq 993
const200: dq 974
const201: dq 742
const202: dq 57
const203: dq 50
const204: dq 295
const205: dq 695
const206: dq 856
const207: dq 194
const208: dq 987
const209: dq 100
const210: dq 829
const211: dq 826
const212: dq 266
const213: dq 275
const214: dq 75
const215: dq 888
const216: dq 367
const217: dq 34
const218: dq 620
const219: dq 292
const220: dq 920
const221: dq 145
const222: dq 882
const223: dq 931
const224: dq 102
const225: dq 69
const226: dq 30
const227: dq 733
const228: dq 880
const229: dq 731
const230: dq 973
const231: dq 420
const232: dq 443
const233: dq 961
const234: dq 430
const235: dq 864
const236: dq 673
const237: dq 797
const238: dq 300
const239: dq 854
const240: dq 285
const241: dq 701
const242: dq 654
const243: dq 106
const244: dq 437
const245: dq 130
const246: dq 619
const247: dq 820
const248: dq 484
const249: dq 273
const250: dq 483
const251: dq 606
const252: dq 657
const253: dq 553
const254: dq 28
const255: dq 680
const256: dq 296
const257: dq 532
const258: dq 97
const259: dq 832
const260: dq 356
const261: dq 681
const262: dq 61
const263: dq 200
const264: dq 717
const265: dq 5.64
const266: dq 83.81
const267: dq 718
const268: dq 927
const269: dq 77
const270: dq 418
const271: dq 156
const272: dq 287
const273: dq 328
const274: dq 238
const275: dq 715
const276: dq 572
const277: dq 843
const278: dq 959
const279: dq 641
const280: dq 592
const281: dq 202
const282: dq 580
const283: dq 988
const284: dq 272
const285: dq 348
const286: dq 997
const287: dq 900
const288: dq 883
const289: dq 800
const290: dq 83.42
const291: dq 4.88
const292: dq 58.65
const293: dq 32.0
const294: dq 38.04
const295: dq 27.8
const296: dq 5.83
const297: dq 952
const298: dq 31.01
const299: dq 66.67
const300: dq 6.37
const301: dq 2.77
const302: dq 63.33
const303: dq 83.9
const304: dq 24.73
const305: dq 58.17
const306: dq 936
const307: dq 12.31
const308: dq 53.45
const309: dq 459
const310: dq 789
const311: dq 109
const312: dq 283
const313: dq 490
const314: dq 205
const315: dq 208
const316: dq 550
const317: dq 738
const318: dq 773
const319: dq 915
const320: dq 403
const321: dq 967
const322: dq 825
const323: dq 512
const324: dq 603
const325: dq 183
const326: dq 782
const327: dq 249
const328: dq 610
const329: dq 982
const330: dq 747
const331: dq 178
const332: dq 63.52
const333: dq 57.47
const334: dq 908
const335: dq 84
const336: dq 429
const337: dq 703
const338: dq 984
const339: dq 965
const340: dq 438
const341: dq 498
const342: dq 262
const343: dq 999
const344: dq 22
const345: dq 878
const346: dq 378
const347: dq 198
const348: dq 478
const349: dq 86.49
const350: dq 340
const351: dq 71.85
const352: dq 331
const353: dq 342
const354: dq 7
const355: dq 123
const356: dq 482
const357: dq 846
const358: dq 83.44
const359: dq 252
const360: dq 64
const361: dq 271
const362: dq 477
const363: dq 191
const364: dq 892
const365: dq 643
const366: dq 40
const367: dq 207
const368: dq 712
const369: dq 14.82
const370: dq 548
const371: dq 290
const372: dq 972
const373: dq 432
const374: dq 904
const375: dq 583
const376: dq 35
const377: dq 5
const378: dq 746
const379: dq 740
const380: dq 551
const381: dq 940
const382: dq 749
const383: dq 231
const384: dq 589
const385: dq 519
const386: dq 39.47
const387: dq 59.1
const388: dq 838
const389: dq 244
const390: dq 155
const391: dq 409
const392: dq 237
const393: dq 425
const394: dq 124
const395: dq 591
const396: dq 363
const397: dq 941
const398: dq 874
const399: dq 92
const400: dq 693
const401: dq 510
const402: dq 159
const403: dq 611
const404: dq 584
const405: dq 772
const406: dq 265
const407: dq 417
const408: dq 408
const409: dq 563
const410: dq 457
const411: dq 112
const412: dq 174
const413: dq 912
const414: dq 552
const415: dq 637
const416: dq 173
const417: dq 333
const418: dq 80.3
const419: dq 69.19
const420: dq 91
const421: dq 918
const422: dq 756
const423: dq 47
const424: dq 351
const425: dq 842
const426: dq 428
const427: dq 260
const428: dq 48.54
const429: dq 42.59
const430: dq 372
const431: dq 802
const432: dq 71.22
const433: dq 651
const434: dq 542
const435: dq 25.64
const436: dq 75.69
const437: dq 48.97
const438: dq 75.11
const439: dq 56.85
const440: dq 71.24
const441: dq 81.92
const442: dq 601
const443: dq 38
const444: dq 24.72
const445: dq 44
const446: dq 71.2
const447: dq 777
const448: dq 586
const449: dq 353
const450: dq 37.82
const451: dq 61.85
const452: dq 28.41
const453: dq 866
const454: dq 650
const455: dq 323
const456: dq 5.46
const457: dq 493
const458: dq 669
const459: dq 816
const460: dq 899
const461: dq 79.95
const462: dq 354
const463: dq 815
const464: dq 828
const465: dq 529
const466: dq 45.83
const467: dq 165
const468: dq 80.59
const469: db `o`, 0
const470: dq 646
const471: dq 468
const472: dq 27.02
const473: dq 785
const474: dq 253
const475: dq 93
const476: dq 304
const477: dq 359
const478: dq 455
const479: dq 898
const480: dq 12.01
const481: dq 714
const482: dq 199
const483: dq 70.35
const484: dq 26.44
const485: dq 96
const486: dq 396
const487: dq 132
const488: dq 921
const489: dq 278
const490: dq 76.2
const491: dq 59.18
const492: dq 679
const493: dq 585
const494: dq 27.92
const495: dq 74.91
const496: dq 15.47
const497: dq 93.78
const498: dq 68.25
const499: dq 151
const500: dq 118
const501: dq 538
const502: dq 341
const503: dq 476
const504: dq 21
const505: dq 17.31
const506: dq 51.73
const507: dq 47.64
const508: dq 50.65
const509: dq 63.63
const510: dq 78.62
const511: dq 172
const512: dq 48.84
const513: dq 1.03
const514: db `t`, 0
const515: dq 890
const516: dq 964
const517: dq 562
const518: dq 487
const519: dq 36.28
const520: dq 89.32
const521: dq 8.86
const522: dq 655
const523: dq 52
const524: dq 992
const525: dq 28.6
const526: dq 80.76
const527: dq 93.04
const528: dq 152
const529: dq 63.25
const530: dq 51.61
const531: dq 26.54
const532: dq 4.45
const533: dq 82.28
const534: dq 27.93
const535: db `x`, 0
const536: dq 34.97
const537: dq 369
const538: dq 222
const539: dq 944
const540: db `m`, 0
const541: dq 83.64
const542: dq 80.26
const543: dq 88.36
const544: dq 35.12
const545: dq 71.03
const546: dq 76.17
const547: dq 8.94
const548: dq 70.09
const549: dq 2.38
const550: dq 59.51
const551: dq 39.12
const552: dq 41.45
const553: dq 35.3
const554: dq 15.99
const555: dq 33.14
const556: dq 60.91
const557: dq 50.02
const558: dq 6.77
const559: dq 386
const560: db `E`, 0
const561: dq 87.82
const562: dq 91.76
const563: dq 632
const564: dq 84.21
const565: db `H`, 0
const566: dq 234
const567: dq 18.43
const568: dq 23
const569: dq 67.24
const570: dq 29
const571: dq 59.31
const572: dq 10.71
const573: dq 78.78
const574: dq 60.67
const575: dq 27.31
const576: dq 59.19
const577: dq 99
const578: dq 37.77
const579: dq 68.18
const580: dq 40.72
const581: dq 98
const582: dq 68.08
const583: dq 270
const584: dq 52.97
const585: dq 79.11
const586: dq 6.9
const587: dq 77.12
const588: dq 73.57
const589: dq 315
const590: dq 47.69
const591: dq 14.72
const592: dq 11.9
const593: dq 23.82
const594: dq 80.5
const595: dq 45.79
const596: dq 61.32
const597: dq 99.72
const598: dq 3.15
const599: dq 764
const600: dq 509
const601: dq 893
const602: dq 18.2
const603: dq 4.29
const604: dq 313
const605: dq 766
const606: db `J`, 0
const607: db `t.png`, 0
const608: dq 72.54
const609: dq 95.38
const610: dq 95.74
const611: dq 914
const612: dq 15
const613: dq 2.01
const614: dq 64.36
const615: dq 628
const616: dq 781
const617: dq 91.23
const618: dq 224
const619: dq 998
const620: dq 26.81
const621: dq 40.83
const622: dq 771
const623: dq 503
const624: dq 905
const625: dq 44.25
const626: dq 16.36
const627: dq 8.71
const628: dq 451
const629: dq 696
const630: dq 29.38
const631: dq 39.13
const632: dq 2.4
const633: dq 29.41
const634: dq 384
const635: dq 793
const636: dq 66.05
const637: dq 64.47
const638: dq 52.96
const639: dq 60.87
const640: dq 81.45
const641: dq 27.08
const642: dq 3.76
const643: dq 9.61
const644: dq 84.52
const645: dq 64.97
const646: dq 56.37
const647: dq 4.94
const648: dq 27.61
const649: dq 80.75
const650: dq 14.87
const651: dq 94.05
const652: dq 55.21
const653: dq 143
const654: dq 317
const655: dq 15.84
const656: dq 75.15
const657: dq 97.9
const658: dq 41.95
const659: dq 34.55
const660: dq 103
const661: dq 0.55
const662: dq 77.37
const663: dq 30.41
const664: dq 51.99
const665: dq 94.87
const666: dq 19.85
const667: dq 33.29
const668: dq 98.97
const669: dq 5.32
const670: dq 7.96
const671: dq 59.73
const672: dq 37.02
const673: dq 68.68
const674: dq 53.47
const675: dq 43.8
const676: dq 86.92
const677: dq 31.26
const678: dq 841
const679: dq 51.72
const680: dq 32.69
const681: dq 89.47
const682: dq 83.23
const683: dq 81.52
const684: dq 30.49
const685: dq 31.68
const686: dq 23.84
const687: dq 40.63
const688: db `z`, 0
const689: dq 13.77
const690: dq 19.02
const691: dq 707
const692: dq 70.58
const693: dq 29.53
const694: dq 865
const695: db `A`, 0
const696: dq 48.49
const697: dq 1.51
const698: dq 652
const699: dq 368
const700: dq 863
const701: dq 807
const702: dq 648
const703: dq 72.16
const704: dq 371
const705: dq 69.85
const706: dq 93.89
const707: dq 27.69
const708: dq 41.14
const709: dq 17.07
const710: dq 79.43
const711: dq 32.6
const712: dq 11.47
const713: dq 779
const714: dq 11
const715: dq 77.65
const716: dq 963
const717: dq 12.19
const718: dq 55.22
const719: dq 51.71
const720: dq 25.89
const721: dq 55.53
const722: dq 928
const723: dq 15.83
const724: dq 29.84
const725: dq 62.7
const726: dq 138
const727: dq 92.09
const728: dq 40.97
const729: dq 62.16
const730: dq 96.61
const731: dq 51.54
const732: dq 25.66
const733: dq 49.43
const734: dq 852
const735: dq 107
const736: dq 91.8
const737: dq 1.98
const738: dq 23.03
const739: dq 364
const740: dq 873
const741: dq 19
const742: db `X`, 0
const743: dq 13
const744: dq 31.63
const745: dq 64.9
const746: dq 68.96
const747: dq 44.29
const748: dq 10.03
const749: dq 39.7
const750: dq 47.37
const751: dq 860
const752: dq 808
const753: dq 99.44
const754: dq 634
const755: dq 5.29
const756: db `(ArrayType (FloatType) 1)`, 0

section .text
i:
_i:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1355:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1356
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1356:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1357
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1357:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1358
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1358:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1359: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const446] ; 71.2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1359 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1359 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1360
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1362
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1362:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1363: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1363 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1361
.jump1360:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump1361:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const447] ; 777
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1364:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const448] ; 586
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1365:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1366
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1366:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1367:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1368: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1368 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1368 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1368 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1369
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1369:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1370:
	; Computing bound for 'k'
	mov rax, [rel const449] ; 353
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1371
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1371:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1372: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1372 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1372 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1372 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1372 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1373
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1373:
	cmp rax, [rsp + 16]
	jl .jump1374
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1374:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1375
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1375:
	cmp rax, [rsp + 24]
	jl .jump1376
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1376:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1377
	mov rax, [rel const450] ; 37.82
	push rax
	jmp .jump1378
.jump1377:
	mov rax, [rel const451] ; 61.85
	push rax
.jump1378:
	mov rax, [rel const452] ; 28.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1379
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1381
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1381:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1382:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1383
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1383:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1384: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const453] ; 866
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1384 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1384 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1384 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1385:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[k : g, l : e, m : (- (- g))] 866)) 
	jno .jump1386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1386:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1387: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1388
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1390
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1390:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1391:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1392
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1392:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1393:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1394:
	imul rdi, [rsp + 0 + 8] ; multiply by (- g) 
	jno .jump1395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1395:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1396:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump1397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1397:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1398: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1399:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump1400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1400:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1401: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1401 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1398 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1398 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1398 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1398 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1389
.jump1388:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1402
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1402:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1403:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1404
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1404:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1405:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1406:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1407:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1408:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump1409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1409:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1410: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1411:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump1412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1412:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1413: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1413 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1410 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1410 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1410 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1410 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1389:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1414
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1415
.jump1414:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1416
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump1416:
	push rax
	pop rax
	cmp rax, 0
	je .jump1417
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump1418
.jump1417:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump1418:
.jump1415:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1419
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1420
.jump1419:
	mov rax, [rel const454] ; 650
	push rax
.jump1420:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const455] ; 323
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1421
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1421:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1422:
	cmp rax, [rsp + 32]
	jl .jump1423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1423:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1424:
	cmp rax, [rsp + 40]
	jl .jump1425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1425:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1426:
	cmp rax, [rsp + 48]
	jl .jump1427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1427:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1428:
	cmp rax, [rsp + 56]
	jl .jump1429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1429:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1387 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump1380
.jump1379:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1430:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1431:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1432: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const456] ; 5.46
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1432 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1380:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1433
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1434
.jump1433:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1435
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1436
.jump1435:
	mov rax, [rel const457] ; 493
	push rax
.jump1436:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1437
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1437:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1438
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1438:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1439:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1440
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1440:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1441: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1441 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1441 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1441 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1442:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1443
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1443:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1444 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1444 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1444 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1434:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1445:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
imul rdi, [rsp + 0 + 0] ; multiply by (if false then b else (sum[k : f, l : (sum[k : e, l : h, m : g] b), m : (if true then b else 493)] l)) 
	jno .jump1446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1446:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1447: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1448
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1448:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump1449
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1449:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1450: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1450 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1447 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1451
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1451:
	cmp rax, [rsp + 8]
	jl .jump1452
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1452:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const458] ; 669
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1453
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1453:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const186] ; 735
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1454:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1455:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const459] ; 816
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1456:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1457: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1458
	mov rax, [rel const330] ; 747
	push rax
	jmp .jump1459
.jump1458:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump1459:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1457 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1460
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1460:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1461:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1462
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1462:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1463: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1463 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1463 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1463 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1463 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1464
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1464:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1465:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const460] ; 899
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1466:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1467
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1467:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1468
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1468:
	imul rdi, [rsp + 0 + 8] ; multiply by 899 
	jno .jump1469
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1469:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1470: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1470 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1470 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1471
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1471:
	cmp rax, [rsp + 16]
	jl .jump1472
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1472:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1473
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1473:
	cmp rax, [rsp + 24]
	jl .jump1474
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1474:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1475
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1475:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1476: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1476 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1476 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1476 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1476 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1477:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1478
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1478:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1479:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1480: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1481
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump1482
.jump1481:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1483
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1485
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1485:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1486:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1487
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1487:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1488:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump1489: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1489 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1489 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1489 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1489 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump1484
.jump1483:
	mov rax, [rel const461] ; 79.95
	push rax
.jump1484:
.jump1482:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1480 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1480 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1480 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rdi, 48
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 3
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1490:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1491
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1491:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1492:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1493
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1493:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1494: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1494 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1494 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1494 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1494 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1495:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1496
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1496:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1497:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump1498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1498:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump1499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1499:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1500:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1501: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1501 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1501 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1501 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1502
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1502:
	cmp rax, [rsp + 24]
	jl .jump1503
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1503:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1504
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1504:
	cmp rax, [rsp + 32]
	jl .jump1505
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1505:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1506
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1506:
	cmp rax, [rsp + 40]
	jl .jump1507
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1507:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1508
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump1509
.jump1508:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const462] ; 354
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1510
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1510:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1511:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1512: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1512 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1512 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1513:
	cmp rax, [rsp + 8]
	jl .jump1514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1514:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1509:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1515:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1516
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1516:
	; Computing bound for 'l'
	mov rax, [rel const324] ; 603
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1517:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1518
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1518:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1519: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1520
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump1521
.jump1520:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump1521:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1522
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1522:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1523:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1524
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1524:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1525:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1526: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1526 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1526 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1526 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1526 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1519 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1519 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1519 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1519 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1527
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1529:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1530
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1530:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump1531
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1531:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1532
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1532:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1533: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1534
	mov rax, [rel const463] ; 815
	push rax
	jmp .jump1535
.jump1534:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump1535:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1533 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1533 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1536
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump1537
.jump1536:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump1537:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1538
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1538:
	cmp rax, [rsp + 8]
	jl .jump1539
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1539:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1540
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1540:
	; Computing bound for 'k'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1541
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump1542
.jump1541:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1542:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1543:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (if false then f else b)) 
	jno .jump1544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1544:
	imul rdi, [rsp + 0 + 8] ; multiply by a[(if false then h else h)] 
	jno .jump1545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1545:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1546: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1546 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1546 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1547
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1549:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1550
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1550:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1551
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1551:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump1552
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1552:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1553: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1553 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1553 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1548
.jump1547:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1554:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1555
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1555:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1556
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1556:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1557
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1557:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1558: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1558 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1558 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1548:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1559
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1559:
	; Computing bound for 'k'
	mov rax, [rel const464] ; 828
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1560:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 828) 
	jno .jump1561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1561:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- e) - (- b)) 
	jno .jump1562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1562:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1563: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1563 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1563 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 96
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1564
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1564:
	cmp rax, [rsp + 8]
	jl .jump1565
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1565:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const338] ; 984
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1566:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1567
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1567:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- g) 
	jno .jump1568
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1568:
	imul rdi, [rsp + 0 + 8] ; multiply by 984 
	jno .jump1569
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1569:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1570: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1570 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1570 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1571:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1572
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1572:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1573: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const465] ; 529
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1573 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1573 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1574
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1574:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1575:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1576:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[k : e, l : e] 529) 
	jno .jump1577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1577:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1578: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const466] ; 45.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1579
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump1580
.jump1579:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump1580:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1578 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1578 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1581
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1582
.jump1581:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1582:
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1583
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1583:
	cmp rax, [rsp + 8]
	jl .jump1584
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1584:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const375] ; 583
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1585:
	cmp rax, [rsp + 16]
	jl .jump1586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1586:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1587:
	cmp rax, [rsp + 24]
	jl .jump1588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1588:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1589
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1589:
	cmp rax, [rsp + 16]
	jl .jump1590
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1590:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1591
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1591:
	cmp rax, [rsp + 24]
	jl .jump1592
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1592:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1593
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1593:
	cmp rax, [rsp + 16]
	jl .jump1594
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1594:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1595
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1595:
	cmp rax, [rsp + 24]
	jl .jump1596
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1596:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1528
.jump1527:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const467] ; 165
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1597
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1597:
	; Computing bound for 'k'
	mov rax, [rel const468] ; 80.59
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1598
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1599
.jump1598:
	mov rax, [rel const261] ; 681
	push rax
.jump1599:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1600:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if i(80.59) then (- g) else 681) 
	jno .jump1601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1601:
	imul rdi, [rsp + 0 + 8] ; multiply by 165 
	jno .jump1602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1602:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1603: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1603 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1603 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1604:
	cmp rax, [rsp + 16]
	jl .jump1605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1605:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1606:
	cmp rax, [rsp + 24]
	jl .jump1607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1607:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1608:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1609
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1609:
	; Computing bound for 'k'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const363] ; 191
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1610:
	cmp rax, [rsp + 8]
	jl .jump1611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1611:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1612
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump1613
.jump1612:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1614:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1615:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1616: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1616 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1617:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1618
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1618:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1619:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1620: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1620 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1620 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1620 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1621
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1621:
	cmp rax, [rsp + 8]
	jl .jump1622
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1622:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1613:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1623
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1623:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1624
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1624:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1625:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1626: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump1627
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
.jump1627:
	push rax
	pop rax
	cmp rax, 0
	je .jump1628
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump1629
.jump1628:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump1629:
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1626 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1626 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1626 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1528:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1630
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1630:
	cmp rax, [rsp + 8]
	jl .jump1631
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1631:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const469] ; 'o'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1632:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1633
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1635
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1635:
	; Computing bound for 'o'
	mov rax, [rel const462] ; 354
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1636:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 354 
	jno .jump1637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1637:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1638:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1639: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1639 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1639 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1634
.jump1633:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const470] ; 646
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1640
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1640:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1641:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1642:
	imul rdi, [rsp + 0 + 8] ; multiply by 646 
	jno .jump1643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1643:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1644: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1644 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1644 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1634:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1645:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1646
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const471] ; 468
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1648
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1648:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1649:
	; Computing bound for 'p'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1650
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1651
.jump1650:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
.jump1651:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1652
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1652:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1653:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1654: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1655:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1656
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1656:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1657: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1657 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1657 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1654 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1654 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1654 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1654 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump1647
.jump1646:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1658
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1658:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1659
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1659:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1660:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1661
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1661:
	; Computing bound for 'o'
	mov rax, [rel const346] ; 378
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1662:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1663: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1664
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump1665
.jump1664:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
.jump1665:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1663 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1663 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1663 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1663 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump1647:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1666:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1667
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1667:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1668:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1669: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1669 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1669 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1669 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1670:
	cmp rax, [rsp + 16]
	jl .jump1671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1671:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1672:
	cmp rax, [rsp + 24]
	jl .jump1673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1673:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1674:
	; Computing bound for 'q'
	mov rax, [rel const377] ; 5
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1675
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1675:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1676:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1677
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1677:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1678: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1679
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1681
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1682
	mov rax, [rel const1] ; False
	push rax
	jmp .jump1683
.jump1682:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const472] ; 27.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump1683:
	pop rax
.jump1681:
	push rax
	jmp .jump1680
.jump1679:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump1680:
	pop rax
	cmp rax, 0
	je .jump1684
	mov rax, [rel const11] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1686
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump1687
.jump1686:
	mov rax, [rel const1] ; False
	push rax
.jump1687:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1688
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1690
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1690:
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1691
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1691:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1692:
	; Computing bound for 't'
	mov rax, [rel const473] ; 785
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1693
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1693:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1694
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1694:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1695:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1696
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1696:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1697:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1698: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1698 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1698 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1698 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1698 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1699:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1700: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1700 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1700 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1700 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1700 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1701:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1702
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1702:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1703
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1703:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[s : (sum[s : f, t : q, u : n, v : h] t), t : 785, u : o, v : g] (v - r)) 
	jno .jump1704
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1704:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1705
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1705:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1706: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const474] ; 253
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1706 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1706 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1706 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1689
.jump1688:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1707
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const475] ; 93
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1709
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1709:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1710:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1711
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1711:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump1712
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1712:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump1713
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1713:
	imul rdi, [rsp + 0 + 16] ; multiply by 93 
	jno .jump1714
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1714:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1715: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1715 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1715 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1715 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1708
.jump1707:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1716
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1718
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1718:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1719:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1720
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1720:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump1721
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1721:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1722
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1722:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump1723
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1723:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1724 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1724 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1724 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1717
.jump1716:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1725
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1725:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1726:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1727
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1727:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1728
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1728:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1729
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1729:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump1730
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1730:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1731: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1731 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1731 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1731 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1717:
.jump1708:
.jump1689:
	jmp .jump1685
.jump1684:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1732
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1734
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1736
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1736:
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1737
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1737:
	; Computing bound for 's'
	mov rax, [rel const476] ; 304
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1738:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1739: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1739 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1739 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1740:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1741
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1741:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1742
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1742:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[s : 304, t : n] t) 
	jno .jump1743
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1743:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump1744
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1744:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1745: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1745 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1745 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1745 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1735
.jump1734:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1746
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1746:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1747:
	; Computing bound for 's'
	mov rax, [rel const477] ; 359
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1748
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1748:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 359 
	jno .jump1749
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1749:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump1750
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1750:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump1751
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1751:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1752: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const442] ; 601
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1752 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1752 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1752 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1735:
	jmp .jump1733
.jump1732:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1753
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1753:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1754:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1755
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1755:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1756:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1757: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const478] ; 455
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1757 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1757 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1757 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1757 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1758:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1759: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1759 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1760
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1760:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1761:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1762
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1762:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump1763
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1763:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1764
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1764:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[s : (sum[s : h, t : e, u : p, v : o] 455)] q) 
	jno .jump1765
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1765:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1766: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1766 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1766 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1766 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1733:
.jump1685:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1767:
	cmp rax, [rsp + 24]
	jl .jump1768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1768:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1769:
	cmp rax, [rsp + 32]
	jl .jump1770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1770:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1771:
	cmp rax, [rsp + 40]
	jl .jump1772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1772:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1678 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1678 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1678 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1678 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1773:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1774
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1774:
	; Computing bound for 'o'
	mov rax, [rel const479] ; 898
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1775:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1776: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const480] ; 12.01
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1776 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1776 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1776 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1777
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1779
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1779:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1780:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1781:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1782:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1783: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1783 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1783 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1778
.jump1777:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const481] ; 714
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1784
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1784:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1785:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1786:
	imul rdi, [rsp + 0 + 8] ; multiply by (714 - n) 
	jno .jump1787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1787:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1788: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1788 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1788 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1778:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1789
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1791
	mov rax, [rel const118] ; 656
	push rax
	jmp .jump1792
.jump1791:
	mov rax, [rel const343] ; 999
	push rax
.jump1792:
	jmp .jump1790
.jump1789:
	mov rax, [rel const482] ; 199
	push rax
.jump1790:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1793:
	cmp rax, [rsp + 16]
	jl .jump1794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1794:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1795:
	cmp rax, [rsp + 24]
	jl .jump1796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1796:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1797
	mov rax, [rel const11] ; True
	push rax
	jmp .jump1798
.jump1797:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const483] ; 70.35
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
.jump1798:
	pop rax
	cmp rax, 0
	je .jump1799
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1801:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1802
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1802:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1803
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1803:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump1804
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1804:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1805: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1805 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1805 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1800
.jump1799:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1806:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1807:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1808
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1808:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1809: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1809 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1809 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1810
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1810:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : l, p : e] g) 
	jno .jump1811
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1811:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump1812
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1812:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1813: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1813 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1813 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1800:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1814
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1814:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1815:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1816
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1816:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1817:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1818: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1818 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1818 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1818 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1818 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1819
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1819:
	cmp rax, [rsp + 16]
	jl .jump1820
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1820:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1821
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1821:
	cmp rax, [rsp + 24]
	jl .jump1822
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1822:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1823
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1825
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1825:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1826: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1827:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1828: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1828 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const484] ; 26.44
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1826 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1829
	mov rax, [rel const392] ; 237
	push rax
	jmp .jump1830
.jump1829:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1830:
	jmp .jump1824
.jump1823:
	mov rax, [rel const136] ; 108
	push rax
.jump1824:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	add rsp, 40 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1831
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1831:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1832
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1832:
	; Computing bound for 'q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1833
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1833:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1834:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1835
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1835:
	; Computing bound for 'o'
	mov rax, [rel const485] ; 96
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1836:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 96 
	jno .jump1837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1837:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1838:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump1839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1839:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump1840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1840:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1841: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const357] ; 846
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1842:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1841 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1841 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1841 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1841 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1843:
	cmp rax, [rsp + 32]
	jl .jump1844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1844:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1845:
	cmp rax, [rsp + 40]
	jl .jump1846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1846:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1847:
	cmp rax, [rsp + 48]
	jl .jump1848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1848:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1849:
	cmp rax, [rsp + 56]
	jl .jump1850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1850:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1851
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1851:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1852:
	; Computing bound for 'p'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const486] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1853:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1854
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1854:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1855
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1855:
	imul rdi, [rsp + 0 + 8] ; multiply by 396 
	jno .jump1856
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1856:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1857: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1858
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump1859
.jump1858:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1859:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1857 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1857 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1860:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1861
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1861:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1862:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump1863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1863:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump1864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1864:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1865:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1866: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1866 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1866 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1866 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1867
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1867:
	cmp rax, [rsp + 24]
	jl .jump1868
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1868:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1869
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1869:
	cmp rax, [rsp + 32]
	jl .jump1870
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1870:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1871
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1871:
	cmp rax, [rsp + 40]
	jl .jump1872
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1872:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1873
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1873:
	cmp rax, [rsp + 16]
	jl .jump1874
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1874:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1875
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1875:
	cmp rax, [rsp + 24]
	jl .jump1876
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1876:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1877
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1877:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1878:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1879: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const85] ; 769
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1880:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1881
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1881:
	; Computing bound for 's'
	mov rax, [rel const166] ; 126
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1882:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 126 
	jno .jump1883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1883:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump1884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1884:
	imul rdi, [rsp + 0 + 16] ; multiply by 769 
	jno .jump1885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1885:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1886: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1886 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1886 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1886 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1887
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1887:
	cmp rax, [rsp + 24]
	jl .jump1888
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1888:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1889
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1889:
	cmp rax, [rsp + 32]
	jl .jump1890
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1890:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1891
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1891:
	cmp rax, [rsp + 40]
	jl .jump1892
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1892:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1893
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const275] ; 715
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1895:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 715 
	jno .jump1896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1896:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump1897: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1897 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump1894
.jump1893:
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1894:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1898
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1898:
	cmp rax, [rsp + 8]
	jl .jump1899
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1899:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1879 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1879 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1879 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1879 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1900:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1901: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1901 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1901 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1902:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1903
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1903:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1904
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1904:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1905:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1906
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1906:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1907: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1907 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1907 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1907 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1908:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1909
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1909:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1910
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1910:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1911: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1911 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1912:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : n] h) 
	jno .jump1913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1913:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump1914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1914:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[o : f, p : (- h), q : h] l) 
	jno .jump1915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1915:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1916: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1916 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1916 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1916 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1917
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1917:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1918:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1919:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1920:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1921: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1921 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1921 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1922
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1922:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1923:
	cmp rax, [rsp + 16]
	jl .jump1924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1924:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1925:
	cmp rax, [rsp + 24]
	jl .jump1926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1926:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1927:
	; Computing bound for 'p'
	mov rax, [rel const487] ; 132
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1928
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1928:
	; Computing bound for 'o'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1929:
	cmp rax, [rsp + 8]
	jl .jump1930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1930:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1931:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a[h] 
	jno .jump1932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1932:
	imul rdi, [rsp + 0 + 8] ; multiply by 132 
	jno .jump1933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1933:
imul rdi, [rsp + 0 + 16] ; multiply by (array[o : f, p : b] f)[(g % f), g] 
	jno .jump1934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1934:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1935: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const488] ; 921
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1936
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1936:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump1937: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1937 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1935 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1935 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1935 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1938:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1939
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1939:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1940:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1941:
	imul rdi, [rsp + 0 + 8] ; multiply by (- h) 
	jno .jump1942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1942:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump1943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1943:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1944: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const463] ; 815
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1944 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1944 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1944 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1945
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1945:
	cmp rax, [rsp + 24]
	jl .jump1946
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1946:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1947
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1947:
	cmp rax, [rsp + 32]
	jl .jump1948
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1948:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1949
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1949:
	cmp rax, [rsp + 40]
	jl .jump1950
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1950:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1951
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1951:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1952
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1952:
	cmp rax, [rsp + 24]
	jl .jump1953
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1953:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1954
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1954:
	cmp rax, [rsp + 32]
	jl .jump1955
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1955:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1956
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1956:
	cmp rax, [rsp + 40]
	jl .jump1957
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1957:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1958
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1958:
	cmp rax, [rsp + 24]
	jl .jump1959
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1959:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1960
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1960:
	cmp rax, [rsp + 32]
	jl .jump1961
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1961:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1962
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1962:
	cmp rax, [rsp + 40]
	jl .jump1963
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1963:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1964:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by ((array[o : (sum[o : n] h), p : n, q : (sum[o : f, p : (- h), q : h] l)] g)[(- n), (- h), (array[o : a[h], p : 132, q : (array[o : f, p : b] f)[(g % f), g]] (sum[r : 921] (- p)))[(- n), (h + (e % (h - h))), (array[o : l, p : (- h), q : (- b)] 815)[n, l, f]]] * h) 
	jno .jump1965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1965:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump1966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1966:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[o : (sum[o : h, p : (array[o : l, p : 396] ((- l) + (if true then p else l)))[l, ((array[o : e, p : e, q : h] p)[(- h), l, e] + h)], q : (e / (array[o : 96, p : h, q : l, r : e] (l / 846))[g, b, l, (- e)]), r : b] (if (array[s : 126, t : l, u : 769] false)[p, (o - r), q] then (array[s : 715] l) else a)[f]), p : (b + (- e))] (e - o)) 
	jno .jump1967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1967:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1968: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1968 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1968 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1968 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const489] ; 278
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1969
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1969:
	cmp rax, [rsp + 24]
	jl .jump1970
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1970:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1971
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1971:
	cmp rax, [rsp + 32]
	jl .jump1972
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1972:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1973
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1973:
	cmp rax, [rsp + 40]
	jl .jump1974
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1974:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1975
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump1977
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1979
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1979:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1980:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1981
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1981:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1982:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1983:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump1984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1984:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump1985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1985:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump1986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1986:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1987: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const490] ; 76.2
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1987 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1987 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1987 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1987 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1978
.jump1977:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1988
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1988:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1989:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1990:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1991
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1991:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1992:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump1993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1993:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- l) / s) 
	jno .jump1994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1994:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump1995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1995:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump1996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1996:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1997: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const491] ; 59.18
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1997 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1997 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1997 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1997 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1978:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1998:
	; Computing bound for 'x'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1999:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2000
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2000:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2001:
	; Computing bound for 'v'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2002
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2002:
	cmp rax, [rsp + 8]
	jl .jump2003
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2003:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2004
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2004:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2005: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2005 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2005 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2005 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2005 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2006
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2006:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2007:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2008
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2008:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2009
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2009:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2010
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2010:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[v : a[f], w : q, x : (- t), y : s] q) 
	jno .jump2011
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2011:
	imul rdi, [rsp + 0 + 24] ; multiply by (- (s + l)) 
	jno .jump2012
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2012:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2013: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const492] ; 679
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2013 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2013 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2013 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2013 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2014
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2014:
	cmp rax, [rsp + 32]
	jl .jump2015
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2015:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2016
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2016:
	cmp rax, [rsp + 40]
	jl .jump2017
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2017:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2018
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2018:
	cmp rax, [rsp + 48]
	jl .jump2019
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2019:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2020
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2020:
	cmp rax, [rsp + 56]
	jl .jump2021
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2021:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2022
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2022:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2023:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2024
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2024:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2025:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2026:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2027:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2028:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump2029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2029:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2030: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2030 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2030 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2030 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2030 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const493] ; 585
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2031:
	cmp rax, [rsp + 32]
	jl .jump2032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2032:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2033:
	cmp rax, [rsp + 40]
	jl .jump2034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2034:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2035:
	cmp rax, [rsp + 48]
	jl .jump2036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2036:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2037:
	cmp rax, [rsp + 56]
	jl .jump2038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2038:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2039:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2040
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2040:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2041:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2042
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2042:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2043: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2043 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2043 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2043 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2043 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2044
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump2044:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2045:
	cmp rax, [rsp + 32]
	jl .jump2046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2046:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2047:
	cmp rax, [rsp + 40]
	jl .jump2048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2048:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2049:
	cmp rax, [rsp + 48]
	jl .jump2050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2050:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2051:
	cmp rax, [rsp + 56]
	jl .jump2052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2052:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1976
.jump1975:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2053
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump2054
.jump2053:
	mov rax, [rel const494] ; 27.92
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2054:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2055
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2056
.jump2055:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2057:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2058
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2058:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2059:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- g) 
	jno .jump2060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2060:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2061:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2062:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2063: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const495] ; 74.91
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 16], 1
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2063 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2063 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2063 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2064
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2064:
	cmp rax, [rsp + 24]
	jl .jump2065
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2065:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2066
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2066:
	cmp rax, [rsp + 32]
	jl .jump2067
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2067:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2068
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2068:
	cmp rax, [rsp + 40]
	jl .jump2069
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2069:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2056:
.jump1976:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	add rsp, 96 ; Local variables
	pop rbp
	ret

l:
_l:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2070:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2071:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2072: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2073
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump2074
.jump2073:
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
.jump2074:
	pop rax
	cmp rax, 0
	je .jump2075
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump2076
.jump2075:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2076:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2077:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2078: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2078 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2072 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2079:
	; Computing bound for 'p'
	mov rax, [rel const182] ; 324
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2080
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2080:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2081: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2081 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2081 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2082
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2082:
	cmp rax, [rsp + 8]
	jl .jump2083
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2083:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2084
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2084:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2085
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2085:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2086:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2087
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2087:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2088: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2089:
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2090:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2091
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2091:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2092
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2092:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2093:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump2094: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2094 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2094 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2095:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump2096: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2097
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump2097:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2096 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2096 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2096 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2098
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2098:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2099:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2100
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2100:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump2101: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2101 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2101 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2101 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2101 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2088 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2088 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2088 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2102:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2103
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2103:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2104
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2104:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2105:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2106: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2107
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2108
.jump2107:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2108:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2109
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2109:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2110: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2110 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2111:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2112
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2112:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2113: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2113 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2113 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2114
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2114:
	cmp rax, [rsp + 16]
	jl .jump2115
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2115:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2116
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2116:
	cmp rax, [rsp + 24]
	jl .jump2117
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2117:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2118
	mov rax, [rel const165] ; 169
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2120
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump2120:
	push rax
	pop rax
	cmp rax, 0
	je .jump2121
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2123
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const496] ; 15.47
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2124
.jump2123:
	mov rax, [rel const497] ; 93.78
	push rax
	mov rax, [rel const498] ; 68.25
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump2124:
	jmp .jump2122
.jump2121:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2125
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump2126
.jump2125:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
.jump2126:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
.jump2122:
	pop rax
	cmp rax, 0
	je .jump2127
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2129:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2130
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump2131
.jump2130:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
.jump2131:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2132:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2133
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2133:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if true then q else o) / e) 
	jno .jump2134
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2134:
	imul rdi, [rsp + 0 + 8] ; multiply by (- b) 
	jno .jump2135
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2135:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2136: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2136 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2136 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2128
.jump2127:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2137
	mov rax, [rel const499] ; 151
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump2137:
	push rax
	pop rax
	cmp rax, 0
	je .jump2138
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2140:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2141
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2141:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2142
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2142:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2143
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2143:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2144: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2144 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2144 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2139
.jump2138:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2145:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2146
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2146:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2147
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2147:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2148
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2148:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2149: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2150
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2150:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2151:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2152
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2152:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2153:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2154: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2154 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2154 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2154 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2154 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2149 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2149 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2139:
.jump2128:
	jmp .jump2119
.jump2118:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const500] ; 118
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2155:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2156
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2156:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2157
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2157:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2158: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2159
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2160
.jump2159:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
.jump2160:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2158 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2161:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2162
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2162:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2163
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2163:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[r : h] (if false then n else o)) 
	jno .jump2164
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2164:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump2165
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2165:
	imul rdi, [rsp + 0 + 24] ; multiply by 118 
	jno .jump2166
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2166:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2167: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	mov rax, [rel const501] ; 538
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2168
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2168:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2169:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2170:
	imul rdi, [rsp + 0 + 8] ; multiply by 538 
	jno .jump2171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2171:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2172: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2172 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2172 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2167 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2167 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2167 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2167 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2173
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2173:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2174
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2174:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2175: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2175 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2176:
	cmp rax, [rsp + 8]
	jl .jump2177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2177:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const502] ; 341
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2178
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2178:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2179:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump2180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2180:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2181:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2182: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 8], 1
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2182 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2182 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2183:
	cmp rax, [rsp + 16]
	jl .jump2184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2184:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2185:
	cmp rax, [rsp + 24]
	jl .jump2186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2186:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const503] ; 476
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2187
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2187:
	cmp rax, [rsp + 32]
	jl .jump2188
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2188:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2189
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2189:
	cmp rax, [rsp + 40]
	jl .jump2190
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2190:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2191
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2191:
	cmp rax, [rsp + 48]
	jl .jump2192
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2192:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2193
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2193:
	cmp rax, [rsp + 56]
	jl .jump2194
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2194:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2119:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2195
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2195:
	cmp rax, [rsp + 16]
	jl .jump2196
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2196:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2197
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2197:
	cmp rax, [rsp + 24]
	jl .jump2198
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2198:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2106 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2106 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2199:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2200: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2200 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2200 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2200 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2200 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1] ; False
	push rax
	pop rax
	add rsp, 8 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2201
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump2201:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2202:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (n / n) 
	jno .jump2203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2203:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2204: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2205
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2206
.jump2205:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2206:
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2207
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2209
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2209:
	; Computing bound for 's'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2210:
	cmp rax, [rsp + 8]
	jl .jump2211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2211:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2212:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2213
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2213:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2214
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2214:
	imul rdi, [rsp + 0 + 8] ; multiply by a[b] 
	jno .jump2215
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2215:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump2216
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2216:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2217: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2218:
	; Computing bound for 'v'
	mov rax, [rel const504] ; 21
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2219
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2219:
	; Computing bound for 'u'
	mov rax, [rel const470] ; 646
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2220:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 646 
	jno .jump2221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2221:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 21) 
	jno .jump2222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2222:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2223:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump2224: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2224 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2224 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2224 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2217 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2217 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2217 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2208
.jump2207:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2225
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2225:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2226:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2227:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2228
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2228:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2229:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2230: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2230 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2230 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2230 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2231
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2231:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[r : f, s : q, t : o] e)) 
	jno .jump2232
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2232:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2233
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2233:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2234
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2234:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2235: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2236:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2237
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2237:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2238:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2239:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2240:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2241:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump2242: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2242 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2242 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2242 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2235 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2235 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2235 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2208:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2204 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2243
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2243:
	cmp rax, [rsp + 8]
	jl .jump2244
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2244:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2245
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2245:
	cmp rax, [rsp + 24]
	jl .jump2246
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2246:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2247
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2247:
	cmp rax, [rsp + 32]
	jl .jump2248
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2248:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2249
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2249:
	cmp rax, [rsp + 40]
	jl .jump2250
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2250:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const147] ; 728
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2251
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2251:
	cmp rax, [rsp + 24]
	jl .jump2252
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2252:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2253
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2253:
	cmp rax, [rsp + 32]
	jl .jump2254
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2254:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2255
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2255:
	cmp rax, [rsp + 40]
	jl .jump2256
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2256:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 8 ; Local variables
	pop rbp
	ret
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	mov rax, [rel const362] ; 477
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2257
	mov rax, [rel const505] ; 17.31
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	mov rax, [rel const126] ; 168
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2259
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2259:
	; Computing bound for 'v'
	mov rax, [rel const164] ; 115
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2260:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2261
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2261:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2262:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2263: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const506] ; 51.73
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2263 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2263 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2263 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2263 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2264:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2265: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const507] ; 47.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2265 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const508] ; 50.65
	push rax
	mov rax, [rel const509] ; 63.63
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2266
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2266:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump2267
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2267:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2268: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	mov rax, [rel const278] ; 959
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2269:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2270
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2270:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2271:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2272
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2272:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2273
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2273:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2274
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2274:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump2275
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2275:
	imul rdi, [rsp + 0 + 24] ; multiply by 959 
	jno .jump2276
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2276:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump2277: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const510] ; 78.62
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2277 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2277 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2277 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2277 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2268 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2278:
	cmp rax, [rsp + 8]
	jl .jump2279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2279:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2280:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2281: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2281 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2282:
	cmp rax, [rsp + 32]
	jl .jump2283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2283:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2284:
	cmp rax, [rsp + 40]
	jl .jump2285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2285:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2286:
	cmp rax, [rsp + 48]
	jl .jump2287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2287:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2288:
	cmp rax, [rsp + 56]
	jl .jump2289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2289:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2258
.jump2257:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2290
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2291:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2292
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2292:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2293
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2293:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2294
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2294:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2295: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2295 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2295 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const511] ; 172
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2296
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump2296:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2297
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2297:
	cmp rax, [rsp + 16]
	jl .jump2298
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2298:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2299
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2299:
	cmp rax, [rsp + 24]
	jl .jump2300
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2300:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump2290:
	push rax
.jump2258:
	pop rax
	cmp rax, 0
	je .jump2301
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2302
.jump2301:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2303:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2304
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2304:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2305
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2305:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2306
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2306:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2307: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2308
	mov rax, [rel const512] ; 48.84
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const513] ; 1.03
	push rax
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	jmp .jump2309
.jump2308:
	mov rax, [rel const11] ; True
	push rax
.jump2309:
	pop rax
	cmp rax, 0
	je .jump2310
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2312
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2312:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2313
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2313:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2314: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2314 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2315:
	cmp rax, [rsp + 8]
	jl .jump2316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2316:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2317:
	cmp rax, [rsp + 16]
	jl .jump2318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2318:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2319:
	cmp rax, [rsp + 24]
	jl .jump2320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2320:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2311
.jump2310:
	mov rax, [rel const1] ; False
	push rax
.jump2311:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2307 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2307 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2302:
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump2321
	lea rdi, [rel const514] ; 't'
	call _fail_assertion
.jump2321:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2322
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2322:
	; Computing bound for 'u'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2323
	mov rax, [rel const162] ; 954
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2325
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump2325:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const260] ; 356
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2326
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2327:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2328
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2328:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2329:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2330: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2330 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2330 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2330 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
.jump2326:
	push rax
	jmp .jump2324
.jump2323:
	mov rax, [rel const1] ; False
	push rax
.jump2324:
	pop rax
	cmp rax, 0
	je .jump2331
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2332
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump2333
.jump2332:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2334
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump2335
.jump2334:
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
.jump2335:
.jump2333:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2336
	mov rax, [rel const1] ; False
	push rax
	jmp .jump2337
.jump2336:
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
.jump2337:
	pop rax
	cmp rax, 0
	je .jump2338
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2339
.jump2338:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
.jump2339:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2340
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump2341
.jump2340:
	mov rax, [rel const515] ; 890
	push rax
.jump2341:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2342:
	cmp rax, [rsp + 32]
	jl .jump2343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2343:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2344:
	cmp rax, [rsp + 40]
	jl .jump2345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2345:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2346:
	cmp rax, [rsp + 48]
	jl .jump2347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2347:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2348:
	cmp rax, [rsp + 56]
	jl .jump2349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2349:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump2331:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2350
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump2351
.jump2350:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const516] ; 964
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump2351:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2352:
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2353
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2353:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2354
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2354:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2355: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2356
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2356:
	cmp rax, [rsp + 16]
	jl .jump2357
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2357:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2358
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2358:
	cmp rax, [rsp + 24]
	jl .jump2359
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2359:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2355 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2360:
	cmp rax, [rsp + 8]
	jl .jump2361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2361:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2362
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2364:
	; Computing bound for 'u'
	mov rax, [rel const406] ; 265
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2365
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2365:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2366:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2367:
	imul rdi, [rsp + 0 + 8] ; multiply by 265 
	jno .jump2368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2368:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2369:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2370: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2370 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2370 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2370 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2371
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2371:
	cmp rax, [rsp + 24]
	jl .jump2372
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2372:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2373
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2373:
	cmp rax, [rsp + 32]
	jl .jump2374
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2374:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2375
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2375:
	cmp rax, [rsp + 40]
	jl .jump2376
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2376:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2377
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2377:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2378:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2379:
imul rdi, [rsp + 0 + 8] ; multiply by (array[t : s, u : 265, v : p] o)[n, e, r] 
	jno .jump2380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2380:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2381: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2382
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2384:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2385
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2385:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump2386
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2386:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2387
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2387:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2388: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const79] ; 741
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2388 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2388 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2383
.jump2382:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2389:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2390
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2390:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2391
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2391:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2392
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2392:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2393: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2393 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2393 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2383:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2381 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2381 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	mov rax, [rel const517] ; 562
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2394
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2394:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2395:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2396
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2396:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2397:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2398: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2398 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2398 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2398 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2398 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const518] ; 487
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2399:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2400
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2400:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2401:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2402: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2402 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2402 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2402 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2403
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2403:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2404:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2405
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2405:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2406
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2406:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2407
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2407:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2408
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2408:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2409: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2409 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2409 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2409 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2410:
	cmp rax, [rsp + 24]
	jl .jump2411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2411:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2412:
	cmp rax, [rsp + 32]
	jl .jump2413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2413:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2414:
	cmp rax, [rsp + 40]
	jl .jump2415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2415:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2416:
	cmp rax, [rsp + 8]
	jl .jump2417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2417:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2418:
	cmp rax, [rsp + 16]
	jl .jump2419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2419:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2420:
	cmp rax, [rsp + 24]
	jl .jump2421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2421:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2363
.jump2362:
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2422
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2424
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2424:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2425:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2426
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2426:
	; Computing bound for 't'
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2427:
	cmp rax, [rsp + 8]
	jl .jump2428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2428:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2429:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j[k] 
	jno .jump2430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2430:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump2431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2431:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2432:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump2433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2433:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2434: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2435:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2436
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2436:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump2437
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2437:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2438
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2438:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2439: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2439 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2439 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2434 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2434 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2434 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2434 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2423
.jump2422:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2440
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2440:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2441:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2442
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2442:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2443:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2444:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2445:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump2446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2446:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump2447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2447:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2448: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2449:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2450
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2450:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump2451
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2451:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2452
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2452:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2453: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2453 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2453 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2448 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2448 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2448 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2448 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2423:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2454
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump2455
.jump2454:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump2455:
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2456
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2456:
	cmp rax, [rsp + 8]
	jl .jump2457
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2457:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2458
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2458:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2459:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2460:
	imul rdi, [rsp + 0 + 8] ; multiply by (p - r) 
	jno .jump2461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2461:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2462: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2462 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2462 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2463:
	cmp rax, [rsp + 16]
	jl .jump2464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2464:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2465:
	cmp rax, [rsp + 24]
	jl .jump2466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2466:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2467:
	cmp rax, [rsp + 32]
	jl .jump2468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2468:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2469:
	cmp rax, [rsp + 40]
	jl .jump2470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2470:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2471:
	cmp rax, [rsp + 48]
	jl .jump2472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2472:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2473:
	cmp rax, [rsp + 56]
	jl .jump2474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2474:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2363:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2475:
	cmp rax, [rsp + 16]
	jl .jump2476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2476:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2477:
	cmp rax, [rsp + 24]
	jl .jump2478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2478:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2479:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2480
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2480:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2481:
	; Computing bound for 't'
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2482
	mov rax, [rel const519] ; 36.28
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2483
.jump2482:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump2483:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2484
	mov rax, [rel const11] ; True
	push rax
	jmp .jump2485
.jump2484:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2486
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2487
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2487:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2488: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const520] ; 89.32
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2488 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump2486:
	push rax
.jump2485:
	pop rax
	cmp rax, 0
	je .jump2489
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2491
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2493:
	; Computing bound for 'v'
	mov rax, [rel const521] ; 8.86
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2494
	mov rax, [rel const522] ; 655
	push rax
	jmp .jump2495
.jump2494:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump2495:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2496
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2496:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2497:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2498
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2498:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump2499
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2499:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2500
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2500:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (c != 8.86) then 655 else g) 
	jno .jump2501
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2501:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump2502
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2502:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2503: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2503 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2503 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2503 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2503 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2492
.jump2491:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2504:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2505
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2505:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2506
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2506:
	cmp rax, [rsp + 8]
	jl .jump2507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2507:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2508:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2509
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2509:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2510
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2510:
	imul rdi, [rsp + 0 + 8] ; multiply by [b, r][(- e)] 
	jno .jump2511
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2511:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump2512
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2512:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump2513
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2513:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2514: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2514 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2514 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2514 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2514 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2492:
	jmp .jump2490
.jump2489:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2515
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2515:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2516:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2517
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2517:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2518:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2519:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2520:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2521:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump2522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2522:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2523: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2523 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2523 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2523 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2523 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const523] ; 52
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2524:
	cmp rax, [rsp + 32]
	jl .jump2525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2525:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2526:
	cmp rax, [rsp + 40]
	jl .jump2527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2527:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2528:
	cmp rax, [rsp + 48]
	jl .jump2529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2529:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2530:
	cmp rax, [rsp + 56]
	jl .jump2531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2531:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2532:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2533
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2533:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2534:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2535:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump2536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2536:
imul rdi, [rsp + 0 + 16] ; multiply by (array[t : b, u : k, v : g, w : n] g)[52, o, n, e] 
	jno .jump2537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2537:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2538: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const524] ; 992
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2539
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2541
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2541:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2542:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2543
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2543:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2544:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2545:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2546:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump2547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2547:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump2548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2548:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump2549: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2549 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2549 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2549 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2549 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2540
.jump2539:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2550
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2550:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2551:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2552
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2552:
	; Computing bound for 'w'
	mov rax, [rel const423] ; 47
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2553:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 47 
	jno .jump2554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2554:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2555:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump2556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2556:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump2557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2557:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump2558: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2558 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2558 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2558 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2558 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2540:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2538 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2538 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2538 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2559:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2560
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2560:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump2561
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2561:
	imul rdi, [rsp + 0 + 8] ; multiply by (- p) 
	jno .jump2562
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2562:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2563: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2563 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2563 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2564
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2564:
	cmp rax, [rsp + 16]
	jl .jump2565
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2565:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2566
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2566:
	cmp rax, [rsp + 24]
	jl .jump2567
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2567:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2568
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2568:
	cmp rax, [rsp + 24]
	jl .jump2569
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2569:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2570
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2570:
	cmp rax, [rsp + 32]
	jl .jump2571
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2571:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2572
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2572:
	cmp rax, [rsp + 40]
	jl .jump2573
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2573:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2490:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2574:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2575
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2575:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2576:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2577: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2577 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2577 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2577 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2578
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2578:
	cmp rax, [rsp + 32]
	jl .jump2579
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2579:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2580
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2580:
	cmp rax, [rsp + 40]
	jl .jump2581
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2581:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2582
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2582:
	cmp rax, [rsp + 48]
	jl .jump2583
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2583:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2584
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2584:
	cmp rax, [rsp + 56]
	jl .jump2585
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2585:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2586
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2586:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2587: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2587 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2587 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2587 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2587 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2588
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2588:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[t : (if (if ((if true then (c == 36.28) else (n < s)) != l(m)) then true else ((k < g) || i((sum[t : e] 89.32)))) then (if l(m) then (array[t : e, u : n, v : (if (c != 8.86) then 655 else g), w : k] g) else (array[t : b, u : [b, r][(- e)], v : e, w : n] s)) else (array[t : b, u : g, v : (array[t : b, u : k, v : g, w : n] g)[52, o, n, e]] (if (t <= 992) then (array[w : f, x : e, y : e, z : g] n) else (array[w : 47, x : s, y : r, z : e] t)))[(array[t : e, u : (- p)] (- u))[o, o], h, b])[f, p, (sum[t : h, u : g, v : h] k), p], u : f, v : k, w : (if (array[t : o] (! q[f, f]))[b] then (array[t : r, u : (array[t : s, u : 265, v : p] o)[n, e, r]] (if i(c) then (array[v : p, w : h] 741) else (array[v : h, w : f] p)))[[(sum[t : o, u : h, v : 487] h), (sum[t : e, u : b, v : s, w : 562] v), g, p][(array[t : r, u : b, v : b] p)[k, k, b]], s] else (if l(m) then (array[t : j[k], u : r, v : p, w : b] (array[x : u, y : h] u)) else (array[t : n, u : e, v : r, w : o] (array[x : u, y : e] k)))[(array[t : h, u : (p - r)] t)[f, k], a[n], (if true then e else h), n])[h, s]] w) 
	jno .jump2589
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2589:
imul rdi, [rsp + 0 + 8] ; multiply by (if (! ((if true then ((356 == (f % 954)) || ((sum[t : g, u : k, v : b] n) > b)) else false) && (if (! true) then d else (if (e != b) then d else d))[(if l(q) then p else 890), p, r, (if (if true then false else l(q)) then n else o)])) then g else (964 * e)) 
	jno .jump2590
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2590:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2591
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2591:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump2592: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2592 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2592 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2592 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const525] ; 28.6
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump2593
	mov rax, [rel const526] ; 80.76
	push rax
	mov rax, [rel const527] ; 93.04
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2595
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2597
	mov rax, [rel const1] ; False
	push rax
	jmp .jump2598
.jump2597:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2599:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2600:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2601: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2601 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2602
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2602:
	cmp rax, [rsp + 8]
	jl .jump2603
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2603:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2604
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2604:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2605:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2606
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2606:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2607:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2608: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2608 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2608 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2608 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2608 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2609:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2610
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2610:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2611:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2612
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2612:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2613
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2613:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump2614
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2614:
	imul rdi, [rsp + 0 + 16] ; multiply by (- p) 
	jno .jump2615
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2615:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump2616
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2616:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2617: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2617 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2617 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2617 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2617 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const528] ; 152
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2618
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2618:
	cmp rax, [rsp + 32]
	jl .jump2619
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2619:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2620
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2620:
	cmp rax, [rsp + 40]
	jl .jump2621
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2621:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2622
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2622:
	cmp rax, [rsp + 48]
	jl .jump2623
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2623:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2624
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2624:
	cmp rax, [rsp + 56]
	jl .jump2625
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2625:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump2598:
	jmp .jump2596
.jump2595:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	mov rax, [rel const529] ; 63.25
	push rax
	mov rax, [rel const530] ; 51.61
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const531] ; 26.54
	push rax
	mov rax, [rel const532] ; 4.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2626
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump2626:
	push rax
	pop rax
	cmp rax, 0
	je .jump2627
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2629:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2630
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2630:
	; Computing bound for 'x'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2631
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2631:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2632:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2633:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2634:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2635: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2635 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2635 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2636:
	cmp rax, [rsp + 16]
	jl .jump2637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2637:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2638:
	cmp rax, [rsp + 24]
	jl .jump2639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2639:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2640:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2641: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2642
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2642:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2643:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2644
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2644:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump2645: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const533] ; 82.28
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2645 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2645 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2645 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'z'
	add qword [rsp + 16], 1
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2641 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2641 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2641 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2628
.jump2627:
	mov rax, [rel const534] ; 27.93
	push rax
.jump2628:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump2596:
	jmp .jump2594
.jump2593:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2646:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2647
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2647:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2648:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2649
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2649:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2650: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2651
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2651:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2652:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2653: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2654:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2655
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2655:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2656:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump2657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2657:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump2658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2658:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump2659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2659:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump2660: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2660 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2660 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2660 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2661
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2661:
	cmp rax, [rsp + 24]
	jl .jump2662
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2662:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2663
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2663:
	cmp rax, [rsp + 32]
	jl .jump2664
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2664:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2665
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2665:
	cmp rax, [rsp + 40]
	jl .jump2666
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2666:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2653 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2653 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2650 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2650 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2650 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2650 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump2594:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2667
	lea rdi, [rel const535] ; 'x'
	call _fail_assertion
.jump2667:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	add rsp, 64 ; Local variables
	pop rbp
	ret

o:
_o:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2714
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	jmp .jump2715
.jump2714:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2716
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2716:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump2717
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2717:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2718: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const547] ; 8.94
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2718 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2719
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2721
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2721:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2722:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2723:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump2724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2724:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2725: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2726
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump2726:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2725 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2725 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2720
.jump2719:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2727
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2727:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2728:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump2729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2729:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2730:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2731: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2731 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2731 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2720:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2732
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2734
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
.jump2734:
	push rax
	pop rax
	cmp rax, 0
	je .jump2735
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2737:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2738
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2738:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2739:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2740:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump2741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2741:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump2742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2742:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2743: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2743 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2743 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2743 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2744
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump2745
.jump2744:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2745:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2746
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2746:
	cmp rax, [rsp + 24]
	jl .jump2747
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2747:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2748
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2748:
	cmp rax, [rsp + 32]
	jl .jump2749
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2749:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2750
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2750:
	cmp rax, [rsp + 40]
	jl .jump2751
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2751:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2736
.jump2735:
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump2736:
	jmp .jump2733
.jump2732:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2752
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump2753
.jump2752:
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump2753:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2754
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const548] ; 70.09
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2755
.jump2754:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump2755:
	mov rax, [rel const549] ; 2.38
	push rax
	mov rax, [rel const550] ; 59.51
	push rax
.jump2733:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump2756
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump2756:
	push rax
	pop rax
	cmp rax, 0
	je .jump2757
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump2757:
	push rax
	pop rax
	cmp rax, 0
	je .jump2758
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2760:
	cmp rax, [rsp + 8]
	jl .jump2761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2761:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2762:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2763
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2763:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2764:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- x) 
	jno .jump2765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2765:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2766:
	imul rdi, [rsp + 0 + 16] ; multiply by a[r] 
	jno .jump2767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2767:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2768: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2768 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2768 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2768 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2759
.jump2758:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2769
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2769:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2770:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2771
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2771:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2772:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2773: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2773 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2773 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2773 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2773 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2774:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2775
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2775:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2776:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2777:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump2778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2778:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[B : b, C : h, D : g, E : A] r) 
	jno .jump2779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2779:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2780: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2780 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2780 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2780 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2759:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2781
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2781:
	cmp rax, [rsp + 24]
	jl .jump2782
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2782:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2783
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2783:
	cmp rax, [rsp + 32]
	jl .jump2784
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2784:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2785
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2785:
	cmp rax, [rsp + 40]
	jl .jump2786
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2786:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2787
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2789:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2790
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2790:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump2791
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2791:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2792
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2792:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2793: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const551] ; 39.12
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2793 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2793 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	mov rax, [rel const552] ; 41.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump2788
.jump2787:
	mov rax, [rel const1] ; False
	push rax
.jump2788:
	pop rax
	cmp rax, 0
	je .jump2794
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -112 to rsp 
		mov r10, [rbp - -112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2796
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump2796:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2797:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2798
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2798:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2799
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2799:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- z) % k) 
	jno .jump2800
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2800:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2801: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump2802
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2803
.jump2802:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2804
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2804:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2805:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump2806: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const553] ; 35.3
	push rax
	mov rax, [rel const554] ; 15.99
	push rax
	mov rax, [rel const555] ; 33.14
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2806 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2806 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2803:
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2801 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2801 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2795
.jump2794:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2807:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2808
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2808:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump2809
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2809:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump2810
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2810:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump2811: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2812
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
.jump2812:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2811 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2811 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2795:
.jump2715:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2813
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 2
	push rax
	jmp .jump2814
.jump2813:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2815:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump2816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2816:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2817: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2817 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump2814:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2818
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2818:
	cmp rax, [rsp + 8]
	jl .jump2819
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2819:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2820
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump2822
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump2823
.jump2822:
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
.jump2823:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -112 to rsp 
		mov r10, [rbp - -112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2824
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2824:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -112 to rsp 
		mov r10, [rbp - -112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2825:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump2826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2826:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump2827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2827:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2828: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2829
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2829:
	cmp rax, [rsp + 16]
	jl .jump2830
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2830:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2831
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2831:
	cmp rax, [rsp + 24]
	jl .jump2832
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2832:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2828 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2828 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2833
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2835
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2837:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump2838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2838:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2839: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2839 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump2836
.jump2835:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2840:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2841:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2842: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2843:
	cmp rax, [rsp + 16]
	jl .jump2844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2844:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2845:
	cmp rax, [rsp + 24]
	jl .jump2846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2846:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2842 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump2836:
	jmp .jump2834
.jump2833:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2847:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump2848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2848:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2849: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2849 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump2834:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2850
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2850:
	cmp rax, [rsp + 8]
	jl .jump2851
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2851:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2821
.jump2820:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const556] ; 60.91
	push rax
	mov rax, [rel const557] ; 50.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2852
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2854:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2855
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2855:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2856:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2857
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2857:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2858: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2858 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2858 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2858 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2858 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2859
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2859:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2860:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2861:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[E : C, F : x, G : h, H : g] g) 
	jno .jump2862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2862:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2863: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const558] ; 6.77
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2863 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2863 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2864
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump2864:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2865:
	cmp rax, [rsp + 16]
	jl .jump2866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2866:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2867:
	cmp rax, [rsp + 24]
	jl .jump2868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2868:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2853
.jump2852:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2869:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2870
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2870:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2871:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2872
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2872:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump2873
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2873:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2874
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2874:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump2875
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2875:
	imul rdi, [rsp + 0 + 24] ; multiply by (x - C) 
	jno .jump2876
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2876:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2877: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2878
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2878:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2879:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2880
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2880:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump2881
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2881:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump2882
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2882:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump2883
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2883:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump2884: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2884 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2884 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2884 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2877 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2877 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2877 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2877 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const70] ; 185
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2885
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2885:
	cmp rax, [rsp + 32]
	jl .jump2886
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2886:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2887
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2887:
	cmp rax, [rsp + 40]
	jl .jump2888
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2888:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2889
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2889:
	cmp rax, [rsp + 48]
	jl .jump2890
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2890:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2891
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2891:
	cmp rax, [rsp + 56]
	jl .jump2892
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2892:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2893
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2893:
	; Computing bound for 'G'
	mov rax, [rel const559] ; 386
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2894:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2895
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2895:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2896:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2897: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2897 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2897 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2897 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2897 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2898
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2898:
	cmp rax, [rsp + 24]
	jl .jump2899
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2899:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2900
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2900:
	cmp rax, [rsp + 32]
	jl .jump2901
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2901:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2902
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2902:
	cmp rax, [rsp + 40]
	jl .jump2903
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2903:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2853:
.jump2821:
	pop rax
	cmp rax, 0
	je .jump2904
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2905
.jump2904:
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2905:
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump2906
	lea rdi, [rel const560] ; 'E'
	call _fail_assertion
.jump2906:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const561] ; 87.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	add rsp, 32 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump2907
	sub rsp, 8 ; Add alignment
	mov rax, [rel const562] ; 91.76
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump2908
.jump2907:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump2908:
	pop rax
	cmp rax, 0
	je .jump2909
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rdi, 72
	call _jpl_alloc
	; Moving 72 bytes from rsp to rax 
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2911
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2911:
	cmp rax, [rsp + 8]
	jl .jump2912
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2912:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2910
.jump2909:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2913:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump2914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2914:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2915: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2915 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const563] ; 632
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2916
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2916:
	cmp rax, [rsp + 8]
	jl .jump2917
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2917:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2910:
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2918
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2920
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2920:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2921
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump2922
.jump2921:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2922:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2923
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump2923:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2924:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2925
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2925:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2926:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,][][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump2927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2927:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump2928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2928:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if (g <= s) then (e - n) else D) % e) 
	jno .jump2929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2929:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump2930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2930:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2931: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2932:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2933
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2933:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump2934
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2934:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2935
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2935:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump2936: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2937
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2937:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump2938
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2938:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump2939: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2939 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2936 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2936 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2931 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2931 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2931 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2931 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2919
.jump2918:
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2940:
	cmp rax, [rsp + 16]
	jl .jump2941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2941:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2942:
	cmp rax, [rsp + 24]
	jl .jump2943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2943:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2944
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2946
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2946:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2947:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2948
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2948:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2949:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,][][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2950:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2951:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump2952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2952:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump2953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2953:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2954: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2955:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2956
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2956:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2957
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2957:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2958
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2958:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump2959: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2960
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2960:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump2961
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2961:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump2962: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2962 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2959 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2959 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2954 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2954 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2954 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2954 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2945
.jump2944:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2963
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2963:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2964:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2965
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2965:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2966:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,][][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump2967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2967:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump2968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2968:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2969:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump2970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2970:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump2971: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2972:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2973
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2973:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2974
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2974:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2975
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2975:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump2976: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2976 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2976 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2971 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2971 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2971 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2971 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2945:
.jump2919:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -112 to rsp 
		mov r10, [rbp - -112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2977:
	cmp rax, [rsp + 32]
	jl .jump2978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2978:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2979:
	cmp rax, [rsp + 40]
	jl .jump2980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2980:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2981:
	cmp rax, [rsp + 48]
	jl .jump2982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2982:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2983:
	cmp rax, [rsp + 56]
	jl .jump2984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2984:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2985:
	cmp rax, [rsp + 16]
	jl .jump2986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2986:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2987:
	cmp rax, [rsp + 24]
	jl .jump2988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2988:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2989:
	cmp rax, [rsp + 8]
	jl .jump2990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2990:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const564] ; 84.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2991
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2992
.jump2991:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2993
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2993:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2994:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2995
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2995:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump2996: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2996 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2996 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2996 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2992:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2997
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump2998
.jump2997:
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump2998:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const565] ; 'H'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2999:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3000
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3000:
	cmp rax, [rsp + 32]
	jl .jump3001
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3001:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3002
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3002:
	cmp rax, [rsp + 40]
	jl .jump3003
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3003:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3004
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3004:
	cmp rax, [rsp + 48]
	jl .jump3005
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3005:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3006
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3006:
	cmp rax, [rsp + 56]
	jl .jump3007
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3007:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3008
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3010
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3012
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3012:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3013:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -112 to rsp 
		mov r10, [rbp - -112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3014
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3014:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump3015
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3015:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3016
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3016:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump3017
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3017:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3018: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3019
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3019:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump3020
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3020:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump3021: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3021 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3022:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3023
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3023:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3024:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3025
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3025:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by L 
	jno .jump3026
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3026:
	imul rdi, [rsp + 0 + 8] ; multiply by I 
	jno .jump3027
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3027:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump3028
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3028:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump3029
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3029:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump3030: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 96 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3030 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3030 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3030 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3030 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3031
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump3032
.jump3031:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3033:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -112 to rsp 
		mov r10, [rbp - -112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3034
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3034:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3035:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3036
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3036:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump3037
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3037:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3038
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3038:
	imul rdi, [rsp + 0 + 16] ; multiply by (O * z) 
	jno .jump3039
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3039:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump3040
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3040:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump3041: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3042:
	cmp rax, [rsp + 16]
	jl .jump3043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3043:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3044:
	cmp rax, [rsp + 24]
	jl .jump3045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3045:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3041 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3041 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3041 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3041 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3032:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3018 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3018 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3018 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3011
.jump3010:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3046
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3046:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump3047
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3047:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3048: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3049:
	; Computing bound for 'O'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3050:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump3051: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 0], 1
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3051 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3052
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3052:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3053:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump3054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3054:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[N : r] x) 
	jno .jump3055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3055:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump3056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3056:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump3057: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'P'
	add qword [rsp + 16], 1
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3057 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3057 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3057 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3048 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3058:
	cmp rax, [rsp + 8]
	jl .jump3059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3059:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3011:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3060:
	cmp rax, [rsp + 24]
	jl .jump3061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3061:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3062:
	cmp rax, [rsp + 32]
	jl .jump3063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3063:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3064:
	cmp rax, [rsp + 40]
	jl .jump3065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3065:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3009
.jump3008:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3066
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump3067
.jump3066:
	mov rax, [rel const566] ; 234
	push rax
.jump3067:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3068
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3068:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if i((- u.g)) then J else 234) 
	jno .jump3069
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3069:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3070: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3071:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3072
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3072:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3073:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3074
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3074:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump3075
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3075:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump3076
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3076:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump3077
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3077:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump3078
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3078:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump3079: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3079 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3079 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3079 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3079 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3070 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3080:
	cmp rax, [rsp + 8]
	jl .jump3081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3081:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3009:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3082:
	cmp rax, [rsp + 32]
	jl .jump3083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3083:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3084:
	cmp rax, [rsp + 40]
	jl .jump3085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3085:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3086:
	cmp rax, [rsp + 48]
	jl .jump3087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3087:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3088:
	cmp rax, [rsp + 56]
	jl .jump3089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3089:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 96 ; Local variables
	pop rbp
	ret

r:
_r:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3090
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3090:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3091:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3092:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3093:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3094: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3095
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3095:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3096:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3097
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3097:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3098
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3098:
	imul rdi, [rsp + 0 + 8] ; multiply by (- n) 
	jno .jump3099
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3099:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump3100
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3100:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3101: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3101 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3101 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3101 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _r
	add rsp, 32
	add rsp, 32
	add rsp, 40
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3102
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3102:
	cmp rax, [rsp + 8]
	jl .jump3103
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3103:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3094 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3094 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const567] ; 18.43
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump3104
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3105
.jump3104:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump3105:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3106:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3107
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3107:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3108:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3109
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3109:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump3110
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3110:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3111
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3111:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3112
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3112:
	imul rdi, [rsp + 0 + 24] ; multiply by (if i(18.43) then t else t) 
	jno .jump3113
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3113:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3114: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3115
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3115:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3116:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3117:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3118:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3119: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3119 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3119 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3114 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3114 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3114 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3114 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3120
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump3120:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3121:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3122
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3122:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3123:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3124
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3124:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump3125
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3125:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3126
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3126:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump3127
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3127:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump3128
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3128:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3129: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3129 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3129 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3129 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3129 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3130:
	cmp rax, [rsp + 8]
	jl .jump3131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3131:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3132:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3133: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3133 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3134
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3134:
	cmp rax, [rsp + 32]
	jl .jump3135
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3135:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3136
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3136:
	cmp rax, [rsp + 40]
	jl .jump3137
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3137:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3138
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3138:
	cmp rax, [rsp + 48]
	jl .jump3139
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3139:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3140
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3140:
	cmp rax, [rsp + 56]
	jl .jump3141
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3141:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3142:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3143:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3144
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3144:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3145: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3145 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3145 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3146
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3146:
	cmp rax, [rsp + 32]
	jl .jump3147
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3147:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3148
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3148:
	cmp rax, [rsp + 40]
	jl .jump3149
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3149:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3150
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3150:
	cmp rax, [rsp + 48]
	jl .jump3151
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3151:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3152
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3152:
	cmp rax, [rsp + 56]
	jl .jump3153
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3153:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3154
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3154:
	cmp rax, [rsp + 16]
	jl .jump3155
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3155:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3156
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3156:
	cmp rax, [rsp + 24]
	jl .jump3157
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3157:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const423] ; 47
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3158
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3160
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3162
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3164:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3165
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3165:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3166:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3167:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3168:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump3169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3169:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3170: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3170 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3170 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3170 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3163
.jump3162:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3171:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3172
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3172:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3173:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3174:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump3175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3175:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3176:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3177: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3177 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3177 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3177 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3163:
	jmp .jump3161
.jump3160:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3178:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3179
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3179:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3180:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3181:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3182:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3183:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3184: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const568] ; 23
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3184 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3184 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3184 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3161:
	jmp .jump3159
.jump3158:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const569] ; 67.24
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3185
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3187
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3187:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3188:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3189
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3189:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3190:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3191: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3191 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3191 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3191 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3191 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3192:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3193
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3193:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3194:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3195:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3196:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[y : g, z : v, A : n, B : v] k) 
	jno .jump3197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3197:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3198: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3198 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3198 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3198 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3186
.jump3185:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3199:
	cmp rax, [rsp + 8]
	jl .jump3200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3200:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3201:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3202:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3203: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3203 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3204
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3204:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3205:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3206:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[y : g] b) 
	jno .jump3207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3207:
	imul rdi, [rsp + 0 + 16] ; multiply by j[n] 
	jno .jump3208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3208:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3209: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3209 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3209 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3209 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3186:
.jump3159:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3210:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3211
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3211:
	cmp rax, [rsp + 24]
	jl .jump3212
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3212:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3213
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3213:
	cmp rax, [rsp + 32]
	jl .jump3214
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3214:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3215
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3215:
	cmp rax, [rsp + 40]
	jl .jump3216
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3216:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3217
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3217:
	cmp rax, [rsp + 8]
	jl .jump3218
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3218:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3219
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump3220
.jump3219:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3221
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3222
.jump3221:
	mov rax, [rel const228] ; 880
	push rax
.jump3222:
.jump3220:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3223
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3223:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3224:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3225:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then k else (if false then t else 880)) 
	jno .jump3226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3226:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3227: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3228
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3230
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3232:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3233
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3233:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3234:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3235
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3235:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3236
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3236:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump3237
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3237:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3238
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3238:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump3239
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3239:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3240: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3240 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3240 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3240 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3240 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3231
.jump3230:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3241:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3242
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3242:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3243:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3244
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3244:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3245
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3245:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3246
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3246:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump3247
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3247:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump3248
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3248:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3249: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3249 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3249 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3249 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3249 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3231:
	jmp .jump3229
.jump3228:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3250:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3251
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3251:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3252:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3253
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3253:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump3254
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3254:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump3255
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3255:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3256
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3256:
	imul rdi, [rsp + 0 + 24] ; multiply by (- z) 
	jno .jump3257
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3257:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3258: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3258 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3258 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3258 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3258 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3229:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3227 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3227 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3259:
	cmp rax, [rsp + 16]
	jl .jump3260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3260:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3261:
	cmp rax, [rsp + 24]
	jl .jump3262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3262:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3263:
	cmp rax, [rsp + 32]
	jl .jump3264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3264:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3265:
	cmp rax, [rsp + 40]
	jl .jump3266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3266:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3267:
	cmp rax, [rsp + 48]
	jl .jump3268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3268:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3269:
	cmp rax, [rsp + 56]
	jl .jump3270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3270:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3271:
	cmp rax, [rsp + 16]
	jl .jump3272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3272:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3273:
	cmp rax, [rsp + 24]
	jl .jump3274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3274:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 0 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const149] ; 607
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3275
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3275:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3276
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3276:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3277:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3278
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3278:
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3279
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3279:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3280
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3280:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3281: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const570] ; 29
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3282
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3282:
	cmp rax, [rsp + 24]
	jl .jump3283
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3283:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3284
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3284:
	cmp rax, [rsp + 32]
	jl .jump3285
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3285:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3286
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3286:
	cmp rax, [rsp + 40]
	jl .jump3287
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3287:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3281 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3288
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3288:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3289:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3290:
	imul rdi, [rsp + 0 + 8] ; multiply by (- k) 
	jno .jump3291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3291:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3292: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3292 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3292 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const571] ; 59.31
	push rax
	mov rax, [rel const572] ; 10.71
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const573] ; 78.78
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3293:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3294
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3294:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3295:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3296
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3296:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump3297
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3297:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump3298
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3298:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump3299
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3299:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump3300
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3300:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3301: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3302
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3302:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3303:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3304
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3304:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3305:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3306:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump3307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3307:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump3308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3308:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump3309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3309:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3310: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3310 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3310 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3310 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3310 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3301 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3301 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3301 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3301 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3311
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump3312
.jump3311:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3313:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3314
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3314:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3315:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3316:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump3317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3317:
	imul rdi, [rsp + 0 + 16] ; multiply by (- t) 
	jno .jump3318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3318:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3319: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3319 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3319 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3319 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3320:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3321
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3321:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3322:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3323: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3323 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3323 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3323 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3324
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3324:
	cmp rax, [rsp + 24]
	jl .jump3325
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3325:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3326
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3326:
	cmp rax, [rsp + 32]
	jl .jump3327
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3327:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3328
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3328:
	cmp rax, [rsp + 40]
	jl .jump3329
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3329:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3312:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3330
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3330:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3331:
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3332
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3332:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3333:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3334
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3334:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3336 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3336 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3336 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3336 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3337:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3338
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3338:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3339: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3339 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3339 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3340
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump3340:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3341:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3342
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3342:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3343: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3343 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3343 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3344
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3344:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3345: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3345 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3345 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3345 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3346:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3347: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3347 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3347 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3347 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3347 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3348:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3349
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3349:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3350:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (n * e) 
	jno .jump3351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3351:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3352:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[y : (- (sum[y : (sum[y : n, z : (- ((sum[y : h, z : f] f) / (sum[y : u, z : f, A : u, B : p] z)))] v), z : f, A : (if o((array[y : g, z : u, A : v, B : f] (array[C : h, D : p, E : A, F : g] w)), rgba {w.a, 78.78, (- 10.71), 59.31}, (array[y : v, z : (- k)] x.b), (array[y : h] s[n, p, 29])) then v else (array[y : e, z : n, A : (- t)] b)[(sum[y : g, z : u, A : b] t), e, h])] A)), z : k, A : e, B : b] h) 
	jno .jump3353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3353:
	imul rdi, [rsp + 0 + 24] ; multiply by 607 
	jno .jump3354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3354:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3355: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3356:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3357: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 0], 1
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3357 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3358
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3358:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3359:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3360
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3360:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3361:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump3362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3362:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3363:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump3364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3364:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[C : h] n) 
	jno .jump3365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3365:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3366: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3367
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3367:
	cmp rax, [rsp + 24]
	jl .jump3368
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3368:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3369
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3369:
	cmp rax, [rsp + 32]
	jl .jump3370
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3370:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3371
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3371:
	cmp rax, [rsp + 40]
	jl .jump3372
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3372:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3366 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3366 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3366 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3366 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3373
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump3374
.jump3373:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump3374:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3375:
	cmp rax, [rsp + 32]
	jl .jump3376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3376:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3377:
	cmp rax, [rsp + 40]
	jl .jump3378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3378:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3379:
	cmp rax, [rsp + 48]
	jl .jump3380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3380:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3381:
	cmp rax, [rsp + 56]
	jl .jump3382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3382:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3383
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3385
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3387
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3387:
	cmp rax, [rsp + 24]
	jl .jump3388
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3388:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3389
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3389:
	cmp rax, [rsp + 32]
	jl .jump3390
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3390:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3391
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3391:
	cmp rax, [rsp + 40]
	jl .jump3392
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3392:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3386
.jump3385:
	mov rax, [rel const574] ; 60.67
	push rax
.jump3386:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3393
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3393:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3394:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3395
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3395:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3396:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3397:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3398:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump3399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3399:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump3400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3400:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3401: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3401 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3401 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3401 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3401 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3402:
	cmp rax, [rsp + 32]
	jl .jump3403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3403:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3404:
	cmp rax, [rsp + 40]
	jl .jump3405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3405:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3406:
	cmp rax, [rsp + 48]
	jl .jump3407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3407:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3408:
	cmp rax, [rsp + 56]
	jl .jump3409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3409:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const575] ; 27.31
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3410:
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3411:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3412
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3412:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3413:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3414
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3414:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3415: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3415 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3415 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3415 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3415 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3416
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3416:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3417: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const576] ; 59.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3417 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3417 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3418
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3418:
	; Computing bound for 'E'
	mov rax, [rel const577] ; 99
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3419:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3420
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3420:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3421:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3422:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump3423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3423:
	imul rdi, [rsp + 0 + 16] ; multiply by 99 
	jno .jump3424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3424:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump3425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3425:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3426: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const578] ; 37.77
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3426 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3426 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3426 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3426 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3427:
	cmp rax, [rsp + 32]
	jl .jump3428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3428:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3429:
	cmp rax, [rsp + 40]
	jl .jump3430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3430:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3431:
	cmp rax, [rsp + 48]
	jl .jump3432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3432:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3433:
	cmp rax, [rsp + 56]
	jl .jump3434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3434:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const579] ; 68.18
	push rax
	jmp .jump3384
.jump3383:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3435
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3435:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3436
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3436:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3437: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 0], 1
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3437 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3438
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3438:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3439:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump3440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3440:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump3441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3441:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3442: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3442 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3442 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3443:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3444
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3444:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3445
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3445:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump3446
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3446:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3447: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3447 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3447 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const83] ; 488
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3448
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3448:
	cmp rax, [rsp + 16]
	jl .jump3449
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3449:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3450
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3450:
	cmp rax, [rsp + 24]
	jl .jump3451
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3451:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3452:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3453
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3453:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3454:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3455
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3455:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- A) 
	jno .jump3456
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3456:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3457
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3457:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump3458
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3458:
	imul rdi, [rsp + 0 + 24] ; multiply by (- h) 
	jno .jump3459
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3459:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3460: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3461
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3461:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3462
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3462:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3463
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3463:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3464:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3465:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump3466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3466:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump3467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3467:
	imul rdi, [rsp + 0 + 24] ; multiply by y 
	jno .jump3468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3468:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3469: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3469 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3469 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3469 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3469 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3460 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3460 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3460 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3460 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3470
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	jmp .jump3471
.jump3470:
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
.jump3471:
.jump3384:
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3355 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3355 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3355 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3355 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3472:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump3473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3473:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump3474: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3475
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	jmp .jump3476
.jump3475:
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
.jump3476:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 0], 1
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3474 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3477
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3477:
	cmp rax, [rsp + 8]
	jl .jump3478
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3478:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3479
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3481:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3482
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3482:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3483
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3483:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump3484
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3484:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump3485: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3486
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3486:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3487:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump3488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3488:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3489:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3490: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const580] ; 40.72
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3490 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3490 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3485 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3485 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3491
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3491:
	cmp rax, [rsp + 16]
	jl .jump3492
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3492:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3493
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3493:
	cmp rax, [rsp + 24]
	jl .jump3494
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3494:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const581] ; 98
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3495
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3495:
	cmp rax, [rsp + 16]
	jl .jump3496
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3496:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3497
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3497:
	cmp rax, [rsp + 24]
	jl .jump3498
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3498:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump3480
.jump3479:
	mov rax, [rel const582] ; 68.08
	push rax
.jump3480:
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3499:
	cmp rax, [rsp + 24]
	jl .jump3500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3500:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3501:
	cmp rax, [rsp + 32]
	jl .jump3502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3502:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3503:
	cmp rax, [rsp + 40]
	jl .jump3504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3504:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3505
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3506
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3506:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3507
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3507:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3508
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3508:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump3509
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3509:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3510: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3510 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3510 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump3505:
	push rax
	pop rax
	cmp rax, 0
	je .jump3511
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3513
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3513:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3514:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3515
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3515:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3516
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3516:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump3517
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3517:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump3518
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3518:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3519: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3520:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3521
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3521:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3522:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3523:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump3524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3524:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump3525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3525:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3526: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3526 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3526 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3526 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3519 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3519 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3519 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3527:
	cmp rax, [rsp + 24]
	jl .jump3528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3528:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3529:
	cmp rax, [rsp + 32]
	jl .jump3530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3530:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3531:
	cmp rax, [rsp + 40]
	jl .jump3532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3532:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3533
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3535
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3535:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3536:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3537:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump3538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3538:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3539: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3539 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3539 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3534
.jump3533:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3540
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3540:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3541:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3542:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump3543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3543:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3544: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3544 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3544 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3534:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3545:
	cmp rax, [rsp + 16]
	jl .jump3546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3546:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3547:
	cmp rax, [rsp + 24]
	jl .jump3548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3548:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3549:
	; Computing bound for 'G'
	mov rax, [rel const583] ; 270
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3550
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3550:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3551:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3552
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3552:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3553
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3553:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump3554
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3554:
	imul rdi, [rsp + 0 + 16] ; multiply by 270 
	jno .jump3555
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3555:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump3556
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3556:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3557: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3557 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3557 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3557 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3557 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3558
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3558:
	cmp rax, [rsp + 32]
	jl .jump3559
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3559:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3560
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3560:
	cmp rax, [rsp + 40]
	jl .jump3561
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3561:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3562
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3562:
	cmp rax, [rsp + 48]
	jl .jump3563
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3563:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3564
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3564:
	cmp rax, [rsp + 56]
	jl .jump3565
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3565:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3566
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3566:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3567:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3568
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3568:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3569: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3570
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3570:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3571:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3572
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3572:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3573: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3573 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3573 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3573 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3574:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3575
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3575:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3576:
	; Computing bound for 'H'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3577:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3578
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3578:
	; Computing bound for 'H'
	mov rax, [rel const372] ; 972
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3579:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3580: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3580 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3580 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3580 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3581
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3581:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3582: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'K'
	add qword [rsp + 24], 1
	; Compare K to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3582 ; If K < bound, next iter
	mov qword [rsp + 24], 0 ; K = 0
	add qword [rsp + 16], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3582 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3582 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3582 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3569 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3569 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3569 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3583:
	cmp rax, [rsp + 24]
	jl .jump3584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3584:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3585:
	cmp rax, [rsp + 32]
	jl .jump3586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3586:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3587:
	cmp rax, [rsp + 40]
	jl .jump3588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3588:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3512
.jump3511:
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
.jump3512:
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3589
	mov rax, [rel const584] ; 52.97
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump3590
.jump3589:
	mov rax, [rel const585] ; 79.11
	push rax
.jump3590:
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3591:
	; Computing bound for 'F'
	mov rax, [rel const538] ; 222
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3592
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3592:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3593:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3594:
	imul rdi, [rsp + 0 + 8] ; multiply by 222 
	jno .jump3595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3595:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump3596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3596:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3597: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3597 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3597 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3597 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const280] ; 592
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3598
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3598:
	cmp rax, [rsp + 24]
	jl .jump3599
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3599:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3600
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3600:
	cmp rax, [rsp + 32]
	jl .jump3601
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3601:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3602
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3602:
	cmp rax, [rsp + 40]
	jl .jump3603
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3603:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3604
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3605
.jump3604:
	mov rax, [rel const586] ; 6.9
	push rax
.jump3605:
	mov rax, [rel const587] ; 77.12
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3606
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3606:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3607:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3608: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3608 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3608 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3609:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3610
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3610:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3611:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3612
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3612:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3613: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3614
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump3615
.jump3614:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
.jump3615:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3616
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3616:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3617: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3618:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3619
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3619:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3620:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3621
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3621:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3622: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const588] ; 73.57
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3622 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3622 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3622 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3622 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3617 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3613 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3613 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3613 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3613 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3623
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3623:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3624:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3625:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump3626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3626:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3627: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3628
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	jmp .jump3629
.jump3628:
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
.jump3629:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3627 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3627 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3630:
	cmp rax, [rsp + 16]
	jl .jump3631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3631:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3632:
	cmp rax, [rsp + 24]
	jl .jump3633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3633:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3634
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3634:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3635:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3636
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3638:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3639
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3639:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3640:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3641:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump3642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3642:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump3643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3643:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3644: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3645
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3645:
	; Computing bound for 'H'
	mov rax, [rel const589] ; 315
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3646:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 315 
	jno .jump3647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3647:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3648:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3649: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 8], 1
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3649 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3649 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3644 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3644 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3644 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3650:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3651 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3652
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3652:
	cmp rax, [rsp + 24]
	jl .jump3653
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3653:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3654
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3654:
	cmp rax, [rsp + 32]
	jl .jump3655
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3655:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3656
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3656:
	cmp rax, [rsp + 40]
	jl .jump3657
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3657:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3637
.jump3636:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3658:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const42] ; 180
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3659
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3659:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (180 + (- B)) 
	jno .jump3660
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3660:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3661
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3661:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3662: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3662 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3662 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3637:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3663
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3664
.jump3663:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump3664:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3665
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3665:
	cmp rax, [rsp + 16]
	jl .jump3666
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3666:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3667
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3667:
	cmp rax, [rsp + 24]
	jl .jump3668
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3668:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3669
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3669:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (if (! (z == n)) then (array[E : h, F : p, G : f] (array[H : 315, I : f] C))[u, B, (sum[E : t] g)] else (array[E : (180 + (- B)), F : h] t))[(if false then C else p), B] 
	jno .jump3670
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3670:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3671
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3671:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump3672
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3672:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3673: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3674:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3675
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3675:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3676:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3677
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3677:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump3678
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3678:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3679
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3679:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump3680
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3680:
	imul rdi, [rsp + 0 + 24] ; multiply by (- F) 
	jno .jump3681
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3681:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3682: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3683
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3683:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3684:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3685:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3686:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump3687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const590] ; 47.69
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3687 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3687 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 24], 1
	; Compare K to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3682 ; If K < bound, next iter
	mov qword [rsp + 24], 0 ; K = 0
	add qword [rsp + 16], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3682 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3682 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3682 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3688
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3688:
	cmp rax, [rsp + 32]
	jl .jump3689
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3689:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3690
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3690:
	cmp rax, [rsp + 40]
	jl .jump3691
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3691:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3692
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3692:
	cmp rax, [rsp + 48]
	jl .jump3693
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3693:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3694
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3694:
	cmp rax, [rsp + 56]
	jl .jump3695
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3695:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump3696
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3698
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump3700
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3701
.jump3700:
	mov rax, [rel const591] ; 14.72
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump3701:
	jmp .jump3699
.jump3698:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3702
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3702:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3703:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump3704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3704:
	imul rdi, [rsp + 0 + 8] ; multiply by (- u) 
	jno .jump3705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3705:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3706: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const592] ; 11.9
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 8], 1
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3706 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3706 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3707:
	cmp rax, [rsp + 16]
	jl .jump3708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3708:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3709:
	cmp rax, [rsp + 24]
	jl .jump3710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3710:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3699:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump3697
.jump3696:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump3697:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3673 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3673 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3673 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	call _r
	add rsp, 32
	add rsp, 32
	add rsp, 40
	push rax
	pop rax
	add rsp, 56 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Add alignment
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3711:
	cmp rax, [rsp + 32]
	jl .jump3712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3712:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3713:
	cmp rax, [rsp + 40]
	jl .jump3714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3714:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3715:
	cmp rax, [rsp + 48]
	jl .jump3716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3716:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3717:
	cmp rax, [rsp + 56]
	jl .jump3718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3718:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const593] ; 23.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3719
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump3720
.jump3719:
	mov rax, [rel const594] ; 80.5
	push rax
.jump3720:
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3721
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3723:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3724 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3725
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3725:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3726:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3727
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3727:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3728:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3729: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const595] ; 45.79
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3729 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3729 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3729 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3729 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const596] ; 61.32
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const597] ; 99.72
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3730:
	cmp rax, [rsp + 32]
	jl .jump3731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3731:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3732:
	cmp rax, [rsp + 40]
	jl .jump3733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3733:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3734:
	cmp rax, [rsp + 48]
	jl .jump3735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3735:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3736:
	cmp rax, [rsp + 56]
	jl .jump3737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3737:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3738:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3739
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3739:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3740:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3741
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3741:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3742: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const598] ; 3.15
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3742 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3742 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3742 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3742 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3743
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3745:
	; Computing bound for 'E'
	mov rax, [rel const599] ; 764
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3746
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3746:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 764 
	jno .jump3747
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3747:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3748
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3748:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3749: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3750
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
.jump3750:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3749 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3749 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3751
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3751:
	cmp rax, [rsp + 16]
	jl .jump3752
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3752:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3753
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3753:
	cmp rax, [rsp + 24]
	jl .jump3754
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3754:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3744
.jump3743:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3755:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3756
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3756:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- v)) 
	jno .jump3757
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3757:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3758
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3758:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3759: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3760:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3761: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 0], 1
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3761 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3759 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3759 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
.jump3744:
	jmp .jump3722
.jump3721:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3762:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3763
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3763:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3764:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3765
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3765:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3766
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3766:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3767
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3767:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3768
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3768:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump3769
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3769:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3770: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3771
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3771:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3772:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3773:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3774:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3775: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3775 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3775 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3770 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3770 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3770 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3770 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3776
	mov rax, [rel const600] ; 509
	push rax
	jmp .jump3777
.jump3776:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3778:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3779
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3779:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3780: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3780 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3780 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump3777:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3781
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3781:
	cmp rax, [rsp + 32]
	jl .jump3782
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3782:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3783
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3783:
	cmp rax, [rsp + 40]
	jl .jump3784
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3784:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3785
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3785:
	cmp rax, [rsp + 48]
	jl .jump3786
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3786:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3787
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3787:
	cmp rax, [rsp + 56]
	jl .jump3788
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3788:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump3789
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3791
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3793:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3794: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3794 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump3792
.jump3791:
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3795
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3795:
	cmp rax, [rsp + 24]
	jl .jump3796
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3796:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3797
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3797:
	cmp rax, [rsp + 32]
	jl .jump3798
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3798:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3799
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3799:
	cmp rax, [rsp + 40]
	jl .jump3800
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3800:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3792:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3801
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3803:
	cmp rax, [rsp + 8]
	jl .jump3804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3804:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3802
.jump3801:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump3802:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump3790
.jump3789:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3805:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3806
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3806:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3807
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3807:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump3808
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3808:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3809: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3809 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3809 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
.jump3790:
.jump3722:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	mov rax, [rel const601] ; 893
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3810
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3810:
	; Computing bound for 'F'
	mov rax, [rel const402] ; 159
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3811:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3812
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3812:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3813
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3813:
	imul rdi, [rsp + 0 + 8] ; multiply by 159 
	jno .jump3814
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3814:
	imul rdi, [rsp + 0 + 16] ; multiply by 893 
	jno .jump3815
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3815:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3816: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const602] ; 18.2
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3817
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3817:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3818:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3819
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3819:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3820:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3821: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 24], 1
	; Compare K to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3821 ; If K < bound, next iter
	mov qword [rsp + 24], 0 ; K = 0
	add qword [rsp + 16], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3821 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3821 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3821 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const603] ; 4.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3822
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3824
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	jmp .jump3825
.jump3824:
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
.jump3825:
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump3823
.jump3822:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3826
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3826:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3827:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3828
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3828:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3829:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump3830: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 24], 1
	; Compare K to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3830 ; If K < bound, next iter
	mov qword [rsp + 24], 0 ; K = 0
	add qword [rsp + 16], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3830 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3830 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3830 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump3823:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3816 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3816 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3816 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3831:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump3832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3832:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3833: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3833 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3834
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3834:
	cmp rax, [rsp + 8]
	jl .jump3835
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3835:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3836:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3837
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3837:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3838
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3838:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump3839
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3839:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3840: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3840 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3840 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3841
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3841:
	cmp rax, [rsp + 16]
	jl .jump3842
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3842:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3843
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3843:
	cmp rax, [rsp + 24]
	jl .jump3844
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3844:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const604] ; 313
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3845
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump3846
.jump3845:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3846:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3847:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3848
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3848:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3849:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3850: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3850 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3850 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3850 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3851
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3851:
	cmp rax, [rsp + 24]
	jl .jump3852
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3852:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3853
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3853:
	cmp rax, [rsp + 32]
	jl .jump3854
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3854:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3855
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3855:
	cmp rax, [rsp + 40]
	jl .jump3856
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3856:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3857
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3857:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3858:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3859
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3859:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3860:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3861: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3862:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3863
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3863:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump3864: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3864 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3864 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3861 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3861 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3861 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3861 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3865
	sub rsp, 32
	; Moving 32 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump3866
.jump3865:
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
.jump3866:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3867
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3867:
	cmp rax, [rsp + 24]
	jl .jump3868
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3868:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3869
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3869:
	cmp rax, [rsp + 32]
	jl .jump3870
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3870:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3871
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3871:
	cmp rax, [rsp + 40]
	jl .jump3872
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3872:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3873
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3875
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump3875:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3876:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3877
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3877:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3878:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3879: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3879 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3879 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3879 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3880
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3880:
	cmp rax, [rsp + 32]
	jl .jump3881
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3881:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3882
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3882:
	cmp rax, [rsp + 40]
	jl .jump3883
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3883:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3884
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3884:
	cmp rax, [rsp + 48]
	jl .jump3885
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3885:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3886
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3886:
	cmp rax, [rsp + 56]
	jl .jump3887
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3887:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3874
.jump3873:
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const605] ; 766
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3888:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3889
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3889:
	cmp rax, [rsp + 24]
	jl .jump3890
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3890:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3891
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3891:
	cmp rax, [rsp + 32]
	jl .jump3892
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3892:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3893
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump3893:
	cmp rax, [rsp + 40]
	jl .jump3894
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump3894:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3874:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3895
	lea rdi, [rel const606] ; 'J'
	call _fail_assertion
.jump3895:

x:
_x:
	push rbp
	mov rbp, rsp
	push rdi
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3896
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3898
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3898:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3899:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3900
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3900:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3901:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3902:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump3903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3903:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3904:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump3905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3905:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3906: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3906 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3906 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3906 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3906 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 40
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	jmp .jump3897
.jump3896:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3907
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3907:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3908
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3908:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3909: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3910:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3911
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3911:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3912:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3913
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3913:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump3914
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3914:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3915
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3915:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3916
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3916:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump3917
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3917:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump3918: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3918 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3918 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3918 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3918 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3909 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3897:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3919:
	cmp rax, [rsp + 8]
	jl .jump3920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3920:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3921:
	cmp rax, [rsp + 32]
	jl .jump3922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3922:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3923:
	cmp rax, [rsp + 40]
	jl .jump3924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3924:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3925:
	cmp rax, [rsp + 48]
	jl .jump3926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3926:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3927:
	cmp rax, [rsp + 56]
	jl .jump3928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3928:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3929:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3930
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3930:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3931
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3931:
imul rdi, [rsp + 0 + 8] ; multiply by (if x().b then [(array[y : e, z : w, A : k, B : b] p)] else (array[y : k] (array[z : e, A : f, B : b, C : k] y)))[n][n, (b - g), b, p] 
	jno .jump3932
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump3932:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3933: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const608] ; 72.54
	push rax
	mov rax, [rel const609] ; 95.38
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3934
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3936
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3936:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3937:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3938: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3938 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3938 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump3935
.jump3934:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump3935:
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3933 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3933 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump3939
	sub rsp, 8 ; Add alignment
	mov rax, [rel const610] ; 95.74
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3941
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3943
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3943:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3944:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3945
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3945:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3946:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3947:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump3948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3948:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump3949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3949:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump3950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3950:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3951: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3951 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3951 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3951 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3951 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3952
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump3953
.jump3952:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump3953:
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3954:
	cmp rax, [rsp + 32]
	jl .jump3955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3955:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3956:
	cmp rax, [rsp + 40]
	jl .jump3957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3957:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3958:
	cmp rax, [rsp + 48]
	jl .jump3959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3959:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3960:
	cmp rax, [rsp + 56]
	jl .jump3961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3961:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump3962
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3964:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3965:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3966
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3966:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3967: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3967 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3967 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3968
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3968:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3969:
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3970:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3971: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3971 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3972
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3972:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3973: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const611] ; 914
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3974
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump3974:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3973 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3973 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3973 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3973 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3975
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3975:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3976:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3977
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3977:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3978:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump3979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3979:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump3980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3980:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3981:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[y : (sum[y : s] y), z : w, A : (sum[y : k, z : p] f), B : k] (914 % u)) 
	jno .jump3982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3982:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3983: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3984
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump3985
.jump3984:
	mov rax, [rel const612] ; 15
	push rax
.jump3985:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3983 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3983 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3983 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3983 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3963
.jump3962:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3986
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3988
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3988:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3989:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3990
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3990:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3991:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- e) 
	jno .jump3992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3992:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3993:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3994:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump3995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3995:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3996: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3996 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3996 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3996 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3996 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3987
.jump3986:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3997
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3997:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3998:
	; Computing bound for 'z'
	mov rax, [rel const211] ; 826
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3999
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump3999:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4000:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump4001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4001:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 826) 
	jno .jump4002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4002:
	imul rdi, [rsp + 0 + 16] ; multiply by (- n) 
	jno .jump4003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4003:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump4004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4004:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4005: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4005 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4005 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4005 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4005 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3987:
.jump3963:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4006:
	cmp rax, [rsp + 32]
	jl .jump4007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4007:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4008:
	cmp rax, [rsp + 40]
	jl .jump4009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4009:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4010:
	cmp rax, [rsp + 48]
	jl .jump4011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4011:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4012:
	cmp rax, [rsp + 56]
	jl .jump4013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4013:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4014:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4015
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4015:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4016:
	; Computing bound for 'y'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4017
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump4018
.jump4017:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
.jump4018:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4019:
	; Computing bound for 'A'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4020
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4020:
	cmp rax, [rsp + 8]
	jl .jump4021
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4021:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4022
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4022:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4023:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4024
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4024:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4025
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4025:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4026
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4026:
	imul rdi, [rsp + 0 + 16] ; multiply by a[e] 
	jno .jump4027
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4027:
	imul rdi, [rsp + 0 + 24] ; multiply by (if true then f else e) 
	jno .jump4028
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4028:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4029: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4030
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4030:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4031:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4032:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump4033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4033:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4034: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4034 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4034 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4035
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4035:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4036:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4037: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4037 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4037 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4038:
	cmp rax, [rsp + 16]
	jl .jump4039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4039:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4040:
	cmp rax, [rsp + 24]
	jl .jump4041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4041:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4029 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4029 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4029 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4029 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4042
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	jmp .jump4043
.jump4042:
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
.jump4043:
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4044
	mov rax, [rel const415] ; 637
	push rax
	jmp .jump4045
.jump4044:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
.jump4045:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4046
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4046:
	cmp rax, [rsp + 32]
	jl .jump4047
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4047:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4048
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4048:
	cmp rax, [rsp + 40]
	jl .jump4049
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4049:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4050
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4050:
	cmp rax, [rsp + 48]
	jl .jump4051
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4051:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4052
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4052:
	cmp rax, [rsp + 56]
	jl .jump4053
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4053:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4054
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4054:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (array[y : b, z : f, A : a[e], B : (if true then f else e)] (array[C : k, D : w] g)[(sum[C : g, D : p] n), w])[(if (! (if true then x() else x()).b) then 637 else f), e, u, k] 
	jno .jump4055
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4055:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4056
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4056:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4057
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4057:
imul rdi, [rsp + 0 + 24] ; multiply by (if (array[y : p, z : e, A : g, B : u] x())[h, u, (if true then f else p), b].b then (array[y : u, z : u, A : k, B : (sum[y : (sum[y : s] y), z : w, A : (sum[y : k, z : p] f), B : k] (914 % u))] (if (h > n) then h else 15)) else (if true then (array[y : (- e), z : k, A : k, B : h] A) else (array[y : g, z : (- 826), A : (- n), B : e] B)))[b, u, b, e] 
	jno .jump4058
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4058:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4059: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4060
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4060:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4061
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump4062
.jump4061:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4063:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4064
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4064:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4065
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4065:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump4066
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4066:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4067: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4067 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4067 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4068
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4068:
	cmp rax, [rsp + 16]
	jl .jump4069
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4069:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4070
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4070:
	cmp rax, [rsp + 24]
	jl .jump4071
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4071:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4072
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4072:
	; Computing bound for 'C'
	mov rax, [rel const613] ; 2.01
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4073
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4075
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump4075:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump4074
.jump4073:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump4074:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4076:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4077: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4077 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4077 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump4062:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4078:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4079
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4079:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4080:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4081: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4082:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4083
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4083:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump4084: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4084 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4084 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4081 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4081 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4081 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4081 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4059 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4059 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4059 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4059 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3942
.jump3941:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4085:
	; Computing bound for 'z'
	mov rax, [rel const426] ; 428
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4086
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4086:
	; Computing bound for 'y'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4087
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4087:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4088:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4089
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4089:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4090:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- e) 
	jno .jump4091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4091:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4092:
	imul rdi, [rsp + 0 + 16] ; multiply by (b - h) 
	jno .jump4093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4093:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4094:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4095: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4096
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump4097
.jump4096:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump4097:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4095 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4095 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4095 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4095 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4098
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4098:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4099:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4100
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4100:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4101
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4101:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4102
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4102:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump4103
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4103:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4104: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4104 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4104 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4104 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4105:
	cmp rax, [rsp + 24]
	jl .jump4106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4106:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4107:
	cmp rax, [rsp + 32]
	jl .jump4108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4108:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4109:
	cmp rax, [rsp + 40]
	jl .jump4110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4110:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4111:
	cmp rax, [rsp + 32]
	jl .jump4112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4112:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4113:
	cmp rax, [rsp + 40]
	jl .jump4114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4114:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4115:
	cmp rax, [rsp + 48]
	jl .jump4116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4116:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4117:
	cmp rax, [rsp + 56]
	jl .jump4118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4118:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4119:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,,][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[y : (- e), z : p, A : (b - h), B : h] (if true then z else y))[(array[y : p, z : f, A : p] e)[p, f, w], w, (w - u), h] 
	jno .jump4120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4120:
	imul rdi, [rsp + 0 + 8] ; multiply by 428 
	jno .jump4121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4121:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4122:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4123: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4124
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4124:
	; Computing bound for 'C'
	mov rax, [rel const201] ; 742
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4125:
	; Computing bound for 'B'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4126
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump4127
.jump4126:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
.jump4127:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4128
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4128:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then h else n) 
	jno .jump4129
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4129:
	imul rdi, [rsp + 0 + 8] ; multiply by 742 
	jno .jump4130
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4130:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump4131
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4131:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump4132: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4133
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4135:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4136
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4136:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4137:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4138
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4138:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4139
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4139:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4140
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4140:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump4141
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4141:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump4142
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4142:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump4143: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4143 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4143 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4143 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4143 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4134
.jump4133:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4144:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4145
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4145:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4146:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4147
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4147:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4148
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4148:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump4149
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4149:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump4150
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4150:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4151
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4151:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump4152: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const614] ; 64.36
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4152 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4152 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4152 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4152 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4134:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4132 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4132 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4132 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4123 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4123 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4123 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4153
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4153:
	cmp rax, [rsp + 24]
	jl .jump4154
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4154:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4155
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4155:
	cmp rax, [rsp + 32]
	jl .jump4156
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4156:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4157
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4157:
	cmp rax, [rsp + 40]
	jl .jump4158
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4158:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4159
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4159:
	cmp rax, [rsp + 24]
	jl .jump4160
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4160:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4161
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4161:
	cmp rax, [rsp + 32]
	jl .jump4162
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4162:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4163
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4163:
	cmp rax, [rsp + 40]
	jl .jump4164
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4164:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3942:
	jmp .jump3940
.jump3939:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4165
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4167:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4168:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4169: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4170
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4170:
	; Computing bound for 'B'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4171
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4171:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4172:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4173
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4173:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4174
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4174:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4175
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4175:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4176
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4176:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4177: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4177 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4177 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4177 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const615] ; 628
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4178:
	cmp rax, [rsp + 24]
	jl .jump4179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4179:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4180:
	cmp rax, [rsp + 32]
	jl .jump4181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4181:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4182:
	cmp rax, [rsp + 40]
	jl .jump4183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4183:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4184:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4185
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4185:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4186
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4186:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4187:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4188
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4188:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4189:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4190: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4190 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4190 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4190 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4190 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4191:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[z : g, A : s, B : e, C : f] k) 
	jno .jump4192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4192:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump4193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4193:
imul rdi, [rsp + 0 + 16] ; multiply by (array[z : k, A : h, B : g] k)[628, u, s] 
	jno .jump4194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4194:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump4195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4195:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4196: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	mov rax, [rel const616] ; 781
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4197:
	; Computing bound for 'F'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4198
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump4199
.jump4198:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump4199:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4200
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4200:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4201:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4202
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4202:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4203
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4203:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4204
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4204:
	imul rdi, [rsp + 0 + 16] ; multiply by (if false then A else h) 
	jno .jump4205
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4205:
	imul rdi, [rsp + 0 + 24] ; multiply by 781 
	jno .jump4206
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4206:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump4207: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 24], 1
	; Compare G to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4207 ; If G < bound, next iter
	mov qword [rsp + 24], 0 ; G = 0
	add qword [rsp + 16], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4207 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4207 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4207 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4196 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4196 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4196 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4196 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4208:
	cmp rax, [rsp + 32]
	jl .jump4209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4209:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4210:
	cmp rax, [rsp + 40]
	jl .jump4211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4211:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4212:
	cmp rax, [rsp + 48]
	jl .jump4213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4213:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4214:
	cmp rax, [rsp + 56]
	jl .jump4215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4215:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4169 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4216
	sub rsp, 8 ; Add alignment
	mov rax, [rel const617] ; 91.23
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4218
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4220:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4221
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4221:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4222:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4223
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4223:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump4224
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4224:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump4225
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4225:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump4226
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4226:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4227
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4227:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4228: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4228 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4228 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4228 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4228 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4219
.jump4218:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4229:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4230
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4230:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4231:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4232
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4232:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump4233
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4233:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump4234
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4234:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump4235
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4235:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4236
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4236:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4237: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const618] ; 224
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4237 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4237 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4237 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4237 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4219:
	jmp .jump4217
.jump4216:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4238
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const619] ; 998
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4240:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4241
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4241:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4242:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4243
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4243:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4244
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4244:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4245
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4245:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump4246
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4246:
	imul rdi, [rsp + 0 + 24] ; multiply by 998 
	jno .jump4247
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4247:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4248: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4248 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4248 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4248 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4248 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4239
.jump4238:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4249:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4250
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4250:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4251:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4252
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4252:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4253
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4253:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4254
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4254:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4255
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4255:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump4256
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4256:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4257: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4257 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4257 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4257 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4257 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4239:
.jump4217:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const327] ; 249
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4258
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4258:
	cmp rax, [rsp + 32]
	jl .jump4259
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4259:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4260
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4260:
	cmp rax, [rsp + 40]
	jl .jump4261
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4261:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4262
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4262:
	cmp rax, [rsp + 48]
	jl .jump4263
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4263:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4264
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4264:
	cmp rax, [rsp + 56]
	jl .jump4265
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4265:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4266
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4266:
	cmp rax, [rsp + 8]
	jl .jump4267
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4267:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4166
.jump4165:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4268:
	; Computing bound for 'A'
	mov rax, [rel const485] ; 96
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4269
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4269:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4270:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4271
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4271:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4272
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4272:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump4273
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4273:
	imul rdi, [rsp + 0 + 16] ; multiply by 96 
	jno .jump4274
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4274:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump4275
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4275:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4276: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const620] ; 26.81
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4277:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4278
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4278:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4279:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4280
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4280:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4281: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4281 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4281 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4281 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4281 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4282:
	cmp rax, [rsp + 8]
	jl .jump4283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4283:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4276 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4276 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4276 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4276 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4284
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4284:
	; Computing bound for 'A'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4285
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4285:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4286:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump4287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4287:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4288:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4289: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4289 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4289 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4290:
	cmp rax, [rsp + 16]
	jl .jump4291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4291:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4292:
	cmp rax, [rsp + 24]
	jl .jump4293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4293:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4294:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4295
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4295:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4296:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump4297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4297:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4298:
imul rdi, [rsp + 0 + 16] ; multiply by (array[y : w, z : p] f)[k, e] 
	jno .jump4299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4299:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump4300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4300:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4301: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4302
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const621] ; 40.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4304
	sub rsp, 16
	; Moving 16 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4306
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4306:
	cmp rax, [rsp + 8]
	jl .jump4307
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4307:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4305
.jump4304:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4308:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4309
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4309:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4310: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4310 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4310 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump4305:
	jmp .jump4303
.jump4302:
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4311
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4311:
	cmp rax, [rsp + 8]
	jl .jump4312
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4312:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4303:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4301 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4301 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4301 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4301 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4313:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4314
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4314:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4315:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4316
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4316:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump4317
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4317:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4318
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4318:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump4319
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4319:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4320
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4320:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4321: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4322
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4322:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4323:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4324
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4324:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4325
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4325:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump4326
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4326:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4327
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4327:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4328: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4328 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4328 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4328 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4329
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4329:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4330:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4331
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4331:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4332:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4333: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4333 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4333 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4333 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4333 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4334:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4335
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4335:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4336:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4337: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4337 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4337 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4337 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4338:
	cmp rax, [rsp + 24]
	jl .jump4339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4339:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4340:
	cmp rax, [rsp + 32]
	jl .jump4341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4341:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4342:
	cmp rax, [rsp + 40]
	jl .jump4343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4343:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4321 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4321 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4321 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4321 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4344
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4344:
	; Computing bound for 'A'
	mov rax, [rel const297] ; 952
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4345:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4346:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4347: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 0], 1
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4347 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4348
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4348:
	; Computing bound for 'y'
	mov rax, [rel const622] ; 771
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4349:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 771 
	jno .jump4350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4350:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[y : p] p) 
	jno .jump4351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4351:
	imul rdi, [rsp + 0 + 16] ; multiply by 952 
	jno .jump4352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4352:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4353:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4354: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4355
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4356
.jump4355:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4357:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4358
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4358:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4359:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4360
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4360:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4361: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4361 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4361 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4361 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4361 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump4356:
	sub rsp, 16
	; Moving 16 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4362:
	cmp rax, [rsp + 8]
	jl .jump4363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4363:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 24], 1
	; Compare B to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4354 ; If B < bound, next iter
	mov qword [rsp + 24], 0 ; B = 0
	add qword [rsp + 16], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4354 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4354 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4354 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 160
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 160 bytes from rsp to rax 
		mov r10, [rsp + 152]
		mov [rax + 152], r10
		mov r10, [rsp + 144]
		mov [rax + 144], r10
		mov r10, [rsp + 136]
		mov [rax + 136], r10
		mov r10, [rsp + 128]
		mov [rax + 128], r10
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const174] ; 970
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4364
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4364:
	cmp rax, [rsp + 8]
	jl .jump4365
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4365:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4166:
.jump3940:
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 88 ; Local variables
	pop rbp
	ret
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4366:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4367:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4368: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4369
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4370
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4370:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4371:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump4372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4372:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump4373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4373:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4374: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4374 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4374 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4375:
	cmp rax, [rsp + 16]
	jl .jump4376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4376:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4377:
	cmp rax, [rsp + 24]
	jl .jump4378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4378:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump4369:
	push rax
	pop rax
	cmp rax, 0
	je .jump4379
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump4381
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4383
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4383:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4384:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4385
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4385:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4386:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump4387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4387:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4388:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump4389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4389:
	imul rdi, [rsp + 0 + 24] ; multiply by z 
	jno .jump4390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4390:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4391: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4391 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4391 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4391 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4391 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const22] ; 131
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4392:
	cmp rax, [rsp + 32]
	jl .jump4393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4393:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4394:
	cmp rax, [rsp + 40]
	jl .jump4395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4395:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4396:
	cmp rax, [rsp + 48]
	jl .jump4397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4397:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4398:
	cmp rax, [rsp + 56]
	jl .jump4399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4399:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	jmp .jump4382
.jump4381:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4400
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump4400:
	push rax
.jump4382:
	pop rax
	cmp rax, 0
	je .jump4401
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4403
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump4403:
	push rax
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	jmp .jump4402
.jump4401:
	mov rax, [rel const1] ; False
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4404
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4404:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump4405
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4405:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4406: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4406 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4407
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4407:
	; Computing bound for 'O'
	mov rax, [rel const175] ; 469
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4408:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4409: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4409 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4409 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4410:
	cmp rax, [rsp + 8]
	jl .jump4411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4411:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4412:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4413
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4413:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4414:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4415:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump4416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4416:
imul rdi, [rsp + 0 + 16] ; multiply by (array[O : B] f)[(sum[O : 469, P : M] A)] 
	jno .jump4417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4417:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4418: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4418 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4418 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4418 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4402:
	jmp .jump4380
.jump4379:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4419
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4419:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4420:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4421
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4421:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4422
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4422:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4423
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4423:
	imul rdi, [rsp + 0 + 16] ; multiply by F 
	jno .jump4424
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4424:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4425: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4426
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump4426:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4425 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4425 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4425 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const623] ; 503
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4427
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4429:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4430
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4430:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4431:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4432: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4433
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4433:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4434:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4435: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4435 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4435 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4432 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4432 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4432 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump4428
.jump4427:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump4428:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	mov rax, [rel const624] ; 905
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4436
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4436:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4437:
	; Computing bound for 'O'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4438:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4439
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4439:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4440:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4441: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4441 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4441 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4441 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4442
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4442:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[O : E, P : e, Q : b] h) 
	jno .jump4443
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4443:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4444
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4444:
	imul rdi, [rsp + 0 + 16] ; multiply by 905 
	jno .jump4445
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4445:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4446: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4446 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4446 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4446 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4447:
	cmp rax, [rsp + 24]
	jl .jump4448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4448:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4449:
	cmp rax, [rsp + 32]
	jl .jump4450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4450:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4451:
	cmp rax, [rsp + 40]
	jl .jump4452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4452:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4453:
	cmp rax, [rsp + 24]
	jl .jump4454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4454:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4455:
	cmp rax, [rsp + 32]
	jl .jump4456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4456:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4457:
	cmp rax, [rsp + 40]
	jl .jump4458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4458:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4459:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4460
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4460:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4461:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump4462
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4462:
	imul rdi, [rsp + 0 + 8] ; multiply by (- A) 
	jno .jump4463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4463:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4464:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4465: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4465 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4465 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4465 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4380:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'N'
	add qword [rsp + 0], 1
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4368 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4466
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4466:
	cmp rax, [rsp + 8]
	jl .jump4467
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4467:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 208 ; Local variables
	pop rbp
	ret

y:
_y:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 16
	; Moving 16 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4468
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4470
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4470:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4471: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4471 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump4469
.jump4468:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4472
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4472:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4473:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4474
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4474:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4475:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4476: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4477
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4477:
	cmp rax, [rsp + 8]
	jl .jump4478
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4478:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4476 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4476 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4476 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4476 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump4469:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4479:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4480
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4480:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4481
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4481:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4482
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4482:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4483: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4483 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4483 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump4484
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4486:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4487
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4487:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4488
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump4488:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4489:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4490: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4490 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4490 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4490 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump4485
.jump4484:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4491
	mov rax, [rel const625] ; 44.25
	push rax
	jmp .jump4492
.jump4491:
	sub rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 40]
	call _y
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4493
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4493:
	cmp rax, [rsp + 8]
	jl .jump4494
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4494:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4492:
.jump4485:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const626] ; 16.36
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const627] ; 8.71
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4495
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4497:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4498
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4498:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4499:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump4500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4500:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump4501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4501:
	imul rdi, [rsp + 0 + 16] ; multiply by (- f) 
	jno .jump4502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4502:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4503: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4504
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4504:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4505:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4506
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4506:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4507:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump4508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4508:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4509:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4510:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4511:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4512: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4512 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4512 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4512 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4512 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4503 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4503 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4503 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4513
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4513:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4514:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4515
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4515:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4516:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4517:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump4518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4518:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump4519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4519:
	imul rdi, [rsp + 0 + 24] ; multiply by A 
	jno .jump4520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4520:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4521: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4521 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4521 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4521 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4521 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4522
	mov rax, [rel const256] ; 296
	push rax
	jmp .jump4523
.jump4522:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump4523:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4524:
	cmp rax, [rsp + 32]
	jl .jump4525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4525:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4526:
	cmp rax, [rsp + 40]
	jl .jump4527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4527:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4528:
	cmp rax, [rsp + 48]
	jl .jump4529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4529:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4530:
	cmp rax, [rsp + 56]
	jl .jump4531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4531:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4532
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4532:
	cmp rax, [rsp + 24]
	jl .jump4533
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4533:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4534
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4534:
	cmp rax, [rsp + 32]
	jl .jump4535
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4535:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4536
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4536:
	cmp rax, [rsp + 40]
	jl .jump4537
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4537:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump4538
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump4539
.jump4538:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump4539:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4540
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4540:
	cmp rax, [rsp + 32]
	jl .jump4541
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4541:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4542
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4542:
	cmp rax, [rsp + 40]
	jl .jump4543
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4543:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4544
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4544:
	cmp rax, [rsp + 48]
	jl .jump4545
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4545:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4546
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4546:
	cmp rax, [rsp + 56]
	jl .jump4547
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4547:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4548
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4548:
	cmp rax, [rsp + 32]
	jl .jump4549
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4549:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4550
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4550:
	cmp rax, [rsp + 40]
	jl .jump4551
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4551:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4552
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4552:
	cmp rax, [rsp + 48]
	jl .jump4553
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4553:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4554
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4554:
	cmp rax, [rsp + 56]
	jl .jump4555
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4555:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4556
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4558:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4559
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4559:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4560:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4561
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4561:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump4562
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4562:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump4563
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4563:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump4564
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4564:
	imul rdi, [rsp + 0 + 24] ; multiply by B 
	jno .jump4565
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4565:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4566: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4567
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4567:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4568:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4569
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4569:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4570
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4570:
	imul rdi, [rsp + 0 + 8] ; multiply by (p + H) 
	jno .jump4571
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4571:
	imul rdi, [rsp + 0 + 16] ; multiply by (u - k) 
	jno .jump4572
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4572:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4573: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4573 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4573 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4573 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4574
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4576
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4576:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4577:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4578
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4578:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump4579
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4579:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump4580
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4580:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump4581
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4581:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4582: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4582 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4582 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4582 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4575
.jump4574:
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
.jump4575:
	mov rdi, 96
	call _jpl_alloc
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 3
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4566 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4566 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4566 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4566 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4583
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4583:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4584:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4585: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4585 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4585 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const628] ; 451
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const629] ; 696
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4586
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4586:
	cmp rax, [rsp + 32]
	jl .jump4587
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4587:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4588
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4588:
	cmp rax, [rsp + 40]
	jl .jump4589
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4589:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4590
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4590:
	cmp rax, [rsp + 48]
	jl .jump4591
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4591:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4592
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4592:
	cmp rax, [rsp + 56]
	jl .jump4593
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4593:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4557
.jump4556:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4594:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump4595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4595:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4596: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4597
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4597:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4598:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4599
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4599:
	; Computing bound for 'G'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4600:
	cmp rax, [rsp + 8]
	jl .jump4601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4601:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4602:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- a[u]) 
	jno .jump4603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4603:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump4604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4604:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump4605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4605:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump4606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4606:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump4607: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4607 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4607 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4607 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4607 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4608:
	cmp rax, [rsp + 32]
	jl .jump4609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4609:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4610:
	cmp rax, [rsp + 40]
	jl .jump4611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4611:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4612:
	cmp rax, [rsp + 48]
	jl .jump4613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4613:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4614:
	cmp rax, [rsp + 56]
	jl .jump4615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4615:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4596 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump4557:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4616
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4616:
	cmp rax, [rsp + 8]
	jl .jump4617
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4617:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4496
.jump4495:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4618:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4619
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4619:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4620:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4621:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4622:
	imul rdi, [rsp + 0 + 16] ; multiply by (p + e) 
	jno .jump4623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4623:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4624: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4625
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4627
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump4628
.jump4627:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const301] ; 2.77
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump4628:
	pop rax
	cmp rax, 0
	je .jump4629
	mov rax, [rel const630] ; 29.38
	push rax
	jmp .jump4630
.jump4629:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump4630:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4626
.jump4625:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4631
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4631:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4632
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4632:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4633: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4633 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4634:
	cmp rax, [rsp + 8]
	jl .jump4635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4635:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4636:
	cmp rax, [rsp + 16]
	jl .jump4637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4637:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4638:
	cmp rax, [rsp + 24]
	jl .jump4639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4639:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump4626:
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4624 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4624 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4624 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4496:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4640
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	jmp .jump4641
.jump4640:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump4641:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4642
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4644
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4644:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4645:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump4646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4646:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump4647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4647:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4648: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const631] ; 39.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4649
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4650
.jump4649:
	mov rax, [rel const632] ; 2.4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4650:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4648 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4648 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4643
.jump4642:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4651
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4653:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4654
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4654:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4655:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump4656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4656:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4657:
	imul rdi, [rsp + 0 + 16] ; multiply by H 
	jno .jump4658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4658:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4659: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4659 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4659 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4659 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4652
.jump4651:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4660:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4661
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4661:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4662:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4663:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump4664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4664:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump4665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4665:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4666: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4666 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4666 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4666 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4652:
	mov rax, [rel const402] ; 159
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4667
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4667:
	cmp rax, [rsp + 24]
	jl .jump4668
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4668:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4669
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4669:
	cmp rax, [rsp + 32]
	jl .jump4670
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4670:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4671
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4671:
	cmp rax, [rsp + 40]
	jl .jump4672
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4672:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4673
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4673:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4674:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump4675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4675:
imul rdi, [rsp + 0 + 8] ; multiply by (if true then (array[J : I, K : A, L : H] h) else (array[J : f, K : e, L : A] f))[H, B, 159] 
	jno .jump4676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4676:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4677: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4678:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4679
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4679:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4680:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4681: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4681 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4681 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4681 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4677 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4677 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4643:
	mov rax, [rel const360] ; 64
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4682:
	cmp rax, [rsp + 16]
	jl .jump4683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4683:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4684:
	cmp rax, [rsp + 24]
	jl .jump4685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4685:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const633] ; 29.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4686:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4687
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4687:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump4688
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4688:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4689
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4689:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4690: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4691:
	cmp rax, [rsp + 32]
	jl .jump4692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4692:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4693
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4693:
	cmp rax, [rsp + 40]
	jl .jump4694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4694:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4695:
	cmp rax, [rsp + 48]
	jl .jump4696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4696:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4697:
	cmp rax, [rsp + 56]
	jl .jump4698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4698:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4699
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	jmp .jump4700
.jump4699:
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
.jump4700:
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump4701
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4702
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4702:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4703:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4704: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4704 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4704 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump4705
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4707
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4707:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4708:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4709
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4709:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4710:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump4711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4711:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4712:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4713:
	imul rdi, [rsp + 0 + 24] ; multiply by C 
	jno .jump4714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4714:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4715: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4715 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4715 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4715 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4715 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const262] ; 61
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4716:
	cmp rax, [rsp + 32]
	jl .jump4717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4717:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4718:
	cmp rax, [rsp + 40]
	jl .jump4719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4719:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4720:
	cmp rax, [rsp + 48]
	jl .jump4721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4721:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4722:
	cmp rax, [rsp + 56]
	jl .jump4723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4723:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4706
.jump4705:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4724
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4724:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4725:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4726
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4726:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4727:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4728:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump4729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4729:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump4730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4730:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4731:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4732: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4732 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4732 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4732 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4732 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4706:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4733:
	cmp rax, [rsp + 32]
	jl .jump4734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4734:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4735:
	cmp rax, [rsp + 40]
	jl .jump4736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4736:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4737:
	cmp rax, [rsp + 48]
	jl .jump4738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4738:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4739:
	cmp rax, [rsp + 56]
	jl .jump4740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4740:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump4701:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4690 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4690 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	mov rax, [rel const1] ; False
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4741
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4741:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4742:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump4743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4743:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4744:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4745: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4745 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4745 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const634] ; 384
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4746:
	cmp rax, [rsp + 16]
	jl .jump4747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4747:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4748:
	cmp rax, [rsp + 24]
	jl .jump4749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4749:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4750:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4751
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump4752
.jump4751:
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const635] ; 793
	push rax
	mov rax, [rel const248] ; 484
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4753
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4753:
	cmp rax, [rsp + 32]
	jl .jump4754
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4754:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4755
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4755:
	cmp rax, [rsp + 40]
	jl .jump4756
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4756:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4757
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4757:
	cmp rax, [rsp + 48]
	jl .jump4758
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4758:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4759
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4759:
	cmp rax, [rsp + 56]
	jl .jump4760
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4760:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4752:
	pop rax
	cmp rax, 0
	je .jump4761
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump4762
.jump4761:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump4762:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4763
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4763:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4764:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4765
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4765:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4766
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4766:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump4767
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4767:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (if (D < u) then (I < n) else d[w, H, 484, 793]) then B else p) 
	jno .jump4768
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4768:
imul rdi, [rsp + 0 + 24] ; multiply by (array[L : I, M : k] s)[384, p] 
	jno .jump4769
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4769:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4770: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4771
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4771:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4772
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4772:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4773: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4774
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4774:
	cmp rax, [rsp + 32]
	jl .jump4775
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4775:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4776
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4776:
	cmp rax, [rsp + 40]
	jl .jump4777
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4777:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4778
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4778:
	cmp rax, [rsp + 48]
	jl .jump4779
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4779:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4780
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4780:
	cmp rax, [rsp + 56]
	jl .jump4781
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4781:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4773 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4782:
	cmp rax, [rsp + 8]
	jl .jump4783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4783:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4770 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4770 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4770 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4770 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	lea rdi, [rsp + 48]
	call _y
	add rsp, 40
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4784
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4784:
	; Computing bound for 'L'
	mov rax, [rel const636] ; 66.05
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4785
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump4786
.jump4785:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump4786:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4787:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! (c > 66.05)) then e else s) 
	jno .jump4788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4788:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4789:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4790: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4791:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4792:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4793
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4793:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (K / A) 
	jno .jump4794
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4794:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump4795
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4795:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4796: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4796 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4796 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4790 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4790 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4797:
	cmp rax, [rsp + 16]
	jl .jump4798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4798:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4799:
	cmp rax, [rsp + 24]
	jl .jump4800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4800:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4801:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4802
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4802:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump4803
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4803:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump4804
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4804:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4805: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const637] ; 64.47
	push rax
	mov rax, [rel const638] ; 52.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4805 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4805 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump4806
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4808
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4810:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4811: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const639] ; 60.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4811 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4809
.jump4808:
	mov rax, [rel const640] ; 81.45
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4809:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4812
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4812:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4813: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4813 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4807
.jump4806:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4814
	mov rax, [rel const641] ; 27.08
	push rax
	jmp .jump4815
.jump4814:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump4815:
	mov rax, [rel const642] ; 3.76
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4816
	mov rax, [rel const643] ; 9.61
	push rax
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4818:
	cmp rax, [rsp + 16]
	jl .jump4819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4819:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4820:
	cmp rax, [rsp + 24]
	jl .jump4821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4821:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4822:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4823
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4823:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4824:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4825:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4826:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4827:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4828: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const644] ; 84.52
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4828 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4828 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4828 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4829
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4829:
	cmp rax, [rsp + 24]
	jl .jump4830
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4830:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4831
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4831:
	cmp rax, [rsp + 32]
	jl .jump4832
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4832:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4833
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4833:
	cmp rax, [rsp + 40]
	jl .jump4834
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4834:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4835:
	cmp rax, [rsp + 8]
	jl .jump4836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4836:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4817
.jump4816:
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump4837
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const645] ; 64.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const308] ; 53.45
	push rax
	jmp .jump4838
.jump4837:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const646] ; 56.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4839:
	cmp rax, [rsp + 8]
	jl .jump4840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4840:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const647] ; 4.94
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump4838:
.jump4817:
.jump4807:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4841:
	cmp rax, [rsp + 8]
	jl .jump4842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4842:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4843:
	; Computing bound for 'N'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4844
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump4845
.jump4844:
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4846
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump4846:
	cqo
	idiv r10
	push rax
.jump4845:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4847:
	; Computing bound for 'N'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4848
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump4849
.jump4848:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump4849:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4850
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4850:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4851:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4852
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4852:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump4853
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4853:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4854
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4854:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (! true) then (- K) else p) 
	jno .jump4855
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4855:
	imul rdi, [rsp + 0 + 24] ; multiply by (if (h >= n) then p else (p / u)) 
	jno .jump4856
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4856:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4857: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4857 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4857 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4857 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4857 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4858
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4858:
	cmp rax, [rsp + 32]
	jl .jump4859
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4859:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4860
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4860:
	cmp rax, [rsp + 40]
	jl .jump4861
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4861:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4862
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4862:
	cmp rax, [rsp + 48]
	jl .jump4863
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4863:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4864
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4864:
	cmp rax, [rsp + 56]
	jl .jump4865
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4865:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4866
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4866:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4867:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4868
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4868:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by H 
	jno .jump4869
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4869:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4870
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4870:
imul rdi, [rsp + 0 + 16] ; multiply by (array[L : I, M : G, N : (if (! true) then (- K) else p), O : (if (h >= n) then p else (p / u))] w)[C, C, g, w] 
	jno .jump4871
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4871:
	imul rdi, [rsp + 0 + 24] ; multiply by j[e] 
	jno .jump4872
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4872:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4873: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4874
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4874:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4875:
	; Computing bound for 'Q'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4876
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4878:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4879
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4879:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4880:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump4881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4881:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4882:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump4883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4883:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4884: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4884 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4884 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4884 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4877
.jump4876:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4885:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4886
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4886:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4887:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4888:
	imul rdi, [rsp + 0 + 8] ; multiply by L 
	jno .jump4889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4889:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4890:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4891: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4891 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4891 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4891 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4877:
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4892
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4892:
	cmp rax, [rsp + 24]
	jl .jump4893
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4893:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4894
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4894:
	cmp rax, [rsp + 32]
	jl .jump4895
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4895:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4896
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4896:
	cmp rax, [rsp + 40]
	jl .jump4897
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4897:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4898
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4898:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4899:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4900:
imul rdi, [rsp + 0 + 8] ; multiply by (if true then (array[P : O, Q : A, R : D] g) else (array[P : b, Q : L, R : b] B))[L, p, L] 
	jno .jump4901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4901:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump4902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4902:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4903:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4904: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const648] ; 27.61
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump4905
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4906
.jump4905:
	mov rax, [rel const649] ; 80.75
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4906:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4907:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4908
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4908:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4909:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by R 
	jno .jump4910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4910:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4911:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump4912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4912:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump4913: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const650] ; 14.87
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4913 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4913 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4913 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4914
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4914:
	cmp rax, [rsp + 24]
	jl .jump4915
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4915:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4916
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4916:
	cmp rax, [rsp + 32]
	jl .jump4917
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4917:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4918
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4918:
	cmp rax, [rsp + 40]
	jl .jump4919
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4919:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4904 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4904 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4904 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4904 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4873 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4873 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4873 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4873 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4920
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4922:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4923
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4923:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4924:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump4925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4925:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump4926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4926:
	imul rdi, [rsp + 0 + 16] ; multiply by H 
	jno .jump4927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4927:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4928: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4929
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4929:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4930:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump4931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4931:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump4932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4932:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4933: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const651] ; 94.05
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4934
	sub rsp, 8 ; Add alignment
	mov rax, [rel const652] ; 55.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump4934:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4933 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4933 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4928 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4928 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4928 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4935
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4935:
	cmp rax, [rsp + 24]
	jl .jump4936
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4936:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4937
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4937:
	cmp rax, [rsp + 32]
	jl .jump4938
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4938:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4939
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4939:
	cmp rax, [rsp + 40]
	jl .jump4940
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4940:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	push rax
	jmp .jump4921
.jump4920:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4941
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4941:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4942:
	; Computing bound for 'M'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4943:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4944
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4944:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4945:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4946
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4946:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4947: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4947 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4947 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4947 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4947 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4948
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4948:
	; Computing bound for 'L'
	mov rax, [rel const653] ; 143
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4949:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 143 
	jno .jump4950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4950:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[L : B, M : G, N : p, O : (s - I)] f) 
	jno .jump4951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4951:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4952:
	imul rdi, [rsp + 0 + 24] ; multiply by H 
	jno .jump4953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4953:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4954: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4955:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4956
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4956:
	; Computing bound for 'P'
	mov rax, [rel const654] ; 317
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4957:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 317 
	jno .jump4958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4958:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4959:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump4960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4960:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4961: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4961 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4961 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4961 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4954 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4954 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4954 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4954 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4962:
	cmp rax, [rsp + 32]
	jl .jump4963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4963:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4964:
	cmp rax, [rsp + 40]
	jl .jump4965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4965:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4966:
	cmp rax, [rsp + 48]
	jl .jump4967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4967:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4968:
	cmp rax, [rsp + 56]
	jl .jump4969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4969:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const42] ; 180
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4970:
	cmp rax, [rsp + 24]
	jl .jump4971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4971:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4972:
	cmp rax, [rsp + 32]
	jl .jump4973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4973:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4974:
	cmp rax, [rsp + 40]
	jl .jump4975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4975:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const324] ; 603
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4976
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4976:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4977:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump4978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4978:
	imul rdi, [rsp + 0 + 8] ; multiply by 603 
	jno .jump4979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4979:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4980: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4980 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4980 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump4981
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump4982
.jump4981:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
.jump4982:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4983:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4984
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4984:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4985:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4986
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4986:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump4987
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4987:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4988
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4988:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump4989
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4989:
	imul rdi, [rsp + 0 + 24] ; multiply by (if i(c) then C else C) 
	jno .jump4990
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump4990:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4991: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4992
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4993
.jump4992:
	mov rax, [rel const655] ; 15.84
	push rax
.jump4993:
	mov rax, [rel const656] ; 75.15
	push rax
	mov rax, [rel const657] ; 97.9
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4994:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4995
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump4995:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4996:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4997: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const658] ; 41.95
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4997 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4997 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4997 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4991 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4991 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4991 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4991 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4998
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump4998:
	cmp rax, [rsp + 32]
	jl .jump4999
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump4999:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5000
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5000:
	cmp rax, [rsp + 40]
	jl .jump5001
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5001:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5002
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5002:
	cmp rax, [rsp + 48]
	jl .jump5003
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5003:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5004
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5004:
	cmp rax, [rsp + 56]
	jl .jump5005
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5005:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5006:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5007
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5007:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5008
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump5008:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5009
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump5010
.jump5009:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump5010:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5011
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5011:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5012:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5013
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5013:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5014
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5014:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5015
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5015:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump5016
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5016:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5017: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5017 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5017 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5017 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5018:
	cmp rax, [rsp + 24]
	jl .jump5019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5019:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5020:
	cmp rax, [rsp + 32]
	jl .jump5021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5021:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5022:
	cmp rax, [rsp + 40]
	jl .jump5023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5023:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5024:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5025
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5025:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5026
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5026:
imul rdi, [rsp + 0 + 8] ; multiply by (((array[L : p, M : f, N : f] h)[k, n, s] - (if (G < H) then g else h)) + (I / k)) 
	jno .jump5027
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5027:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump5028
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5028:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump5029
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5029:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5030: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump5031
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5033
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5033:
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5034
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5034:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5035:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5036
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5036:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5037: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5037 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5037 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5037 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5038:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5039
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5039:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5040:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump5041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5041:
	imul rdi, [rsp + 0 + 8] ; multiply by O 
	jno .jump5042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5042:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[P : L, Q : I, R : M] h) 
	jno .jump5043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5043:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump5044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5044:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5045: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const659] ; 34.55
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5045 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5045 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5045 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5045 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5032
.jump5031:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5046
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5046:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5047:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5048
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5048:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5049:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5050:
	imul rdi, [rsp + 0 + 8] ; multiply by (u - M) 
	jno .jump5051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5051:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump5052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5052:
	imul rdi, [rsp + 0 + 24] ; multiply by A 
	jno .jump5053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5053:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5054: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5055
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5055:
	cmp rax, [rsp + 32]
	jl .jump5056
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5056:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5057
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5057:
	cmp rax, [rsp + 40]
	jl .jump5058
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5058:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5059
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5059:
	cmp rax, [rsp + 48]
	jl .jump5060
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5060:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5061
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5061:
	cmp rax, [rsp + 56]
	jl .jump5062
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5062:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5063
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5065
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5065:
	cmp rax, [rsp + 16]
	jl .jump5066
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5066:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5067
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5067:
	cmp rax, [rsp + 24]
	jl .jump5068
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5068:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5064
.jump5063:
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5069
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5069:
	cmp rax, [rsp + 16]
	jl .jump5070
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5070:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5071
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5071:
	cmp rax, [rsp + 24]
	jl .jump5072
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5072:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5064:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5054 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5054 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5054 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5054 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5032:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5030 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5030 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5030 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5030 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
.jump4921:
	pop rax
	cmp rax, 0
	je .jump5073
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5075:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump5076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5076:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5077: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5078
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump5079
.jump5078:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5080
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5080:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5081:
	; Computing bound for 'M'
	mov rax, [rel const660] ; 103
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5082
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5082:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 103 
	jno .jump5083
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5083:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump5084
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5084:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump5085
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5085:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5086: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const661] ; 0.55
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5086 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5086 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5086 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5087:
	cmp rax, [rsp + 24]
	jl .jump5088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5088:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5089:
	cmp rax, [rsp + 32]
	jl .jump5090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5090:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5091:
	cmp rax, [rsp + 40]
	jl .jump5092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5092:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5079:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5093:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5094
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5094:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5095:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5096
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5096:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by H 
	jno .jump5097
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5097:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5098
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5098:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump5099
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5099:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump5100
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5100:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5101: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5102
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5102:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5103:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5104
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5104:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5105: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const662] ; 77.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5105 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5105 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5105 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5101 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5101 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5101 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5101 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5106:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5107
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5107:
	cmp rax, [rsp + 32]
	jl .jump5108
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5108:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5109
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5109:
	cmp rax, [rsp + 40]
	jl .jump5110
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5110:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5111
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5111:
	cmp rax, [rsp + 48]
	jl .jump5112
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5112:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5113
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5113:
	cmp rax, [rsp + 56]
	jl .jump5114
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5114:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5115
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5115:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5116: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5116 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8 ; Add alignment
	mov rax, [rel const663] ; 30.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump5117
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump5117:
	push rax
	pop rax
	cmp rax, 0
	je .jump5118
	sub rsp, 16
	; Moving 16 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5120
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5120:
	cmp rax, [rsp + 8]
	jl .jump5121
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5121:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5119
.jump5118:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump5119:
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5077 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5074
.jump5073:
	mov rax, [rel const664] ; 51.99
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5122
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	jmp .jump5123
.jump5122:
	sub rsp, 32
	; Moving 32 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5124:
	cmp rax, [rsp + 8]
	jl .jump5125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5125:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5123:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5126:
	cmp rax, [rsp + 24]
	jl .jump5127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5127:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5128:
	cmp rax, [rsp + 32]
	jl .jump5129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5129:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5130:
	cmp rax, [rsp + 40]
	jl .jump5131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5131:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5132
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump5133
.jump5132:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5134:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5135: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const665] ; 94.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5135 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	mov rax, [rel const666] ; 19.85
	push rax
	mov rax, [rel const667] ; 33.29
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump5133:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5136
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5136:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5137:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5138:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump5139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5139:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5140: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const668] ; 98.97
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5140 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5140 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5141:
	cmp rax, [rsp + 16]
	jl .jump5142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5142:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5143:
	cmp rax, [rsp + 24]
	jl .jump5144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5144:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5145:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5146
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5146:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5147:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5148
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5148:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5149: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const669] ; 5.32
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5149 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5149 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5149 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5149 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const670] ; 7.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5150:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5151
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5151:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5152:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump5153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5153:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump5154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5154:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5155:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5156: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5156 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5156 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5156 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const20] ; 546
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5157
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5157:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5158:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5159
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5159:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5160:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5161:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump5162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5162:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump5163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5163:
	imul rdi, [rsp + 0 + 24] ; multiply by C 
	jno .jump5164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5164:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5165: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5165 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5165 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5165 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5165 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5166
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump5167
.jump5166:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump5167:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5168:
	cmp rax, [rsp + 32]
	jl .jump5169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5169:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5170:
	cmp rax, [rsp + 40]
	jl .jump5171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5171:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5172:
	cmp rax, [rsp + 48]
	jl .jump5173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5173:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5174:
	cmp rax, [rsp + 56]
	jl .jump5175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5175:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5176
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5176:
	cmp rax, [rsp + 24]
	jl .jump5177
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5177:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5178
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5178:
	cmp rax, [rsp + 32]
	jl .jump5179
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5179:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5180
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5180:
	cmp rax, [rsp + 40]
	jl .jump5181
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5181:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5182
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5184:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5185
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5185:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5186:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5187
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5187:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5188
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5188:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5189
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5189:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump5190
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5190:
	imul rdi, [rsp + 0 + 24] ; multiply by I 
	jno .jump5191
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5191:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5192: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const671] ; 59.73
	push rax
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5192 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5192 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5192 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5192 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5183
.jump5182:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5193
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5195:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5196
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5196:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump5197
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5197:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump5198
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5198:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5199: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	mov rax, [rel const624] ; 905
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5200
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5200:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5201:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5202
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5202:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5203:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump5204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5204:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump5205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5205:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5206:
	imul rdi, [rsp + 0 + 24] ; multiply by 905 
	jno .jump5207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5207:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5208: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const672] ; 37.02
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5208 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5208 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5208 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5208 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5199 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5199 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5209
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5209:
	cmp rax, [rsp + 16]
	jl .jump5210
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5210:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5211
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5211:
	cmp rax, [rsp + 24]
	jl .jump5212
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5212:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5194
.jump5193:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5213:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5214
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5214:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5215:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5216
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5216:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5217
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5217:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump5218
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5218:
	imul rdi, [rsp + 0 + 16] ; multiply by H 
	jno .jump5219
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5219:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump5220
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5220:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5221: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5222
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5222:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5223:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5224
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5224:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5225:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5226:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump5227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5227:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump5228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5228:
	imul rdi, [rsp + 0 + 24] ; multiply by O 
	jno .jump5229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5229:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5230: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const673] ; 68.68
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5230 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5230 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5230 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5230 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5221 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5221 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5221 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5221 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5231
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5231:
	cmp rax, [rsp + 32]
	jl .jump5232
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5232:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5233
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5233:
	cmp rax, [rsp + 40]
	jl .jump5234
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5234:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5235
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5235:
	cmp rax, [rsp + 48]
	jl .jump5236
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5236:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5237
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5237:
	cmp rax, [rsp + 56]
	jl .jump5238
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5238:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5194:
.jump5183:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5239
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5239:
	cmp rax, [rsp + 32]
	jl .jump5240
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5240:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5241
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5241:
	cmp rax, [rsp + 40]
	jl .jump5242
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5242:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5243
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5243:
	cmp rax, [rsp + 48]
	jl .jump5244
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5244:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5245
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5245:
	cmp rax, [rsp + 56]
	jl .jump5246
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5246:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump5074:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 88 ; Local variables
	pop rbp
	ret
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 104 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5247
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump5248
.jump5247:
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
.jump5248:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5249
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5249:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5250:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5251
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5251:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump5252
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5252:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump5253
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5253:
	imul rdi, [rsp + 0 + 16] ; multiply by (if true then C else n) 
	jno .jump5254
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5254:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5255: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 40]
	call _y
	add rsp, 40
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5255 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5255 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5255 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160 ; Local variables
	pop rbp
	ret

z:
_z:
	push rbp
	mov rbp, rsp
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const689] ; 13.77
	push rax
	mov rax, [rel const690] ; 19.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5432
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5433
.jump5432:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump5433:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5434
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump5434:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5435:
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5436:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5437: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const691] ; 707
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5438
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump5438:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5437 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5439
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5439:
	; Computing bound for 'B'
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5440:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5441
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5441:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5442
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5442:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5443
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5443:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5444: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5444 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5444 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5445
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump5446
.jump5445:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5447
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5447:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5448:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5449
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5449:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5450: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5450 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5450 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5450 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump5446:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5451:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5452
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5452:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5453: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5453 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5453 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5453 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5453 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5454:
	cmp rax, [rsp + 32]
	jl .jump5455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5455:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5456:
	cmp rax, [rsp + 40]
	jl .jump5457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5457:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5458:
	cmp rax, [rsp + 48]
	jl .jump5459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5459:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5460:
	cmp rax, [rsp + 56]
	jl .jump5461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5461:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5462
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump5463
.jump5462:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5464
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	xor rax, 1
	push rax
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	jmp .jump5465
.jump5464:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	jne .jump5466
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const692] ; 70.58
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump5466:
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5467:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5468
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5468:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5469:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5470:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5471:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5472:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5473: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const693] ; 29.53
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5473 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5473 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5473 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5465:
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
.jump5463:
	pop rax
	cmp rax, 0
	jne .jump5474
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const694] ; 865
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5475
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5475:
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5476
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5476:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5477: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5478
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5480:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5481
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5481:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5482:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump5483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5483:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump5484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5484:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump5485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5485:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5486: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5486 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5486 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5486 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5487
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5487:
	cmp rax, [rsp + 24]
	jl .jump5488
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5488:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5489
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5489:
	cmp rax, [rsp + 32]
	jl .jump5490
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5490:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5491
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5491:
	cmp rax, [rsp + 40]
	jl .jump5492
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5492:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5479
.jump5478:
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5479:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5493
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5493:
	cmp rax, [rsp + 8]
	jl .jump5494
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5494:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5477 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5495:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5496:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5497: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5498:
	cmp rax, [rsp + 8]
	jl .jump5499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5499:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5497 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5500
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5500:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5501:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump5502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5502:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[A : b] j[p]) 
	jno .jump5503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5503:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[A : n] (if ((- z()) == (c - z())) then (array[B : u, C : A, D : w] j)[(- s), n, h] else a)[w]) 
	jno .jump5504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5504:
	imul rdi, [rsp + 0 + 24] ; multiply by 865 
	jno .jump5505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5505:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5506: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5507
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5507:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (e * p) 
	jno .jump5508
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5508:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump5509: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5510:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5511
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5511:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5512:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5513
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5513:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5514
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5514:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5515
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5515:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump5516
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5516:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump5517
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5517:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump5518: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5518 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5518 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5518 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5518 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5509 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5519:
	cmp rax, [rsp + 8]
	jl .jump5520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5520:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5521:
	cmp rax, [rsp + 32]
	jl .jump5522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5522:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5523:
	cmp rax, [rsp + 40]
	jl .jump5524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5524:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5525:
	cmp rax, [rsp + 48]
	jl .jump5526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5526:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5527:
	cmp rax, [rsp + 56]
	jl .jump5528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5528:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5506 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5506 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5506 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5506 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5529:
	cmp rax, [rsp + 32]
	jl .jump5530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5530:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5531:
	cmp rax, [rsp + 40]
	jl .jump5532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5532:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5533:
	cmp rax, [rsp + 48]
	jl .jump5534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5534:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5535:
	cmp rax, [rsp + 56]
	jl .jump5536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5536:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump5474:
	push rax
	pop rax
	cmp rax, 0
	jne .jump5537
	lea rdi, [rel const695] ; 'A'
	call _fail_assertion
.jump5537:
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5538
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5538:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5539:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5540:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5541:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5542: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5543
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5543:
	cmp rax, [rsp + 8]
	jl .jump5544
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5544:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5542 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5542 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const696] ; 48.49
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump5545
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5547
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5547:
	; Computing bound for 'F'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5548
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5548:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5549:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump5550: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5550 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5550 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5551:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[F : n, G : s] w) 
	jno .jump5552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5552:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump5553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5553:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump5554: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5555:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5556
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5556:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5557
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5557:
	imul rdi, [rsp + 0 + 8] ; multiply by (e - b) 
	jno .jump5558
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5558:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump5559: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'I'
	add qword [rsp + 8], 1
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5559 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5559 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5560
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5560:
	cmp rax, [rsp + 16]
	jl .jump5561
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5561:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5562
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5562:
	cmp rax, [rsp + 24]
	jl .jump5563
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5563:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5564
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5564:
	cmp rax, [rsp + 32]
	jl .jump5565
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5565:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5566
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5566:
	cmp rax, [rsp + 40]
	jl .jump5567
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5567:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5568
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5568:
	cmp rax, [rsp + 48]
	jl .jump5569
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5569:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5570
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5570:
	cmp rax, [rsp + 56]
	jl .jump5571
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5571:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5554 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5554 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5546
.jump5545:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5572
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5572:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5573:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump5574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5574:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5575:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump5576: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump5577
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5579
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump5579:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5580:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5581
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5581:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5582:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump5583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5583:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump5584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5584:
	imul rdi, [rsp + 0 + 16] ; multiply by (e / G) 
	jno .jump5585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5585:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump5586: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5586 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5586 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5586 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5578
.jump5577:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5587:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5588
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5588:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5589:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump5590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5590:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5591:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5592:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump5593: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5593 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5593 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5593 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5578:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5594
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5594:
	cmp rax, [rsp + 24]
	jl .jump5595
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5595:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5596
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5596:
	cmp rax, [rsp + 32]
	jl .jump5597
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5597:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5598
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5598:
	cmp rax, [rsp + 40]
	jl .jump5599
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5599:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5576 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5576 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5546:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5600:
	cmp rax, [rsp + 16]
	jl .jump5601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5601:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5602:
	cmp rax, [rsp + 24]
	jl .jump5603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5603:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5604
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5605
.jump5604:
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
.jump5605:
	sub rsp, 40
	; Moving 40 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	sub rsp, 24
	; Moving 24 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5606:
	cmp rax, [rsp + 16]
	jl .jump5607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5607:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5608:
	cmp rax, [rsp + 24]
	jl .jump5609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5609:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 160 ; Local variables
	pop rbp
	ret

H:
_H:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	mov rax, [rel const722] ; 928
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6266
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6266:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6267:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6268
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6268:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6269:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6270:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump6271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6271:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump6272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6272:
	imul rdi, [rsp + 0 + 24] ; multiply by 928 
	jno .jump6273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6273:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump6274: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6275:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6276
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6276:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6277
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6277:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6278
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6278:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump6279: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6280:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6281
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6281:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump6282
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6282:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump6283
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6283:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump6284: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6284 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6284 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6279 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6279 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6285:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6286
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6288:
	; Computing bound for 'N'
	mov rax, [rel const82] ; 329
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6289
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6289:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6290:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof D 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump6291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6291:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 329) 
	jno .jump6292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6292:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump6293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6293:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump6294: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6294 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6294 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6294 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6295
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6295:
	cmp rax, [rsp + 24]
	jl .jump6296
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6296:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6297
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6297:
	cmp rax, [rsp + 32]
	jl .jump6298
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6298:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6299
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6299:
	cmp rax, [rsp + 40]
	jl .jump6300
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6300:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	jmp .jump6287
.jump6286:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump6287:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6301
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6301:
	cmp rax, [rsp + 16]
	jl .jump6302
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6302:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6303
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6303:
	cmp rax, [rsp + 24]
	jl .jump6304
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6304:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6274 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6274 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6274 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6274 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6305
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6305:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6306:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6307
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6307:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6308:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump6309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6309:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump6310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6310:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump6311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6311:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump6312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6312:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump6313: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6313 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6313 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6313 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6313 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6314
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6316
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6318
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump6320
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	call _H
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6322:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6323
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6323:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump6324
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6324:
	imul rdi, [rsp + 0 + 8] ; multiply by H() 
	jno .jump6325
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6325:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6326: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6326 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6326 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump6327
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6329:
	; Computing bound for 'V'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6330:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6331: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6331 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6332
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6332:
	; Computing bound for 'U'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6333
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6333:
	; Computing bound for 'T'
	call _H
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6334:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6335: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6335 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6335 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6336:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6337
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6337:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump6338
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6338:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[T : H(), U : w] K) 
	jno .jump6339
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6339:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[T : M] S) 
	jno .jump6340
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6340:
	imul rdi, [rsp + 0 + 24] ; multiply by C 
	jno .jump6341
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6341:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6342: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6342 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6342 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6342 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6342 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6343
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6343:
	cmp rax, [rsp + 32]
	jl .jump6344
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6344:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6345
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6345:
	cmp rax, [rsp + 40]
	jl .jump6346
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6346:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6347
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6347:
	cmp rax, [rsp + 48]
	jl .jump6348
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6348:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6349
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6349:
	cmp rax, [rsp + 56]
	jl .jump6350
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6350:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6328
.jump6327:
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump6328:
	jmp .jump6321
.jump6320:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6351
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump6352
.jump6351:
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump6352:
.jump6321:
	jmp .jump6319
.jump6318:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6353:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6354
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6354:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump6355
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6355:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump6356
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6356:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6357: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const343] ; 999
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6358
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump6358:
	push rax
	pop rax
	cmp rax, 0
	je .jump6359
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump6360
.jump6359:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump6360:
	pop rax
	cmp rax, 0
	je .jump6361
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6363:
	cmp rax, [rsp + 16]
	jl .jump6364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6364:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6365:
	cmp rax, [rsp + 24]
	jl .jump6366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6366:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6362
.jump6361:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6367
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6369:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump6370: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const723] ; 15.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6370 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump6368
.jump6367:
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6371:
	cmp rax, [rsp + 16]
	jl .jump6372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6372:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6373:
	cmp rax, [rsp + 24]
	jl .jump6374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6374:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6368:
.jump6362:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6357 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6357 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6319:
	jmp .jump6317
.jump6316:
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump6317:
	jmp .jump6315
.jump6314:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6375
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump6375:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6376:
	; Computing bound for 'T'
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6377
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6377:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by H() 
	jno .jump6378
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6378:
	imul rdi, [rsp + 0 + 8] ; multiply by (n % b) 
	jno .jump6379
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6379:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6380: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6381
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6381:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6382:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6383
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6383:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump6384: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const724] ; 29.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'X'
	add qword [rsp + 16], 1
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6384 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6384 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6384 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const725] ; 62.7
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6380 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6380 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6385:
	cmp rax, [rsp + 8]
	jl .jump6386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6386:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6387
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const726] ; 138
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6389:
	cmp rax, [rsp + 8]
	jl .jump6390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6390:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6388
.jump6387:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6391
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6391:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6392
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6392:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6393: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6394:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6395
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6395:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by R 
	jno .jump6396
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6396:
	imul rdi, [rsp + 0 + 8] ; multiply by J 
	jno .jump6397
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6397:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump6398: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'V'
	add qword [rsp + 8], 1
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6398 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6398 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6393 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6399:
	cmp rax, [rsp + 8]
	jl .jump6400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6400:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const473] ; 785
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6401:
	cmp rax, [rsp + 16]
	jl .jump6402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6402:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6403:
	cmp rax, [rsp + 24]
	jl .jump6404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6404:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6388:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6405
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	call _H
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6407:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6408
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6408:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6409:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump6410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6410:
	imul rdi, [rsp + 0 + 8] ; multiply by M 
	jno .jump6411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6411:
	imul rdi, [rsp + 0 + 16] ; multiply by H() 
	jno .jump6412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6412:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6413: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6413 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6413 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6413 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6414
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6414:
	cmp rax, [rsp + 24]
	jl .jump6415
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6415:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6416
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6416:
	cmp rax, [rsp + 32]
	jl .jump6417
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6417:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6418
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6418:
	cmp rax, [rsp + 40]
	jl .jump6419
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6419:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump6406
.jump6405:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump6420
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump6420:
	push rax
	pop rax
	cmp rax, 0
	je .jump6421
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump6422
.jump6421:
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump6422:
.jump6406:
	pop rax
	cmp rax, 0
	je .jump6423
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6425:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6426:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6427: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6427 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6428
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6428:
	cmp rax, [rsp + 8]
	jl .jump6429
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6429:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6430
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6430:
	cmp rax, [rsp + 8]
	jl .jump6431
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6431:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6424
.jump6423:
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump6424:
	mov rdi, 72
	call _jpl_alloc
	; Moving 72 bytes from rsp to rax 
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6432
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6432:
	cmp rax, [rsp + 8]
	jl .jump6433
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6433:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6315:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6434:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6435
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6435:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6436:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump6437: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'af'
	add qword [rsp + 16], 1
	; Compare af to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6437 ; If af < bound, next iter
	mov qword [rsp + 16], 0 ; af = 0
	add qword [rsp + 8], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6437 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6437 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add rsp, 184 ; Local variables
	pop rbp
	ret

I:
_I:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	push rdx
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32 ; Local variables
	pop rbp
	ret
	sub rsp, 40
	; Moving 40 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	sub rsp, 16
	; Moving 16 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6438
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6438:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6439:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump6440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6440:
	imul rdi, [rsp + 0 + 8] ; multiply by V 
	jno .jump6441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6441:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6442: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6443:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6444
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6444:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6445:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6446
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6446:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6447: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'ac'
	add qword [rsp + 24], 1
	; Compare ac to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6447 ; If ac < bound, next iter
	mov qword [rsp + 24], 0 ; ac = 0
	add qword [rsp + 16], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6447 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6447 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6447 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6448
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6448:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6449:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6450: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6450 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6450 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Y'
	add qword [rsp + 8], 1
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6442 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6442 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const727] ; 92.09
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const728] ; 40.97
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6451
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6451:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6452:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6453
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6453:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6454:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6455: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const729] ; 62.16
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6455 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6455 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6455 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6455 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const730] ; 96.61
	push rax
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6456
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6456:
	cmp rax, [rsp + 8]
	jl .jump6457
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6457:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const731] ; 51.54
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6458
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6458:
	cmp rax, [rsp + 8]
	jl .jump6459
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6459:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6460
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump6461
.jump6460:
	mov rax, [rel const732] ; 25.66
	push rax
.jump6461:
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const733] ; 49.43
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const734] ; 852
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6462
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6462:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6463:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6464
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6464:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6465:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump6466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6466:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump6467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6467:
	imul rdi, [rsp + 0 + 16] ; multiply by R 
	jno .jump6468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6468:
	imul rdi, [rsp + 0 + 24] ; multiply by T 
	jno .jump6469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6469:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6470: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6470 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6470 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6470 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6470 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 56 to rsp + 56 
		mov r10, [rsp + 56 + 0]
		mov [rsp + 56 + 0], r10
	add rsp, 56
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6471:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6472
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6472:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6473:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6474
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6474:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by S 
	jno .jump6475
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6475:
	imul rdi, [rsp + 0 + 8] ; multiply by V 
	jno .jump6476
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6476:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump6477
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6477:
imul rdi, [rsp + 0 + 24] ; multiply by G {N, (array[X : Q, Y : b, Z : R, aa : T] z()), 852, n}.d 
	jno .jump6478
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6478:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6479: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6480
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6480:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6481:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6482
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6482:
	; Computing bound for 'ab'
	sub rsp, 8
	sub rsp, 8 ; Add alignment
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const735] ; 107
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rsi
	pop rdx
	lea rdi, [rsp + 72]
	call _I
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6483:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by I(J, (107 <= u), N, P).a 
	jno .jump6484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6484:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (n + aa)) 
	jno .jump6485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6485:
	imul rdi, [rsp + 0 + 16] ; multiply by V 
	jno .jump6486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6486:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump6487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6487:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump6488: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const736] ; 91.8
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6489
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6489:
	cmp rax, [rsp + 8]
	jl .jump6490
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6490:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6491:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6492
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6492:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump6493
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6493:
	imul rdi, [rsp + 0 + 8] ; multiply by ae 
	jno .jump6494
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6494:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump6495: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ag'
	add qword [rsp + 8], 1
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6495 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6495 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const356] ; 482
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6496
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6496:
	cmp rax, [rsp + 16]
	jl .jump6497
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6497:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6498
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6498:
	cmp rax, [rsp + 24]
	jl .jump6499
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6499:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const737] ; 1.98
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 24], 1
	; Compare ae to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6488 ; If ae < bound, next iter
	mov qword [rsp + 24], 0 ; ae = 0
	add qword [rsp + 16], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6488 ; If ad < bound, next iter
	mov qword [rsp + 16], 0 ; ad = 0
	add qword [rsp + 8], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6488 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6488 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6479 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6479 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6479 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6479 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6500
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6501:
	; Computing bound for 'Z'
	sub rsp, 8 ; Add alignment
	mov rax, [rel const738] ; 23.03
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump6502
	mov rax, [rel const739] ; 364
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6504
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6506
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6506:
	push rax
	jmp .jump6505
.jump6504:
	mov rax, [rel const11] ; True
	push rax
.jump6505:
	pop rax
	cmp rax, 0
	je .jump6507
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6509:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6510
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6510:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6511:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6512
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6512:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6513
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6513:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6514
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6514:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump6515
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6515:
	imul rdi, [rsp + 0 + 24] ; multiply by S 
	jno .jump6516
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6516:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6517: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6517 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6517 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6517 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6517 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6508
.jump6507:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6518
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6520:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6521
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6521:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6522:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6523
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6523:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by L 
	jno .jump6524
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6524:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump6525
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6525:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump6526
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6526:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump6527
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6527:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6528: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6528 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6528 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6528 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6528 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6519
.jump6518:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6529:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6530
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6530:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6531:
	; Computing bound for 'X'
	mov rax, [rel const740] ; 873
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6532
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6532:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 873 
	jno .jump6533
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6533:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump6534
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6534:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump6535
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6535:
	imul rdi, [rsp + 0 + 24] ; multiply by Q 
	jno .jump6536
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6536:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6537: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6537 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6537 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6537 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6537 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6519:
.jump6508:
	jmp .jump6503
.jump6502:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6538
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6540
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6542:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6543
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6543:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6544:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6545
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6545:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump6546
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6546:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump6547
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6547:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump6548
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6548:
	imul rdi, [rsp + 0 + 24] ; multiply by K 
	jno .jump6549
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6549:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6550: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6550 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6550 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6550 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6550 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6541
.jump6540:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6551:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6552
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6552:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6553:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6554
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6554:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6555
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6555:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump6556
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6556:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump6557
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6557:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump6558
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6558:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6559: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6559 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6559 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6559 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6559 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6541:
	jmp .jump6539
.jump6538:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6560:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6561
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6561:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6562:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6563
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6563:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump6564
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6564:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump6565
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6565:
	imul rdi, [rsp + 0 + 16] ; multiply by R 
	jno .jump6566
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6566:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump6567
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6567:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6568: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6568 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6568 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6568 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6568 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6539:
.jump6503:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const741] ; 19
	push rax
	mov rax, [rel const132] ; 739
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6569
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6569:
	cmp rax, [rsp + 32]
	jl .jump6570
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6570:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6571
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6571:
	cmp rax, [rsp + 40]
	jl .jump6572
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6572:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6573
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6573:
	cmp rax, [rsp + 48]
	jl .jump6574
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6574:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6575
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6575:
	cmp rax, [rsp + 56]
	jl .jump6576
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6576:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6577
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6577:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6578:
	; Computing bound for 'X'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6579
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6579:
	cmp rax, [rsp + 8]
	jl .jump6580
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6580:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6581
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6581:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump6582: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6583
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6583:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6584:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump6585: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6586
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6586:
	cmp rax, [rsp + 16]
	jl .jump6587
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6587:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6588
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6588:
	cmp rax, [rsp + 24]
	jl .jump6589
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6589:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 64
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 64
	; Moving 64 bytes from rax to rsp 
		mov r10, [rax + 56]
		mov [rsp + 56], r10
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 40 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 32]
		mov [rsp + 24 + 32], r10
		mov r10, [rsp + 8 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6590:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6591
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6591:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6592:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6593
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6593:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump6594: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'ag'
	add qword [rsp + 24], 1
	; Compare ag to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6594 ; If ag < bound, next iter
	mov qword [rsp + 24], 0 ; ag = 0
	add qword [rsp + 16], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6594 ; If af < bound, next iter
	mov qword [rsp + 16], 0 ; af = 0
	add qword [rsp + 8], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6594 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6594 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6595
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6595:
	cmp rax, [rsp + 32]
	jl .jump6596
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6596:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6597
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6597:
	cmp rax, [rsp + 40]
	jl .jump6598
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6598:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6599
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6599:
	cmp rax, [rsp + 48]
	jl .jump6600
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6600:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6601
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6601:
	cmp rax, [rsp + 56]
	jl .jump6602
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6602:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6585 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6585 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6582 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6582 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6582 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6582 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump6500:
	push rax
	pop rax
	cmp rax, 0
	jne .jump6603
	lea rdi, [rel const742] ; 'X'
	call _fail_assertion
.jump6603:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const743] ; 13
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const744] ; 31.63
	push rax
	mov rax, [rel const745] ; 64.9
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6604
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6606:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6607
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6607:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6608:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump6609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6609:
	imul rdi, [rsp + 0 + 8] ; multiply by L 
	jno .jump6610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6610:
	imul rdi, [rsp + 0 + 16] ; multiply by S 
	jno .jump6611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6611:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6612: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6613
	sub rsp, 40
	; Moving 40 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 128 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 128 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 128 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	jmp .jump6614
.jump6613:
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
.jump6614:
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ab'
	add qword [rsp + 16], 1
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6612 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6612 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6612 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6615
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6615:
	cmp rax, [rsp + 24]
	jl .jump6616
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6616:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6617
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6617:
	cmp rax, [rsp + 32]
	jl .jump6618
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6618:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6619
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6619:
	cmp rax, [rsp + 40]
	jl .jump6620
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6620:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6605
.jump6604:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6621:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6622
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6622:
	; Computing bound for 'Z'
	sub rsp, 8
	sub rsp, 8 ; Add alignment
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	mov rax, [rel const746] ; 68.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rsi
	pop rdx
	lea rdi, [rsp + 72]
	call _I
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6623:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by I(J, i(68.96), N, P).a 
	jno .jump6624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6624:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump6625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6625:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump6626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6626:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6627: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 16], 1
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6627 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6627 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6627 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6605:
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump6628
	sub rsp, 8
	sub rsp, 8 ; Add alignment
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6630:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6631
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6631:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by X 
	jno .jump6632
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6632:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump6633
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6633:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6634: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6634 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6634 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6635
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const747] ; 44.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6637
	sub rsp, 40
	; Moving 40 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 128 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 128 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 128 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	jmp .jump6638
.jump6637:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
.jump6638:
	pop rax
	cmp rax, 0
	je .jump6639
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	jmp .jump6640
.jump6639:
	sub rsp, 40
	; Moving 40 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 128 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 128 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 128 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
.jump6640:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6641
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6641:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6642:
	; Computing bound for 'Z'
	sub rsp, 8 ; Add alignment
	mov rax, [rel const748] ; 10.03
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump6643
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6645:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6646
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6646:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6647: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6647 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6647 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump6644
.jump6643:
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
.jump6644:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6648
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6648:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6649: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'ab'
	add qword [rsp + 16], 1
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6649 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6649 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6649 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6650:
	cmp rax, [rsp + 24]
	jl .jump6651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6651:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6652:
	cmp rax, [rsp + 32]
	jl .jump6653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6653:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6654:
	cmp rax, [rsp + 40]
	jl .jump6655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6655:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6656
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6658
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6658:
	; Computing bound for 'ab'
	call _H
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6659:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6660
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6660:
	; Computing bound for 'Z'
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6661:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6662
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6662:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump6663
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6663:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump6664
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6664:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6665: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6665 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6665 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump6666
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump6667
.jump6666:
	call _H
	push rax
.jump6667:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6668:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
imul rdi, [rsp + 0 + 0] ; multiply by (if l((array[Z : Q, aa : w] false)) then g else H()) 
	jno .jump6669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6669:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump6670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6670:
	imul rdi, [rsp + 0 + 16] ; multiply by H() 
	jno .jump6671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6671:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump6672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6672:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6673: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6674
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	jmp .jump6675
.jump6674:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6676
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6676:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6677:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6678
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6678:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by ac 
	jno .jump6679
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6679:
	imul rdi, [rsp + 0 + 8] ; multiply by Z 
	jno .jump6680
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6680:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6681
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6681:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump6682: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 16], 1
	; Compare af to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6682 ; If af < bound, next iter
	mov qword [rsp + 16], 0 ; af = 0
	add qword [rsp + 8], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6682 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6682 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6675:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ac'
	add qword [rsp + 24], 1
	; Compare ac to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6673 ; If ac < bound, next iter
	mov qword [rsp + 24], 0 ; ac = 0
	add qword [rsp + 16], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6673 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6673 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6673 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6657
.jump6656:
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump6657:
	jmp .jump6636
.jump6635:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6683
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump6683:
	push rax
	pop rax
	cmp rax, 0
	je .jump6684
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump6685
.jump6684:
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump6685:
.jump6636:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6686
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6686:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6687:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof D 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6688:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump6689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6689:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6690: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6691
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump6692
.jump6691:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump6692:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6690 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6690 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	call _H
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6693
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6693:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6694
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6694:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6695:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6696
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6696:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump6697
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6697:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump6698
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6698:
	imul rdi, [rsp + 0 + 16] ; multiply by R 
	jno .jump6699
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6699:
	imul rdi, [rsp + 0 + 24] ; multiply by H() 
	jno .jump6700
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6700:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6701: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ac'
	add qword [rsp + 24], 1
	; Compare ac to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6701 ; If ac < bound, next iter
	mov qword [rsp + 24], 0 ; ac = 0
	add qword [rsp + 16], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6701 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6701 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6701 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 56 to rsp + 56 
		mov r10, [rsp + 56 + 0]
		mov [rsp + 56 + 0], r10
	add rsp, 56
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6702:
	cmp rax, [rsp + 16]
	jl .jump6703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6703:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6704:
	cmp rax, [rsp + 24]
	jl .jump6705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6705:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6706:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6707
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6707:
	; Computing total size of heap memory to allocate
	mov rdi, 64 ; sizeof G 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump6708
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6708:
imul rdi, [rsp + 0 + 8] ; multiply by (array[Z : h, aa : C] (if true then D {e} else D {h}))[(- h), G {N, (array[Z : e, aa : T, ab : R, ac : H()] z()), (- h), Y}.d].a 
	jno .jump6709
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6709:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6710: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6711
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6711:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6712:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6713
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6713:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump6714
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6714:
	imul rdi, [rsp + 0 + 8] ; multiply by Q 
	jno .jump6715
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6715:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump6716
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6716:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump6717: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6718:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6719
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6719:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6720:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6721
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6721:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump6722
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6722:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6723
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6723:
	imul rdi, [rsp + 0 + 16] ; multiply by F 
	jno .jump6724
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6724:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump6725
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6725:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6726: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const749] ; 39.7
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6726 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6726 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6726 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6726 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ad'
	add qword [rsp + 16], 1
	; Compare ad to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6717 ; If ad < bound, next iter
	mov qword [rsp + 16], 0 ; ad = 0
	add qword [rsp + 8], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6717 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6717 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6727:
	cmp rax, [rsp + 24]
	jl .jump6728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6728:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6729:
	cmp rax, [rsp + 32]
	jl .jump6730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6730:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6731:
	cmp rax, [rsp + 40]
	jl .jump6732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6732:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6733
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6735:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6736
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6736:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6737:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6738
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6738:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump6739
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6739:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6740
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6740:
	imul rdi, [rsp + 0 + 16] ; multiply by L 
	jno .jump6741
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6741:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump6742
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6742:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump6743: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 24], 1
	; Compare ae to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6743 ; If ae < bound, next iter
	mov qword [rsp + 24], 0 ; ae = 0
	add qword [rsp + 16], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6743 ; If ad < bound, next iter
	mov qword [rsp + 16], 0 ; ad = 0
	add qword [rsp + 8], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6743 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6743 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 56 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 56 + 0], r10
	add rsp, 56
	jmp .jump6734
.jump6733:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6744:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump6745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6745:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump6746: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 0], 1
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6746 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6747
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6747:
	cmp rax, [rsp + 8]
	jl .jump6748
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6748:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6734:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 64
	add rax, [rsp + 96]
	; Move body (64 bytes) to index
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6710 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6710 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const750] ; 47.37
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6749
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6751
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6751:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6752:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6753
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6753:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6754:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump6755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6755:
	imul rdi, [rsp + 0 + 8] ; multiply by V 
	jno .jump6756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6756:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump6757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6757:
	imul rdi, [rsp + 0 + 24] ; multiply by V 
	jno .jump6758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6758:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6759: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const751] ; 860
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6760
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6760:
	cmp rax, [rsp + 16]
	jl .jump6761
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6761:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6762
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6762:
	cmp rax, [rsp + 24]
	jl .jump6763
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6763:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ac'
	add qword [rsp + 24], 1
	; Compare ac to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6759 ; If ac < bound, next iter
	mov qword [rsp + 24], 0 ; ac = 0
	add qword [rsp + 16], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6759 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6759 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6759 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6750
.jump6749:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const752] ; 808
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6764
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump6765
.jump6764:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6765:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6766:
	cmp rax, [rsp + 16]
	jl .jump6767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6767:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6768:
	cmp rax, [rsp + 24]
	jl .jump6769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6769:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 64
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 64
	; Moving 64 bytes from rax to rsp 
		mov r10, [rax + 56]
		mov [rsp + 56], r10
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 40 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 32]
		mov [rsp + 24 + 32], r10
		mov r10, [rsp + 8 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump6750:
	sub rsp, 8 ; Add alignment
	mov rax, [rel const753] ; 99.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump6770
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6771
.jump6770:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6771:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6772
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6772:
	cmp rax, [rsp + 16]
	jl .jump6773
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6773:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6774
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6774:
	cmp rax, [rsp + 24]
	jl .jump6775
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6775:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 64
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 64
	; Moving 64 bytes from rax to rsp 
		mov r10, [rax + 56]
		mov [rsp + 56], r10
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 56 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 56 + 0], r10
	add rsp, 56
	; Moving 8 bytes from rsp + 0 to rsp + 56 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 56 + 0], r10
	add rsp, 56
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6776:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6777
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6777:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump6778
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6778:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump6779
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6779:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6780: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6780 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6780 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rsi
	pop rdx
	lea rdi, [rsp + 72]
	call _I
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	jmp .jump6629
.jump6628:
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump6781
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6783
	mov rax, [rel const1] ; False
	push rax
	jmp .jump6784
.jump6783:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump6784:
	jmp .jump6782
.jump6781:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump6782:
	pop rax
	cmp rax, 0
	je .jump6785
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6787
	sub rsp, 8
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6789
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6789:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6790:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6791
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6791:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6792:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump6793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6793:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump6794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6794:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump6795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6795:
	imul rdi, [rsp + 0 + 24] ; multiply by H() 
	jno .jump6796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6796:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6797: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ac'
	add qword [rsp + 24], 1
	; Compare ac to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6797 ; If ac < bound, next iter
	mov qword [rsp + 24], 0 ; ac = 0
	add qword [rsp + 16], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6797 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6797 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6797 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump6798
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6799
.jump6798:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump6799:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6800:
	cmp rax, [rsp + 32]
	jl .jump6801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6801:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6802:
	cmp rax, [rsp + 40]
	jl .jump6803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6803:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6804:
	cmp rax, [rsp + 48]
	jl .jump6805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6805:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6806:
	cmp rax, [rsp + 56]
	jl .jump6807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6807:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6808
	sub rsp, 40
	; Moving 40 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump6809
.jump6808:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6810
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6810:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6811:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by R 
	jno .jump6812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6812:
	imul rdi, [rsp + 0 + 8] ; multiply by Y 
	jno .jump6813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6813:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6814: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6815
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump6816
.jump6815:
	sub rsp, 40
	; Moving 40 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump6816:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6814 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6814 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6817:
	cmp rax, [rsp + 16]
	jl .jump6818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6818:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6819:
	cmp rax, [rsp + 24]
	jl .jump6820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6820:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6809:
	sub rsp, 40
	; Moving 40 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 128 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 128 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 128 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6821
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6823
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6823:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6824:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6825
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6825:
	; Computing bound for 'Z'
	mov rax, [rel const754] ; 634
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6826:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 634 
	jno .jump6827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6827:
	imul rdi, [rsp + 0 + 8] ; multiply by X 
	jno .jump6828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6828:
	imul rdi, [rsp + 0 + 16] ; multiply by Y 
	jno .jump6829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6829:
	imul rdi, [rsp + 0 + 24] ; multiply by F 
	jno .jump6830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6830:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6831: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ac'
	add qword [rsp + 24], 1
	; Compare ac to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6831 ; If ac < bound, next iter
	mov qword [rsp + 24], 0 ; ac = 0
	add qword [rsp + 16], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6831 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6831 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6831 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6832:
	cmp rax, [rsp + 32]
	jl .jump6833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6833:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6834:
	cmp rax, [rsp + 40]
	jl .jump6835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6835:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6836:
	cmp rax, [rsp + 48]
	jl .jump6837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6837:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6838:
	cmp rax, [rsp + 56]
	jl .jump6839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6839:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6840:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6841
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6841:
	; Computing total size of heap memory to allocate
	mov rdi, 64 ; sizeof G 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump6842
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6842:
imul rdi, [rsp + 0 + 8] ; multiply by (array[Z : 634, aa : X, ab : Y, ac : F] X)[T, S, p, C] 
	jno .jump6843
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6843:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump6844: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6845
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6845:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6846:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6847
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6847:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp 
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6848:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6849:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6850:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6851:
	imul rdi, [rsp + 0 + 24] ; multiply by Y 
	jno .jump6852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6852:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump6853: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 24], 1
	; Compare ae to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6853 ; If ae < bound, next iter
	mov qword [rsp + 24], 0 ; ae = 0
	add qword [rsp + 16], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6853 ; If ad < bound, next iter
	mov qword [rsp + 16], 0 ; ad = 0
	add qword [rsp + 8], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6853 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6853 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 64
	add rax, [rsp + 96]
	; Move body (64 bytes) to index
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6844 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6844 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6822
.jump6821:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6822:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const755] ; 5.29
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rsi
	pop rdx
	lea rdi, [rsp + 72]
	call _I
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	jmp .jump6788
.jump6787:
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
.jump6788:
	jmp .jump6786
.jump6785:
	sub rsp, 8
	; Moving 8 bytes from r12 - 208 to rsp 
		mov r10, [r12 - 208 + 0]
		mov [rsp + 0], r10
.jump6786:
.jump6629:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 152 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp ; end of jpl_main prelude
	mov rax, [rel const0] ; 19.64
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	mov rax, [rel const2] ; 41.05
	push rax
	mov rax, [rel const3] ; 53.42
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2
.jump1:
	mov rax, [rel const4] ; 4.41
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const5] ; 213
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4:
	; Computing bound for 'b'
	mov rax, [rel const7] ; 615
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5:
	; Computing bound for 'a'
	mov rax, [rel const8] ; 653
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump7: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const9] ; 73.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const10] ; 66.06
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump8
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump9
	mov rax, [rel const12] ; 332
	push rax
	mov rax, [rel const13] ; 629
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump9:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump10
	mov rax, [rel const1] ; False
	push rax
	jmp .jump11
.jump10:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump12
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump12:
	push rax
	pop rax
	xor rax, 1
	push rax
.jump11:
	pop rax
.jump8:
	push rax
	pop rax
.jump3:
	push rax
	pop rax
	cmp rax, 0
	je .jump13
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const14] ; 375
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump14
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump14:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const15] ; 792
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump15
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump15:
	; Computing bound for 'a'
	mov rax, [rel const16] ; 267
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump16
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump16:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump17: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump17 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump17 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump18:
	; Computing bound for 'b'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump19
	mov rax, [rel const17] ; 12
	push rax
	jmp .jump20
.jump19:
	mov rax, [rel const18] ; 379
	push rax
.jump20:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump21
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump21:
	; Computing bound for 'a'
	mov rax, [rel const19] ; 582
	push rax
	mov rax, [rel const20] ; 546
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump22
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump22:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump23: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump23 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump23 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump23 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump23 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const21] ; 811
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump24
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump24:
	; Computing bound for 'b'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump25
	mov rax, [rel const22] ; 131
	push rax
	mov rax, [rel const23] ; 876
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump26
.jump25:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const24] ; 319
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump27
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump27:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump28: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump28 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump26:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump29
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump29:
	; Computing bound for 'a'
	mov rax, [rel const25] ; 531
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump30
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump30:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 531 
	jno .jump31
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump31:
imul rdi, [rsp + 0 + 8] ; multiply by (if false then ((- 876) * 131) else (sum[a : (- 319)] a)) 
	jno .jump32
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump32:
imul rdi, [rsp + 0 + 16] ; multiply by (811 + (sum[a : (546 * 582), b : (if false then 12 else 379), c : (sum[a : 267, b : 792] a), d : (- 375)] a)) 
	jno .jump33
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump33:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump34: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump35
	mov rax, [rel const27] ; 337
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump35:
	push rax
	pop rax
	cmp rax, 0
	je .jump36
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump38
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump38:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump39
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump39:
	; Computing bound for 'e'
	mov rax, [rel const28] ; 599
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump40
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump40:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump41
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump41:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump42: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump42 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump42 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump42 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump43
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump43:
	; Computing bound for 'd'
	mov rax, [rel const29] ; 158
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump44
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump44:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 158 
	jno .jump45
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump45:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[d : b, e : 599, f : b] f) 
	jno .jump46
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump46:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump47
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump47:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump48: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump48 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump48 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump48 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump37
.jump36:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const30] ; 164
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump49
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump49:
	; Computing bound for 'e'
	mov rax, [rel const31] ; 958
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump50
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump50:
	; Computing bound for 'd'
	mov rax, [rel const32] ; 190
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump51
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump51:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 190 
	jno .jump52
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump52:
	imul rdi, [rsp + 0 + 8] ; multiply by 958 
	jno .jump53
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump53:
	imul rdi, [rsp + 0 + 16] ; multiply by 164 
	jno .jump54
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump54:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump55: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump55 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump55 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump55 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump37:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump34 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump34 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump34 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump56
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump56:
	push rax
	pop rax
	cmp rax, 0
	je .jump57
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const33] ; 263
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump59
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump59:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump60: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump60 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const34] ; 373
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump61
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump61:
	; Computing bound for 'b'
	mov rax, [rel const35] ; 698
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump62
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump62:
	; Computing bound for 'a'
	mov rax, [rel const36] ; 803
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump63
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump63:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump64: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const37] ; 587
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump65
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump65:
	; Computing bound for 'd'
	mov rax, [rel const38] ; 985
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump66
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump66:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump67: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const39] ; 520
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump67 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump67 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump64 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump64 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump64 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump58
.jump57:
	mov rax, [rel const40] ; 872
	push rax
.jump58:
	mov rax, [rel const41] ; 903
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const42] ; 180
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump68
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump68:
	; Computing bound for 'a'
	mov rax, [rel const43] ; 497
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump69
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump69:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump70: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump70 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump70 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const44] ; 719
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const45] ; 809
	push rax
	mov rax, [rel const46] ; 289
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump71
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump71:
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const47] ; 56
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump72
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump72:
	; Computing bound for 'b'
	mov rax, [rel const48] ; 326
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump73
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump73:
	; Computing bound for 'a'
	mov rax, [rel const49] ; 24
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump74
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump74:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 24 
	jno .jump75
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump75:
	imul rdi, [rsp + 0 + 8] ; multiply by 326 
	jno .jump76
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump76:
	imul rdi, [rsp + 0 + 16] ; multiply by 56 
	jno .jump77
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump77:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump78: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump78 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump78 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump78 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const50] ; 858
	push rax
	mov rax, [rel const51] ; 983
	push rax
	mov rax, [rel const52] ; 906
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump79
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump79:
	cmp rax, [rsp + 24]
	jl .jump80
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump80:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump81
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump81:
	cmp rax, [rsp + 32]
	jl .jump82
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump82:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump83
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump83:
	cmp rax, [rsp + 40]
	jl .jump84
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump84:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump85
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump85:
	; Computing bound for 'b'
	mov rax, [rel const1] ; False
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump86
	mov rax, [rel const55] ; 49
	push rax
	jmp .jump87
.jump86:
	mov rax, [rel const56] ; 960
	push rax
	pop rax
	neg rax
	push rax
.jump87:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump88
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump88:
	; Computing bound for 'a'
	mov rax, [rel const57] ; 694
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump89
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump89:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump90: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump90 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump90 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump90 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump90 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump91
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump91:
	cmp rax, [rsp + 8]
	jl .jump92
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump92:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const58] ; 726
	push rax
	mov rax, [rel const59] ; 196
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump93
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump93:
	; Computing bound for 'c'
	mov rax, [rel const60] ; 778
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump94
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump94:
	; Computing bound for 'b'
	mov rax, [rel const61] ; 752
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump95
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump95:
	; Computing bound for 'a'
	mov rax, [rel const62] ; 609
	push rax
	mov rax, [rel const63] ; 361
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump96
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump96:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump97
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump97:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump98: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const65] ; 355
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump98 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump98 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump98 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump98 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump99
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump99:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const66] ; 76
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump100:
	; Computing bound for 'a'
	mov rax, [rel const67] ; 302
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump101
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump101:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump102: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump102 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump102 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump103
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump103:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const68] ; 414
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump104
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump104:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump105: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const69] ; 555
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump105 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump106:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump107: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump107 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump107 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump107 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump108
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump108:
	cmp rax, [rsp + 24]
	jl .jump109
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump109:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump110
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump110:
	cmp rax, [rsp + 32]
	jl .jump111
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump111:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump112
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump112:
	cmp rax, [rsp + 40]
	jl .jump113
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump113:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const70] ; 185
	push rax
	mov rax, [rel const71] ; 444
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump114
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump114:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump115: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const72] ; 264
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump115 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump116:
	; Computing bound for 'a'
	mov rax, [rel const52] ; 906
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump117
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump117:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 906 
	jno .jump118
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump118:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[a : (444 - 185)] 264) 
	jno .jump119
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump119:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump120: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const73] ; 768
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump121
	mov rax, [rel const74] ; 357
	push rax
	jmp .jump122
.jump121:
	mov rax, [rel const75] ; 716
	push rax
.jump122:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump120 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump120 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const76] ; 953
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const77] ; 748
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump123:
	; Computing bound for 'b'
	mov rax, [rel const78] ; 705
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump124
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump124:
	; Computing bound for 'a'
	mov rax, [rel const79] ; 741
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump125:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 741 
	jno .jump126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump126:
	imul rdi, [rsp + 0 + 8] ; multiply by 705 
	jno .jump127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump127:
	imul rdi, [rsp + 0 + 16] ; multiply by 748 
	jno .jump128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump128:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump129: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump129 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump129 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump129 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const80] ; 441
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump130
	mov rax, [rel const81] ; 105
	push rax
	jmp .jump131
.jump130:
	mov rax, [rel const82] ; 329
	push rax
.jump131:
	mov rax, [rel const83] ; 488
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump132
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump132:
	cmp rax, [rsp + 24]
	jl .jump133
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump133:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump134
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump134:
	cmp rax, [rsp + 32]
	jl .jump135
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump135:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump136
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump136:
	cmp rax, [rsp + 40]
	jl .jump137
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump137:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump138
	mov rax, [rel const84] ; 636
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump139
.jump138:
	mov rax, [rel const85] ; 769
	push rax
	pop rax
	neg rax
	push rax
.jump139:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump140
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump140:
	cmp rax, [rsp + 16]
	jl .jump141
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump141:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump142
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump142:
	cmp rax, [rsp + 24]
	jl .jump143
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump143:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const86] ; 579
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump144
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump144:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump145: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump146
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump146:
	; Computing bound for 'b'
	mov rax, [rel const87] ; 316
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump147:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump148: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump148 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump148 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump150: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump150 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump145 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const88] ; 933
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump151
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump151:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 933 
	jno .jump152
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump152:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump153: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump153 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const89] ; 891
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump154:
	cmp rax, [rsp + 8]
	jl .jump155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump155:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump156:
	; Computing bound for 'b'
	mov rax, [rel const90] ; 682
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const91] ; 684
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump157
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump157:
	; Computing bound for 'a'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump158
	mov rax, [rel const92] ; 919
	push rax
	jmp .jump159
.jump158:
	mov rax, [rel const93] ; 917
	push rax
.jump159:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump160:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump161: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump161 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump161 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump162
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump162:
	; Computing bound for 'a'
	mov rax, [rel const94] ; 697
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump163:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 697 
	jno .jump164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump164:
imul rdi, [rsp + 0 + 8] ; multiply by ((sum[a : (if false then 919 else 917), b : 684] (b * a)) - 682) 
	jno .jump165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump165:
imul rdi, [rsp + 0 + 16] ; multiply by (array[a : 933] a)[(- 891)] 
	jno .jump166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump166:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump167: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump168
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump168:
	; Computing bound for 'e'
	mov rax, [rel const95] ; 162
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump169:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump170
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump170:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump171
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump171:
	imul rdi, [rsp + 0 + 8] ; multiply by 162 
	jno .jump172
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump172:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump173
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump173:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump174: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump174 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump174 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump174 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const96] ; 80
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump175:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump176
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump176:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump177: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump177 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump177 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump178:
	cmp rax, [rsp + 24]
	jl .jump179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump179:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump180:
	cmp rax, [rsp + 32]
	jl .jump181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump181:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump182:
	cmp rax, [rsp + 40]
	jl .jump183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump183:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump184
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump185
.jump184:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump185:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump167 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump167 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump167 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const97] ; 325
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const98] ; 407
	push rax
	mov rax, [rel const99] ; 672
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump186
	mov rax, [rel const11] ; True
	push rax
	jmp .jump187
.jump186:
	mov rax, [rel const100] ; 62.65
	push rax
	mov rax, [rel const101] ; 73.76
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump187:
	pop rax
	cmp rax, 0
	je .jump188
	mov rax, [rel const102] ; 58.7
	push rax
	mov rax, [rel const103] ; 65.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump190
	mov rax, [rel const104] ; 1000
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump191
.jump190:
	mov rax, [rel const105] ; 479
	push rax
	pop rax
	neg rax
	push rax
.jump191:
	jmp .jump189
.jump188:
	mov rax, [rel const106] ; 810
	push rax
.jump189:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump192
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump192:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const107] ; 314
	push rax
	mov rax, [rel const108] ; 280
	push rax
	mov rax, [rel const109] ; 366
	push rax
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump193
	mov rax, [rel const110] ; 274
	push rax
	jmp .jump194
.jump193:
	mov rax, [rel const111] ; 844
	push rax
.jump194:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump195
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump195:
	cmp rax, [rsp + 8]
	jl .jump196
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump196:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump197
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump197:
	; Computing bound for 'c'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump198
	mov rax, [rel const112] ; 765
	push rax
	jmp .jump199
.jump198:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump200
	mov rax, [rel const113] ; 871
	push rax
	jmp .jump201
.jump200:
	mov rax, [rel const114] ; 245
	push rax
.jump201:
.jump199:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump202:
	; Computing bound for 'b'
	mov rax, [rel const115] ; 104
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump203
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump203:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const116] ; 945
	push rax
	mov rax, [rel const117] ; 261
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump204:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump205
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump205:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const118] ; 656
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump206
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump206:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump207: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const119] ; 293
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump207 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump208:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump209: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const120] ; 833
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump209 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump209 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump210:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump211: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump211 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump211 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump211 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump211 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump212:
	; Computing bound for 'b'
	mov rax, [rel const121] ; 981
	push rax
	mov rax, [rel const122] ; 125
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump213:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump214
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump214:
	; Computing bound for 'a'
	mov rax, [rel const123] ; 184
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump215:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump216: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump216 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump216 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump216 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump216 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump217
	mov rax, [rel const1] ; False
	push rax
	jmp .jump218
.jump217:
	mov rax, [rel const124] ; 424
	push rax
	mov rax, [rel const80] ; 441
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
.jump218:
	pop rax
	cmp rax, 0
	je .jump219
	mov rax, [rel const121] ; 981
	push rax
	jmp .jump220
.jump219:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const125] ; 613
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump221:
	; Computing bound for 'a'
	mov rax, [rel const126] ; 168
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump222
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump222:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump223: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const127] ; 282
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump223 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump223 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const128] ; 397
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump224
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump224:
	; Computing bound for 'a'
	mov rax, [rel const129] ; 68
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump225:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump226: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump226 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump226 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
.jump220:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump227
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump227:
	cmp rax, [rsp + 24]
	jl .jump228
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump228:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump229
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump229:
	cmp rax, [rsp + 32]
	jl .jump230
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump230:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump231
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump231:
	cmp rax, [rsp + 40]
	jl .jump232
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump232:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump233
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump233:
	cmp rax, [rsp + 24]
	jl .jump234
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump234:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump235
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump235:
	cmp rax, [rsp + 32]
	jl .jump236
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump236:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump237
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump237:
	cmp rax, [rsp + 40]
	jl .jump238
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump238:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump13:
	push rax
	pop rax
	cmp rax, 0
	je .jump239
	mov rax, [rel const130] ; 662
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const131] ; 849
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const132] ; 739
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump241
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const133] ; 515
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump243
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump243:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 515 
	jno .jump244
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump244:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump245: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const134] ; 311
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump245 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump242
.jump241:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const12] ; 332
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump246:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump247: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump247 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump248
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump248:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[a : 332] a) 
	jno .jump249
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump249:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump250: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump250 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump242:
	mov rax, [rel const135] ; 281
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump251:
	cmp rax, [rsp + 8]
	jl .jump252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump252:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const87] ; 316
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const136] ; 108
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump253:
	cqo
	idiv r10
	push rax
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump254
	mov rax, [rel const137] ; 570
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump255
.jump254:
	mov rax, [rel const138] ; 861
	push rax
.jump255:
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const80] ; 441
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump256
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump256:
	; Computing bound for 'c'
	mov rax, [rel const139] ; 211
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump257:
	; Computing bound for 'b'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump258
	mov rax, [rel const140] ; 767
	push rax
	jmp .jump259
.jump258:
	mov rax, [rel const11] ; 1
	push rax
.jump259:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump260
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump260:
	; Computing bound for 'a'
	mov rax, [rel const141] ; 539
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump261:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 539 
	jno .jump262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump262:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then 767 else 1) 
	jno .jump263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump263:
	imul rdi, [rsp + 0 + 16] ; multiply by 211 
	jno .jump264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump264:
	imul rdi, [rsp + 0 + 24] ; multiply by 441 
	jno .jump265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump265:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump266: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const142] ; 394
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump267:
	; Computing bound for 'f'
	mov rax, [rel const143] ; 458
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump268
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump268:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump269:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump270:
	imul rdi, [rsp + 0 + 8] ; multiply by 458 
	jno .jump271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump271:
	imul rdi, [rsp + 0 + 16] ; multiply by 394 
	jno .jump272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump272:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump273: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const144] ; 147
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump273 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump273 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump273 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump266 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump266 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump266 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump266 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const145] ; 209
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump274
	mov rax, [rel const146] ; 117
	push rax
	jmp .jump275
.jump274:
	mov rax, [rel const60] ; 778
	push rax
.jump275:
	mov rax, [rel const147] ; 728
	push rax
	mov rax, [rel const148] ; 32
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump276:
	cmp rax, [rsp + 32]
	jl .jump277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump277:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump278:
	cmp rax, [rsp + 40]
	jl .jump279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump279:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump280:
	cmp rax, [rsp + 48]
	jl .jump281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump281:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump282:
	cmp rax, [rsp + 56]
	jl .jump283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump283:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const149] ; 607
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const150] ; 463
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump284
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump284:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const152] ; 230
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const153] ; 505
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump286:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump287: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump287 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump288
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump288:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump289: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const154] ; 801
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump289 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump289 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump290
	mov rax, [rel const1] ; False
	push rax
	jmp .jump291
.jump290:
	mov rax, [rel const1] ; False
	push rax
.jump291:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump292
	mov rax, [rel const155] ; 349
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump293
.jump292:
	mov rax, [rel const156] ; 523
	push rax
.jump293:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump294:
	cmp rax, [rsp + 24]
	jl .jump295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump295:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump296:
	cmp rax, [rsp + 32]
	jl .jump297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump297:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump298:
	cmp rax, [rsp + 40]
	jl .jump299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump299:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const33] ; 263
	push rax
	mov rax, [rel const157] ; 780
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump300:
	; Computing bound for 'c'
	mov rax, [rel const158] ; 622
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump301
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump301:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const159] ; 110
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump302
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump302:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump303: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const160] ; 581
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump304:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump305: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const16] ; 267
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump305 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump303 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump306:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const161] ; 855
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump307:
	; Computing bound for 'c'
	mov rax, [rel const162] ; 954
	push rax
	mov rax, [rel const163] ; 543
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump308:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump309
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump309:
	; Computing bound for 'b'
	mov rax, [rel const164] ; 115
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump310:
	; Computing bound for 'a'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump311
	mov rax, [rel const165] ; 169
	push rax
	jmp .jump312
.jump311:
	mov rax, [rel const166] ; 126
	push rax
.jump312:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump313
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump313:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump314: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump314 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump314 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump314 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump314 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump315
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump315:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump316: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump316 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump316 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump316 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump316 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const167] ; 916
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump317
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump317:
	; Computing bound for 'c'
	mov rax, [rel const168] ; 65
	push rax
	mov rax, [rel const169] ; 419
	push rax
	mov rax, [rel const115] ; 104
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump318:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump319:
	; Computing bound for 'b'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump320
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump320:
	push rax
	pop rax
	cmp rax, 0
	je .jump321
	mov rax, [rel const170] ; 111
	push rax
	jmp .jump322
.jump321:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const171] ; 787
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump323:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump324: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump324 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump322:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump325
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump325:
	; Computing bound for 'a'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump326
	mov rax, [rel const172] ; 442
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump327
.jump326:
	mov rax, [rel const173] ; 51
	push rax
.jump327:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump328:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! false) then (- 442) else 51) 
	jno .jump329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump329:
imul rdi, [rsp + 0 + 8] ; multiply by (if (true || false) then 111 else (sum[a : 787] a)) 
	jno .jump330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump330:
	imul rdi, [rsp + 0 + 16] ; multiply by ((104 / 419) + 65) 
	jno .jump331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump331:
	imul rdi, [rsp + 0 + 24] ; multiply by (- (- 916)) 
	jno .jump332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump332:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump333: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump333 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump333 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump333 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump333 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const174] ; 970
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const175] ; 469
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump334:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const21] ; 811
	push rax
	mov rax, [rel const176] ; 600
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump335
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump335:
	; Computing bound for 'a'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump336
	mov rax, [rel const177] ; 644
	push rax
	jmp .jump337
.jump336:
	mov rax, [rel const178] ; 511
	push rax
.jump337:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump338:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump339: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump339 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump339 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const179] ; 491
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const180] ; 160
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump340
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump340:
	; Computing bound for 'b'
	mov rax, [rel const181] ; 16
	push rax
	mov rax, [rel const182] ; 324
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump341
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump341:
	cqo
	idiv r10
	push rax
	mov rax, [rel const82] ; 329
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump342
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump342:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump343:
	; Computing bound for 'a'
	mov rax, [rel const183] ; 649
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump344
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump344:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump345: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; 213
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump345 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump345 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump345 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump346:
	cmp rax, [rsp + 32]
	jl .jump347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump347:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump348:
	cmp rax, [rsp + 40]
	jl .jump349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump349:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump350:
	cmp rax, [rsp + 48]
	jl .jump351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump351:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump352:
	cmp rax, [rsp + 56]
	jl .jump353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump353:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump354:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[a : (if (! false) then (- 442) else 51), b : (if (true || false) then 111 else (sum[a : 787] a)), c : ((104 / 419) + 65), d : (- (- 916))] (- d))[(sum[a : (- 649), b : (329 / (324 / 16)), c : 160] 213), 491, (sum[a : (if true then 644 else 511), b : ((- 600) * 811)] a), (- (469 % (- 970)))] 
	jno .jump355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump355:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump356: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const184] ; 412
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump356 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const185] ; 5.43
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const186] ; 735
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump357
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump357:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const187] ; 335
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump358
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump358:
	; Computing bound for 'b'
	mov rax, [rel const188] ; 910
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump359:
	; Computing bound for 'a'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump360
	mov rax, [rel const189] ; 492
	push rax
	jmp .jump361
.jump360:
	mov rax, [rel const190] ; 121
	push rax
.jump361:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump362
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump362:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump363: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump363 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump363 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump363 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump364:
	; Computing bound for 'b'
	mov rax, [rel const191] ; 255
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump365
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump365:
	; Computing bound for 'a'
	mov rax, [rel const192] ; 406
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump366:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump367: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const193] ; 63.34
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump368
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump368:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump369:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump370: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const194] ; 44.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump370 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump370 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump367 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump367 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump367 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump367 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump371
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const195] ; 473
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump373:
	; Computing bound for 'b'
	mov rax, [rel const196] ; 595
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump374
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump374:
	; Computing bound for 'a'
	mov rax, [rel const197] ; 137
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump375:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 137 
	jno .jump376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump376:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 595) 
	jno .jump377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump377:
	imul rdi, [rsp + 0 + 16] ; multiply by 473 
	jno .jump378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump378:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump379: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const198] ; 246
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump379 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump379 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump379 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const199] ; 993
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump380:
	; Computing bound for 'a'
	mov rax, [rel const200] ; 974
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump381
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump381:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 974 
	jno .jump382
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump382:
	imul rdi, [rsp + 0 + 8] ; multiply by 993 
	jno .jump383
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump383:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump384: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump385
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump385:
	; Computing bound for 'c'
	mov rax, [rel const201] ; 742
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump386:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump387: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump387 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump387 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump384 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump384 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const74] ; 357
	push rax
	mov rax, [rel const202] ; 57
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump388
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump388:
	cmp rax, [rsp + 16]
	jl .jump389
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump389:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump390
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump390:
	cmp rax, [rsp + 24]
	jl .jump391
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump391:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const203] ; 50
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump392
	mov rax, [rel const204] ; 295
	push rax
	mov rax, [rel const205] ; 695
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump393
.jump392:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump394
	mov rax, [rel const206] ; 856
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump395
.jump394:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const207] ; 194
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump396:
	; Computing bound for 'a'
	mov rax, [rel const208] ; 987
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump397
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump397:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump398: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump398 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump398 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump395:
.jump393:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump399
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump399:
	cmp rax, [rsp + 24]
	jl .jump400
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump400:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump401
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump401:
	cmp rax, [rsp + 32]
	jl .jump402
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump402:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump403
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump403:
	cmp rax, [rsp + 40]
	jl .jump404
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump404:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump372
.jump371:
	mov rax, [rel const140] ; 767
	push rax
	mov rax, [rel const209] ; 100
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump405
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump405:
	push rax
	pop rax
	cmp rax, 0
	je .jump406
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const210] ; 829
	push rax
	mov rax, [rel const98] ; 407
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump408:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (407 * 829) 
	jno .jump409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump409:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump410: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const211] ; 826
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump411:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump412
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump412:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const212] ; 266
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump413
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump413:
	; Computing bound for 'c'
	mov rax, [rel const213] ; 275
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump414:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump415
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump415:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump416: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump416 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump416 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump416 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump417:
	; Computing bound for 'b'
	mov rax, [rel const197] ; 137
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump418
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump418:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump419: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump419 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump419 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump419 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump410 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump407
.jump406:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump420
	mov rax, [rel const214] ; 75
	push rax
	jmp .jump421
.jump420:
	mov rax, [rel const215] ; 888
	push rax
	pop rax
	neg rax
	push rax
.jump421:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump422:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! false) then 75 else (- 888)) 
	jno .jump423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump423:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump424: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const216] ; 367
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump425
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump425:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump426: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump426 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump424 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump407:
.jump372:
	mov rdi, 64
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const217] ; 34
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump427:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 34 
	jno .jump428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump428:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump429: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump430
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump430:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump429 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const218] ; 620
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump431
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump431:
	cmp rax, [rsp + 8]
	jl .jump432
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump432:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const219] ; 292
	push rax
	mov rax, [rel const220] ; 920
	push rax
	mov rax, [rel const221] ; 145
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const222] ; 882
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump433
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump433:
	cmp rax, [rsp + 8]
	jl .jump434
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump434:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump240
.jump239:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const223] ; 931
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump435
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump435:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const224] ; 102
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump436
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump436:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump437: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump437 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump438:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[a : (- 102)] (- a)) 
	jno .jump439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump439:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 931) 
	jno .jump440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump440:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump441: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const225] ; 69
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump442:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump443
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump443:
	; Computing bound for 'c'
	mov rax, [rel const226] ; 30
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump444:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 30 
	jno .jump445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump445:
	imul rdi, [rsp + 0 + 8] ; multiply by a 
	jno .jump446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump446:
	imul rdi, [rsp + 0 + 16] ; multiply by (a - 69) 
	jno .jump447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump447:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump448: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump448 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump448 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump448 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump441 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump441 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const227] ; 733
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const228] ; 880
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump449:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const229] ; 731
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump450:
	cmp rax, [rsp + 16]
	jl .jump451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump451:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump452:
	cmp rax, [rsp + 24]
	jl .jump453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump453:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const230] ; 973
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const231] ; 420
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump454:
	; Computing bound for 'c'
	mov rax, [rel const232] ; 443
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const233] ; 961
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump455:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump456
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump456:
	; Computing bound for 'b'
	mov rax, [rel const145] ; 209
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump457:
	; Computing bound for 'a'
	mov rax, [rel const115] ; 104
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump458
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump458:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump459: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump460
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump460:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump461: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump461 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump459 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump459 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump459 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump459 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const234] ; 430
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump462
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump462:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump463: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const235] ; 864
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump463 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const236] ; 673
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump464
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump464:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const237] ; 797
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump465
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump465:
	; Computing bound for 'a'
	mov rax, [rel const238] ; 300
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump466:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump467: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump468
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump469
.jump468:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump470
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump471
.jump470:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump471:
.jump469:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump467 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump467 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump472:
	; Computing bound for 'a'
	mov rax, [rel const239] ; 854
	push rax
	mov rax, [rel const240] ; 285
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump473
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump473:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump474: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump474 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump474 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump474 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump475:
	cmp rax, [rsp + 24]
	jl .jump476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump476:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump477:
	cmp rax, [rsp + 32]
	jl .jump478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump478:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump479:
	cmp rax, [rsp + 40]
	jl .jump480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump480:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump481:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (array[a : (sum[a : (- 102)] (- a)), b : (- 931)] (array[c : 30, d : a, e : (a - 69)] b))[731, ((- (- 880)) % (- 733))][(sum[a : ((- 285) * 854), b : (sum[a : (- (- 300)), b : 797] (if true then a else (if false then b else a))), c : 673] c), ((- (sum[a : (- 430)] 864)) + (sum[a : 104, b : 209, c : (961 / (- 443)), d : 420] (sum[e : b] d))), 973]) 
	jno .jump482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump482:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump483: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump483 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump240:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump484
	mov rax, [rel const11] ; True
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump485
	mov rax, [rel const1] ; False
	push rax
	jmp .jump486
.jump485:
	mov rax, [rel const1] ; False
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const241] ; 701
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump487:
	cmp rax, [rsp + 8]
	jl .jump488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump488:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump486:
	pop rax
.jump484:
	push rax
	pop rax
	cmp rax, 0
	je .jump489
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump491
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump491:
	; Computing bound for 'd'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump492
	mov rax, [rel const242] ; 654
	push rax
	mov rax, [rel const243] ; 106
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump493
.jump492:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump494
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump494:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump495:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump496: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const244] ; 437
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump496 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump496 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump493:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump497:
	; Computing bound for 'c'
	mov rax, [rel const89] ; 891
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const245] ; 130
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump498:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump499
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump499:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((130 - b) / 891) 
	jno .jump500
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump500:
imul rdi, [rsp + 0 + 8] ; multiply by (if (! (! true)) then (106 + 654) else (sum[c : b, d : b] 437)) 
	jno .jump501
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump501:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump502
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump502:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump503: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump503 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump503 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump503 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump490
.jump489:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump504
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump504:
	push rax
	pop rax
	cmp rax, 0
	je .jump505
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump507
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump507:
	; Computing bound for 'd'
	mov rax, [rel const63] ; 361
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump508:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump509:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump510: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump510 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump511
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump511:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[c : b] c) 
	jno .jump512
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump512:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 361) 
	jno .jump513
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump513:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump514
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump514:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump515: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump516:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump517
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump517:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump518:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump519:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump520:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump521:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump522: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump522 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump522 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump522 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump515 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump515 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump515 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump523
	mov rax, [rel const246] ; 619
	push rax
	jmp .jump524
.jump523:
	mov rax, [rel const247] ; 820
	push rax
.jump524:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump525
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump525:
	; Computing bound for 'e'
	mov rax, [rel const248] ; 484
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump526:
	; Computing bound for 'd'
	mov rax, [rel const48] ; 326
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump527
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump527:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump528
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump528:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump529:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump530: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump530 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump530 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump530 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump530 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const249] ; 273
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump531:
	cmp rax, [rsp + 24]
	jl .jump532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump532:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump533:
	cmp rax, [rsp + 32]
	jl .jump534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump534:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump535:
	cmp rax, [rsp + 40]
	jl .jump536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump536:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump506
.jump505:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const250] ; 483
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump537:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const251] ; 606
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump538:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump539: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump539 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump540
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump540:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump541:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump542: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump542 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump542 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump542 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump543
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump543:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const252] ; 657
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump544:
	; Computing bound for 'c'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const253] ; 553
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump545
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump545:
	cmp rax, [rsp + 8]
	jl .jump546
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump546:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump547
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump547:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a[(- 553)] 
	jno .jump548
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump548:
	imul rdi, [rsp + 0 + 8] ; multiply by (657 - b) 
	jno .jump549
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump549:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[c : b, d : (sum[c : 606] b), e : (- 483)] b) 
	jno .jump550
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump550:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump551: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump552:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump553
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump553:
	; Computing bound for 'f'
	mov rax, [rel const254] ; 28
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump554:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump555: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump555 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump555 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump555 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump551 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump551 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump551 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump506:
.jump490:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump556
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump556:
	push rax
	pop rax
	cmp rax, 0
	je .jump557
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const255] ; 680
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump559
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump559:
	; Computing bound for 'd'
	mov rax, [rel const256] ; 296
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump560:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump561
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump561:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump562
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump562:
	imul rdi, [rsp + 0 + 8] ; multiply by 296 
	jno .jump563
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump563:
	imul rdi, [rsp + 0 + 16] ; multiply by 680 
	jno .jump564
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump564:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump565: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const257] ; 532
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump565 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump565 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump565 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump558
.jump557:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump566
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump566:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump567:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump568
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump568:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump569
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump569:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump570
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump570:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump571
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump571:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump572: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const258] ; 97
	push rax
	mov rax, [rel const259] ; 832
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump572 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump572 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump572 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump558:
	mov rax, [rel const260] ; 356
	push rax
	mov rax, [rel const11] ; True
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump573
	mov rax, [rel const261] ; 681
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump574
.jump573:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump575
	mov rax, [rel const262] ; 61
	push rax
	jmp .jump576
.jump575:
	mov rax, [rel const263] ; 200
	push rax
	pop rax
	neg rax
	push rax
.jump576:
.jump574:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump577
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump577:
	; Computing bound for 'e'
	mov rax, [rel const264] ; 717
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump578:
	; Computing bound for 'd'
	mov rax, [rel const16] ; 267
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump579
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump579:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump580:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump581: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const265] ; 5.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump581 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump581 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump581 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump581 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const266] ; 83.81
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump582
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump584:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump585
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump585:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump586: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump586 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump586 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump587
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump587:
	; Computing bound for 'e'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump588
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump589
.jump588:
	mov rax, [rel const267] ; 718
	push rax
.jump589:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump590:
	; Computing bound for 'd'
	mov rax, [rel const268] ; 927
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump591
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump591:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump592:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump593: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump594:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump595
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump595:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump596: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump596 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump596 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump593 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump593 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump593 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump593 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump583
.jump582:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump597
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump597:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump598:
	; Computing bound for 'd'
	mov rax, [rel const269] ; 77
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump599
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump599:
	; Computing bound for 'c'
	mov rax, [rel const270] ; 418
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump600:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump601: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump601 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump601 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump601 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump601 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump583:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump602:
	cmp rax, [rsp + 24]
	jl .jump603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump603:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump604:
	cmp rax, [rsp + 32]
	jl .jump605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump605:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump606:
	cmp rax, [rsp + 40]
	jl .jump607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump607:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const271] ; 156
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump608
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump610:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump611
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump611:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump612:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump613:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump614:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump615:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump616: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump616 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump616 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump616 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump609
.jump608:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump617:
	; Computing bound for 'd'
	mov rax, [rel const272] ; 287
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump618
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump618:
	; Computing bound for 'c'
	mov rax, [rel const273] ; 328
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump619:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 328 
	jno .jump620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump620:
	imul rdi, [rsp + 0 + 8] ; multiply by 287 
	jno .jump621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump621:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump622:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump623: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const274] ; 238
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump623 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump623 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump623 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump609:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const275] ; 715
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump624
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump624:
	cmp rax, [rsp + 24]
	jl .jump625
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump625:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump626
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump626:
	cmp rax, [rsp + 32]
	jl .jump627
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump627:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump628
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump628:
	cmp rax, [rsp + 40]
	jl .jump629
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump629:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump630:
	cmp rax, [rsp + 8]
	jl .jump631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump631:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const276] ; 572
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump632
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump632:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump633
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump633:
	; Computing bound for 'd'
	mov rax, [rel const277] ; 843
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump634:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump635
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump635:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump636: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump636 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump636 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump636 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump637:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[c : (- b), d : (- 843), e : b] b) 
	jno .jump638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump638:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- 572) + b) 
	jno .jump639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump639:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump640: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const278] ; 959
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump641
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump641:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump642:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump643: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const182] ; 324
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump643 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump643 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump644:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump645
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump645:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump646: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump646 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump646 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump640 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump640 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump647
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const84] ; 636
	push rax
	mov rax, [rel const279] ; 641
	push rax
	mov rax, [rel const280] ; 592
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	jmp .jump648
.jump647:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump648:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump649:
	cmp rax, [rsp + 8]
	jl .jump650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump650:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump651:
	cmp rax, [rsp + 16]
	jl .jump652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump652:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump653:
	cmp rax, [rsp + 24]
	jl .jump654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump654:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump655:
	; Computing bound for 'd'
	mov rax, [rel const281] ; 202
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump656
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump656:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const282] ; 580
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump657
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const283] ; 988
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump657:
	push rax
	pop rax
	cmp rax, 0
	je .jump658
	mov rax, [rel const11] ; True
	push rax
	jmp .jump659
.jump658:
	mov rax, [rel const11] ; True
	push rax
.jump659:
	pop rax
	cmp rax, 0
	je .jump660
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const284] ; 272
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump662
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump662:
	; Computing bound for 'd'
	mov rax, [rel const285] ; 348
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump663:
	; Computing bound for 'c'
	mov rax, [rel const126] ; 168
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump664
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump664:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 168) 
	jno .jump665
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump665:
	imul rdi, [rsp + 0 + 8] ; multiply by 348 
	jno .jump666
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump666:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 272) 
	jno .jump667
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump667:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump668: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump669:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump670: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump670 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump668 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump668 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump668 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const286] ; 997
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump671
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump671:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump672: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump673
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump674
.jump673:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump674:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump672 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const287] ; 900
	push rax
	mov rax, [rel const288] ; 883
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump675
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump675:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump676:
	cmp rax, [rsp + 24]
	jl .jump677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump677:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump678:
	cmp rax, [rsp + 32]
	jl .jump679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump679:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump680:
	cmp rax, [rsp + 40]
	jl .jump681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump681:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump661
.jump660:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump661:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump682:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump683: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump684
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump684:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump685: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump685 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump683 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump683 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump683 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump686:
	cmp rax, [rsp + 24]
	jl .jump687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump687:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump688:
	cmp rax, [rsp + 32]
	jl .jump689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump689:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump690:
	cmp rax, [rsp + 40]
	jl .jump691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump691:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump692:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump693
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump693:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump694:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump695:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump696:
imul rdi, [rsp + 0 + 16] ; multiply by (if (true && (if ((! true) != true) then false else [false][701])) then (array[c : ((130 - b) / 891), d : (if (! (! true)) then (106 + 654) else (sum[c : b, d : b] 437)), e : b] (c - c)) else (if (false || false) then (array[c : (sum[c : b] c), d : (- 361), e : b] (array[f : e, g : c, h : e] c))[273, b, (sum[c : (b / b), d : 326, e : 484, f : (if true then 619 else 820)] e)] else (array[c : a[(- 553)], d : (657 - b), e : (sum[c : b, d : (sum[c : 606] b), e : (- 483)] b)] (sum[f : 28, g : e, h : (c - c)] h))))[b, (sum[c : (if (if ((580 != b) && (988 <= b)) then true else true) then (array[c : (- 168), d : 348, e : (- 272)] (sum[f : e] b))[(- (883 / 900)), b, (sum[c : (997 - b)] (if false then c else b))] else b), d : 202, e : (array[c : (sum[c : (- b), d : (- 843), e : b] b), d : ((- 572) + b)] (sum[e : b, f : (sum[e : b, f : 959] 324)] (- d)))[(if false then [592, 641, 636, b] else a)[b], b]] (- (sum[f : (- d)] c))), (if (false && false) then (array[c : b, d : 296, e : 680] [532]) else (array[c : b, d : b, e : b] [c, 832, 97]))[(if (83.81 == (sum[c : b, d : 267, e : 717, f : b] 5.64)) then (sum[c : b, d : (- 927), e : (if false then b else 718), f : (sum[c : b, d : b] b)] (sum[g : d, h : b] e)) else (sum[c : 418, d : (- 77), e : b, f : b] (d * e))), (if (false == true) then (- (- 681)) else (if false then 61 else (- 200))), 356][((if true then (array[c : b, d : b, e : b] b) else (array[c : 328, d : 287, e : b] 238))[715, (- b), b] * 156)]] 
	jno .jump697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump697:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump698: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump699
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump701
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump701:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump702:
	; Computing bound for 'g'
	mov rax, [rel const289] ; 800
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump703
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump703:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump704:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump705: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump706:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump707
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump707:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump708:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump709: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const290] ; 83.42
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump709 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump709 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump709 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump705 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump705 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump705 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump705 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump700
.jump699:
	mov rax, [rel const291] ; 4.88
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump700:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump710
	mov rax, [rel const292] ; 58.65
	push rax
	jmp .jump711
.jump710:
	mov rax, [rel const293] ; 32.0
	push rax
.jump711:
	mov rax, [rel const294] ; 38.04
	push rax
	mov rax, [rel const295] ; 27.8
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const296] ; 5.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump712:
	; Computing bound for 'f'
	mov rax, [rel const297] ; 952
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump713
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump713:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump714: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const298] ; 31.01
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump714 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump714 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const299] ; 66.67
	push rax
	mov rax, [rel const300] ; 6.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump715
	mov rax, [rel const301] ; 2.77
	push rax
	jmp .jump716
.jump715:
	mov rax, [rel const302] ; 63.33
	push rax
.jump716:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const303] ; 83.9
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const304] ; 24.73
	push rax
	mov rax, [rel const305] ; 58.17
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump717:
	; Computing bound for 'g'
	mov rax, [rel const306] ; 936
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump718
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump718:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump719:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump720: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const307] ; 12.31
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump720 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump720 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump720 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const308] ; 53.45
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump698 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump698 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump698 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump721
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const309] ; 459
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump723:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump724
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump724:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump725:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump726:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump727: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const310] ; 789
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump727 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const311] ; 109
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump728
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump728:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump729
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump729:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump730: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump731
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump731:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump732:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump733
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump733:
	; Computing bound for 'f'
	mov rax, [rel const312] ; 283
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump734:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 283 
	jno .jump735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	imul rdi, [rsp + 0 + 8] ; multiply by (b - b) 
	jno .jump736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump736:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump737:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump738:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump739: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump739 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump739 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump739 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump739 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump740
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump740:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump741:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump742: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump743
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump743:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump742 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump744
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump745
.jump744:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump745:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump746
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump747
.jump746:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump747:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump748:
	cmp rax, [rsp + 32]
	jl .jump749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump749:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump750:
	cmp rax, [rsp + 40]
	jl .jump751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump751:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump752:
	cmp rax, [rsp + 48]
	jl .jump753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump753:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump754:
	cmp rax, [rsp + 56]
	jl .jump755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump755:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump730 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump730 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump730 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump756:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump757
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump757:
	; Computing bound for 'c'
	mov rax, [rel const313] ; 490
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump758:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump759: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump759 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump759 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump759 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump722
.jump721:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const314] ; 205
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump760:
	; Computing bound for 'c'
	mov rax, [rel const315] ; 208
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump761
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump761:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 208 
	jno .jump762
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump762:
	imul rdi, [rsp + 0 + 8] ; multiply by ((b + 205) - b) 
	jno .jump763
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump763:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump764: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump764 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump764 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump765
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump765:
	; Computing bound for 'd'
	mov rax, [rel const96] ; 80
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump766:
	; Computing bound for 'c'
	mov rax, [rel const316] ; 550
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump767
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump767:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 550) 
	jno .jump768
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump768:
	imul rdi, [rsp + 0 + 8] ; multiply by 80 
	jno .jump769
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump769:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump770
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump770:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump771: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump771 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump771 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump771 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const317] ; 738
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump772
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump772:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump773: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump773 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const318] ; 773
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const207] ; 194
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump774
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump774:
	; Computing bound for 'e'
	mov rax, [rel const319] ; 915
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump775:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump776
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump776:
	; Computing bound for 'c'
	mov rax, [rel const212] ; 266
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump777:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump778: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump778 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump778 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump778 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump778 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump779:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const13] ; 629
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump780:
	cmp rax, [rsp + 24]
	jl .jump781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump781:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump782:
	cmp rax, [rsp + 32]
	jl .jump783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump783:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump784:
	cmp rax, [rsp + 40]
	jl .jump785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump785:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const320] ; 403
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump786:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const321] ; 967
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump787:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump788
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump788:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump789: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump789 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump789 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump790
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump790:
	cmp rax, [rsp + 16]
	jl .jump791
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump791:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump792
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump792:
	cmp rax, [rsp + 24]
	jl .jump793
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump793:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump794
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump796
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump796:
	; Computing bound for 'd'
	mov rax, [rel const322] ; 825
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump797:
	; Computing bound for 'c'
	mov rax, [rel const323] ; 512
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump798
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump798:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump799: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const287] ; 900
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump799 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump799 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump799 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump795
.jump794:
	mov rax, [rel const324] ; 603
	push rax
	mov rax, [rel const325] ; 183
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump800
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const326] ; 782
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump802
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump802:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump803: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump803 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump801
.jump800:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump801:
.jump795:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump804:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
.jump722:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump805
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const180] ; 160
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump807:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump808
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump808:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump809
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump809:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump810: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump810 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump811:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump812
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump812:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump813: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump813 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump813 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump813 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump813 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump806
.jump805:
	mov rax, [rel const327] ; 249
	push rax
.jump806:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump814
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump814:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump815: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump816
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump816:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const328] ; 610
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump817
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump817:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump818: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const255] ; 680
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump818 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump819:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump820
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump820:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump821: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump821 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump821 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump822
	mov rax, [rel const12] ; 332
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump824:
	; Computing bound for 'e'
	mov rax, [rel const329] ; 982
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump825
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump825:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump826:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump827: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const330] ; 747
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump827 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump827 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump827 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump828
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump828:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump823
.jump822:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump829
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump829:
	push rax
	pop rax
	cmp rax, 0
	je .jump830
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump831
.jump830:
	mov rax, [rel const331] ; 178
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump832
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump832:
	cqo
	idiv r10
	push rax
.jump831:
.jump823:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump833:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump815 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump834:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump835
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump835:
	; Computing bound for 'e'
	mov rax, [rel const251] ; 606
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump836:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump837
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump837:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump838:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump839: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const332] ; 63.52
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump839 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump839 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump839 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump839 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const333] ; 57.47
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump840
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump841
.jump840:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump842:
	cmp rax, [rsp + 8]
	jl .jump843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump843:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump841:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump844:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const319] ; 915
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump845:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump846: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump847
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump847:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump848:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump849
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump849:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump850:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump851: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump851 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump851 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump851 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump851 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump846 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump852
	mov rax, [rel const334] ; 908
	push rax
	jmp .jump853
.jump852:
	mov rax, [rel const335] ; 84
	push rax
.jump853:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump854:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump855
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump855:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump856: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump856 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump856 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump857
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump857:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[c : ((if (! false) then 908 else 84) % (sum[c : 915] (sum[d : b, e : b, f : c, g : b] b))), d : (if (57.47 >= (sum[c : b, d : b, e : 606, f : b] 63.52)) then b else a[b])] (- d)) 
	jno .jump858
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump858:
	imul rdi, [rsp + 0 + 8] ; multiply by (- b) 
	jno .jump859
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump859:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump860: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump860 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump860 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump861
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump861:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump862:
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const336] ; 429
	push rax
	mov rax, [rel const337] ; 703
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump863:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (703 * 429) 
	jno .jump864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump864:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump865: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump865 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const338] ; 984
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump866
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump866:
	cmp rax, [rsp + 8]
	jl .jump867
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump867:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump868
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump868:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump869:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump870: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const339] ; 965
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump870 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump870 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump870 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const340] ; 438
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump871
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump871:
	cmp rax, [rsp + 16]
	jl .jump872
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump872:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump873
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump873:
	cmp rax, [rsp + 24]
	jl .jump874
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump874:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const341] ; 498
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const342] ; 262
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump875
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump875:
	; Computing bound for 'e'
	mov rax, [rel const343] ; 999
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump876:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump877
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump877:
	; Computing bound for 'c'
	mov rax, [rel const344] ; 22
	push rax
	mov rax, [rel const345] ; 878
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump878:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump879: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump879 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump879 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump879 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump879 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump880
	mov rax, [rel const346] ; 378
	push rax
	jmp .jump881
.jump880:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump881:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump882
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump882:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump883:
	cqo
	idiv r10
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump884
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump886
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump886:
	; Computing bound for 'c'
	mov rax, [rel const347] ; 198
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump887:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump888: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const105] ; 479
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump888 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump888 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump889
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump889:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump890:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump891: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump891 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump891 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump892:
	cmp rax, [rsp + 8]
	jl .jump893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump893:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump885
.jump884:
	mov rax, [rel const236] ; 673
	push rax
.jump885:
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump894
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump894:
	; Computing bound for 'c'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump895
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump896
.jump895:
	mov rax, [rel const328] ; 610
	push rax
	pop rax
	neg rax
	push rax
.jump896:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump897:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump898: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump899:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump900
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump900:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump901
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump901:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump902
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump902:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump903: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const348] ; 478
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump904
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump904:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump905: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const349] ; 86.49
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump905 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump903 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump903 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump906
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump906:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump907:
	; Computing bound for 'f'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump908
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump908:
	cmp rax, [rsp + 8]
	jl .jump909
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump909:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump910
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump910:
	; Computing bound for 'e'
	mov rax, [rel const350] ; 340
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump911:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump912: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump912 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump912 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump912 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump912 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump913
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump913:
	cmp rax, [rsp + 16]
	jl .jump914
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump914:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump915
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump915:
	cmp rax, [rsp + 24]
	jl .jump916
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump916:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const351] ; 71.85
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump917
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump918
.jump917:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump918:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump898 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump898 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump919:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump920
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump920:
	cmp rax, [rsp + 24]
	jl .jump921
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump921:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump922
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump922:
	cmp rax, [rsp + 32]
	jl .jump923
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump923:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump924
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump924:
	cmp rax, [rsp + 40]
	jl .jump925
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump925:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump926
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump926:
	; Computing bound for 'e'
	mov rax, [rel const352] ; 331
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump927:
	; Computing bound for 'd'
	mov rax, [rel const353] ; 342
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump928
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump928:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- b) + 342) 
	jno .jump929
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump929:
	imul rdi, [rsp + 0 + 8] ; multiply by 331 
	jno .jump930
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump930:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump931
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump931:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump932: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump933
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump933:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump932 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump932 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump932 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump934
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump935
.jump934:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const354] ; 7
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump935:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const355] ; 123
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const356] ; 482
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump936:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump937
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump937:
	cmp rax, [rsp + 8]
	jl .jump938
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump938:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const357] ; 846
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump939:
	cmp rax, [rsp + 8]
	jl .jump940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump940:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump941:
	cmp rax, [rsp + 24]
	jl .jump942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump942:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump943:
	cmp rax, [rsp + 32]
	jl .jump944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump944:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump945:
	cmp rax, [rsp + 40]
	jl .jump946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump946:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump947
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const358] ; 83.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump947:
	push rax
	pop rax
	cmp rax, 0
	je .jump948
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump949
.jump948:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump949:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump950
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump951
.jump950:
	mov rax, [rel const263] ; 200
	push rax
.jump951:
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump952
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump953
.jump952:
	mov rax, [rel const235] ; 864
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump954
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const289] ; 800
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump956
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump956:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump957:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump958:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 800) 
	jno .jump959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump959:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump960: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump960 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump960 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump955
.jump954:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump961
	mov rax, [rel const359] ; 252
	push rax
	jmp .jump962
.jump961:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump962:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump963
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump963:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump964:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump965:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then 252 else b) 
	jno .jump966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump966:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump967: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const170] ; 111
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump967 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump967 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump955:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump968
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump968:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump969:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump970
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump970:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump971
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump971:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump972
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump972:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump973
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump973:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump974: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump975
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump975:
	cmp rax, [rsp + 8]
	jl .jump976
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump976:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump974 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump974 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump974 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump977:
	; Computing bound for 'd'
	mov rax, [rel const360] ; 64
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump978
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump978:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump979: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump979 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump979 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const361] ; 271
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump980
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump980:
	; Computing bound for 'f'
	mov rax, [rel const362] ; 477
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump981:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump982
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump982:
	; Computing bound for 'd'
	mov rax, [rel const363] ; 191
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump983:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump984: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump984 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump984 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump984 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump984 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const364] ; 892
	push rax
	mov rax, [rel const41] ; 903
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump985:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump986:
	cmp rax, [rsp + 24]
	jl .jump987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump987:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump988:
	cmp rax, [rsp + 32]
	jl .jump989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump989:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump990:
	cmp rax, [rsp + 40]
	jl .jump991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump991:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump992:
	cmp rax, [rsp + 16]
	jl .jump993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump993:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump994:
	cmp rax, [rsp + 24]
	jl .jump995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump995:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump953:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump996:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump997
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump997:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump998:
	; Computing bound for 'f'
	mov rax, [rel const353] ; 342
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump999
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump999:
	; Computing bound for 'e'
	mov rax, [rel const121] ; 981
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1000:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1001
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1001:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1002: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1002 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1002 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1002 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1002 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1003:
	; Computing bound for 'e'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1004
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump1004:
	push rax
	pop rax
	cmp rax, 0
	je .jump1005
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const365] ; 643
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1007:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1008
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1008:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1009: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1009 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1009 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump1006
.jump1005:
	mov rax, [rel const366] ; 40
	push rax
.jump1006:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1010
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1010:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1011:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1012
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1012:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1013:
	; Computing bound for 'd'
	mov rax, [rel const367] ; 207
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1014
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1014:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1015: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1015 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1015 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1015 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1016:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1017: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1017 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1017 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1017 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1017 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1018:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1019: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1020
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1022
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1022:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1023
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1023:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1024: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1024 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1025
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1025:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1026: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1026 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1027:
	cmp rax, [rsp + 8]
	jl .jump1028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1028:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1021
.jump1020:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1029
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1029:
	; Computing bound for 'e'
	mov rax, [rel const35] ; 698
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1030:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 698 
	jno .jump1031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1031:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1032:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1033: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const368] ; 712
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1033 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1033 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1034:
	cmp rax, [rsp + 16]
	jl .jump1035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1035:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1036:
	cmp rax, [rsp + 24]
	jl .jump1037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1037:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1021:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1019 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const365] ; 643
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const369] ; 14.82
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1038
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1040
	mov rax, [rel const370] ; 548
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1041
.jump1040:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1041:
	jmp .jump1039
.jump1038:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const126] ; 168
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1042:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1043
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1043:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1044
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1044:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1045:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1046: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1046 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1046 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1046 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1039:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1047
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1047:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1048
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1048:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1049: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1049 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1049 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1050
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const371] ; 290
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1052:
	; Computing bound for 'e'
	mov rax, [rel const372] ; 972
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const373] ; 432
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1053:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1054
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1054:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1055: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const374] ; 904
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1055 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const80] ; 441
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1056:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1057
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1057:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1058: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1059
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1059:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1058 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1058 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1060
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1060:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1061
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1061:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const375] ; 583
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1062
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1062:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1063:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1064: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const376] ; 35
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1064 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1064 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1064 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1065
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1065:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1066
	mov rax, [rel const278] ; 959
	push rax
	jmp .jump1067
.jump1066:
	mov rax, [rel const356] ; 482
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1068
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const252] ; 657
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1070:
	; Computing bound for 'e'
	mov rax, [rel const377] ; 5
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1071
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1071:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1072:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1073: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1073 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1073 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1073 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump1069
.jump1068:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const73] ; 768
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1074:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 768 
	jno .jump1075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1075:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1076: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1076 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const378] ; 746
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1077
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1077:
	cmp rax, [rsp + 8]
	jl .jump1078
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1078:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1069:
.jump1067:
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1079:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1080
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const379] ; 740
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1082:
	cmp rax, [rsp + 8]
	jl .jump1083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1083:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1081
.jump1080:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const380] ; 551
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1084
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1084:
	; Computing bound for 'e'
	mov rax, [rel const381] ; 940
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1085:
	; Computing bound for 'd'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1086
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1087
.jump1086:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1087:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1088
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1088:
	cmp rax, [rsp + 8]
	jl .jump1089
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1089:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1090
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1090:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1091: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1091 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1091 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1091 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1081:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1092
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1092:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1093: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1094:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1093 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const382] ; 749
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1095
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1095:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1096:
	; Computing bound for 'd'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1097
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const383] ; 231
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1099
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1099:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1100:
	; Computing bound for 'e'
	mov rax, [rel const384] ; 589
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1101
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1101:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1102:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1103: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1103 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1103 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1103 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump1098
.jump1097:
	mov rax, [rel const17] ; 12
	push rax
.jump1098:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1104
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1104:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1105: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1105 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1105 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1106
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1106:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1107:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1108
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1108:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1109: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1110
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1110:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1111:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1112: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const385] ; 519
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1112 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1112 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1109 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1109 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1113
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1113:
	; Computing bound for 'd'
	mov rax, [rel const386] ; 39.47
	push rax
	mov rax, [rel const387] ; 59.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1114
	mov rax, [rel const11] ; True
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1116
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1118
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1118:
	; Computing bound for 'e'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1119
	mov rax, [rel const388] ; 838
	push rax
	jmp .jump1120
.jump1119:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1120:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1121:
	; Computing bound for 'd'
	mov rax, [rel const389] ; 244
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1122
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1122:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 244 
	jno .jump1123
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1123:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then 838 else b) 
	jno .jump1124
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1124:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1125
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1125:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1126: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1126 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1126 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1126 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1117
.jump1116:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const390] ; 155
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1127
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1127:
	; Computing bound for 'e'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1128
	mov rax, [rel const391] ; 409
	push rax
	jmp .jump1129
.jump1128:
	mov rax, [rel const392] ; 237
	push rax
.jump1129:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1130:
	; Computing bound for 'd'
	mov rax, [rel const393] ; 425
	push rax
	mov rax, [rel const331] ; 178
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1131
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1131:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (178 * 425) 
	jno .jump1132
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1132:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then 409 else 237) 
	jno .jump1133
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1133:
	imul rdi, [rsp + 0 + 16] ; multiply by 155 
	jno .jump1134
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1134:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1135: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1135 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1135 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1135 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1117:
	jmp .jump1115
.jump1114:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1136
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1136:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const394] ; 124
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1137
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1137:
	; Computing bound for 'e'
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1138
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1139
.jump1138:
	mov rax, [rel const395] ; 591
	push rax
.jump1139:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1140:
	; Computing bound for 'd'
	mov rax, [rel const59] ; 196
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1141
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1141:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1142: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1142 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1142 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1142 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1143:
	; Computing bound for 'd'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1144
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1146
	mov rax, [rel const396] ; 363
	push rax
	jmp .jump1147
.jump1146:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1147:
	jmp .jump1145
.jump1144:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1145:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1148
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1148:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then (if false then 363 else b) else b) 
	jno .jump1149
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1149:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[d : 196, e : (if false then b else 591), f : (- 124)] e) 
	jno .jump1150
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1150:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump1151
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1151:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1152: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1152 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1152 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1152 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1115:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1153
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1153:
	cmp rax, [rsp + 8]
	jl .jump1154
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1154:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1155
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1155:
	; Computing bound for 'd'
	mov rax, [rel const383] ; 231
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1156:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1157: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1157 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1157 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const397] ; 941
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const398] ; 874
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1158
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1158:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1159: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1159 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1160:
	cmp rax, [rsp + 24]
	jl .jump1161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1161:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1162:
	cmp rax, [rsp + 32]
	jl .jump1163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1163:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1164:
	cmp rax, [rsp + 40]
	jl .jump1165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1165:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1166
	mov rax, [rel const399] ; 92
	push rax
	jmp .jump1167
.jump1166:
	mov rax, [rel const400] ; 693
	push rax
.jump1167:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1168:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if (if (59.1 != 39.47) then (if ((! true) == true) then (array[d : 244, e : (if false then 838 else b), f : b] true) else (array[d : (178 * 425), e : (if true then 409 else 237), f : 155] true)) else (array[d : (if true then (if false then 363 else b) else b), e : (sum[d : 196, e : (if false then b else 591), f : (- 124)] e), f : (- b)] (! (! true))))[(- (sum[d : (- 874)] b)), (- 941), (sum[d : 231, e : a[(- (b + b))]] e)] then 92 else 693) 
	jno .jump1169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1169:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[d : (- b), e : ((sum[d : (if false then (sum[d : b, e : 589, f : (231 % b)] d) else 12), e : ((- 749) % (sum[d : b] (b / b)))] d) / (if (! false) then a[740] else (sum[d : (if true then a else a)[b], e : 940, f : 551] e)))] (- (sum[f : b, g : e] 519))) 
	jno .jump1170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1170:
imul rdi, [rsp + 0 + 16] ; multiply by (- ((if (! (c != c)) then 959 else (if ((- b) == (- 482)) then (sum[d : (- b), e : (- 5), f : (- 657)] b) else (array[d : 768] d)[(- 746)])) + (- b))) 
	jno .jump1171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1171:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[d : ((- ((- 583) * b)) % (- (b % b))), e : (- (((sum[d : b, e : (- 441)] (e / d)) * (sum[d : (432 % b)] (- 904))) - 972)), f : 290] 35) 
	jno .jump1172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1172:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1173: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1173 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1173 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1173 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1173 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1051
.jump1050:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const15] ; 792
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1174
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1174:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1175: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const401] ; 510
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1175 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1176:
	; Computing bound for 'e'
	mov rax, [rel const402] ; 159
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1177
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1177:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1178
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1178:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1179
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1179:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1180: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const373] ; 432
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1180 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const403] ; 611
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1181:
	cmp rax, [rsp + 8]
	jl .jump1182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1182:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1183:
	; Computing bound for 'd'
	mov rax, [rel const255] ; 680
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1184
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1184:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1185: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const404] ; 584
	push rax
	mov rax, [rel const405] ; 772
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1186
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1186:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1185 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1185 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1187
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1187:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1188:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1189:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1190
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1190:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1191: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const406] ; 265
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1192:
	cmp rax, [rsp + 8]
	jl .jump1193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1193:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1191 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1191 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1194
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1194:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1195: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const407] ; 417
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1195 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1195 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1195 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1196:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const408] ; 408
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1197 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1197 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1197 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1198
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1198:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const409] ; 563
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1199
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1199:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1200:
	; Computing bound for 'd'
	mov rax, [rel const410] ; 457
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1201
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1201:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 457 
	jno .jump1202
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1202:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1203
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1203:
	imul rdi, [rsp + 0 + 16] ; multiply by 563 
	jno .jump1204
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1204:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1205: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const411] ; 112
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1205 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1205 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1205 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1206
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1207
.jump1206:
	mov rax, [rel const31] ; 958
	push rax
.jump1207:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1208:
	cmp rax, [rsp + 24]
	jl .jump1209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1209:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1210:
	cmp rax, [rsp + 32]
	jl .jump1211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1211:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1212:
	cmp rax, [rsp + 40]
	jl .jump1213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1213:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1214:
	cmp rax, [rsp + 8]
	jl .jump1215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1215:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const356] ; 482
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1216:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1217:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1218: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const412] ; 174
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1218 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1219
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1219:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1220
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1220:
	; Computing bound for 'f'
	mov rax, [rel const413] ; 912
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1221:
	; Computing bound for 'e'
	mov rax, [rel const363] ; 191
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1222
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1222:
	; Computing bound for 'd'
	mov rax, [rel const340] ; 438
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1223:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1224: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1224 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1224 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1224 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1224 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1225:
	; Computing bound for 'd'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1226
	mov rax, [rel const414] ; 552
	push rax
	jmp .jump1227
.jump1226:
	mov rax, [rel const415] ; 637
	push rax
.jump1227:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1228
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1228:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then 552 else 637) 
	jno .jump1229
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1229:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[d : (- 438), e : 191, f : 912, g : b] e) 
	jno .jump1230
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1230:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[d : b] 174) 
	jno .jump1231
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1231:
	imul rdi, [rsp + 0 + 24] ; multiply by 482 
	jno .jump1232
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1232:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1233: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const416] ; 173
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1233 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1233 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1233 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1233 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1234
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1235
.jump1234:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1235:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1236
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1236:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1237: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1238
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1240:
	; Computing bound for 'e'
	mov rax, [rel const204] ; 295
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1241
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1241:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1242: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1242 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1242 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump1239
.jump1238:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1239:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1237 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const417] ; 333
	push rax
	mov rax, [rel const155] ; 349
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1243
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1243:
	cmp rax, [rsp + 32]
	jl .jump1244
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1244:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1245
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1245:
	cmp rax, [rsp + 40]
	jl .jump1246
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1246:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1247
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1247:
	cmp rax, [rsp + 48]
	jl .jump1248
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1248:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1249
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1249:
	cmp rax, [rsp + 56]
	jl .jump1250
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1250:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1251
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump1253
	mov rax, [rel const418] ; 80.3
	push rax
	mov rax, [rel const419] ; 69.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump1253:
	push rax
	pop rax
	cmp rax, 0
	je .jump1254
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const420] ; 91
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1256:
	; Computing bound for 'f'
	mov rax, [rel const421] ; 918
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1257
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1257:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1258:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1259
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1259:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1260: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1260 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1260 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1260 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1260 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1261
	mov rax, [rel const422] ; 756
	push rax
	jmp .jump1262
.jump1261:
	mov rax, [rel const423] ; 47
	push rax
.jump1262:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1263:
	cqo
	idiv r10
	push rax
	jmp .jump1255
.jump1254:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1264
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1264:
	cmp rax, [rsp + 8]
	jl .jump1265
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1265:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1255:
	jmp .jump1252
.jump1251:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1252:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const424] ; 351
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1266
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1266:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1267: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1267 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1268:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const415] ; 637
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const425] ; 842
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1269
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1269:
	; Computing bound for 'e'
	mov rax, [rel const426] ; 428
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1270
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1270:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1271:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const380] ; 551
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1272:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const427] ; 260
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1273
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1273:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1274: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const58] ; 726
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1274 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1275
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1275:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1276: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const213] ; 275
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1276 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1276 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1277
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1277:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1278: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1278 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1278 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1278 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1279:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1280: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1281
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1281:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1282:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1283: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const428] ; 48.54
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1283 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1283 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const429] ; 42.59
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1284
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump1285
.jump1284:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1285:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1286:
	cmp rax, [rsp + 8]
	jl .jump1287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1287:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1280 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1288
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1288:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const430] ; 372
	push rax
	mov rax, [rel const431] ; 802
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1289:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1290
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump1290:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const432] ; 71.22
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1291
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const48] ; 326
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1293:
	; Computing bound for 'e'
	mov rax, [rel const433] ; 651
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1294
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1294:
	; Computing bound for 'd'
	mov rax, [rel const434] ; 542
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1295:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1296: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1296 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1296 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1296 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1297
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1297:
	cmp rax, [rsp + 8]
	jl .jump1298
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1298:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1292
.jump1291:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1292:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1299
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump1299:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1300:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (- (- ((if (! (c > 71.22)) then a[(sum[d : 542, e : 651, f : 326] e)] else b) / (((- 802) % 372) % (- (- b)))))) 
	jno .jump1301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1301:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[d : (sum[d : (sum[d : ((sum[d : (260 - b)] (726 * d)) + (- (- b))), e : 551] 275), e : (- (- (b % (- 428)))), f : ((- (- 842)) * (- 637))] b)] a[(if (c >= (42.59 % (sum[e : b, f : d] 48.54))) then d else b)]) 
	jno .jump1302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1302:
imul rdi, [rsp + 0 + 16] ; multiply by (((- (sum[d : (- 351)] d)) + (if (! false) then (if (true || (69.19 <= 80.3)) then ((if true then 756 else 47) / (sum[d : b, e : b, f : 918, g : 91] b)) else a[(b * b)]) else b)) * ((array[d : (if true then 552 else 637), e : (sum[d : (- 438), e : 191, f : 912, g : b] e), f : (sum[d : b] 174), g : 482] 173)[b, 349, 333, (sum[d : ((if true then b else b) - b)] (if true then (sum[e : 295, f : d] d) else b))] + [(array[d : 457, e : b, f : 563] 112)[b, b, (if true then b else 958)]][b])) 
	jno .jump1303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1303:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[d : (- (sum[d : (sum[d : (b * b), e : b] [e][(265 - e)]), e : b, f : (sum[d : 680, e : (array[d : b] 432)[611]] (772 % 584))] 417)), e : 159, f : (sum[d : 792] 510)] (408 - b)) 
	jno .jump1304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1304:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1305: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1306
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1307
.jump1306:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1307:
	mov rax, [rel const435] ; 25.64
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1308:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1309
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1309:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1310:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1311
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1311:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1312: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const436] ; 75.69
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1312 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1312 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1312 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1312 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1313
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1315
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1315:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1316:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1317: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1317 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1317 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1318
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump1318:
	push rax
	jmp .jump1314
.jump1313:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1319
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1319:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1320: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1320 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump1314:
	pop rax
	cmp rax, 0
	je .jump1321
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const437] ; 48.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1322
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const438] ; 75.11
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const439] ; 56.85
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const440] ; 71.24
	push rax
	mov rax, [rel const441] ; 81.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump1323
.jump1322:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1324
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1324:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1325:
	; Computing bound for 'i'
	mov rax, [rel const442] ; 601
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1326
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1326:
	; Computing bound for 'h'
	mov rax, [rel const443] ; 38
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1327:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1328: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1328 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1328 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1328 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1328 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1329:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1330
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1330:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- b) 
	jno .jump1331
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1331:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[h : 38, i : 601, j : b, k : g] g) 
	jno .jump1332
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump1332:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1333: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1333 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1333 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1334
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1334:
	cmp rax, [rsp + 16]
	jl .jump1335
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1335:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1336
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump1336:
	cmp rax, [rsp + 24]
	jl .jump1337
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump1337:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1323:
	pop rax
.jump1321:
	push rax
	pop rax
	cmp rax, 0
	je .jump1338
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const311] ; 109
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump1339
.jump1338:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1340:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1341: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1342
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1342:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1343:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1344
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1344:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1345: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1345 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1345 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1345 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1341 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const444] ; 24.72
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1346
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1346:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1347:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1348
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1348:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1349: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1349 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1349 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1349 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1350:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1351
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1351:
	; Computing bound for 'i'
	mov rax, [rel const445] ; 44
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1352:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1353
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump1353:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1354: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1354 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1354 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1354 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1354 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump1339:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1305 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1305 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1305 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1305 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1051:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2668
	sub rsp, 8 ; Add alignment
	sub rsp, 8 ; Add alignment
	mov rax, [rel const536] ; 34.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2669
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2671:
	; Computing bound for 'm'
	mov rax, [rel const537] ; 369
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2672
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2672:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 369 
	jno .jump2673
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2673:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2674
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2674:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2675: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2675 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2675 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2670
.jump2669:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const538] ; 222
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2676:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2677
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2677:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2678
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2678:
	imul rdi, [rsp + 0 + 8] ; multiply by 222 
	jno .jump2679
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2679:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2680: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2680 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2680 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2670:
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump2681
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump2681:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump2668:
	push rax
	pop rax
	cmp rax, 0
	jne .jump2682
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2683
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump2684
.jump2683:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2684:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2685:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2686
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2686:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2687:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2688: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2688 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2688 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2688 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2689
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2689:
	; Computing bound for 'm'
	mov rax, [rel const38] ; 985
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2690:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2691: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2691 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2691 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2692
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2694:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2695
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2695:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump2696
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2696:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump2697
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump2697:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2698: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2698 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2698 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const539] ; 944
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2699
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2699:
	cmp rax, [rsp + 16]
	jl .jump2700
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2700:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2701
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2701:
	cmp rax, [rsp + 24]
	jl .jump2702
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2702:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2703
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump2703:
	cmp rax, [rsp + 8]
	jl .jump2704
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump2704:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2693
.jump2692:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump2693:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump2682:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2705
	lea rdi, [rel const540] ; 'm'
	call _fail_assertion
.jump2705:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2706
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2708
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2709
.jump2708:
	mov rax, [rel const541] ; 83.64
	push rax
.jump2709:
	mov rax, [rel const542] ; 80.26
	push rax
	mov rax, [rel const543] ; 88.36
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const544] ; 35.12
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2710
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump2710:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2711: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const545] ; 71.03
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2712
	mov rax, [rel const546] ; 76.17
	push rax
	jmp .jump2713
.jump2712:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2713:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2711 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2707
.jump2706:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2707:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const514] ; 't'
	call _print
	sub rsp, 24
	lea rdi, [rsp]
	sub rsp, 8 ; Add alignment
	lea rsi, [rel const607] ; 't.png'
	call _read_image
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5256
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5256:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5257
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5257:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5258: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5258 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5259
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump5261
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5263:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5264
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5264:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5265:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5266: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5266 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5266 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5266 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump5262
.jump5261:
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5267
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump5268
.jump5267:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump5268:
.jump5262:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5269
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5269:
	; Computing bound for 'z'
	mov rax, [rel const73] ; 768
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5270:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 768 
	jno .jump5271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5271:
imul rdi, [rsp + 0 + 8] ; multiply by (if x().b then (sum[z : (b + h), A : s, B : (w + e)] n) else (if i(c) then (- n) else p)) 
	jno .jump5272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5272:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5273: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5274:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5275
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5275:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5276
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5276:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5277
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5277:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5278: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5278 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5278 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'A'
	add qword [rsp + 8], 1
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5273 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5273 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5260
.jump5259:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5279
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5279:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5280:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5281:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5282:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5283: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5284:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5285
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5285:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump5286
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5286:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump5287
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5287:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5288: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5288 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5288 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'A'
	add qword [rsp + 8], 1
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5283 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5283 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5260:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5289:
	cmp rax, [rsp + 16]
	jl .jump5290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5290:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5291:
	cmp rax, [rsp + 24]
	jl .jump5292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5292:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5293
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5293:
	; Computing bound for 'B'
	mov rax, [rel const250] ; 483
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5294:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5295
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5295:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5296:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5297: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const674] ; 53.47
	push rax
	mov rax, [rel const675] ; 43.8
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5297 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5297 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5297 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5297 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5298
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump5298:
	push rax
	pop rax
	cmp rax, 0
	je .jump5299
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5301:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5302:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5303: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const676] ; 86.92
	push rax
	mov rax, [rel const677] ; 31.26
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5304:
	; Computing bound for 'B'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5305
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump5306
.jump5305:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump5306:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5307
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5307:
	; Computing bound for 'A'
	mov rax, [rel const678] ; 841
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5308:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5309: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5309 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5309 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5309 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5303 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5300
.jump5299:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5310:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5311:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5312: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5313:
	cmp rax, [rsp + 16]
	jl .jump5314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5314:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5315:
	cmp rax, [rsp + 24]
	jl .jump5316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5316:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5312 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5300:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5317
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5317:
	cmp rax, [rsp + 8]
	jl .jump5318
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5318:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5319
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5321:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5322
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5322:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5323:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5324: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5324 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5324 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5324 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const679] ; 51.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5320
.jump5319:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump5320:
	mov rax, [rel const680] ; 32.69
	push rax
	mov rax, [rel const681] ; 89.47
	push rax
	mov rax, [rel const304] ; 24.73
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const682] ; 83.23
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5325
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5327:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5328:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5329
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5329:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5330
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5330:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5331:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5332:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5333
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5333:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5334:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5335: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5335 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5335 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5335 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5336:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5337
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5337:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5338: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5338 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5338 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5338 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5339:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5340: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5341
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5341:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5342:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump5343: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 0], 1
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5343 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5344
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump5344:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5345:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5346
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5346:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5347:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump5348: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5348 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5348 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5348 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5348 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5340 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5340 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5340 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5349
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5349:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5350:
	; Computing bound for 'z'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5351
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5352
.jump5351:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump5352:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5353
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5353:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then w else e) 
	jno .jump5354
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5354:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5355
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5355:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[z : (sum[z : (w / (sum[z : f, A : h, B : u] w)), A : p, B : p] (- k)), A : w, B : p] (sum[C : p, D : n, E : ((sum[C : f] k) % f), F : z] B)) 
	jno .jump5356
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5356:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump5357
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5357:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5358: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5359
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5359:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5360:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5361
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5361:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5362:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump5363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5363:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5364:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump5365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5365:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump5366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5366:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5367: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const683] ; 81.52
	push rax
	mov rax, [rel const684] ; 30.49
	push rax
	mov rax, [rel const685] ; 31.68
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'G'
	add qword [rsp + 24], 1
	; Compare G to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5367 ; If G < bound, next iter
	mov qword [rsp + 24], 0 ; G = 0
	add qword [rsp + 16], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5367 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5367 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5367 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5358 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5358 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5358 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5358 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5326
.jump5325:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5368:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5369
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5371:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5372
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5372:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5373:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5374
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5374:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump5375
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5375:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5376
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5376:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump5377
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5377:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump5378
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5378:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5379: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5380
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5381
.jump5380:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump5381:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5382
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5382:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5383:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5384
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5384:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5385:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5386:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5387:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump5388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5388:
	imul rdi, [rsp + 0 + 24] ; multiply by (if (e == z) then w else g) 
	jno .jump5389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5389:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5390: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5391
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump5392
.jump5391:
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
.jump5392:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5393
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5393:
	cmp rax, [rsp + 16]
	jl .jump5394
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5394:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5395
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5395:
	cmp rax, [rsp + 24]
	jl .jump5396
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5396:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'G'
	add qword [rsp + 24], 1
	; Compare G to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5390 ; If G < bound, next iter
	mov qword [rsp + 24], 0 ; G = 0
	add qword [rsp + 16], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5390 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5390 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5390 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5379 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5379 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5379 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5379 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5370
.jump5369:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump5397
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5398
.jump5397:
	mov rax, [rel const686] ; 23.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump5399
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5400
.jump5399:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5401
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump5401:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump5400:
.jump5398:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5402:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5403
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5403:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5404:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5405
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5405:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump5406
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5406:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5407
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5407:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5408
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5408:
	imul rdi, [rsp + 0 + 24] ; multiply by (if x().b then w else (if i(23.84) then e else (h % f))) 
	jno .jump5409
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5409:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump5410: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5411
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5411:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5412:
	; Computing bound for 'E'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5413:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5414
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5414:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5415:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5416
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5416:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5417: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 24], 1
	; Compare G to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5417 ; If G < bound, next iter
	mov qword [rsp + 24], 0 ; G = 0
	add qword [rsp + 16], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5417 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5417 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5417 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5418
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5418:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5419:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump5420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5420:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[D : h, E : n, F : (- k), G : f] k) 
	jno .jump5421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5421:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump5422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5422:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump5423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5423:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5424: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 400 to rsp 
		mov r10, [rbp - 400 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5425:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5426
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5426:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump5427: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const687] ; 40.63
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 8], 1
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5427 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5427 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 400 to rsp 
		mov r10, [rbp - 400 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5428
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5428:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5429:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump5430: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 8], 1
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5430 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5430 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'G'
	add qword [rsp + 24], 1
	; Compare G to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5424 ; If G < bound, next iter
	mov qword [rsp + 24], 0 ; G = 0
	add qword [rsp + 16], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5424 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5424 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5424 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5410 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5410 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5410 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5410 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5370:
.jump5326:
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump5431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const688] ; 'z'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5431:
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 0]
	subsd xmm0, xmm1
	sub rsp, 8 ; Add alignment
	call _print_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	; Moving 16 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5610
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump5611
.jump5610:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5612
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5612:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5613:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5614
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5614:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5615: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5615 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5615 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5615 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump5611:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5616:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5617
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5617:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- n) 
	jno .jump5618
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5618:
imul rdi, [rsp + 0 + 8] ; multiply by (if (h == b) then (u * k) else (sum[A : h, B : w, C : b] h)) 
	jno .jump5619
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5619:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5620: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5620 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5620 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5621
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5623
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5623:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5624:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump5625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5625:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5626:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5627: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5627 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5627 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5622
.jump5621:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5628
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5628:
	; Computing bound for 'A'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5629
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump5630
.jump5629:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump5630:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5631:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then g else w) 
	jno .jump5632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5632:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5633:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5634: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5634 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5634 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5622:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5635:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5636
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5636:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5637
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5637:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5638
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5638:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5639: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5640:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5641
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5641:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5642
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5642:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5643
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5643:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump5644: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 8], 1
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5644 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5644 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5639 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5639 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5645
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5645:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5646:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5647:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump5648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5648:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5649: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5649 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5649 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 96
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5650
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5650:
	cmp rax, [rsp + 8]
	jl .jump5651
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5651:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5652
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5654
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5656
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5656:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5657:
	; Computing bound for 'A'
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump5658
	mov rax, [rel const407] ; 417
	push rax
	jmp .jump5659
.jump5658:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5660:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5661
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5661:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5662:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5663
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5663:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5664: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5664 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5664 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5664 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5664 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump5659:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5665
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5665:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (- (if x().b then 417 else (sum[A : k, B : b, C : u, D : f] n))) 
	jno .jump5666
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5666:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump5667
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5667:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5668
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5668:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5669: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump5670
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
.jump5670:
	push rax
	pop rax
	cmp rax, 0
	je .jump5671
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5673:
	; Computing bound for 'D'
	mov rax, [rel const359] ; 252
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5674
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5674:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 252 
	jno .jump5675
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5675:
	imul rdi, [rsp + 0 + 8] ; multiply by (- k) 
	jno .jump5676
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5676:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5677: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5677 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5677 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5672
.jump5671:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5678:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5679
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5679:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5680
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5680:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5681
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5681:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5682: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5682 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5682 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5672:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5669 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5669 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5669 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5655
.jump5654:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5683
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5683:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5684:
	; Computing bound for 'A'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5685
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5686
.jump5685:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump5686:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5687
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5687:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then e else u) 
	jno .jump5688
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5688:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5689
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5689:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump5690
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5690:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5691: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5692
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5692:
	; Computing bound for 'E'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5693
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5693:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5694:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5695: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5695 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5695 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5696:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5697
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5697:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5698: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5698 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5698 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5698 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5699:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5700
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5700:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump5701
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5701:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[D : e, E : (sum[D : e, E : B] w), F : k] (h * D)) 
	jno .jump5702
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5702:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5703: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5703 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5703 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5691 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5691 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5691 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5655:
	sub rsp, 24
	; Moving 24 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5704:
	cmp rax, [rsp + 16]
	jl .jump5705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5705:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5706:
	cmp rax, [rsp + 24]
	jl .jump5707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5707:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const697] ; 1.51
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5708
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump5709
.jump5708:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5710
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5710:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump5711
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5712
.jump5711:
	mov rax, [rel const18] ; 379
	push rax
.jump5712:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5713:
	; Computing bound for 'A'
	mov rax, [rel const698] ; 652
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5714:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5715
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5715:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- h) / 652) 
	jno .jump5716
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5716:
	imul rdi, [rsp + 0 + 8] ; multiply by (if i(c) then w else 379) 
	jno .jump5717
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5717:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5718
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5718:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5719: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5720:
	; Computing bound for 'D'
	sub rsp, 16
	; Moving 16 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5721
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5721:
	cmp rax, [rsp + 8]
	jl .jump5722
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5722:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5723
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5723:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5724 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5724 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5719 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5719 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5719 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5725:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5726
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5726:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5727
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5727:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5728
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5728:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5729: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5729 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5729 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5730
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5731
.jump5730:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump5731:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump5732
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump5733
.jump5732:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump5733:
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5734
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5734:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5735: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5735 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5736:
	cmp rax, [rsp + 24]
	jl .jump5737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5737:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5738:
	cmp rax, [rsp + 32]
	jl .jump5739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5739:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5740:
	cmp rax, [rsp + 40]
	jl .jump5741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5741:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5709:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5742:
	cmp rax, [rsp + 24]
	jl .jump5743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5743:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5744:
	cmp rax, [rsp + 32]
	jl .jump5745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5745:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5746:
	cmp rax, [rsp + 40]
	jl .jump5747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5747:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5653
.jump5652:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const699] ; 368
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5748:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5749
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5749:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5750
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5750:
	imul rdi, [rsp + 0 + 8] ; multiply by 368 
	jno .jump5751
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5751:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5752: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5752 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5752 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _l
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5753
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5755
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump5756
.jump5755:
	mov rax, [rel const700] ; 863
	push rax
.jump5756:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5757:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5758
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5758:
	; Computing bound for 'B'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5759
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5759:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5760:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5761:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5762:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5763: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const701] ; 807
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5763 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5763 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5764:
	cmp rax, [rsp + 16]
	jl .jump5765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5765:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5766:
	cmp rax, [rsp + 24]
	jl .jump5767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5767:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5768:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5769
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5769:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5770: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5770 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5770 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5770 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5770 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5771
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5771:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5772:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5773
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5773:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump5774
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5774:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump5775
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5775:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[A : k, B : (array[A : f, B : k] 807)[(- g), w], C : p, D : (if true then f else 863)] (- n)) 
	jno .jump5776
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5776:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5777: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump5778
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump5778:
	push rax
	pop rax
	cmp rax, 0
	je .jump5779
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	mov rax, [rel const60] ; 778
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5781
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump5781:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5782:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5783
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5783:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5784
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5784:
	imul rdi, [rsp + 0 + 8] ; multiply by (k / 778) 
	jno .jump5785
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5785:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5786: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5786 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5786 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5780
.jump5779:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5787:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5788
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5788:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump5789
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5789:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5790
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5790:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5791: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5791 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5791 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5780:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5777 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5777 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5777 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5792:
	cmp rax, [rsp + 24]
	jl .jump5793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5793:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5794:
	cmp rax, [rsp + 32]
	jl .jump5795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5795:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5796:
	cmp rax, [rsp + 40]
	jl .jump5797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5797:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5754
.jump5753:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5798
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5798:
	; Computing bound for 'B'
	mov rax, [rel const8] ; 653
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5799:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5800
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5800:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5801: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5801 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5801 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5801 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	pop rax
	cmp rax, 0
	je .jump5802
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5804
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5804:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5805:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5806: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5806 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5806 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	jmp .jump5803
.jump5802:
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
.jump5803:
	pop rax
	cmp rax, 0
	je .jump5807
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5809
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5809:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5810:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5811:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5812:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5813: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5814
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5815
.jump5814:
	sub rsp, 16
	; Moving 16 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5816:
	cmp rax, [rsp + 8]
	jl .jump5817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5817:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5815:
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5813 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5813 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5808
.jump5807:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5818
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5818:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5819:
	; Computing bound for 'B'
	mov rax, [rel const104] ; 1000
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5820
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5820:
	; Computing bound for 'A'
	mov rax, [rel const702] ; 648
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5821:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 648 
	jno .jump5822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5822:
	imul rdi, [rsp + 0 + 8] ; multiply by 1000 
	jno .jump5823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5823:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump5824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5824:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump5825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5825:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5826: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5827:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5828
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5828:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump5829
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5829:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump5830
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5830:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump5831: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5831 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5831 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5826 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5826 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5826 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5826 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5832:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5833
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5833:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5834: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5834 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5834 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5835:
	cmp rax, [rsp + 32]
	jl .jump5836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5836:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5837:
	cmp rax, [rsp + 40]
	jl .jump5838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5838:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5839:
	cmp rax, [rsp + 48]
	jl .jump5840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5840:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5841:
	cmp rax, [rsp + 56]
	jl .jump5842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5842:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5808:
.jump5754:
.jump5653:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	sub rsp, 40
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _x
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5843
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5843:
	cmp rax, [rsp + 8]
	jl .jump5844
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5844:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5845
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	jne .jump5847
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
.jump5847:
	push rax
	pop rax
	cmp rax, 0
	je .jump5848
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	jmp .jump5849
.jump5848:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5850
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	jmp .jump5851
.jump5850:
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
.jump5851:
.jump5849:
	jmp .jump5846
.jump5845:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5852
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5852:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5853:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5854
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5854:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5855:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5856:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump5857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5857:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5858:
	imul rdi, [rsp + 0 + 24] ; multiply by (n * g) 
	jno .jump5859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5859:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5860: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 32 bytes from rsp + 0 to rsp + 8 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5860 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5860 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5860 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5860 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5861
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5861:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5862:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5863
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5863:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5864:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5865:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5866:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump5867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5867:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump5868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5868:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5869: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5869 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5869 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5869 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5869 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5870:
	cmp rax, [rsp + 32]
	jl .jump5871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5871:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5872:
	cmp rax, [rsp + 40]
	jl .jump5873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5873:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5874:
	cmp rax, [rsp + 48]
	jl .jump5875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5875:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5876:
	cmp rax, [rsp + 56]
	jl .jump5877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5877:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5878
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump5879
.jump5878:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump5879:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5880:
	cmp rax, [rsp + 32]
	jl .jump5881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5881:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5882:
	cmp rax, [rsp + 40]
	jl .jump5883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5883:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5884:
	cmp rax, [rsp + 48]
	jl .jump5885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5885:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5886:
	cmp rax, [rsp + 56]
	jl .jump5887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5887:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5846:
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump5888
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5890
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5892:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5893: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5893 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump5891
.jump5890:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump5891:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5894
	mov rax, [rel const703] ; 72.16
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	mov rax, [rel const704] ; 371
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5896
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5896:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5897:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5898:
	imul rdi, [rsp + 0 + 8] ; multiply by 371 
	jno .jump5899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5899:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5900: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const705] ; 69.85
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5900 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5900 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5901:
	cmp rax, [rsp + 16]
	jl .jump5902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5902:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5903:
	cmp rax, [rsp + 24]
	jl .jump5904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5904:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5905
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump5906
.jump5905:
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump5906:
	mov rax, [rel const706] ; 93.89
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const707] ; 27.69
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump5895
.jump5894:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5907
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump5907:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5908
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5910
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump5910:
	push rax
	pop rax
	cmp rax, 0
	je .jump5911
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5913
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5913:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5914: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5914 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5915:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5916
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5916:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5917:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5918: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5918 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5918 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5918 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5919
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5919:
	cmp rax, [rsp + 32]
	jl .jump5920
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5920:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5921
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5921:
	cmp rax, [rsp + 40]
	jl .jump5922
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5922:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5923
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5923:
	cmp rax, [rsp + 48]
	jl .jump5924
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5924:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5925
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5925:
	cmp rax, [rsp + 56]
	jl .jump5926
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5926:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5912
.jump5911:
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
.jump5912:
	jmp .jump5909
.jump5908:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5927:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5928:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5929: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5929 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5930
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5930:
	cmp rax, [rsp + 8]
	jl .jump5931
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5931:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5909:
	pop rax
	cmp rax, 0
	je .jump5932
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const365] ; 643
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5934:
	cmp rax, [rsp + 16]
	jl .jump5935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5935:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5936:
	cmp rax, [rsp + 24]
	jl .jump5937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5937:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const708] ; 41.14
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5938
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump5938:
	push rax
	pop rax
	cmp rax, 0
	je .jump5939
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const162] ; 954
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5941:
	cmp rax, [rsp + 32]
	jl .jump5942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5942:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5943:
	cmp rax, [rsp + 40]
	jl .jump5944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5944:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5945:
	cmp rax, [rsp + 48]
	jl .jump5946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5946:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5947:
	cmp rax, [rsp + 56]
	jl .jump5948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5948:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5949
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump5950
.jump5949:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5951
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5951:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5952:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5953
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5953:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5954: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const709] ; 17.07
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5954 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5954 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5954 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump5950:
	jmp .jump5940
.jump5939:
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
.jump5940:
	jmp .jump5933
.jump5932:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5955
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	jmp .jump5956
.jump5955:
	mov rax, [rel const11] ; True
	push rax
.jump5956:
	pop rax
	cmp rax, 0
	je .jump5957
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5959
	mov rax, [rel const710] ; 79.43
	push rax
	jmp .jump5960
.jump5959:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump5960:
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5961
	mov rax, [rel const711] ; 32.6
	push rax
	jmp .jump5962
.jump5961:
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump5962:
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const712] ; 11.47
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump5958
.jump5957:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5963
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5963:
	; Computing bound for 'B'
	mov rax, [rel const713] ; 779
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5964:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5965
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5965:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5966: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5966 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5966 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5966 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
.jump5958:
.jump5933:
.jump5895:
	jmp .jump5889
.jump5888:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5967:
	; Computing bound for 'C'
	mov rax, [rel const714] ; 11
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5968
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5968:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5969:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5970
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5970:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5971
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5971:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump5972
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5972:
	imul rdi, [rsp + 0 + 16] ; multiply by 11 
	jno .jump5973
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5973:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump5974
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump5974:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5975: ; Begin body of loop
	; Compute loop body
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5976:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5977
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5977:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5978:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5979
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5979:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump5980: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5980 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5980 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5980 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5980 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const715] ; 77.65
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5975 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5975 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5975 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5975 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5981
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5981:
	cmp rax, [rsp + 32]
	jl .jump5982
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5982:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5983
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5983:
	cmp rax, [rsp + 40]
	jl .jump5984
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5984:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5985
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5985:
	cmp rax, [rsp + 48]
	jl .jump5986
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5986:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5987
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump5987:
	cmp rax, [rsp + 56]
	jl .jump5988
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump5988:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5889:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5989
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5991:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5992
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5992:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5993
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5993:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5994:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5995
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5995:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5996:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5997: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const359] ; 252
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5997 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5997 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5997 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5997 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5998:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5999
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump5999:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump6000
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6000:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[A : w, B : e, C : (s + h), D : e] 252) 
	jno .jump6001
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6001:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6002
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6002:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump6003
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6003:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6004: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6005
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6005:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6006:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6007
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6007:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6008
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6008:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump6009
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6009:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6010
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6010:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6011: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6012:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6013
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6013:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6014:
	; Computing bound for 'H'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6015:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6016
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6016:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 376 to rsp 
		mov r10, [rbp - 376 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6017:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6018
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6018:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump6019
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6019:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump6020
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6020:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6021
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6021:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump6022
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6022:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump6023: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 24], 1
	; Compare K to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6023 ; If K < bound, next iter
	mov qword [rsp + 24], 0 ; K = 0
	add qword [rsp + 16], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6023 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6023 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6023 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 376 to rsp 
		mov r10, [rbp - 376 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const716] ; 963
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6024
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6024:
	cmp rax, [rsp + 32]
	jl .jump6025
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6025:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6026
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6026:
	cmp rax, [rsp + 40]
	jl .jump6027
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6027:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6028
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6028:
	cmp rax, [rsp + 48]
	jl .jump6029
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6029:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6030
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6030:
	cmp rax, [rsp + 56]
	jl .jump6031
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6031:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6032
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6032:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (array[H : f, I : G, J : n, K : f] h)[963, (- f), G, (- p)] 
	jno .jump6033
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6033:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump6034
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6034:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump6035
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6035:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump6036
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6036:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump6037: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const717] ; 12.19
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const718] ; 55.22
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 440 to rsp 
		mov r10, [rbp - 440 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6038:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 376 to rsp 
		mov r10, [rbp - 376 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6039
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6039:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6040:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6041: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const719] ; 51.71
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6041 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6041 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6041 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'K'
	add qword [rsp + 24], 1
	; Compare K to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6037 ; If K < bound, next iter
	mov qword [rsp + 24], 0 ; K = 0
	add qword [rsp + 16], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6037 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6037 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6037 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6011 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6011 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6011 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6042:
	cmp rax, [rsp + 24]
	jl .jump6043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6043:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6044:
	cmp rax, [rsp + 32]
	jl .jump6045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6045:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6046:
	cmp rax, [rsp + 40]
	jl .jump6047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6047:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6004 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6004 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6004 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6004 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5990
.jump5989:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6048:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6049
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6049:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6050:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6051
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6051:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6052
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6052:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump6053
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6053:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6054
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6054:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump6055
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6055:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6056: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6057
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6057:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6058:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6059
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6059:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof q 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump6060
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6060:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6061
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6061:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump6062
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6062:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6063: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6063 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6063 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6063 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6064:
	cmp rax, [rsp + 24]
	jl .jump6065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6065:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6066:
	cmp rax, [rsp + 32]
	jl .jump6067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6067:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6068:
	cmp rax, [rsp + 40]
	jl .jump6069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6069:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6056 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6056 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6056 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6056 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6070
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6070:
	cmp rax, [rsp + 32]
	jl .jump6071
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6071:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6072
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6072:
	cmp rax, [rsp + 40]
	jl .jump6073
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6073:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6074
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6074:
	cmp rax, [rsp + 48]
	jl .jump6075
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6075:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6076
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6076:
	cmp rax, [rsp + 56]
	jl .jump6077
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6077:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump6078
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump6080
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6082:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6083:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6084
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6084:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6085:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6086: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6086 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6086 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6086 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6087
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6087:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[A : u, B : p, C : g] C) 
	jno .jump6088
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6088:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump6089
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6089:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6090: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6090 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6090 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6081
.jump6080:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6091:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6092
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6092:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (u + h) 
	jno .jump6093
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6093:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6094
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6094:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6095: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6096:
	cmp rax, [rsp + 32]
	jl .jump6097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6097:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6098:
	cmp rax, [rsp + 40]
	jl .jump6099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6099:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6100:
	cmp rax, [rsp + 48]
	jl .jump6101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6101:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6102:
	cmp rax, [rsp + 56]
	jl .jump6103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6103:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6095 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6095 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6081:
	call _l
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump6104
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6106:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6107
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6107:
	; Computing bound for 'B'
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6108
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump6109
.jump6108:
	sub rsp, 16
	; Moving 16 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6110:
	cmp rax, [rsp + 8]
	jl .jump6111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6111:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6109:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6112:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6113
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6113:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump6114
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6114:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (c != z()) then e else j[e]) 
	jno .jump6115
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6115:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6116
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6116:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump6117
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6117:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6118: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6119
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6119:
	; Computing bound for 'G'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6120
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6120:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6121:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6122
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6122:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6123:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6124: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6124 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6124 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6124 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6124 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6125:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6126
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6126:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6127:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- k) 
	jno .jump6128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6128:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump6129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6129:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[E : s, F : n, G : w, H : e] n) 
	jno .jump6130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6130:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump6131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6131:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6132: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const265] ; 5.64
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6133:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6134
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6134:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6135:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 384 to rsp 
		mov r10, [rbp - 384 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6136
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6136:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump6137: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6137 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6137 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6137 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6137 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6132 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6132 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6132 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6132 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6118 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6118 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6118 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6118 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6105
.jump6104:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6138
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump6139
.jump6138:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump6139:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6140:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6141
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6141:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6142
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6142:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6143
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6143:
	; Computing bound for 'B'
	mov rax, [rel const612] ; 15
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6144:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6145
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6145:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6146: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6146 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6146 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6146 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6147:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6148
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6148:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6149: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6149 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6149 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6149 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6150:
	; Computing bound for 'A'
	sub rsp, 40
	lea rdi, [rsp + 0]
	call _x
	; Moving 8 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	cmp rax, 0
	je .jump6151
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6153:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6154
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6154:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6155:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6156:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump6157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6157:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump6158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6158:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6159: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6159 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6159 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6159 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump6152
.jump6151:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6160:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6161
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6161:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6162:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6163:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6164:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump6165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6165:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6166: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6166 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6166 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6166 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6152:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6167:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6168:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6169: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6169 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6170
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6170:
	cmp rax, [rsp + 8]
	jl .jump6171
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6171:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6172
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6172:
	cmp rax, [rsp + 24]
	jl .jump6173
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6173:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6174
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6174:
	cmp rax, [rsp + 32]
	jl .jump6175
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6175:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6176
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6176:
	cmp rax, [rsp + 40]
	jl .jump6177
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6177:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6178
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6178:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if x().b then (array[A : h, B : h, C : g] p) else (array[A : n, B : n, C : u] u))[(array[A : n] b)[b], g, (- k)] 
	jno .jump6179
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6179:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[A : k, B : (sum[A : e, B : 15, C : k] k), C : g] g) 
	jno .jump6180
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6180:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump6181
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6181:
	imul rdi, [rsp + 0 + 24] ; multiply by (if true then b else e) 
	jno .jump6182
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6182:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6183: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6184
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6184:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6185:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6186
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6186:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6187:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump6188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6188:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump6189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6189:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump6190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6190:
	imul rdi, [rsp + 0 + 24] ; multiply by B 
	jno .jump6191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6191:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6192: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 152 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6193
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6193:
	cmp rax, [rsp + 16]
	jl .jump6194
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6194:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6195
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6195:
	cmp rax, [rsp + 24]
	jl .jump6196
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6196:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6192 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6192 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6192 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6192 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6183 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6183 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6183 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6183 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6105:
	jmp .jump6079
.jump6078:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6197
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const248] ; 484
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6199
	lea rdi, [rel const151] ; 'mod by zero'
	call _fail_assertion
.jump6199:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6200:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6201
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6201:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6202:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6203
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6203:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump6204
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6204:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f) 
	jno .jump6205
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6205:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump6206
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6206:
	imul rdi, [rsp + 0 + 24] ; multiply by (n % (- 484)) 
	jno .jump6207
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6207:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6208: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6209
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6209:
	; Computing bound for 'G'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6210
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6210:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6211:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6212: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6213:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6214
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6214:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6215:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump6216: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 432 to rsp 
		mov r10, [rbp - 432 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'I'
	add qword [rsp + 16], 1
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6216 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6216 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6216 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'F'
	add qword [rsp + 8], 1
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6212 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6212 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6217:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6218
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6218:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6219:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6220:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump6221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6221:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[E : e, F : C] (sum[G : s, H : u, I : A] I)) 
	jno .jump6222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6222:
	imul rdi, [rsp + 0 + 24] ; multiply by A 
	jno .jump6223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6223:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6224: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _z
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6224 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6224 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6224 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6224 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6208 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6208 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6208 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6208 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6198
.jump6197:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6225:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6226
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6226:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6227:
	; Computing bound for 'A'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6228
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6228:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6229:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6230: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6230 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6230 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6231:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6232
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6232:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6233:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6234:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump6235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6235:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[A : u, B : b] b) 
	jno .jump6236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6236:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6237: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6237 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6237 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6237 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const97] ; 325
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6238
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6238:
	cmp rax, [rsp + 24]
	jl .jump6239
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6239:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6240
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6240:
	cmp rax, [rsp + 32]
	jl .jump6241
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6241:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6242
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6242:
	cmp rax, [rsp + 40]
	jl .jump6243
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6243:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6244
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6244:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[A : w, B : g, C : (sum[A : u, B : b] b)] k)[325, p, (- (- g))] 
	jno .jump6245
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6245:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump6246
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6246:
	imul rdi, [rsp + 0 + 16] ; multiply by (w - g) 
	jno .jump6247
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6247:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump6248
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
.jump6248:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump6249: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6250
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6250:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6251:
	; Computing bound for 'F'
	sub rsp, 8 ; Add alignment
	mov rax, [rel const720] ; 25.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _i
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump6252
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump6253
.jump6252:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump6253:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6254
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
.jump6254:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const116] ; 945
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6255
	lea rdi, [rel const64] ; 'divide by zero'
	call _fail_assertion
.jump6255:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6256:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (945 / g) 
	jno .jump6257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6257:
	imul rdi, [rsp + 0 + 8] ; multiply by (if i(25.89) then h else w) 
	jno .jump6258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6258:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump6259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6259:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump6260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const26] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6260:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump6261: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6262
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
.jump6262:
	cmp rax, [rsp + 8]
	jl .jump6263
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
.jump6263:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const53] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6264:
	cmp rax, [rsp + 8]
	jl .jump6265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const54] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6265:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const721] ; 55.53
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6261 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6261 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6261 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6261 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6249 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6249 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6249 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6249 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6198:
.jump6079:
.jump5990:
	call _o
	add rsp, 40
	add rsp, 32
	add rsp, 24
	add rsp, 16
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const756] ; '(ArrayType (FloatType) 1)'
	lea rsi, [rsp]
	call _show
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	add rsp, 232 ; Local variables
	pop r12 ; begin jpl_main postlude
	pop rbp
	ret

