global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 81.56
const1: dq 19.88
const2: dq 95.91
const3: dq 4.68
const4: dq 79.5
const5: dq 0
const6: dq 1
const7: dq 788
const8: dq 780
const9: dq 1000
const10: dq 41.42
const11: dq 25.54
const12: dq 76.7
const13: dq 507
const14: dq 601
const15: db `non-positive loop bound`, 0
const16: dq 834
const17: dq 728
const18: dq 916
const19: dq 903
const20: db `overflow computing array size`, 0
const21: dq 41.98
const22: dq 75.04
const23: dq 75.36
const24: dq 885
const25: dq 466
const26: dq 869
const27: dq 460
const28: dq 77.0
const29: db `negative array index`, 0
const30: db `index too large`, 0
const31: dq 829
const32: dq 186
const33: dq 320
const34: dq 679
const35: dq 25.27
const36: dq 194
const37: dq 129
const38: dq 599
const39: dq 690
const40: dq 705
const41: dq 8.59
const42: dq 941
const43: dq 814
const44: dq 461
const45: dq 596
const46: dq 341
const47: dq 837
const48: dq 725
const49: dq 923
const50: dq 863
const51: dq 874
const52: dq 830
const53: dq 562
const54: dq 767
const55: dq 887
const56: dq 900
const57: dq 283
const58: dq 606
const59: dq 393
const60: dq 708
const61: dq 499
const62: dq 333
const63: db `divide by zero`, 0
const64: dq 665
const65: dq 649
const66: dq 241
const67: dq 325
const68: dq 230
const69: dq 693
const70: dq 37
const71: dq 443
const72: dq 698
const73: dq 45
const74: dq 639
const75: dq 684
const76: dq 385
const77: dq 504
const78: dq 743
const79: dq 192
const80: dq 615
const81: dq 678
const82: dq 638
const83: dq 204
const84: dq 114
const85: dq 199
const86: dq 17
const87: dq 870
const88: dq 831
const89: dq 79
const90: db `mod by zero`, 0
const91: dq 488
const92: dq 473
const93: dq 994
const94: dq 11.66
const95: dq 512
const96: dq 360
const97: dq 308
const98: dq 36.48
const99: dq 73.44
const100: dq 303
const101: dq 19
const102: dq 677
const103: dq 49.51
const104: dq 603
const105: dq 525
const106: dq 68.3
const107: dq 967
const108: dq 327
const109: dq 10.88
const110: dq 843
const111: dq 578
const112: dq 17.33
const113: dq 26.88
const114: dq 337
const115: dq 53.54
const116: dq 49.66
const117: dq 33.15
const118: dq 69.69
const119: db `(IntType)`, 0
const120: dq 40.3
const121: dq 761
const122: dq 70.32
const123: dq 16.69
const124: dq 515
const125: dq 628
const126: dq 1.93
const127: dq 52.88
const128: dq 105
const129: dq 44.79
const130: dq 50.09
const131: dq 53.8
const132: dq 463
const133: dq 89
const134: dq 27.13
const135: dq 26.38
const136: dq 91.66
const137: dq 66.33
const138: dq 88.11
const139: dq 25.97
const140: dq 63.39
const141: dq 754
const142: dq 462
const143: dq 540
const144: dq 524
const145: dq 433
const146: dq 30.29
const147: dq 77.45
const148: dq 45.71
const149: dq 50.59
const150: dq 332
const151: dq 927
const152: dq 858
const153: dq 50.46
const154: dq 35.27
const155: dq 62.57
const156: dq 17.73
const157: dq 28.94
const158: dq 72.03
const159: dq 81.54
const160: dq 71.25
const161: dq 31.48
const162: dq 24.16
const163: dq 26.23
const164: dq 422
const165: dq 50
const166: dq 495
const167: dq 14
const168: dq 899
const169: dq 6
const170: dq 908
const171: dq 25.93
const172: dq 41.54
const173: dq 757
const174: dq 56.98
const175: dq 714
const176: dq 804
const177: dq 240
const178: dq 68.72
const179: dq 589
const180: dq 251
const181: dq 752

section .text
g:
_g:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const103] ; 49.51
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump271
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump271:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump272
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump272:
	; Computing bound for 'm'
	mov rax, [rel const104] ; 603
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump273
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump273:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump274: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump274 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump274 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump274 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump275
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump277
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump277:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump278
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump278:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump279
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump279:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump280
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump280:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump281
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump281:
	imul rdi, [rsp + 0 + 16] ; multiply by (- f) 
	jno .jump282
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump282:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump283: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump283 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump283 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump283 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump276
.jump275:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump276:
	mov rax, [rel const6] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump284
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const105] ; 525
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump286
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump286:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump287
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump287:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump288
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump288:
	imul rdi, [rsp + 0 + 8] ; multiply by 525 
	jno .jump289
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump289:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump290: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump290 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump290 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump285
.jump284:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const106] ; 68.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump291
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	jmp .jump292
.jump291:
	mov rax, [rel const107] ; 967
	push rax
	pop rax
	neg rax
	push rax
.jump292:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump293
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump293:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump294
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump294:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump295
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump295:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (68.3 > l) then k else (- 967)) 
	jno .jump296
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump296:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump297: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump297 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump297 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump285:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump298
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump298:
	cmp rax, [rsp + 16]
	jl .jump299
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump299:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump300
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump300:
	cmp rax, [rsp + 24]
	jl .jump301
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump301:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump302
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump304
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump304:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump305
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump307
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump307:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump308
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump308:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump309
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump309:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump310
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump310:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump311: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump311 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump311 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump306
.jump305:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const36] ; 194
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump312
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump312:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump313
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump313:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump314
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump314:
	imul rdi, [rsp + 0 + 8] ; multiply by 194 
	jno .jump315
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump315:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump316: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump316 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump316 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump306:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump317
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump317:
	cmp rax, [rsp + 16]
	jl .jump318
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump318:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump319
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump319:
	cmp rax, [rsp + 24]
	jl .jump320
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump320:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump321
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump321:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump322
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump324
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump324:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump325
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump325:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump326
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump326:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump327
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump327:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump328
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump328:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump329
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump329:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump330: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump330 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump330 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump330 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump323
.jump322:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const46] ; 341
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump331
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump331:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump332
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump332:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump333
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump333:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump334
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump334:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump335
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump335:
	imul rdi, [rsp + 0 + 16] ; multiply by 341 
	jno .jump336
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump336:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump337: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump337 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump337 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump337 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump323:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump338
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump338:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump339: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump339 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump340
	mov rax, [rel const108] ; 327
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump341
.jump340:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump342
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump342:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump343
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump343:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump344: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump344 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump344 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump341:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump345
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump345:
	cmp rax, [rsp + 24]
	jl .jump346
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump346:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump347
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump347:
	cmp rax, [rsp + 32]
	jl .jump348
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump348:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump349
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump349:
	cmp rax, [rsp + 40]
	jl .jump350
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump350:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump351
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump351:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if (n >= b) then (array[q : c, r : f, s : d] f) else (array[q : n, r : o, s : 341] o))[(if true then (f * 327) else (sum[q : n, r : n] k)), b, (sum[q : n] k)] 
	jno .jump352
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump352:
imul rdi, [rsp + 0 + 8] ; multiply by (if (f < o) then (array[q : d, r : f] n) else (array[q : c, r : 194] k))[d, f] 
	jno .jump353
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump353:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump354
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump354:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump355: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump356
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump356:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump357
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump357:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump358: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump359
	sub rsp, 32
	; Moving 32 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump360
.jump359:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump360:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump358 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump361
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump361:
	cmp rax, [rsp + 8]
	jl .jump362
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump362:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump355 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump355 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump355 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump363
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump363:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump364
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump364:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump365: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const109] ; 10.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump366
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump367
.jump366:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const110] ; 843
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump368
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump368:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump369
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump369:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump370
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump370:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump371: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump371 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump371 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump371 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump367:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump365 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump365 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump372
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump372:
	cmp rax, [rsp + 24]
	jl .jump373
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump373:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump374
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump374:
	cmp rax, [rsp + 32]
	jl .jump375
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump375:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump376
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump376:
	cmp rax, [rsp + 40]
	jl .jump377
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump377:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump303
.jump302:
	sub rsp, 32
	; Moving 32 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump303:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const6] ; True
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	add rsp, 96 ; Local variables
	pop rbp
	ret

j:
_j:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump454
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump454:
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump455
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump455:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump456
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump456:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump457: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump458
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump458:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump459
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump459:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump460: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const131] ; 53.8
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump460 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump457 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump461
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump461:
	cmp rax, [rsp + 8]
	jl .jump462
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump462:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const132] ; 463
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump463
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump463:
	; Computing bound for 'k'
	mov rax, [rel const133] ; 89
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump464
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump464:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump465: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const134] ; 27.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump465 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump465 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump466
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump466:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump467
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump467:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump468: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const135] ; 26.38
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump468 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump468 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const136] ; 91.66
	push rax
	mov rax, [rel const137] ; 66.33
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump469
	mov rax, [rel const138] ; 88.11
	push rax
	jmp .jump470
.jump469:
	mov rax, [rel const139] ; 25.97
	push rax
.jump470:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 24
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump471
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump471:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump472: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const140] ; 63.39
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump472 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _g
	add rsp, 16
	add rsp, 16
	push rax
	pop rax
	cmp rax, 0
	je .jump473
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump474
.jump473:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump475
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump475:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const141] ; 754
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump476
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump476:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump477
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump477:
	; Computing bound for 'k'
	mov rax, [rel const142] ; 462
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump478
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump478:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump479: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const143] ; 540
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump479 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump479 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump480
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump480:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[k : 462, l : b] 540) 
	jno .jump481
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump481:
	imul rdi, [rsp + 0 + 8] ; multiply by (754 * f) 
	jno .jump482
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump482:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump483
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump483:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump484: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump484 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump484 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump484 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const144] ; 524
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump485
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump485:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump486
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump486:
	cmp rax, [rsp + 24]
	jl .jump487
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump487:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump488
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump488:
	cmp rax, [rsp + 32]
	jl .jump489
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump489:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump490
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump490:
	cmp rax, [rsp + 40]
	jl .jump491
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump491:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump492
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump494
	lea rdi, [rel const90] ; 'mod by zero'
	call _fail_assertion
.jump494:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump493
.jump492:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump493:
.jump474:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump495
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump495:
	; Computing bound for 'k'
	mov rax, [rel const145] ; 433
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump496
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump496:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- 433)) 
	jno .jump497
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump497:
imul rdi, [rsp + 0 + 8] ; multiply by (if g((sum[k : c] (- (- 63.39))), [((if false then 88.11 else 25.97) / (66.33 * 91.66)), (sum[k : c, l : d] 26.38), (sum[k : 89, l : 463] 27.13)], (array[k : f] (array[l : k] 53.8))[f]) then f else (if (array[k : (sum[k : 462, l : b] 540), l : (754 * f), m : (- b)] (! false))[b, (b - (f / 524)), c] then (f % c) else c)) 
	jno .jump498
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump498:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump499
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump499:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump500: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump500 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump500 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump500 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump501
	mov rax, [rel const146] ; 30.29
	push rax
	jmp .jump502
.jump501:
	mov rax, [rel const147] ; 77.45
	push rax
.jump502:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump503
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump503:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump504
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump504:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump505: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump506
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump506:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump507
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump507:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump508: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const148] ; 45.71
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump508 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump508 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump505 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump505 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const149] ; 50.59
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump509
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const150] ; 332
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump511
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump511:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const151] ; 927
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump512
	lea rdi, [rel const90] ; 'mod by zero'
	call _fail_assertion
.jump512:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump513
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump513:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (927 % m) 
	jno .jump514
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump514:
	imul rdi, [rsp + 0 + 8] ; multiply by 332 
	jno .jump515
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump515:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump516: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump517
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump517:
	cmp rax, [rsp + 24]
	jl .jump518
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump518:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump519
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump519:
	cmp rax, [rsp + 32]
	jl .jump520
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump520:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump521
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump521:
	cmp rax, [rsp + 40]
	jl .jump522
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump522:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump523
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump523:
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump524
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump524:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump525: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump525 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump526
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump526:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[q : f] l) 
	jno .jump527
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump527:
	imul rdi, [rsp + 0 + 8] ; multiply by k[b, n, m] 
	jno .jump528
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump528:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump529: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump530
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump530:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump531
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump531:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump532
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump532:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump533
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump533:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump534: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump534 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump534 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump529 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump529 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump535
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump535:
	cmp rax, [rsp + 16]
	jl .jump536
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump536:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump537
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump537:
	cmp rax, [rsp + 24]
	jl .jump538
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump538:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump516 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump516 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump510
.jump509:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump539
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump540
.jump539:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump540:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump541
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump541:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump542
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump542:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump543
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump543:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (l > (- n)) then b else m) 
	jno .jump544
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump544:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump545: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump546
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump546:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump547
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump547:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump548
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump548:
	imul rdi, [rsp + 0 + 8] ; multiply by (m + p) 
	jno .jump549
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump549:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump550: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump550 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump550 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump545 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump545 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump510:
	mov rax, [rel const152] ; 858
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump551
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump551:
	cmp rax, [rsp + 16]
	jl .jump552
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump552:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump553
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump553:
	cmp rax, [rsp + 24]
	jl .jump554
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump554:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump555
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump557
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump558
.jump557:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
.jump558:
	jmp .jump556
.jump555:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
.jump556:
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump559
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump559:
	cmp rax, [rsp + 8]
	jl .jump560
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump560:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump561
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump563
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump563:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump564
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump564:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump565: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump565 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump562
.jump561:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump566
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump566:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump567
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump567:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump568
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump568:
	imul rdi, [rsp + 0 + 8] ; multiply by (t + n) 
	jno .jump569
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump569:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump570: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump570 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump570 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump571
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump571:
	cmp rax, [rsp + 16]
	jl .jump572
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump572:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump573
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump573:
	cmp rax, [rsp + 24]
	jl .jump574
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump574:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump575
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump577
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump577:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump578
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump578:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump579: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump580
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump580:
	cmp rax, [rsp + 16]
	jl .jump581
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump581:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump582
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump582:
	cmp rax, [rsp + 24]
	jl .jump583
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump583:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump584
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump586
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump588
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump588:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump589
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump589:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump590
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump590:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump591
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump591:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump592
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump592:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump593
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump593:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump594: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump594 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump594 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump594 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump587
.jump586:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump595
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump595:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump596
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump596:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump597
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump597:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump598
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump598:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump599
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump599:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump600
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump600:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump601: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump601 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump601 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump601 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump587:
	jmp .jump585
.jump584:
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump602
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump602:
	cmp rax, [rsp + 8]
	jl .jump603
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump603:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump585:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump579 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump576
.jump575:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump604
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump604:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump605
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump605:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump606: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump606 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const132] ; 463
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump607
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump607:
	cmp rax, [rsp + 8]
	jl .jump608
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump608:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump576:
.jump562:
	mov rax, [rel const153] ; 50.46
	push rax
	mov rax, [rel const154] ; 35.27
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump609
	sub asp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump611
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump611:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump612
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump612:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump613: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump614
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump614:
	cmp rax, [rsp + 24]
	jl .jump615
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump615:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump616
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump616:
	cmp rax, [rsp + 32]
	jl .jump617
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump617:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump618
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump618:
	cmp rax, [rsp + 40]
	jl .jump619
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump619:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump613 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump620
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump620:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump621
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump621:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump622: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const155] ; 62.57
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump622 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const156] ; 17.73
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _g
	add rsp, 16
	add rsp, 16
	add asp, 8 ; Remove alignment
	push rax
	jmp .jump610
.jump609:
	mov rax, [rel const6] ; True
	push rax
.jump610:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump623
	mov rax, [rel const157] ; 28.94
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump625
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump625:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump626: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const158] ; 72.03
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump626 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump627
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	mov rax, [rel const24] ; 885
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump629
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump629:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump630
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump630:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump631
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump631:
	imul rdi, [rsp + 0 + 8] ; multiply by (f + 885) 
	jno .jump632
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump632:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump633: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const159] ; 81.54
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump633 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump633 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump628
.jump627:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump634
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump634:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump635
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump635:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump636
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump636:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump637
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump637:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump638: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const160] ; 71.25
	push rax
	mov rax, [rel const161] ; 31.48
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump638 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump638 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump628:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump639
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump639:
	cmp rax, [rsp + 16]
	jl .jump640
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump640:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump641
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump641:
	cmp rax, [rsp + 24]
	jl .jump642
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump642:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump624
.jump623:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump643
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump643:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump644
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump644:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump645: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump645 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump645 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump646
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump646:
	cmp rax, [rsp + 24]
	jl .jump647
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump647:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump648
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump648:
	cmp rax, [rsp + 32]
	jl .jump649
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump649:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump650
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump650:
	cmp rax, [rsp + 40]
	jl .jump651
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump651:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump624:
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 104 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump652
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump652:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump653
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump653:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump654
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump654:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump655
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump655:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump656: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump657
	mov rax, [rel const162] ; 24.16
	push rax
	jmp .jump658
.jump657:
	mov rax, [rel const163] ; 26.23
	push rax
.jump658:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump659
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump659:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump660: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump661
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump662
.jump661:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump662:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump663
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump663:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump664
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump664:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump665
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump665:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump666: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump667
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump667:
	cmp rax, [rsp + 24]
	jl .jump668
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump668:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump669
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump669:
	cmp rax, [rsp + 32]
	jl .jump670
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump670:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump671
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump671:
	cmp rax, [rsp + 40]
	jl .jump672
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump672:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump666 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump666 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump666 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump660 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump656 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump656 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump673
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump673:
	cmp rax, [rsp + 16]
	jl .jump674
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump674:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump675
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump675:
	cmp rax, [rsp + 24]
	jl .jump676
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump676:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 104 ; Local variables
	pop rbp
	ret

s:
_s:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 24
	; Moving 24 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump779
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump779:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump780
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump781
.jump780:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump781:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump782
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump782:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump783
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump784
.jump783:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump784:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump785
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump785:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if h then m else q) 
	jno .jump786
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump786:
	imul rdi, [rsp + 0 + 8] ; multiply by (if h then (- c) else (- q)) 
	jno .jump787
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump787:
	imul rdi, [rsp + 0 + 16] ; multiply by (- l) 
	jno .jump788
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump788:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump789: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump790
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump790:
	; Computing bound for 'A'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump791
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump792
.jump791:
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
.jump792:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump793
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump793:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump794
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump794:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump795
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump795:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then d else m) 
	jno .jump796
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump796:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump797
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump797:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump798: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump799
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump800
.jump799:
	mov rax, [rel const6] ; True
	push rax
.jump800:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump798 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump798 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump798 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump789 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump789 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump789 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump801
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump801:
	cmp rax, [rsp + 24]
	jl .jump802
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump802:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump803
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump803:
	cmp rax, [rsp + 32]
	jl .jump804
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump804:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump805
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump805:
	cmp rax, [rsp + 40]
	jl .jump806
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump806:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump807
	mov rax, [rel const171] ; 25.93
	push rax
	jmp .jump808
.jump807:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump809
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump809:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump810: ; Begin body of loop
	; Compute loop body
	sub asp, 8 ; Add alignment
	call _j
	add asp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump810 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump808:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	call _j
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump811
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump812
.jump811:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump812:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump813
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump813:
	cmp rax, [rsp + 8]
	jl .jump814
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump814:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const172] ; 41.54
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump815
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump815:
	cmp rax, [rsp + 8]
	jl .jump816
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump816:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump817
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump818
.jump817:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump818:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump819
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump819:
	cmp rax, [rsp + 8]
	jl .jump820
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump820:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump821
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump823
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump825
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump826
.jump825:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump826:
	jmp .jump824
.jump823:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump824:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump827
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump827:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump828
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump828:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump829
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump829:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump830
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump830:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump831
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump831:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump832
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump832:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump833: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const173] ; 757
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump833 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump833 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump833 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump834
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump834:
	cmp rax, [rsp + 24]
	jl .jump835
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump835:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump836
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump836:
	cmp rax, [rsp + 32]
	jl .jump837
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump837:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump838
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump838:
	cmp rax, [rsp + 40]
	jl .jump839
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump839:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump840
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump840:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump841
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump843
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump845
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump847
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump847:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump848
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump848:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump849
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump849:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- r) 
	jno .jump850
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump850:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump851
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump851:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump852
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump852:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump853: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump853 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump853 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump853 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump846
.jump845:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump854
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump854:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump855
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump855:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump856
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump856:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump857
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump857:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump858
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump858:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump859
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump859:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump860: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const174] ; 56.98
	push rax
	sub asp, 8 ; Add alignment
	call _j
	add asp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump860 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump860 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump860 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump846:
	jmp .jump844
.jump843:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump861
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump862
.jump861:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump862:
	pop rax
	cmp rax, 0
	je .jump863
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump865
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump867
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump867:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump868
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump868:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump869
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump869:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump870
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump870:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump871
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump871:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump872
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump872:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump873: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump873 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump873 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump873 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump866
.jump865:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump874
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump874:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump875
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump875:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump876
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump876:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump877
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump877:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump878
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump878:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump879
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump879:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump880: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump880 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump880 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump880 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump866:
	jmp .jump864
.jump863:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump881
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump882
.jump881:
	mov rax, [rel const5] ; False
	push rax
.jump882:
	pop rax
	cmp rax, 0
	je .jump883
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump885
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump885:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump886
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump886:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump887
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump887:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump888
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump888:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump889
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump889:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump890
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump890:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump891: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump891 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump891 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump891 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump884
.jump883:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump892
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump892:
	; Computing bound for 'A'
	mov rax, [rel const175] ; 714
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump893
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump893:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump894
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump894:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump895
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump895:
	imul rdi, [rsp + 0 + 8] ; multiply by 714 
	jno .jump896
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump896:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump897
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump897:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump898: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump898 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump898 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump898 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump884:
.jump864:
.jump844:
	jmp .jump842
.jump841:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump899
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump899:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump900
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump900:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump901
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump901:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump902: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump902 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump903
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump903:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[z : q] l) 
	jno .jump904
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump904:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump905
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump905:
	imul rdi, [rsp + 0 + 16] ; multiply by (q - p) 
	jno .jump906
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump906:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump907: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump907 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump907 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump907 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump842:
	jmp .jump822
.jump821:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump908
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump910
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump910:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump911
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump911:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump912
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump912:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump913
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump913:
	imul rdi, [rsp + 0 + 8] ; multiply by (- p) 
	jno .jump914
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump914:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump915
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump915:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump916: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump916 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump916 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump916 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump909
.jump908:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump917
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump917:
	; Computing bound for 'A'
	mov rax, [rel const176] ; 804
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump918
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump918:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump919
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump919:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- c) 
	jno .jump920
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump920:
	imul rdi, [rsp + 0 + 8] ; multiply by 804 
	jno .jump921
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump921:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump922
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump922:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump923: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump923 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump923 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump923 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump909:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	mov rax, [rel const45] ; 596
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump924
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump924:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump925
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump925:
	; Computing bound for 'z'
	mov rax, [rel const177] ; 240
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump926
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump926:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump927: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 8], 1
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump927 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump927 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump928
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump928:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[z : 240, A : v] u) 
	jno .jump929
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump929:
	imul rdi, [rsp + 0 + 8] ; multiply by (f * 596) 
	jno .jump930
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump930:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump931: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump932
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump932:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump933
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump933:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump934
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump934:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump935
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump935:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump936
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump936:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump937
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump937:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump938: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump938 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump938 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump938 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'A'
	add qword [rsp + 8], 1
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump931 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump931 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump939
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump939:
	cmp rax, [rsp + 16]
	jl .jump940
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump940:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump941
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump941:
	cmp rax, [rsp + 24]
	jl .jump942
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump942:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump943
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump943:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump944
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump944:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump945
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump945:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump946
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump946:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump947
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump947:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump948
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump948:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump949: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump949 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump949 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump949 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump950
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump950:
	cmp rax, [rsp + 24]
	jl .jump951
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump951:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump952
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump952:
	cmp rax, [rsp + 32]
	jl .jump953
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump953:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump954
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump954:
	cmp rax, [rsp + 40]
	jl .jump955
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump955:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump956
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump958
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump958:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump959
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump959:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump960
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump960:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- q) 
	jno .jump961
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump961:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump962
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump962:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump963
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump963:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump964: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump964 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump964 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump964 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump957
.jump956:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump965
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump966
.jump965:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump966:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump967
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump967:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump968
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump968:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump969
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump969:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump970
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump970:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump971
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump971:
	imul rdi, [rsp + 0 + 16] ; multiply by (if h then r else q) 
	jno .jump972
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump972:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump973: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump973 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump973 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump973 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump957:
	mov rdi, 96
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump974
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump974:
	cmp rax, [rsp + 8]
	jl .jump975
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump975:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump822:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 120 ; Local variables
	pop rbp
	ret

v:
_v:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump976
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump977
.jump976:
	mov rax, [rel const5] ; False
	push rax
.jump977:
	pop rax
	add rsp, 16 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 16 ; Local variables
	pop rbp
	ret
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _s
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump978
	lea rdi, [rel const90] ; 'mod by zero'
	call _fail_assertion
.jump978:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump979
	lea rdi, [rel const90] ; 'mod by zero'
	call _fail_assertion
.jump979:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump980
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump980:
	cmp rax, [rsp + 24]
	jl .jump981
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump981:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump982
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump982:
	cmp rax, [rsp + 32]
	jl .jump983
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump983:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump984
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump984:
	cmp rax, [rsp + 40]
	jl .jump985
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump985:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump986
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump988
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump988:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump989
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump989:
	; Computing bound for 'D'
	mov rax, [rel const179] ; 589
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump990
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump990:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 589 
	jno .jump991
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump991:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump992
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump992:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump993
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump993:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump994: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump994 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump994 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump994 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 88 to rsp 
		mov r10, [r12 - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump995
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump995:
	cmp rax, [rsp + 24]
	jl .jump996
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump996:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump997
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump997:
	cmp rax, [rsp + 32]
	jl .jump998
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump998:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump999
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump999:
	cmp rax, [rsp + 40]
	jl .jump1000
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1000:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump987
.jump986:
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1001
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1003
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const6] ; True
	push rax
	mov rax, [rel const6] ; True
	push rax
	mov rdi, 24
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump1004
.jump1003:
	mov rax, [rel const5] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump1004:
	jmp .jump1002
.jump1001:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1005
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1005:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1006
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1006:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump1007: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 0], 1
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1007 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1002:
.jump987:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1008
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
.jump1008:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1009
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1009:
	cmp rax, [rsp + 8]
	jl .jump1010
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1010:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1011
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1013
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1013:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump1014
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1014:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump1015: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub asp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _s
	add asp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 0], 1
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1015 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1016
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1016:
	cmp rax, [rsp + 8]
	jl .jump1017
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1017:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1012
.jump1011:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1018
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1018:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1019
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1019:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1020
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump1021
.jump1020:
	sub rsp, 8
	; Moving 8 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1022
	mov rax, [rel const76] ; 385
	push rax
	jmp .jump1023
.jump1022:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1023:
.jump1021:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1024
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1024:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if i then B else (if i then 385 else (- x))) 
	jno .jump1025
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1025:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump1026
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1026:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump1027
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1027:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump1028: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 64 to rsp 
		mov r10, [r12 - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1028 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1028 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1028 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1012:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1029
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1030
.jump1029:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump1030:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1031
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1031:
	cmp rax, [rsp + 24]
	jl .jump1032
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1032:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1033
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1033:
	cmp rax, [rsp + 32]
	jl .jump1034
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1034:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1035
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1035:
	cmp rax, [rsp + 40]
	jl .jump1036
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1036:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 80 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp ; end of jpl_main prelude
	mov rax, [rel const0] ; 81.56
	push rax
	mov rax, [rel const1] ; 19.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	mov rax, [rel const2] ; 95.91
	push rax
	jmp .jump2
.jump1:
	mov rax, [rel const3] ; 4.68
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const4] ; 79.5
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3
	mov rax, [rel const5] ; False
	push rax
	jmp .jump4
.jump3:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump6
.jump5:
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7
	mov rax, [rel const7] ; 788
	push rax
	jmp .jump8
.jump7:
	mov rax, [rel const8] ; 780
	push rax
.jump8:
	mov rax, [rel const9] ; 1000
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump6:
	pop rax
	xor rax, 1
	push rax
.jump4:
	pop rax
	cmp rax, 0
	je .jump9
	mov rax, [rel const6] ; True
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump11
	mov rax, [rel const10] ; 41.42
	push rax
	jmp .jump12
.jump11:
	mov rax, [rel const11] ; 25.54
	push rax
.jump12:
	mov rax, [rel const12] ; 76.7
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump13
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const13] ; 507
	push rax
	mov rax, [rel const14] ; 601
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump15
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump15:
	; Computing bound for 'b'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump16
	mov rax, [rel const16] ; 834
	push rax
	jmp .jump17
.jump16:
	mov rax, [rel const17] ; 728
	push rax
.jump17:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump18:
	; Computing bound for 'a'
	mov rax, [rel const18] ; 916
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const19] ; 903
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump19:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- (- 903)) * (- 916)) 
	jno .jump20
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump20:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then 834 else 728) 
	jno .jump21
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump21:
	imul rdi, [rsp + 0 + 16] ; multiply by (601 - 507) 
	jno .jump22
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump22:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump23: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const21] ; 41.98
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump23 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump23 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump23 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump14
.jump13:
	mov rax, [rel const22] ; 75.04
	push rax
	mov rax, [rel const23] ; 75.36
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const24] ; 885
	push rax
	mov rax, [rel const25] ; 466
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump26
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump26:
	; Computing bound for 'b'
	mov rax, [rel const26] ; 869
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump27
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump27:
	; Computing bound for 'a'
	mov rax, [rel const27] ; 460
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump28
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump28:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 460 
	jno .jump29
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump29:
	imul rdi, [rsp + 0 + 8] ; multiply by 869 
	jno .jump30
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump30:
	imul rdi, [rsp + 0 + 16] ; multiply by (466 + 885) 
	jno .jump31
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump31:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump32: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump33
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump33:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump34
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump34:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump35: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const28] ; 77.0
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump35 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump36
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump36:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump37
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump37:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump38: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump38 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump38 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump39
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump39:
	cmp rax, [rsp + 8]
	jl .jump40
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump40:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump32 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump32 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump32 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump25
.jump24:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const31] ; 829
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump41
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump41:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump42: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const32] ; 186
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump42 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump43
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump43:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const33] ; 320
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump44
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump44:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump45: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump45 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump46
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump46:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[a : 320] a) 
	jno .jump47
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump47:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[a : 829] 186) 
	jno .jump48
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump48:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump49: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const34] ; 679
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump50
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump50:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump51
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump51:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump52
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump52:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump53
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump53:
	imul rdi, [rsp + 0 + 8] ; multiply by a 
	jno .jump54
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump54:
	imul rdi, [rsp + 0 + 16] ; multiply by 679 
	jno .jump55
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump55:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump56: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const35] ; 25.27
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump56 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump56 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump56 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump49 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump49 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const36] ; 194
	push rax
	mov rax, [rel const37] ; 129
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump57
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump57:
	cmp rax, [rsp + 16]
	jl .jump58
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump58:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump59
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump59:
	cmp rax, [rsp + 24]
	jl .jump60
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump60:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump25:
.jump14:
	jmp .jump10
.jump9:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump61
	mov rax, [rel const38] ; 599
	push rax
	jmp .jump62
.jump61:
	mov rax, [rel const39] ; 690
	push rax
.jump62:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump63
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump63:
	; Computing bound for 'a'
	mov rax, [rel const40] ; 705
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump64
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump64:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 705 
	jno .jump65
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump65:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (if true then 599 else 690)) 
	jno .jump66
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump66:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump67: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump68
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump68:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump69
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump69:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump70
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump70:
	imul rdi, [rsp + 0 + 8] ; multiply by (- a) 
	jno .jump71
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump71:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump72: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump73
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump73:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump74
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump74:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump75
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump75:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump76
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump76:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump77
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump77:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump78
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump78:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump79: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const41] ; 8.59
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump79 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump79 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump79 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump72 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump72 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump67 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump67 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump80
	mov rax, [rel const42] ; 941
	push rax
	jmp .jump81
.jump80:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const43] ; 814
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump82
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump82:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump83: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const44] ; 461
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump83 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump81:
	pop rax
	neg rax
	push rax
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump84
	mov rax, [rel const45] ; 596
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump85
.jump84:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const46] ; 341
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump86
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump86:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump87: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const47] ; 837
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump87 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump85:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump88
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump88:
	cmp rax, [rsp + 16]
	jl .jump89
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump89:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump90
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump90:
	cmp rax, [rsp + 24]
	jl .jump91
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump91:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const48] ; 725
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump92
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump92:
	; Computing bound for 'b'
	mov rax, [rel const49] ; 923
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump93
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump93:
	; Computing bound for 'a'
	mov rax, [rel const50] ; 863
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump94
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump94:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 863) 
	jno .jump95
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump95:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 923) 
	jno .jump96
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump96:
	imul rdi, [rsp + 0 + 16] ; multiply by 725 
	jno .jump97
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump97:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump98: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump98 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump98 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump98 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const51] ; 874
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const52] ; 830
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump99
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump99:
	; Computing bound for 'b'
	mov rax, [rel const53] ; 562
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump100
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump100:
	; Computing bound for 'a'
	mov rax, [rel const54] ; 767
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump101
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump101:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump102: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump102 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump102 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump102 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const55] ; 887
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump103
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump103:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump104: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const56] ; 900
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump104 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump105
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump105:
	cmp rax, [rsp + 24]
	jl .jump106
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump106:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump107
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump107:
	cmp rax, [rsp + 32]
	jl .jump108
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump108:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump109
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump109:
	cmp rax, [rsp + 40]
	jl .jump110
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump110:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump111
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump111:
	; Computing bound for 'b'
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump112
	mov rax, [rel const57] ; 283
	push rax
	mov rax, [rel const58] ; 606
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const59] ; 393
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump113
.jump112:
	mov rax, [rel const60] ; 708
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const61] ; 499
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump114
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump114:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump115: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const62] ; 333
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump115 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump116
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
.jump116:
	cqo
	idiv r10
	push rax
.jump113:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump117
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump117:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump118
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const64] ; 665
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump120
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump120:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump121: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const65] ; 649
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump121 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump119
.jump118:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const66] ; 241
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump122
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump122:
	; Computing bound for 'b'
	mov rax, [rel const67] ; 325
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump123
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump123:
	; Computing bound for 'a'
	mov rax, [rel const68] ; 230
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump124
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump124:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump125: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump125 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump125 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump125 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump119:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump126
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump126:
	; Computing bound for 'b'
	mov rax, [rel const69] ; 693
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump127
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump127:
	; Computing bound for 'a'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump128
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump130
	mov rax, [rel const70] ; 37
	push rax
	jmp .jump131
.jump130:
	mov rax, [rel const71] ; 443
	push rax
.jump131:
	jmp .jump129
.jump128:
	mov rax, [rel const72] ; 698
	push rax
.jump129:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump132
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump132:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump133: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump133 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump133 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump133 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump134
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump134:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump135: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump135 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump135 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump135 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump136
	mov rax, [rel const73] ; 45
	push rax
	jmp .jump137
.jump136:
	mov rax, [rel const74] ; 639
	push rax
.jump137:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump138
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump138:
	; Computing bound for 'a'
	mov rax, [rel const75] ; 684
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump139
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump139:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 684 
	jno .jump140
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump140:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then 45 else 639) 
	jno .jump141
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump141:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump142: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const76] ; 385
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump143
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump143:
	cmp rax, [rsp + 8]
	jl .jump144
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump144:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump142 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump142 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const77] ; 504
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump145
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump145:
	; Computing bound for 'b'
	mov rax, [rel const78] ; 743
	push rax
	mov rax, [rel const79] ; 192
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump146
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump146:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const80] ; 615
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump147
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump147:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump148: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const81] ; 678
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump148 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump150: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump150 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump150 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump150 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const82] ; 638
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump151
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump151:
	cmp rax, [rsp + 16]
	jl .jump152
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump152:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump153
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump153:
	cmp rax, [rsp + 24]
	jl .jump154
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump154:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump155
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump155:
	cmp rax, [rsp + 16]
	jl .jump156
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump156:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump157
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump157:
	cmp rax, [rsp + 24]
	jl .jump158
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump158:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump10:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump159
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump159:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump160
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump160:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump161
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump161:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d) 
	jno .jump162
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump162:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump163
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump163:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump164
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump164:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump165: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump165 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump165 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump165 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump166
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump167
.jump166:
	mov rax, [rel const83] ; 204
	push rax
.jump167:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const84] ; 114
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump168
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump168:
	cmp rax, [rsp + 24]
	jl .jump169
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump169:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump170
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump170:
	cmp rax, [rsp + 32]
	jl .jump171
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump171:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump172
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump172:
	cmp rax, [rsp + 40]
	jl .jump173
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump173:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump174
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump174:
	cqo
	idiv r10
	push rax
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump175
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump176
.jump175:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump176:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump177
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump179
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump179:
	; Computing bound for 'e'
	mov rax, [rel const85] ; 199
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump180
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump180:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump181
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump181:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (b / 199) 
	jno .jump182
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump182:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (b + b)) 
	jno .jump183
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump183:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump184: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump184 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump184 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump185
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump186
.jump185:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump187
	mov rax, [rel const86] ; 17
	push rax
	jmp .jump188
.jump187:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump189
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump189:
	cqo
	idiv r10
	push rax
.jump188:
.jump186:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump190
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump190:
	cmp rax, [rsp + 16]
	jl .jump191
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump191:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump192
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump192:
	cmp rax, [rsp + 24]
	jl .jump193
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump193:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const87] ; 870
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump194
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump194:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump195
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump195:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump196
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump196:
	imul rdi, [rsp + 0 + 8] ; multiply by 870 
	jno .jump197
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump197:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump198: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump199
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump199:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump200
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump200:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump201
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump201:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump202
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump202:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump203
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump203:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump204
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump204:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump205: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const88] ; 831
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump205 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump205 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump205 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump198 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump198 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump206
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump206:
	cmp rax, [rsp + 16]
	jl .jump207
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump207:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump208
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump208:
	cmp rax, [rsp + 24]
	jl .jump209
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump209:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump210
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump210:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump211: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump211 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const89] ; 79
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump212
	sub asp, 8 ; Add alignment
	lea rdi, [rel const90] ; 'mod by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump212:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const91] ; 488
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump213
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump213:
	cmp rax, [rsp + 24]
	jl .jump214
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump214:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump215
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump215:
	cmp rax, [rsp + 32]
	jl .jump216
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump216:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump217
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump217:
	cmp rax, [rsp + 40]
	jl .jump218
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump218:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump178
.jump177:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump219
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump221
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump222
.jump221:
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump222:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const92] ; 473
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump223
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump223:
	cmp rax, [rsp + 24]
	jl .jump224
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump224:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump225
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump225:
	cmp rax, [rsp + 32]
	jl .jump226
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump226:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump227
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump227:
	cmp rax, [rsp + 40]
	jl .jump228
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump228:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const93] ; 994
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump229
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump229:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump230
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump230:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump231: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; 11.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump231 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	jmp .jump220
.jump219:
	mov rax, [rel const6] ; True
	push rax
.jump220:
	pop rax
	cmp rax, 0
	je .jump232
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump234
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump234:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump235
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump235:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (d - d) 
	jno .jump236
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump236:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump237
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump237:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump238: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump238 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump238 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const95] ; 512
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump239
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump241
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump242
.jump241:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump242:
	jmp .jump240
.jump239:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump240:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump243
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump243:
	cmp rax, [rsp + 16]
	jl .jump244
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump244:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump245
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump245:
	cmp rax, [rsp + 24]
	jl .jump246
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump246:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump233
.jump232:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump247
	mov rax, [rel const6] ; True
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump248
.jump247:
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump249
	mov rax, [rel const5] ; False
	push rax
	jmp .jump250
.jump249:
	mov rax, [rel const6] ; True
	push rax
.jump250:
.jump248:
	pop rax
	cmp rax, 0
	je .jump251
	mov rax, [rel const96] ; 360
	push rax
	mov rax, [rel const97] ; 308
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump252
.jump251:
	mov rax, [rel const6] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump252:
	pop rax
	cmp rax, 0
	je .jump253
	mov rax, [rel const98] ; 36.48
	push rax
	mov rax, [rel const99] ; 73.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump255
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump257
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump257:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump258
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump258:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump259: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump259 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump256
.jump255:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump256:
	jmp .jump254
.jump253:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump260
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump260:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump261: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const100] ; 303
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump261 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump262
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump262:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump263: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump263 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump264
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump264:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump265: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump265 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump266
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump266:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump267: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump267 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump268
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump268:
	; Computing bound for 'e'
	mov rax, [rel const101] ; 19
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump269
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump269:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump270: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const102] ; 677
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump270 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump270 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump254:
.jump233:
.jump178:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump378
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump378:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump379
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump379:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump380
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump380:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump381
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump381:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump382: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump382 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump382 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump383
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump383:
	cmp rax, [rsp + 16]
	jl .jump384
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump384:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump385
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump385:
	cmp rax, [rsp + 24]
	jl .jump386
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump386:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump387
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump387:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump388
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump388:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump389: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump390
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump390:
	; Computing bound for 'j'
	mov rax, [rel const111] ; 578
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump391
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump391:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump392: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump392 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump392 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump389 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump389 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump393
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump393:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump394
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump394:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump395
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump395:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump396: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump397
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump397:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump398
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump398:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump399: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump400
	mov rax, [rel const112] ; 17.33
	push rax
	jmp .jump401
.jump400:
	mov rax, [rel const113] ; 26.88
	push rax
.jump401:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump399 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump402
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump402:
	cmp rax, [rsp + 8]
	jl .jump403
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump403:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump396 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump396 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump396 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const114] ; 337
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump404
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump404:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump405
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump405:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump406: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const115] ; 53.54
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump406 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump406 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const116] ; 49.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const117] ; 33.15
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const118] ; 69.69
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub asp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const119] ; '(IntType)'
	lea rsi, [rsp]
	call _show
	add rsp, 8
	add asp, 8 ; Remove alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump407
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump407:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump408
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump408:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump409
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump409:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump410: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump411
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump412
.jump411:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump412:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump413
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump413:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump414
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump414:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump415
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump415:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump416: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const120] ; 40.3
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump416 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump416 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump416 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump410 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump410 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump410 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump417
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump419
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump419:
	; Computing bound for 'i'
	mov rax, [rel const121] ; 761
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump420
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump420:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump421: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump421 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump421 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump422
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump422:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump423: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump424
	mov rax, [rel const122] ; 70.32
	push rax
	jmp .jump425
.jump424:
	mov rax, [rel const123] ; 16.69
	push rax
.jump425:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump423 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump418
.jump417:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump426
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump426:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const124] ; 515
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump427:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump428
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump428:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump429
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump429:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump430
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump430:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump431
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump431:
	imul rdi, [rsp + 0 + 16] ; multiply by 515 
	jno .jump432
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump432:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump433: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump433 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump433 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump433 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump434
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump435
.jump434:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump435:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump436
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump436:
	cmp rax, [rsp + 8]
	jl .jump437
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump437:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump438
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump438:
	cmp rax, [rsp + 24]
	jl .jump439
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump439:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump440
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump440:
	cmp rax, [rsp + 32]
	jl .jump441
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump441:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump442
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump442:
	cmp rax, [rsp + 40]
	jl .jump443
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump443:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump444
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump444:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump445
	mov rax, [rel const125] ; 628
	push rax
	jmp .jump446
.jump445:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump446:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump447
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump447:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump448: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const126] ; 1.93
	push rax
	mov rax, [rel const127] ; 52.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const128] ; 105
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump449
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump449:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump450
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump450:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump451: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const129] ; 44.79
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump451 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump451 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump448 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump448 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump448 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump418:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump452
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump452:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump453: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const130] ; 50.09
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump453 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump677
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const107] ; 967
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump679
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump679:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump680
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump680:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump681
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump681:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump682
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump682:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump683
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump683:
	imul rdi, [rsp + 0 + 16] ; multiply by 967 
	jno .jump684
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump684:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump685: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump685 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump685 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump685 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump686
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump686:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump687 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump688
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump688:
	cmp rax, [rsp + 24]
	jl .jump689
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump689:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump690
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump690:
	cmp rax, [rsp + 32]
	jl .jump691
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump691:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump692
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump692:
	cmp rax, [rsp + 40]
	jl .jump693
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump693:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump694
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump694:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump695
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump695:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump696: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump697
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump698
.jump697:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump699
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump699:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump700
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump700:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump701
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump701:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump702: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump702 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump702 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump702 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump698:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump696 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump696 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump703
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump703:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump704
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump704:
	; Computing bound for 'k'
	mov rax, [rel const164] ; 422
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump705
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump705:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 422 
	jno .jump706
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump706:
	imul rdi, [rsp + 0 + 8] ; multiply by (f - f) 
	jno .jump707
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump707:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[k : b, l : (array[k : c, l : c, m : 967] m)[f, c, (sum[k : c] k)]] (if i then d else (sum[m : d, n : c, o : k] k))) 
	jno .jump708
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump708:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump709: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump710
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump710:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump711
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump711:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump712: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump713
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump713:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump714: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump714 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump712 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump715
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump715:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[n : d] (sum[o : b] n)) 
	jno .jump716
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump716:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump717
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump717:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump718: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump718 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump718 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump709 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump709 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump709 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const82] ; 638
	push rax
	mov rax, [rel const165] ; 50
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump719
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump719:
	cmp rax, [rsp + 24]
	jl .jump720
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump720:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump721
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump721:
	cmp rax, [rsp + 32]
	jl .jump722
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump722:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump723
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump723:
	cmp rax, [rsp + 40]
	jl .jump724
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump724:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump678
.jump677:
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump725
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump727
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump728
.jump727:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump728:
	jmp .jump726
.jump725:
	mov rax, [rel const6] ; True
	push rax
.jump726:
	pop rax
	cmp rax, 0
	je .jump729
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump731
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump733
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump733:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump734
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump734:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump735
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump735:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump736
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump736:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump737: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump737 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump737 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump732
.jump731:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const166] ; 495
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump738
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump738:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump739
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump740
.jump739:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump740:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump741
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump741:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if h then f else c) 
	jno .jump742
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump742:
	imul rdi, [rsp + 0 + 8] ; multiply by 495 
	jno .jump743
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump743:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump744: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump745
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump745:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump746
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump746:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump747
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump747:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump748
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump748:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump749: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump749 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump749 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump744 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump744 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump750
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump750:
	cmp rax, [rsp + 16]
	jl .jump751
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump751:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump752
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump752:
	cmp rax, [rsp + 24]
	jl .jump753
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump753:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump732:
	jmp .jump730
.jump729:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump754
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump756
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump756:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const121] ; 761
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump757
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump757:
	; Computing bound for 'l'
	mov rax, [rel const167] ; 14
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump758
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump758:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump759
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump759:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump760: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump760 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump760 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump760 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump761
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump761:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump762
	sub asp, 8 ; Add alignment
	lea rdi, [rel const90] ; 'mod by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump762:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump763
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump763:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump764: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump764 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump764 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump764 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump755
.jump754:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const168] ; 899
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump765
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump765:
	; Computing bound for 'k'
	mov rax, [rel const169] ; 6
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump766
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump766:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump767: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump768
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump768:
	cmp rax, [rsp + 8]
	jl .jump769
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump769:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump767 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump767 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump755:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump770
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump770:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump771
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump771:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump772
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump772:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump773
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump773:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump774: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const170] ; 908
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump774 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump774 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump774 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump775
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump775:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[k : b, l : c, m : b] 908)) 
	jno .jump776
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump776:
imul rdi, [rsp + 0 + 8] ; multiply by (if h then (sum[k : (b % f), l : (sum[k : f, l : 14, m : 761] l), m : c] m) else (sum[k : (- 6), l : 899] e[b])) 
	jno .jump777
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump777:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump778: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump778 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump778 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump730:
.jump678:
	call _j
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 24
	; Moving 24 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 96 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	call _j
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const178] ; 68.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1037
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1039
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1039:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1040
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1042
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1042:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1043
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1043:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1044
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1044:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1045
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1045:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1046: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1047
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1047:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1048
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1048:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1049
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1049:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1050
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1050:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump1051
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1051:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump1052
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1052:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump1053: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1053 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1053 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1053 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1046 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1046 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1054
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1054:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1055
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1055:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1056: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1056 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1056 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1057
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1057:
	cmp rax, [rsp + 16]
	jl .jump1058
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1058:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1059
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1059:
	cmp rax, [rsp + 24]
	jl .jump1060
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1060:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1061
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1061:
	cmp rax, [rsp + 24]
	jl .jump1062
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1062:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1063
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1063:
	cmp rax, [rsp + 32]
	jl .jump1064
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1064:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1065
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1065:
	cmp rax, [rsp + 40]
	jl .jump1066
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1066:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1041
.jump1040:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1067
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1067:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1068
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1068:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1069: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1069 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1070
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1070:
	cmp rax, [rsp + 8]
	jl .jump1071
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1071:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1072
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1074
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1074:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1075
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1075:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump1076
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1076:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump1077
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1077:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1078: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1078 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1078 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1079
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1079:
	cmp rax, [rsp + 16]
	jl .jump1080
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1080:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1081
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1081:
	cmp rax, [rsp + 24]
	jl .jump1082
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1082:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1073
.jump1072:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	mov rax, [rel const180] ; 251
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1083
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1083:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1084
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1084:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1085
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1085:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump1086
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1086:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1087
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1087:
	imul rdi, [rsp + 0 + 16] ; multiply by 251 
	jno .jump1088
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1088:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1089: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1089 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1089 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1089 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1090
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1090:
	cmp rax, [rsp + 24]
	jl .jump1091
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1091:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1092
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1092:
	cmp rax, [rsp + 32]
	jl .jump1093
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1093:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1094
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1094:
	cmp rax, [rsp + 40]
	jl .jump1095
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1095:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1073:
.jump1041:
	jmp .jump1038
.jump1037:
	sub asp, 8 ; Add alignment
	call _j
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1096
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	jmp .jump1097
.jump1096:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub asp, 8 ; Add alignment
	call _jpl_alloc
	add asp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump1097:
	mov rax, [rel const5] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1098
	call _j
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump1099
.jump1098:
	call _j
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1099:
	movsd xmm0, [rsp]
	add rsp, 8
	call _g
	add rsp, 16
	add rsp, 16
	add asp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1100
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1102
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1102:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1103
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1103:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1104
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1104:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1105
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1105:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump1106
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1106:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump1107
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1107:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1108: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1109
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1109:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1110
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1110:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1111
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1111:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump1112
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1112:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump1113
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1113:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump1114
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
.jump1114:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump1115: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1115 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1115 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1115 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1108 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1108 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1108 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1116
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump1117
.jump1116:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump1117:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1118
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1118:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1119
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1119:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1120
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1120:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1121: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1121 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1121 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1121 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1122
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1122:
	cmp rax, [rsp + 24]
	jl .jump1123
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1123:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1124
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1124:
	cmp rax, [rsp + 32]
	jl .jump1125
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1125:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1126
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1126:
	cmp rax, [rsp + 40]
	jl .jump1127
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1127:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1101
.jump1100:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1128
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1128:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1129
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1129:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1130
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1130:
	; Computing bound for 'A'
	mov rax, [rel const181] ; 752
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1131
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1131:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1132: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1132 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1132 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1132 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1133
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1133:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1134
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1134:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump1135
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1135:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[A : (p - 752), B : x, C : z] z) 
	jno .jump1136
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1136:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1137
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1137:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1138: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1139
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1139:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1140
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1140:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump1141
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1141:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump1142
	sub asp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'overflow computing array size'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1142:
	sub asp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add asp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump1143: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1143 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1143 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1144
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1144:
	cmp rax, [rsp + 16]
	jl .jump1145
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1145:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1146
	sub asp, 8 ; Add alignment
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1146:
	cmp rax, [rsp + 24]
	jl .jump1147
	sub asp, 8 ; Add alignment
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1147:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1138 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1138 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1138 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1101:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1148
	sub asp, 8 ; Add alignment
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1148:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1149
	lea rdi, [rel const15] ; 'non-positive loop bound'
	call _fail_assertion
.jump1149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump1150: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1150 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1150 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1151
	sub asp, 8 ; Add alignment
	lea rdi, [rel const63] ; 'divide by zero'
	call _fail_assertion
	add asp, 8 ; Remove alignment
.jump1151:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1152
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1152:
	cmp rax, [rsp + 24]
	jl .jump1153
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1153:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1154
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1154:
	cmp rax, [rsp + 32]
	jl .jump1155
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1155:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1156
	lea rdi, [rel const29] ; 'negative array index'
	call _fail_assertion
.jump1156:
	cmp rax, [rsp + 40]
	jl .jump1157
	lea rdi, [rel const30] ; 'index too large'
	call _fail_assertion
.jump1157:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1038:
	mov rax, [rel const33] ; 320
	push rax
	add rsp, 216 ; Local variables
	pop r12 ; begin jpl_main postlude
	pop rbp
	ret

