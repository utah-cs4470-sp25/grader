
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2__a1_int64_t *data;
} _a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1__a2__a1_int64_t *data;
} _a1__a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_int64_t *data;
} _a3__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_rgba *data;
} _a3__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_int64_t *data;
} _a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_rgba *data;
} _a3__a3__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_rgba *data;
} _a3__a3_rgba;

typedef struct {
  int64_t d0;
  _a3_rgba *data;
} _a1__a3_rgba;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_rgba *data;
} _a2__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a2__a1_int64_t *data;
} _a2__a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1__a2__a1_int64_t *data;
} _a3__a2__a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a3_int64_t *data;
} _a1__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1__a3_int64_t *data;
} _a3__a1__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1__a3_int64_t *data;
} _a2__a1__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_int64_t *data;
} _a3__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_void_t *data;
} _a3__a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

double a(double b, _a2_bool c) {
    _a1_bool _1;
    // Computing bound for d
    _a2_int64_t _2;
    // Computing bound for d
    int64_t _3;
    // Computing bound for d
    int64_t _4 = 619;
    if (_4 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing bound for e
    int64_t _5 = 536;
    int64_t _6 = 828;
    int64_t _7 = _5 * _6;
    if (_7 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    _3 = 0;
    int64_t _8 = 0; // e
    int64_t _9 = 0; // d
    _jump3:; // Begin body of loop
    int64_t _10;
    // Computing bound for f
    if (_9 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    _10 = 0;
    int64_t _11 = 0; // f
    _jump5:; // Begin body of loop
    _10 += _8;
    _11++;
    if (_11 < _9)
    goto _jump5;
    // End body of loop
    _3 += _10;
    _8++;
    if (_8 < _7)
    goto _jump3;
    _8 = 0;
    _9++;
    if (_9 < _4)
    goto _jump3;
    // End body of loop
    _2.d0 = _3;
    if (_3 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    // Computing bound for e
    int64_t _12 = 147;
    _2.d1 = _12;
    if (_12 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _3;
    _13 *= _12;
    _13 *= sizeof(int64_t);
    _2.data = jpl_alloc(_13);
    int64_t _14 = 0; // e
    int64_t _15 = 0; // d
    _jump8:; // Begin body of loop
    int64_t _16;
    // Computing bound for f
    if (_14 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    // Computing bound for g
    if (_14 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    // Computing bound for h
    int64_t _17 = 259;
    if (_17 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    _16 = 0;
    int64_t _18 = 0; // h
    int64_t _19 = 0; // g
    int64_t _20 = 0; // f
    _jump12:; // Begin body of loop
    int64_t _21 = 963;
    _16 += _21;
    _18++;
    if (_18 < _17)
    goto _jump12;
    _18 = 0;
    _19++;
    if (_19 < _14)
    goto _jump12;
    _19 = 0;
    _20++;
    if (_20 < _14)
    goto _jump12;
    // End body of loop
    int64_t _22 = -_16;
    int64_t _23 = 0;
    _23 *= _2.d0;
    _23 += _15;
    _23 *= _2.d1;
    _23 += _14;
    _2.data[_23] = _22;
    _14++;
    if (_14 < _12)
    goto _jump8;
    _14 = 0;
    _15++;
    if (_15 < _3)
    goto _jump8;
    // End body of loop
    bool _24 = true;
    int64_t _25;
    if (!_24)
    goto _jump13;
    int64_t _26 = 601;
    _25 = _26;
    goto _jump14;
    _jump13:;
    bool _27 = false;
    int64_t _28;
    if (!_27)
    goto _jump15;
    int64_t _29 = 760;
    int64_t _30 = -_29;
    _28 = _30;
    goto _jump16;
    _jump15:;
    int64_t _31 = 993;
    _28 = _31;
    _jump16:;
    _25 = _28;
    _jump14:;
    _a2_int64_t _32;
    // Computing bound for d
    int64_t _33 = 51;
    int64_t _34 = -_33;
    _32.d0 = _34;
    if (_34 > 0) 
    goto _jump17;
    fail_assertion("non-positive loop bound");
    _jump17:;
    // Computing bound for e
    int64_t _35 = 657;
    int64_t _36 = -_35;
    _32.d1 = _36;
    if (_36 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _34;
    _37 *= _36;
    _37 *= sizeof(int64_t);
    _32.data = jpl_alloc(_37);
    int64_t _38 = 0; // e
    int64_t _39 = 0; // d
    _jump19:; // Begin body of loop
    int64_t _40 = 695;
    int64_t _41 = 0;
    _41 *= _32.d0;
    _41 += _39;
    _41 *= _32.d1;
    _41 += _38;
    _32.data[_41] = _40;
    _38++;
    if (_38 < _36)
    goto _jump19;
    _38 = 0;
    _39++;
    if (_39 < _34)
    goto _jump19;
    // End body of loop
    int64_t _42;
    // Computing bound for d
    int64_t _43 = 859;
    if (_43 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    // Computing bound for e
    int64_t _44 = 773;
    int64_t _45 = -_44;
    if (_45 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    _42 = 0;
    int64_t _46 = 0; // e
    int64_t _47 = 0; // d
    _jump22:; // Begin body of loop
    _42 += _47;
    _46++;
    if (_46 < _45)
    goto _jump22;
    _46 = 0;
    _47++;
    if (_47 < _43)
    goto _jump22;
    // End body of loop
    int64_t _48;
    // Computing bound for d
    int64_t _49;
    // Computing bound for d
    int64_t _50 = 622;
    if (_50 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    _49 = 0;
    int64_t _51 = 0; // d
    _jump24:; // Begin body of loop
    _49 += _51;
    _51++;
    if (_51 < _50)
    goto _jump24;
    // End body of loop
    if (_49 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for e
    int64_t _52 = 812;
    if (_52 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for f
    int64_t _53 = 706;
    int64_t _54 = -_53;
    if (_54 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _48 = 0;
    int64_t _55 = 0; // f
    int64_t _56 = 0; // e
    int64_t _57 = 0; // d
    _jump28:; // Begin body of loop
    _48 += _56;
    _55++;
    if (_55 < _54)
    goto _jump28;
    _55 = 0;
    _56++;
    if (_56 < _52)
    goto _jump28;
    _56 = 0;
    _57++;
    if (_57 < _49)
    goto _jump28;
    // End body of loop
    if (_42 >= 0)
    goto _jump29;
    fail_assertion("negative array index");
    _jump29:;
    if (_42 < _32.d0)
    goto _jump30;
    fail_assertion("index too large");
    _jump30:;
    if (_48 >= 0)
    goto _jump31;
    fail_assertion("negative array index");
    _jump31:;
    if (_48 < _32.d1)
    goto _jump32;
    fail_assertion("index too large");
    _jump32:;
    int64_t _58 = 0;
    _58 *= _32.d0;
    _58 += _42;
    _58 *= _32.d1;
    _58 += _48;
    int64_t _59 = _32.data[_58];
    if (_25 >= 0)
    goto _jump33;
    fail_assertion("negative array index");
    _jump33:;
    if (_25 < _2.d0)
    goto _jump34;
    fail_assertion("index too large");
    _jump34:;
    if (_59 >= 0)
    goto _jump35;
    fail_assertion("negative array index");
    _jump35:;
    if (_59 < _2.d1)
    goto _jump36;
    fail_assertion("index too large");
    _jump36:;
    int64_t _60 = 0;
    _60 *= _2.d0;
    _60 += _25;
    _60 *= _2.d1;
    _60 += _59;
    int64_t _61 = _2.data[_60];
    _1.d0 = _61;
    if (_61 > 0) 
    goto _jump37;
    fail_assertion("non-positive loop bound");
    _jump37:;
    // Computing total size of heap memory to allocate
    int64_t _62 = 1;
    _62 *= _61;
    _62 *= sizeof(bool);
    _1.data = jpl_alloc(_62);
    int64_t _63 = 0; // d
    _jump38:; // Begin body of loop
    bool _64 = true;
    bool _65 = !_64;
    bool _66 = !_65;
    bool _67;
    if (!_66)
    goto _jump39;
    bool _68 = true;
    bool _69 = !_68;
    bool _70 = !_69;
    _67 = _70;
    goto _jump40;
    _jump39:;
    bool _71 = false;
    _67 = _71;
    _jump40:;
    int64_t _72 = 0;
    _72 *= _1.d0;
    _72 += _63;
    _1.data[_72] = _67;
    _63++;
    if (_63 < _61)
    goto _jump38;
    // End body of loop
    int64_t _73 = 106;
    if (_73 >= 0)
    goto _jump41;
    fail_assertion("negative array index");
    _jump41:;
    if (_73 < _1.d0)
    goto _jump42;
    fail_assertion("index too large");
    _jump42:;
    int64_t _74 = 0;
    _74 *= _1.d0;
    _74 += _73;
    bool _75 = _1.data[_74];
    bool _0 = _75;
    if (0 != _75)
    goto _jump43;
    bool _76 = true;
    double _77;
    if (!_76)
    goto _jump44;
    double _78 = 9.0;
    double _79 = -b;
    double _80 = _78 - _79;
    _77 = _80;
    goto _jump45;
    _jump44:;
    _a2_bool _81;
    // Computing bound for d
    int64_t _82;
    // Computing bound for d
    int64_t _83 = 394;
    if (_83 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    // Computing bound for e
    int64_t _84 = 268;
    if (_84 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    // Computing bound for f
    int64_t _85 = 22;
    if (_85 > 0) 
    goto _jump48;
    fail_assertion("non-positive loop bound");
    _jump48:;
    _82 = 0;
    int64_t _86 = 0; // f
    int64_t _87 = 0; // e
    int64_t _88 = 0; // d
    _jump49:; // Begin body of loop
    _82 += _87;
    _86++;
    if (_86 < _85)
    goto _jump49;
    _86 = 0;
    _87++;
    if (_87 < _84)
    goto _jump49;
    _87 = 0;
    _88++;
    if (_88 < _83)
    goto _jump49;
    // End body of loop
    _81.d0 = _82;
    if (_82 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    // Computing bound for e
    int64_t _89 = 687;
    _81.d1 = _89;
    if (_89 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    // Computing total size of heap memory to allocate
    int64_t _90 = 1;
    _90 *= _82;
    _90 *= _89;
    _90 *= sizeof(bool);
    _81.data = jpl_alloc(_90);
    int64_t _91 = 0; // e
    int64_t _92 = 0; // d
    _jump52:; // Begin body of loop
    bool _93 = _91 >= _91;
    int64_t _94 = 0;
    _94 *= _81.d0;
    _94 += _92;
    _94 *= _81.d1;
    _94 += _91;
    _81.data[_94] = _93;
    _91++;
    if (_91 < _89)
    goto _jump52;
    _91 = 0;
    _92++;
    if (_92 < _82)
    goto _jump52;
    // End body of loop
    int64_t _95;
    // Computing bound for d
    int64_t _96 = 611;
    if (_96 > 0) 
    goto _jump53;
    fail_assertion("non-positive loop bound");
    _jump53:;
    // Computing bound for e
    int64_t _97 = 438;
    if (_97 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    _95 = 0;
    int64_t _98 = 0; // e
    int64_t _99 = 0; // d
    _jump55:; // Begin body of loop
    int64_t _100 = 468;
    _95 += _100;
    _98++;
    if (_98 < _97)
    goto _jump55;
    _98 = 0;
    _99++;
    if (_99 < _96)
    goto _jump55;
    // End body of loop
    int64_t _101 = 721;
    int64_t _102 = -_101;
    if (_95 >= 0)
    goto _jump56;
    fail_assertion("negative array index");
    _jump56:;
    if (_95 < _81.d0)
    goto _jump57;
    fail_assertion("index too large");
    _jump57:;
    if (_102 >= 0)
    goto _jump58;
    fail_assertion("negative array index");
    _jump58:;
    if (_102 < _81.d1)
    goto _jump59;
    fail_assertion("index too large");
    _jump59:;
    int64_t _103 = 0;
    _103 *= _81.d0;
    _103 += _95;
    _103 *= _81.d1;
    _103 += _102;
    bool _104 = _81.data[_103];
    double _105;
    if (!_104)
    goto _jump60;
    double _106 = 13.0;
    _105 = _106;
    goto _jump61;
    _jump60:;
    _105 = b;
    _jump61:;
    _77 = _105;
    _jump45:;
    bool _107 = b == _77;
    _0 = _107;
    _jump43:;
    if (0 != _0)
    goto _jump62;
    fail_assertion("d");
    _jump62:;
    int64_t _108 = 211;
    int64_t _109 = -_108;
    bool _110 = true;
    bool _111 = !_110;
    bool _112 = !_111;
    _a1_bool _113;
    _113.d0 = 1;
    _113.data = jpl_alloc(sizeof(bool) * 1);
    _113.data[0] = _112;
    double _114 = 7.0;
    bool _115 = _114 < b;
    int64_t _116;
    if (!_115)
    goto _jump63;
    int64_t _117 = 521;
    _116 = _117;
    goto _jump64;
    _jump63:;
    int64_t _118 = 950;
    int64_t _119 = -_118;
    _116 = _119;
    _jump64:;
    if (_116 >= 0)
    goto _jump65;
    fail_assertion("negative array index");
    _jump65:;
    if (_116 < _113.d0)
    goto _jump66;
    fail_assertion("index too large");
    _jump66:;
    int64_t _120 = 0;
    _120 *= _113.d0;
    _120 += _116;
    bool _121 = _113.data[_120];
    int64_t _122;
    if (!_121)
    goto _jump67;
    int64_t _123 = 519;
    int64_t _124 = -_123;
    int64_t _125 = -_124;
    _122 = _125;
    goto _jump68;
    _jump67:;
    int64_t _126;
    // Computing bound for d
    int64_t _127 = 892;
    int64_t _128 = -_127;
    if (_128 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    _126 = 0;
    int64_t _129 = 0; // d
    _jump70:; // Begin body of loop
    bool _130 = true;
    int64_t _131;
    if (!_130)
    goto _jump71;
    int64_t _132 = 479;
    _131 = _132;
    goto _jump72;
    _jump71:;
    int64_t _133 = _129 - _129;
    _131 = _133;
    _jump72:;
    _126 += _131;
    _129++;
    if (_129 < _128)
    goto _jump70;
    // End body of loop
    int64_t _134 = 373;
    int64_t _135 = -_134;
    int64_t _136 = -_135;
    int64_t _137 = _126 - _136;
    _122 = _137;
    _jump68:;
    int64_t _138 = 557;
    int64_t _139 = -_138;
    int64_t _140;
    // Computing bound for d
    int64_t _141 = 296;
    if (_141 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing bound for e
    int64_t _142 = 254;
    if (_142 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    _140 = 0;
    int64_t _143 = 0; // e
    int64_t _144 = 0; // d
    _jump75:; // Begin body of loop
    _140 += _144;
    _143++;
    if (_143 < _142)
    goto _jump75;
    _143 = 0;
    _144++;
    if (_144 < _141)
    goto _jump75;
    // End body of loop
    int64_t _145 = _139 * _140;
    int64_t _146 = 492;
    int64_t _147;
    // Computing bound for d
    int64_t _148 = 898;
    if (_148 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for e
    int64_t _149 = 674;
    if (_149 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    // Computing bound for f
    int64_t _150 = 810;
    if (_150 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    _147 = 0;
    int64_t _151 = 0; // f
    int64_t _152 = 0; // e
    int64_t _153 = 0; // d
    _jump79:; // Begin body of loop
    _147 += _153;
    _151++;
    if (_151 < _150)
    goto _jump79;
    _151 = 0;
    _152++;
    if (_152 < _149)
    goto _jump79;
    _152 = 0;
    _153++;
    if (_153 < _148)
    goto _jump79;
    // End body of loop
    int64_t _154 = 337;
    int64_t _155 = _147 % _154;
    int64_t _156 = _146 * _155;
    bool _157 = _145 >= _156;
    int64_t _158;
    if (!_157)
    goto _jump80;
    bool _159 = true;
    int64_t _160;
    if (!_159)
    goto _jump81;
    int64_t _161 = 890;
    _160 = _161;
    goto _jump82;
    _jump81:;
    bool _162 = false;
    bool _163 = !_162;
    int64_t _164;
    if (!_163)
    goto _jump83;
    int64_t _165 = 319;
    int64_t _166 = -_165;
    _164 = _166;
    goto _jump84;
    _jump83:;
    int64_t _167 = 118;
    int64_t _168 = -_167;
    int64_t _169 = 376;
    int64_t _170 = _168 * _169;
    _164 = _170;
    _jump84:;
    _160 = _164;
    _jump82:;
    _158 = _160;
    goto _jump85;
    _jump80:;
    bool _171 = true;
    int64_t _172;
    if (!_171)
    goto _jump86;
    int64_t _173;
    // Computing bound for d
    int64_t _174;
    // Computing bound for d
    int64_t _175 = 467;
    if (_175 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    _174 = 0;
    int64_t _176 = 0; // d
    _jump88:; // Begin body of loop
    _174 += _176;
    _176++;
    if (_176 < _175)
    goto _jump88;
    // End body of loop
    if (_174 > 0) 
    goto _jump89;
    fail_assertion("non-positive loop bound");
    _jump89:;
    // Computing bound for e
    int64_t _177;
    // Computing bound for d
    int64_t _178 = 396;
    int64_t _179 = -_178;
    if (_179 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing bound for e
    int64_t _180 = 310;
    if (_180 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    _177 = 0;
    int64_t _181 = 0; // e
    int64_t _182 = 0; // d
    _jump92:; // Begin body of loop
    _177 += _182;
    _181++;
    if (_181 < _180)
    goto _jump92;
    _181 = 0;
    _182++;
    if (_182 < _179)
    goto _jump92;
    // End body of loop
    if (_177 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing bound for f
    bool _183 = b < b;
    int64_t _184;
    if (!_183)
    goto _jump94;
    int64_t _185 = 850;
    int64_t _186 = -_185;
    _184 = _186;
    goto _jump95;
    _jump94:;
    int64_t _187 = 73;
    int64_t _188 = -_187;
    _184 = _188;
    _jump95:;
    if (_184 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    _173 = 0;
    int64_t _189 = 0; // f
    int64_t _190 = 0; // e
    int64_t _191 = 0; // d
    _jump97:; // Begin body of loop
    _173 += _189;
    _189++;
    if (_189 < _184)
    goto _jump97;
    _189 = 0;
    _190++;
    if (_190 < _177)
    goto _jump97;
    _190 = 0;
    _191++;
    if (_191 < _174)
    goto _jump97;
    // End body of loop
    _172 = _173;
    goto _jump98;
    _jump86:;
    bool _193 = true;
    bool _194 = !_193;
    bool _192 = _194;
    if (0 == _194)
    goto _jump99;
    bool _195 = false;
    _192 = _195;
    _jump99:;
    int64_t _196;
    if (!_192)
    goto _jump100;
    int64_t _197 = 790;
    int64_t _198 = -_197;
    int64_t _199 = -_198;
    _196 = _199;
    goto _jump101;
    _jump100:;
    int64_t _200 = 363;
    int64_t _201;
    // Computing bound for d
    int64_t _202 = 360;
    if (_202 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    _201 = 0;
    int64_t _203 = 0; // d
    _jump103:; // Begin body of loop
    _201 += _203;
    _203++;
    if (_203 < _202)
    goto _jump103;
    // End body of loop
    int64_t _204 = _200 - _201;
    _196 = _204;
    _jump101:;
    _172 = _196;
    _jump98:;
    _158 = _172;
    _jump85:;
    int64_t _205 = _122 + _158;
    if (_109 >= 0)
    goto _jump104;
    fail_assertion("negative array index");
    _jump104:;
    if (_109 < c.d0)
    goto _jump105;
    fail_assertion("index too large");
    _jump105:;
    if (_205 >= 0)
    goto _jump106;
    fail_assertion("negative array index");
    _jump106:;
    if (_205 < c.d1)
    goto _jump107;
    fail_assertion("index too large");
    _jump107:;
    int64_t _206 = 0;
    _206 *= c.d0;
    _206 += _109;
    _206 *= c.d1;
    _206 += _205;
    bool _207 = c.data[_206];
    int64_t _208 = 95;
    double _209 = -b;
    bool _210 = false;
    double _211;
    if (!_210)
    goto _jump108;
    _a1_double _212;
    // Computing bound for f
    _212.d0 = _208;
    if (_208 > 0) 
    goto _jump109;
    fail_assertion("non-positive loop bound");
    _jump109:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= _208;
    _213 *= sizeof(double);
    _212.data = jpl_alloc(_213);
    int64_t _214 = 0; // f
    _jump110:; // Begin body of loop
    double _215 = 22.0;
    int64_t _216 = 0;
    _216 *= _212.d0;
    _216 += _214;
    _212.data[_216] = _215;
    _214++;
    if (_214 < _208)
    goto _jump110;
    // End body of loop
    int64_t _217 = -_208;
    if (_217 >= 0)
    goto _jump111;
    fail_assertion("negative array index");
    _jump111:;
    if (_217 < _212.d0)
    goto _jump112;
    fail_assertion("index too large");
    _jump112:;
    int64_t _218 = 0;
    _218 *= _212.d0;
    _218 += _217;
    double _219 = _212.data[_218];
    _211 = _219;
    goto _jump113;
    _jump108:;
    double _220 = 46.0;
    _211 = _220;
    _jump113:;
    double _221 = -_211;
    bool _222 = _209 == _221;
    double _223 = b - b;
    _a3_bool _225;
    // Computing bound for h
    int64_t _226;
    // Computing bound for h
    bool _228 = true;
    bool _227 = _228;
    if (0 != _228)
    goto _jump114;
    _227 = _222;
    _jump114:;
    int64_t _229;
    if (!_227)
    goto _jump115;
    int64_t _230;
    if (!_222)
    goto _jump116;
    int64_t _231 = 39;
    _230 = _231;
    goto _jump117;
    _jump116:;
    _230 = _208;
    _jump117:;
    _229 = _230;
    goto _jump118;
    _jump115:;
    _229 = _208;
    _jump118:;
    if (_229 > 0) 
    goto _jump119;
    fail_assertion("non-positive loop bound");
    _jump119:;
    // Computing bound for i
    int64_t _232 = 745;
    if (_232 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    _226 = 0;
    int64_t _233 = 0; // i
    int64_t _234 = 0; // h
    _jump121:; // Begin body of loop
    _226 += _233;
    _233++;
    if (_233 < _232)
    goto _jump121;
    _233 = 0;
    _234++;
    if (_234 < _229)
    goto _jump121;
    // End body of loop
    _225.d0 = _226;
    if (_226 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing bound for i
    int64_t _235;
    // Computing bound for h
    int64_t _236 = 340;
    if (_236 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    // Computing bound for i
    int64_t _237 = -_208;
    if (_237 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    // Computing bound for j
    int64_t _238 = 775;
    int64_t _239 = -_238;
    if (_239 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    _235 = 0;
    int64_t _240 = 0; // j
    int64_t _241 = 0; // i
    int64_t _242 = 0; // h
    _jump126:; // Begin body of loop
    bool _243 = !_222;
    int64_t _244;
    if (!_243)
    goto _jump127;
    _244 = _242;
    goto _jump128;
    _jump127:;
    int64_t _245 = -_240;
    _244 = _245;
    _jump128:;
    _235 += _244;
    _240++;
    if (_240 < _239)
    goto _jump126;
    _240 = 0;
    _241++;
    if (_241 < _237)
    goto _jump126;
    _241 = 0;
    _242++;
    if (_242 < _236)
    goto _jump126;
    // End body of loop
    _225.d1 = _235;
    if (_235 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    // Computing bound for j
    _a2_int64_t _246;
    // Computing bound for h
    int64_t _247 = 590;
    _246.d0 = _247;
    if (_247 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for i
    _246.d1 = _208;
    if (_208 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= _247;
    _248 *= _208;
    _248 *= sizeof(int64_t);
    _246.data = jpl_alloc(_248);
    int64_t _249 = 0; // i
    int64_t _250 = 0; // h
    _jump132:; // Begin body of loop
    int64_t _251 = 474;
    int64_t _252 = 0;
    _252 *= _246.d0;
    _252 += _250;
    _252 *= _246.d1;
    _252 += _249;
    _246.data[_252] = _251;
    _249++;
    if (_249 < _208)
    goto _jump132;
    _249 = 0;
    _250++;
    if (_250 < _247)
    goto _jump132;
    // End body of loop
    int64_t _253 = -_208;
    int64_t _254 = -_208;
    if (_253 >= 0)
    goto _jump133;
    fail_assertion("negative array index");
    _jump133:;
    if (_253 < _246.d0)
    goto _jump134;
    fail_assertion("index too large");
    _jump134:;
    if (_254 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_254 < _246.d1)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    int64_t _255 = 0;
    _255 *= _246.d0;
    _255 += _253;
    _255 *= _246.d1;
    _255 += _254;
    int64_t _256 = _246.data[_255];
    int64_t _257 = -_256;
    _225.d2 = _257;
    if (_257 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing total size of heap memory to allocate
    int64_t _258 = 1;
    _258 *= _226;
    _258 *= _235;
    _258 *= _257;
    _258 *= sizeof(bool);
    _225.data = jpl_alloc(_258);
    int64_t _259 = 0; // j
    int64_t _260 = 0; // i
    int64_t _261 = 0; // h
    _jump138:; // Begin body of loop
    int64_t _262 = 0;
    _262 *= _225.d0;
    _262 += _261;
    _262 *= _225.d1;
    _262 += _260;
    _262 *= _225.d2;
    _262 += _259;
    _225.data[_262] = _222;
    _259++;
    if (_259 < _257)
    goto _jump138;
    _259 = 0;
    _260++;
    if (_260 < _235)
    goto _jump138;
    _260 = 0;
    _261++;
    if (_261 < _226)
    goto _jump138;
    // End body of loop
    bool _263 = _207;
    if (0 != _207)
    goto _jump139;
    bool _264 = false;
    _263 = _264;
    _jump139:;
    int64_t _265;
    if (!_263)
    goto _jump140;
    int64_t _266 = _208 * _208;
    _265 = _266;
    goto _jump141;
    _jump140:;
    int64_t _267 = 466;
    int64_t _268 = -_267;
    _265 = _268;
    _jump141:;
    bool _269 = _208 > _265;
    int64_t _270;
    if (!_269)
    goto _jump142;
    _a3_int64_t _271;
    // Computing bound for h
    int64_t _272 = 818;
    _271.d0 = _272;
    if (_272 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing bound for i
    int64_t _273 = 325;
    _271.d1 = _273;
    if (_273 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    // Computing bound for j
    _271.d2 = _208;
    if (_208 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= _272;
    _274 *= _273;
    _274 *= _208;
    _274 *= sizeof(int64_t);
    _271.data = jpl_alloc(_274);
    int64_t _275 = 0; // j
    int64_t _276 = 0; // i
    int64_t _277 = 0; // h
    _jump146:; // Begin body of loop
    int64_t _278 = 0;
    _278 *= _271.d0;
    _278 += _277;
    _278 *= _271.d1;
    _278 += _276;
    _278 *= _271.d2;
    _278 += _275;
    _271.data[_278] = _208;
    _275++;
    if (_275 < _208)
    goto _jump146;
    _275 = 0;
    _276++;
    if (_276 < _273)
    goto _jump146;
    _276 = 0;
    _277++;
    if (_277 < _272)
    goto _jump146;
    // End body of loop
    if (_208 >= 0)
    goto _jump147;
    fail_assertion("negative array index");
    _jump147:;
    if (_208 < _271.d0)
    goto _jump148;
    fail_assertion("index too large");
    _jump148:;
    if (_208 >= 0)
    goto _jump149;
    fail_assertion("negative array index");
    _jump149:;
    if (_208 < _271.d1)
    goto _jump150;
    fail_assertion("index too large");
    _jump150:;
    if (_208 >= 0)
    goto _jump151;
    fail_assertion("negative array index");
    _jump151:;
    if (_208 < _271.d2)
    goto _jump152;
    fail_assertion("index too large");
    _jump152:;
    int64_t _279 = 0;
    _279 *= _271.d0;
    _279 += _208;
    _279 *= _271.d1;
    _279 += _208;
    _279 *= _271.d2;
    _279 += _208;
    int64_t _280 = _271.data[_279];
    int64_t _281 = -_280;
    _270 = _281;
    goto _jump153;
    _jump142:;
    int64_t _282 = 44;
    _270 = _282;
    _jump153:;
    if (_208 >= 0)
    goto _jump154;
    fail_assertion("negative array index");
    _jump154:;
    if (_208 < _225.d0)
    goto _jump155;
    fail_assertion("index too large");
    _jump155:;
    if (_270 >= 0)
    goto _jump156;
    fail_assertion("negative array index");
    _jump156:;
    if (_270 < _225.d1)
    goto _jump157;
    fail_assertion("index too large");
    _jump157:;
    if (_208 >= 0)
    goto _jump158;
    fail_assertion("negative array index");
    _jump158:;
    if (_208 < _225.d2)
    goto _jump159;
    fail_assertion("index too large");
    _jump159:;
    int64_t _283 = 0;
    _283 *= _225.d0;
    _283 += _208;
    _283 *= _225.d1;
    _283 += _270;
    _283 *= _225.d2;
    _283 += _208;
    bool _284 = _225.data[_283];
    bool _224 = _284;
    if (0 != _284)
    goto _jump160;
    double _285;
    // Computing bound for h
    if (_208 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for i
    int64_t _286 = 180;
    if (_286 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _285 = 0;
    int64_t _287 = 0; // i
    int64_t _288 = 0; // h
    _jump163:; // Begin body of loop
    _285 += _223;
    _287++;
    if (_287 < _286)
    goto _jump163;
    _287 = 0;
    _288++;
    if (_288 < _208)
    goto _jump163;
    // End body of loop
    double _289 = -_285;
    bool _290 = b > _289;
    _a1_bool _291;
    _291.d0 = 2;
    _291.data = jpl_alloc(sizeof(bool) * 2);
    _291.data[0] = _290;
    _291.data[1] = _222;
    if (_208 >= 0)
    goto _jump164;
    fail_assertion("negative array index");
    _jump164:;
    if (_208 < _291.d0)
    goto _jump165;
    fail_assertion("index too large");
    _jump165:;
    int64_t _292 = 0;
    _292 *= _291.d0;
    _292 += _208;
    bool _293 = _291.data[_292];
    _224 = _293;
    _jump160:;
    bool _294 = !_224;
    if (0 != _294)
    goto _jump166;
    fail_assertion("h");
    _jump166:;
    return b;
}

bool e(_a1_rgba f, _a3_rgba h) {
    bool _0 = e(f, h);
    bool _1 = !_0;
    _a2__a1_int64_t _2;
    if (!_1)
    goto _jump216;
    double _3 = 56.0;
    double _4 = -_3;
    double _5 = -_4;
    int64_t _6 = 390;
    int64_t _7 = 947;
    if (_6 >= 0)
    goto _jump217;
    fail_assertion("negative array index");
    _jump217:;
    if (_6 < h.d0)
    goto _jump218;
    fail_assertion("index too large");
    _jump218:;
    if (h.d1 >= 0)
    goto _jump219;
    fail_assertion("negative array index");
    _jump219:;
    if (h.d1 < h.d1)
    goto _jump220;
    fail_assertion("index too large");
    _jump220:;
    if (_7 >= 0)
    goto _jump221;
    fail_assertion("negative array index");
    _jump221:;
    if (_7 < h.d2)
    goto _jump222;
    fail_assertion("index too large");
    _jump222:;
    int64_t _8 = 0;
    _8 *= h.d0;
    _8 += _6;
    _8 *= h.d1;
    _8 += h.d1;
    _8 *= h.d2;
    _8 += _7;
    rgba _9 = h.data[_8];
    double _10 = _9.g;
    int64_t _11 = 114;
    bool _12 = h.d2 != _11;
    bool _13 = e(f, h);
    bool _14 = _12 != _13;
    _a2_bool _15;
    if (!_14)
    goto _jump223;
    _a2_bool _16;
    // Computing bound for l
    _16.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    // Computing bound for m
    _16.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing total size of heap memory to allocate
    int64_t _17 = 1;
    _17 *= h.d1;
    _17 *= f.d0;
    _17 *= sizeof(bool);
    _16.data = jpl_alloc(_17);
    int64_t _18 = 0; // m
    int64_t _19 = 0; // l
    _jump226:; // Begin body of loop
    bool _20 = e(f, h);
    int64_t _21 = 0;
    _21 *= _16.d0;
    _21 += _19;
    _21 *= _16.d1;
    _21 += _18;
    _16.data[_21] = _20;
    _18++;
    if (_18 < f.d0)
    goto _jump226;
    _18 = 0;
    _19++;
    if (_19 < h.d1)
    goto _jump226;
    // End body of loop
    _15 = _16;
    goto _jump227;
    _jump223:;
    _a2_bool _22;
    // Computing bound for l
    _22.d0 = d;
    if (d > 0) 
    goto _jump228;
    fail_assertion("non-positive loop bound");
    _jump228:;
    // Computing bound for m
    _22.d1 = d;
    if (d > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= d;
    _23 *= d;
    _23 *= sizeof(bool);
    _22.data = jpl_alloc(_23);
    int64_t _24 = 0; // m
    int64_t _25 = 0; // l
    _jump230:; // Begin body of loop
    bool _27 = false;
    bool _26 = _27;
    if (0 == _27)
    goto _jump231;
    bool _28 = false;
    _26 = _28;
    _jump231:;
    int64_t _29 = 0;
    _29 *= _22.d0;
    _29 += _25;
    _29 *= _22.d1;
    _29 += _24;
    _22.data[_29] = _26;
    _24++;
    if (_24 < d)
    goto _jump230;
    _24 = 0;
    _25++;
    if (_25 < d)
    goto _jump230;
    // End body of loop
    _15 = _22;
    _jump227:;
    double _30 = a(_10, _15);
    bool _31 = _5 < _30;
    _a2__a1_int64_t _32;
    if (!_31)
    goto _jump232;
    _a3__a2__a1_int64_t _33;
    // Computing bound for l
    int64_t _34 = d % h.d0;
    _33.d0 = _34;
    if (_34 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    // Computing bound for m
    _33.d1 = h.d1;
    if (h.d1 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing bound for n
    _a1_int64_t _35;
    // Computing bound for l
    int64_t _36 = 513;
    _35.d0 = _36;
    if (_36 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _36;
    _37 *= sizeof(int64_t);
    _35.data = jpl_alloc(_37);
    int64_t _38 = 0; // l
    _jump236:; // Begin body of loop
    int64_t _39 = c * c;
    int64_t _40 = 0;
    _40 *= _35.d0;
    _40 += _38;
    _35.data[_40] = _39;
    _38++;
    if (_38 < _36)
    goto _jump236;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump237;
    fail_assertion("negative array index");
    _jump237:;
    if (h.d0 < _35.d0)
    goto _jump238;
    fail_assertion("index too large");
    _jump238:;
    int64_t _41 = 0;
    _41 *= _35.d0;
    _41 += h.d0;
    int64_t _42 = _35.data[_41];
    _33.d2 = _42;
    if (_42 > 0) 
    goto _jump239;
    fail_assertion("non-positive loop bound");
    _jump239:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= _34;
    _43 *= h.d1;
    _43 *= _42;
    _43 *= sizeof(_a2__a1_int64_t);
    _33.data = jpl_alloc(_43);
    int64_t _44 = 0; // n
    int64_t _45 = 0; // m
    int64_t _46 = 0; // l
    _jump240:; // Begin body of loop
    int64_t _47 = 0;
    _47 *= _33.d0;
    _47 += _46;
    _47 *= _33.d1;
    _47 += _45;
    _47 *= _33.d2;
    _47 += _44;
    _33.data[_47] = b;
    _44++;
    if (_44 < _42)
    goto _jump240;
    _44 = 0;
    _45++;
    if (_45 < h.d1)
    goto _jump240;
    _45 = 0;
    _46++;
    if (_46 < _34)
    goto _jump240;
    // End body of loop
    int64_t _48;
    // Computing bound for l
    if (h.d1 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing bound for m
    int64_t _49 = d / h.d1;
    int64_t _50 = _49 + h.d1;
    if (_50 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for n
    int64_t _51;
    // Computing bound for l
    int64_t _52 = 915;
    if (_52 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    _51 = 0;
    int64_t _53 = 0; // l
    _jump244:; // Begin body of loop
    int64_t _54 = -d;
    int64_t _55 = _54 - _53;
    _51 += _55;
    _53++;
    if (_53 < _52)
    goto _jump244;
    // End body of loop
    if (_51 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    _48 = 0;
    int64_t _56 = 0; // n
    int64_t _57 = 0; // m
    int64_t _58 = 0; // l
    _jump246:; // Begin body of loop
    _48 += f.d0;
    _56++;
    if (_56 < _51)
    goto _jump246;
    _56 = 0;
    _57++;
    if (_57 < _50)
    goto _jump246;
    _57 = 0;
    _58++;
    if (_58 < h.d1)
    goto _jump246;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump247;
    fail_assertion("negative array index");
    _jump247:;
    if (h.d0 < _33.d0)
    goto _jump248;
    fail_assertion("index too large");
    _jump248:;
    if (_48 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (_48 < _33.d1)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    if (c >= 0)
    goto _jump251;
    fail_assertion("negative array index");
    _jump251:;
    if (c < _33.d2)
    goto _jump252;
    fail_assertion("index too large");
    _jump252:;
    int64_t _59 = 0;
    _59 *= _33.d0;
    _59 += h.d0;
    _59 *= _33.d1;
    _59 += _48;
    _59 *= _33.d2;
    _59 += c;
    _a2__a1_int64_t _60 = _33.data[_59];
    _32 = _60;
    goto _jump253;
    _jump232:;
    _a3__a1_rgba _61;
    // Computing bound for l
    _61.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump254;
    fail_assertion("non-positive loop bound");
    _jump254:;
    // Computing bound for m
    int64_t _62;
    // Computing bound for l
    if (f.d0 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    _62 = 0;
    int64_t _63 = 0; // l
    _jump256:; // Begin body of loop
    _62 += d;
    _63++;
    if (_63 < f.d0)
    goto _jump256;
    // End body of loop
    _61.d1 = _62;
    if (_62 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing bound for n
    _61.d2 = f.d0;
    if (f.d0 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= f.d0;
    _64 *= _62;
    _64 *= f.d0;
    _64 *= sizeof(_a1_rgba);
    _61.data = jpl_alloc(_64);
    int64_t _65 = 0; // n
    int64_t _66 = 0; // m
    int64_t _67 = 0; // l
    _jump259:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _61.d0;
    _68 += _67;
    _68 *= _61.d1;
    _68 += _66;
    _68 *= _61.d2;
    _68 += _65;
    _61.data[_68] = f;
    _65++;
    if (_65 < f.d0)
    goto _jump259;
    _65 = 0;
    _66++;
    if (_66 < _62)
    goto _jump259;
    _66 = 0;
    _67++;
    if (_67 < f.d0)
    goto _jump259;
    // End body of loop
    _a1_int64_t _69;
    _69.d0 = 1;
    _69.data = jpl_alloc(sizeof(int64_t) * 1);
    _69.data[0] = f.d0;
    int64_t _70;
    // Computing bound for l
    if (f.d0 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    // Computing bound for m
    if (c > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    _70 = 0;
    int64_t _71 = 0; // m
    int64_t _72 = 0; // l
    _jump262:; // Begin body of loop
    _70 += h.d2;
    _71++;
    if (_71 < c)
    goto _jump262;
    _71 = 0;
    _72++;
    if (_72 < f.d0)
    goto _jump262;
    // End body of loop
    if (_70 >= 0)
    goto _jump263;
    fail_assertion("negative array index");
    _jump263:;
    if (_70 < _69.d0)
    goto _jump264;
    fail_assertion("index too large");
    _jump264:;
    int64_t _73 = 0;
    _73 *= _69.d0;
    _73 += _70;
    int64_t _74 = _69.data[_73];
    int64_t _75;
    // Computing bound for l
    if (d > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing bound for m
    if (h.d2 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing bound for n
    bool _76 = false;
    int64_t _77;
    if (!_76)
    goto _jump267;
    _77 = h.d1;
    goto _jump268;
    _jump267:;
    _77 = d;
    _jump268:;
    if (_77 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    _75 = 0;
    int64_t _78 = 0; // n
    int64_t _79 = 0; // m
    int64_t _80 = 0; // l
    _jump270:; // Begin body of loop
    _75 += _78;
    _78++;
    if (_78 < _77)
    goto _jump270;
    _78 = 0;
    _79++;
    if (_79 < h.d2)
    goto _jump270;
    _79 = 0;
    _80++;
    if (_80 < d)
    goto _jump270;
    // End body of loop
    if (_74 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_74 < _61.d0)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    if (h.d0 >= 0)
    goto _jump273;
    fail_assertion("negative array index");
    _jump273:;
    if (h.d0 < _61.d1)
    goto _jump274;
    fail_assertion("index too large");
    _jump274:;
    if (_75 >= 0)
    goto _jump275;
    fail_assertion("negative array index");
    _jump275:;
    if (_75 < _61.d2)
    goto _jump276;
    fail_assertion("index too large");
    _jump276:;
    int64_t _81 = 0;
    _81 *= _61.d0;
    _81 += _74;
    _81 *= _61.d1;
    _81 += h.d0;
    _81 *= _61.d2;
    _81 += _75;
    _a1_rgba _82 = _61.data[_81];
    _a3_rgba _83;
    // Computing bound for l
    int64_t _84 = d + c;
    int64_t _85 = -_84;
    _83.d0 = _85;
    if (_85 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for m
    _83.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing bound for n
    _83.d2 = c;
    if (c > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= _85;
    _86 *= h.d0;
    _86 *= c;
    _86 *= sizeof(rgba);
    _83.data = jpl_alloc(_86);
    int64_t _87 = 0; // n
    int64_t _88 = 0; // m
    int64_t _89 = 0; // l
    _jump280:; // Begin body of loop
    bool _90 = true;
    _a3_rgba _91;
    if (!_90)
    goto _jump281;
    _91 = h;
    goto _jump282;
    _jump281:;
    _91 = h;
    _jump282:;
    int64_t _92 = 606;
    int64_t _93 = _87 * _92;
    int64_t _94 = _87 / f.d0;
    int64_t _95 = d * h.d1;
    if (_93 >= 0)
    goto _jump283;
    fail_assertion("negative array index");
    _jump283:;
    if (_93 < _91.d0)
    goto _jump284;
    fail_assertion("index too large");
    _jump284:;
    if (_94 >= 0)
    goto _jump285;
    fail_assertion("negative array index");
    _jump285:;
    if (_94 < _91.d1)
    goto _jump286;
    fail_assertion("index too large");
    _jump286:;
    if (_95 >= 0)
    goto _jump287;
    fail_assertion("negative array index");
    _jump287:;
    if (_95 < _91.d2)
    goto _jump288;
    fail_assertion("index too large");
    _jump288:;
    int64_t _96 = 0;
    _96 *= _91.d0;
    _96 += _93;
    _96 *= _91.d1;
    _96 += _94;
    _96 *= _91.d2;
    _96 += _95;
    rgba _97 = _91.data[_96];
    int64_t _98 = 0;
    _98 *= _83.d0;
    _98 += _89;
    _98 *= _83.d1;
    _98 += _88;
    _98 *= _83.d2;
    _98 += _87;
    _83.data[_98] = _97;
    _87++;
    if (_87 < c)
    goto _jump280;
    _87 = 0;
    _88++;
    if (_88 < h.d0)
    goto _jump280;
    _88 = 0;
    _89++;
    if (_89 < _85)
    goto _jump280;
    // End body of loop
    bool _99 = e(_82, _83);
    _a2__a1_int64_t _100;
    if (!_99)
    goto _jump289;
    bool _101 = true;
    _a3__a2__a1_int64_t _102;
    if (!_101)
    goto _jump290;
    _a3__a2__a1_int64_t _103;
    // Computing bound for l
    _103.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump291;
    fail_assertion("non-positive loop bound");
    _jump291:;
    // Computing bound for m
    int64_t _104 = -f.d0;
    _103.d1 = _104;
    if (_104 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing bound for n
    bool _105 = true;
    int64_t _106;
    if (!_105)
    goto _jump293;
    _106 = h.d2;
    goto _jump294;
    _jump293:;
    int64_t _107 = 541;
    _106 = _107;
    _jump294:;
    _103.d2 = _106;
    if (_106 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= h.d1;
    _108 *= _104;
    _108 *= _106;
    _108 *= sizeof(_a2__a1_int64_t);
    _103.data = jpl_alloc(_108);
    int64_t _109 = 0; // n
    int64_t _110 = 0; // m
    int64_t _111 = 0; // l
    _jump296:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _103.d0;
    _112 += _111;
    _112 *= _103.d1;
    _112 += _110;
    _112 *= _103.d2;
    _112 += _109;
    _103.data[_112] = b;
    _109++;
    if (_109 < _106)
    goto _jump296;
    _109 = 0;
    _110++;
    if (_110 < _104)
    goto _jump296;
    _110 = 0;
    _111++;
    if (_111 < h.d1)
    goto _jump296;
    // End body of loop
    _102 = _103;
    goto _jump297;
    _jump290:;
    _a3__a2__a1_int64_t _113;
    // Computing bound for l
    _113.d0 = d;
    if (d > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing bound for m
    _113.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for n
    _113.d2 = c;
    if (c > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= d;
    _114 *= h.d0;
    _114 *= c;
    _114 *= sizeof(_a2__a1_int64_t);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // n
    int64_t _116 = 0; // m
    int64_t _117 = 0; // l
    _jump301:; // Begin body of loop
    bool _118 = false;
    _a2__a1_int64_t _119;
    if (!_118)
    goto _jump302;
    _119 = b;
    goto _jump303;
    _jump302:;
    _119 = b;
    _jump303:;
    int64_t _120 = 0;
    _120 *= _113.d0;
    _120 += _117;
    _120 *= _113.d1;
    _120 += _116;
    _120 *= _113.d2;
    _120 += _115;
    _113.data[_120] = _119;
    _115++;
    if (_115 < c)
    goto _jump301;
    _115 = 0;
    _116++;
    if (_116 < h.d0)
    goto _jump301;
    _116 = 0;
    _117++;
    if (_117 < d)
    goto _jump301;
    // End body of loop
    _102 = _113;
    _jump297:;
    int64_t _121;
    // Computing bound for l
    if (f.d0 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for m
    if (c > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing bound for n
    int64_t _122 = 738;
    if (_122 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    _121 = 0;
    int64_t _123 = 0; // n
    int64_t _124 = 0; // m
    int64_t _125 = 0; // l
    _jump307:; // Begin body of loop
    int64_t _126 = -c;
    _121 += _126;
    _123++;
    if (_123 < _122)
    goto _jump307;
    _123 = 0;
    _124++;
    if (_124 < c)
    goto _jump307;
    _124 = 0;
    _125++;
    if (_125 < f.d0)
    goto _jump307;
    // End body of loop
    if (f.d0 >= 0)
    goto _jump308;
    fail_assertion("negative array index");
    _jump308:;
    if (f.d0 < _102.d0)
    goto _jump309;
    fail_assertion("index too large");
    _jump309:;
    if (_121 >= 0)
    goto _jump310;
    fail_assertion("negative array index");
    _jump310:;
    if (_121 < _102.d1)
    goto _jump311;
    fail_assertion("index too large");
    _jump311:;
    if (c >= 0)
    goto _jump312;
    fail_assertion("negative array index");
    _jump312:;
    if (c < _102.d2)
    goto _jump313;
    fail_assertion("index too large");
    _jump313:;
    int64_t _127 = 0;
    _127 *= _102.d0;
    _127 += f.d0;
    _127 *= _102.d1;
    _127 += _121;
    _127 *= _102.d2;
    _127 += c;
    _a2__a1_int64_t _128 = _102.data[_127];
    _100 = _128;
    goto _jump314;
    _jump289:;
    _a2__a2__a1_int64_t _129;
    // Computing bound for l
    _a3_int64_t _130;
    // Computing bound for l
    _130.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    // Computing bound for m
    _130.d1 = d;
    if (d > 0) 
    goto _jump316;
    fail_assertion("non-positive loop bound");
    _jump316:;
    // Computing bound for n
    _130.d2 = c;
    if (c > 0) 
    goto _jump317;
    fail_assertion("non-positive loop bound");
    _jump317:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= h.d2;
    _131 *= d;
    _131 *= c;
    _131 *= sizeof(int64_t);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // n
    int64_t _133 = 0; // m
    int64_t _134 = 0; // l
    _jump318:; // Begin body of loop
    int64_t _135 = 0;
    _135 *= _130.d0;
    _135 += _134;
    _135 *= _130.d1;
    _135 += _133;
    _135 *= _130.d2;
    _135 += _132;
    _130.data[_135] = c;
    _132++;
    if (_132 < c)
    goto _jump318;
    _132 = 0;
    _133++;
    if (_133 < d)
    goto _jump318;
    _133 = 0;
    _134++;
    if (_134 < h.d2)
    goto _jump318;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump319;
    fail_assertion("negative array index");
    _jump319:;
    if (h.d0 < _130.d0)
    goto _jump320;
    fail_assertion("index too large");
    _jump320:;
    if (h.d0 >= 0)
    goto _jump321;
    fail_assertion("negative array index");
    _jump321:;
    if (h.d0 < _130.d1)
    goto _jump322;
    fail_assertion("index too large");
    _jump322:;
    if (h.d2 >= 0)
    goto _jump323;
    fail_assertion("negative array index");
    _jump323:;
    if (h.d2 < _130.d2)
    goto _jump324;
    fail_assertion("index too large");
    _jump324:;
    int64_t _136 = 0;
    _136 *= _130.d0;
    _136 += h.d0;
    _136 *= _130.d1;
    _136 += h.d0;
    _136 *= _130.d2;
    _136 += h.d2;
    int64_t _137 = _130.data[_136];
    _129.d0 = _137;
    if (_137 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    // Computing bound for m
    _129.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= _137;
    _138 *= h.d0;
    _138 *= sizeof(_a2__a1_int64_t);
    _129.data = jpl_alloc(_138);
    int64_t _139 = 0; // m
    int64_t _140 = 0; // l
    _jump327:; // Begin body of loop
    int64_t _141 = 0;
    _141 *= _129.d0;
    _141 += _140;
    _141 *= _129.d1;
    _141 += _139;
    _129.data[_141] = b;
    _139++;
    if (_139 < h.d0)
    goto _jump327;
    _139 = 0;
    _140++;
    if (_140 < _137)
    goto _jump327;
    // End body of loop
    int64_t _142;
    // Computing bound for l
    int64_t _143 = -h.d2;
    if (_143 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    // Computing bound for m
    if (f.d0 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    _142 = 0;
    int64_t _144 = 0; // m
    int64_t _145 = 0; // l
    _jump330:; // Begin body of loop
    _142 += _144;
    _144++;
    if (_144 < f.d0)
    goto _jump330;
    _144 = 0;
    _145++;
    if (_145 < _143)
    goto _jump330;
    // End body of loop
    int64_t _146;
    // Computing bound for l
    bool _147 = true;
    int64_t _148;
    if (!_147)
    goto _jump331;
    _148 = h.d0;
    goto _jump332;
    _jump331:;
    _148 = f.d0;
    _jump332:;
    if (_148 > 0) 
    goto _jump333;
    fail_assertion("non-positive loop bound");
    _jump333:;
    // Computing bound for m
    if (d > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    _146 = 0;
    int64_t _149 = 0; // m
    int64_t _150 = 0; // l
    _jump335:; // Begin body of loop
    _a3_int64_t _151;
    // Computing bound for n
    _151.d0 = _149;
    if (_149 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    // Computing bound for o
    int64_t _152 = 433;
    _151.d1 = _152;
    if (_152 > 0) 
    goto _jump337;
    fail_assertion("non-positive loop bound");
    _jump337:;
    // Computing bound for p
    _151.d2 = _149;
    if (_149 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _149;
    _153 *= _152;
    _153 *= _149;
    _153 *= sizeof(int64_t);
    _151.data = jpl_alloc(_153);
    int64_t _154 = 0; // p
    int64_t _155 = 0; // o
    int64_t _156 = 0; // n
    _jump339:; // Begin body of loop
    int64_t _157 = 0;
    _157 *= _151.d0;
    _157 += _156;
    _157 *= _151.d1;
    _157 += _155;
    _157 *= _151.d2;
    _157 += _154;
    _151.data[_157] = h.d2;
    _154++;
    if (_154 < _149)
    goto _jump339;
    _154 = 0;
    _155++;
    if (_155 < _152)
    goto _jump339;
    _155 = 0;
    _156++;
    if (_156 < _149)
    goto _jump339;
    // End body of loop
    int64_t _158 = 415;
    int64_t _159 = c + c;
    if (_158 >= 0)
    goto _jump340;
    fail_assertion("negative array index");
    _jump340:;
    if (_158 < _151.d0)
    goto _jump341;
    fail_assertion("index too large");
    _jump341:;
    if (_159 >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (_159 < _151.d1)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    if (_150 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (_150 < _151.d2)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    int64_t _160 = 0;
    _160 *= _151.d0;
    _160 += _158;
    _160 *= _151.d1;
    _160 += _159;
    _160 *= _151.d2;
    _160 += _150;
    int64_t _161 = _151.data[_160];
    _146 += _161;
    _149++;
    if (_149 < d)
    goto _jump335;
    _149 = 0;
    _150++;
    if (_150 < _148)
    goto _jump335;
    // End body of loop
    if (_142 >= 0)
    goto _jump346;
    fail_assertion("negative array index");
    _jump346:;
    if (_142 < _129.d0)
    goto _jump347;
    fail_assertion("index too large");
    _jump347:;
    if (_146 >= 0)
    goto _jump348;
    fail_assertion("negative array index");
    _jump348:;
    if (_146 < _129.d1)
    goto _jump349;
    fail_assertion("index too large");
    _jump349:;
    int64_t _162 = 0;
    _162 *= _129.d0;
    _162 += _142;
    _162 *= _129.d1;
    _162 += _146;
    _a2__a1_int64_t _163 = _129.data[_162];
    _100 = _163;
    _jump314:;
    _32 = _100;
    _jump253:;
    _2 = _32;
    goto _jump350;
    _jump216:;
    _a2__a1_int64_t _164;
    // Computing bound for l
    _164.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing bound for m
    double _165 = 35.0;
    double _166;
    // Computing bound for l
    if (h.d1 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    // Computing bound for m
    int64_t _167 = c * f.d0;
    if (_167 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    _166 = 0;
    int64_t _168 = 0; // m
    int64_t _169 = 0; // l
    _jump354:; // Begin body of loop
    double _170 = 10.0;
    _166 += _170;
    _168++;
    if (_168 < _167)
    goto _jump354;
    _168 = 0;
    _169++;
    if (_169 < h.d1)
    goto _jump354;
    // End body of loop
    double _171;
    // Computing bound for l
    int64_t _172 = h.d1 % f.d0;
    if (_172 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing bound for m
    if (f.d0 > 0) 
    goto _jump356;
    fail_assertion("non-positive loop bound");
    _jump356:;
    // Computing bound for n
    int64_t _173 = c % h.d2;
    if (_173 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    _171 = 0;
    int64_t _174 = 0; // n
    int64_t _175 = 0; // m
    int64_t _176 = 0; // l
    _jump358:; // Begin body of loop
    bool _177 = true;
    double _178;
    if (!_177)
    goto _jump359;
    double _179 = 96.0;
    _178 = _179;
    goto _jump360;
    _jump359:;
    double _180 = 48.0;
    _178 = _180;
    _jump360:;
    _171 += _178;
    _174++;
    if (_174 < _173)
    goto _jump358;
    _174 = 0;
    _175++;
    if (_175 < f.d0)
    goto _jump358;
    _175 = 0;
    _176++;
    if (_176 < _172)
    goto _jump358;
    // End body of loop
    double _181 = _166 + _171;
    bool _182 = _165 > _181;
    int64_t _183;
    if (!_182)
    goto _jump361;
    _183 = c;
    goto _jump362;
    _jump361:;
    _183 = h.d0;
    _jump362:;
    _164.d1 = _183;
    if (_183 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= h.d2;
    _184 *= _183;
    _184 *= sizeof(_a1_int64_t);
    _164.data = jpl_alloc(_184);
    int64_t _185 = 0; // m
    int64_t _186 = 0; // l
    _jump364:; // Begin body of loop
    _a1_int64_t _187;
    // Computing bound for n
    _187.d0 = d;
    if (d > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= d;
    _188 *= sizeof(int64_t);
    _187.data = jpl_alloc(_188);
    int64_t _189 = 0; // n
    _jump366:; // Begin body of loop
    int64_t _190 = 8;
    int64_t _191 = 0;
    _191 *= _187.d0;
    _191 += _189;
    _187.data[_191] = _190;
    _189++;
    if (_189 < d)
    goto _jump366;
    // End body of loop
    int64_t _192 = 0;
    _192 *= _164.d0;
    _192 += _186;
    _192 *= _164.d1;
    _192 += _185;
    _164.data[_192] = _187;
    _185++;
    if (_185 < _183)
    goto _jump364;
    _185 = 0;
    _186++;
    if (_186 < h.d2)
    goto _jump364;
    // End body of loop
    _2 = _164;
    _jump350:;
    double _193;
    // Computing bound for o
    bool _194 = e(f, h);
    int64_t _195;
    if (!_194)
    goto _jump367;
    int64_t _196;
    // Computing bound for o
    if (_2.d1 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    _196 = 0;
    int64_t _197 = 0; // o
    _jump369:; // Begin body of loop
    int64_t _198 = 874;
    _196 += _198;
    _197++;
    if (_197 < _2.d1)
    goto _jump369;
    // End body of loop
    _195 = _196;
    goto _jump370;
    _jump367:;
    _195 = c;
    _jump370:;
    if (_195 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing bound for p
    int64_t _199;
    // Computing bound for o
    if (f.d0 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    _199 = 0;
    int64_t _200 = 0; // o
    _jump373:; // Begin body of loop
    _199 += _200;
    _200++;
    if (_200 < f.d0)
    goto _jump373;
    // End body of loop
    if (_199 > 0) 
    goto _jump374;
    fail_assertion("non-positive loop bound");
    _jump374:;
    _193 = 0;
    int64_t _201 = 0; // p
    int64_t _202 = 0; // o
    _jump375:; // Begin body of loop
    double _203 = 84.0;
    _193 += _203;
    _201++;
    if (_201 < _199)
    goto _jump375;
    _201 = 0;
    _202++;
    if (_202 < _195)
    goto _jump375;
    // End body of loop
    double _204 = 44.0;
    double _205 = -_204;
    double _206 = _193 - _205;
    _a3_double _207;
    // Computing bound for o
    _207.d0 = c;
    if (c > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing bound for p
    int64_t _208 = 769;
    int64_t _209 = -_208;
    _207.d1 = _209;
    if (_209 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    // Computing bound for q
    _207.d2 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= c;
    _210 *= _209;
    _210 *= _2.d0;
    _210 *= sizeof(double);
    _207.data = jpl_alloc(_210);
    int64_t _211 = 0; // q
    int64_t _212 = 0; // p
    int64_t _213 = 0; // o
    _jump379:; // Begin body of loop
    double _214;
    // Computing bound for r
    if (h.d2 > 0) 
    goto _jump380;
    fail_assertion("non-positive loop bound");
    _jump380:;
    // Computing bound for s
    if (d > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    _214 = 0;
    int64_t _215 = 0; // s
    int64_t _216 = 0; // r
    _jump382:; // Begin body of loop
    double _217 = 36.0;
    _214 += _217;
    _215++;
    if (_215 < d)
    goto _jump382;
    _215 = 0;
    _216++;
    if (_216 < h.d2)
    goto _jump382;
    // End body of loop
    int64_t _218 = 0;
    _218 *= _207.d0;
    _218 += _213;
    _218 *= _207.d1;
    _218 += _212;
    _218 *= _207.d2;
    _218 += _211;
    _207.data[_218] = _214;
    _211++;
    if (_211 < _2.d0)
    goto _jump379;
    _211 = 0;
    _212++;
    if (_212 < _209)
    goto _jump379;
    _212 = 0;
    _213++;
    if (_213 < c)
    goto _jump379;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump383;
    fail_assertion("negative array index");
    _jump383:;
    if (h.d0 < _207.d0)
    goto _jump384;
    fail_assertion("index too large");
    _jump384:;
    if (d >= 0)
    goto _jump385;
    fail_assertion("negative array index");
    _jump385:;
    if (d < _207.d1)
    goto _jump386;
    fail_assertion("index too large");
    _jump386:;
    if (h.d1 >= 0)
    goto _jump387;
    fail_assertion("negative array index");
    _jump387:;
    if (h.d1 < _207.d2)
    goto _jump388;
    fail_assertion("index too large");
    _jump388:;
    int64_t _219 = 0;
    _219 *= _207.d0;
    _219 += h.d0;
    _219 *= _207.d1;
    _219 += d;
    _219 *= _207.d2;
    _219 += h.d1;
    double _220 = _207.data[_219];
    double _221 = -_220;
    bool _222 = _206 != _221;
    bool _223;
    if (!_222)
    goto _jump389;
    _a3__a3__a1_rgba _224;
    // Computing bound for o
    int64_t _225 = 659;
    _224.d0 = _225;
    if (_225 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for p
    _224.d1 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for q
    _224.d2 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing total size of heap memory to allocate
    int64_t _226 = 1;
    _226 *= _225;
    _226 *= _2.d0;
    _226 *= _2.d0;
    _226 *= sizeof(_a3__a1_rgba);
    _224.data = jpl_alloc(_226);
    int64_t _227 = 0; // q
    int64_t _228 = 0; // p
    int64_t _229 = 0; // o
    _jump393:; // Begin body of loop
    _a3__a1_rgba _230;
    // Computing bound for r
    _230.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing bound for s
    _230.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    // Computing bound for t
    int64_t _231 = 532;
    _230.d2 = _231;
    if (_231 > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= h.d0;
    _232 *= f.d0;
    _232 *= _231;
    _232 *= sizeof(_a1_rgba);
    _230.data = jpl_alloc(_232);
    int64_t _233 = 0; // t
    int64_t _234 = 0; // s
    int64_t _235 = 0; // r
    _jump397:; // Begin body of loop
    int64_t _236 = 0;
    _236 *= _230.d0;
    _236 += _235;
    _236 *= _230.d1;
    _236 += _234;
    _236 *= _230.d2;
    _236 += _233;
    _230.data[_236] = f;
    _233++;
    if (_233 < _231)
    goto _jump397;
    _233 = 0;
    _234++;
    if (_234 < f.d0)
    goto _jump397;
    _234 = 0;
    _235++;
    if (_235 < h.d0)
    goto _jump397;
    // End body of loop
    int64_t _237 = 0;
    _237 *= _224.d0;
    _237 += _229;
    _237 *= _224.d1;
    _237 += _228;
    _237 *= _224.d2;
    _237 += _227;
    _224.data[_237] = _230;
    _227++;
    if (_227 < _2.d0)
    goto _jump393;
    _227 = 0;
    _228++;
    if (_228 < _2.d0)
    goto _jump393;
    _228 = 0;
    _229++;
    if (_229 < _225)
    goto _jump393;
    // End body of loop
    bool _238 = h.d0 == c;
    int64_t _239;
    if (!_238)
    goto _jump398;
    int64_t _240 = 772;
    int64_t _241 = _240 / _2.d1;
    _239 = _241;
    goto _jump399;
    _jump398:;
    _239 = c;
    _jump399:;
    int64_t _242 = 772;
    if (h.d1 >= 0)
    goto _jump400;
    fail_assertion("negative array index");
    _jump400:;
    if (h.d1 < _224.d0)
    goto _jump401;
    fail_assertion("index too large");
    _jump401:;
    if (_239 >= 0)
    goto _jump402;
    fail_assertion("negative array index");
    _jump402:;
    if (_239 < _224.d1)
    goto _jump403;
    fail_assertion("index too large");
    _jump403:;
    if (_242 >= 0)
    goto _jump404;
    fail_assertion("negative array index");
    _jump404:;
    if (_242 < _224.d2)
    goto _jump405;
    fail_assertion("index too large");
    _jump405:;
    int64_t _243 = 0;
    _243 *= _224.d0;
    _243 += h.d1;
    _243 *= _224.d1;
    _243 += _239;
    _243 *= _224.d2;
    _243 += _242;
    _a3__a1_rgba _244 = _224.data[_243];
    double _245 = 75.0;
    double _246 = 79.0;
    bool _247 = _245 > _246;
    int64_t _248;
    if (!_247)
    goto _jump406;
    int64_t _249 = 397;
    int64_t _250 = f.d0 / h.d0;
    int64_t _251 = _249 - _250;
    _248 = _251;
    goto _jump407;
    _jump406:;
    _248 = h.d2;
    _jump407:;
    if (_248 >= 0)
    goto _jump408;
    fail_assertion("negative array index");
    _jump408:;
    if (_248 < _244.d0)
    goto _jump409;
    fail_assertion("index too large");
    _jump409:;
    if (h.d2 >= 0)
    goto _jump410;
    fail_assertion("negative array index");
    _jump410:;
    if (h.d2 < _244.d1)
    goto _jump411;
    fail_assertion("index too large");
    _jump411:;
    if (d >= 0)
    goto _jump412;
    fail_assertion("negative array index");
    _jump412:;
    if (d < _244.d2)
    goto _jump413;
    fail_assertion("index too large");
    _jump413:;
    int64_t _252 = 0;
    _252 *= _244.d0;
    _252 += _248;
    _252 *= _244.d1;
    _252 += h.d2;
    _252 *= _244.d2;
    _252 += d;
    _a1_rgba _253 = _244.data[_252];
    if (_2.d0 >= 0)
    goto _jump414;
    fail_assertion("negative array index");
    _jump414:;
    if (_2.d0 < h.d0)
    goto _jump415;
    fail_assertion("index too large");
    _jump415:;
    if (d >= 0)
    goto _jump416;
    fail_assertion("negative array index");
    _jump416:;
    if (d < h.d1)
    goto _jump417;
    fail_assertion("index too large");
    _jump417:;
    if (_2.d1 >= 0)
    goto _jump418;
    fail_assertion("negative array index");
    _jump418:;
    if (_2.d1 < h.d2)
    goto _jump419;
    fail_assertion("index too large");
    _jump419:;
    int64_t _254 = 0;
    _254 *= h.d0;
    _254 += _2.d0;
    _254 *= h.d1;
    _254 += d;
    _254 *= h.d2;
    _254 += _2.d1;
    rgba _255 = h.data[_254];
    double _256 = _255.g;
    double _257 = 53.0;
    _a1_double _258;
    _258.d0 = 1;
    _258.data = jpl_alloc(sizeof(double) * 1);
    _258.data[0] = _257;
    int64_t _259 = 861;
    if (_259 >= 0)
    goto _jump420;
    fail_assertion("negative array index");
    _jump420:;
    if (_259 < _258.d0)
    goto _jump421;
    fail_assertion("index too large");
    _jump421:;
    int64_t _260 = 0;
    _260 *= _258.d0;
    _260 += _259;
    double _261 = _258.data[_260];
    bool _262 = _256 < _261;
    _a3_rgba _263;
    if (!_262)
    goto _jump422;
    _263 = h;
    goto _jump423;
    _jump422:;
    _a3__a3_rgba _264;
    // Computing bound for o
    int64_t _265 = 103;
    _264.d0 = _265;
    if (_265 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing bound for p
    bool _266 = true;
    int64_t _267;
    if (!_266)
    goto _jump425;
    _267 = f.d0;
    goto _jump426;
    _jump425:;
    _267 = d;
    _jump426:;
    _264.d1 = _267;
    if (_267 > 0) 
    goto _jump427;
    fail_assertion("non-positive loop bound");
    _jump427:;
    // Computing bound for q
    _264.d2 = h.d1;
    if (h.d1 > 0) 
    goto _jump428;
    fail_assertion("non-positive loop bound");
    _jump428:;
    // Computing total size of heap memory to allocate
    int64_t _268 = 1;
    _268 *= _265;
    _268 *= _267;
    _268 *= h.d1;
    _268 *= sizeof(_a3_rgba);
    _264.data = jpl_alloc(_268);
    int64_t _269 = 0; // q
    int64_t _270 = 0; // p
    int64_t _271 = 0; // o
    _jump429:; // Begin body of loop
    int64_t _272 = 0;
    _272 *= _264.d0;
    _272 += _271;
    _272 *= _264.d1;
    _272 += _270;
    _272 *= _264.d2;
    _272 += _269;
    _264.data[_272] = h;
    _269++;
    if (_269 < h.d1)
    goto _jump429;
    _269 = 0;
    _270++;
    if (_270 < _267)
    goto _jump429;
    _270 = 0;
    _271++;
    if (_271 < _265)
    goto _jump429;
    // End body of loop
    _a2_int64_t _273;
    // Computing bound for o
    _273.d0 = c;
    if (c > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing bound for p
    _273.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= c;
    _274 *= h.d0;
    _274 *= sizeof(int64_t);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // p
    int64_t _276 = 0; // o
    _jump432:; // Begin body of loop
    int64_t _277 = 0;
    _277 *= _273.d0;
    _277 += _276;
    _277 *= _273.d1;
    _277 += _275;
    _273.data[_277] = h.d2;
    _275++;
    if (_275 < h.d0)
    goto _jump432;
    _275 = 0;
    _276++;
    if (_276 < c)
    goto _jump432;
    // End body of loop
    if (f.d0 >= 0)
    goto _jump433;
    fail_assertion("negative array index");
    _jump433:;
    if (f.d0 < _273.d0)
    goto _jump434;
    fail_assertion("index too large");
    _jump434:;
    if (f.d0 >= 0)
    goto _jump435;
    fail_assertion("negative array index");
    _jump435:;
    if (f.d0 < _273.d1)
    goto _jump436;
    fail_assertion("index too large");
    _jump436:;
    int64_t _278 = 0;
    _278 *= _273.d0;
    _278 += f.d0;
    _278 *= _273.d1;
    _278 += f.d0;
    int64_t _279 = _273.data[_278];
    int64_t _280;
    // Computing bound for o
    if (_2.d0 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    _280 = 0;
    int64_t _281 = 0; // o
    _jump438:; // Begin body of loop
    _280 += _281;
    _281++;
    if (_281 < _2.d0)
    goto _jump438;
    // End body of loop
    int64_t _282 = c * _280;
    if (_279 >= 0)
    goto _jump439;
    fail_assertion("negative array index");
    _jump439:;
    if (_279 < _264.d0)
    goto _jump440;
    fail_assertion("index too large");
    _jump440:;
    if (_282 >= 0)
    goto _jump441;
    fail_assertion("negative array index");
    _jump441:;
    if (_282 < _264.d1)
    goto _jump442;
    fail_assertion("index too large");
    _jump442:;
    if (h.d2 >= 0)
    goto _jump443;
    fail_assertion("negative array index");
    _jump443:;
    if (h.d2 < _264.d2)
    goto _jump444;
    fail_assertion("index too large");
    _jump444:;
    int64_t _283 = 0;
    _283 *= _264.d0;
    _283 += _279;
    _283 *= _264.d1;
    _283 += _282;
    _283 *= _264.d2;
    _283 += h.d2;
    _a3_rgba _284 = _264.data[_283];
    _263 = _284;
    _jump423:;
    bool _285 = e(_253, _263);
    _223 = _285;
    goto _jump445;
    _jump389:;
    bool _286 = true;
    _223 = _286;
    _jump445:;
    double _287;
    if (!_223)
    goto _jump446;
    double _288 = 24.0;
    double _289 = 86.0;
    bool _290 = _288 < _289;
    double _291;
    if (!_290)
    goto _jump447;
    double _292 = 78.0;
    double _293 = -_292;
    _291 = _293;
    goto _jump448;
    _jump447:;
    double _294 = 24.0;
    double _295 = -_294;
    _291 = _295;
    _jump448:;
    if (d >= 0)
    goto _jump449;
    fail_assertion("negative array index");
    _jump449:;
    if (d < h.d0)
    goto _jump450;
    fail_assertion("index too large");
    _jump450:;
    if (f.d0 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (f.d0 < h.d1)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    if (d >= 0)
    goto _jump453;
    fail_assertion("negative array index");
    _jump453:;
    if (d < h.d2)
    goto _jump454;
    fail_assertion("index too large");
    _jump454:;
    int64_t _296 = 0;
    _296 *= h.d0;
    _296 += d;
    _296 *= h.d1;
    _296 += f.d0;
    _296 *= h.d2;
    _296 += d;
    rgba _297 = h.data[_296];
    double _298 = _297.g;
    double _299 = _291 + _298;
    double _300 = -_299;
    double _301 = -_300;
    _a2_bool _302;
    // Computing bound for o
    _302.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for p
    _302.d1 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= h.d1;
    _303 *= _2.d0;
    _303 *= sizeof(bool);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // p
    int64_t _305 = 0; // o
    _jump457:; // Begin body of loop
    bool _308 = false;
    bool _309 = !_308;
    bool _311 = false;
    bool _310 = _311;
    if (0 != _311)
    goto _jump458;
    bool _312 = false;
    _310 = _312;
    _jump458:;
    bool _313 = _309 == _310;
    bool _307 = _313;
    if (0 != _313)
    goto _jump459;
    _a3_bool _314;
    // Computing bound for q
    _314.d0 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing bound for r
    _314.d1 = c;
    if (c > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for s
    _314.d2 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing total size of heap memory to allocate
    int64_t _315 = 1;
    _315 *= _2.d0;
    _315 *= c;
    _315 *= _2.d1;
    _315 *= sizeof(bool);
    _314.data = jpl_alloc(_315);
    int64_t _316 = 0; // s
    int64_t _317 = 0; // r
    int64_t _318 = 0; // q
    _jump463:; // Begin body of loop
    bool _319 = true;
    int64_t _320 = 0;
    _320 *= _314.d0;
    _320 += _318;
    _320 *= _314.d1;
    _320 += _317;
    _320 *= _314.d2;
    _320 += _316;
    _314.data[_320] = _319;
    _316++;
    if (_316 < _2.d1)
    goto _jump463;
    _316 = 0;
    _317++;
    if (_317 < c)
    goto _jump463;
    _317 = 0;
    _318++;
    if (_318 < _2.d0)
    goto _jump463;
    // End body of loop
    int64_t _321 = 692;
    int64_t _322;
    // Computing bound for q
    if (_2.d1 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    _322 = 0;
    int64_t _323 = 0; // q
    _jump465:; // Begin body of loop
    _322 += _2.d0;
    _323++;
    if (_323 < _2.d1)
    goto _jump465;
    // End body of loop
    int64_t _324 = h.d2 / h.d2;
    if (_321 >= 0)
    goto _jump466;
    fail_assertion("negative array index");
    _jump466:;
    if (_321 < _314.d0)
    goto _jump467;
    fail_assertion("index too large");
    _jump467:;
    if (_322 >= 0)
    goto _jump468;
    fail_assertion("negative array index");
    _jump468:;
    if (_322 < _314.d1)
    goto _jump469;
    fail_assertion("index too large");
    _jump469:;
    if (_324 >= 0)
    goto _jump470;
    fail_assertion("negative array index");
    _jump470:;
    if (_324 < _314.d2)
    goto _jump471;
    fail_assertion("index too large");
    _jump471:;
    int64_t _325 = 0;
    _325 *= _314.d0;
    _325 += _321;
    _325 *= _314.d1;
    _325 += _322;
    _325 *= _314.d2;
    _325 += _324;
    bool _326 = _314.data[_325];
    _307 = _326;
    _jump459:;
    bool _306 = _307;
    if (0 == _307)
    goto _jump472;
    int64_t _327 = _304 * _305;
    bool _328 = _327 > _304;
    _306 = _328;
    _jump472:;
    int64_t _329 = 0;
    _329 *= _302.d0;
    _329 += _305;
    _329 *= _302.d1;
    _329 += _304;
    _302.data[_329] = _306;
    _304++;
    if (_304 < _2.d0)
    goto _jump457;
    _304 = 0;
    _305++;
    if (_305 < h.d1)
    goto _jump457;
    // End body of loop
    double _330 = a(_301, _302);
    _287 = _330;
    goto _jump473;
    _jump446:;
    _a3_double _331;
    // Computing bound for o
    _331.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing bound for p
    _331.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing bound for q
    _331.d2 = c;
    if (c > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= h.d0;
    _332 *= f.d0;
    _332 *= c;
    _332 *= sizeof(double);
    _331.data = jpl_alloc(_332);
    int64_t _333 = 0; // q
    int64_t _334 = 0; // p
    int64_t _335 = 0; // o
    _jump477:; // Begin body of loop
    double _336 = 72.0;
    int64_t _337 = 0;
    _337 *= _331.d0;
    _337 += _335;
    _337 *= _331.d1;
    _337 += _334;
    _337 *= _331.d2;
    _337 += _333;
    _331.data[_337] = _336;
    _333++;
    if (_333 < c)
    goto _jump477;
    _333 = 0;
    _334++;
    if (_334 < f.d0)
    goto _jump477;
    _334 = 0;
    _335++;
    if (_335 < h.d0)
    goto _jump477;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump478;
    fail_assertion("negative array index");
    _jump478:;
    if (h.d1 < _331.d0)
    goto _jump479;
    fail_assertion("index too large");
    _jump479:;
    if (c >= 0)
    goto _jump480;
    fail_assertion("negative array index");
    _jump480:;
    if (c < _331.d1)
    goto _jump481;
    fail_assertion("index too large");
    _jump481:;
    if (c >= 0)
    goto _jump482;
    fail_assertion("negative array index");
    _jump482:;
    if (c < _331.d2)
    goto _jump483;
    fail_assertion("index too large");
    _jump483:;
    int64_t _338 = 0;
    _338 *= _331.d0;
    _338 += h.d1;
    _338 *= _331.d1;
    _338 += c;
    _338 *= _331.d2;
    _338 += c;
    double _339 = _331.data[_338];
    double _340 = -_339;
    _a2_bool _341;
    // Computing bound for o
    _341.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing bound for p
    _341.d1 = d;
    if (d > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing total size of heap memory to allocate
    int64_t _342 = 1;
    _342 *= h.d0;
    _342 *= d;
    _342 *= sizeof(bool);
    _341.data = jpl_alloc(_342);
    int64_t _343 = 0; // p
    int64_t _344 = 0; // o
    _jump486:; // Begin body of loop
    int64_t _345 = 977;
    bool _346 = _2.d1 > _345;
    bool _347 = false;
    bool _348 = _346 != _347;
    int64_t _349 = 0;
    _349 *= _341.d0;
    _349 += _344;
    _349 *= _341.d1;
    _349 += _343;
    _341.data[_349] = _348;
    _343++;
    if (_343 < d)
    goto _jump486;
    _343 = 0;
    _344++;
    if (_344 < h.d0)
    goto _jump486;
    // End body of loop
    double _350 = a(_340, _341);
    bool _352 = true;
    bool _351 = _352;
    if (0 != _352)
    goto _jump487;
    bool _354 = h.d2 >= _2.d1;
    bool _353 = _354;
    if (0 != _354)
    goto _jump488;
    int64_t _355 = 497;
    bool _356 = _355 > f.d0;
    _353 = _356;
    _jump488:;
    _351 = _353;
    _jump487:;
    double _357;
    if (!_351)
    goto _jump489;
    double _358 = 8.0;
    _357 = _358;
    goto _jump490;
    _jump489:;
    if (h.d0 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (h.d0 < f.d0)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    int64_t _359 = 0;
    _359 *= f.d0;
    _359 += h.d0;
    rgba _360 = f.data[_359];
    double _361 = _360.a;
    double _362 = -_361;
    _357 = _362;
    _jump490:;
    double _363 = 47.0;
    _a2_bool _364;
    // Computing bound for o
    _364.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for p
    _364.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing total size of heap memory to allocate
    int64_t _365 = 1;
    _365 *= h.d0;
    _365 *= h.d0;
    _365 *= sizeof(bool);
    _364.data = jpl_alloc(_365);
    int64_t _366 = 0; // p
    int64_t _367 = 0; // o
    _jump495:; // Begin body of loop
    _a3_bool _368;
    // Computing bound for q
    _368.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing bound for r
    _368.d1 = d;
    if (d > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing bound for s
    _368.d2 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= h.d2;
    _369 *= d;
    _369 *= _2.d0;
    _369 *= sizeof(bool);
    _368.data = jpl_alloc(_369);
    int64_t _370 = 0; // s
    int64_t _371 = 0; // r
    int64_t _372 = 0; // q
    _jump499:; // Begin body of loop
    bool _373 = false;
    int64_t _374 = 0;
    _374 *= _368.d0;
    _374 += _372;
    _374 *= _368.d1;
    _374 += _371;
    _374 *= _368.d2;
    _374 += _370;
    _368.data[_374] = _373;
    _370++;
    if (_370 < _2.d0)
    goto _jump499;
    _370 = 0;
    _371++;
    if (_371 < d)
    goto _jump499;
    _371 = 0;
    _372++;
    if (_372 < h.d2)
    goto _jump499;
    // End body of loop
    int64_t _375 = 350;
    int64_t _376 = -h.d0;
    if (_375 >= 0)
    goto _jump500;
    fail_assertion("negative array index");
    _jump500:;
    if (_375 < _368.d0)
    goto _jump501;
    fail_assertion("index too large");
    _jump501:;
    if (_376 >= 0)
    goto _jump502;
    fail_assertion("negative array index");
    _jump502:;
    if (_376 < _368.d1)
    goto _jump503;
    fail_assertion("index too large");
    _jump503:;
    if (d >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (d < _368.d2)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    int64_t _377 = 0;
    _377 *= _368.d0;
    _377 += _375;
    _377 *= _368.d1;
    _377 += _376;
    _377 *= _368.d2;
    _377 += d;
    bool _378 = _368.data[_377];
    int64_t _379 = 0;
    _379 *= _364.d0;
    _379 += _367;
    _379 *= _364.d1;
    _379 += _366;
    _364.data[_379] = _378;
    _366++;
    if (_366 < h.d0)
    goto _jump495;
    _366 = 0;
    _367++;
    if (_367 < h.d0)
    goto _jump495;
    // End body of loop
    double _380 = a(_363, _364);
    double _381;
    // Computing bound for o
    bool _382 = true;
    int64_t _383;
    if (!_382)
    goto _jump506;
    _383 = _2.d1;
    goto _jump507;
    _jump506:;
    _383 = h.d0;
    _jump507:;
    if (_383 > 0) 
    goto _jump508;
    fail_assertion("non-positive loop bound");
    _jump508:;
    _381 = 0;
    int64_t _384 = 0; // o
    _jump509:; // Begin body of loop
    double _385 = 14.0;
    _381 += _385;
    _384++;
    if (_384 < _383)
    goto _jump509;
    // End body of loop
    rgba _386 = { _350, _357, _380, _381 };
    double _387 = _386.b;
    _287 = _387;
    _jump473:;
    bool _388 = false;
    return _388;
    _a1_rgba _389;
    // Computing bound for p
    _389.d0 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing total size of heap memory to allocate
    int64_t _390 = 1;
    _390 *= _2.d0;
    _390 *= sizeof(rgba);
    _389.data = jpl_alloc(_390);
    int64_t _391 = 0; // p
    _jump511:; // Begin body of loop
    double _392 = 4.0;
    rgba _393 = { _287, _392, _287, _287 };
    int64_t _394 = 0;
    _394 *= _389.d0;
    _394 += _391;
    _389.data[_394] = _393;
    _391++;
    if (_391 < _2.d0)
    goto _jump511;
    // End body of loop
    _a3_rgba _395;
    // Computing bound for p
    _395.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump512;
    fail_assertion("non-positive loop bound");
    _jump512:;
    // Computing bound for q
    _395.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing bound for r
    bool _396 = true;
    int64_t _397;
    if (!_396)
    goto _jump514;
    _397 = f.d0;
    goto _jump515;
    _jump514:;
    _397 = c;
    _jump515:;
    _395.d2 = _397;
    if (_397 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing total size of heap memory to allocate
    int64_t _398 = 1;
    _398 *= f.d0;
    _398 *= h.d0;
    _398 *= _397;
    _398 *= sizeof(rgba);
    _395.data = jpl_alloc(_398);
    int64_t _399 = 0; // r
    int64_t _400 = 0; // q
    int64_t _401 = 0; // p
    _jump517:; // Begin body of loop
    if (h.d2 >= 0)
    goto _jump518;
    fail_assertion("negative array index");
    _jump518:;
    if (h.d2 < f.d0)
    goto _jump519;
    fail_assertion("index too large");
    _jump519:;
    int64_t _402 = 0;
    _402 *= f.d0;
    _402 += h.d2;
    rgba _403 = f.data[_402];
    int64_t _404 = 0;
    _404 *= _395.d0;
    _404 += _401;
    _404 *= _395.d1;
    _404 += _400;
    _404 *= _395.d2;
    _404 += _399;
    _395.data[_404] = _403;
    _399++;
    if (_399 < _397)
    goto _jump517;
    _399 = 0;
    _400++;
    if (_400 < h.d0)
    goto _jump517;
    _400 = 0;
    _401++;
    if (_401 < f.d0)
    goto _jump517;
    // End body of loop
    bool _405 = false;
    bool _406 = !_405;
    _a3_rgba _407;
    if (!_406)
    goto _jump520;
    _407 = h;
    goto _jump521;
    _jump520:;
    _407 = h;
    _jump521:;
    _a1__a3_rgba _408;
    _408.d0 = 2;
    _408.data = jpl_alloc(sizeof(_a3_rgba) * 2);
    _408.data[0] = _395;
    _408.data[1] = _407;
    if (h.d1 >= 0)
    goto _jump522;
    fail_assertion("negative array index");
    _jump522:;
    if (h.d1 < _408.d0)
    goto _jump523;
    fail_assertion("index too large");
    _jump523:;
    int64_t _409 = 0;
    _409 *= _408.d0;
    _409 += h.d1;
    _a3_rgba _410 = _408.data[_409];
    bool _411 = e(_389, _410);
    double _412;
    if (!_411)
    goto _jump524;
    _a3_double _413;
    // Computing bound for p
    _413.d0 = d;
    if (d > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    // Computing bound for q
    _413.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump526;
    fail_assertion("non-positive loop bound");
    _jump526:;
    // Computing bound for r
    _413.d2 = d;
    if (d > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing total size of heap memory to allocate
    int64_t _414 = 1;
    _414 *= d;
    _414 *= h.d0;
    _414 *= d;
    _414 *= sizeof(double);
    _413.data = jpl_alloc(_414);
    int64_t _415 = 0; // r
    int64_t _416 = 0; // q
    int64_t _417 = 0; // p
    _jump528:; // Begin body of loop
    double _418 = 92.0;
    int64_t _419 = 0;
    _419 *= _413.d0;
    _419 += _417;
    _419 *= _413.d1;
    _419 += _416;
    _419 *= _413.d2;
    _419 += _415;
    _413.data[_419] = _418;
    _415++;
    if (_415 < d)
    goto _jump528;
    _415 = 0;
    _416++;
    if (_416 < h.d0)
    goto _jump528;
    _416 = 0;
    _417++;
    if (_417 < d)
    goto _jump528;
    // End body of loop
    _a1__a3_double _420;
    _420.d0 = 1;
    _420.data = jpl_alloc(sizeof(_a3_double) * 1);
    _420.data[0] = _413;
    if (h.d1 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (h.d1 < _420.d0)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    int64_t _421 = 0;
    _421 *= _420.d0;
    _421 += h.d1;
    _a3_double _422 = _420.data[_421];
    int64_t _423 = 385;
    _a3_int64_t _424;
    // Computing bound for p
    _424.d0 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump531;
    fail_assertion("non-positive loop bound");
    _jump531:;
    // Computing bound for q
    int64_t _425 = -d;
    _424.d1 = _425;
    if (_425 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing bound for r
    _424.d2 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing total size of heap memory to allocate
    int64_t _426 = 1;
    _426 *= _2.d0;
    _426 *= _425;
    _426 *= _2.d1;
    _426 *= sizeof(int64_t);
    _424.data = jpl_alloc(_426);
    int64_t _427 = 0; // r
    int64_t _428 = 0; // q
    int64_t _429 = 0; // p
    _jump534:; // Begin body of loop
    int64_t _430 = 0;
    _430 *= _424.d0;
    _430 += _429;
    _430 *= _424.d1;
    _430 += _428;
    _430 *= _424.d2;
    _430 += _427;
    _424.data[_430] = c;
    _427++;
    if (_427 < _2.d1)
    goto _jump534;
    _427 = 0;
    _428++;
    if (_428 < _425)
    goto _jump534;
    _428 = 0;
    _429++;
    if (_429 < _2.d0)
    goto _jump534;
    // End body of loop
    int64_t _431 = 224;
    int64_t _432 = -_431;
    bool _433 = false;
    int64_t _434;
    if (!_433)
    goto _jump535;
    _434 = d;
    goto _jump536;
    _jump535:;
    _434 = _2.d0;
    _jump536:;
    int64_t _435 = _434 + h.d0;
    if (_432 >= 0)
    goto _jump537;
    fail_assertion("negative array index");
    _jump537:;
    if (_432 < _424.d0)
    goto _jump538;
    fail_assertion("index too large");
    _jump538:;
    if (h.d2 >= 0)
    goto _jump539;
    fail_assertion("negative array index");
    _jump539:;
    if (h.d2 < _424.d1)
    goto _jump540;
    fail_assertion("index too large");
    _jump540:;
    if (_435 >= 0)
    goto _jump541;
    fail_assertion("negative array index");
    _jump541:;
    if (_435 < _424.d2)
    goto _jump542;
    fail_assertion("index too large");
    _jump542:;
    int64_t _436 = 0;
    _436 *= _424.d0;
    _436 += _432;
    _436 *= _424.d1;
    _436 += h.d2;
    _436 *= _424.d2;
    _436 += _435;
    int64_t _437 = _424.data[_436];
    if (_2.d1 >= 0)
    goto _jump543;
    fail_assertion("negative array index");
    _jump543:;
    if (_2.d1 < _422.d0)
    goto _jump544;
    fail_assertion("index too large");
    _jump544:;
    if (_423 >= 0)
    goto _jump545;
    fail_assertion("negative array index");
    _jump545:;
    if (_423 < _422.d1)
    goto _jump546;
    fail_assertion("index too large");
    _jump546:;
    if (_437 >= 0)
    goto _jump547;
    fail_assertion("negative array index");
    _jump547:;
    if (_437 < _422.d2)
    goto _jump548;
    fail_assertion("index too large");
    _jump548:;
    int64_t _438 = 0;
    _438 *= _422.d0;
    _438 += _2.d1;
    _438 *= _422.d1;
    _438 += _423;
    _438 *= _422.d2;
    _438 += _437;
    double _439 = _422.data[_438];
    _a2_bool _440;
    // Computing bound for p
    _440.d0 = c;
    if (c > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    // Computing bound for q
    int64_t _441 = -h.d1;
    int64_t _442 = -_441;
    _440.d1 = _442;
    if (_442 > 0) 
    goto _jump550;
    fail_assertion("non-positive loop bound");
    _jump550:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= c;
    _443 *= _442;
    _443 *= sizeof(bool);
    _440.data = jpl_alloc(_443);
    int64_t _444 = 0; // q
    int64_t _445 = 0; // p
    _jump551:; // Begin body of loop
    double _446 = 1.0;
    double _447;
    // Computing bound for r
    if (_444 > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    // Computing bound for s
    int64_t _448 = 347;
    if (_448 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for t
    if (h.d0 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    _447 = 0;
    int64_t _449 = 0; // t
    int64_t _450 = 0; // s
    int64_t _451 = 0; // r
    _jump555:; // Begin body of loop
    double _452 = 76.0;
    _447 += _452;
    _449++;
    if (_449 < h.d0)
    goto _jump555;
    _449 = 0;
    _450++;
    if (_450 < _448)
    goto _jump555;
    _450 = 0;
    _451++;
    if (_451 < _444)
    goto _jump555;
    // End body of loop
    double _453 = _446 + _447;
    bool _454 = _287 <= _453;
    int64_t _455 = 0;
    _455 *= _440.d0;
    _455 += _445;
    _455 *= _440.d1;
    _455 += _444;
    _440.data[_455] = _454;
    _444++;
    if (_444 < _442)
    goto _jump551;
    _444 = 0;
    _445++;
    if (_445 < c)
    goto _jump551;
    // End body of loop
    double _456 = a(_439, _440);
    _412 = _456;
    goto _jump556;
    _jump524:;
    double _457 = 20.0;
    double _458 = -_457;
    _412 = _458;
    _jump556:;
    double _459 = 34.0;
    bool _460 = _412 <= _459;
    _a1_double _461;
    // Computing bound for q
    _461.d0 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing total size of heap memory to allocate
    int64_t _462 = 1;
    _462 *= _2.d1;
    _462 *= sizeof(double);
    _461.data = jpl_alloc(_462);
    int64_t _463 = 0; // q
    _jump558:; // Begin body of loop
    bool _464 = f.d0 == h.d1;
    rgba _465;
    if (!_464)
    goto _jump559;
    bool _467 = false;
    double _468;
    if (!_467)
    goto _jump560;
    _468 = _287;
    goto _jump561;
    _jump560:;
    double _469 = 66.0;
    _468 = _469;
    _jump561:;
    bool _470 = _287 > _468;
    bool _466 = _470;
    if (0 != _470)
    goto _jump562;
    _466 = _460;
    _jump562:;
    rgba _471;
    if (!_466)
    goto _jump563;
    double _472 = 22.0;
    _a1_double _473;
    // Computing bound for r
    _473.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing total size of heap memory to allocate
    int64_t _474 = 1;
    _474 *= h.d0;
    _474 *= sizeof(double);
    _473.data = jpl_alloc(_474);
    int64_t _475 = 0; // r
    _jump565:; // Begin body of loop
    double _476 = 4.0;
    int64_t _477 = 0;
    _477 *= _473.d0;
    _477 += _475;
    _473.data[_477] = _476;
    _475++;
    if (_475 < h.d0)
    goto _jump565;
    // End body of loop
    if (_2.d1 >= 0)
    goto _jump566;
    fail_assertion("negative array index");
    _jump566:;
    if (_2.d1 < _473.d0)
    goto _jump567;
    fail_assertion("index too large");
    _jump567:;
    int64_t _478 = 0;
    _478 *= _473.d0;
    _478 += _2.d1;
    double _479 = _473.data[_478];
    rgba _480 = { _472, _479, _287, _287 };
    _471 = _480;
    goto _jump568;
    _jump563:;
    _a2_rgba _481;
    // Computing bound for r
    int64_t _482 = _2.d0 * f.d0;
    _481.d0 = _482;
    if (_482 > 0) 
    goto _jump569;
    fail_assertion("non-positive loop bound");
    _jump569:;
    // Computing bound for s
    _481.d1 = d;
    if (d > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing total size of heap memory to allocate
    int64_t _483 = 1;
    _483 *= _482;
    _483 *= d;
    _483 *= sizeof(rgba);
    _481.data = jpl_alloc(_483);
    int64_t _484 = 0; // s
    int64_t _485 = 0; // r
    _jump571:; // Begin body of loop
    if (h.d2 >= 0)
    goto _jump572;
    fail_assertion("negative array index");
    _jump572:;
    if (h.d2 < f.d0)
    goto _jump573;
    fail_assertion("index too large");
    _jump573:;
    int64_t _486 = 0;
    _486 *= f.d0;
    _486 += h.d2;
    rgba _487 = f.data[_486];
    int64_t _488 = 0;
    _488 *= _481.d0;
    _488 += _485;
    _488 *= _481.d1;
    _488 += _484;
    _481.data[_488] = _487;
    _484++;
    if (_484 < d)
    goto _jump571;
    _484 = 0;
    _485++;
    if (_485 < _482)
    goto _jump571;
    // End body of loop
    bool _489 = true;
    bool _490 = !_489;
    int64_t _491;
    if (!_490)
    goto _jump574;
    _491 = c;
    goto _jump575;
    _jump574:;
    _491 = c;
    _jump575:;
    if (c >= 0)
    goto _jump576;
    fail_assertion("negative array index");
    _jump576:;
    if (c < _481.d0)
    goto _jump577;
    fail_assertion("index too large");
    _jump577:;
    if (_491 >= 0)
    goto _jump578;
    fail_assertion("negative array index");
    _jump578:;
    if (_491 < _481.d1)
    goto _jump579;
    fail_assertion("index too large");
    _jump579:;
    int64_t _492 = 0;
    _492 *= _481.d0;
    _492 += c;
    _492 *= _481.d1;
    _492 += _491;
    rgba _493 = _481.data[_492];
    _471 = _493;
    _jump568:;
    _465 = _471;
    goto _jump580;
    _jump559:;
    double _494;
    // Computing bound for r
    int64_t _495 = h.d2 % _463;
    if (_495 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing bound for s
    if (c > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    // Computing bound for t
    if (d > 0) 
    goto _jump583;
    fail_assertion("non-positive loop bound");
    _jump583:;
    _494 = 0;
    int64_t _496 = 0; // t
    int64_t _497 = 0; // s
    int64_t _498 = 0; // r
    _jump584:; // Begin body of loop
    double _499 = 72.0;
    _494 += _499;
    _496++;
    if (_496 < d)
    goto _jump584;
    _496 = 0;
    _497++;
    if (_497 < c)
    goto _jump584;
    _497 = 0;
    _498++;
    if (_498 < _495)
    goto _jump584;
    // End body of loop
    _a2_bool _500;
    // Computing bound for r
    int64_t _501;
    // Computing bound for r
    int64_t _502 = 789;
    if (_502 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing bound for s
    if (h.d2 > 0) 
    goto _jump586;
    fail_assertion("non-positive loop bound");
    _jump586:;
    _501 = 0;
    int64_t _503 = 0; // s
    int64_t _504 = 0; // r
    _jump587:; // Begin body of loop
    _501 += d;
    _503++;
    if (_503 < h.d2)
    goto _jump587;
    _503 = 0;
    _504++;
    if (_504 < _502)
    goto _jump587;
    // End body of loop
    _500.d0 = _501;
    if (_501 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing bound for s
    _500.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing total size of heap memory to allocate
    int64_t _505 = 1;
    _505 *= _501;
    _505 *= f.d0;
    _505 *= sizeof(bool);
    _500.data = jpl_alloc(_505);
    int64_t _506 = 0; // s
    int64_t _507 = 0; // r
    _jump590:; // Begin body of loop
    bool _508 = true;
    int64_t _509 = 0;
    _509 *= _500.d0;
    _509 += _507;
    _509 *= _500.d1;
    _509 += _506;
    _500.data[_509] = _508;
    _506++;
    if (_506 < f.d0)
    goto _jump590;
    _506 = 0;
    _507++;
    if (_507 < _501)
    goto _jump590;
    // End body of loop
    double _510 = a(_494, _500);
    double _511 = 7.0;
    bool _512 = false;
    bool _513;
    if (!_512)
    goto _jump591;
    _513 = _460;
    goto _jump592;
    _jump591:;
    _513 = _460;
    _jump592:;
    bool _514;
    if (!_513)
    goto _jump593;
    bool _515 = false;
    bool _516;
    if (!_515)
    goto _jump594;
    _516 = _460;
    goto _jump595;
    _jump594:;
    bool _517 = false;
    _516 = _517;
    _jump595:;
    _514 = _516;
    goto _jump596;
    _jump593:;
    bool _518 = true;
    bool _519 = !_518;
    _514 = _519;
    _jump596:;
    double _520;
    if (!_514)
    goto _jump597;
    double _521 = -_287;
    _520 = _521;
    goto _jump598;
    _jump597:;
    bool _522 = c > _2.d0;
    double _523;
    if (!_522)
    goto _jump599;
    _523 = _287;
    goto _jump600;
    _jump599:;
    double _524 = 94.0;
    _523 = _524;
    _jump600:;
    _520 = _523;
    _jump598:;
    bool _525 = false;
    double _526;
    if (!_525)
    goto _jump601;
    if (_2.d0 >= 0)
    goto _jump602;
    fail_assertion("negative array index");
    _jump602:;
    if (_2.d0 < h.d0)
    goto _jump603;
    fail_assertion("index too large");
    _jump603:;
    if (h.d2 >= 0)
    goto _jump604;
    fail_assertion("negative array index");
    _jump604:;
    if (h.d2 < h.d1)
    goto _jump605;
    fail_assertion("index too large");
    _jump605:;
    if (h.d0 >= 0)
    goto _jump606;
    fail_assertion("negative array index");
    _jump606:;
    if (h.d0 < h.d2)
    goto _jump607;
    fail_assertion("index too large");
    _jump607:;
    int64_t _527 = 0;
    _527 *= h.d0;
    _527 += _2.d0;
    _527 *= h.d1;
    _527 += h.d2;
    _527 *= h.d2;
    _527 += h.d0;
    rgba _528 = h.data[_527];
    double _529 = _528.a;
    _526 = _529;
    goto _jump608;
    _jump601:;
    _a1_double _530;
    _530.d0 = 1;
    _530.data = jpl_alloc(sizeof(double) * 1);
    _530.data[0] = _287;
    if (_463 >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (_463 < _530.d0)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _531 = 0;
    _531 *= _530.d0;
    _531 += _463;
    double _532 = _530.data[_531];
    _526 = _532;
    _jump608:;
    rgba _533 = { _510, _511, _520, _526 };
    _465 = _533;
    _jump580:;
    double _534 = _465.g;
    int64_t _535 = 0;
    _535 *= _461.d0;
    _535 += _463;
    _461.data[_535] = _534;
    _463++;
    if (_463 < _2.d1)
    goto _jump558;
    // End body of loop
    _a1__a3_rgba _536;
    // Computing bound for r
    _536.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing total size of heap memory to allocate
    int64_t _537 = 1;
    _537 *= h.d2;
    _537 *= sizeof(_a3_rgba);
    _536.data = jpl_alloc(_537);
    int64_t _538 = 0; // r
    _jump612:; // Begin body of loop
    int64_t _539 = 0;
    _539 *= _536.d0;
    _539 += _538;
    _536.data[_539] = h;
    _538++;
    if (_538 < h.d2)
    goto _jump612;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (h.d1 < _536.d0)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    int64_t _540 = 0;
    _540 *= _536.d0;
    _540 += h.d1;
    _a3_rgba _541 = _536.data[_540];
    _a1_rgba _543;
    // Computing bound for v
    _543.d0 = _541.d0;
    if (_541.d0 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing total size of heap memory to allocate
    int64_t _544 = 1;
    _544 *= _541.d0;
    _544 *= sizeof(rgba);
    _543.data = jpl_alloc(_544);
    int64_t _545 = 0; // v
    _jump616:; // Begin body of loop
    bool _546 = false;
    bool _547;
    if (!_546)
    goto _jump617;
    int64_t _548 = 457;
    bool _549 = _2.d0 != _548;
    _547 = _549;
    goto _jump618;
    _jump617:;
    bool _550 = _460;
    if (0 == _460)
    goto _jump619;
    _550 = _460;
    _jump619:;
    _547 = _550;
    _jump618:;
    double _551;
    if (!_547)
    goto _jump620;
    double _552 = 89.0;
    _551 = _552;
    goto _jump621;
    _jump620:;
    if (_2.d0 >= 0)
    goto _jump622;
    fail_assertion("negative array index");
    _jump622:;
    if (_2.d0 < _541.d0)
    goto _jump623;
    fail_assertion("index too large");
    _jump623:;
    if (h.d1 >= 0)
    goto _jump624;
    fail_assertion("negative array index");
    _jump624:;
    if (h.d1 < _541.d1)
    goto _jump625;
    fail_assertion("index too large");
    _jump625:;
    if (d >= 0)
    goto _jump626;
    fail_assertion("negative array index");
    _jump626:;
    if (d < _541.d2)
    goto _jump627;
    fail_assertion("index too large");
    _jump627:;
    int64_t _553 = 0;
    _553 *= _541.d0;
    _553 += _2.d0;
    _553 *= _541.d1;
    _553 += h.d1;
    _553 *= _541.d2;
    _553 += d;
    rgba _554 = _541.data[_553];
    double _555 = _554.b;
    _551 = _555;
    _jump621:;
    double _556 = -_287;
    _a2_bool _557;
    // Computing bound for w
    _557.d0 = d;
    if (d > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    // Computing bound for x
    _557.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    // Computing total size of heap memory to allocate
    int64_t _558 = 1;
    _558 *= d;
    _558 *= f.d0;
    _558 *= sizeof(bool);
    _557.data = jpl_alloc(_558);
    int64_t _559 = 0; // x
    int64_t _560 = 0; // w
    _jump630:; // Begin body of loop
    bool _562 = true;
    bool _561 = _562;
    if (0 != _562)
    goto _jump631;
    bool _563 = true;
    _561 = _563;
    _jump631:;
    int64_t _564 = 0;
    _564 *= _557.d0;
    _564 += _560;
    _564 *= _557.d1;
    _564 += _559;
    _557.data[_564] = _561;
    _559++;
    if (_559 < f.d0)
    goto _jump630;
    _559 = 0;
    _560++;
    if (_560 < d)
    goto _jump630;
    // End body of loop
    double _565 = a(_556, _557);
    rgba _566 = { _287, _551, _287, _565 };
    int64_t _567 = 0;
    _567 *= _543.d0;
    _567 += _545;
    _543.data[_567] = _566;
    _545++;
    if (_545 < _541.d0)
    goto _jump616;
    // End body of loop
    _a2__a3_rgba _568;
    // Computing bound for v
    _568.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for w
    _568.d1 = _541.d0;
    if (_541.d0 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing total size of heap memory to allocate
    int64_t _569 = 1;
    _569 *= f.d0;
    _569 *= _541.d0;
    _569 *= sizeof(_a3_rgba);
    _568.data = jpl_alloc(_569);
    int64_t _570 = 0; // w
    int64_t _571 = 0; // v
    _jump634:; // Begin body of loop
    _a3_rgba _572;
    // Computing bound for x
    _572.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    // Computing bound for y
    int64_t _573 = _2.d1 - _541.d0;
    _572.d1 = _573;
    if (_573 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for z
    _572.d2 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing total size of heap memory to allocate
    int64_t _574 = 1;
    _574 *= f.d0;
    _574 *= _573;
    _574 *= _2.d0;
    _574 *= sizeof(rgba);
    _572.data = jpl_alloc(_574);
    int64_t _575 = 0; // z
    int64_t _576 = 0; // y
    int64_t _577 = 0; // x
    _jump638:; // Begin body of loop
    if (_2.d1 >= 0)
    goto _jump639;
    fail_assertion("negative array index");
    _jump639:;
    if (_2.d1 < _541.d0)
    goto _jump640;
    fail_assertion("index too large");
    _jump640:;
    if (h.d1 >= 0)
    goto _jump641;
    fail_assertion("negative array index");
    _jump641:;
    if (h.d1 < _541.d1)
    goto _jump642;
    fail_assertion("index too large");
    _jump642:;
    if (_575 >= 0)
    goto _jump643;
    fail_assertion("negative array index");
    _jump643:;
    if (_575 < _541.d2)
    goto _jump644;
    fail_assertion("index too large");
    _jump644:;
    int64_t _578 = 0;
    _578 *= _541.d0;
    _578 += _2.d1;
    _578 *= _541.d1;
    _578 += h.d1;
    _578 *= _541.d2;
    _578 += _575;
    rgba _579 = _541.data[_578];
    int64_t _580 = 0;
    _580 *= _572.d0;
    _580 += _577;
    _580 *= _572.d1;
    _580 += _576;
    _580 *= _572.d2;
    _580 += _575;
    _572.data[_580] = _579;
    _575++;
    if (_575 < _2.d0)
    goto _jump638;
    _575 = 0;
    _576++;
    if (_576 < _573)
    goto _jump638;
    _576 = 0;
    _577++;
    if (_577 < f.d0)
    goto _jump638;
    // End body of loop
    int64_t _581 = 0;
    _581 *= _568.d0;
    _581 += _571;
    _581 *= _568.d1;
    _581 += _570;
    _568.data[_581] = _572;
    _570++;
    if (_570 < _541.d0)
    goto _jump634;
    _570 = 0;
    _571++;
    if (_571 < f.d0)
    goto _jump634;
    // End body of loop
    bool _582 = true;
    bool _583 = !_582;
    int64_t _584;
    if (!_583)
    goto _jump645;
    _584 = _2.d1;
    goto _jump646;
    _jump645:;
    _584 = _541.d2;
    _jump646:;
    if (h.d2 >= 0)
    goto _jump647;
    fail_assertion("negative array index");
    _jump647:;
    if (h.d2 < _568.d0)
    goto _jump648;
    fail_assertion("index too large");
    _jump648:;
    if (_584 >= 0)
    goto _jump649;
    fail_assertion("negative array index");
    _jump649:;
    if (_584 < _568.d1)
    goto _jump650;
    fail_assertion("index too large");
    _jump650:;
    int64_t _585 = 0;
    _585 *= _568.d0;
    _585 += h.d2;
    _585 *= _568.d1;
    _585 += _584;
    _a3_rgba _586 = _568.data[_585];
    bool _587 = e(_543, _586);
    bool _542 = _587;
    if (0 == _587)
    goto _jump651;
    bool _588 = false;
    _542 = _588;
    _jump651:;
    return _542;
}

void_t z(_a2_rgba A) {
    _a2__a2_int64_t _0;
    // Computing bound for D
    _0.d0 = d;
    if (d > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    // Computing bound for E
    _0.d1 = u;
    if (u > 0) 
    goto _jump1162;
    fail_assertion("non-positive loop bound");
    _jump1162:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= d;
    _1 *= u;
    _1 *= sizeof(_a2_int64_t);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // E
    int64_t _3 = 0; // D
    _jump1163:; // Begin body of loop
    _a2_int64_t _4;
    // Computing bound for F
    _4.d0 = n;
    if (n > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    // Computing bound for G
    _4.d1 = u;
    if (u > 0) 
    goto _jump1165;
    fail_assertion("non-positive loop bound");
    _jump1165:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= n;
    _5 *= u;
    _5 *= sizeof(int64_t);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // G
    int64_t _7 = 0; // F
    _jump1166:; // Begin body of loop
    int64_t _8 = 0;
    _8 *= _4.d0;
    _8 += _7;
    _8 *= _4.d1;
    _8 += _6;
    _4.data[_8] = A.d1;
    _6++;
    if (_6 < u)
    goto _jump1166;
    _6 = 0;
    _7++;
    if (_7 < n)
    goto _jump1166;
    // End body of loop
    int64_t _9 = 0;
    _9 *= _0.d0;
    _9 += _3;
    _9 *= _0.d1;
    _9 += _2;
    _0.data[_9] = _4;
    _2++;
    if (_2 < u)
    goto _jump1163;
    _2 = 0;
    _3++;
    if (_3 < d)
    goto _jump1163;
    // End body of loop
    if (A.d1 >= 0)
    goto _jump1167;
    fail_assertion("negative array index");
    _jump1167:;
    if (A.d1 < _0.d0)
    goto _jump1168;
    fail_assertion("index too large");
    _jump1168:;
    if (g >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (g < _0.d1)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    int64_t _10 = 0;
    _10 *= _0.d0;
    _10 += A.d1;
    _10 *= _0.d1;
    _10 += g;
    _a2_int64_t _11 = _0.data[_10];
    _a1_bool _12;
    // Computing bound for J
    _12.d0 = y;
    if (y > 0) 
    goto _jump1171;
    fail_assertion("non-positive loop bound");
    _jump1171:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= y;
    _13 *= sizeof(bool);
    _12.data = jpl_alloc(_13);
    int64_t _14 = 0; // J
    _jump1172:; // Begin body of loop
    bool _15 = g < _11.d1;
    int64_t _16 = 0;
    _16 *= _12.d0;
    _16 += _14;
    _12.data[_16] = _15;
    _14++;
    if (_14 < y)
    goto _jump1172;
    // End body of loop
    _a3_int64_t _17;
    if (!r)
    goto _jump1173;
    _17 = i;
    goto _jump1174;
    _jump1173:;
    _17 = i;
    _jump1174:;
    void_t _18 = {};
    return _18;
}

bool G() {
    _a1_int64_t _0;
    _0.d0 = 2;
    _0.data = jpl_alloc(sizeof(int64_t) * 2);
    _0.data[0] = j;
    _0.data[1] = u;
    _a1__a1_int64_t _1;
    _1.d0 = 2;
    _1.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _1.data[0] = A;
    _1.data[1] = _0;
    _a3__a2__a1_int64_t _2;
    // Computing bound for I
    _2.d0 = s;
    if (s > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing bound for J
    int64_t _3;
    // Computing bound for I
    int64_t _4;
    // Computing bound for I
    if (h > 0) 
    goto _jump1178;
    fail_assertion("non-positive loop bound");
    _jump1178:;
    _4 = 0;
    int64_t _5 = 0; // I
    _jump1179:; // Begin body of loop
    _4 += k;
    _5++;
    if (_5 < h)
    goto _jump1179;
    // End body of loop
    if (_4 > 0) 
    goto _jump1180;
    fail_assertion("non-positive loop bound");
    _jump1180:;
    // Computing bound for J
    int64_t _6 = 82;
    if (_6 > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    _3 = 0;
    int64_t _7 = 0; // J
    int64_t _8 = 0; // I
    _jump1182:; // Begin body of loop
    _3 += B;
    _7++;
    if (_7 < _6)
    goto _jump1182;
    _7 = 0;
    _8++;
    if (_8 < _4)
    goto _jump1182;
    // End body of loop
    _2.d1 = _3;
    if (_3 > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    // Computing bound for K
    _2.d2 = E;
    if (E > 0) 
    goto _jump1184;
    fail_assertion("non-positive loop bound");
    _jump1184:;
    // Computing total size of heap memory to allocate
    int64_t _9 = 1;
    _9 *= s;
    _9 *= _3;
    _9 *= E;
    _9 *= sizeof(_a2__a1_int64_t);
    _2.data = jpl_alloc(_9);
    int64_t _10 = 0; // K
    int64_t _11 = 0; // J
    int64_t _12 = 0; // I
    _jump1185:; // Begin body of loop
    int64_t _13 = 0;
    _13 *= _2.d0;
    _13 += _12;
    _13 *= _2.d1;
    _13 += _11;
    _13 *= _2.d2;
    _13 += _10;
    _2.data[_13] = b;
    _10++;
    if (_10 < E)
    goto _jump1185;
    _10 = 0;
    _11++;
    if (_11 < _3)
    goto _jump1185;
    _11 = 0;
    _12++;
    if (_12 < s)
    goto _jump1185;
    // End body of loop
    if (y >= 0)
    goto _jump1186;
    fail_assertion("negative array index");
    _jump1186:;
    if (y < A.d0)
    goto _jump1187;
    fail_assertion("index too large");
    _jump1187:;
    int64_t _14 = 0;
    _14 *= A.d0;
    _14 += y;
    int64_t _15 = A.data[_14];
    if (v >= 0)
    goto _jump1188;
    fail_assertion("negative array index");
    _jump1188:;
    if (v < _2.d0)
    goto _jump1189;
    fail_assertion("index too large");
    _jump1189:;
    if (g >= 0)
    goto _jump1190;
    fail_assertion("negative array index");
    _jump1190:;
    if (g < _2.d1)
    goto _jump1191;
    fail_assertion("index too large");
    _jump1191:;
    if (_15 >= 0)
    goto _jump1192;
    fail_assertion("negative array index");
    _jump1192:;
    if (_15 < _2.d2)
    goto _jump1193;
    fail_assertion("index too large");
    _jump1193:;
    int64_t _16 = 0;
    _16 *= _2.d0;
    _16 += v;
    _16 *= _2.d1;
    _16 += g;
    _16 *= _2.d2;
    _16 += _15;
    _a2__a1_int64_t _17 = _2.data[_16];
    bool _18 = n != l;
    if (0 != _18)
    goto _jump1194;
    fail_assertion("L");
    _jump1194:;
    bool _19 = true;
    int64_t _20;
    // Computing bound for M
    if (s > 0) 
    goto _jump1195;
    fail_assertion("non-positive loop bound");
    _jump1195:;
    // Computing bound for N
    if (E > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for O
    int64_t _21 = 540;
    if (_21 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    _20 = 0;
    int64_t _22 = 0; // O
    int64_t _23 = 0; // N
    int64_t _24 = 0; // M
    _jump1198:; // Begin body of loop
    _20 += g;
    _22++;
    if (_22 < _21)
    goto _jump1198;
    _22 = 0;
    _23++;
    if (_23 < E)
    goto _jump1198;
    _23 = 0;
    _24++;
    if (_24 < s)
    goto _jump1198;
    // End body of loop
    if (_20 >= 0)
    goto _jump1199;
    fail_assertion("negative array index");
    _jump1199:;
    if (_20 < m.d0)
    goto _jump1200;
    fail_assertion("index too large");
    _jump1200:;
    int64_t _25 = 0;
    _25 *= m.d0;
    _25 += _20;
    bool _26 = m.data[_25];
    _a2__a3_int64_t _27;
    if (!_26)
    goto _jump1201;
    _a2__a3_int64_t _28;
    // Computing bound for M
    _28.d0 = y;
    if (y > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for N
    _28.d1 = g;
    if (g > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= y;
    _29 *= g;
    _29 *= sizeof(_a3_int64_t);
    _28.data = jpl_alloc(_29);
    int64_t _30 = 0; // N
    int64_t _31 = 0; // M
    _jump1204:; // Begin body of loop
    if (v >= 0)
    goto _jump1205;
    fail_assertion("negative array index");
    _jump1205:;
    if (v < x.d0)
    goto _jump1206;
    fail_assertion("index too large");
    _jump1206:;
    int64_t _32 = 0;
    _32 *= x.d0;
    _32 += v;
    _a3_int64_t _33 = x.data[_32];
    int64_t _34 = 0;
    _34 *= _28.d0;
    _34 += _31;
    _34 *= _28.d1;
    _34 += _30;
    _28.data[_34] = _33;
    _30++;
    if (_30 < g)
    goto _jump1204;
    _30 = 0;
    _31++;
    if (_31 < y)
    goto _jump1204;
    // End body of loop
    _27 = _28;
    goto _jump1207;
    _jump1201:;
    double _35;
    // Computing bound for M
    if (D > 0) 
    goto _jump1208;
    fail_assertion("non-positive loop bound");
    _jump1208:;
    _35 = 0;
    int64_t _36 = 0; // M
    _jump1209:; // Begin body of loop
    double _37;
    // Computing bound for N
    if (B > 0) 
    goto _jump1210;
    fail_assertion("non-positive loop bound");
    _jump1210:;
    // Computing bound for O
    if (q > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    _37 = 0;
    int64_t _38 = 0; // O
    int64_t _39 = 0; // N
    _jump1212:; // Begin body of loop
    double _40 = 99.0;
    _37 += _40;
    _38++;
    if (_38 < q)
    goto _jump1212;
    _38 = 0;
    _39++;
    if (_39 < B)
    goto _jump1212;
    // End body of loop
    _35 += _37;
    _36++;
    if (_36 < D)
    goto _jump1209;
    // End body of loop
    double _41;
    // Computing bound for M
    int64_t _42 = 433;
    if (_42 > 0) 
    goto _jump1213;
    fail_assertion("non-positive loop bound");
    _jump1213:;
    // Computing bound for N
    int64_t _43;
    // Computing bound for M
    if (u > 0) 
    goto _jump1214;
    fail_assertion("non-positive loop bound");
    _jump1214:;
    // Computing bound for N
    if (_17.d0 > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    _43 = 0;
    int64_t _44 = 0; // N
    int64_t _45 = 0; // M
    _jump1216:; // Begin body of loop
    _43 += q;
    _44++;
    if (_44 < _17.d0)
    goto _jump1216;
    _44 = 0;
    _45++;
    if (_45 < u)
    goto _jump1216;
    // End body of loop
    if (_43 > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    _41 = 0;
    int64_t _46 = 0; // N
    int64_t _47 = 0; // M
    _jump1218:; // Begin body of loop
    double _48 = 54.0;
    double _49 = 50.0;
    double _50 = _48 + _49;
    _41 += _50;
    _46++;
    if (_46 < _43)
    goto _jump1218;
    _46 = 0;
    _47++;
    if (_47 < _42)
    goto _jump1218;
    // End body of loop
    bool _51 = _35 < _41;
    bool _52;
    if (!_51)
    goto _jump1219;
    double _53 = 50.0;
    double _54;
    // Computing bound for M
    if (j > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing bound for N
    if (g > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing bound for O
    if (_17.d0 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    _54 = 0;
    int64_t _55 = 0; // O
    int64_t _56 = 0; // N
    int64_t _57 = 0; // M
    _jump1223:; // Begin body of loop
    double _58 = 98.0;
    _54 += _58;
    _55++;
    if (_55 < _17.d0)
    goto _jump1223;
    _55 = 0;
    _56++;
    if (_56 < g)
    goto _jump1223;
    _56 = 0;
    _57++;
    if (_57 < j)
    goto _jump1223;
    // End body of loop
    bool _59 = _53 <= _54;
    _52 = _59;
    goto _jump1224;
    _jump1219:;
    int64_t _60;
    if (!r)
    goto _jump1225;
    _60 = k;
    goto _jump1226;
    _jump1225:;
    _60 = q;
    _jump1226:;
    int64_t _61 = -v;
    bool _62 = _60 >= _61;
    bool _63 = true;
    bool _64 = _62 != _63;
    _52 = _64;
    _jump1224:;
    _a2__a3_int64_t _65;
    if (!_52)
    goto _jump1227;
    _a3__a2__a3_int64_t _66;
    // Computing bound for M
    _66.d0 = l;
    if (l > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    // Computing bound for N
    int64_t _67 = 699;
    int64_t _68 = j + _67;
    _66.d1 = _68;
    if (_68 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    // Computing bound for O
    _66.d2 = g;
    if (g > 0) 
    goto _jump1230;
    fail_assertion("non-positive loop bound");
    _jump1230:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= l;
    _69 *= _68;
    _69 *= g;
    _69 *= sizeof(_a2__a3_int64_t);
    _66.data = jpl_alloc(_69);
    int64_t _70 = 0; // O
    int64_t _71 = 0; // N
    int64_t _72 = 0; // M
    _jump1231:; // Begin body of loop
    _a2__a3_int64_t _73;
    // Computing bound for P
    _73.d0 = _70;
    if (_70 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    // Computing bound for Q
    _73.d1 = j;
    if (j > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= _70;
    _74 *= j;
    _74 *= sizeof(_a3_int64_t);
    _73.data = jpl_alloc(_74);
    int64_t _75 = 0; // Q
    int64_t _76 = 0; // P
    _jump1234:; // Begin body of loop
    int64_t _77 = 0;
    _77 *= _73.d0;
    _77 += _76;
    _77 *= _73.d1;
    _77 += _75;
    _73.data[_77] = i;
    _75++;
    if (_75 < j)
    goto _jump1234;
    _75 = 0;
    _76++;
    if (_76 < _70)
    goto _jump1234;
    // End body of loop
    int64_t _78 = 0;
    _78 *= _66.d0;
    _78 += _72;
    _78 *= _66.d1;
    _78 += _71;
    _78 *= _66.d2;
    _78 += _70;
    _66.data[_78] = _73;
    _70++;
    if (_70 < g)
    goto _jump1231;
    _70 = 0;
    _71++;
    if (_71 < _68)
    goto _jump1231;
    _71 = 0;
    _72++;
    if (_72 < l)
    goto _jump1231;
    // End body of loop
    int64_t _79;
    if (!r)
    goto _jump1235;
    _79 = d;
    goto _jump1236;
    _jump1235:;
    _79 = n;
    _jump1236:;
    if (_79 >= 0)
    goto _jump1237;
    fail_assertion("negative array index");
    _jump1237:;
    if (_79 < _66.d0)
    goto _jump1238;
    fail_assertion("index too large");
    _jump1238:;
    if (c >= 0)
    goto _jump1239;
    fail_assertion("negative array index");
    _jump1239:;
    if (c < _66.d1)
    goto _jump1240;
    fail_assertion("index too large");
    _jump1240:;
    if (D >= 0)
    goto _jump1241;
    fail_assertion("negative array index");
    _jump1241:;
    if (D < _66.d2)
    goto _jump1242;
    fail_assertion("index too large");
    _jump1242:;
    int64_t _80 = 0;
    _80 *= _66.d0;
    _80 += _79;
    _80 *= _66.d1;
    _80 += c;
    _80 *= _66.d2;
    _80 += D;
    _a2__a3_int64_t _81 = _66.data[_80];
    _65 = _81;
    goto _jump1243;
    _jump1227:;
    bool _82 = true;
    _a2__a3_int64_t _83;
    if (!_82)
    goto _jump1244;
    bool _84 = true;
    bool _85 = !_84;
    _a2__a3_int64_t _86;
    if (!_85)
    goto _jump1245;
    _a2__a3_int64_t _87;
    // Computing bound for M
    _87.d0 = c;
    if (c > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing bound for N
    _87.d1 = E;
    if (E > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= c;
    _88 *= E;
    _88 *= sizeof(_a3_int64_t);
    _87.data = jpl_alloc(_88);
    int64_t _89 = 0; // N
    int64_t _90 = 0; // M
    _jump1248:; // Begin body of loop
    _a3_int64_t _91;
    // Computing bound for O
    _91.d0 = _89;
    if (_89 > 0) 
    goto _jump1249;
    fail_assertion("non-positive loop bound");
    _jump1249:;
    // Computing bound for P
    _91.d1 = _17.d0;
    if (_17.d0 > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing bound for Q
    int64_t _92 = 92;
    _91.d2 = _92;
    if (_92 > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= _89;
    _93 *= _17.d0;
    _93 *= _92;
    _93 *= sizeof(int64_t);
    _91.data = jpl_alloc(_93);
    int64_t _94 = 0; // Q
    int64_t _95 = 0; // P
    int64_t _96 = 0; // O
    _jump1252:; // Begin body of loop
    int64_t _97 = 0;
    _97 *= _91.d0;
    _97 += _96;
    _97 *= _91.d1;
    _97 += _95;
    _97 *= _91.d2;
    _97 += _94;
    _91.data[_97] = k;
    _94++;
    if (_94 < _92)
    goto _jump1252;
    _94 = 0;
    _95++;
    if (_95 < _17.d0)
    goto _jump1252;
    _95 = 0;
    _96++;
    if (_96 < _89)
    goto _jump1252;
    // End body of loop
    int64_t _98 = 0;
    _98 *= _87.d0;
    _98 += _90;
    _98 *= _87.d1;
    _98 += _89;
    _87.data[_98] = _91;
    _89++;
    if (_89 < E)
    goto _jump1248;
    _89 = 0;
    _90++;
    if (_90 < c)
    goto _jump1248;
    // End body of loop
    _86 = _87;
    goto _jump1253;
    _jump1245:;
    _a2__a3_int64_t _99;
    // Computing bound for M
    _99.d0 = k;
    if (k > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    // Computing bound for N
    _99.d1 = B;
    if (B > 0) 
    goto _jump1255;
    fail_assertion("non-positive loop bound");
    _jump1255:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= k;
    _100 *= B;
    _100 *= sizeof(_a3_int64_t);
    _99.data = jpl_alloc(_100);
    int64_t _101 = 0; // N
    int64_t _102 = 0; // M
    _jump1256:; // Begin body of loop
    int64_t _103 = 0;
    _103 *= _99.d0;
    _103 += _102;
    _103 *= _99.d1;
    _103 += _101;
    _99.data[_103] = i;
    _101++;
    if (_101 < B)
    goto _jump1256;
    _101 = 0;
    _102++;
    if (_102 < k)
    goto _jump1256;
    // End body of loop
    _86 = _99;
    _jump1253:;
    _83 = _86;
    goto _jump1257;
    _jump1244:;
    _a2__a3_int64_t _104;
    if (!r)
    goto _jump1258;
    _a2__a3_int64_t _105;
    // Computing bound for M
    _105.d0 = d;
    if (d > 0) 
    goto _jump1259;
    fail_assertion("non-positive loop bound");
    _jump1259:;
    // Computing bound for N
    _105.d1 = y;
    if (y > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= d;
    _106 *= y;
    _106 *= sizeof(_a3_int64_t);
    _105.data = jpl_alloc(_106);
    int64_t _107 = 0; // N
    int64_t _108 = 0; // M
    _jump1261:; // Begin body of loop
    _a3_int64_t _109;
    // Computing bound for O
    _109.d0 = g;
    if (g > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    // Computing bound for P
    _109.d1 = s;
    if (s > 0) 
    goto _jump1263;
    fail_assertion("non-positive loop bound");
    _jump1263:;
    // Computing bound for Q
    _109.d2 = c;
    if (c > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= g;
    _110 *= s;
    _110 *= c;
    _110 *= sizeof(int64_t);
    _109.data = jpl_alloc(_110);
    int64_t _111 = 0; // Q
    int64_t _112 = 0; // P
    int64_t _113 = 0; // O
    _jump1265:; // Begin body of loop
    int64_t _114 = 0;
    _114 *= _109.d0;
    _114 += _113;
    _114 *= _109.d1;
    _114 += _112;
    _114 *= _109.d2;
    _114 += _111;
    _109.data[_114] = _107;
    _111++;
    if (_111 < c)
    goto _jump1265;
    _111 = 0;
    _112++;
    if (_112 < s)
    goto _jump1265;
    _112 = 0;
    _113++;
    if (_113 < g)
    goto _jump1265;
    // End body of loop
    int64_t _115 = 0;
    _115 *= _105.d0;
    _115 += _108;
    _115 *= _105.d1;
    _115 += _107;
    _105.data[_115] = _109;
    _107++;
    if (_107 < y)
    goto _jump1261;
    _107 = 0;
    _108++;
    if (_108 < d)
    goto _jump1261;
    // End body of loop
    _104 = _105;
    goto _jump1266;
    _jump1258:;
    _a2__a3_int64_t _116;
    // Computing bound for M
    int64_t _117;
    // Computing bound for M
    if (s > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    // Computing bound for N
    if (g > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    _117 = 0;
    int64_t _118 = 0; // N
    int64_t _119 = 0; // M
    _jump1269:; // Begin body of loop
    _117 += h;
    _118++;
    if (_118 < g)
    goto _jump1269;
    _118 = 0;
    _119++;
    if (_119 < s)
    goto _jump1269;
    // End body of loop
    _116.d0 = _117;
    if (_117 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    // Computing bound for N
    _116.d1 = D;
    if (D > 0) 
    goto _jump1271;
    fail_assertion("non-positive loop bound");
    _jump1271:;
    // Computing total size of heap memory to allocate
    int64_t _120 = 1;
    _120 *= _117;
    _120 *= D;
    _120 *= sizeof(_a3_int64_t);
    _116.data = jpl_alloc(_120);
    int64_t _121 = 0; // N
    int64_t _122 = 0; // M
    _jump1272:; // Begin body of loop
    int64_t _123 = 0;
    _123 *= _116.d0;
    _123 += _122;
    _123 *= _116.d1;
    _123 += _121;
    _116.data[_123] = i;
    _121++;
    if (_121 < D)
    goto _jump1272;
    _121 = 0;
    _122++;
    if (_122 < _117)
    goto _jump1272;
    // End body of loop
    _104 = _116;
    _jump1266:;
    _83 = _104;
    _jump1257:;
    _65 = _83;
    _jump1243:;
    _27 = _65;
    _jump1207:;
    if (v >= 0)
    goto _jump1273;
    fail_assertion("negative array index");
    _jump1273:;
    if (v < _27.d0)
    goto _jump1274;
    fail_assertion("index too large");
    _jump1274:;
    if (_17.d0 >= 0)
    goto _jump1275;
    fail_assertion("negative array index");
    _jump1275:;
    if (_17.d0 < _27.d1)
    goto _jump1276;
    fail_assertion("index too large");
    _jump1276:;
    int64_t _124 = 0;
    _124 *= _27.d0;
    _124 += v;
    _124 *= _27.d1;
    _124 += _17.d0;
    _a3_int64_t _125 = _27.data[_124];
    bool _126 = G();
    if (0 != _126)
    goto _jump1277;
    fail_assertion("Q");
    _jump1277:;
    _a3__a2_double _127;
    // Computing bound for Q
    _127.d0 = d;
    if (d > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing bound for R
    _127.d1 = c;
    if (c > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing bound for S
    _127.d2 = _125.d0;
    if (_125.d0 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= d;
    _128 *= c;
    _128 *= _125.d0;
    _128 *= sizeof(_a2_double);
    _127.data = jpl_alloc(_128);
    int64_t _129 = 0; // S
    int64_t _130 = 0; // R
    int64_t _131 = 0; // Q
    _jump1281:; // Begin body of loop
    _a2_double _132;
    // Computing bound for T
    _132.d0 = E;
    if (E > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing bound for U
    _132.d1 = g;
    if (g > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= E;
    _133 *= g;
    _133 *= sizeof(double);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // U
    int64_t _135 = 0; // T
    _jump1284:; // Begin body of loop
    double _136 = 44.0;
    double _137 = -_136;
    int64_t _138 = 0;
    _138 *= _132.d0;
    _138 += _135;
    _138 *= _132.d1;
    _138 += _134;
    _132.data[_138] = _137;
    _134++;
    if (_134 < g)
    goto _jump1284;
    _134 = 0;
    _135++;
    if (_135 < E)
    goto _jump1284;
    // End body of loop
    int64_t _139 = 0;
    _139 *= _127.d0;
    _139 += _131;
    _139 *= _127.d1;
    _139 += _130;
    _139 *= _127.d2;
    _139 += _129;
    _127.data[_139] = _132;
    _129++;
    if (_129 < _125.d0)
    goto _jump1281;
    _129 = 0;
    _130++;
    if (_130 < c)
    goto _jump1281;
    _130 = 0;
    _131++;
    if (_131 < d)
    goto _jump1281;
    // End body of loop
    if (j >= 0)
    goto _jump1285;
    fail_assertion("negative array index");
    _jump1285:;
    if (j < _127.d0)
    goto _jump1286;
    fail_assertion("index too large");
    _jump1286:;
    if (u >= 0)
    goto _jump1287;
    fail_assertion("negative array index");
    _jump1287:;
    if (u < _127.d1)
    goto _jump1288;
    fail_assertion("index too large");
    _jump1288:;
    if (_125.d0 >= 0)
    goto _jump1289;
    fail_assertion("negative array index");
    _jump1289:;
    if (_125.d0 < _127.d2)
    goto _jump1290;
    fail_assertion("index too large");
    _jump1290:;
    int64_t _140 = 0;
    _140 *= _127.d0;
    _140 += j;
    _140 *= _127.d1;
    _140 += u;
    _140 *= _127.d2;
    _140 += _125.d0;
    _a2_double _141 = _127.data[_140];
    if (d >= 0)
    goto _jump1291;
    fail_assertion("negative array index");
    _jump1291:;
    if (d < _141.d0)
    goto _jump1292;
    fail_assertion("index too large");
    _jump1292:;
    if (c >= 0)
    goto _jump1293;
    fail_assertion("negative array index");
    _jump1293:;
    if (c < _141.d1)
    goto _jump1294;
    fail_assertion("index too large");
    _jump1294:;
    int64_t _142 = 0;
    _142 *= _141.d0;
    _142 += d;
    _142 *= _141.d1;
    _142 += c;
    double _143 = _141.data[_142];
    double _144;
    // Computing bound for Q
    if (B > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing bound for R
    if (u > 0) 
    goto _jump1296;
    fail_assertion("non-positive loop bound");
    _jump1296:;
    // Computing bound for S
    int64_t _145 = 68;
    if (_145 > 0) 
    goto _jump1297;
    fail_assertion("non-positive loop bound");
    _jump1297:;
    _144 = 0;
    int64_t _146 = 0; // S
    int64_t _147 = 0; // R
    int64_t _148 = 0; // Q
    _jump1298:; // Begin body of loop
    bool _149 = !r;
    double _150;
    if (!_149)
    goto _jump1299;
    double _151;
    // Computing bound for T
    if (_125.d1 > 0) 
    goto _jump1300;
    fail_assertion("non-positive loop bound");
    _jump1300:;
    // Computing bound for U
    if (l > 0) 
    goto _jump1301;
    fail_assertion("non-positive loop bound");
    _jump1301:;
    _151 = 0;
    int64_t _152 = 0; // U
    int64_t _153 = 0; // T
    _jump1302:; // Begin body of loop
    double _154 = 55.0;
    _151 += _154;
    _152++;
    if (_152 < l)
    goto _jump1302;
    _152 = 0;
    _153++;
    if (_153 < _125.d1)
    goto _jump1302;
    // End body of loop
    _150 = _151;
    goto _jump1303;
    _jump1299:;
    double _155 = 13.0;
    _150 = _155;
    _jump1303:;
    _a2_bool _156;
    // Computing bound for T
    _156.d0 = h;
    if (h > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    // Computing bound for U
    _156.d1 = c;
    if (c > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= h;
    _157 *= c;
    _157 *= sizeof(bool);
    _156.data = jpl_alloc(_157);
    int64_t _158 = 0; // U
    int64_t _159 = 0; // T
    _jump1306:; // Begin body of loop
    bool _160 = G();
    int64_t _161 = 0;
    _161 *= _156.d0;
    _161 += _159;
    _161 *= _156.d1;
    _161 += _158;
    _156.data[_161] = _160;
    _158++;
    if (_158 < c)
    goto _jump1306;
    _158 = 0;
    _159++;
    if (_159 < h)
    goto _jump1306;
    // End body of loop
    double _162 = a(_150, _156);
    _144 += _162;
    _146++;
    if (_146 < _145)
    goto _jump1298;
    _146 = 0;
    _147++;
    if (_147 < u)
    goto _jump1298;
    _147 = 0;
    _148++;
    if (_148 < B)
    goto _jump1298;
    // End body of loop
    bool _163 = _19;
    if (0 == _19)
    goto _jump1307;
    bool _164;
    if (!_19)
    goto _jump1308;
    bool _165 = G();
    _164 = _165;
    goto _jump1309;
    _jump1308:;
    _164 = _19;
    _jump1309:;
    _163 = _164;
    _jump1307:;
    double _166;
    if (!_163)
    goto _jump1310;
    double _167 = 55.0;
    double _168 = 26.0;
    _a1_double _169;
    _169.d0 = 2;
    _169.data = jpl_alloc(sizeof(double) * 2);
    _169.data[0] = _167;
    _169.data[1] = _168;
    if (D >= 0)
    goto _jump1311;
    fail_assertion("negative array index");
    _jump1311:;
    if (D < _169.d0)
    goto _jump1312;
    fail_assertion("index too large");
    _jump1312:;
    int64_t _170 = 0;
    _170 *= _169.d0;
    _170 += D;
    double _171 = _169.data[_170];
    _166 = _171;
    goto _jump1313;
    _jump1310:;
    if (s >= 0)
    goto _jump1314;
    fail_assertion("negative array index");
    _jump1314:;
    if (s < t.d0)
    goto _jump1315;
    fail_assertion("index too large");
    _jump1315:;
    if (D >= 0)
    goto _jump1316;
    fail_assertion("negative array index");
    _jump1316:;
    if (D < t.d1)
    goto _jump1317;
    fail_assertion("index too large");
    _jump1317:;
    int64_t _172 = 0;
    _172 *= t.d0;
    _172 += s;
    _172 *= t.d1;
    _172 += D;
    rgba _173 = t.data[_172];
    double _174 = _173.r;
    _a2_bool _175;
    // Computing bound for Q
    _175.d0 = E;
    if (E > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for R
    _175.d1 = q;
    if (q > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= E;
    _176 *= q;
    _176 *= sizeof(bool);
    _175.data = jpl_alloc(_176);
    int64_t _177 = 0; // R
    int64_t _178 = 0; // Q
    _jump1320:; // Begin body of loop
    int64_t _179 = 0;
    _179 *= _175.d0;
    _179 += _178;
    _179 *= _175.d1;
    _179 += _177;
    _175.data[_179] = _19;
    _177++;
    if (_177 < q)
    goto _jump1320;
    _177 = 0;
    _178++;
    if (_178 < E)
    goto _jump1320;
    // End body of loop
    double _180 = a(_174, _175);
    _166 = _180;
    _jump1313:;
    double _181 = fmod(_144, _166);
    bool _182 = _143 != _181;
    bool _183;
    if (!_182)
    goto _jump1321;
    _183 = _19;
    goto _jump1322;
    _jump1321:;
    bool _184 = _19;
    if (0 == _19)
    goto _jump1323;
    bool _185 = true;
    _184 = _185;
    _jump1323:;
    _183 = _184;
    _jump1322:;
    return _183;
}

double K(_a3_void_t L, _a1_void_t M) {
    double _0;
    // Computing bound for O
    if (c > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    // Computing bound for P
    if (D > 0) 
    goto _jump1336;
    fail_assertion("non-positive loop bound");
    _jump1336:;
    // Computing bound for Q
    if (l > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    _0 = 0;
    int64_t _1 = 0; // Q
    int64_t _2 = 0; // P
    int64_t _3 = 0; // O
    _jump1338:; // Begin body of loop
    double _4 = 44.0;
    _0 += _4;
    _1++;
    if (_1 < l)
    goto _jump1338;
    _1 = 0;
    _2++;
    if (_2 < D)
    goto _jump1338;
    _2 = 0;
    _3++;
    if (_3 < c)
    goto _jump1338;
    // End body of loop
    double _5 = 40.0;
    bool _6 = _0 > _5;
    _a2_double _7;
    if (!_6)
    goto _jump1339;
    bool _8 = true;
    _a2__a2_double _9;
    if (!_8)
    goto _jump1340;
    _a2__a2_double _10;
    // Computing bound for O
    _10.d0 = E;
    if (E > 0) 
    goto _jump1341;
    fail_assertion("non-positive loop bound");
    _jump1341:;
    // Computing bound for P
    int64_t _11;
    // Computing bound for O
    if (y > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    _11 = 0;
    int64_t _12 = 0; // O
    _jump1343:; // Begin body of loop
    _11 += y;
    _12++;
    if (_12 < y)
    goto _jump1343;
    // End body of loop
    _10.d1 = _11;
    if (_11 > 0) 
    goto _jump1344;
    fail_assertion("non-positive loop bound");
    _jump1344:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= E;
    _13 *= _11;
    _13 *= sizeof(_a2_double);
    _10.data = jpl_alloc(_13);
    int64_t _14 = 0; // P
    int64_t _15 = 0; // O
    _jump1345:; // Begin body of loop
    _a2_double _16;
    // Computing bound for Q
    _16.d0 = g;
    if (g > 0) 
    goto _jump1346;
    fail_assertion("non-positive loop bound");
    _jump1346:;
    // Computing bound for R
    _16.d1 = D;
    if (D > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing total size of heap memory to allocate
    int64_t _17 = 1;
    _17 *= g;
    _17 *= D;
    _17 *= sizeof(double);
    _16.data = jpl_alloc(_17);
    int64_t _18 = 0; // R
    int64_t _19 = 0; // Q
    _jump1348:; // Begin body of loop
    double _20 = 82.0;
    int64_t _21 = 0;
    _21 *= _16.d0;
    _21 += _19;
    _21 *= _16.d1;
    _21 += _18;
    _16.data[_21] = _20;
    _18++;
    if (_18 < D)
    goto _jump1348;
    _18 = 0;
    _19++;
    if (_19 < g)
    goto _jump1348;
    // End body of loop
    int64_t _22 = 0;
    _22 *= _10.d0;
    _22 += _15;
    _22 *= _10.d1;
    _22 += _14;
    _10.data[_22] = _16;
    _14++;
    if (_14 < _11)
    goto _jump1345;
    _14 = 0;
    _15++;
    if (_15 < E)
    goto _jump1345;
    // End body of loop
    _9 = _10;
    goto _jump1349;
    _jump1340:;
    _a2__a2_double _23;
    // Computing bound for O
    _23.d0 = l;
    if (l > 0) 
    goto _jump1350;
    fail_assertion("non-positive loop bound");
    _jump1350:;
    // Computing bound for P
    int64_t _24 = q / c;
    _23.d1 = _24;
    if (_24 > 0) 
    goto _jump1351;
    fail_assertion("non-positive loop bound");
    _jump1351:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= l;
    _25 *= _24;
    _25 *= sizeof(_a2_double);
    _23.data = jpl_alloc(_25);
    int64_t _26 = 0; // P
    int64_t _27 = 0; // O
    _jump1352:; // Begin body of loop
    _a2_double _28;
    // Computing bound for Q
    _28.d0 = D;
    if (D > 0) 
    goto _jump1353;
    fail_assertion("non-positive loop bound");
    _jump1353:;
    // Computing bound for R
    _28.d1 = h;
    if (h > 0) 
    goto _jump1354;
    fail_assertion("non-positive loop bound");
    _jump1354:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= D;
    _29 *= h;
    _29 *= sizeof(double);
    _28.data = jpl_alloc(_29);
    int64_t _30 = 0; // R
    int64_t _31 = 0; // Q
    _jump1355:; // Begin body of loop
    double _32 = 45.0;
    int64_t _33 = 0;
    _33 *= _28.d0;
    _33 += _31;
    _33 *= _28.d1;
    _33 += _30;
    _28.data[_33] = _32;
    _30++;
    if (_30 < h)
    goto _jump1355;
    _30 = 0;
    _31++;
    if (_31 < D)
    goto _jump1355;
    // End body of loop
    int64_t _34 = 0;
    _34 *= _23.d0;
    _34 += _27;
    _34 *= _23.d1;
    _34 += _26;
    _23.data[_34] = _28;
    _26++;
    if (_26 < _24)
    goto _jump1352;
    _26 = 0;
    _27++;
    if (_27 < l)
    goto _jump1352;
    // End body of loop
    _9 = _23;
    _jump1349:;
    int64_t _35 = -k;
    if (_35 >= 0)
    goto _jump1356;
    fail_assertion("negative array index");
    _jump1356:;
    if (_35 < _9.d0)
    goto _jump1357;
    fail_assertion("index too large");
    _jump1357:;
    if (D >= 0)
    goto _jump1358;
    fail_assertion("negative array index");
    _jump1358:;
    if (D < _9.d1)
    goto _jump1359;
    fail_assertion("index too large");
    _jump1359:;
    int64_t _36 = 0;
    _36 *= _9.d0;
    _36 += _35;
    _36 *= _9.d1;
    _36 += D;
    _a2_double _37 = _9.data[_36];
    _7 = _37;
    goto _jump1360;
    _jump1339:;
    _a2_double _38;
    // Computing bound for O
    int64_t _39 = 898;
    _38.d0 = _39;
    if (_39 > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing bound for P
    _38.d1 = v;
    if (v > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= _39;
    _40 *= v;
    _40 *= sizeof(double);
    _38.data = jpl_alloc(_40);
    int64_t _41 = 0; // P
    int64_t _42 = 0; // O
    _jump1363:; // Begin body of loop
    double _43 = 75.0;
    int64_t _44 = 0;
    _44 *= _38.d0;
    _44 += _42;
    _44 *= _38.d1;
    _44 += _41;
    _38.data[_44] = _43;
    _41++;
    if (_41 < v)
    goto _jump1363;
    _41 = 0;
    _42++;
    if (_42 < _39)
    goto _jump1363;
    // End body of loop
    _7 = _38;
    _jump1360:;
    int64_t _45;
    // Computing bound for O
    if (h > 0) 
    goto _jump1364;
    fail_assertion("non-positive loop bound");
    _jump1364:;
    // Computing bound for P
    if (s > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing bound for Q
    if (n > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    _45 = 0;
    int64_t _46 = 0; // Q
    int64_t _47 = 0; // P
    int64_t _48 = 0; // O
    _jump1367:; // Begin body of loop
    _45 += _48;
    _46++;
    if (_46 < n)
    goto _jump1367;
    _46 = 0;
    _47++;
    if (_47 < s)
    goto _jump1367;
    _47 = 0;
    _48++;
    if (_48 < h)
    goto _jump1367;
    // End body of loop
    if (l >= 0)
    goto _jump1368;
    fail_assertion("negative array index");
    _jump1368:;
    if (l < _7.d0)
    goto _jump1369;
    fail_assertion("index too large");
    _jump1369:;
    if (_45 >= 0)
    goto _jump1370;
    fail_assertion("negative array index");
    _jump1370:;
    if (_45 < _7.d1)
    goto _jump1371;
    fail_assertion("index too large");
    _jump1371:;
    int64_t _49 = 0;
    _49 *= _7.d0;
    _49 += l;
    _49 *= _7.d1;
    _49 += _45;
    double _50 = _7.data[_49];
    double _51;
    // Computing bound for O
    int64_t _52 = 543;
    if (_52 > 0) 
    goto _jump1372;
    fail_assertion("non-positive loop bound");
    _jump1372:;
    // Computing bound for P
    if (g > 0) 
    goto _jump1373;
    fail_assertion("non-positive loop bound");
    _jump1373:;
    // Computing bound for Q
    if (D > 0) 
    goto _jump1374;
    fail_assertion("non-positive loop bound");
    _jump1374:;
    _51 = 0;
    int64_t _53 = 0; // Q
    int64_t _54 = 0; // P
    int64_t _55 = 0; // O
    _jump1375:; // Begin body of loop
    bool _56 = G();
    _a2_double _57;
    if (!_56)
    goto _jump1376;
    _a2_double _58;
    // Computing bound for R
    _58.d0 = k;
    if (k > 0) 
    goto _jump1377;
    fail_assertion("non-positive loop bound");
    _jump1377:;
    // Computing bound for S
    _58.d1 = _54;
    if (_54 > 0) 
    goto _jump1378;
    fail_assertion("non-positive loop bound");
    _jump1378:;
    // Computing total size of heap memory to allocate
    int64_t _59 = 1;
    _59 *= k;
    _59 *= _54;
    _59 *= sizeof(double);
    _58.data = jpl_alloc(_59);
    int64_t _60 = 0; // S
    int64_t _61 = 0; // R
    _jump1379:; // Begin body of loop
    double _62 = 91.0;
    double _63 = -_62;
    int64_t _64 = 0;
    _64 *= _58.d0;
    _64 += _61;
    _64 *= _58.d1;
    _64 += _60;
    _58.data[_64] = _63;
    _60++;
    if (_60 < _54)
    goto _jump1379;
    _60 = 0;
    _61++;
    if (_61 < k)
    goto _jump1379;
    // End body of loop
    _57 = _58;
    goto _jump1380;
    _jump1376:;
    bool _65 = true;
    double _66;
    if (!_65)
    goto _jump1381;
    double _67 = 31.0;
    _66 = _67;
    goto _jump1382;
    _jump1381:;
    double _68 = 57.0;
    _66 = _68;
    _jump1382:;
    double _69;
    // Computing bound for R
    if (n > 0) 
    goto _jump1383;
    fail_assertion("non-positive loop bound");
    _jump1383:;
    _69 = 0;
    int64_t _70 = 0; // R
    _jump1384:; // Begin body of loop
    double _71 = 43.0;
    _69 += _71;
    _70++;
    if (_70 < n)
    goto _jump1384;
    // End body of loop
    bool _72 = _66 != _69;
    _a2_double _73;
    if (!_72)
    goto _jump1385;
    _a2_double _74;
    // Computing bound for R
    _74.d0 = s;
    if (s > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing bound for S
    _74.d1 = E;
    if (E > 0) 
    goto _jump1387;
    fail_assertion("non-positive loop bound");
    _jump1387:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= s;
    _75 *= E;
    _75 *= sizeof(double);
    _74.data = jpl_alloc(_75);
    int64_t _76 = 0; // S
    int64_t _77 = 0; // R
    _jump1388:; // Begin body of loop
    double _78 = 51.0;
    double _79 = -_78;
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += _77;
    _80 *= _74.d1;
    _80 += _76;
    _74.data[_80] = _79;
    _76++;
    if (_76 < E)
    goto _jump1388;
    _76 = 0;
    _77++;
    if (_77 < s)
    goto _jump1388;
    // End body of loop
    _73 = _74;
    goto _jump1389;
    _jump1385:;
    _a2_double _81;
    // Computing bound for R
    int64_t _82;
    // Computing bound for R
    if (v > 0) 
    goto _jump1390;
    fail_assertion("non-positive loop bound");
    _jump1390:;
    _82 = 0;
    int64_t _83 = 0; // R
    _jump1391:; // Begin body of loop
    _82 += _54;
    _83++;
    if (_83 < v)
    goto _jump1391;
    // End body of loop
    _81.d0 = _82;
    if (_82 > 0) 
    goto _jump1392;
    fail_assertion("non-positive loop bound");
    _jump1392:;
    // Computing bound for S
    _81.d1 = B;
    if (B > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= _82;
    _84 *= B;
    _84 *= sizeof(double);
    _81.data = jpl_alloc(_84);
    int64_t _85 = 0; // S
    int64_t _86 = 0; // R
    _jump1394:; // Begin body of loop
    double _87 = 56.0;
    double _88 = -_87;
    int64_t _89 = 0;
    _89 *= _81.d0;
    _89 += _86;
    _89 *= _81.d1;
    _89 += _85;
    _81.data[_89] = _88;
    _85++;
    if (_85 < B)
    goto _jump1394;
    _85 = 0;
    _86++;
    if (_86 < _82)
    goto _jump1394;
    // End body of loop
    _73 = _81;
    _jump1389:;
    _57 = _73;
    _jump1380:;
    int64_t _90 = d - u;
    int64_t _91 = -_54;
    if (_90 >= 0)
    goto _jump1395;
    fail_assertion("negative array index");
    _jump1395:;
    if (_90 < _57.d0)
    goto _jump1396;
    fail_assertion("index too large");
    _jump1396:;
    if (_91 >= 0)
    goto _jump1397;
    fail_assertion("negative array index");
    _jump1397:;
    if (_91 < _57.d1)
    goto _jump1398;
    fail_assertion("index too large");
    _jump1398:;
    int64_t _92 = 0;
    _92 *= _57.d0;
    _92 += _90;
    _92 *= _57.d1;
    _92 += _91;
    double _93 = _57.data[_92];
    _51 += _93;
    _53++;
    if (_53 < D)
    goto _jump1375;
    _53 = 0;
    _54++;
    if (_54 < g)
    goto _jump1375;
    _54 = 0;
    _55++;
    if (_55 < _52)
    goto _jump1375;
    // End body of loop
    double _94 = _50 / _51;
    return _94;
    bool _95 = true;
    _a3_void_t _96;
    if (!_95)
    goto _jump1399;
    _a3__a2__a3_void_t _97;
    // Computing bound for O
    _97.d0 = v;
    if (v > 0) 
    goto _jump1400;
    fail_assertion("non-positive loop bound");
    _jump1400:;
    // Computing bound for P
    _97.d1 = l;
    if (l > 0) 
    goto _jump1401;
    fail_assertion("non-positive loop bound");
    _jump1401:;
    // Computing bound for Q
    _97.d2 = M.d0;
    if (M.d0 > 0) 
    goto _jump1402;
    fail_assertion("non-positive loop bound");
    _jump1402:;
    // Computing total size of heap memory to allocate
    int64_t _98 = 1;
    _98 *= v;
    _98 *= l;
    _98 *= M.d0;
    _98 *= sizeof(_a2__a3_void_t);
    _97.data = jpl_alloc(_98);
    int64_t _99 = 0; // Q
    int64_t _100 = 0; // P
    int64_t _101 = 0; // O
    _jump1403:; // Begin body of loop
    _a2__a3_void_t _102;
    // Computing bound for R
    _102.d0 = D;
    if (D > 0) 
    goto _jump1404;
    fail_assertion("non-positive loop bound");
    _jump1404:;
    // Computing bound for S
    _102.d1 = k;
    if (k > 0) 
    goto _jump1405;
    fail_assertion("non-positive loop bound");
    _jump1405:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= D;
    _103 *= k;
    _103 *= sizeof(_a3_void_t);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // S
    int64_t _105 = 0; // R
    _jump1406:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _102.d0;
    _106 += _105;
    _106 *= _102.d1;
    _106 += _104;
    _102.data[_106] = L;
    _104++;
    if (_104 < k)
    goto _jump1406;
    _104 = 0;
    _105++;
    if (_105 < D)
    goto _jump1406;
    // End body of loop
    int64_t _107 = 0;
    _107 *= _97.d0;
    _107 += _101;
    _107 *= _97.d1;
    _107 += _100;
    _107 *= _97.d2;
    _107 += _99;
    _97.data[_107] = _102;
    _99++;
    if (_99 < M.d0)
    goto _jump1403;
    _99 = 0;
    _100++;
    if (_100 < l)
    goto _jump1403;
    _100 = 0;
    _101++;
    if (_101 < v)
    goto _jump1403;
    // End body of loop
    if (u >= 0)
    goto _jump1407;
    fail_assertion("negative array index");
    _jump1407:;
    if (u < _97.d0)
    goto _jump1408;
    fail_assertion("index too large");
    _jump1408:;
    if (u >= 0)
    goto _jump1409;
    fail_assertion("negative array index");
    _jump1409:;
    if (u < _97.d1)
    goto _jump1410;
    fail_assertion("index too large");
    _jump1410:;
    if (h >= 0)
    goto _jump1411;
    fail_assertion("negative array index");
    _jump1411:;
    if (h < _97.d2)
    goto _jump1412;
    fail_assertion("index too large");
    _jump1412:;
    int64_t _108 = 0;
    _108 *= _97.d0;
    _108 += u;
    _108 *= _97.d1;
    _108 += u;
    _108 *= _97.d2;
    _108 += h;
    _a2__a3_void_t _109 = _97.data[_108];
    if (g >= 0)
    goto _jump1413;
    fail_assertion("negative array index");
    _jump1413:;
    if (g < _109.d0)
    goto _jump1414;
    fail_assertion("index too large");
    _jump1414:;
    if (u >= 0)
    goto _jump1415;
    fail_assertion("negative array index");
    _jump1415:;
    if (u < _109.d1)
    goto _jump1416;
    fail_assertion("index too large");
    _jump1416:;
    int64_t _110 = 0;
    _110 *= _109.d0;
    _110 += g;
    _110 *= _109.d1;
    _110 += u;
    _a3_void_t _111 = _109.data[_110];
    _96 = _111;
    goto _jump1417;
    _jump1399:;
    _a3_void_t _112;
    // Computing bound for O
    _112.d0 = c;
    if (c > 0) 
    goto _jump1418;
    fail_assertion("non-positive loop bound");
    _jump1418:;
    // Computing bound for P
    int64_t _113 = -d;
    _112.d1 = _113;
    if (_113 > 0) 
    goto _jump1419;
    fail_assertion("non-positive loop bound");
    _jump1419:;
    // Computing bound for Q
    _112.d2 = h;
    if (h > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= c;
    _114 *= _113;
    _114 *= h;
    _114 *= sizeof(void_t);
    _112.data = jpl_alloc(_114);
    int64_t _115 = 0; // Q
    int64_t _116 = 0; // P
    int64_t _117 = 0; // O
    _jump1421:; // Begin body of loop
    bool _118 = G();
    bool _119 = !_118;
    bool _120 = !r;
    bool _121 = h < _115;
    bool _122 = _120 != _121;
    bool _123 = _119 == _122;
    void_t _124;
    if (!_123)
    goto _jump1422;
    bool _125 = false;
    bool _126 = G();
    bool _127 = _125 != _126;
    void_t _128;
    if (!_127)
    goto _jump1423;
    void_t _129 = z(w);
    _128 = _129;
    goto _jump1424;
    _jump1423:;
    void_t _130 = z(w);
    _128 = _130;
    _jump1424:;
    _124 = _128;
    goto _jump1425;
    _jump1422:;
    _a2_void_t _131;
    // Computing bound for R
    _131.d0 = s;
    if (s > 0) 
    goto _jump1426;
    fail_assertion("non-positive loop bound");
    _jump1426:;
    // Computing bound for S
    _131.d1 = j;
    if (j > 0) 
    goto _jump1427;
    fail_assertion("non-positive loop bound");
    _jump1427:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= s;
    _132 *= j;
    _132 *= sizeof(void_t);
    _131.data = jpl_alloc(_132);
    int64_t _133 = 0; // S
    int64_t _134 = 0; // R
    _jump1428:; // Begin body of loop
    void_t _135 = z(J);
    int64_t _136 = 0;
    _136 *= _131.d0;
    _136 += _134;
    _136 *= _131.d1;
    _136 += _133;
    _131.data[_136] = _135;
    _133++;
    if (_133 < j)
    goto _jump1428;
    _133 = 0;
    _134++;
    if (_134 < s)
    goto _jump1428;
    // End body of loop
    if (s >= 0)
    goto _jump1429;
    fail_assertion("negative array index");
    _jump1429:;
    if (s < _131.d0)
    goto _jump1430;
    fail_assertion("index too large");
    _jump1430:;
    if (c >= 0)
    goto _jump1431;
    fail_assertion("negative array index");
    _jump1431:;
    if (c < _131.d1)
    goto _jump1432;
    fail_assertion("index too large");
    _jump1432:;
    int64_t _137 = 0;
    _137 *= _131.d0;
    _137 += s;
    _137 *= _131.d1;
    _137 += c;
    void_t _138 = _131.data[_137];
    _124 = _138;
    _jump1425:;
    int64_t _139 = 0;
    _139 *= _112.d0;
    _139 += _117;
    _139 *= _112.d1;
    _139 += _116;
    _139 *= _112.d2;
    _139 += _115;
    _112.data[_139] = _124;
    _115++;
    if (_115 < h)
    goto _jump1421;
    _115 = 0;
    _116++;
    if (_116 < _113)
    goto _jump1421;
    _116 = 0;
    _117++;
    if (_117 < c)
    goto _jump1421;
    // End body of loop
    _96 = _112;
    _jump1417:;
    double _140 = K(_96, M);
    return _140;
    _a3__a2_rgba _141;
    // Computing bound for O
    _141.d0 = D;
    if (D > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing bound for P
    int64_t _142;
    // Computing bound for O
    if (c > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    _142 = 0;
    int64_t _143 = 0; // O
    _jump1435:; // Begin body of loop
    _142 += M.d0;
    _143++;
    if (_143 < c)
    goto _jump1435;
    // End body of loop
    _141.d1 = _142;
    if (_142 > 0) 
    goto _jump1436;
    fail_assertion("non-positive loop bound");
    _jump1436:;
    // Computing bound for Q
    _141.d2 = q;
    if (q > 0) 
    goto _jump1437;
    fail_assertion("non-positive loop bound");
    _jump1437:;
    // Computing total size of heap memory to allocate
    int64_t _144 = 1;
    _144 *= D;
    _144 *= _142;
    _144 *= q;
    _144 *= sizeof(_a2_rgba);
    _141.data = jpl_alloc(_144);
    int64_t _145 = 0; // Q
    int64_t _146 = 0; // P
    int64_t _147 = 0; // O
    _jump1438:; // Begin body of loop
    bool _148 = true;
    _a2_rgba _149;
    if (!_148)
    goto _jump1439;
    _149 = w;
    goto _jump1440;
    _jump1439:;
    _149 = t;
    _jump1440:;
    int64_t _150 = 0;
    _150 *= _141.d0;
    _150 += _147;
    _150 *= _141.d1;
    _150 += _146;
    _150 *= _141.d2;
    _150 += _145;
    _141.data[_150] = _149;
    _145++;
    if (_145 < q)
    goto _jump1438;
    _145 = 0;
    _146++;
    if (_146 < _142)
    goto _jump1438;
    _146 = 0;
    _147++;
    if (_147 < D)
    goto _jump1438;
    // End body of loop
    int64_t _151 = 730;
    if (j >= 0)
    goto _jump1441;
    fail_assertion("negative array index");
    _jump1441:;
    if (j < _141.d0)
    goto _jump1442;
    fail_assertion("index too large");
    _jump1442:;
    if (s >= 0)
    goto _jump1443;
    fail_assertion("negative array index");
    _jump1443:;
    if (s < _141.d1)
    goto _jump1444;
    fail_assertion("index too large");
    _jump1444:;
    if (_151 >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (_151 < _141.d2)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    int64_t _152 = 0;
    _152 *= _141.d0;
    _152 += j;
    _152 *= _141.d1;
    _152 += s;
    _152 *= _141.d2;
    _152 += _151;
    _a2_rgba _153 = _141.data[_152];
    if (g >= 0)
    goto _jump1447;
    fail_assertion("negative array index");
    _jump1447:;
    if (g < _153.d0)
    goto _jump1448;
    fail_assertion("index too large");
    _jump1448:;
    if (I >= 0)
    goto _jump1449;
    fail_assertion("negative array index");
    _jump1449:;
    if (I < _153.d1)
    goto _jump1450;
    fail_assertion("index too large");
    _jump1450:;
    int64_t _154 = 0;
    _154 *= _153.d0;
    _154 += g;
    _154 *= _153.d1;
    _154 += I;
    rgba _155 = _153.data[_154];
    double _156 = _155.b;
    _a1_double _157;
    if (!r)
    goto _jump1451;
    double _158 = 53.0;
    double _159 = -_158;
    double _160 = 33.0;
    _a1_double _161;
    _161.d0 = 2;
    _161.data = jpl_alloc(sizeof(double) * 2);
    _161.data[0] = _159;
    _161.data[1] = _160;
    _157 = _161;
    goto _jump1452;
    _jump1451:;
    double _162 = 92.0;
    double _163;
    // Computing bound for O
    if (v > 0) 
    goto _jump1453;
    fail_assertion("non-positive loop bound");
    _jump1453:;
    _163 = 0;
    int64_t _164 = 0; // O
    _jump1454:; // Begin body of loop
    double _165 = 13.0;
    _163 += _165;
    _164++;
    if (_164 < v)
    goto _jump1454;
    // End body of loop
    double _166 = 79.0;
    double _167 = -_166;
    _a1_double _168;
    _168.d0 = 3;
    _168.data = jpl_alloc(sizeof(double) * 3);
    _168.data[0] = _162;
    _168.data[1] = _163;
    _168.data[2] = _167;
    _157 = _168;
    _jump1452:;
    bool _169 = G();
    bool _170;
    if (!_169)
    goto _jump1455;
    bool _171 = G();
    _170 = _171;
    goto _jump1456;
    _jump1455:;
    bool _172 = false;
    _170 = _172;
    _jump1456:;
    bool _173;
    if (!_170)
    goto _jump1457;
    bool _174 = false;
    _173 = _174;
    goto _jump1458;
    _jump1457:;
    bool _175 = g != l;
    _173 = _175;
    _jump1458:;
    int64_t _176;
    if (!_173)
    goto _jump1459;
    int64_t _177 = 558;
    _176 = _177;
    goto _jump1460;
    _jump1459:;
    _176 = v;
    _jump1460:;
    if (_176 >= 0)
    goto _jump1461;
    fail_assertion("negative array index");
    _jump1461:;
    if (_176 < _157.d0)
    goto _jump1462;
    fail_assertion("index too large");
    _jump1462:;
    int64_t _178 = 0;
    _178 *= _157.d0;
    _178 += _176;
    double _179 = _157.data[_178];
    _a3__a2_bool _180;
    // Computing bound for O
    int64_t _181 = 895;
    _180.d0 = _181;
    if (_181 > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing bound for P
    int64_t _182 = q + s;
    _180.d1 = _182;
    if (_182 > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing bound for Q
    _180.d2 = j;
    if (j > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= _181;
    _183 *= _182;
    _183 *= j;
    _183 *= sizeof(_a2_bool);
    _180.data = jpl_alloc(_183);
    int64_t _184 = 0; // Q
    int64_t _185 = 0; // P
    int64_t _186 = 0; // O
    _jump1466:; // Begin body of loop
    _a2_bool _187;
    // Computing bound for R
    _187.d0 = n;
    if (n > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    // Computing bound for S
    _187.d1 = B;
    if (B > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= n;
    _188 *= B;
    _188 *= sizeof(bool);
    _187.data = jpl_alloc(_188);
    int64_t _189 = 0; // S
    int64_t _190 = 0; // R
    _jump1469:; // Begin body of loop
    bool _191 = G();
    int64_t _192 = 0;
    _192 *= _187.d0;
    _192 += _190;
    _192 *= _187.d1;
    _192 += _189;
    _187.data[_192] = _191;
    _189++;
    if (_189 < B)
    goto _jump1469;
    _189 = 0;
    _190++;
    if (_190 < n)
    goto _jump1469;
    // End body of loop
    int64_t _193 = 0;
    _193 *= _180.d0;
    _193 += _186;
    _193 *= _180.d1;
    _193 += _185;
    _193 *= _180.d2;
    _193 += _184;
    _180.data[_193] = _187;
    _184++;
    if (_184 < j)
    goto _jump1466;
    _184 = 0;
    _185++;
    if (_185 < _182)
    goto _jump1466;
    _185 = 0;
    _186++;
    if (_186 < _181)
    goto _jump1466;
    // End body of loop
    if (d >= 0)
    goto _jump1470;
    fail_assertion("negative array index");
    _jump1470:;
    if (d < _180.d0)
    goto _jump1471;
    fail_assertion("index too large");
    _jump1471:;
    if (k >= 0)
    goto _jump1472;
    fail_assertion("negative array index");
    _jump1472:;
    if (k < _180.d1)
    goto _jump1473;
    fail_assertion("index too large");
    _jump1473:;
    if (j >= 0)
    goto _jump1474;
    fail_assertion("negative array index");
    _jump1474:;
    if (j < _180.d2)
    goto _jump1475;
    fail_assertion("index too large");
    _jump1475:;
    int64_t _194 = 0;
    _194 *= _180.d0;
    _194 += d;
    _194 *= _180.d1;
    _194 += k;
    _194 *= _180.d2;
    _194 += j;
    _a2_bool _195 = _180.data[_194];
    double _196 = a(_179, _195);
    bool _197 = _156 > _196;
    bool _198 = true;
    double _200 = 15.0;
    double _201 = -_200;
    double _202 = K(L, M);
    double _203 = -_202;
    double _204 = 90.0;
    bool _205 = G();
    double _206;
    if (!_205)
    goto _jump1476;
    double _207 = 90.0;
    _206 = _207;
    goto _jump1477;
    _jump1476:;
    double _208 = 59.0;
    _206 = _208;
    _jump1477:;
    double _209 = -_206;
    rgba _210 = { _201, _203, _204, _209 };
    _a1_rgba _211;
    _211.d0 = 1;
    _211.data = jpl_alloc(sizeof(rgba) * 1);
    _211.data[0] = _210;
    _a3_rgba _212;
    // Computing bound for O
    _212.d0 = k;
    if (k > 0) 
    goto _jump1478;
    fail_assertion("non-positive loop bound");
    _jump1478:;
    // Computing bound for P
    _212.d1 = g;
    if (g > 0) 
    goto _jump1479;
    fail_assertion("non-positive loop bound");
    _jump1479:;
    // Computing bound for Q
    _212.d2 = I;
    if (I > 0) 
    goto _jump1480;
    fail_assertion("non-positive loop bound");
    _jump1480:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= k;
    _213 *= g;
    _213 *= I;
    _213 *= sizeof(rgba);
    _212.data = jpl_alloc(_213);
    int64_t _214 = 0; // Q
    int64_t _215 = 0; // P
    int64_t _216 = 0; // O
    _jump1481:; // Begin body of loop
    double _217;
    // Computing bound for R
    if (h > 0) 
    goto _jump1482;
    fail_assertion("non-positive loop bound");
    _jump1482:;
    // Computing bound for S
    if (c > 0) 
    goto _jump1483;
    fail_assertion("non-positive loop bound");
    _jump1483:;
    // Computing bound for T
    int64_t _218 = 967;
    if (_218 > 0) 
    goto _jump1484;
    fail_assertion("non-positive loop bound");
    _jump1484:;
    _217 = 0;
    int64_t _219 = 0; // T
    int64_t _220 = 0; // S
    int64_t _221 = 0; // R
    _jump1485:; // Begin body of loop
    double _222 = 68.0;
    _217 += _222;
    _219++;
    if (_219 < _218)
    goto _jump1485;
    _219 = 0;
    _220++;
    if (_220 < c)
    goto _jump1485;
    _220 = 0;
    _221++;
    if (_221 < h)
    goto _jump1485;
    // End body of loop
    double _223 = K(L, M);
    double _224 = _217 * _223;
    if (I >= 0)
    goto _jump1486;
    fail_assertion("negative array index");
    _jump1486:;
    if (I < t.d0)
    goto _jump1487;
    fail_assertion("index too large");
    _jump1487:;
    if (g >= 0)
    goto _jump1488;
    fail_assertion("negative array index");
    _jump1488:;
    if (g < t.d1)
    goto _jump1489;
    fail_assertion("index too large");
    _jump1489:;
    int64_t _225 = 0;
    _225 *= t.d0;
    _225 += I;
    _225 *= t.d1;
    _225 += g;
    rgba _226 = t.data[_225];
    double _227 = _226.a;
    double _228 = 11.0;
    double _229 = 32.0;
    double _230 = fmod(_228, _229);
    _a2_bool _231;
    // Computing bound for R
    _231.d0 = E;
    if (E > 0) 
    goto _jump1490;
    fail_assertion("non-positive loop bound");
    _jump1490:;
    // Computing bound for S
    _231.d1 = j;
    if (j > 0) 
    goto _jump1491;
    fail_assertion("non-positive loop bound");
    _jump1491:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= E;
    _232 *= j;
    _232 *= sizeof(bool);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // S
    int64_t _234 = 0; // R
    _jump1492:; // Begin body of loop
    bool _235 = G();
    int64_t _236 = 0;
    _236 *= _231.d0;
    _236 += _234;
    _236 *= _231.d1;
    _236 += _233;
    _231.data[_236] = _235;
    _233++;
    if (_233 < j)
    goto _jump1492;
    _233 = 0;
    _234++;
    if (_234 < E)
    goto _jump1492;
    // End body of loop
    double _237 = a(_230, _231);
    double _238;
    if (!r)
    goto _jump1493;
    double _239 = 64.0;
    _238 = _239;
    goto _jump1494;
    _jump1493:;
    double _240 = 57.0;
    _238 = _240;
    _jump1494:;
    _a2_bool _241;
    // Computing bound for R
    _241.d0 = v;
    if (v > 0) 
    goto _jump1495;
    fail_assertion("non-positive loop bound");
    _jump1495:;
    // Computing bound for S
    _241.d1 = c;
    if (c > 0) 
    goto _jump1496;
    fail_assertion("non-positive loop bound");
    _jump1496:;
    // Computing total size of heap memory to allocate
    int64_t _242 = 1;
    _242 *= v;
    _242 *= c;
    _242 *= sizeof(bool);
    _241.data = jpl_alloc(_242);
    int64_t _243 = 0; // S
    int64_t _244 = 0; // R
    _jump1497:; // Begin body of loop
    int64_t _245 = 0;
    _245 *= _241.d0;
    _245 += _244;
    _245 *= _241.d1;
    _245 += _243;
    _241.data[_245] = r;
    _243++;
    if (_243 < c)
    goto _jump1497;
    _243 = 0;
    _244++;
    if (_244 < v)
    goto _jump1497;
    // End body of loop
    double _246 = a(_238, _241);
    rgba _247 = { _224, _227, _237, _246 };
    int64_t _248 = 0;
    _248 *= _212.d0;
    _248 += _216;
    _248 *= _212.d1;
    _248 += _215;
    _248 *= _212.d2;
    _248 += _214;
    _212.data[_248] = _247;
    _214++;
    if (_214 < I)
    goto _jump1481;
    _214 = 0;
    _215++;
    if (_215 < g)
    goto _jump1481;
    _215 = 0;
    _216++;
    if (_216 < k)
    goto _jump1481;
    // End body of loop
    bool _249 = e(_211, _212);
    bool _199 = _249;
    if (0 != _249)
    goto _jump1498;
    _199 = r;
    _jump1498:;
    _a1_bool _250;
    _250.d0 = 3;
    _250.data = jpl_alloc(sizeof(bool) * 3);
    _250.data[0] = _197;
    _250.data[1] = _198;
    _250.data[2] = _199;
    _a3__a2_double _251;
    // Computing bound for Q
    _251.d0 = B;
    if (B > 0) 
    goto _jump1499;
    fail_assertion("non-positive loop bound");
    _jump1499:;
    // Computing bound for R
    _251.d1 = g;
    if (g > 0) 
    goto _jump1500;
    fail_assertion("non-positive loop bound");
    _jump1500:;
    // Computing bound for S
    int64_t _252 = d + d;
    _251.d2 = _252;
    if (_252 > 0) 
    goto _jump1501;
    fail_assertion("non-positive loop bound");
    _jump1501:;
    // Computing total size of heap memory to allocate
    int64_t _253 = 1;
    _253 *= B;
    _253 *= g;
    _253 *= _252;
    _253 *= sizeof(_a2_double);
    _251.data = jpl_alloc(_253);
    int64_t _254 = 0; // S
    int64_t _255 = 0; // R
    int64_t _256 = 0; // Q
    _jump1502:; // Begin body of loop
    _a2_double _257;
    // Computing bound for T
    _a3_int64_t _258;
    // Computing bound for T
    _258.d0 = _256;
    if (_256 > 0) 
    goto _jump1503;
    fail_assertion("non-positive loop bound");
    _jump1503:;
    // Computing bound for U
    int64_t _259 = 630;
    _258.d1 = _259;
    if (_259 > 0) 
    goto _jump1504;
    fail_assertion("non-positive loop bound");
    _jump1504:;
    // Computing bound for V
    _258.d2 = g;
    if (g > 0) 
    goto _jump1505;
    fail_assertion("non-positive loop bound");
    _jump1505:;
    // Computing total size of heap memory to allocate
    int64_t _260 = 1;
    _260 *= _256;
    _260 *= _259;
    _260 *= g;
    _260 *= sizeof(int64_t);
    _258.data = jpl_alloc(_260);
    int64_t _261 = 0; // V
    int64_t _262 = 0; // U
    int64_t _263 = 0; // T
    _jump1506:; // Begin body of loop
    int64_t _264 = 0;
    _264 *= _258.d0;
    _264 += _263;
    _264 *= _258.d1;
    _264 += _262;
    _264 *= _258.d2;
    _264 += _261;
    _258.data[_264] = _261;
    _261++;
    if (_261 < g)
    goto _jump1506;
    _261 = 0;
    _262++;
    if (_262 < _259)
    goto _jump1506;
    _262 = 0;
    _263++;
    if (_263 < _256)
    goto _jump1506;
    // End body of loop
    if (B >= 0)
    goto _jump1507;
    fail_assertion("negative array index");
    _jump1507:;
    if (B < _258.d0)
    goto _jump1508;
    fail_assertion("index too large");
    _jump1508:;
    if (n >= 0)
    goto _jump1509;
    fail_assertion("negative array index");
    _jump1509:;
    if (n < _258.d1)
    goto _jump1510;
    fail_assertion("index too large");
    _jump1510:;
    if (q >= 0)
    goto _jump1511;
    fail_assertion("negative array index");
    _jump1511:;
    if (q < _258.d2)
    goto _jump1512;
    fail_assertion("index too large");
    _jump1512:;
    int64_t _265 = 0;
    _265 *= _258.d0;
    _265 += B;
    _265 *= _258.d1;
    _265 += n;
    _265 *= _258.d2;
    _265 += q;
    int64_t _266 = _258.data[_265];
    _257.d0 = _266;
    if (_266 > 0) 
    goto _jump1513;
    fail_assertion("non-positive loop bound");
    _jump1513:;
    // Computing bound for U
    _257.d1 = E;
    if (E > 0) 
    goto _jump1514;
    fail_assertion("non-positive loop bound");
    _jump1514:;
    // Computing total size of heap memory to allocate
    int64_t _267 = 1;
    _267 *= _266;
    _267 *= E;
    _267 *= sizeof(double);
    _257.data = jpl_alloc(_267);
    int64_t _268 = 0; // U
    int64_t _269 = 0; // T
    _jump1515:; // Begin body of loop
    double _270 = 67.0;
    int64_t _271 = 0;
    _271 *= _257.d0;
    _271 += _269;
    _271 *= _257.d1;
    _271 += _268;
    _257.data[_271] = _270;
    _268++;
    if (_268 < E)
    goto _jump1515;
    _268 = 0;
    _269++;
    if (_269 < _266)
    goto _jump1515;
    // End body of loop
    int64_t _272 = 0;
    _272 *= _251.d0;
    _272 += _256;
    _272 *= _251.d1;
    _272 += _255;
    _272 *= _251.d2;
    _272 += _254;
    _251.data[_272] = _257;
    _254++;
    if (_254 < _252)
    goto _jump1502;
    _254 = 0;
    _255++;
    if (_255 < g)
    goto _jump1502;
    _255 = 0;
    _256++;
    if (_256 < B)
    goto _jump1502;
    // End body of loop
    bool _273 = G();
    _a1_int64_t _274;
    if (!_273)
    goto _jump1516;
    _274 = A;
    goto _jump1517;
    _jump1516:;
    bool _275 = G();
    bool _276 = !_275;
    _a1_int64_t _277;
    if (!_276)
    goto _jump1518;
    _277 = A;
    goto _jump1519;
    _jump1518:;
    _a1_int64_t _278;
    _278.d0 = 1;
    _278.data = jpl_alloc(sizeof(int64_t) * 1);
    _278.data[0] = B;
    _277 = _278;
    _jump1519:;
    _274 = _277;
    _jump1517:;
    if (v >= 0)
    goto _jump1520;
    fail_assertion("negative array index");
    _jump1520:;
    if (v < _274.d0)
    goto _jump1521;
    fail_assertion("index too large");
    _jump1521:;
    int64_t _279 = 0;
    _279 *= _274.d0;
    _279 += v;
    int64_t _280 = _274.data[_279];
    int64_t _281 = -k;
    if (_280 >= 0)
    goto _jump1522;
    fail_assertion("negative array index");
    _jump1522:;
    if (_280 < _251.d0)
    goto _jump1523;
    fail_assertion("index too large");
    _jump1523:;
    if (_281 >= 0)
    goto _jump1524;
    fail_assertion("negative array index");
    _jump1524:;
    if (_281 < _251.d1)
    goto _jump1525;
    fail_assertion("index too large");
    _jump1525:;
    if (s >= 0)
    goto _jump1526;
    fail_assertion("negative array index");
    _jump1526:;
    if (s < _251.d2)
    goto _jump1527;
    fail_assertion("index too large");
    _jump1527:;
    int64_t _282 = 0;
    _282 *= _251.d0;
    _282 += _280;
    _282 *= _251.d1;
    _282 += _281;
    _282 *= _251.d2;
    _282 += s;
    _a2_double _283 = _251.data[_282];
    if (q >= 0)
    goto _jump1528;
    fail_assertion("negative array index");
    _jump1528:;
    if (q < _283.d0)
    goto _jump1529;
    fail_assertion("index too large");
    _jump1529:;
    if (k >= 0)
    goto _jump1530;
    fail_assertion("negative array index");
    _jump1530:;
    if (k < _283.d1)
    goto _jump1531;
    fail_assertion("index too large");
    _jump1531:;
    int64_t _284 = 0;
    _284 *= _283.d0;
    _284 += q;
    _284 *= _283.d1;
    _284 += k;
    double _285 = _283.data[_284];
    _a3_void_t _286;
    if (!r)
    goto _jump1532;
    _286 = L;
    goto _jump1533;
    _jump1532:;
    _a3_void_t _287;
    // Computing bound for Q
    _287.d0 = s;
    if (s > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    // Computing bound for R
    int64_t _288 = 165;
    _287.d1 = _288;
    if (_288 > 0) 
    goto _jump1535;
    fail_assertion("non-positive loop bound");
    _jump1535:;
    // Computing bound for S
    _287.d2 = n;
    if (n > 0) 
    goto _jump1536;
    fail_assertion("non-positive loop bound");
    _jump1536:;
    // Computing total size of heap memory to allocate
    int64_t _289 = 1;
    _289 *= s;
    _289 *= _288;
    _289 *= n;
    _289 *= sizeof(void_t);
    _287.data = jpl_alloc(_289);
    int64_t _290 = 0; // S
    int64_t _291 = 0; // R
    int64_t _292 = 0; // Q
    _jump1537:; // Begin body of loop
    _a3_void_t _293;
    // Computing bound for T
    _293.d0 = I;
    if (I > 0) 
    goto _jump1538;
    fail_assertion("non-positive loop bound");
    _jump1538:;
    // Computing bound for U
    _293.d1 = l;
    if (l > 0) 
    goto _jump1539;
    fail_assertion("non-positive loop bound");
    _jump1539:;
    // Computing bound for V
    _293.d2 = k;
    if (k > 0) 
    goto _jump1540;
    fail_assertion("non-positive loop bound");
    _jump1540:;
    // Computing total size of heap memory to allocate
    int64_t _294 = 1;
    _294 *= I;
    _294 *= l;
    _294 *= k;
    _294 *= sizeof(void_t);
    _293.data = jpl_alloc(_294);
    int64_t _295 = 0; // V
    int64_t _296 = 0; // U
    int64_t _297 = 0; // T
    _jump1541:; // Begin body of loop
    void_t _298 = z(w);
    int64_t _299 = 0;
    _299 *= _293.d0;
    _299 += _297;
    _299 *= _293.d1;
    _299 += _296;
    _299 *= _293.d2;
    _299 += _295;
    _293.data[_299] = _298;
    _295++;
    if (_295 < k)
    goto _jump1541;
    _295 = 0;
    _296++;
    if (_296 < l)
    goto _jump1541;
    _296 = 0;
    _297++;
    if (_297 < I)
    goto _jump1541;
    // End body of loop
    if (n >= 0)
    goto _jump1542;
    fail_assertion("negative array index");
    _jump1542:;
    if (n < _293.d0)
    goto _jump1543;
    fail_assertion("index too large");
    _jump1543:;
    if (c >= 0)
    goto _jump1544;
    fail_assertion("negative array index");
    _jump1544:;
    if (c < _293.d1)
    goto _jump1545;
    fail_assertion("index too large");
    _jump1545:;
    if (E >= 0)
    goto _jump1546;
    fail_assertion("negative array index");
    _jump1546:;
    if (E < _293.d2)
    goto _jump1547;
    fail_assertion("index too large");
    _jump1547:;
    int64_t _300 = 0;
    _300 *= _293.d0;
    _300 += n;
    _300 *= _293.d1;
    _300 += c;
    _300 *= _293.d2;
    _300 += E;
    void_t _301 = _293.data[_300];
    int64_t _302 = 0;
    _302 *= _287.d0;
    _302 += _292;
    _302 *= _287.d1;
    _302 += _291;
    _302 *= _287.d2;
    _302 += _290;
    _287.data[_302] = _301;
    _290++;
    if (_290 < n)
    goto _jump1537;
    _290 = 0;
    _291++;
    if (_291 < _288)
    goto _jump1537;
    _291 = 0;
    _292++;
    if (_292 < s)
    goto _jump1537;
    // End body of loop
    _286 = _287;
    _jump1533:;
    double _303 = K(_286, M);
    bool _304 = _285 >= _303;
    if (0 != _304)
    goto _jump1548;
    fail_assertion("Q");
    _jump1548:;
    double _305 = 49.0;
    double _306 = 96.0;
    double _307 = -_306;
    _a2_bool _308;
    // Computing bound for Q
    _308.d0 = d;
    if (d > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    // Computing bound for R
    _308.d1 = _250.d0;
    if (_250.d0 > 0) 
    goto _jump1550;
    fail_assertion("non-positive loop bound");
    _jump1550:;
    // Computing total size of heap memory to allocate
    int64_t _309 = 1;
    _309 *= d;
    _309 *= _250.d0;
    _309 *= sizeof(bool);
    _308.data = jpl_alloc(_309);
    int64_t _310 = 0; // R
    int64_t _311 = 0; // Q
    _jump1551:; // Begin body of loop
    bool _312 = false;
    bool _313 = !_312;
    int64_t _314 = 0;
    _314 *= _308.d0;
    _314 += _311;
    _314 *= _308.d1;
    _314 += _310;
    _308.data[_314] = _313;
    _310++;
    if (_310 < _250.d0)
    goto _jump1551;
    _310 = 0;
    _311++;
    if (_311 < d)
    goto _jump1551;
    // End body of loop
    double _315 = a(_307, _308);
    double _316 = 71.0;
    double _317 = -_316;
    double _318 = fmod(_315, _317);
    bool _319 = _305 < _318;
    _a2__a1__a2__a1_int64_t _320;
    if (!_319)
    goto _jump1552;
    _320 = f;
    goto _jump1553;
    _jump1552:;
    _320 = f;
    _jump1553:;
    int64_t _321 = 980;
    if (_321 >= 0)
    goto _jump1554;
    fail_assertion("negative array index");
    _jump1554:;
    if (_321 < _320.d0)
    goto _jump1555;
    fail_assertion("index too large");
    _jump1555:;
    if (g >= 0)
    goto _jump1556;
    fail_assertion("negative array index");
    _jump1556:;
    if (g < _320.d1)
    goto _jump1557;
    fail_assertion("index too large");
    _jump1557:;
    int64_t _322 = 0;
    _322 *= _320.d0;
    _322 += _321;
    _322 *= _320.d1;
    _322 += g;
    _a1__a2__a1_int64_t _323 = _320.data[_322];
    bool _324 = true;
    _a3_void_t _325;
    if (!_324)
    goto _jump1558;
    bool _326 = true;
    _a3_void_t _327;
    if (!_326)
    goto _jump1559;
    _a3_void_t _328;
    if (!r)
    goto _jump1560;
    bool _329 = G();
    bool _330;
    if (!_329)
    goto _jump1561;
    _330 = r;
    goto _jump1562;
    _jump1561:;
    bool _331 = true;
    _330 = _331;
    _jump1562:;
    _a3_void_t _332;
    if (!_330)
    goto _jump1563;
    _332 = L;
    goto _jump1564;
    _jump1563:;
    _332 = L;
    _jump1564:;
    _328 = _332;
    goto _jump1565;
    _jump1560:;
    bool _333 = G();
    _a3_void_t _334;
    if (!_333)
    goto _jump1566;
    _334 = L;
    goto _jump1567;
    _jump1566:;
    _a3_void_t _335;
    // Computing bound for S
    _335.d0 = y;
    if (y > 0) 
    goto _jump1568;
    fail_assertion("non-positive loop bound");
    _jump1568:;
    // Computing bound for T
    _335.d1 = u;
    if (u > 0) 
    goto _jump1569;
    fail_assertion("non-positive loop bound");
    _jump1569:;
    // Computing bound for U
    int64_t _336 = q + g;
    _335.d2 = _336;
    if (_336 > 0) 
    goto _jump1570;
    fail_assertion("non-positive loop bound");
    _jump1570:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= y;
    _337 *= u;
    _337 *= _336;
    _337 *= sizeof(void_t);
    _335.data = jpl_alloc(_337);
    int64_t _338 = 0; // U
    int64_t _339 = 0; // T
    int64_t _340 = 0; // S
    _jump1571:; // Begin body of loop
    if (I >= 0)
    goto _jump1572;
    fail_assertion("negative array index");
    _jump1572:;
    if (I < M.d0)
    goto _jump1573;
    fail_assertion("index too large");
    _jump1573:;
    int64_t _341 = 0;
    _341 *= M.d0;
    _341 += I;
    void_t _342 = M.data[_341];
    int64_t _343 = 0;
    _343 *= _335.d0;
    _343 += _340;
    _343 *= _335.d1;
    _343 += _339;
    _343 *= _335.d2;
    _343 += _338;
    _335.data[_343] = _342;
    _338++;
    if (_338 < _336)
    goto _jump1571;
    _338 = 0;
    _339++;
    if (_339 < u)
    goto _jump1571;
    _339 = 0;
    _340++;
    if (_340 < y)
    goto _jump1571;
    // End body of loop
    _334 = _335;
    _jump1567:;
    _328 = _334;
    _jump1565:;
    _327 = _328;
    goto _jump1574;
    _jump1559:;
    _a3_void_t _344;
    // Computing bound for S
    _344.d0 = g;
    if (g > 0) 
    goto _jump1575;
    fail_assertion("non-positive loop bound");
    _jump1575:;
    // Computing bound for T
    _344.d1 = y;
    if (y > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    // Computing bound for U
    _344.d2 = d;
    if (d > 0) 
    goto _jump1577;
    fail_assertion("non-positive loop bound");
    _jump1577:;
    // Computing total size of heap memory to allocate
    int64_t _345 = 1;
    _345 *= g;
    _345 *= y;
    _345 *= d;
    _345 *= sizeof(void_t);
    _344.data = jpl_alloc(_345);
    int64_t _346 = 0; // U
    int64_t _347 = 0; // T
    int64_t _348 = 0; // S
    _jump1578:; // Begin body of loop
    if (k >= 0)
    goto _jump1579;
    fail_assertion("negative array index");
    _jump1579:;
    if (k < L.d0)
    goto _jump1580;
    fail_assertion("index too large");
    _jump1580:;
    if (v >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (v < L.d1)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    if (q >= 0)
    goto _jump1583;
    fail_assertion("negative array index");
    _jump1583:;
    if (q < L.d2)
    goto _jump1584;
    fail_assertion("index too large");
    _jump1584:;
    int64_t _349 = 0;
    _349 *= L.d0;
    _349 += k;
    _349 *= L.d1;
    _349 += v;
    _349 *= L.d2;
    _349 += q;
    void_t _350 = L.data[_349];
    int64_t _351 = 0;
    _351 *= _344.d0;
    _351 += _348;
    _351 *= _344.d1;
    _351 += _347;
    _351 *= _344.d2;
    _351 += _346;
    _344.data[_351] = _350;
    _346++;
    if (_346 < d)
    goto _jump1578;
    _346 = 0;
    _347++;
    if (_347 < y)
    goto _jump1578;
    _347 = 0;
    _348++;
    if (_348 < g)
    goto _jump1578;
    // End body of loop
    _327 = _344;
    _jump1574:;
    _325 = _327;
    goto _jump1585;
    _jump1558:;
    bool _352 = G();
    _a3_bool _353;
    if (!_352)
    goto _jump1586;
    _a3_bool _354;
    // Computing bound for S
    _354.d0 = n;
    if (n > 0) 
    goto _jump1587;
    fail_assertion("non-positive loop bound");
    _jump1587:;
    // Computing bound for T
    _354.d1 = h;
    if (h > 0) 
    goto _jump1588;
    fail_assertion("non-positive loop bound");
    _jump1588:;
    // Computing bound for U
    _354.d2 = B;
    if (B > 0) 
    goto _jump1589;
    fail_assertion("non-positive loop bound");
    _jump1589:;
    // Computing total size of heap memory to allocate
    int64_t _355 = 1;
    _355 *= n;
    _355 *= h;
    _355 *= B;
    _355 *= sizeof(bool);
    _354.data = jpl_alloc(_355);
    int64_t _356 = 0; // U
    int64_t _357 = 0; // T
    int64_t _358 = 0; // S
    _jump1590:; // Begin body of loop
    bool _359 = l == B;
    int64_t _360 = 0;
    _360 *= _354.d0;
    _360 += _358;
    _360 *= _354.d1;
    _360 += _357;
    _360 *= _354.d2;
    _360 += _356;
    _354.data[_360] = _359;
    _356++;
    if (_356 < B)
    goto _jump1590;
    _356 = 0;
    _357++;
    if (_357 < h)
    goto _jump1590;
    _357 = 0;
    _358++;
    if (_358 < n)
    goto _jump1590;
    // End body of loop
    _353 = _354;
    goto _jump1591;
    _jump1586:;
    bool _361 = G();
    _a3_bool _362;
    if (!_361)
    goto _jump1592;
    _a3_bool _363;
    // Computing bound for S
    _363.d0 = M.d0;
    if (M.d0 > 0) 
    goto _jump1593;
    fail_assertion("non-positive loop bound");
    _jump1593:;
    // Computing bound for T
    _363.d1 = M.d0;
    if (M.d0 > 0) 
    goto _jump1594;
    fail_assertion("non-positive loop bound");
    _jump1594:;
    // Computing bound for U
    _363.d2 = j;
    if (j > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing total size of heap memory to allocate
    int64_t _364 = 1;
    _364 *= M.d0;
    _364 *= M.d0;
    _364 *= j;
    _364 *= sizeof(bool);
    _363.data = jpl_alloc(_364);
    int64_t _365 = 0; // U
    int64_t _366 = 0; // T
    int64_t _367 = 0; // S
    _jump1596:; // Begin body of loop
    int64_t _368 = 0;
    _368 *= _363.d0;
    _368 += _367;
    _368 *= _363.d1;
    _368 += _366;
    _368 *= _363.d2;
    _368 += _365;
    _363.data[_368] = r;
    _365++;
    if (_365 < j)
    goto _jump1596;
    _365 = 0;
    _366++;
    if (_366 < M.d0)
    goto _jump1596;
    _366 = 0;
    _367++;
    if (_367 < M.d0)
    goto _jump1596;
    // End body of loop
    _362 = _363;
    goto _jump1597;
    _jump1592:;
    _a3_bool _369;
    // Computing bound for S
    _369.d0 = u;
    if (u > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    // Computing bound for T
    _369.d1 = k;
    if (k > 0) 
    goto _jump1599;
    fail_assertion("non-positive loop bound");
    _jump1599:;
    // Computing bound for U
    _369.d2 = D;
    if (D > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing total size of heap memory to allocate
    int64_t _370 = 1;
    _370 *= u;
    _370 *= k;
    _370 *= D;
    _370 *= sizeof(bool);
    _369.data = jpl_alloc(_370);
    int64_t _371 = 0; // U
    int64_t _372 = 0; // T
    int64_t _373 = 0; // S
    _jump1601:; // Begin body of loop
    bool _374 = G();
    int64_t _375 = 0;
    _375 *= _369.d0;
    _375 += _373;
    _375 *= _369.d1;
    _375 += _372;
    _375 *= _369.d2;
    _375 += _371;
    _369.data[_375] = _374;
    _371++;
    if (_371 < D)
    goto _jump1601;
    _371 = 0;
    _372++;
    if (_372 < k)
    goto _jump1601;
    _372 = 0;
    _373++;
    if (_373 < u)
    goto _jump1601;
    // End body of loop
    _362 = _369;
    _jump1597:;
    _353 = _362;
    _jump1591:;
    if (d >= 0)
    goto _jump1602;
    fail_assertion("negative array index");
    _jump1602:;
    if (d < _353.d0)
    goto _jump1603;
    fail_assertion("index too large");
    _jump1603:;
    if (_250.d0 >= 0)
    goto _jump1604;
    fail_assertion("negative array index");
    _jump1604:;
    if (_250.d0 < _353.d1)
    goto _jump1605;
    fail_assertion("index too large");
    _jump1605:;
    if (g >= 0)
    goto _jump1606;
    fail_assertion("negative array index");
    _jump1606:;
    if (g < _353.d2)
    goto _jump1607;
    fail_assertion("index too large");
    _jump1607:;
    int64_t _376 = 0;
    _376 *= _353.d0;
    _376 += d;
    _376 *= _353.d1;
    _376 += _250.d0;
    _376 *= _353.d2;
    _376 += g;
    bool _377 = _353.data[_376];
    _a3_void_t _378;
    if (!_377)
    goto _jump1608;
    bool _379 = G();
    _a3_bool _380;
    // Computing bound for S
    _380.d0 = B;
    if (B > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing bound for T
    _380.d1 = _323.d0;
    if (_323.d0 > 0) 
    goto _jump1610;
    fail_assertion("non-positive loop bound");
    _jump1610:;
    // Computing bound for U
    _380.d2 = B;
    if (B > 0) 
    goto _jump1611;
    fail_assertion("non-positive loop bound");
    _jump1611:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= B;
    _381 *= _323.d0;
    _381 *= B;
    _381 *= sizeof(bool);
    _380.data = jpl_alloc(_381);
    int64_t _382 = 0; // U
    int64_t _383 = 0; // T
    int64_t _384 = 0; // S
    _jump1612:; // Begin body of loop
    bool _385 = false;
    int64_t _386 = 0;
    _386 *= _380.d0;
    _386 += _384;
    _386 *= _380.d1;
    _386 += _383;
    _386 *= _380.d2;
    _386 += _382;
    _380.data[_386] = _385;
    _382++;
    if (_382 < B)
    goto _jump1612;
    _382 = 0;
    _383++;
    if (_383 < _323.d0)
    goto _jump1612;
    _383 = 0;
    _384++;
    if (_384 < B)
    goto _jump1612;
    // End body of loop
    int64_t _387 = -g;
    int64_t _388 = 26;
    if (I >= 0)
    goto _jump1613;
    fail_assertion("negative array index");
    _jump1613:;
    if (I < _380.d0)
    goto _jump1614;
    fail_assertion("index too large");
    _jump1614:;
    if (_387 >= 0)
    goto _jump1615;
    fail_assertion("negative array index");
    _jump1615:;
    if (_387 < _380.d1)
    goto _jump1616;
    fail_assertion("index too large");
    _jump1616:;
    if (_388 >= 0)
    goto _jump1617;
    fail_assertion("negative array index");
    _jump1617:;
    if (_388 < _380.d2)
    goto _jump1618;
    fail_assertion("index too large");
    _jump1618:;
    int64_t _389 = 0;
    _389 *= _380.d0;
    _389 += I;
    _389 *= _380.d1;
    _389 += _387;
    _389 *= _380.d2;
    _389 += _388;
    bool _390 = _380.data[_389];
    bool _391 = _379 == _390;
    _a3_void_t _392;
    if (!_391)
    goto _jump1619;
    _392 = L;
    goto _jump1620;
    _jump1619:;
    _a3_void_t _393;
    // Computing bound for S
    _a3_int64_t _394;
    // Computing bound for S
    _394.d0 = B;
    if (B > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    // Computing bound for T
    _394.d1 = M.d0;
    if (M.d0 > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    // Computing bound for U
    _394.d2 = _250.d0;
    if (_250.d0 > 0) 
    goto _jump1623;
    fail_assertion("non-positive loop bound");
    _jump1623:;
    // Computing total size of heap memory to allocate
    int64_t _395 = 1;
    _395 *= B;
    _395 *= M.d0;
    _395 *= _250.d0;
    _395 *= sizeof(int64_t);
    _394.data = jpl_alloc(_395);
    int64_t _396 = 0; // U
    int64_t _397 = 0; // T
    int64_t _398 = 0; // S
    _jump1624:; // Begin body of loop
    int64_t _399 = 0;
    _399 *= _394.d0;
    _399 += _398;
    _399 *= _394.d1;
    _399 += _397;
    _399 *= _394.d2;
    _399 += _396;
    _394.data[_399] = _250.d0;
    _396++;
    if (_396 < _250.d0)
    goto _jump1624;
    _396 = 0;
    _397++;
    if (_397 < M.d0)
    goto _jump1624;
    _397 = 0;
    _398++;
    if (_398 < B)
    goto _jump1624;
    // End body of loop
    if (_250.d0 >= 0)
    goto _jump1625;
    fail_assertion("negative array index");
    _jump1625:;
    if (_250.d0 < _394.d0)
    goto _jump1626;
    fail_assertion("index too large");
    _jump1626:;
    if (j >= 0)
    goto _jump1627;
    fail_assertion("negative array index");
    _jump1627:;
    if (j < _394.d1)
    goto _jump1628;
    fail_assertion("index too large");
    _jump1628:;
    if (M.d0 >= 0)
    goto _jump1629;
    fail_assertion("negative array index");
    _jump1629:;
    if (M.d0 < _394.d2)
    goto _jump1630;
    fail_assertion("index too large");
    _jump1630:;
    int64_t _400 = 0;
    _400 *= _394.d0;
    _400 += _250.d0;
    _400 *= _394.d1;
    _400 += j;
    _400 *= _394.d2;
    _400 += M.d0;
    int64_t _401 = _394.data[_400];
    _393.d0 = _401;
    if (_401 > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing bound for T
    int64_t _402 = -B;
    int64_t _403 = E + _402;
    _393.d1 = _403;
    if (_403 > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    // Computing bound for U
    bool _404;
    if (!r)
    goto _jump1633;
    _404 = r;
    goto _jump1634;
    _jump1633:;
    bool _405 = true;
    _404 = _405;
    _jump1634:;
    int64_t _406;
    if (!_404)
    goto _jump1635;
    _406 = s;
    goto _jump1636;
    _jump1635:;
    _406 = j;
    _jump1636:;
    _393.d2 = _406;
    if (_406 > 0) 
    goto _jump1637;
    fail_assertion("non-positive loop bound");
    _jump1637:;
    // Computing total size of heap memory to allocate
    int64_t _407 = 1;
    _407 *= _401;
    _407 *= _403;
    _407 *= _406;
    _407 *= sizeof(void_t);
    _393.data = jpl_alloc(_407);
    int64_t _408 = 0; // U
    int64_t _409 = 0; // T
    int64_t _410 = 0; // S
    _jump1638:; // Begin body of loop
    void_t _411 = z(w);
    int64_t _412 = 0;
    _412 *= _393.d0;
    _412 += _410;
    _412 *= _393.d1;
    _412 += _409;
    _412 *= _393.d2;
    _412 += _408;
    _393.data[_412] = _411;
    _408++;
    if (_408 < _406)
    goto _jump1638;
    _408 = 0;
    _409++;
    if (_409 < _403)
    goto _jump1638;
    _409 = 0;
    _410++;
    if (_410 < _401)
    goto _jump1638;
    // End body of loop
    _392 = _393;
    _jump1620:;
    _378 = _392;
    goto _jump1639;
    _jump1608:;
    _a2__a3_void_t _413;
    // Computing bound for S
    bool _414 = G();
    int64_t _415;
    if (!_414)
    goto _jump1640;
    _415 = c;
    goto _jump1641;
    _jump1640:;
    _415 = n;
    _jump1641:;
    _413.d0 = _415;
    if (_415 > 0) 
    goto _jump1642;
    fail_assertion("non-positive loop bound");
    _jump1642:;
    // Computing bound for T
    int64_t _416 = -I;
    _413.d1 = _416;
    if (_416 > 0) 
    goto _jump1643;
    fail_assertion("non-positive loop bound");
    _jump1643:;
    // Computing total size of heap memory to allocate
    int64_t _417 = 1;
    _417 *= _415;
    _417 *= _416;
    _417 *= sizeof(_a3_void_t);
    _413.data = jpl_alloc(_417);
    int64_t _418 = 0; // T
    int64_t _419 = 0; // S
    _jump1644:; // Begin body of loop
    _a3_void_t _420;
    // Computing bound for U
    _420.d0 = D;
    if (D > 0) 
    goto _jump1645;
    fail_assertion("non-positive loop bound");
    _jump1645:;
    // Computing bound for V
    if (k >= 0)
    goto _jump1646;
    fail_assertion("negative array index");
    _jump1646:;
    if (k < A.d0)
    goto _jump1647;
    fail_assertion("index too large");
    _jump1647:;
    int64_t _421 = 0;
    _421 *= A.d0;
    _421 += k;
    int64_t _422 = A.data[_421];
    _420.d1 = _422;
    if (_422 > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    // Computing bound for W
    _420.d2 = k;
    if (k > 0) 
    goto _jump1649;
    fail_assertion("non-positive loop bound");
    _jump1649:;
    // Computing total size of heap memory to allocate
    int64_t _423 = 1;
    _423 *= D;
    _423 *= _422;
    _423 *= k;
    _423 *= sizeof(void_t);
    _420.data = jpl_alloc(_423);
    int64_t _424 = 0; // W
    int64_t _425 = 0; // V
    int64_t _426 = 0; // U
    _jump1650:; // Begin body of loop
    void_t _427 = z(J);
    int64_t _428 = 0;
    _428 *= _420.d0;
    _428 += _426;
    _428 *= _420.d1;
    _428 += _425;
    _428 *= _420.d2;
    _428 += _424;
    _420.data[_428] = _427;
    _424++;
    if (_424 < k)
    goto _jump1650;
    _424 = 0;
    _425++;
    if (_425 < _422)
    goto _jump1650;
    _425 = 0;
    _426++;
    if (_426 < D)
    goto _jump1650;
    // End body of loop
    int64_t _429 = 0;
    _429 *= _413.d0;
    _429 += _419;
    _429 *= _413.d1;
    _429 += _418;
    _413.data[_429] = _420;
    _418++;
    if (_418 < _416)
    goto _jump1644;
    _418 = 0;
    _419++;
    if (_419 < _415)
    goto _jump1644;
    // End body of loop
    bool _430 = true;
    int64_t _431;
    if (!_430)
    goto _jump1651;
    int64_t _432;
    if (!r)
    goto _jump1652;
    _432 = _250.d0;
    goto _jump1653;
    _jump1652:;
    _432 = u;
    _jump1653:;
    _431 = _432;
    goto _jump1654;
    _jump1651:;
    _431 = _323.d0;
    _jump1654:;
    if (_431 >= 0)
    goto _jump1655;
    fail_assertion("negative array index");
    _jump1655:;
    if (_431 < _413.d0)
    goto _jump1656;
    fail_assertion("index too large");
    _jump1656:;
    if (M.d0 >= 0)
    goto _jump1657;
    fail_assertion("negative array index");
    _jump1657:;
    if (M.d0 < _413.d1)
    goto _jump1658;
    fail_assertion("index too large");
    _jump1658:;
    int64_t _433 = 0;
    _433 *= _413.d0;
    _433 += _431;
    _433 *= _413.d1;
    _433 += M.d0;
    _a3_void_t _434 = _413.data[_433];
    _378 = _434;
    _jump1639:;
    _325 = _378;
    _jump1585:;
    _a1_void_t _435;
    // Computing bound for S
    _435.d0 = j;
    if (j > 0) 
    goto _jump1659;
    fail_assertion("non-positive loop bound");
    _jump1659:;
    // Computing total size of heap memory to allocate
    int64_t _436 = 1;
    _436 *= j;
    _436 *= sizeof(void_t);
    _435.data = jpl_alloc(_436);
    int64_t _437 = 0; // S
    _jump1660:; // Begin body of loop
    _a2_bool _438;
    // Computing bound for T
    _438.d0 = _323.d0;
    if (_323.d0 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing bound for U
    _438.d1 = _323.d0;
    if (_323.d0 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= _323.d0;
    _439 *= _323.d0;
    _439 *= sizeof(bool);
    _438.data = jpl_alloc(_439);
    int64_t _440 = 0; // U
    int64_t _441 = 0; // T
    _jump1663:; // Begin body of loop
    int64_t _442 = 0;
    _442 *= _438.d0;
    _442 += _441;
    _442 *= _438.d1;
    _442 += _440;
    _438.data[_442] = r;
    _440++;
    if (_440 < _323.d0)
    goto _jump1663;
    _440 = 0;
    _441++;
    if (_441 < _323.d0)
    goto _jump1663;
    // End body of loop
    int64_t _443 = B / v;
    if (_443 >= 0)
    goto _jump1664;
    fail_assertion("negative array index");
    _jump1664:;
    if (_443 < _438.d0)
    goto _jump1665;
    fail_assertion("index too large");
    _jump1665:;
    if (c >= 0)
    goto _jump1666;
    fail_assertion("negative array index");
    _jump1666:;
    if (c < _438.d1)
    goto _jump1667;
    fail_assertion("index too large");
    _jump1667:;
    int64_t _444 = 0;
    _444 *= _438.d0;
    _444 += _443;
    _444 *= _438.d1;
    _444 += c;
    bool _445 = _438.data[_444];
    void_t _446;
    if (!_445)
    goto _jump1668;
    void_t _447 = z(w);
    _446 = _447;
    goto _jump1669;
    _jump1668:;
    void_t _448 = z(J);
    _a1_void_t _449;
    _449.d0 = 1;
    _449.data = jpl_alloc(sizeof(void_t) * 1);
    _449.data[0] = _448;
    int64_t _450 = 324;
    if (_450 >= 0)
    goto _jump1670;
    fail_assertion("negative array index");
    _jump1670:;
    if (_450 < _449.d0)
    goto _jump1671;
    fail_assertion("index too large");
    _jump1671:;
    int64_t _451 = 0;
    _451 *= _449.d0;
    _451 += _450;
    void_t _452 = _449.data[_451];
    _446 = _452;
    _jump1669:;
    int64_t _453 = 0;
    _453 *= _435.d0;
    _453 += _437;
    _435.data[_453] = _446;
    _437++;
    if (_437 < j)
    goto _jump1660;
    // End body of loop
    double _454 = K(_325, _435);
    return _454;
    bool _455 = true;
    _a3_double _456;
    if (!_455)
    goto _jump1672;
    if (c >= 0)
    goto _jump1673;
    fail_assertion("negative array index");
    _jump1673:;
    if (c < J.d0)
    goto _jump1674;
    fail_assertion("index too large");
    _jump1674:;
    if (_250.d0 >= 0)
    goto _jump1675;
    fail_assertion("negative array index");
    _jump1675:;
    if (_250.d0 < J.d1)
    goto _jump1676;
    fail_assertion("index too large");
    _jump1676:;
    int64_t _457 = 0;
    _457 *= J.d0;
    _457 += c;
    _457 *= J.d1;
    _457 += _250.d0;
    rgba _458 = J.data[_457];
    double _459 = _458.r;
    bool _460 = true;
    bool _461 = !_460;
    rgba _462;
    if (!_461)
    goto _jump1677;
    if (d >= 0)
    goto _jump1678;
    fail_assertion("negative array index");
    _jump1678:;
    if (d < w.d0)
    goto _jump1679;
    fail_assertion("index too large");
    _jump1679:;
    if (n >= 0)
    goto _jump1680;
    fail_assertion("negative array index");
    _jump1680:;
    if (n < w.d1)
    goto _jump1681;
    fail_assertion("index too large");
    _jump1681:;
    int64_t _463 = 0;
    _463 *= w.d0;
    _463 += d;
    _463 *= w.d1;
    _463 += n;
    rgba _464 = w.data[_463];
    _462 = _464;
    goto _jump1682;
    _jump1677:;
    if (E >= 0)
    goto _jump1683;
    fail_assertion("negative array index");
    _jump1683:;
    if (E < t.d0)
    goto _jump1684;
    fail_assertion("index too large");
    _jump1684:;
    if (u >= 0)
    goto _jump1685;
    fail_assertion("negative array index");
    _jump1685:;
    if (u < t.d1)
    goto _jump1686;
    fail_assertion("index too large");
    _jump1686:;
    int64_t _465 = 0;
    _465 *= t.d0;
    _465 += E;
    _465 *= t.d1;
    _465 += u;
    rgba _466 = t.data[_465];
    _462 = _466;
    _jump1682:;
    double _467 = _462.a;
    bool _468 = _459 != _467;
    _a3_double _469;
    if (!_468)
    goto _jump1687;
    _a3_double _470;
    // Computing bound for S
    _470.d0 = B;
    if (B > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing bound for T
    _470.d1 = q;
    if (q > 0) 
    goto _jump1689;
    fail_assertion("non-positive loop bound");
    _jump1689:;
    // Computing bound for U
    _470.d2 = _250.d0;
    if (_250.d0 > 0) 
    goto _jump1690;
    fail_assertion("non-positive loop bound");
    _jump1690:;
    // Computing total size of heap memory to allocate
    int64_t _471 = 1;
    _471 *= B;
    _471 *= q;
    _471 *= _250.d0;
    _471 *= sizeof(double);
    _470.data = jpl_alloc(_471);
    int64_t _472 = 0; // U
    int64_t _473 = 0; // T
    int64_t _474 = 0; // S
    _jump1691:; // Begin body of loop
    double _475 = 20.0;
    int64_t _476 = 0;
    _476 *= _470.d0;
    _476 += _474;
    _476 *= _470.d1;
    _476 += _473;
    _476 *= _470.d2;
    _476 += _472;
    _470.data[_476] = _475;
    _472++;
    if (_472 < _250.d0)
    goto _jump1691;
    _472 = 0;
    _473++;
    if (_473 < q)
    goto _jump1691;
    _473 = 0;
    _474++;
    if (_474 < B)
    goto _jump1691;
    // End body of loop
    _a1__a3_double _477;
    _477.d0 = 1;
    _477.data = jpl_alloc(sizeof(_a3_double) * 1);
    _477.data[0] = _470;
    if (d >= 0)
    goto _jump1692;
    fail_assertion("negative array index");
    _jump1692:;
    if (d < _477.d0)
    goto _jump1693;
    fail_assertion("index too large");
    _jump1693:;
    int64_t _478 = 0;
    _478 *= _477.d0;
    _478 += d;
    _a3_double _479 = _477.data[_478];
    _469 = _479;
    goto _jump1694;
    _jump1687:;
    bool _480 = false;
    _a3_double _481;
    if (!_480)
    goto _jump1695;
    _a3_double _482;
    // Computing bound for S
    _482.d0 = j;
    if (j > 0) 
    goto _jump1696;
    fail_assertion("non-positive loop bound");
    _jump1696:;
    // Computing bound for T
    _482.d1 = I;
    if (I > 0) 
    goto _jump1697;
    fail_assertion("non-positive loop bound");
    _jump1697:;
    // Computing bound for U
    _482.d2 = E;
    if (E > 0) 
    goto _jump1698;
    fail_assertion("non-positive loop bound");
    _jump1698:;
    // Computing total size of heap memory to allocate
    int64_t _483 = 1;
    _483 *= j;
    _483 *= I;
    _483 *= E;
    _483 *= sizeof(double);
    _482.data = jpl_alloc(_483);
    int64_t _484 = 0; // U
    int64_t _485 = 0; // T
    int64_t _486 = 0; // S
    _jump1699:; // Begin body of loop
    bool _487 = true;
    double _488;
    if (!_487)
    goto _jump1700;
    double _489 = 27.0;
    _488 = _489;
    goto _jump1701;
    _jump1700:;
    double _490 = 10.0;
    _488 = _490;
    _jump1701:;
    int64_t _491 = 0;
    _491 *= _482.d0;
    _491 += _486;
    _491 *= _482.d1;
    _491 += _485;
    _491 *= _482.d2;
    _491 += _484;
    _482.data[_491] = _488;
    _484++;
    if (_484 < E)
    goto _jump1699;
    _484 = 0;
    _485++;
    if (_485 < I)
    goto _jump1699;
    _485 = 0;
    _486++;
    if (_486 < j)
    goto _jump1699;
    // End body of loop
    _481 = _482;
    goto _jump1702;
    _jump1695:;
    _a3_double _492;
    // Computing bound for S
    _492.d0 = c;
    if (c > 0) 
    goto _jump1703;
    fail_assertion("non-positive loop bound");
    _jump1703:;
    // Computing bound for T
    _492.d1 = D;
    if (D > 0) 
    goto _jump1704;
    fail_assertion("non-positive loop bound");
    _jump1704:;
    // Computing bound for U
    _492.d2 = s;
    if (s > 0) 
    goto _jump1705;
    fail_assertion("non-positive loop bound");
    _jump1705:;
    // Computing total size of heap memory to allocate
    int64_t _493 = 1;
    _493 *= c;
    _493 *= D;
    _493 *= s;
    _493 *= sizeof(double);
    _492.data = jpl_alloc(_493);
    int64_t _494 = 0; // U
    int64_t _495 = 0; // T
    int64_t _496 = 0; // S
    _jump1706:; // Begin body of loop
    double _497 = 80.0;
    int64_t _498 = 0;
    _498 *= _492.d0;
    _498 += _496;
    _498 *= _492.d1;
    _498 += _495;
    _498 *= _492.d2;
    _498 += _494;
    _492.data[_498] = _497;
    _494++;
    if (_494 < s)
    goto _jump1706;
    _494 = 0;
    _495++;
    if (_495 < D)
    goto _jump1706;
    _495 = 0;
    _496++;
    if (_496 < c)
    goto _jump1706;
    // End body of loop
    _481 = _492;
    _jump1702:;
    _469 = _481;
    _jump1694:;
    _456 = _469;
    goto _jump1707;
    _jump1672:;
    _a3_double _499;
    // Computing bound for S
    _499.d0 = c;
    if (c > 0) 
    goto _jump1708;
    fail_assertion("non-positive loop bound");
    _jump1708:;
    // Computing bound for T
    _499.d1 = E;
    if (E > 0) 
    goto _jump1709;
    fail_assertion("non-positive loop bound");
    _jump1709:;
    // Computing bound for U
    _499.d2 = u;
    if (u > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    // Computing total size of heap memory to allocate
    int64_t _500 = 1;
    _500 *= c;
    _500 *= E;
    _500 *= u;
    _500 *= sizeof(double);
    _499.data = jpl_alloc(_500);
    int64_t _501 = 0; // U
    int64_t _502 = 0; // T
    int64_t _503 = 0; // S
    _jump1711:; // Begin body of loop
    if (h >= 0)
    goto _jump1712;
    fail_assertion("negative array index");
    _jump1712:;
    if (h < J.d0)
    goto _jump1713;
    fail_assertion("index too large");
    _jump1713:;
    if (_501 >= 0)
    goto _jump1714;
    fail_assertion("negative array index");
    _jump1714:;
    if (_501 < J.d1)
    goto _jump1715;
    fail_assertion("index too large");
    _jump1715:;
    int64_t _504 = 0;
    _504 *= J.d0;
    _504 += h;
    _504 *= J.d1;
    _504 += _501;
    rgba _505 = J.data[_504];
    if (n >= 0)
    goto _jump1716;
    fail_assertion("negative array index");
    _jump1716:;
    if (n < w.d0)
    goto _jump1717;
    fail_assertion("index too large");
    _jump1717:;
    if (q >= 0)
    goto _jump1718;
    fail_assertion("negative array index");
    _jump1718:;
    if (q < w.d1)
    goto _jump1719;
    fail_assertion("index too large");
    _jump1719:;
    int64_t _506 = 0;
    _506 *= w.d0;
    _506 += n;
    _506 *= w.d1;
    _506 += q;
    rgba _507 = w.data[_506];
    _a1_rgba _508;
    _508.d0 = 2;
    _508.data = jpl_alloc(sizeof(rgba) * 2);
    _508.data[0] = _505;
    _508.data[1] = _507;
    if (B >= 0)
    goto _jump1720;
    fail_assertion("negative array index");
    _jump1720:;
    if (B < _508.d0)
    goto _jump1721;
    fail_assertion("index too large");
    _jump1721:;
    int64_t _509 = 0;
    _509 *= _508.d0;
    _509 += B;
    rgba _510 = _508.data[_509];
    double _511 = _510.r;
    int64_t _512 = 0;
    _512 *= _499.d0;
    _512 += _503;
    _512 *= _499.d1;
    _512 += _502;
    _512 *= _499.d2;
    _512 += _501;
    _499.data[_512] = _511;
    _501++;
    if (_501 < u)
    goto _jump1711;
    _501 = 0;
    _502++;
    if (_502 < E)
    goto _jump1711;
    _502 = 0;
    _503++;
    if (_503 < c)
    goto _jump1711;
    // End body of loop
    _456 = _499;
    _jump1707:;
    double _514 = 80.0;
    double _515 = 40.0;
    double _516 = -_515;
    bool _517 = _514 == _516;
    bool _513 = _517;
    if (0 != _517)
    goto _jump1722;
    bool _518 = false;
    _a3_bool _519;
    if (!_518)
    goto _jump1723;
    _a3_bool _520;
    // Computing bound for S
    _520.d0 = h;
    if (h > 0) 
    goto _jump1724;
    fail_assertion("non-positive loop bound");
    _jump1724:;
    // Computing bound for T
    _520.d1 = E;
    if (E > 0) 
    goto _jump1725;
    fail_assertion("non-positive loop bound");
    _jump1725:;
    // Computing bound for U
    _520.d2 = B;
    if (B > 0) 
    goto _jump1726;
    fail_assertion("non-positive loop bound");
    _jump1726:;
    // Computing total size of heap memory to allocate
    int64_t _521 = 1;
    _521 *= h;
    _521 *= E;
    _521 *= B;
    _521 *= sizeof(bool);
    _520.data = jpl_alloc(_521);
    int64_t _522 = 0; // U
    int64_t _523 = 0; // T
    int64_t _524 = 0; // S
    _jump1727:; // Begin body of loop
    bool _525 = G();
    int64_t _526 = 0;
    _526 *= _520.d0;
    _526 += _524;
    _526 *= _520.d1;
    _526 += _523;
    _526 *= _520.d2;
    _526 += _522;
    _520.data[_526] = _525;
    _522++;
    if (_522 < B)
    goto _jump1727;
    _522 = 0;
    _523++;
    if (_523 < E)
    goto _jump1727;
    _523 = 0;
    _524++;
    if (_524 < h)
    goto _jump1727;
    // End body of loop
    _519 = _520;
    goto _jump1728;
    _jump1723:;
    _a3_bool _527;
    // Computing bound for S
    _527.d0 = y;
    if (y > 0) 
    goto _jump1729;
    fail_assertion("non-positive loop bound");
    _jump1729:;
    // Computing bound for T
    _527.d1 = I;
    if (I > 0) 
    goto _jump1730;
    fail_assertion("non-positive loop bound");
    _jump1730:;
    // Computing bound for U
    _527.d2 = M.d0;
    if (M.d0 > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    // Computing total size of heap memory to allocate
    int64_t _528 = 1;
    _528 *= y;
    _528 *= I;
    _528 *= M.d0;
    _528 *= sizeof(bool);
    _527.data = jpl_alloc(_528);
    int64_t _529 = 0; // U
    int64_t _530 = 0; // T
    int64_t _531 = 0; // S
    _jump1732:; // Begin body of loop
    bool _532 = G();
    int64_t _533 = 0;
    _533 *= _527.d0;
    _533 += _531;
    _533 *= _527.d1;
    _533 += _530;
    _533 *= _527.d2;
    _533 += _529;
    _527.data[_533] = _532;
    _529++;
    if (_529 < M.d0)
    goto _jump1732;
    _529 = 0;
    _530++;
    if (_530 < I)
    goto _jump1732;
    _530 = 0;
    _531++;
    if (_531 < y)
    goto _jump1732;
    // End body of loop
    _519 = _527;
    _jump1728:;
    if (D >= 0)
    goto _jump1733;
    fail_assertion("negative array index");
    _jump1733:;
    if (D < _519.d0)
    goto _jump1734;
    fail_assertion("index too large");
    _jump1734:;
    if (E >= 0)
    goto _jump1735;
    fail_assertion("negative array index");
    _jump1735:;
    if (E < _519.d1)
    goto _jump1736;
    fail_assertion("index too large");
    _jump1736:;
    if (c >= 0)
    goto _jump1737;
    fail_assertion("negative array index");
    _jump1737:;
    if (c < _519.d2)
    goto _jump1738;
    fail_assertion("index too large");
    _jump1738:;
    int64_t _534 = 0;
    _534 *= _519.d0;
    _534 += D;
    _534 *= _519.d1;
    _534 += E;
    _534 *= _519.d2;
    _534 += c;
    bool _535 = _519.data[_534];
    _513 = _535;
    _jump1722:;
    bool _536;
    if (!_513)
    goto _jump1739;
    _a3_bool _538;
    // Computing bound for S
    _538.d0 = y;
    if (y > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing bound for T
    _538.d1 = c;
    if (c > 0) 
    goto _jump1741;
    fail_assertion("non-positive loop bound");
    _jump1741:;
    // Computing bound for U
    _538.d2 = E;
    if (E > 0) 
    goto _jump1742;
    fail_assertion("non-positive loop bound");
    _jump1742:;
    // Computing total size of heap memory to allocate
    int64_t _539 = 1;
    _539 *= y;
    _539 *= c;
    _539 *= E;
    _539 *= sizeof(bool);
    _538.data = jpl_alloc(_539);
    int64_t _540 = 0; // U
    int64_t _541 = 0; // T
    int64_t _542 = 0; // S
    _jump1743:; // Begin body of loop
    bool _543 = G();
    int64_t _544 = 0;
    _544 *= _538.d0;
    _544 += _542;
    _544 *= _538.d1;
    _544 += _541;
    _544 *= _538.d2;
    _544 += _540;
    _538.data[_544] = _543;
    _540++;
    if (_540 < E)
    goto _jump1743;
    _540 = 0;
    _541++;
    if (_541 < c)
    goto _jump1743;
    _541 = 0;
    _542++;
    if (_542 < y)
    goto _jump1743;
    // End body of loop
    if (_250.d0 >= 0)
    goto _jump1744;
    fail_assertion("negative array index");
    _jump1744:;
    if (_250.d0 < _538.d0)
    goto _jump1745;
    fail_assertion("index too large");
    _jump1745:;
    if (q >= 0)
    goto _jump1746;
    fail_assertion("negative array index");
    _jump1746:;
    if (q < _538.d1)
    goto _jump1747;
    fail_assertion("index too large");
    _jump1747:;
    if (k >= 0)
    goto _jump1748;
    fail_assertion("negative array index");
    _jump1748:;
    if (k < _538.d2)
    goto _jump1749;
    fail_assertion("index too large");
    _jump1749:;
    int64_t _545 = 0;
    _545 *= _538.d0;
    _545 += _250.d0;
    _545 *= _538.d1;
    _545 += q;
    _545 *= _538.d2;
    _545 += k;
    bool _546 = _538.data[_545];
    bool _537 = _546;
    if (0 != _546)
    goto _jump1750;
    bool _547 = true;
    _537 = _547;
    _jump1750:;
    bool _548;
    if (!_537)
    goto _jump1751;
    bool _549 = true;
    _548 = _549;
    goto _jump1752;
    _jump1751:;
    bool _550 = G();
    _548 = _550;
    _jump1752:;
    _536 = _548;
    goto _jump1753;
    _jump1739:;
    _a2_bool _551;
    // Computing bound for S
    int64_t _552 = -g;
    _551.d0 = _552;
    if (_552 > 0) 
    goto _jump1754;
    fail_assertion("non-positive loop bound");
    _jump1754:;
    // Computing bound for T
    _551.d1 = B;
    if (B > 0) 
    goto _jump1755;
    fail_assertion("non-positive loop bound");
    _jump1755:;
    // Computing total size of heap memory to allocate
    int64_t _553 = 1;
    _553 *= _552;
    _553 *= B;
    _553 *= sizeof(bool);
    _551.data = jpl_alloc(_553);
    int64_t _554 = 0; // T
    int64_t _555 = 0; // S
    _jump1756:; // Begin body of loop
    bool _556 = l < I;
    int64_t _557 = 0;
    _557 *= _551.d0;
    _557 += _555;
    _557 *= _551.d1;
    _557 += _554;
    _551.data[_557] = _556;
    _554++;
    if (_554 < B)
    goto _jump1756;
    _554 = 0;
    _555++;
    if (_555 < _552)
    goto _jump1756;
    // End body of loop
    int64_t _558 = 750;
    if (_558 >= 0)
    goto _jump1757;
    fail_assertion("negative array index");
    _jump1757:;
    if (_558 < _551.d0)
    goto _jump1758;
    fail_assertion("index too large");
    _jump1758:;
    if (I >= 0)
    goto _jump1759;
    fail_assertion("negative array index");
    _jump1759:;
    if (I < _551.d1)
    goto _jump1760;
    fail_assertion("index too large");
    _jump1760:;
    int64_t _559 = 0;
    _559 *= _551.d0;
    _559 += _558;
    _559 *= _551.d1;
    _559 += I;
    bool _560 = _551.data[_559];
    _536 = _560;
    _jump1753:;
    int64_t _561;
    if (!_536)
    goto _jump1761;
    _561 = n;
    goto _jump1762;
    _jump1761:;
    int64_t _562 = -v;
    _561 = _562;
    _jump1762:;
    int64_t _563 = -M.d0;
    if (_561 >= 0)
    goto _jump1763;
    fail_assertion("negative array index");
    _jump1763:;
    if (_561 < _456.d0)
    goto _jump1764;
    fail_assertion("index too large");
    _jump1764:;
    if (_563 >= 0)
    goto _jump1765;
    fail_assertion("negative array index");
    _jump1765:;
    if (_563 < _456.d1)
    goto _jump1766;
    fail_assertion("index too large");
    _jump1766:;
    if (v >= 0)
    goto _jump1767;
    fail_assertion("negative array index");
    _jump1767:;
    if (v < _456.d2)
    goto _jump1768;
    fail_assertion("index too large");
    _jump1768:;
    int64_t _564 = 0;
    _564 *= _456.d0;
    _564 += _561;
    _564 *= _456.d1;
    _564 += _563;
    _564 *= _456.d2;
    _564 += v;
    double _565 = _456.data[_564];
    return _565;
}

void jpl_main(struct args args) {
    bool _0 = false;
    _a1__a2__a1_int64_t _1;
    if (!_0)
    goto _jump167;
    _a1__a1__a2__a1_int64_t _2;
    // Computing bound for b
    int64_t _3;
    // Computing bound for b
    int64_t _4;
    // Computing bound for b
    int64_t _5 = 649;
    if (_5 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    _4 = 0;
    int64_t _6 = 0; // b
    _jump169:; // Begin body of loop
    int64_t _7 = 732;
    _4 += _7;
    _6++;
    if (_6 < _5)
    goto _jump169;
    // End body of loop
    if (_4 > 0) 
    goto _jump170;
    fail_assertion("non-positive loop bound");
    _jump170:;
    // Computing bound for c
    int64_t _8;
    // Computing bound for b
    int64_t _9 = 290;
    if (_9 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing bound for c
    int64_t _10 = 579;
    if (_10 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    _8 = 0;
    int64_t _11 = 0; // c
    int64_t _12 = 0; // b
    _jump173:; // Begin body of loop
    _8 += _11;
    _11++;
    if (_11 < _10)
    goto _jump173;
    _11 = 0;
    _12++;
    if (_12 < _9)
    goto _jump173;
    // End body of loop
    if (_8 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    // Computing bound for d
    bool _13 = false;
    int64_t _14;
    if (!_13)
    goto _jump175;
    int64_t _15 = 764;
    _14 = _15;
    goto _jump176;
    _jump175:;
    int64_t _16 = 426;
    _14 = _16;
    _jump176:;
    int64_t _17 = -_14;
    if (_17 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    _3 = 0;
    int64_t _18 = 0; // d
    int64_t _19 = 0; // c
    int64_t _20 = 0; // b
    _jump178:; // Begin body of loop
    int64_t _21 = 245;
    _3 += _21;
    _18++;
    if (_18 < _17)
    goto _jump178;
    _18 = 0;
    _19++;
    if (_19 < _8)
    goto _jump178;
    _19 = 0;
    _20++;
    if (_20 < _4)
    goto _jump178;
    // End body of loop
    _2.d0 = _3;
    if (_3 > 0) 
    goto _jump179;
    fail_assertion("non-positive loop bound");
    _jump179:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= _3;
    _22 *= sizeof(_a1__a2__a1_int64_t);
    _2.data = jpl_alloc(_22);
    int64_t _23 = 0; // b
    _jump180:; // Begin body of loop
    _a2__a1_int64_t _24;
    // Computing bound for c
    int64_t _25 = 851;
    _24.d0 = _25;
    if (_25 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing bound for d
    int64_t _26 = 690;
    _24.d1 = _26;
    if (_26 > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= _25;
    _27 *= _26;
    _27 *= sizeof(_a1_int64_t);
    _24.data = jpl_alloc(_27);
    int64_t _28 = 0; // d
    int64_t _29 = 0; // c
    _jump183:; // Begin body of loop
    _a1_int64_t _30;
    _30.d0 = 1;
    _30.data = jpl_alloc(sizeof(int64_t) * 1);
    _30.data[0] = _29;
    int64_t _31 = 0;
    _31 *= _24.d0;
    _31 += _29;
    _31 *= _24.d1;
    _31 += _28;
    _24.data[_31] = _30;
    _28++;
    if (_28 < _26)
    goto _jump183;
    _28 = 0;
    _29++;
    if (_29 < _25)
    goto _jump183;
    // End body of loop
    _a2__a1_int64_t _32;
    // Computing bound for c
    int64_t _33 = 220;
    int64_t _34 = -_33;
    _32.d0 = _34;
    if (_34 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing bound for d
    int64_t _35 = 521;
    _32.d1 = _35;
    if (_35 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _34;
    _36 *= _35;
    _36 *= sizeof(_a1_int64_t);
    _32.data = jpl_alloc(_36);
    int64_t _37 = 0; // d
    int64_t _38 = 0; // c
    _jump186:; // Begin body of loop
    int64_t _39 = 384;
    _a1_int64_t _40;
    _40.d0 = 3;
    _40.data = jpl_alloc(sizeof(int64_t) * 3);
    _40.data[0] = _37;
    _40.data[1] = _37;
    _40.data[2] = _39;
    int64_t _41 = 0;
    _41 *= _32.d0;
    _41 += _38;
    _41 *= _32.d1;
    _41 += _37;
    _32.data[_41] = _40;
    _37++;
    if (_37 < _35)
    goto _jump186;
    _37 = 0;
    _38++;
    if (_38 < _34)
    goto _jump186;
    // End body of loop
    _a1__a2__a1_int64_t _42;
    _42.d0 = 2;
    _42.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 2);
    _42.data[0] = _24;
    _42.data[1] = _32;
    int64_t _43 = 0;
    _43 *= _2.d0;
    _43 += _23;
    _2.data[_43] = _42;
    _23++;
    if (_23 < _3)
    goto _jump180;
    // End body of loop
    int64_t _44 = 139;
    if (_44 >= 0)
    goto _jump187;
    fail_assertion("negative array index");
    _jump187:;
    if (_44 < _2.d0)
    goto _jump188;
    fail_assertion("index too large");
    _jump188:;
    int64_t _45 = 0;
    _45 *= _2.d0;
    _45 += _44;
    _a1__a2__a1_int64_t _46 = _2.data[_45];
    _1 = _46;
    goto _jump189;
    _jump167:;
    _a1__a2__a1_int64_t _47;
    // Computing bound for b
    int64_t _48 = 442;
    int64_t _49 = -_48;
    _47.d0 = _49;
    if (_49 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _49;
    _50 *= sizeof(_a2__a1_int64_t);
    _47.data = jpl_alloc(_50);
    int64_t _51 = 0; // b
    _jump191:; // Begin body of loop
    _a2__a1_int64_t _52;
    // Computing bound for c
    int64_t _53;
    // Computing bound for c
    if (_51 > 0) 
    goto _jump192;
    fail_assertion("non-positive loop bound");
    _jump192:;
    // Computing bound for d
    int64_t _54;
    // Computing bound for c
    int64_t _55 = 879;
    if (_55 > 0) 
    goto _jump193;
    fail_assertion("non-positive loop bound");
    _jump193:;
    // Computing bound for d
    int64_t _56 = 539;
    int64_t _57 = -_56;
    if (_57 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for e
    if (_51 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    _54 = 0;
    int64_t _58 = 0; // e
    int64_t _59 = 0; // d
    int64_t _60 = 0; // c
    _jump196:; // Begin body of loop
    _54 += _51;
    _58++;
    if (_58 < _51)
    goto _jump196;
    _58 = 0;
    _59++;
    if (_59 < _57)
    goto _jump196;
    _59 = 0;
    _60++;
    if (_60 < _55)
    goto _jump196;
    // End body of loop
    if (_54 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing bound for e
    int64_t _61 = -_51;
    if (_61 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    _53 = 0;
    int64_t _62 = 0; // e
    int64_t _63 = 0; // d
    int64_t _64 = 0; // c
    _jump199:; // Begin body of loop
    int64_t _65;
    // Computing bound for f
    if (_63 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing bound for g
    if (_64 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing bound for h
    int64_t _66 = 22;
    if (_66 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    _65 = 0;
    int64_t _67 = 0; // h
    int64_t _68 = 0; // g
    int64_t _69 = 0; // f
    _jump203:; // Begin body of loop
    _65 += _67;
    _67++;
    if (_67 < _66)
    goto _jump203;
    _67 = 0;
    _68++;
    if (_68 < _64)
    goto _jump203;
    _68 = 0;
    _69++;
    if (_69 < _63)
    goto _jump203;
    // End body of loop
    int64_t _70 = _64 * _65;
    _53 += _70;
    _62++;
    if (_62 < _61)
    goto _jump199;
    _62 = 0;
    _63++;
    if (_63 < _54)
    goto _jump199;
    _63 = 0;
    _64++;
    if (_64 < _51)
    goto _jump199;
    // End body of loop
    _52.d0 = _53;
    if (_53 > 0) 
    goto _jump204;
    fail_assertion("non-positive loop bound");
    _jump204:;
    // Computing bound for d
    _52.d1 = _51;
    if (_51 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= _53;
    _71 *= _51;
    _71 *= sizeof(_a1_int64_t);
    _52.data = jpl_alloc(_71);
    int64_t _72 = 0; // d
    int64_t _73 = 0; // c
    _jump206:; // Begin body of loop
    _a2__a1_int64_t _74;
    // Computing bound for e
    _74.d0 = _51;
    if (_51 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing bound for f
    int64_t _75 = _51 + _51;
    _74.d1 = _75;
    if (_75 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _51;
    _76 *= _75;
    _76 *= sizeof(_a1_int64_t);
    _74.data = jpl_alloc(_76);
    int64_t _77 = 0; // f
    int64_t _78 = 0; // e
    _jump209:; // Begin body of loop
    _a1_int64_t _79;
    _79.d0 = 3;
    _79.data = jpl_alloc(sizeof(int64_t) * 3);
    _79.data[0] = _51;
    _79.data[1] = _78;
    _79.data[2] = _51;
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += _78;
    _80 *= _74.d1;
    _80 += _77;
    _74.data[_80] = _79;
    _77++;
    if (_77 < _75)
    goto _jump209;
    _77 = 0;
    _78++;
    if (_78 < _51)
    goto _jump209;
    // End body of loop
    int64_t _81 = _72 % _72;
    if (_73 >= 0)
    goto _jump210;
    fail_assertion("negative array index");
    _jump210:;
    if (_73 < _74.d0)
    goto _jump211;
    fail_assertion("index too large");
    _jump211:;
    if (_81 >= 0)
    goto _jump212;
    fail_assertion("negative array index");
    _jump212:;
    if (_81 < _74.d1)
    goto _jump213;
    fail_assertion("index too large");
    _jump213:;
    int64_t _82 = 0;
    _82 *= _74.d0;
    _82 += _73;
    _82 *= _74.d1;
    _82 += _81;
    _a1_int64_t _83 = _74.data[_82];
    int64_t _84 = 0;
    _84 *= _52.d0;
    _84 += _73;
    _84 *= _52.d1;
    _84 += _72;
    _52.data[_84] = _83;
    _72++;
    if (_72 < _51)
    goto _jump206;
    _72 = 0;
    _73++;
    if (_73 < _53)
    goto _jump206;
    // End body of loop
    int64_t _85 = 0;
    _85 *= _47.d0;
    _85 += _51;
    _47.data[_85] = _52;
    _51++;
    if (_51 < _49)
    goto _jump191;
    // End body of loop
    _1 = _47;
    _jump189:;
    int64_t _86 = 200;
    int64_t _87 = -_86;
    if (_87 >= 0)
    goto _jump214;
    fail_assertion("negative array index");
    _jump214:;
    if (_87 < _1.d0)
    goto _jump215;
    fail_assertion("index too large");
    _jump215:;
    int64_t _88 = 0;
    _88 *= _1.d0;
    _88 += _87;
    _a2__a1_int64_t _89 = _1.data[_88];
    _a3__a2__a1__a2__a1_int64_t _90;
    // Computing bound for f
    double _91 = 8.0;
    _a2_bool _92;
    // Computing bound for f
    int64_t _93 = _89.d0 - _89.d0;
    _92.d0 = _93;
    if (_93 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing bound for g
    int64_t _94 = 32;
    _92.d1 = _94;
    if (_94 > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= _93;
    _95 *= _94;
    _95 *= sizeof(bool);
    _92.data = jpl_alloc(_95);
    int64_t _96 = 0; // g
    int64_t _97 = 0; // f
    _jump654:; // Begin body of loop
    bool _98 = _89.d1 < _89.d1;
    int64_t _99 = 0;
    _99 *= _92.d0;
    _99 += _97;
    _99 *= _92.d1;
    _99 += _96;
    _92.data[_99] = _98;
    _96++;
    if (_96 < _94)
    goto _jump654;
    _96 = 0;
    _97++;
    if (_97 < _93)
    goto _jump654;
    // End body of loop
    double _100 = a(_91, _92);
    double _101 = 86.0;
    _a2_bool _102;
    // Computing bound for f
    int64_t _103 = 826;
    _102.d0 = _103;
    if (_103 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for g
    int64_t _104 = 452;
    _102.d1 = _104;
    if (_104 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _103;
    _105 *= _104;
    _105 *= sizeof(bool);
    _102.data = jpl_alloc(_105);
    int64_t _106 = 0; // g
    int64_t _107 = 0; // f
    _jump657:; // Begin body of loop
    bool _108 = true;
    int64_t _109 = 0;
    _109 *= _102.d0;
    _109 += _107;
    _109 *= _102.d1;
    _109 += _106;
    _102.data[_109] = _108;
    _106++;
    if (_106 < _104)
    goto _jump657;
    _106 = 0;
    _107++;
    if (_107 < _103)
    goto _jump657;
    // End body of loop
    double _110 = a(_101, _102);
    double _111 = -_110;
    bool _112 = _100 != _111;
    int64_t _113;
    if (!_112)
    goto _jump658;
    _113 = _89.d1;
    goto _jump659;
    _jump658:;
    int64_t _114 = 269;
    int64_t _115 = -_114;
    _113 = _115;
    _jump659:;
    _90.d0 = _113;
    if (_113 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for g
    bool _117 = _89.d0 > _89.d0;
    bool _116 = _117;
    if (0 != _117)
    goto _jump661;
    bool _118 = false;
    bool _119;
    if (!_118)
    goto _jump662;
    bool _120 = true;
    _119 = _120;
    goto _jump663;
    _jump662:;
    bool _121 = false;
    _119 = _121;
    _jump663:;
    _116 = _119;
    _jump661:;
    int64_t _122;
    if (!_116)
    goto _jump664;
    int64_t _123 = 516;
    _122 = _123;
    goto _jump665;
    _jump664:;
    int64_t _124 = 159;
    _122 = _124;
    _jump665:;
    int64_t _125 = -_122;
    int64_t _126 = -_125;
    _90.d1 = _126;
    if (_126 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing bound for h
    _90.d2 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= _113;
    _127 *= _126;
    _127 *= _89.d0;
    _127 *= sizeof(_a2__a1__a2__a1_int64_t);
    _90.data = jpl_alloc(_127);
    int64_t _128 = 0; // h
    int64_t _129 = 0; // g
    int64_t _130 = 0; // f
    _jump668:; // Begin body of loop
    _a2__a1__a2__a1_int64_t _131;
    // Computing bound for i
    int64_t _132 = 910;
    int64_t _133 = _129 * _132;
    _131.d0 = _133;
    if (_133 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for j
    int64_t _134 = 272;
    _131.d1 = _134;
    if (_134 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= _133;
    _135 *= _134;
    _135 *= sizeof(_a1__a2__a1_int64_t);
    _131.data = jpl_alloc(_135);
    int64_t _136 = 0; // j
    int64_t _137 = 0; // i
    _jump671:; // Begin body of loop
    _a1__a2__a1_int64_t _138;
    // Computing bound for k
    int64_t _139;
    // Computing bound for k
    if (_136 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    _139 = 0;
    int64_t _140 = 0; // k
    _jump673:; // Begin body of loop
    _139 += _130;
    _140++;
    if (_140 < _136)
    goto _jump673;
    // End body of loop
    _138.d0 = _139;
    if (_139 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= _139;
    _141 *= sizeof(_a2__a1_int64_t);
    _138.data = jpl_alloc(_141);
    int64_t _142 = 0; // k
    _jump675:; // Begin body of loop
    int64_t _143 = 0;
    _143 *= _138.d0;
    _143 += _142;
    _138.data[_143] = _89;
    _142++;
    if (_142 < _139)
    goto _jump675;
    // End body of loop
    int64_t _144 = 0;
    _144 *= _131.d0;
    _144 += _137;
    _144 *= _131.d1;
    _144 += _136;
    _131.data[_144] = _138;
    _136++;
    if (_136 < _134)
    goto _jump671;
    _136 = 0;
    _137++;
    if (_137 < _133)
    goto _jump671;
    // End body of loop
    int64_t _145 = 0;
    _145 *= _90.d0;
    _145 += _130;
    _145 *= _90.d1;
    _145 += _129;
    _145 *= _90.d2;
    _145 += _128;
    _90.data[_145] = _131;
    _128++;
    if (_128 < _89.d0)
    goto _jump668;
    _128 = 0;
    _129++;
    if (_129 < _126)
    goto _jump668;
    _129 = 0;
    _130++;
    if (_130 < _113)
    goto _jump668;
    // End body of loop
    int64_t _146;
    // Computing bound for f
    _a3_int64_t _147;
    // Computing bound for f
    _a1_int64_t _148;
    _148.d0 = 2;
    _148.data = jpl_alloc(sizeof(int64_t) * 2);
    _148.data[0] = _89.d0;
    _148.data[1] = _89.d1;
    if (_89.d0 >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (_89.d0 < _148.d0)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    int64_t _149 = 0;
    _149 *= _148.d0;
    _149 += _89.d0;
    int64_t _150 = _148.data[_149];
    _147.d0 = _150;
    if (_150 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing bound for g
    _147.d1 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing bound for h
    int64_t _151 = 3;
    _147.d2 = _151;
    if (_151 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= _150;
    _152 *= _89.d0;
    _152 *= _151;
    _152 *= sizeof(int64_t);
    _147.data = jpl_alloc(_152);
    int64_t _153 = 0; // h
    int64_t _154 = 0; // g
    int64_t _155 = 0; // f
    _jump681:; // Begin body of loop
    int64_t _156 = _155 / _89.d0;
    int64_t _157 = 0;
    _157 *= _147.d0;
    _157 += _155;
    _157 *= _147.d1;
    _157 += _154;
    _157 *= _147.d2;
    _157 += _153;
    _147.data[_157] = _156;
    _153++;
    if (_153 < _151)
    goto _jump681;
    _153 = 0;
    _154++;
    if (_154 < _89.d0)
    goto _jump681;
    _154 = 0;
    _155++;
    if (_155 < _150)
    goto _jump681;
    // End body of loop
    int64_t _158 = 711;
    double _160 = 10.0;
    double _161 = 55.0;
    bool _162 = _160 <= _161;
    bool _159 = _162;
    if (0 != _162)
    goto _jump682;
    bool _163 = false;
    bool _164 = !_163;
    _159 = _164;
    _jump682:;
    int64_t _165;
    if (!_159)
    goto _jump683;
    int64_t _166 = 411;
    int64_t _167 = _166 + _89.d0;
    int64_t _168 = _167 / _89.d1;
    _165 = _168;
    goto _jump684;
    _jump683:;
    _165 = _89.d1;
    _jump684:;
    if (_158 >= 0)
    goto _jump685;
    fail_assertion("negative array index");
    _jump685:;
    if (_158 < _147.d0)
    goto _jump686;
    fail_assertion("index too large");
    _jump686:;
    if (_89.d0 >= 0)
    goto _jump687;
    fail_assertion("negative array index");
    _jump687:;
    if (_89.d0 < _147.d1)
    goto _jump688;
    fail_assertion("index too large");
    _jump688:;
    if (_165 >= 0)
    goto _jump689;
    fail_assertion("negative array index");
    _jump689:;
    if (_165 < _147.d2)
    goto _jump690;
    fail_assertion("index too large");
    _jump690:;
    int64_t _169 = 0;
    _169 *= _147.d0;
    _169 += _158;
    _169 *= _147.d1;
    _169 += _89.d0;
    _169 *= _147.d2;
    _169 += _165;
    int64_t _170 = _147.data[_169];
    int64_t _171 = -_170;
    if (_171 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for g
    _a2_int64_t _172;
    // Computing bound for f
    int64_t _173 = 522;
    int64_t _174 = _173 / _89.d1;
    int64_t _175 = 484;
    int64_t _176 = _175 / _89.d1;
    int64_t _177 = _174 * _176;
    _172.d0 = _177;
    if (_177 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing bound for g
    int64_t _178 = -_89.d0;
    _172.d1 = _178;
    if (_178 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= _177;
    _179 *= _178;
    _179 *= sizeof(int64_t);
    _172.data = jpl_alloc(_179);
    int64_t _180 = 0; // g
    int64_t _181 = 0; // f
    _jump694:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _172.d0;
    _182 += _181;
    _182 *= _172.d1;
    _182 += _180;
    _172.data[_182] = _181;
    _180++;
    if (_180 < _178)
    goto _jump694;
    _180 = 0;
    _181++;
    if (_181 < _177)
    goto _jump694;
    // End body of loop
    _a3__a1_int64_t _183;
    // Computing bound for f
    int64_t _184 = 140;
    int64_t _185 = -_184;
    _183.d0 = _185;
    if (_185 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for g
    _183.d1 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for h
    int64_t _186;
    // Computing bound for f
    int64_t _187 = 653;
    if (_187 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    // Computing bound for g
    if (_89.d1 > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    // Computing bound for h
    if (_89.d1 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    _186 = 0;
    int64_t _188 = 0; // h
    int64_t _189 = 0; // g
    int64_t _190 = 0; // f
    _jump700:; // Begin body of loop
    int64_t _191 = 698;
    _186 += _191;
    _188++;
    if (_188 < _89.d1)
    goto _jump700;
    _188 = 0;
    _189++;
    if (_189 < _89.d1)
    goto _jump700;
    _189 = 0;
    _190++;
    if (_190 < _187)
    goto _jump700;
    // End body of loop
    _183.d2 = _186;
    if (_186 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= _185;
    _192 *= _89.d1;
    _192 *= _186;
    _192 *= sizeof(_a1_int64_t);
    _183.data = jpl_alloc(_192);
    int64_t _193 = 0; // h
    int64_t _194 = 0; // g
    int64_t _195 = 0; // f
    _jump702:; // Begin body of loop
    _a1_int64_t _196;
    // Computing bound for i
    _196.d0 = _194;
    if (_194 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= _194;
    _197 *= sizeof(int64_t);
    _196.data = jpl_alloc(_197);
    int64_t _198 = 0; // i
    _jump704:; // Begin body of loop
    int64_t _199 = 0;
    _199 *= _196.d0;
    _199 += _198;
    _196.data[_199] = _198;
    _198++;
    if (_198 < _194)
    goto _jump704;
    // End body of loop
    int64_t _200 = 0;
    _200 *= _183.d0;
    _200 += _195;
    _200 *= _183.d1;
    _200 += _194;
    _200 *= _183.d2;
    _200 += _193;
    _183.data[_200] = _196;
    _193++;
    if (_193 < _186)
    goto _jump702;
    _193 = 0;
    _194++;
    if (_194 < _89.d1)
    goto _jump702;
    _194 = 0;
    _195++;
    if (_195 < _185)
    goto _jump702;
    // End body of loop
    bool _201 = true;
    int64_t _202;
    if (!_201)
    goto _jump705;
    int64_t _203;
    // Computing bound for f
    if (_89.d0 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    _203 = 0;
    int64_t _204 = 0; // f
    _jump707:; // Begin body of loop
    _203 += _204;
    _204++;
    if (_204 < _89.d0)
    goto _jump707;
    // End body of loop
    _202 = _203;
    goto _jump708;
    _jump705:;
    _202 = _89.d0;
    _jump708:;
    int64_t _205 = 543;
    int64_t _206 = _89.d1 * _205;
    double _207 = 78.0;
    double _208 = 99.0;
    bool _209 = _207 != _208;
    int64_t _210;
    if (!_209)
    goto _jump709;
    _210 = _89.d1;
    goto _jump710;
    _jump709:;
    int64_t _211 = 194;
    _210 = _211;
    _jump710:;
    if (_202 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (_202 < _183.d0)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    if (_206 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_206 < _183.d1)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    if (_210 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_210 < _183.d2)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    int64_t _212 = 0;
    _212 *= _183.d0;
    _212 += _202;
    _212 *= _183.d1;
    _212 += _206;
    _212 *= _183.d2;
    _212 += _210;
    _a1_int64_t _213 = _183.data[_212];
    int64_t _214 = -_89.d0;
    int64_t _215 = -_214;
    bool _216 = false;
    bool _217 = !_216;
    int64_t _218;
    if (!_217)
    goto _jump717;
    int64_t _219 = 184;
    _218 = _219;
    goto _jump718;
    _jump717:;
    int64_t _220 = -_89.d0;
    _218 = _220;
    _jump718:;
    int64_t _221 = _215 % _218;
    if (_221 >= 0)
    goto _jump719;
    fail_assertion("negative array index");
    _jump719:;
    if (_221 < _213.d0)
    goto _jump720;
    fail_assertion("index too large");
    _jump720:;
    int64_t _222 = 0;
    _222 *= _213.d0;
    _222 += _221;
    int64_t _223 = _213.data[_222];
    if (_89.d0 >= 0)
    goto _jump721;
    fail_assertion("negative array index");
    _jump721:;
    if (_89.d0 < _172.d0)
    goto _jump722;
    fail_assertion("index too large");
    _jump722:;
    if (_223 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (_223 < _172.d1)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    int64_t _224 = 0;
    _224 *= _172.d0;
    _224 += _89.d0;
    _224 *= _172.d1;
    _224 += _223;
    int64_t _225 = _172.data[_224];
    if (_225 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    _146 = 0;
    int64_t _226 = 0; // g
    int64_t _227 = 0; // f
    _jump726:; // Begin body of loop
    _146 += _227;
    _226++;
    if (_226 < _225)
    goto _jump726;
    _226 = 0;
    _227++;
    if (_227 < _171)
    goto _jump726;
    // End body of loop
    int64_t _228;
    // Computing bound for f
    bool _230 = false;
    bool _229 = _230;
    if (0 == _230)
    goto _jump727;
    bool _231 = true;
    _229 = _231;
    _jump727:;
    int64_t _232;
    if (!_229)
    goto _jump728;
    _232 = _89.d1;
    goto _jump729;
    _jump728:;
    _232 = _89.d0;
    _jump729:;
    int64_t _233 = -_232;
    int64_t _234 = -_233;
    if (_234 > 0) 
    goto _jump730;
    fail_assertion("non-positive loop bound");
    _jump730:;
    _228 = 0;
    int64_t _235 = 0; // f
    _jump731:; // Begin body of loop
    bool _236 = true;
    int64_t _237;
    if (!_236)
    goto _jump732;
    int64_t _238;
    // Computing bound for g
    int64_t _239 = 577;
    int64_t _240 = -_239;
    if (_240 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for h
    if (_235 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    _238 = 0;
    int64_t _241 = 0; // h
    int64_t _242 = 0; // g
    _jump735:; // Begin body of loop
    _238 += _242;
    _241++;
    if (_241 < _235)
    goto _jump735;
    _241 = 0;
    _242++;
    if (_242 < _240)
    goto _jump735;
    // End body of loop
    _237 = _238;
    goto _jump736;
    _jump732:;
    _237 = _89.d0;
    _jump736:;
    int64_t _243;
    // Computing bound for g
    if (_235 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    // Computing bound for h
    if (_235 > 0) 
    goto _jump738;
    fail_assertion("non-positive loop bound");
    _jump738:;
    // Computing bound for i
    if (_89.d0 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    _243 = 0;
    int64_t _244 = 0; // i
    int64_t _245 = 0; // h
    int64_t _246 = 0; // g
    _jump740:; // Begin body of loop
    int64_t _247;
    // Computing bound for j
    if (_246 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for k
    if (_244 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing bound for l
    if (_235 > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    _247 = 0;
    int64_t _248 = 0; // l
    int64_t _249 = 0; // k
    int64_t _250 = 0; // j
    _jump744:; // Begin body of loop
    _247 += _89.d1;
    _248++;
    if (_248 < _235)
    goto _jump744;
    _248 = 0;
    _249++;
    if (_249 < _244)
    goto _jump744;
    _249 = 0;
    _250++;
    if (_250 < _246)
    goto _jump744;
    // End body of loop
    int64_t _251 = -_247;
    _243 += _251;
    _244++;
    if (_244 < _89.d0)
    goto _jump740;
    _244 = 0;
    _245++;
    if (_245 < _235)
    goto _jump740;
    _245 = 0;
    _246++;
    if (_246 < _235)
    goto _jump740;
    // End body of loop
    int64_t _252 = _237 - _243;
    int64_t _253 = -_252;
    _228 += _253;
    _235++;
    if (_235 < _234)
    goto _jump731;
    // End body of loop
    int64_t _254;
    // Computing bound for f
    if (_89.d1 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing bound for g
    int64_t _255;
    // Computing bound for f
    if (_89.d0 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    _255 = 0;
    int64_t _256 = 0; // f
    _jump747:; // Begin body of loop
    int64_t _257 = 756;
    _255 += _257;
    _256++;
    if (_256 < _89.d0)
    goto _jump747;
    // End body of loop
    if (_255 > 0) 
    goto _jump748;
    fail_assertion("non-positive loop bound");
    _jump748:;
    _254 = 0;
    int64_t _258 = 0; // g
    int64_t _259 = 0; // f
    _jump749:; // Begin body of loop
    _254 += _89.d0;
    _258++;
    if (_258 < _255)
    goto _jump749;
    _258 = 0;
    _259++;
    if (_259 < _89.d1)
    goto _jump749;
    // End body of loop
    if (_146 >= 0)
    goto _jump750;
    fail_assertion("negative array index");
    _jump750:;
    if (_146 < _90.d0)
    goto _jump751;
    fail_assertion("index too large");
    _jump751:;
    if (_228 >= 0)
    goto _jump752;
    fail_assertion("negative array index");
    _jump752:;
    if (_228 < _90.d1)
    goto _jump753;
    fail_assertion("index too large");
    _jump753:;
    if (_254 >= 0)
    goto _jump754;
    fail_assertion("negative array index");
    _jump754:;
    if (_254 < _90.d2)
    goto _jump755;
    fail_assertion("index too large");
    _jump755:;
    int64_t _260 = 0;
    _260 *= _90.d0;
    _260 += _146;
    _260 *= _90.d1;
    _260 += _228;
    _260 *= _90.d2;
    _260 += _254;
    _a2__a1__a2__a1_int64_t _261 = _90.data[_260];
    bool _263 = true;
    bool _262 = _263;
    if (0 != _263)
    goto _jump756;
    bool _264 = _89.d0 >= _89.d0;
    _262 = _264;
    _jump756:;
    bool _265;
    if (!_262)
    goto _jump757;
    int64_t _266 = 857;
    bool _267 = _89.d1 == _266;
    _265 = _267;
    goto _jump758;
    _jump757:;
    bool _269 = true;
    bool _268 = _269;
    if (0 == _269)
    goto _jump759;
    bool _270 = true;
    _268 = _270;
    _jump759:;
    _265 = _268;
    _jump758:;
    double _271;
    if (!_265)
    goto _jump760;
    bool _272 = false;
    bool _273 = !_272;
    double _274;
    if (!_273)
    goto _jump761;
    double _275 = 15.0;
    _274 = _275;
    goto _jump762;
    _jump761:;
    double _276 = 4.0;
    double _277 = -_276;
    double _278 = 67.0;
    double _279 = _277 - _278;
    _274 = _279;
    _jump762:;
    _271 = _274;
    goto _jump763;
    _jump760:;
    double _280;
    // Computing bound for i
    if (_89.d1 > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    _280 = 0;
    int64_t _281 = 0; // i
    _jump765:; // Begin body of loop
    double _282 = 99.0;
    _280 += _282;
    _281++;
    if (_281 < _89.d1)
    goto _jump765;
    // End body of loop
    _271 = _280;
    _jump763:;
    bool _283 = _261.d0 <= _89.d1;
    bool _284 = !_283;
    double _285;
    if (!_284)
    goto _jump766;
    double _286;
    // Computing bound for i
    if (_261.d0 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for j
    if (_89.d1 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    // Computing bound for k
    int64_t _287;
    // Computing bound for i
    if (_261.d1 > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    // Computing bound for j
    if (_89.d0 > 0) 
    goto _jump770;
    fail_assertion("non-positive loop bound");
    _jump770:;
    // Computing bound for k
    if (_89.d1 > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    _287 = 0;
    int64_t _288 = 0; // k
    int64_t _289 = 0; // j
    int64_t _290 = 0; // i
    _jump772:; // Begin body of loop
    _287 += _261.d1;
    _288++;
    if (_288 < _89.d1)
    goto _jump772;
    _288 = 0;
    _289++;
    if (_289 < _89.d0)
    goto _jump772;
    _289 = 0;
    _290++;
    if (_290 < _261.d1)
    goto _jump772;
    // End body of loop
    if (_287 > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    _286 = 0;
    int64_t _291 = 0; // k
    int64_t _292 = 0; // j
    int64_t _293 = 0; // i
    _jump774:; // Begin body of loop
    double _294;
    // Computing bound for l
    if (_261.d1 > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    _294 = 0;
    int64_t _295 = 0; // l
    _jump776:; // Begin body of loop
    double _296 = 56.0;
    _294 += _296;
    _295++;
    if (_295 < _261.d1)
    goto _jump776;
    // End body of loop
    _286 += _294;
    _291++;
    if (_291 < _287)
    goto _jump774;
    _291 = 0;
    _292++;
    if (_292 < _89.d1)
    goto _jump774;
    _292 = 0;
    _293++;
    if (_293 < _261.d0)
    goto _jump774;
    // End body of loop
    _285 = _286;
    goto _jump777;
    _jump766:;
    int64_t _297 = _261.d1 * _89.d0;
    bool _298 = _297 > _89.d0;
    double _299;
    if (!_298)
    goto _jump778;
    _a1_double _300;
    // Computing bound for i
    _300.d0 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= _89.d1;
    _301 *= sizeof(double);
    _300.data = jpl_alloc(_301);
    int64_t _302 = 0; // i
    _jump780:; // Begin body of loop
    double _303 = 84.0;
    int64_t _304 = 0;
    _304 *= _300.d0;
    _304 += _302;
    _300.data[_304] = _303;
    _302++;
    if (_302 < _89.d1)
    goto _jump780;
    // End body of loop
    int64_t _305 = -_261.d1;
    if (_305 >= 0)
    goto _jump781;
    fail_assertion("negative array index");
    _jump781:;
    if (_305 < _300.d0)
    goto _jump782;
    fail_assertion("index too large");
    _jump782:;
    int64_t _306 = 0;
    _306 *= _300.d0;
    _306 += _305;
    double _307 = _300.data[_306];
    _299 = _307;
    goto _jump783;
    _jump778:;
    double _308 = 65.0;
    double _309 = -_308;
    _299 = _309;
    _jump783:;
    _285 = _299;
    _jump777:;
    bool _310 = _271 >= _285;
    bool _311 = !_310;
    _a3_int64_t _312;
    if (!_311)
    goto _jump784;
    double _313 = 43.0;
    double _314 = -_313;
    double _315 = 99.0;
    double _316 = 31.0;
    double _317 = 55.0;
    rgba _318 = { _314, _315, _316, _317 };
    _a1_rgba _319;
    _319.d0 = 1;
    _319.data = jpl_alloc(sizeof(rgba) * 1);
    _319.data[0] = _318;
    _a3_rgba _320;
    // Computing bound for i
    int64_t _321;
    // Computing bound for i
    if (_89.d0 > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    _321 = 0;
    int64_t _322 = 0; // i
    _jump786:; // Begin body of loop
    int64_t _323 = -_89.d0;
    _321 += _323;
    _322++;
    if (_322 < _89.d0)
    goto _jump786;
    // End body of loop
    _320.d0 = _321;
    if (_321 > 0) 
    goto _jump787;
    fail_assertion("non-positive loop bound");
    _jump787:;
    // Computing bound for j
    _320.d1 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    // Computing bound for k
    _a1_int64_t _324;
    // Computing bound for i
    _324.d0 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump789;
    fail_assertion("non-positive loop bound");
    _jump789:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= _261.d1;
    _325 *= sizeof(int64_t);
    _324.data = jpl_alloc(_325);
    int64_t _326 = 0; // i
    _jump790:; // Begin body of loop
    int64_t _327 = 0;
    _327 *= _324.d0;
    _327 += _326;
    _324.data[_327] = _261.d1;
    _326++;
    if (_326 < _261.d1)
    goto _jump790;
    // End body of loop
    int64_t _328 = 8;
    int64_t _329 = -_328;
    if (_329 >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (_329 < _324.d0)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    int64_t _330 = 0;
    _330 *= _324.d0;
    _330 += _329;
    int64_t _331 = _324.data[_330];
    _320.d2 = _331;
    if (_331 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= _321;
    _332 *= _261.d0;
    _332 *= _331;
    _332 *= sizeof(rgba);
    _320.data = jpl_alloc(_332);
    int64_t _333 = 0; // k
    int64_t _334 = 0; // j
    int64_t _335 = 0; // i
    _jump794:; // Begin body of loop
    double _336 = 73.0;
    double _337 = 79.0;
    double _338 = 71.0;
    double _339 = 38.0;
    rgba _340 = { _336, _337, _338, _339 };
    int64_t _341 = 0;
    _341 *= _320.d0;
    _341 += _335;
    _341 *= _320.d1;
    _341 += _334;
    _341 *= _320.d2;
    _341 += _333;
    _320.data[_341] = _340;
    _333++;
    if (_333 < _331)
    goto _jump794;
    _333 = 0;
    _334++;
    if (_334 < _261.d0)
    goto _jump794;
    _334 = 0;
    _335++;
    if (_335 < _321)
    goto _jump794;
    // End body of loop
    bool _342 = e(_319, _320);
    _a3__a3_int64_t _343;
    if (!_342)
    goto _jump795;
    _a3__a3_int64_t _344;
    // Computing bound for i
    _a3_int64_t _345;
    // Computing bound for i
    _345.d0 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing bound for j
    _345.d1 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump797;
    fail_assertion("non-positive loop bound");
    _jump797:;
    // Computing bound for k
    int64_t _346;
    // Computing bound for i
    if (_89.d1 > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing bound for j
    if (_89.d0 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    _346 = 0;
    int64_t _347 = 0; // j
    int64_t _348 = 0; // i
    _jump800:; // Begin body of loop
    int64_t _349 = 238;
    _346 += _349;
    _347++;
    if (_347 < _89.d0)
    goto _jump800;
    _347 = 0;
    _348++;
    if (_348 < _89.d1)
    goto _jump800;
    // End body of loop
    _345.d2 = _346;
    if (_346 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing total size of heap memory to allocate
    int64_t _350 = 1;
    _350 *= _89.d0;
    _350 *= _89.d0;
    _350 *= _346;
    _350 *= sizeof(int64_t);
    _345.data = jpl_alloc(_350);
    int64_t _351 = 0; // k
    int64_t _352 = 0; // j
    int64_t _353 = 0; // i
    _jump802:; // Begin body of loop
    int64_t _354 = -_261.d1;
    int64_t _355 = 0;
    _355 *= _345.d0;
    _355 += _353;
    _355 *= _345.d1;
    _355 += _352;
    _355 *= _345.d2;
    _355 += _351;
    _345.data[_355] = _354;
    _351++;
    if (_351 < _346)
    goto _jump802;
    _351 = 0;
    _352++;
    if (_352 < _89.d0)
    goto _jump802;
    _352 = 0;
    _353++;
    if (_353 < _89.d0)
    goto _jump802;
    // End body of loop
    if (_261.d0 >= 0)
    goto _jump803;
    fail_assertion("negative array index");
    _jump803:;
    if (_261.d0 < _345.d0)
    goto _jump804;
    fail_assertion("index too large");
    _jump804:;
    if (_89.d0 >= 0)
    goto _jump805;
    fail_assertion("negative array index");
    _jump805:;
    if (_89.d0 < _345.d1)
    goto _jump806;
    fail_assertion("index too large");
    _jump806:;
    if (_89.d1 >= 0)
    goto _jump807;
    fail_assertion("negative array index");
    _jump807:;
    if (_89.d1 < _345.d2)
    goto _jump808;
    fail_assertion("index too large");
    _jump808:;
    int64_t _356 = 0;
    _356 *= _345.d0;
    _356 += _261.d0;
    _356 *= _345.d1;
    _356 += _89.d0;
    _356 *= _345.d2;
    _356 += _89.d1;
    int64_t _357 = _345.data[_356];
    _344.d0 = _357;
    if (_357 > 0) 
    goto _jump809;
    fail_assertion("non-positive loop bound");
    _jump809:;
    // Computing bound for j
    _344.d1 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    // Computing bound for k
    _344.d2 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    // Computing total size of heap memory to allocate
    int64_t _358 = 1;
    _358 *= _357;
    _358 *= _89.d1;
    _358 *= _89.d1;
    _358 *= sizeof(_a3_int64_t);
    _344.data = jpl_alloc(_358);
    int64_t _359 = 0; // k
    int64_t _360 = 0; // j
    int64_t _361 = 0; // i
    _jump812:; // Begin body of loop
    _a2__a3_int64_t _362;
    // Computing bound for l
    int64_t _363 = 443;
    _362.d0 = _363;
    if (_363 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    // Computing bound for m
    int64_t _364 = 997;
    _362.d1 = _364;
    if (_364 > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    // Computing total size of heap memory to allocate
    int64_t _365 = 1;
    _365 *= _363;
    _365 *= _364;
    _365 *= sizeof(_a3_int64_t);
    _362.data = jpl_alloc(_365);
    int64_t _366 = 0; // m
    int64_t _367 = 0; // l
    _jump815:; // Begin body of loop
    _a3_int64_t _368;
    // Computing bound for n
    _368.d0 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    // Computing bound for o
    _368.d1 = _367;
    if (_367 > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for p
    _368.d2 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= _261.d1;
    _369 *= _367;
    _369 *= _89.d0;
    _369 *= sizeof(int64_t);
    _368.data = jpl_alloc(_369);
    int64_t _370 = 0; // p
    int64_t _371 = 0; // o
    int64_t _372 = 0; // n
    _jump819:; // Begin body of loop
    int64_t _373 = 0;
    _373 *= _368.d0;
    _373 += _372;
    _373 *= _368.d1;
    _373 += _371;
    _373 *= _368.d2;
    _373 += _370;
    _368.data[_373] = _359;
    _370++;
    if (_370 < _89.d0)
    goto _jump819;
    _370 = 0;
    _371++;
    if (_371 < _367)
    goto _jump819;
    _371 = 0;
    _372++;
    if (_372 < _261.d1)
    goto _jump819;
    // End body of loop
    int64_t _374 = 0;
    _374 *= _362.d0;
    _374 += _367;
    _374 *= _362.d1;
    _374 += _366;
    _362.data[_374] = _368;
    _366++;
    if (_366 < _364)
    goto _jump815;
    _366 = 0;
    _367++;
    if (_367 < _363)
    goto _jump815;
    // End body of loop
    if (_359 >= 0)
    goto _jump820;
    fail_assertion("negative array index");
    _jump820:;
    if (_359 < _362.d0)
    goto _jump821;
    fail_assertion("index too large");
    _jump821:;
    if (_89.d1 >= 0)
    goto _jump822;
    fail_assertion("negative array index");
    _jump822:;
    if (_89.d1 < _362.d1)
    goto _jump823;
    fail_assertion("index too large");
    _jump823:;
    int64_t _375 = 0;
    _375 *= _362.d0;
    _375 += _359;
    _375 *= _362.d1;
    _375 += _89.d1;
    _a3_int64_t _376 = _362.data[_375];
    int64_t _377 = 0;
    _377 *= _344.d0;
    _377 += _361;
    _377 *= _344.d1;
    _377 += _360;
    _377 *= _344.d2;
    _377 += _359;
    _344.data[_377] = _376;
    _359++;
    if (_359 < _89.d1)
    goto _jump812;
    _359 = 0;
    _360++;
    if (_360 < _89.d1)
    goto _jump812;
    _360 = 0;
    _361++;
    if (_361 < _357)
    goto _jump812;
    // End body of loop
    _343 = _344;
    goto _jump824;
    _jump795:;
    _a3__a3_int64_t _378;
    // Computing bound for i
    int64_t _379;
    // Computing bound for i
    if (_261.d1 > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    _379 = 0;
    int64_t _380 = 0; // i
    _jump826:; // Begin body of loop
    int64_t _381;
    // Computing bound for j
    if (_380 > 0) 
    goto _jump827;
    fail_assertion("non-positive loop bound");
    _jump827:;
    // Computing bound for k
    if (_380 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    _381 = 0;
    int64_t _382 = 0; // k
    int64_t _383 = 0; // j
    _jump829:; // Begin body of loop
    _381 += _89.d1;
    _382++;
    if (_382 < _380)
    goto _jump829;
    _382 = 0;
    _383++;
    if (_383 < _380)
    goto _jump829;
    // End body of loop
    int64_t _384 = 714;
    int64_t _385 = _381 - _384;
    _379 += _385;
    _380++;
    if (_380 < _261.d1)
    goto _jump826;
    // End body of loop
    _378.d0 = _379;
    if (_379 > 0) 
    goto _jump830;
    fail_assertion("non-positive loop bound");
    _jump830:;
    // Computing bound for j
    _a1_int64_t _386;
    _386.d0 = 1;
    _386.data = jpl_alloc(sizeof(int64_t) * 1);
    _386.data[0] = _89.d1;
    if (_89.d1 >= 0)
    goto _jump831;
    fail_assertion("negative array index");
    _jump831:;
    if (_89.d1 < _386.d0)
    goto _jump832;
    fail_assertion("index too large");
    _jump832:;
    int64_t _387 = 0;
    _387 *= _386.d0;
    _387 += _89.d1;
    int64_t _388 = _386.data[_387];
    _378.d1 = _388;
    if (_388 > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for k
    _378.d2 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _379;
    _389 *= _388;
    _389 *= _89.d1;
    _389 *= sizeof(_a3_int64_t);
    _378.data = jpl_alloc(_389);
    int64_t _390 = 0; // k
    int64_t _391 = 0; // j
    int64_t _392 = 0; // i
    _jump835:; // Begin body of loop
    _a3_int64_t _393;
    // Computing bound for l
    bool _394 = true;
    int64_t _395;
    if (!_394)
    goto _jump836;
    _395 = _392;
    goto _jump837;
    _jump836:;
    _395 = _391;
    _jump837:;
    int64_t _396 = _395 - _391;
    _393.d0 = _396;
    if (_396 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing bound for m
    _a1_int64_t _397;
    _397.d0 = 2;
    _397.data = jpl_alloc(sizeof(int64_t) * 2);
    _397.data[0] = _261.d0;
    _397.data[1] = _261.d0;
    if (_261.d0 >= 0)
    goto _jump839;
    fail_assertion("negative array index");
    _jump839:;
    if (_261.d0 < _397.d0)
    goto _jump840;
    fail_assertion("index too large");
    _jump840:;
    int64_t _398 = 0;
    _398 *= _397.d0;
    _398 += _261.d0;
    int64_t _399 = _397.data[_398];
    _393.d1 = _399;
    if (_399 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing bound for n
    int64_t _400 = 765;
    _393.d2 = _400;
    if (_400 > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing total size of heap memory to allocate
    int64_t _401 = 1;
    _401 *= _396;
    _401 *= _399;
    _401 *= _400;
    _401 *= sizeof(int64_t);
    _393.data = jpl_alloc(_401);
    int64_t _402 = 0; // n
    int64_t _403 = 0; // m
    int64_t _404 = 0; // l
    _jump843:; // Begin body of loop
    int64_t _405 = -_404;
    int64_t _406 = -_405;
    int64_t _407 = 0;
    _407 *= _393.d0;
    _407 += _404;
    _407 *= _393.d1;
    _407 += _403;
    _407 *= _393.d2;
    _407 += _402;
    _393.data[_407] = _406;
    _402++;
    if (_402 < _400)
    goto _jump843;
    _402 = 0;
    _403++;
    if (_403 < _399)
    goto _jump843;
    _403 = 0;
    _404++;
    if (_404 < _396)
    goto _jump843;
    // End body of loop
    int64_t _408 = 0;
    _408 *= _378.d0;
    _408 += _392;
    _408 *= _378.d1;
    _408 += _391;
    _408 *= _378.d2;
    _408 += _390;
    _378.data[_408] = _393;
    _390++;
    if (_390 < _89.d1)
    goto _jump835;
    _390 = 0;
    _391++;
    if (_391 < _388)
    goto _jump835;
    _391 = 0;
    _392++;
    if (_392 < _379)
    goto _jump835;
    // End body of loop
    _343 = _378;
    _jump824:;
    int64_t _409;
    // Computing bound for i
    if (_89.d1 > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    _409 = 0;
    int64_t _410 = 0; // i
    _jump845:; // Begin body of loop
    int64_t _411;
    // Computing bound for j
    if (_89.d0 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    // Computing bound for k
    if (_89.d0 > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    _411 = 0;
    int64_t _412 = 0; // k
    int64_t _413 = 0; // j
    _jump848:; // Begin body of loop
    _411 += _261.d1;
    _412++;
    if (_412 < _89.d0)
    goto _jump848;
    _412 = 0;
    _413++;
    if (_413 < _89.d0)
    goto _jump848;
    // End body of loop
    int64_t _414 = -_411;
    _409 += _414;
    _410++;
    if (_410 < _89.d1)
    goto _jump845;
    // End body of loop
    bool _415 = _409 > _89.d1;
    int64_t _416;
    if (!_415)
    goto _jump849;
    bool _417 = false;
    int64_t _418;
    if (!_417)
    goto _jump850;
    _418 = _89.d0;
    goto _jump851;
    _jump850:;
    int64_t _419 = 359;
    _418 = _419;
    _jump851:;
    int64_t _420;
    // Computing bound for i
    if (_261.d0 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for j
    int64_t _421 = 134;
    if (_421 > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing bound for k
    int64_t _422 = 326;
    if (_422 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    _420 = 0;
    int64_t _423 = 0; // k
    int64_t _424 = 0; // j
    int64_t _425 = 0; // i
    _jump855:; // Begin body of loop
    _420 += _261.d0;
    _423++;
    if (_423 < _422)
    goto _jump855;
    _423 = 0;
    _424++;
    if (_424 < _421)
    goto _jump855;
    _424 = 0;
    _425++;
    if (_425 < _261.d0)
    goto _jump855;
    // End body of loop
    int64_t _426 = _418 - _420;
    _416 = _426;
    goto _jump856;
    _jump849:;
    bool _427 = _261.d0 >= _261.d0;
    bool _428 = !_427;
    int64_t _429;
    if (!_428)
    goto _jump857;
    _429 = _261.d0;
    goto _jump858;
    _jump857:;
    int64_t _430 = -_261.d0;
    int64_t _431;
    // Computing bound for i
    if (_89.d0 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    // Computing bound for j
    if (_261.d1 > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    _431 = 0;
    int64_t _432 = 0; // j
    int64_t _433 = 0; // i
    _jump861:; // Begin body of loop
    _431 += _261.d0;
    _432++;
    if (_432 < _261.d1)
    goto _jump861;
    _432 = 0;
    _433++;
    if (_433 < _89.d0)
    goto _jump861;
    // End body of loop
    int64_t _434 = _430 - _431;
    _429 = _434;
    _jump858:;
    int64_t _435 = -_89.d0;
    int64_t _436 = _429 - _435;
    _416 = _436;
    _jump856:;
    int64_t _437;
    // Computing bound for i
    int64_t _438;
    // Computing bound for i
    if (_89.d0 > 0) 
    goto _jump862;
    fail_assertion("non-positive loop bound");
    _jump862:;
    // Computing bound for j
    if (_89.d1 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing bound for k
    int64_t _439 = -_261.d1;
    if (_439 > 0) 
    goto _jump864;
    fail_assertion("non-positive loop bound");
    _jump864:;
    _438 = 0;
    int64_t _440 = 0; // k
    int64_t _441 = 0; // j
    int64_t _442 = 0; // i
    _jump865:; // Begin body of loop
    _438 += _440;
    _440++;
    if (_440 < _439)
    goto _jump865;
    _440 = 0;
    _441++;
    if (_441 < _89.d1)
    goto _jump865;
    _441 = 0;
    _442++;
    if (_442 < _89.d0)
    goto _jump865;
    // End body of loop
    if (_438 > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    _437 = 0;
    int64_t _443 = 0; // i
    _jump867:; // Begin body of loop
    int64_t _444 = 902;
    _437 += _444;
    _443++;
    if (_443 < _438)
    goto _jump867;
    // End body of loop
    int64_t _445 = -_437;
    int64_t _446 = -_445;
    _a3_bool _448;
    // Computing bound for i
    _448.d0 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing bound for j
    _448.d1 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing bound for k
    _448.d2 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    // Computing total size of heap memory to allocate
    int64_t _449 = 1;
    _449 *= _261.d1;
    _449 *= _261.d0;
    _449 *= _261.d0;
    _449 *= sizeof(bool);
    _448.data = jpl_alloc(_449);
    int64_t _450 = 0; // k
    int64_t _451 = 0; // j
    int64_t _452 = 0; // i
    _jump871:; // Begin body of loop
    bool _453 = true;
    int64_t _454 = 0;
    _454 *= _448.d0;
    _454 += _452;
    _454 *= _448.d1;
    _454 += _451;
    _454 *= _448.d2;
    _454 += _450;
    _448.data[_454] = _453;
    _450++;
    if (_450 < _261.d0)
    goto _jump871;
    _450 = 0;
    _451++;
    if (_451 < _261.d0)
    goto _jump871;
    _451 = 0;
    _452++;
    if (_452 < _261.d1)
    goto _jump871;
    // End body of loop
    int64_t _455 = 733;
    int64_t _456 = _261.d0 + _89.d1;
    if (_455 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_455 < _448.d0)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    if (_261.d0 >= 0)
    goto _jump874;
    fail_assertion("negative array index");
    _jump874:;
    if (_261.d0 < _448.d1)
    goto _jump875;
    fail_assertion("index too large");
    _jump875:;
    if (_456 >= 0)
    goto _jump876;
    fail_assertion("negative array index");
    _jump876:;
    if (_456 < _448.d2)
    goto _jump877;
    fail_assertion("index too large");
    _jump877:;
    int64_t _457 = 0;
    _457 *= _448.d0;
    _457 += _455;
    _457 *= _448.d1;
    _457 += _261.d0;
    _457 *= _448.d2;
    _457 += _456;
    bool _458 = _448.data[_457];
    bool _447 = _458;
    if (0 == _458)
    goto _jump878;
    int64_t _459 = 148;
    int64_t _460 = -_261.d0;
    bool _461 = _459 < _460;
    _447 = _461;
    _jump878:;
    _a1_int64_t _462;
    if (!_447)
    goto _jump879;
    _a1_int64_t _463;
    // Computing bound for i
    _463.d0 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= _89.d1;
    _464 *= sizeof(int64_t);
    _463.data = jpl_alloc(_464);
    int64_t _465 = 0; // i
    _jump881:; // Begin body of loop
    int64_t _466 = 0;
    _466 *= _463.d0;
    _466 += _465;
    _463.data[_466] = _465;
    _465++;
    if (_465 < _89.d1)
    goto _jump881;
    // End body of loop
    _462 = _463;
    goto _jump882;
    _jump879:;
    _a3__a1_int64_t _467;
    // Computing bound for i
    _467.d0 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump883;
    fail_assertion("non-positive loop bound");
    _jump883:;
    // Computing bound for j
    _467.d1 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump884;
    fail_assertion("non-positive loop bound");
    _jump884:;
    // Computing bound for k
    _467.d2 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing total size of heap memory to allocate
    int64_t _468 = 1;
    _468 *= _89.d0;
    _468 *= _261.d1;
    _468 *= _261.d1;
    _468 *= sizeof(_a1_int64_t);
    _467.data = jpl_alloc(_468);
    int64_t _469 = 0; // k
    int64_t _470 = 0; // j
    int64_t _471 = 0; // i
    _jump886:; // Begin body of loop
    if (_470 >= 0)
    goto _jump887;
    fail_assertion("negative array index");
    _jump887:;
    if (_470 < _89.d0)
    goto _jump888;
    fail_assertion("index too large");
    _jump888:;
    if (_89.d1 >= 0)
    goto _jump889;
    fail_assertion("negative array index");
    _jump889:;
    if (_89.d1 < _89.d1)
    goto _jump890;
    fail_assertion("index too large");
    _jump890:;
    int64_t _472 = 0;
    _472 *= _89.d0;
    _472 += _470;
    _472 *= _89.d1;
    _472 += _89.d1;
    _a1_int64_t _473 = _89.data[_472];
    int64_t _474 = 0;
    _474 *= _467.d0;
    _474 += _471;
    _474 *= _467.d1;
    _474 += _470;
    _474 *= _467.d2;
    _474 += _469;
    _467.data[_474] = _473;
    _469++;
    if (_469 < _261.d1)
    goto _jump886;
    _469 = 0;
    _470++;
    if (_470 < _261.d1)
    goto _jump886;
    _470 = 0;
    _471++;
    if (_471 < _89.d0)
    goto _jump886;
    // End body of loop
    int64_t _475;
    // Computing bound for i
    if (_261.d1 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    _475 = 0;
    int64_t _476 = 0; // i
    _jump892:; // Begin body of loop
    _475 += _261.d1;
    _476++;
    if (_476 < _261.d1)
    goto _jump892;
    // End body of loop
    int64_t _477 = _89.d1 * _475;
    if (_261.d0 >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (_261.d0 < _467.d0)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    if (_477 >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (_477 < _467.d1)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    if (_261.d1 >= 0)
    goto _jump897;
    fail_assertion("negative array index");
    _jump897:;
    if (_261.d1 < _467.d2)
    goto _jump898;
    fail_assertion("index too large");
    _jump898:;
    int64_t _478 = 0;
    _478 *= _467.d0;
    _478 += _261.d0;
    _478 *= _467.d1;
    _478 += _477;
    _478 *= _467.d2;
    _478 += _261.d1;
    _a1_int64_t _479 = _467.data[_478];
    _462 = _479;
    _jump882:;
    if (_89.d0 >= 0)
    goto _jump899;
    fail_assertion("negative array index");
    _jump899:;
    if (_89.d0 < _462.d0)
    goto _jump900;
    fail_assertion("index too large");
    _jump900:;
    int64_t _480 = 0;
    _480 *= _462.d0;
    _480 += _89.d0;
    int64_t _481 = _462.data[_480];
    if (_416 >= 0)
    goto _jump901;
    fail_assertion("negative array index");
    _jump901:;
    if (_416 < _343.d0)
    goto _jump902;
    fail_assertion("index too large");
    _jump902:;
    if (_446 >= 0)
    goto _jump903;
    fail_assertion("negative array index");
    _jump903:;
    if (_446 < _343.d1)
    goto _jump904;
    fail_assertion("index too large");
    _jump904:;
    if (_481 >= 0)
    goto _jump905;
    fail_assertion("negative array index");
    _jump905:;
    if (_481 < _343.d2)
    goto _jump906;
    fail_assertion("index too large");
    _jump906:;
    int64_t _482 = 0;
    _482 *= _343.d0;
    _482 += _416;
    _482 *= _343.d1;
    _482 += _446;
    _482 *= _343.d2;
    _482 += _481;
    _a3_int64_t _483 = _343.data[_482];
    _312 = _483;
    goto _jump907;
    _jump784:;
    int64_t _484;
    // Computing bound for i
    if (_89.d1 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    _484 = 0;
    int64_t _485 = 0; // i
    _jump909:; // Begin body of loop
    _484 += _89.d1;
    _485++;
    if (_485 < _89.d1)
    goto _jump909;
    // End body of loop
    int64_t _486 = _484 + _89.d0;
    int64_t _487 = -_89.d0;
    bool _488 = _486 == _487;
    bool _489 = true;
    bool _490 = !_489;
    bool _491 = _488 != _490;
    _a3__a3_int64_t _492;
    if (!_491)
    goto _jump910;
    _a3__a3_int64_t _493;
    // Computing bound for i
    int64_t _494;
    // Computing bound for i
    if (_89.d0 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing bound for j
    int64_t _495 = _89.d1 - _89.d1;
    int64_t _496 = -_495;
    if (_496 > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    // Computing bound for k
    int64_t _497 = 112;
    if (_497 > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    _494 = 0;
    int64_t _498 = 0; // k
    int64_t _499 = 0; // j
    int64_t _500 = 0; // i
    _jump914:; // Begin body of loop
    _494 += _89.d0;
    _498++;
    if (_498 < _497)
    goto _jump914;
    _498 = 0;
    _499++;
    if (_499 < _496)
    goto _jump914;
    _499 = 0;
    _500++;
    if (_500 < _89.d0)
    goto _jump914;
    // End body of loop
    _493.d0 = _494;
    if (_494 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing bound for j
    double _501 = 88.0;
    double _502 = 28.0;
    bool _503 = _501 != _502;
    bool _504 = !_503;
    int64_t _505;
    if (!_504)
    goto _jump916;
    int64_t _506;
    // Computing bound for i
    int64_t _507;
    // Computing bound for i
    int64_t _508 = 918;
    if (_508 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    _507 = 0;
    int64_t _509 = 0; // i
    _jump918:; // Begin body of loop
    _507 += _89.d0;
    _509++;
    if (_509 < _508)
    goto _jump918;
    // End body of loop
    if (_507 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    _506 = 0;
    int64_t _510 = 0; // i
    _jump920:; // Begin body of loop
    int64_t _511;
    // Computing bound for j
    if (_261.d0 > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing bound for k
    if (_89.d1 > 0) 
    goto _jump922;
    fail_assertion("non-positive loop bound");
    _jump922:;
    _511 = 0;
    int64_t _512 = 0; // k
    int64_t _513 = 0; // j
    _jump923:; // Begin body of loop
    _511 += _89.d1;
    _512++;
    if (_512 < _89.d1)
    goto _jump923;
    _512 = 0;
    _513++;
    if (_513 < _261.d0)
    goto _jump923;
    // End body of loop
    _506 += _511;
    _510++;
    if (_510 < _507)
    goto _jump920;
    // End body of loop
    _505 = _506;
    goto _jump924;
    _jump916:;
    int64_t _514;
    // Computing bound for i
    int64_t _515 = -_89.d0;
    if (_515 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for j
    int64_t _516 = 151;
    if (_516 > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing bound for k
    int64_t _517 = 580;
    int64_t _518 = -_517;
    if (_518 > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    _514 = 0;
    int64_t _519 = 0; // k
    int64_t _520 = 0; // j
    int64_t _521 = 0; // i
    _jump928:; // Begin body of loop
    _514 += _89.d1;
    _519++;
    if (_519 < _518)
    goto _jump928;
    _519 = 0;
    _520++;
    if (_520 < _516)
    goto _jump928;
    _520 = 0;
    _521++;
    if (_521 < _515)
    goto _jump928;
    // End body of loop
    _505 = _514;
    _jump924:;
    _493.d1 = _505;
    if (_505 > 0) 
    goto _jump929;
    fail_assertion("non-positive loop bound");
    _jump929:;
    // Computing bound for k
    _493.d2 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump930;
    fail_assertion("non-positive loop bound");
    _jump930:;
    // Computing total size of heap memory to allocate
    int64_t _522 = 1;
    _522 *= _494;
    _522 *= _505;
    _522 *= _89.d0;
    _522 *= sizeof(_a3_int64_t);
    _493.data = jpl_alloc(_522);
    int64_t _523 = 0; // k
    int64_t _524 = 0; // j
    int64_t _525 = 0; // i
    _jump931:; // Begin body of loop
    bool _526 = _89.d0 != _89.d0;
    _a3_int64_t _527;
    if (!_526)
    goto _jump932;
    _a3_int64_t _528;
    // Computing bound for l
    _528.d0 = _525;
    if (_525 > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    // Computing bound for m
    _528.d1 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for n
    int64_t _529 = -_525;
    _528.d2 = _529;
    if (_529 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _530 = 1;
    _530 *= _525;
    _530 *= _89.d1;
    _530 *= _529;
    _530 *= sizeof(int64_t);
    _528.data = jpl_alloc(_530);
    int64_t _531 = 0; // n
    int64_t _532 = 0; // m
    int64_t _533 = 0; // l
    _jump936:; // Begin body of loop
    int64_t _534 = 0;
    _534 *= _528.d0;
    _534 += _533;
    _534 *= _528.d1;
    _534 += _532;
    _534 *= _528.d2;
    _534 += _531;
    _528.data[_534] = _532;
    _531++;
    if (_531 < _529)
    goto _jump936;
    _531 = 0;
    _532++;
    if (_532 < _89.d1)
    goto _jump936;
    _532 = 0;
    _533++;
    if (_533 < _525)
    goto _jump936;
    // End body of loop
    _527 = _528;
    goto _jump937;
    _jump932:;
    _a3_int64_t _535;
    // Computing bound for l
    _535.d0 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing bound for m
    _535.d1 = _523;
    if (_523 > 0) 
    goto _jump939;
    fail_assertion("non-positive loop bound");
    _jump939:;
    // Computing bound for n
    int64_t _536 = -_524;
    _535.d2 = _536;
    if (_536 > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    // Computing total size of heap memory to allocate
    int64_t _537 = 1;
    _537 *= _89.d1;
    _537 *= _523;
    _537 *= _536;
    _537 *= sizeof(int64_t);
    _535.data = jpl_alloc(_537);
    int64_t _538 = 0; // n
    int64_t _539 = 0; // m
    int64_t _540 = 0; // l
    _jump941:; // Begin body of loop
    int64_t _541 = 0;
    _541 *= _535.d0;
    _541 += _540;
    _541 *= _535.d1;
    _541 += _539;
    _541 *= _535.d2;
    _541 += _538;
    _535.data[_541] = _89.d1;
    _538++;
    if (_538 < _536)
    goto _jump941;
    _538 = 0;
    _539++;
    if (_539 < _523)
    goto _jump941;
    _539 = 0;
    _540++;
    if (_540 < _89.d1)
    goto _jump941;
    // End body of loop
    _527 = _535;
    _jump937:;
    int64_t _542 = 0;
    _542 *= _493.d0;
    _542 += _525;
    _542 *= _493.d1;
    _542 += _524;
    _542 *= _493.d2;
    _542 += _523;
    _493.data[_542] = _527;
    _523++;
    if (_523 < _89.d0)
    goto _jump931;
    _523 = 0;
    _524++;
    if (_524 < _505)
    goto _jump931;
    _524 = 0;
    _525++;
    if (_525 < _494)
    goto _jump931;
    // End body of loop
    _492 = _493;
    goto _jump942;
    _jump910:;
    int64_t _543;
    // Computing bound for i
    int64_t _544 = 612;
    if (_544 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    _543 = 0;
    int64_t _545 = 0; // i
    _jump944:; // Begin body of loop
    _543 += _89.d1;
    _545++;
    if (_545 < _544)
    goto _jump944;
    // End body of loop
    int64_t _546 = -_261.d0;
    int64_t _547 = _261.d0 % _546;
    bool _548 = _543 != _547;
    _a3__a3_int64_t _549;
    if (!_548)
    goto _jump945;
    bool _550 = true;
    _a3__a3_int64_t _551;
    if (!_550)
    goto _jump946;
    _a3__a3_int64_t _552;
    // Computing bound for i
    _552.d0 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for j
    _552.d1 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing bound for k
    bool _553 = false;
    int64_t _554;
    if (!_553)
    goto _jump949;
    _554 = _261.d0;
    goto _jump950;
    _jump949:;
    _554 = _89.d0;
    _jump950:;
    _552.d2 = _554;
    if (_554 > 0) 
    goto _jump951;
    fail_assertion("non-positive loop bound");
    _jump951:;
    // Computing total size of heap memory to allocate
    int64_t _555 = 1;
    _555 *= _89.d1;
    _555 *= _89.d1;
    _555 *= _554;
    _555 *= sizeof(_a3_int64_t);
    _552.data = jpl_alloc(_555);
    int64_t _556 = 0; // k
    int64_t _557 = 0; // j
    int64_t _558 = 0; // i
    _jump952:; // Begin body of loop
    _a3_int64_t _559;
    // Computing bound for l
    _559.d0 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    // Computing bound for m
    _559.d1 = _558;
    if (_558 > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing bound for n
    _559.d2 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing total size of heap memory to allocate
    int64_t _560 = 1;
    _560 *= _261.d1;
    _560 *= _558;
    _560 *= _89.d0;
    _560 *= sizeof(int64_t);
    _559.data = jpl_alloc(_560);
    int64_t _561 = 0; // n
    int64_t _562 = 0; // m
    int64_t _563 = 0; // l
    _jump956:; // Begin body of loop
    int64_t _564 = 0;
    _564 *= _559.d0;
    _564 += _563;
    _564 *= _559.d1;
    _564 += _562;
    _564 *= _559.d2;
    _564 += _561;
    _559.data[_564] = _561;
    _561++;
    if (_561 < _89.d0)
    goto _jump956;
    _561 = 0;
    _562++;
    if (_562 < _558)
    goto _jump956;
    _562 = 0;
    _563++;
    if (_563 < _261.d1)
    goto _jump956;
    // End body of loop
    int64_t _565 = 0;
    _565 *= _552.d0;
    _565 += _558;
    _565 *= _552.d1;
    _565 += _557;
    _565 *= _552.d2;
    _565 += _556;
    _552.data[_565] = _559;
    _556++;
    if (_556 < _554)
    goto _jump952;
    _556 = 0;
    _557++;
    if (_557 < _89.d1)
    goto _jump952;
    _557 = 0;
    _558++;
    if (_558 < _89.d1)
    goto _jump952;
    // End body of loop
    _551 = _552;
    goto _jump957;
    _jump946:;
    _a3__a3_int64_t _566;
    // Computing bound for i
    int64_t _567 = -_89.d1;
    _566.d0 = _567;
    if (_567 > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing bound for j
    _566.d1 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing bound for k
    int64_t _568;
    // Computing bound for i
    if (_89.d0 > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for j
    if (_89.d0 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for k
    if (_261.d1 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    _568 = 0;
    int64_t _569 = 0; // k
    int64_t _570 = 0; // j
    int64_t _571 = 0; // i
    _jump963:; // Begin body of loop
    _568 += _261.d0;
    _569++;
    if (_569 < _261.d1)
    goto _jump963;
    _569 = 0;
    _570++;
    if (_570 < _89.d0)
    goto _jump963;
    _570 = 0;
    _571++;
    if (_571 < _89.d0)
    goto _jump963;
    // End body of loop
    _566.d2 = _568;
    if (_568 > 0) 
    goto _jump964;
    fail_assertion("non-positive loop bound");
    _jump964:;
    // Computing total size of heap memory to allocate
    int64_t _572 = 1;
    _572 *= _567;
    _572 *= _261.d0;
    _572 *= _568;
    _572 *= sizeof(_a3_int64_t);
    _566.data = jpl_alloc(_572);
    int64_t _573 = 0; // k
    int64_t _574 = 0; // j
    int64_t _575 = 0; // i
    _jump965:; // Begin body of loop
    _a3_int64_t _576;
    // Computing bound for l
    _576.d0 = _573;
    if (_573 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing bound for m
    _576.d1 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump967;
    fail_assertion("non-positive loop bound");
    _jump967:;
    // Computing bound for n
    _576.d2 = _261.d1;
    if (_261.d1 > 0) 
    goto _jump968;
    fail_assertion("non-positive loop bound");
    _jump968:;
    // Computing total size of heap memory to allocate
    int64_t _577 = 1;
    _577 *= _573;
    _577 *= _89.d0;
    _577 *= _261.d1;
    _577 *= sizeof(int64_t);
    _576.data = jpl_alloc(_577);
    int64_t _578 = 0; // n
    int64_t _579 = 0; // m
    int64_t _580 = 0; // l
    _jump969:; // Begin body of loop
    int64_t _581 = 0;
    _581 *= _576.d0;
    _581 += _580;
    _581 *= _576.d1;
    _581 += _579;
    _581 *= _576.d2;
    _581 += _578;
    _576.data[_581] = _89.d1;
    _578++;
    if (_578 < _261.d1)
    goto _jump969;
    _578 = 0;
    _579++;
    if (_579 < _89.d0)
    goto _jump969;
    _579 = 0;
    _580++;
    if (_580 < _573)
    goto _jump969;
    // End body of loop
    int64_t _582 = 0;
    _582 *= _566.d0;
    _582 += _575;
    _582 *= _566.d1;
    _582 += _574;
    _582 *= _566.d2;
    _582 += _573;
    _566.data[_582] = _576;
    _573++;
    if (_573 < _568)
    goto _jump965;
    _573 = 0;
    _574++;
    if (_574 < _261.d0)
    goto _jump965;
    _574 = 0;
    _575++;
    if (_575 < _567)
    goto _jump965;
    // End body of loop
    _551 = _566;
    _jump957:;
    _549 = _551;
    goto _jump970;
    _jump945:;
    _a3__a3_int64_t _583;
    // Computing bound for i
    int64_t _584;
    // Computing bound for i
    if (_261.d0 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    _584 = 0;
    int64_t _585 = 0; // i
    _jump972:; // Begin body of loop
    _584 += _89.d1;
    _585++;
    if (_585 < _261.d0)
    goto _jump972;
    // End body of loop
    _583.d0 = _584;
    if (_584 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for j
    bool _586 = true;
    int64_t _587;
    if (!_586)
    goto _jump974;
    _587 = _89.d0;
    goto _jump975;
    _jump974:;
    int64_t _588 = 128;
    _587 = _588;
    _jump975:;
    int64_t _589 = 380;
    int64_t _590 = _587 - _589;
    _583.d1 = _590;
    if (_590 > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    // Computing bound for k
    _a1_int64_t _591;
    // Computing bound for i
    _591.d0 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing total size of heap memory to allocate
    int64_t _592 = 1;
    _592 *= _261.d0;
    _592 *= sizeof(int64_t);
    _591.data = jpl_alloc(_592);
    int64_t _593 = 0; // i
    _jump978:; // Begin body of loop
    int64_t _594 = 0;
    _594 *= _591.d0;
    _594 += _593;
    _591.data[_594] = _261.d0;
    _593++;
    if (_593 < _261.d0)
    goto _jump978;
    // End body of loop
    if (_89.d0 >= 0)
    goto _jump979;
    fail_assertion("negative array index");
    _jump979:;
    if (_89.d0 < _591.d0)
    goto _jump980;
    fail_assertion("index too large");
    _jump980:;
    int64_t _595 = 0;
    _595 *= _591.d0;
    _595 += _89.d0;
    int64_t _596 = _591.data[_595];
    _583.d2 = _596;
    if (_596 > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    // Computing total size of heap memory to allocate
    int64_t _597 = 1;
    _597 *= _584;
    _597 *= _590;
    _597 *= _596;
    _597 *= sizeof(_a3_int64_t);
    _583.data = jpl_alloc(_597);
    int64_t _598 = 0; // k
    int64_t _599 = 0; // j
    int64_t _600 = 0; // i
    _jump982:; // Begin body of loop
    _a3_int64_t _601;
    // Computing bound for l
    _601.d0 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for m
    int64_t _602 = 925;
    int64_t _603 = -_602;
    _601.d1 = _603;
    if (_603 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing bound for n
    _601.d2 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    // Computing total size of heap memory to allocate
    int64_t _604 = 1;
    _604 *= _261.d0;
    _604 *= _603;
    _604 *= _89.d0;
    _604 *= sizeof(int64_t);
    _601.data = jpl_alloc(_604);
    int64_t _605 = 0; // n
    int64_t _606 = 0; // m
    int64_t _607 = 0; // l
    _jump986:; // Begin body of loop
    int64_t _608 = 704;
    int64_t _609 = -_608;
    int64_t _610 = 0;
    _610 *= _601.d0;
    _610 += _607;
    _610 *= _601.d1;
    _610 += _606;
    _610 *= _601.d2;
    _610 += _605;
    _601.data[_610] = _609;
    _605++;
    if (_605 < _89.d0)
    goto _jump986;
    _605 = 0;
    _606++;
    if (_606 < _603)
    goto _jump986;
    _606 = 0;
    _607++;
    if (_607 < _261.d0)
    goto _jump986;
    // End body of loop
    int64_t _611 = 0;
    _611 *= _583.d0;
    _611 += _600;
    _611 *= _583.d1;
    _611 += _599;
    _611 *= _583.d2;
    _611 += _598;
    _583.data[_611] = _601;
    _598++;
    if (_598 < _596)
    goto _jump982;
    _598 = 0;
    _599++;
    if (_599 < _590)
    goto _jump982;
    _599 = 0;
    _600++;
    if (_600 < _584)
    goto _jump982;
    // End body of loop
    _549 = _583;
    _jump970:;
    _492 = _549;
    _jump942:;
    _a2_int64_t _612;
    // Computing bound for i
    int64_t _613 = _261.d1 / _261.d1;
    int64_t _614 = 190;
    int64_t _615 = _613 + _614;
    _612.d0 = _615;
    if (_615 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing bound for j
    int64_t _616 = _261.d1 - _89.d0;
    _612.d1 = _616;
    if (_616 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing total size of heap memory to allocate
    int64_t _617 = 1;
    _617 *= _615;
    _617 *= _616;
    _617 *= sizeof(int64_t);
    _612.data = jpl_alloc(_617);
    int64_t _618 = 0; // j
    int64_t _619 = 0; // i
    _jump989:; // Begin body of loop
    int64_t _620 = 0;
    _620 *= _612.d0;
    _620 += _619;
    _620 *= _612.d1;
    _620 += _618;
    _612.data[_620] = _89.d0;
    _618++;
    if (_618 < _616)
    goto _jump989;
    _618 = 0;
    _619++;
    if (_619 < _615)
    goto _jump989;
    // End body of loop
    int64_t _621 = 64;
    if (_621 >= 0)
    goto _jump990;
    fail_assertion("negative array index");
    _jump990:;
    if (_621 < _612.d0)
    goto _jump991;
    fail_assertion("index too large");
    _jump991:;
    if (_261.d0 >= 0)
    goto _jump992;
    fail_assertion("negative array index");
    _jump992:;
    if (_261.d0 < _612.d1)
    goto _jump993;
    fail_assertion("index too large");
    _jump993:;
    int64_t _622 = 0;
    _622 *= _612.d0;
    _622 += _621;
    _622 *= _612.d1;
    _622 += _261.d0;
    int64_t _623 = _612.data[_622];
    _a1_int64_t _624;
    // Computing bound for i
    int64_t _625 = 300;
    _624.d0 = _625;
    if (_625 > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    // Computing total size of heap memory to allocate
    int64_t _626 = 1;
    _626 *= _625;
    _626 *= sizeof(int64_t);
    _624.data = jpl_alloc(_626);
    int64_t _627 = 0; // i
    _jump995:; // Begin body of loop
    bool _628 = true;
    int64_t _629;
    if (!_628)
    goto _jump996;
    _629 = _627;
    goto _jump997;
    _jump996:;
    _629 = _261.d0;
    _jump997:;
    int64_t _630 = -_629;
    int64_t _631 = 0;
    _631 *= _624.d0;
    _631 += _627;
    _624.data[_631] = _630;
    _627++;
    if (_627 < _625)
    goto _jump995;
    // End body of loop
    if (_89.d0 >= 0)
    goto _jump998;
    fail_assertion("negative array index");
    _jump998:;
    if (_89.d0 < _624.d0)
    goto _jump999;
    fail_assertion("index too large");
    _jump999:;
    int64_t _632 = 0;
    _632 *= _624.d0;
    _632 += _89.d0;
    int64_t _633 = _624.data[_632];
    int64_t _634 = _623 + _633;
    int64_t _635;
    // Computing bound for i
    if (_89.d1 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for j
    bool _636 = false;
    bool _637 = !_636;
    int64_t _638;
    if (!_637)
    goto _jump1001;
    _638 = _89.d0;
    goto _jump1002;
    _jump1001:;
    int64_t _639;
    // Computing bound for i
    if (_261.d0 > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    // Computing bound for j
    if (_89.d0 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for k
    if (_261.d0 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    _639 = 0;
    int64_t _640 = 0; // k
    int64_t _641 = 0; // j
    int64_t _642 = 0; // i
    _jump1006:; // Begin body of loop
    int64_t _643 = 514;
    _639 += _643;
    _640++;
    if (_640 < _261.d0)
    goto _jump1006;
    _640 = 0;
    _641++;
    if (_641 < _89.d0)
    goto _jump1006;
    _641 = 0;
    _642++;
    if (_642 < _261.d0)
    goto _jump1006;
    // End body of loop
    int64_t _644;
    // Computing bound for i
    if (_89.d1 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    _644 = 0;
    int64_t _645 = 0; // i
    _jump1008:; // Begin body of loop
    _644 += _89.d0;
    _645++;
    if (_645 < _89.d1)
    goto _jump1008;
    // End body of loop
    bool _646 = _639 == _644;
    int64_t _647;
    if (!_646)
    goto _jump1009;
    int64_t _648;
    // Computing bound for i
    int64_t _649 = -_261.d1;
    if (_649 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for j
    int64_t _650 = 303;
    if (_650 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    _648 = 0;
    int64_t _651 = 0; // j
    int64_t _652 = 0; // i
    _jump1012:; // Begin body of loop
    int64_t _653 = 873;
    _648 += _653;
    _651++;
    if (_651 < _650)
    goto _jump1012;
    _651 = 0;
    _652++;
    if (_652 < _649)
    goto _jump1012;
    // End body of loop
    _647 = _648;
    goto _jump1013;
    _jump1009:;
    _647 = _89.d0;
    _jump1013:;
    _638 = _647;
    _jump1002:;
    if (_638 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing bound for k
    int64_t _654 = -_261.d1;
    if (_654 > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    _635 = 0;
    int64_t _655 = 0; // k
    int64_t _656 = 0; // j
    int64_t _657 = 0; // i
    _jump1016:; // Begin body of loop
    int64_t _658 = _261.d0 - _655;
    _635 += _658;
    _655++;
    if (_655 < _654)
    goto _jump1016;
    _655 = 0;
    _656++;
    if (_656 < _638)
    goto _jump1016;
    _656 = 0;
    _657++;
    if (_657 < _89.d1)
    goto _jump1016;
    // End body of loop
    if (_261.d0 >= 0)
    goto _jump1017;
    fail_assertion("negative array index");
    _jump1017:;
    if (_261.d0 < _492.d0)
    goto _jump1018;
    fail_assertion("index too large");
    _jump1018:;
    if (_634 >= 0)
    goto _jump1019;
    fail_assertion("negative array index");
    _jump1019:;
    if (_634 < _492.d1)
    goto _jump1020;
    fail_assertion("index too large");
    _jump1020:;
    if (_635 >= 0)
    goto _jump1021;
    fail_assertion("negative array index");
    _jump1021:;
    if (_635 < _492.d2)
    goto _jump1022;
    fail_assertion("index too large");
    _jump1022:;
    int64_t _659 = 0;
    _659 *= _492.d0;
    _659 += _261.d0;
    _659 *= _492.d1;
    _659 += _634;
    _659 *= _492.d2;
    _659 += _635;
    _a3_int64_t _660 = _492.data[_659];
    _312 = _660;
    _jump907:;
    _a1_bool _661;
    // Computing bound for m
    int64_t _662 = -_312.d1;
    bool _663 = _662 <= _312.d0;
    bool _664;
    if (!_663)
    goto _jump1023;
    bool _666 = false;
    bool _665 = _666;
    if (0 == _666)
    goto _jump1024;
    bool _668 = true;
    bool _667 = _668;
    if (0 == _668)
    goto _jump1025;
    bool _669 = false;
    _667 = _669;
    _jump1025:;
    bool _670 = true;
    bool _671 = !_670;
    bool _672 = _667 != _671;
    _665 = _672;
    _jump1024:;
    _664 = _665;
    goto _jump1026;
    _jump1023:;
    bool _673 = false;
    bool _674;
    if (!_673)
    goto _jump1027;
    int64_t _675;
    // Computing bound for m
    if (_261.d0 > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing bound for n
    if (_89.d1 > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    _675 = 0;
    int64_t _676 = 0; // n
    int64_t _677 = 0; // m
    _jump1030:; // Begin body of loop
    _675 += _312.d1;
    _676++;
    if (_676 < _89.d1)
    goto _jump1030;
    _676 = 0;
    _677++;
    if (_677 < _261.d0)
    goto _jump1030;
    // End body of loop
    bool _678 = _675 >= _89.d0;
    _674 = _678;
    goto _jump1031;
    _jump1027:;
    bool _679 = false;
    _674 = _679;
    _jump1031:;
    _664 = _674;
    _jump1026:;
    _a3_int64_t _680;
    if (!_664)
    goto _jump1032;
    _a3_int64_t _681;
    // Computing bound for m
    _681.d0 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump1033;
    fail_assertion("non-positive loop bound");
    _jump1033:;
    // Computing bound for n
    _681.d1 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing bound for o
    _a1_int64_t _682;
    // Computing bound for m
    int64_t _683;
    // Computing bound for m
    if (_312.d1 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    _683 = 0;
    int64_t _684 = 0; // m
    _jump1036:; // Begin body of loop
    _683 += _312.d1;
    _684++;
    if (_684 < _312.d1)
    goto _jump1036;
    // End body of loop
    _682.d0 = _683;
    if (_683 > 0) 
    goto _jump1037;
    fail_assertion("non-positive loop bound");
    _jump1037:;
    // Computing total size of heap memory to allocate
    int64_t _685 = 1;
    _685 *= _683;
    _685 *= sizeof(int64_t);
    _682.data = jpl_alloc(_685);
    int64_t _686 = 0; // m
    _jump1038:; // Begin body of loop
    int64_t _687 = 0;
    _687 *= _682.d0;
    _687 += _686;
    _682.data[_687] = _312.d0;
    _686++;
    if (_686 < _683)
    goto _jump1038;
    // End body of loop
    if (_261.d1 >= 0)
    goto _jump1039;
    fail_assertion("negative array index");
    _jump1039:;
    if (_261.d1 < _682.d0)
    goto _jump1040;
    fail_assertion("index too large");
    _jump1040:;
    int64_t _688 = 0;
    _688 *= _682.d0;
    _688 += _261.d1;
    int64_t _689 = _682.data[_688];
    _681.d2 = _689;
    if (_689 > 0) 
    goto _jump1041;
    fail_assertion("non-positive loop bound");
    _jump1041:;
    // Computing total size of heap memory to allocate
    int64_t _690 = 1;
    _690 *= _89.d1;
    _690 *= _261.d0;
    _690 *= _689;
    _690 *= sizeof(int64_t);
    _681.data = jpl_alloc(_690);
    int64_t _691 = 0; // o
    int64_t _692 = 0; // n
    int64_t _693 = 0; // m
    _jump1042:; // Begin body of loop
    int64_t _694 = 0;
    _694 *= _681.d0;
    _694 += _693;
    _694 *= _681.d1;
    _694 += _692;
    _694 *= _681.d2;
    _694 += _691;
    _681.data[_694] = _693;
    _691++;
    if (_691 < _689)
    goto _jump1042;
    _691 = 0;
    _692++;
    if (_692 < _261.d0)
    goto _jump1042;
    _692 = 0;
    _693++;
    if (_693 < _89.d1)
    goto _jump1042;
    // End body of loop
    _680 = _681;
    goto _jump1043;
    _jump1032:;
    _a3_int64_t _695;
    // Computing bound for m
    int64_t _696 = 192;
    _695.d0 = _696;
    if (_696 > 0) 
    goto _jump1044;
    fail_assertion("non-positive loop bound");
    _jump1044:;
    // Computing bound for n
    int64_t _697 = -_261.d1;
    _695.d1 = _697;
    if (_697 > 0) 
    goto _jump1045;
    fail_assertion("non-positive loop bound");
    _jump1045:;
    // Computing bound for o
    _695.d2 = _312.d2;
    if (_312.d2 > 0) 
    goto _jump1046;
    fail_assertion("non-positive loop bound");
    _jump1046:;
    // Computing total size of heap memory to allocate
    int64_t _698 = 1;
    _698 *= _696;
    _698 *= _697;
    _698 *= _312.d2;
    _698 *= sizeof(int64_t);
    _695.data = jpl_alloc(_698);
    int64_t _699 = 0; // o
    int64_t _700 = 0; // n
    int64_t _701 = 0; // m
    _jump1047:; // Begin body of loop
    int64_t _702 = 0;
    _702 *= _695.d0;
    _702 += _701;
    _702 *= _695.d1;
    _702 += _700;
    _702 *= _695.d2;
    _702 += _699;
    _695.data[_702] = _701;
    _699++;
    if (_699 < _312.d2)
    goto _jump1047;
    _699 = 0;
    _700++;
    if (_700 < _697)
    goto _jump1047;
    _700 = 0;
    _701++;
    if (_701 < _696)
    goto _jump1047;
    // End body of loop
    _680 = _695;
    _jump1043:;
    int64_t _703 = _89.d0 - _89.d0;
    if (_312.d2 >= 0)
    goto _jump1048;
    fail_assertion("negative array index");
    _jump1048:;
    if (_312.d2 < _680.d0)
    goto _jump1049;
    fail_assertion("index too large");
    _jump1049:;
    if (_312.d1 >= 0)
    goto _jump1050;
    fail_assertion("negative array index");
    _jump1050:;
    if (_312.d1 < _680.d1)
    goto _jump1051;
    fail_assertion("index too large");
    _jump1051:;
    if (_703 >= 0)
    goto _jump1052;
    fail_assertion("negative array index");
    _jump1052:;
    if (_703 < _680.d2)
    goto _jump1053;
    fail_assertion("index too large");
    _jump1053:;
    int64_t _704 = 0;
    _704 *= _680.d0;
    _704 += _312.d2;
    _704 *= _680.d1;
    _704 += _312.d1;
    _704 *= _680.d2;
    _704 += _703;
    int64_t _705 = _680.data[_704];
    _661.d0 = _705;
    if (_705 > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing total size of heap memory to allocate
    int64_t _706 = 1;
    _706 *= _705;
    _706 *= sizeof(bool);
    _661.data = jpl_alloc(_706);
    int64_t _707 = 0; // m
    _jump1055:; // Begin body of loop
    bool _709 = _261.d0 <= _707;
    bool _708 = _709;
    if (0 != _709)
    goto _jump1056;
    bool _710 = _261.d0 <= _89.d0;
    _708 = _710;
    _jump1056:;
    bool _711 = !_708;
    int64_t _712 = 0;
    _712 *= _661.d0;
    _712 += _707;
    _661.data[_712] = _711;
    _707++;
    if (_707 < _705)
    goto _jump1055;
    // End body of loop
    _a2__a2__a1_int64_t _713;
    // Computing bound for o
    int64_t _714 = -_661.d0;
    _713.d0 = _714;
    if (_714 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing bound for p
    _713.d1 = _312.d2;
    if (_312.d2 > 0) 
    goto _jump1058;
    fail_assertion("non-positive loop bound");
    _jump1058:;
    // Computing total size of heap memory to allocate
    int64_t _715 = 1;
    _715 *= _714;
    _715 *= _312.d2;
    _715 *= sizeof(_a2__a1_int64_t);
    _713.data = jpl_alloc(_715);
    int64_t _716 = 0; // p
    int64_t _717 = 0; // o
    _jump1059:; // Begin body of loop
    int64_t _718 = 0;
    _718 *= _713.d0;
    _718 += _717;
    _718 *= _713.d1;
    _718 += _716;
    _713.data[_718] = _89;
    _716++;
    if (_716 < _312.d2)
    goto _jump1059;
    _716 = 0;
    _717++;
    if (_717 < _714)
    goto _jump1059;
    // End body of loop
    _a1_bool _719;
    // Computing bound for p
    int64_t _720 = 552;
    int64_t _721 = -_312.d0;
    int64_t _722 = _720 % _721;
    int64_t _723 = _312.d1 + _722;
    int64_t _724 = _312.d1 + _723;
    int64_t _725 = 728;
    int64_t _726 = _312.d0 % _725;
    int64_t _727 = _724 + _726;
    _719.d0 = _727;
    if (_727 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing total size of heap memory to allocate
    int64_t _728 = 1;
    _728 *= _727;
    _728 *= sizeof(bool);
    _719.data = jpl_alloc(_728);
    int64_t _729 = 0; // p
    _jump1061:; // Begin body of loop
    bool _730 = false;
    bool _731;
    if (!_730)
    goto _jump1062;
    bool _732 = true;
    _731 = _732;
    goto _jump1063;
    _jump1062:;
    int64_t _734 = -_312.d2;
    bool _735 = _89.d1 == _734;
    bool _736;
    if (!_735)
    goto _jump1064;
    bool _737 = true;
    _736 = _737;
    goto _jump1065;
    _jump1064:;
    bool _738 = true;
    _736 = _738;
    _jump1065:;
    bool _733 = _736;
    if (0 == _736)
    goto _jump1066;
    if (_261.d1 >= 0)
    goto _jump1067;
    fail_assertion("negative array index");
    _jump1067:;
    if (_261.d1 < _661.d0)
    goto _jump1068;
    fail_assertion("index too large");
    _jump1068:;
    int64_t _739 = 0;
    _739 *= _661.d0;
    _739 += _261.d1;
    bool _740 = _661.data[_739];
    _a1_bool _741;
    if (!_740)
    goto _jump1069;
    _741 = _661;
    goto _jump1070;
    _jump1069:;
    _741 = _661;
    _jump1070:;
    int64_t _742;
    // Computing bound for q
    if (_312.d0 > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing bound for r
    if (_661.d0 > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    _742 = 0;
    int64_t _743 = 0; // r
    int64_t _744 = 0; // q
    _jump1073:; // Begin body of loop
    _742 += _89.d1;
    _743++;
    if (_743 < _661.d0)
    goto _jump1073;
    _743 = 0;
    _744++;
    if (_744 < _312.d0)
    goto _jump1073;
    // End body of loop
    int64_t _745 = _261.d1 % _742;
    if (_745 >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (_745 < _741.d0)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    int64_t _746 = 0;
    _746 *= _741.d0;
    _746 += _745;
    bool _747 = _741.data[_746];
    _733 = _747;
    _jump1066:;
    _731 = _733;
    _jump1063:;
    bool _748;
    if (!_731)
    goto _jump1076;
    _a2_double _749;
    // Computing bound for q
    int64_t _750 = 243;
    _749.d0 = _750;
    if (_750 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    // Computing bound for r
    _749.d1 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    // Computing total size of heap memory to allocate
    int64_t _751 = 1;
    _751 *= _750;
    _751 *= _89.d0;
    _751 *= sizeof(double);
    _749.data = jpl_alloc(_751);
    int64_t _752 = 0; // r
    int64_t _753 = 0; // q
    _jump1079:; // Begin body of loop
    double _754 = 77.0;
    int64_t _755 = 0;
    _755 *= _749.d0;
    _755 += _753;
    _755 *= _749.d1;
    _755 += _752;
    _749.data[_755] = _754;
    _752++;
    if (_752 < _89.d0)
    goto _jump1079;
    _752 = 0;
    _753++;
    if (_753 < _750)
    goto _jump1079;
    // End body of loop
    if (_312.d1 >= 0)
    goto _jump1080;
    fail_assertion("negative array index");
    _jump1080:;
    if (_312.d1 < _749.d0)
    goto _jump1081;
    fail_assertion("index too large");
    _jump1081:;
    if (_312.d0 >= 0)
    goto _jump1082;
    fail_assertion("negative array index");
    _jump1082:;
    if (_312.d0 < _749.d1)
    goto _jump1083;
    fail_assertion("index too large");
    _jump1083:;
    int64_t _756 = 0;
    _756 *= _749.d0;
    _756 += _312.d1;
    _756 *= _749.d1;
    _756 += _312.d0;
    double _757 = _749.data[_756];
    double _758 = 40.0;
    double _759 = fmod(_757, _758);
    double _760 = 60.0;
    double _761;
    // Computing bound for q
    int64_t _762 = 212;
    if (_762 > 0) 
    goto _jump1084;
    fail_assertion("non-positive loop bound");
    _jump1084:;
    // Computing bound for r
    if (_729 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    _761 = 0;
    int64_t _763 = 0; // r
    int64_t _764 = 0; // q
    _jump1086:; // Begin body of loop
    double _765;
    // Computing bound for s
    if (_661.d0 > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    _765 = 0;
    int64_t _766 = 0; // s
    _jump1088:; // Begin body of loop
    double _767 = 45.0;
    _765 += _767;
    _766++;
    if (_766 < _661.d0)
    goto _jump1088;
    // End body of loop
    double _768 = -_765;
    _761 += _768;
    _763++;
    if (_763 < _729)
    goto _jump1086;
    _763 = 0;
    _764++;
    if (_764 < _762)
    goto _jump1086;
    // End body of loop
    double _769 = _760 * _761;
    bool _770 = _759 < _769;
    _748 = _770;
    goto _jump1089;
    _jump1076:;
    bool _771 = true;
    _748 = _771;
    _jump1089:;
    int64_t _772 = 0;
    _772 *= _719.d0;
    _772 += _729;
    _719.data[_772] = _748;
    _729++;
    if (_729 < _727)
    goto _jump1061;
    // End body of loop
    int64_t _775 = 189;
    bool _776 = _775 >= _89.d1;
    bool _774 = _776;
    if (0 != _776)
    goto _jump1090;
    bool _777 = _261.d1 != _261.d0;
    _774 = _777;
    _jump1090:;
    bool _778 = !_774;
    bool _779 = !_778;
    bool _773 = _779;
    if (0 != _779)
    goto _jump1091;
    _a3_bool _780;
    // Computing bound for r
    int64_t _781 = -_312.d0;
    _780.d0 = _781;
    if (_781 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing bound for s
    _780.d1 = _312.d1;
    if (_312.d1 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing bound for t
    _780.d2 = _261.d0;
    if (_261.d0 > 0) 
    goto _jump1094;
    fail_assertion("non-positive loop bound");
    _jump1094:;
    // Computing total size of heap memory to allocate
    int64_t _782 = 1;
    _782 *= _781;
    _782 *= _312.d1;
    _782 *= _261.d0;
    _782 *= sizeof(bool);
    _780.data = jpl_alloc(_782);
    int64_t _783 = 0; // t
    int64_t _784 = 0; // s
    int64_t _785 = 0; // r
    _jump1095:; // Begin body of loop
    int64_t _786 = -_783;
    bool _787 = _786 == _261.d1;
    int64_t _788 = 0;
    _788 *= _780.d0;
    _788 += _785;
    _788 *= _780.d1;
    _788 += _784;
    _788 *= _780.d2;
    _788 += _783;
    _780.data[_788] = _787;
    _783++;
    if (_783 < _261.d0)
    goto _jump1095;
    _783 = 0;
    _784++;
    if (_784 < _312.d1)
    goto _jump1095;
    _784 = 0;
    _785++;
    if (_785 < _781)
    goto _jump1095;
    // End body of loop
    bool _789 = _261.d1 > _89.d0;
    int64_t _790;
    if (!_789)
    goto _jump1096;
    int64_t _791;
    // Computing bound for r
    int64_t _792 = -_261.d0;
    if (_792 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for s
    int64_t _793 = -_261.d0;
    if (_793 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    _791 = 0;
    int64_t _794 = 0; // s
    int64_t _795 = 0; // r
    _jump1099:; // Begin body of loop
    _791 += _795;
    _794++;
    if (_794 < _793)
    goto _jump1099;
    _794 = 0;
    _795++;
    if (_795 < _792)
    goto _jump1099;
    // End body of loop
    _790 = _791;
    goto _jump1100;
    _jump1096:;
    _790 = _312.d1;
    _jump1100:;
    int64_t _796;
    // Computing bound for r
    if (_261.d0 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing bound for s
    int64_t _797 = 704;
    if (_797 > 0) 
    goto _jump1102;
    fail_assertion("non-positive loop bound");
    _jump1102:;
    _796 = 0;
    int64_t _798 = 0; // s
    int64_t _799 = 0; // r
    _jump1103:; // Begin body of loop
    _796 += _312.d2;
    _798++;
    if (_798 < _797)
    goto _jump1103;
    _798 = 0;
    _799++;
    if (_799 < _261.d0)
    goto _jump1103;
    // End body of loop
    if (_790 >= 0)
    goto _jump1104;
    fail_assertion("negative array index");
    _jump1104:;
    if (_790 < _780.d0)
    goto _jump1105;
    fail_assertion("index too large");
    _jump1105:;
    if (_89.d0 >= 0)
    goto _jump1106;
    fail_assertion("negative array index");
    _jump1106:;
    if (_89.d0 < _780.d1)
    goto _jump1107;
    fail_assertion("index too large");
    _jump1107:;
    if (_796 >= 0)
    goto _jump1108;
    fail_assertion("negative array index");
    _jump1108:;
    if (_796 < _780.d2)
    goto _jump1109;
    fail_assertion("index too large");
    _jump1109:;
    int64_t _800 = 0;
    _800 *= _780.d0;
    _800 += _790;
    _800 *= _780.d1;
    _800 += _89.d0;
    _800 *= _780.d2;
    _800 += _796;
    bool _801 = _780.data[_800];
    _773 = _801;
    _jump1091:;
    bool _802 = _261.d1 >= _261.d1;
    bool _803 = _773 == _802;
    bool _804 = !_803;
    double _805 = get_time();
    _a2_rgba _806 = read_image("t.png");
    int64_t u = _806.d0;
    int64_t v = _806.d1;
    double _807 = get_time();
    print_time(_807 - _805);
    print("w");
    _a2_rgba _808 = read_image("w.png");
    bool _809 = false;
    bool _810 = !_809;
    _a1__a1__a3_int64_t _811;
    if (!_810)
    goto _jump1110;
    _a3__a1__a1__a3_int64_t _812;
    // Computing bound for x
    int64_t _813 = 439;
    _812.d0 = _813;
    if (_813 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for y
    int64_t _814 = 848;
    _812.d1 = _814;
    if (_814 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing bound for z
    _812.d2 = _312.d1;
    if (_312.d1 > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    // Computing total size of heap memory to allocate
    int64_t _815 = 1;
    _815 *= _813;
    _815 *= _814;
    _815 *= _312.d1;
    _815 *= sizeof(_a1__a1__a3_int64_t);
    _812.data = jpl_alloc(_815);
    int64_t _816 = 0; // z
    int64_t _817 = 0; // y
    int64_t _818 = 0; // x
    _jump1114:; // Begin body of loop
    _a1__a3_int64_t _819;
    // Computing bound for A
    _819.d0 = _719.d0;
    if (_719.d0 > 0) 
    goto _jump1115;
    fail_assertion("non-positive loop bound");
    _jump1115:;
    // Computing total size of heap memory to allocate
    int64_t _820 = 1;
    _820 *= _719.d0;
    _820 *= sizeof(_a3_int64_t);
    _819.data = jpl_alloc(_820);
    int64_t _821 = 0; // A
    _jump1116:; // Begin body of loop
    int64_t _822 = 0;
    _822 *= _819.d0;
    _822 += _821;
    _819.data[_822] = _312;
    _821++;
    if (_821 < _719.d0)
    goto _jump1116;
    // End body of loop
    bool _823 = _804;
    if (0 != _804)
    goto _jump1117;
    _823 = _804;
    _jump1117:;
    _a1__a3_int64_t _824;
    if (!_823)
    goto _jump1118;
    _a1__a3_int64_t _825;
    // Computing bound for A
    _825.d0 = _817;
    if (_817 > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing total size of heap memory to allocate
    int64_t _826 = 1;
    _826 *= _817;
    _826 *= sizeof(_a3_int64_t);
    _825.data = jpl_alloc(_826);
    int64_t _827 = 0; // A
    _jump1120:; // Begin body of loop
    int64_t _828 = 0;
    _828 *= _825.d0;
    _828 += _827;
    _825.data[_828] = _312;
    _827++;
    if (_827 < _817)
    goto _jump1120;
    // End body of loop
    _824 = _825;
    goto _jump1121;
    _jump1118:;
    _a1__a3_int64_t _829;
    // Computing bound for A
    _829.d0 = _312.d2;
    if (_312.d2 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    // Computing total size of heap memory to allocate
    int64_t _830 = 1;
    _830 *= _312.d2;
    _830 *= sizeof(_a3_int64_t);
    _829.data = jpl_alloc(_830);
    int64_t _831 = 0; // A
    _jump1123:; // Begin body of loop
    int64_t _832 = 0;
    _832 *= _829.d0;
    _832 += _831;
    _829.data[_832] = _312;
    _831++;
    if (_831 < _312.d2)
    goto _jump1123;
    // End body of loop
    _824 = _829;
    _jump1121:;
    _a1__a1__a3_int64_t _833;
    _833.d0 = 2;
    _833.data = jpl_alloc(sizeof(_a1__a3_int64_t) * 2);
    _833.data[0] = _819;
    _833.data[1] = _824;
    int64_t _834 = 0;
    _834 *= _812.d0;
    _834 += _818;
    _834 *= _812.d1;
    _834 += _817;
    _834 *= _812.d2;
    _834 += _816;
    _812.data[_834] = _833;
    _816++;
    if (_816 < _312.d1)
    goto _jump1114;
    _816 = 0;
    _817++;
    if (_817 < _814)
    goto _jump1114;
    _817 = 0;
    _818++;
    if (_818 < _813)
    goto _jump1114;
    // End body of loop
    int64_t _835;
    // Computing bound for x
    if (_89.d0 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing bound for y
    if (_806.d0 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    _835 = 0;
    int64_t _836 = 0; // y
    int64_t _837 = 0; // x
    _jump1126:; // Begin body of loop
    _835 += _312.d0;
    _836++;
    if (_836 < _806.d0)
    goto _jump1126;
    _836 = 0;
    _837++;
    if (_837 < _89.d0)
    goto _jump1126;
    // End body of loop
    if (_312.d1 >= 0)
    goto _jump1127;
    fail_assertion("negative array index");
    _jump1127:;
    if (_312.d1 < _812.d0)
    goto _jump1128;
    fail_assertion("index too large");
    _jump1128:;
    if (_89.d0 >= 0)
    goto _jump1129;
    fail_assertion("negative array index");
    _jump1129:;
    if (_89.d0 < _812.d1)
    goto _jump1130;
    fail_assertion("index too large");
    _jump1130:;
    if (_835 >= 0)
    goto _jump1131;
    fail_assertion("negative array index");
    _jump1131:;
    if (_835 < _812.d2)
    goto _jump1132;
    fail_assertion("index too large");
    _jump1132:;
    int64_t _838 = 0;
    _838 *= _812.d0;
    _838 += _312.d1;
    _838 *= _812.d1;
    _838 += _89.d0;
    _838 *= _812.d2;
    _838 += _835;
    _a1__a1__a3_int64_t _839 = _812.data[_838];
    _811 = _839;
    goto _jump1133;
    _jump1110:;
    bool _840 = false;
    _a2__a1__a1__a3_int64_t _841;
    if (!_840)
    goto _jump1134;
    _a2__a1__a1__a3_int64_t _842;
    // Computing bound for x
    _842.d0 = _312.d0;
    if (_312.d0 > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    // Computing bound for y
    int64_t _843 = 12;
    bool _844 = _843 > _661.d0;
    int64_t _845;
    if (!_844)
    goto _jump1136;
    _845 = _312.d2;
    goto _jump1137;
    _jump1136:;
    _845 = _261.d1;
    _jump1137:;
    _842.d1 = _845;
    if (_845 > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing total size of heap memory to allocate
    int64_t _846 = 1;
    _846 *= _312.d0;
    _846 *= _845;
    _846 *= sizeof(_a1__a1__a3_int64_t);
    _842.data = jpl_alloc(_846);
    int64_t _847 = 0; // y
    int64_t _848 = 0; // x
    _jump1139:; // Begin body of loop
    _a1__a1__a3_int64_t _849;
    // Computing bound for z
    _849.d0 = _312.d1;
    if (_312.d1 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    // Computing total size of heap memory to allocate
    int64_t _850 = 1;
    _850 *= _312.d1;
    _850 *= sizeof(_a1__a3_int64_t);
    _849.data = jpl_alloc(_850);
    int64_t _851 = 0; // z
    _jump1141:; // Begin body of loop
    _a1__a3_int64_t _852;
    // Computing bound for A
    int64_t _853 = 419;
    _852.d0 = _853;
    if (_853 > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    // Computing total size of heap memory to allocate
    int64_t _854 = 1;
    _854 *= _853;
    _854 *= sizeof(_a3_int64_t);
    _852.data = jpl_alloc(_854);
    int64_t _855 = 0; // A
    _jump1143:; // Begin body of loop
    int64_t _856 = 0;
    _856 *= _852.d0;
    _856 += _855;
    _852.data[_856] = _312;
    _855++;
    if (_855 < _853)
    goto _jump1143;
    // End body of loop
    int64_t _857 = 0;
    _857 *= _849.d0;
    _857 += _851;
    _849.data[_857] = _852;
    _851++;
    if (_851 < _312.d1)
    goto _jump1141;
    // End body of loop
    int64_t _858 = 0;
    _858 *= _842.d0;
    _858 += _848;
    _858 *= _842.d1;
    _858 += _847;
    _842.data[_858] = _849;
    _847++;
    if (_847 < _845)
    goto _jump1139;
    _847 = 0;
    _848++;
    if (_848 < _312.d0)
    goto _jump1139;
    // End body of loop
    _841 = _842;
    goto _jump1144;
    _jump1134:;
    _a2__a1__a1__a3_int64_t _859;
    // Computing bound for x
    int64_t _860 = 606;
    _859.d0 = _860;
    if (_860 > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing bound for y
    _859.d1 = _806.d1;
    if (_806.d1 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing total size of heap memory to allocate
    int64_t _861 = 1;
    _861 *= _860;
    _861 *= _806.d1;
    _861 *= sizeof(_a1__a1__a3_int64_t);
    _859.data = jpl_alloc(_861);
    int64_t _862 = 0; // y
    int64_t _863 = 0; // x
    _jump1147:; // Begin body of loop
    _a1__a1__a3_int64_t _864;
    // Computing bound for z
    _864.d0 = _312.d0;
    if (_312.d0 > 0) 
    goto _jump1148;
    fail_assertion("non-positive loop bound");
    _jump1148:;
    // Computing total size of heap memory to allocate
    int64_t _865 = 1;
    _865 *= _312.d0;
    _865 *= sizeof(_a1__a3_int64_t);
    _864.data = jpl_alloc(_865);
    int64_t _866 = 0; // z
    _jump1149:; // Begin body of loop
    _a1__a3_int64_t _867;
    // Computing bound for A
    _867.d0 = _863;
    if (_863 > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    // Computing total size of heap memory to allocate
    int64_t _868 = 1;
    _868 *= _863;
    _868 *= sizeof(_a3_int64_t);
    _867.data = jpl_alloc(_868);
    int64_t _869 = 0; // A
    _jump1151:; // Begin body of loop
    int64_t _870 = 0;
    _870 *= _867.d0;
    _870 += _869;
    _867.data[_870] = _312;
    _869++;
    if (_869 < _863)
    goto _jump1151;
    // End body of loop
    int64_t _871 = 0;
    _871 *= _864.d0;
    _871 += _866;
    _864.data[_871] = _867;
    _866++;
    if (_866 < _312.d0)
    goto _jump1149;
    // End body of loop
    int64_t _872 = 0;
    _872 *= _859.d0;
    _872 += _863;
    _872 *= _859.d1;
    _872 += _862;
    _859.data[_872] = _864;
    _862++;
    if (_862 < _806.d1)
    goto _jump1147;
    _862 = 0;
    _863++;
    if (_863 < _860)
    goto _jump1147;
    // End body of loop
    _841 = _859;
    _jump1144:;
    int64_t _873;
    // Computing bound for x
    if (_312.d0 > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    // Computing bound for y
    if (_89.d0 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    _873 = 0;
    int64_t _874 = 0; // y
    int64_t _875 = 0; // x
    _jump1154:; // Begin body of loop
    _873 += _89.d1;
    _874++;
    if (_874 < _89.d0)
    goto _jump1154;
    _874 = 0;
    _875++;
    if (_875 < _312.d0)
    goto _jump1154;
    // End body of loop
    if (_873 >= 0)
    goto _jump1155;
    fail_assertion("negative array index");
    _jump1155:;
    if (_873 < _841.d0)
    goto _jump1156;
    fail_assertion("index too large");
    _jump1156:;
    if (_806.d0 >= 0)
    goto _jump1157;
    fail_assertion("negative array index");
    _jump1157:;
    if (_806.d0 < _841.d1)
    goto _jump1158;
    fail_assertion("index too large");
    _jump1158:;
    int64_t _876 = 0;
    _876 *= _841.d0;
    _876 += _873;
    _876 *= _841.d1;
    _876 += _806.d0;
    _a1__a1__a3_int64_t _877 = _841.data[_876];
    _811 = _877;
    _jump1133:;
    if (_661.d0 >= 0)
    goto _jump1159;
    fail_assertion("negative array index");
    _jump1159:;
    if (_661.d0 < _811.d0)
    goto _jump1160;
    fail_assertion("index too large");
    _jump1160:;
    int64_t _878 = 0;
    _878 *= _811.d0;
    _878 += _661.d0;
    _a1__a3_int64_t _879 = _811.data[_878];
    _a1_int64_t _880;
    // Computing bound for A
    _880.d0 = _89.d1;
    if (_89.d1 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    // Computing total size of heap memory to allocate
    int64_t _881 = 1;
    _881 *= _89.d1;
    _881 *= sizeof(int64_t);
    _880.data = jpl_alloc(_881);
    int64_t _882 = 0; // A
    _jump1176:; // Begin body of loop
    int64_t _883 = 0;
    _883 *= _880.d0;
    _883 += _882;
    _880.data[_883] = _806.d0;
    _882++;
    if (_882 < _89.d1)
    goto _jump1176;
    // End body of loop
    double _884 = get_time();
    double _885 = get_time();
    print_time(_885 - _884);
    bool _886 = true;
    if (0 != _886)
    goto _jump1324;
    fail_assertion("K");
    _jump1324:;
    int64_t _887;
    // Computing bound for K
    if (_806.d0 > 0) 
    goto _jump1325;
    fail_assertion("non-positive loop bound");
    _jump1325:;
    // Computing bound for L
    if (_713.d0 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    // Computing bound for M
    int64_t _888;
    // Computing bound for K
    int64_t _889;
    // Computing bound for K
    if (_312.d2 > 0) 
    goto _jump1327;
    fail_assertion("non-positive loop bound");
    _jump1327:;
    // Computing bound for L
    if (_719.d0 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    _889 = 0;
    int64_t _890 = 0; // L
    int64_t _891 = 0; // K
    _jump1329:; // Begin body of loop
    _889 += _880.d0;
    _890++;
    if (_890 < _719.d0)
    goto _jump1329;
    _890 = 0;
    _891++;
    if (_891 < _312.d2)
    goto _jump1329;
    // End body of loop
    if (_889 > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    // Computing bound for L
    if (_879.d0 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    _888 = 0;
    int64_t _892 = 0; // L
    int64_t _893 = 0; // K
    _jump1332:; // Begin body of loop
    _888 += _89.d0;
    _892++;
    if (_892 < _879.d0)
    goto _jump1332;
    _892 = 0;
    _893++;
    if (_893 < _889)
    goto _jump1332;
    // End body of loop
    int64_t _894 = _888 + _312.d2;
    if (_894 > 0) 
    goto _jump1333;
    fail_assertion("non-positive loop bound");
    _jump1333:;
    _887 = 0;
    int64_t _895 = 0; // M
    int64_t _896 = 0; // L
    int64_t _897 = 0; // K
    _jump1334:; // Begin body of loop
    _887 += _312.d2;
    _895++;
    if (_895 < _894)
    goto _jump1334;
    _895 = 0;
    _896++;
    if (_896 < _713.d0)
    goto _jump1334;
    _896 = 0;
    _897++;
    if (_897 < _806.d0)
    goto _jump1334;
    // End body of loop
    show("(IntType)", &_887);
}

