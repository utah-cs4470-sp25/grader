
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_int64_t *data;
} _a2__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_void_t *data;
} _a2__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_void_t *data;
} _a3__a1_void_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_int64_t *data;
} _a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2__a1_int64_t *data;
} _a2__a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_bool *data;
} _a2__a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  _a1_void_t *data;
} _a1__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2__a2_int64_t *data;
} _a1__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_bool *data;
} _a3__a3__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a1_bool *data;
} _a2__a3__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1_void_t *data;
} _a3__a1__a1_void_t;

typedef struct {
  int64_t d0;
  _a3__a1__a1_void_t *data;
} _a1__a3__a1__a1_void_t;

typedef struct {
  int64_t d0;
  _a3__a3_double *data;
} _a1__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
    bool a;
    void_t b;
    bool c;
} s;

double c(int64_t d, void_t e) {
    bool _1 = false;
    bool _0 = _1;
    if (0 == _1)
    goto _jump38;
    _0 = b;
    _jump38:;
    bool _2 = false;
    int64_t _3;
    if (!_2)
    goto _jump39;
    int64_t _4 = 324;
    _3 = _4;
    goto _jump40;
    _jump39:;
    int64_t _5 = -d;
    _3 = _5;
    _jump40:;
    int64_t _6 = -d;
    bool _7 = _6 == d;
    int64_t _8;
    if (!_7)
    goto _jump41;
    int64_t _9 = 780;
    int64_t _10 = -_9;
    _8 = _10;
    goto _jump42;
    _jump41:;
    int64_t _11 = 347;
    int64_t _12 = _11 + d;
    int64_t _13 = d * _12;
    _8 = _13;
    _jump42:;
    bool _14 = _3 == _8;
    bool _15 = _0 != _14;
    double _16;
    if (!_15)
    goto _jump43;
    double _17;
    // Computing bound for f
    if (d > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    _17 = 0;
    int64_t _18 = 0; // f
    _jump45:; // Begin body of loop
    double _19;
    // Computing bound for g
    int64_t _20 = 465;
    int64_t _21 = -_20;
    if (_21 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    // Computing bound for h
    double _22 = c(d, e);
    double _23 = 92.0;
    bool _24 = _22 < _23;
    int64_t _25;
    if (!_24)
    goto _jump47;
    int64_t _26 = 688;
    _25 = _26;
    goto _jump48;
    _jump47:;
    int64_t _27 = 820;
    int64_t _28 = -_27;
    int64_t _29 = -_28;
    _25 = _29;
    _jump48:;
    if (_25 > 0) 
    goto _jump49;
    fail_assertion("non-positive loop bound");
    _jump49:;
    // Computing bound for i
    int64_t _30 = 379;
    if (_30 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    _19 = 0;
    int64_t _31 = 0; // i
    int64_t _32 = 0; // h
    int64_t _33 = 0; // g
    _jump51:; // Begin body of loop
    double _34 = 25.0;
    _19 += _34;
    _31++;
    if (_31 < _30)
    goto _jump51;
    _31 = 0;
    _32++;
    if (_32 < _25)
    goto _jump51;
    _32 = 0;
    _33++;
    if (_33 < _21)
    goto _jump51;
    // End body of loop
    _17 += _19;
    _18++;
    if (_18 < d)
    goto _jump45;
    // End body of loop
    _16 = _17;
    goto _jump52;
    _jump43:;
    double _35 = 33.0;
    double _36 = 83.0;
    double _37 = _35 + _36;
    double _38 = -_37;
    double _39 = 46.0;
    double _40 = c(d, e);
    double _41 = _39 * _40;
    bool _42 = _38 <= _41;
    int64_t _43;
    if (!_42)
    goto _jump53;
    int64_t _44 = 138;
    _43 = _44;
    goto _jump54;
    _jump53:;
    bool _45 = false;
    int64_t _46;
    if (!_45)
    goto _jump55;
    int64_t _47;
    // Computing bound for f
    if (d > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    _47 = 0;
    int64_t _48 = 0; // f
    _jump57:; // Begin body of loop
    int64_t _49 = 806;
    _47 += _49;
    _48++;
    if (_48 < d)
    goto _jump57;
    // End body of loop
    _46 = _47;
    goto _jump58;
    _jump55:;
    int64_t _50;
    // Computing bound for f
    int64_t _51 = 901;
    if (_51 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    // Computing bound for g
    if (d > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    _50 = 0;
    int64_t _52 = 0; // g
    int64_t _53 = 0; // f
    _jump61:; // Begin body of loop
    _50 += _52;
    _52++;
    if (_52 < d)
    goto _jump61;
    _52 = 0;
    _53++;
    if (_53 < _51)
    goto _jump61;
    // End body of loop
    _46 = _50;
    _jump58:;
    int64_t _54 = _46 / d;
    _43 = _54;
    _jump54:;
    bool _55 = false;
    _a2_void_t _56;
    if (!_55)
    goto _jump62;
    _a2_void_t _57;
    // Computing bound for f
    _57.d0 = d;
    if (d > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing bound for g
    int64_t _58;
    // Computing bound for f
    if (d > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    _58 = 0;
    int64_t _59 = 0; // f
    _jump65:; // Begin body of loop
    _58 += d;
    _59++;
    if (_59 < d)
    goto _jump65;
    // End body of loop
    _57.d1 = _58;
    if (_58 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= d;
    _60 *= _58;
    _60 *= sizeof(void_t);
    _57.data = jpl_alloc(_60);
    int64_t _61 = 0; // g
    int64_t _62 = 0; // f
    _jump67:; // Begin body of loop
    int64_t _63 = 0;
    _63 *= _57.d0;
    _63 += _62;
    _63 *= _57.d1;
    _63 += _61;
    _57.data[_63] = e;
    _61++;
    if (_61 < _58)
    goto _jump67;
    _61 = 0;
    _62++;
    if (_62 < d)
    goto _jump67;
    // End body of loop
    _56 = _57;
    goto _jump68;
    _jump62:;
    bool _65 = true;
    bool _64 = _65;
    if (0 != _65)
    goto _jump69;
    bool _66 = true;
    _64 = _66;
    _jump69:;
    _a2_void_t _67;
    if (!_64)
    goto _jump70;
    _a2_void_t _68;
    // Computing bound for f
    int64_t _69 = 280;
    _68.d0 = _69;
    if (_69 > 0) 
    goto _jump71;
    fail_assertion("non-positive loop bound");
    _jump71:;
    // Computing bound for g
    int64_t _70 = 814;
    _68.d1 = _70;
    if (_70 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= _69;
    _71 *= _70;
    _71 *= sizeof(void_t);
    _68.data = jpl_alloc(_71);
    int64_t _72 = 0; // g
    int64_t _73 = 0; // f
    _jump73:; // Begin body of loop
    int64_t _74 = 0;
    _74 *= _68.d0;
    _74 += _73;
    _74 *= _68.d1;
    _74 += _72;
    _68.data[_74] = e;
    _72++;
    if (_72 < _70)
    goto _jump73;
    _72 = 0;
    _73++;
    if (_73 < _69)
    goto _jump73;
    // End body of loop
    _67 = _68;
    goto _jump74;
    _jump70:;
    _a2_void_t _75;
    // Computing bound for f
    int64_t _76 = 766;
    _75.d0 = _76;
    if (_76 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for g
    _75.d1 = d;
    if (d > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _76;
    _77 *= d;
    _77 *= sizeof(void_t);
    _75.data = jpl_alloc(_77);
    int64_t _78 = 0; // g
    int64_t _79 = 0; // f
    _jump77:; // Begin body of loop
    int64_t _80 = 0;
    _80 *= _75.d0;
    _80 += _79;
    _80 *= _75.d1;
    _80 += _78;
    _75.data[_80] = e;
    _78++;
    if (_78 < d)
    goto _jump77;
    _78 = 0;
    _79++;
    if (_79 < _76)
    goto _jump77;
    // End body of loop
    _67 = _75;
    _jump74:;
    _56 = _67;
    _jump68:;
    int64_t _81;
    // Computing bound for f
    int64_t _82;
    if (!b)
    goto _jump78;
    int64_t _83 = 285;
    _82 = _83;
    goto _jump79;
    _jump78:;
    int64_t _84 = 309;
    _82 = _84;
    _jump79:;
    if (_82 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    _81 = 0;
    int64_t _85 = 0; // f
    _jump81:; // Begin body of loop
    int64_t _86 = 835;
    _81 += _86;
    _85++;
    if (_85 < _82)
    goto _jump81;
    // End body of loop
    int64_t _87 = -_81;
    int64_t _88 = -d;
    int64_t _89 = -_88;
    if (_87 >= 0)
    goto _jump82;
    fail_assertion("negative array index");
    _jump82:;
    if (_87 < _56.d0)
    goto _jump83;
    fail_assertion("index too large");
    _jump83:;
    if (_89 >= 0)
    goto _jump84;
    fail_assertion("negative array index");
    _jump84:;
    if (_89 < _56.d1)
    goto _jump85;
    fail_assertion("index too large");
    _jump85:;
    int64_t _90 = 0;
    _90 *= _56.d0;
    _90 += _87;
    _90 *= _56.d1;
    _90 += _89;
    void_t _91 = _56.data[_90];
    double _92 = c(_43, _91);
    _16 = _92;
    _jump52:;
    double _93 = -_16;
    _a2_double _94;
    // Computing bound for g
    bool _95 = !b;
    int64_t _96;
    if (!_95)
    goto _jump86;
    bool _97 = a;
    if (0 != a)
    goto _jump87;
    bool _99 = _93 >= _93;
    bool _100 = !_99;
    bool _98 = _100;
    if (0 != _100)
    goto _jump88;
    double _101 = 17.0;
    bool _102 = _101 != _93;
    bool _103;
    if (!_102)
    goto _jump89;
    bool _104 = false;
    bool _105 = true;
    bool _106 = _104 == _105;
    _103 = _106;
    goto _jump90;
    _jump89:;
    bool _107 = _93 != _93;
    _103 = _107;
    _jump90:;
    _98 = _103;
    _jump88:;
    _97 = _98;
    _jump87:;
    int64_t _108;
    if (!_97)
    goto _jump91;
    int64_t _109 = -d;
    _108 = _109;
    goto _jump92;
    _jump91:;
    int64_t _110 = 992;
    _108 = _110;
    _jump92:;
    _96 = _108;
    goto _jump93;
    _jump86:;
    int64_t _111;
    // Computing bound for g
    int64_t _112 = -d;
    int64_t _113 = -_112;
    int64_t _114 = -_113;
    int64_t _115 = -_114;
    if (_115 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    // Computing bound for h
    double _116 = c(d, e);
    double _117 = 41.0;
    bool _118 = _116 < _117;
    int64_t _119;
    if (!_118)
    goto _jump95;
    double _120 = _93 / _93;
    bool _121 = _93 > _120;
    int64_t _122;
    if (!_121)
    goto _jump96;
    int64_t _123;
    // Computing bound for g
    int64_t _124 = 926;
    if (_124 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing bound for h
    bool _125 = false;
    int64_t _126;
    if (!_125)
    goto _jump98;
    _126 = d;
    goto _jump99;
    _jump98:;
    int64_t _127 = 43;
    _126 = _127;
    _jump99:;
    if (_126 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    _123 = 0;
    int64_t _128 = 0; // h
    int64_t _129 = 0; // g
    _jump101:; // Begin body of loop
    int64_t _130;
    // Computing bound for i
    if (_129 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    // Computing bound for j
    int64_t _131 = 649;
    if (_131 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    // Computing bound for k
    int64_t _132 = 354;
    if (_132 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    _130 = 0;
    int64_t _133 = 0; // k
    int64_t _134 = 0; // j
    int64_t _135 = 0; // i
    _jump105:; // Begin body of loop
    _130 += _128;
    _133++;
    if (_133 < _132)
    goto _jump105;
    _133 = 0;
    _134++;
    if (_134 < _131)
    goto _jump105;
    _134 = 0;
    _135++;
    if (_135 < _129)
    goto _jump105;
    // End body of loop
    _123 += _130;
    _128++;
    if (_128 < _126)
    goto _jump101;
    _128 = 0;
    _129++;
    if (_129 < _124)
    goto _jump101;
    // End body of loop
    _122 = _123;
    goto _jump106;
    _jump96:;
    int64_t _136;
    // Computing bound for g
    if (d > 0) 
    goto _jump107;
    fail_assertion("non-positive loop bound");
    _jump107:;
    // Computing bound for h
    if (d > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    _136 = 0;
    int64_t _137 = 0; // h
    int64_t _138 = 0; // g
    _jump109:; // Begin body of loop
    int64_t _139 = 532;
    _136 += _139;
    _137++;
    if (_137 < d)
    goto _jump109;
    _137 = 0;
    _138++;
    if (_138 < d)
    goto _jump109;
    // End body of loop
    int64_t _140 = 164;
    int64_t _141 = d / _140;
    int64_t _142 = _136 * _141;
    _122 = _142;
    _jump106:;
    _119 = _122;
    goto _jump110;
    _jump95:;
    int64_t _143;
    // Computing bound for g
    int64_t _144;
    if (!b)
    goto _jump111;
    _144 = d;
    goto _jump112;
    _jump111:;
    _144 = d;
    _jump112:;
    int64_t _145 = 663;
    int64_t _146 = _144 * _145;
    if (_146 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    _143 = 0;
    int64_t _147 = 0; // g
    _jump114:; // Begin body of loop
    _a2_int64_t _148;
    // Computing bound for h
    _148.d0 = _147;
    if (_147 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing bound for i
    _148.d1 = _147;
    if (_147 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _147;
    _149 *= _147;
    _149 *= sizeof(int64_t);
    _148.data = jpl_alloc(_149);
    int64_t _150 = 0; // i
    int64_t _151 = 0; // h
    _jump117:; // Begin body of loop
    int64_t _152 = 0;
    _152 *= _148.d0;
    _152 += _151;
    _152 *= _148.d1;
    _152 += _150;
    _148.data[_152] = _147;
    _150++;
    if (_150 < _147)
    goto _jump117;
    _150 = 0;
    _151++;
    if (_151 < _147)
    goto _jump117;
    // End body of loop
    int64_t _153 = 655;
    int64_t _154 = 817;
    if (_153 >= 0)
    goto _jump118;
    fail_assertion("negative array index");
    _jump118:;
    if (_153 < _148.d0)
    goto _jump119;
    fail_assertion("index too large");
    _jump119:;
    if (_154 >= 0)
    goto _jump120;
    fail_assertion("negative array index");
    _jump120:;
    if (_154 < _148.d1)
    goto _jump121;
    fail_assertion("index too large");
    _jump121:;
    int64_t _155 = 0;
    _155 *= _148.d0;
    _155 += _153;
    _155 *= _148.d1;
    _155 += _154;
    int64_t _156 = _148.data[_155];
    _143 += _156;
    _147++;
    if (_147 < _146)
    goto _jump114;
    // End body of loop
    _119 = _143;
    _jump110:;
    if (_119 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    _111 = 0;
    int64_t _157 = 0; // h
    int64_t _158 = 0; // g
    _jump123:; // Begin body of loop
    int64_t _159 = 48;
    _111 += _159;
    _157++;
    if (_157 < _119)
    goto _jump123;
    _157 = 0;
    _158++;
    if (_158 < _115)
    goto _jump123;
    // End body of loop
    _96 = _111;
    _jump93:;
    _94.d0 = _96;
    if (_96 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    // Computing bound for h
    int64_t _160;
    // Computing bound for g
    int64_t _161;
    // Computing bound for g
    int64_t _162;
    // Computing bound for g
    if (d > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    _162 = 0;
    int64_t _163 = 0; // g
    _jump126:; // Begin body of loop
    _162 += d;
    _163++;
    if (_163 < d)
    goto _jump126;
    // End body of loop
    if (_162 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for h
    _a1_int64_t _164;
    // Computing bound for g
    int64_t _165 = -d;
    int64_t _166 = 948;
    int64_t _167 = -_166;
    int64_t _168 = _165 % _167;
    _164.d0 = _168;
    if (_168 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= _168;
    _169 *= sizeof(int64_t);
    _164.data = jpl_alloc(_169);
    int64_t _170 = 0; // g
    _jump129:; // Begin body of loop
    int64_t _171;
    // Computing bound for h
    if (_170 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for i
    int64_t _172 = _170 + d;
    if (_172 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    _171 = 0;
    int64_t _173 = 0; // i
    int64_t _174 = 0; // h
    _jump132:; // Begin body of loop
    int64_t _175 = 152;
    int64_t _176 = -_175;
    _171 += _176;
    _173++;
    if (_173 < _172)
    goto _jump132;
    _173 = 0;
    _174++;
    if (_174 < _170)
    goto _jump132;
    // End body of loop
    int64_t _177 = 0;
    _177 *= _164.d0;
    _177 += _170;
    _164.data[_177] = _171;
    _170++;
    if (_170 < _168)
    goto _jump129;
    // End body of loop
    _a2_int64_t _178;
    // Computing bound for g
    _178.d0 = d;
    if (d > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    // Computing bound for h
    int64_t _179 = -d;
    _178.d1 = _179;
    if (_179 > 0) 
    goto _jump134;
    fail_assertion("non-positive loop bound");
    _jump134:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= d;
    _180 *= _179;
    _180 *= sizeof(int64_t);
    _178.data = jpl_alloc(_180);
    int64_t _181 = 0; // h
    int64_t _182 = 0; // g
    _jump135:; // Begin body of loop
    int64_t _183 = -_181;
    int64_t _184 = 0;
    _184 *= _178.d0;
    _184 += _182;
    _184 *= _178.d1;
    _184 += _181;
    _178.data[_184] = _183;
    _181++;
    if (_181 < _179)
    goto _jump135;
    _181 = 0;
    _182++;
    if (_182 < d)
    goto _jump135;
    // End body of loop
    int64_t _185;
    if (!b)
    goto _jump136;
    int64_t _186 = 201;
    _185 = _186;
    goto _jump137;
    _jump136:;
    _185 = d;
    _jump137:;
    int64_t _187 = -_185;
    int64_t _188;
    if (!b)
    goto _jump138;
    _188 = d;
    goto _jump139;
    _jump138:;
    int64_t _189 = 620;
    _188 = _189;
    _jump139:;
    if (_187 >= 0)
    goto _jump140;
    fail_assertion("negative array index");
    _jump140:;
    if (_187 < _178.d0)
    goto _jump141;
    fail_assertion("index too large");
    _jump141:;
    if (_188 >= 0)
    goto _jump142;
    fail_assertion("negative array index");
    _jump142:;
    if (_188 < _178.d1)
    goto _jump143;
    fail_assertion("index too large");
    _jump143:;
    int64_t _190 = 0;
    _190 *= _178.d0;
    _190 += _187;
    _190 *= _178.d1;
    _190 += _188;
    int64_t _191 = _178.data[_190];
    if (_191 >= 0)
    goto _jump144;
    fail_assertion("negative array index");
    _jump144:;
    if (_191 < _164.d0)
    goto _jump145;
    fail_assertion("index too large");
    _jump145:;
    int64_t _192 = 0;
    _192 *= _164.d0;
    _192 += _191;
    int64_t _193 = _164.data[_192];
    if (_193 > 0) 
    goto _jump146;
    fail_assertion("non-positive loop bound");
    _jump146:;
    _161 = 0;
    int64_t _194 = 0; // h
    int64_t _195 = 0; // g
    _jump147:; // Begin body of loop
    int64_t _196 = 702;
    _161 += _196;
    _194++;
    if (_194 < _193)
    goto _jump147;
    _194 = 0;
    _195++;
    if (_195 < _162)
    goto _jump147;
    // End body of loop
    if (_161 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    // Computing bound for h
    _a1_int64_t _197;
    if (!a)
    goto _jump149;
    _a1_int64_t _198;
    _198.d0 = 1;
    _198.data = jpl_alloc(sizeof(int64_t) * 1);
    _198.data[0] = d;
    _197 = _198;
    goto _jump150;
    _jump149:;
    _a1_int64_t _199;
    _199.d0 = 1;
    _199.data = jpl_alloc(sizeof(int64_t) * 1);
    _199.data[0] = d;
    _197 = _199;
    _jump150:;
    int64_t _200;
    if (!a)
    goto _jump151;
    _a2_int64_t _201;
    // Computing bound for g
    int64_t _202 = d - d;
    _201.d0 = _202;
    if (_202 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing bound for h
    int64_t _203;
    // Computing bound for g
    if (d > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing bound for h
    if (d > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    _203 = 0;
    int64_t _204 = 0; // h
    int64_t _205 = 0; // g
    _jump155:; // Begin body of loop
    _203 += _204;
    _204++;
    if (_204 < d)
    goto _jump155;
    _204 = 0;
    _205++;
    if (_205 < d)
    goto _jump155;
    // End body of loop
    _201.d1 = _203;
    if (_203 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= _202;
    _206 *= _203;
    _206 *= sizeof(int64_t);
    _201.data = jpl_alloc(_206);
    int64_t _207 = 0; // h
    int64_t _208 = 0; // g
    _jump157:; // Begin body of loop
    int64_t _209 = 0;
    _209 *= _201.d0;
    _209 += _208;
    _209 *= _201.d1;
    _209 += _207;
    _201.data[_209] = _207;
    _207++;
    if (_207 < _203)
    goto _jump157;
    _207 = 0;
    _208++;
    if (_208 < _202)
    goto _jump157;
    // End body of loop
    int64_t _210 = -d;
    bool _211 = false;
    int64_t _212;
    if (!_211)
    goto _jump158;
    int64_t _213;
    if (!a)
    goto _jump159;
    int64_t _214 = 75;
    _213 = _214;
    goto _jump160;
    _jump159:;
    _213 = d;
    _jump160:;
    _212 = _213;
    goto _jump161;
    _jump158:;
    _212 = d;
    _jump161:;
    if (_210 >= 0)
    goto _jump162;
    fail_assertion("negative array index");
    _jump162:;
    if (_210 < _201.d0)
    goto _jump163;
    fail_assertion("index too large");
    _jump163:;
    if (_212 >= 0)
    goto _jump164;
    fail_assertion("negative array index");
    _jump164:;
    if (_212 < _201.d1)
    goto _jump165;
    fail_assertion("index too large");
    _jump165:;
    int64_t _215 = 0;
    _215 *= _201.d0;
    _215 += _210;
    _215 *= _201.d1;
    _215 += _212;
    int64_t _216 = _201.data[_215];
    _200 = _216;
    goto _jump166;
    _jump151:;
    int64_t _217;
    if (!a)
    goto _jump167;
    int64_t _218 = 119;
    _217 = _218;
    goto _jump168;
    _jump167:;
    int64_t _219 = 848;
    _217 = _219;
    _jump168:;
    int64_t _220;
    if (!a)
    goto _jump169;
    int64_t _221;
    // Computing bound for g
    int64_t _222 = 916;
    if (_222 > 0) 
    goto _jump170;
    fail_assertion("non-positive loop bound");
    _jump170:;
    // Computing bound for h
    int64_t _223 = 546;
    if (_223 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing bound for i
    if (d > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    _221 = 0;
    int64_t _224 = 0; // i
    int64_t _225 = 0; // h
    int64_t _226 = 0; // g
    _jump173:; // Begin body of loop
    int64_t _227 = 409;
    _221 += _227;
    _224++;
    if (_224 < d)
    goto _jump173;
    _224 = 0;
    _225++;
    if (_225 < _223)
    goto _jump173;
    _225 = 0;
    _226++;
    if (_226 < _222)
    goto _jump173;
    // End body of loop
    _220 = _221;
    goto _jump174;
    _jump169:;
    _220 = d;
    _jump174:;
    int64_t _228 = _217 % _220;
    _200 = _228;
    _jump166:;
    if (_200 >= 0)
    goto _jump175;
    fail_assertion("negative array index");
    _jump175:;
    if (_200 < _197.d0)
    goto _jump176;
    fail_assertion("index too large");
    _jump176:;
    int64_t _229 = 0;
    _229 *= _197.d0;
    _229 += _200;
    int64_t _230 = _197.data[_229];
    if (_230 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    _160 = 0;
    int64_t _231 = 0; // h
    int64_t _232 = 0; // g
    _jump178:; // Begin body of loop
    _160 += _232;
    _231++;
    if (_231 < _230)
    goto _jump178;
    _231 = 0;
    _232++;
    if (_232 < _161)
    goto _jump178;
    // End body of loop
    _94.d1 = _160;
    if (_160 > 0) 
    goto _jump179;
    fail_assertion("non-positive loop bound");
    _jump179:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= _96;
    _233 *= _160;
    _233 *= sizeof(double);
    _94.data = jpl_alloc(_233);
    int64_t _234 = 0; // h
    int64_t _235 = 0; // g
    _jump180:; // Begin body of loop
    int64_t _236 = 273;
    bool _237 = d < _236;
    bool _238 = !_237;
    int64_t _239 = -_234;
    int64_t _240;
    if (!a)
    goto _jump181;
    _240 = d;
    goto _jump182;
    _jump181:;
    _240 = _234;
    _jump182:;
    bool _241 = _239 > _240;
    bool _242 = _238 != _241;
    bool _243;
    if (!_242)
    goto _jump183;
    bool _244;
    if (!b)
    goto _jump184;
    _a3_bool _245;
    // Computing bound for i
    _245.d0 = d;
    if (d > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing bound for j
    _245.d1 = _234;
    if (_234 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing bound for k
    int64_t _246 = 383;
    _245.d2 = _246;
    if (_246 > 0) 
    goto _jump187;
    fail_assertion("non-positive loop bound");
    _jump187:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= d;
    _247 *= _234;
    _247 *= _246;
    _247 *= sizeof(bool);
    _245.data = jpl_alloc(_247);
    int64_t _248 = 0; // k
    int64_t _249 = 0; // j
    int64_t _250 = 0; // i
    _jump188:; // Begin body of loop
    int64_t _251 = 0;
    _251 *= _245.d0;
    _251 += _250;
    _251 *= _245.d1;
    _251 += _249;
    _251 *= _245.d2;
    _251 += _248;
    _245.data[_251] = a;
    _248++;
    if (_248 < _246)
    goto _jump188;
    _248 = 0;
    _249++;
    if (_249 < _234)
    goto _jump188;
    _249 = 0;
    _250++;
    if (_250 < d)
    goto _jump188;
    // End body of loop
    int64_t _252;
    if (!b)
    goto _jump189;
    _252 = d;
    goto _jump190;
    _jump189:;
    _252 = _234;
    _jump190:;
    if (_235 >= 0)
    goto _jump191;
    fail_assertion("negative array index");
    _jump191:;
    if (_235 < _245.d0)
    goto _jump192;
    fail_assertion("index too large");
    _jump192:;
    if (d >= 0)
    goto _jump193;
    fail_assertion("negative array index");
    _jump193:;
    if (d < _245.d1)
    goto _jump194;
    fail_assertion("index too large");
    _jump194:;
    if (_252 >= 0)
    goto _jump195;
    fail_assertion("negative array index");
    _jump195:;
    if (_252 < _245.d2)
    goto _jump196;
    fail_assertion("index too large");
    _jump196:;
    int64_t _253 = 0;
    _253 *= _245.d0;
    _253 += _235;
    _253 *= _245.d1;
    _253 += d;
    _253 *= _245.d2;
    _253 += _252;
    bool _254 = _245.data[_253];
    _244 = _254;
    goto _jump197;
    _jump184:;
    bool _255;
    if (!b)
    goto _jump198;
    bool _256 = false;
    _255 = _256;
    goto _jump199;
    _jump198:;
    bool _257 = false;
    _255 = _257;
    _jump199:;
    bool _258 = true;
    bool _259 = !_258;
    bool _260 = _255 == _259;
    _244 = _260;
    _jump197:;
    _243 = _244;
    goto _jump200;
    _jump183:;
    _243 = a;
    _jump200:;
    rgba _261;
    if (!_243)
    goto _jump201;
    rgba _262;
    if (!a)
    goto _jump202;
    double _263;
    // Computing bound for i
    bool _264 = true;
    int64_t _265;
    if (!_264)
    goto _jump203;
    _265 = d;
    goto _jump204;
    _jump203:;
    _265 = _235;
    _jump204:;
    if (_265 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing bound for j
    if (_235 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    // Computing bound for k
    if (_234 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    _263 = 0;
    int64_t _266 = 0; // k
    int64_t _267 = 0; // j
    int64_t _268 = 0; // i
    _jump208:; // Begin body of loop
    _263 += _93;
    _266++;
    if (_266 < _234)
    goto _jump208;
    _266 = 0;
    _267++;
    if (_267 < _235)
    goto _jump208;
    _267 = 0;
    _268++;
    if (_268 < _265)
    goto _jump208;
    // End body of loop
    double _269 = 95.0;
    double _270 = c(_234, e);
    _a2_double _271;
    // Computing bound for i
    _271.d0 = d;
    if (d > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    // Computing bound for j
    _271.d1 = _235;
    if (_235 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing total size of heap memory to allocate
    int64_t _272 = 1;
    _272 *= d;
    _272 *= _235;
    _272 *= sizeof(double);
    _271.data = jpl_alloc(_272);
    int64_t _273 = 0; // j
    int64_t _274 = 0; // i
    _jump211:; // Begin body of loop
    double _275 = 38.0;
    int64_t _276 = 0;
    _276 *= _271.d0;
    _276 += _274;
    _276 *= _271.d1;
    _276 += _273;
    _271.data[_276] = _275;
    _273++;
    if (_273 < _235)
    goto _jump211;
    _273 = 0;
    _274++;
    if (_274 < d)
    goto _jump211;
    // End body of loop
    int64_t _277 = -d;
    if (_235 >= 0)
    goto _jump212;
    fail_assertion("negative array index");
    _jump212:;
    if (_235 < _271.d0)
    goto _jump213;
    fail_assertion("index too large");
    _jump213:;
    if (_277 >= 0)
    goto _jump214;
    fail_assertion("negative array index");
    _jump214:;
    if (_277 < _271.d1)
    goto _jump215;
    fail_assertion("index too large");
    _jump215:;
    int64_t _278 = 0;
    _278 *= _271.d0;
    _278 += _235;
    _278 *= _271.d1;
    _278 += _277;
    double _279 = _271.data[_278];
    rgba _280 = { _263, _269, _270, _279 };
    _262 = _280;
    goto _jump216;
    _jump202:;
    double _281 = c(d, e);
    double _282 = fmod(_93, _281);
    int64_t _283 = 68;
    int64_t _284 = _283 / _234;
    void_t _285;
    if (!b)
    goto _jump217;
    _285 = e;
    goto _jump218;
    _jump217:;
    _285 = e;
    _jump218:;
    double _286 = c(_284, _285);
    double _287;
    // Computing bound for i
    int64_t _288 = 685;
    if (_288 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing bound for j
    int64_t _289 = 624;
    int64_t _290 = 626;
    int64_t _291 = _289 + _290;
    if (_291 > 0) 
    goto _jump220;
    fail_assertion("non-positive loop bound");
    _jump220:;
    // Computing bound for k
    if (d > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    _287 = 0;
    int64_t _292 = 0; // k
    int64_t _293 = 0; // j
    int64_t _294 = 0; // i
    _jump222:; // Begin body of loop
    _287 += _93;
    _292++;
    if (_292 < d)
    goto _jump222;
    _292 = 0;
    _293++;
    if (_293 < _291)
    goto _jump222;
    _293 = 0;
    _294++;
    if (_294 < _288)
    goto _jump222;
    // End body of loop
    rgba _295 = { _282, _93, _286, _287 };
    _262 = _295;
    _jump216:;
    _261 = _262;
    goto _jump223;
    _jump201:;
    double _296 = 72.0;
    double _297 = 80.0;
    double _298 = fmod(_296, _297);
    bool _299 = _298 > _93;
    bool _300 = !_299;
    rgba _301;
    if (!_300)
    goto _jump224;
    double _302 = 93.0;
    double _303 = _93 / _302;
    double _304 = fmod(_93, _93);
    double _305;
    // Computing bound for i
    if (_234 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for j
    int64_t _306 = 657;
    if (_306 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for k
    int64_t _307 = -_234;
    if (_307 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    _305 = 0;
    int64_t _308 = 0; // k
    int64_t _309 = 0; // j
    int64_t _310 = 0; // i
    _jump228:; // Begin body of loop
    double _311;
    if (!b)
    goto _jump229;
    _311 = _93;
    goto _jump230;
    _jump229:;
    _311 = _93;
    _jump230:;
    _305 += _311;
    _308++;
    if (_308 < _307)
    goto _jump228;
    _308 = 0;
    _309++;
    if (_309 < _306)
    goto _jump228;
    _309 = 0;
    _310++;
    if (_310 < _234)
    goto _jump228;
    // End body of loop
    double _312;
    if (!b)
    goto _jump231;
    double _313 = c(_235, e);
    _312 = _313;
    goto _jump232;
    _jump231:;
    double _314;
    // Computing bound for i
    if (_235 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    // Computing bound for j
    if (_234 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    _314 = 0;
    int64_t _315 = 0; // j
    int64_t _316 = 0; // i
    _jump235:; // Begin body of loop
    double _317 = 6.0;
    _314 += _317;
    _315++;
    if (_315 < _234)
    goto _jump235;
    _315 = 0;
    _316++;
    if (_316 < _235)
    goto _jump235;
    // End body of loop
    _312 = _314;
    _jump232:;
    rgba _318 = { _303, _304, _305, _312 };
    _301 = _318;
    goto _jump236;
    _jump224:;
    double _319 = 24.0;
    double _320 = -_93;
    double _321 = _93 + _320;
    rgba _322 = { _93, _319, _93, _321 };
    _301 = _322;
    _jump236:;
    _261 = _301;
    _jump223:;
    double _323 = _261.a;
    int64_t _324 = 0;
    _324 *= _94.d0;
    _324 += _235;
    _324 *= _94.d1;
    _324 += _234;
    _94.data[_324] = _323;
    _234++;
    if (_234 < _160)
    goto _jump180;
    _234 = 0;
    _235++;
    if (_235 < _96)
    goto _jump180;
    // End body of loop
    int64_t _325 = 586;
    _a2__a2__a3_int64_t _326;
    // Computing bound for k
    bool _327 = true;
    bool _328 = !_327;
    bool _329;
    if (!_328)
    goto _jump237;
    bool _330 = _94.d0 >= d;
    _329 = _330;
    goto _jump238;
    _jump237:;
    bool _331 = true;
    bool _332 = !_331;
    _329 = _332;
    _jump238:;
    int64_t _333;
    if (!_329)
    goto _jump239;
    int64_t _334;
    // Computing bound for k
    int64_t _335 = 568;
    if (_335 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    // Computing bound for l
    if (d > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing bound for m
    if (_325 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    _334 = 0;
    int64_t _336 = 0; // m
    int64_t _337 = 0; // l
    int64_t _338 = 0; // k
    _jump243:; // Begin body of loop
    _334 += _338;
    _336++;
    if (_336 < _325)
    goto _jump243;
    _336 = 0;
    _337++;
    if (_337 < d)
    goto _jump243;
    _337 = 0;
    _338++;
    if (_338 < _335)
    goto _jump243;
    // End body of loop
    _333 = _334;
    goto _jump244;
    _jump239:;
    _333 = d;
    _jump244:;
    int64_t _339 = 916;
    int64_t _340 = -_339;
    int64_t _341 = _333 - _340;
    _326.d0 = _341;
    if (_341 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing bound for l
    _326.d1 = _94.d1;
    if (_94.d1 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing total size of heap memory to allocate
    int64_t _342 = 1;
    _342 *= _341;
    _342 *= _94.d1;
    _342 *= sizeof(_a2__a3_int64_t);
    _326.data = jpl_alloc(_342);
    int64_t _343 = 0; // l
    int64_t _344 = 0; // k
    _jump247:; // Begin body of loop
    bool _345 = _343 > _343;
    _a2__a3_int64_t _346;
    if (!_345)
    goto _jump248;
    _a2__a3_int64_t _347;
    // Computing bound for m
    int64_t _348 = 984;
    _347.d0 = _348;
    if (_348 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    // Computing bound for n
    _347.d1 = _344;
    if (_344 > 0) 
    goto _jump250;
    fail_assertion("non-positive loop bound");
    _jump250:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= _348;
    _349 *= _344;
    _349 *= sizeof(_a3_int64_t);
    _347.data = jpl_alloc(_349);
    int64_t _350 = 0; // n
    int64_t _351 = 0; // m
    _jump251:; // Begin body of loop
    _a3_int64_t _352;
    // Computing bound for o
    _352.d0 = _350;
    if (_350 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for p
    int64_t _353;
    if (!a)
    goto _jump253;
    _353 = _344;
    goto _jump254;
    _jump253:;
    int64_t _354 = 231;
    _353 = _354;
    _jump254:;
    _352.d1 = _353;
    if (_353 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    // Computing bound for q
    int64_t _355;
    // Computing bound for o
    if (_343 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing bound for p
    if (_343 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    _355 = 0;
    int64_t _356 = 0; // p
    int64_t _357 = 0; // o
    _jump258:; // Begin body of loop
    _355 += d;
    _356++;
    if (_356 < _343)
    goto _jump258;
    _356 = 0;
    _357++;
    if (_357 < _343)
    goto _jump258;
    // End body of loop
    _352.d2 = _355;
    if (_355 > 0) 
    goto _jump259;
    fail_assertion("non-positive loop bound");
    _jump259:;
    // Computing total size of heap memory to allocate
    int64_t _358 = 1;
    _358 *= _350;
    _358 *= _353;
    _358 *= _355;
    _358 *= sizeof(int64_t);
    _352.data = jpl_alloc(_358);
    int64_t _359 = 0; // q
    int64_t _360 = 0; // p
    int64_t _361 = 0; // o
    _jump260:; // Begin body of loop
    int64_t _362 = 0;
    _362 *= _352.d0;
    _362 += _361;
    _362 *= _352.d1;
    _362 += _360;
    _362 *= _352.d2;
    _362 += _359;
    _352.data[_362] = d;
    _359++;
    if (_359 < _355)
    goto _jump260;
    _359 = 0;
    _360++;
    if (_360 < _353)
    goto _jump260;
    _360 = 0;
    _361++;
    if (_361 < _350)
    goto _jump260;
    // End body of loop
    int64_t _363 = 0;
    _363 *= _347.d0;
    _363 += _351;
    _363 *= _347.d1;
    _363 += _350;
    _347.data[_363] = _352;
    _350++;
    if (_350 < _344)
    goto _jump251;
    _350 = 0;
    _351++;
    if (_351 < _348)
    goto _jump251;
    // End body of loop
    _346 = _347;
    goto _jump261;
    _jump248:;
    _a2__a3_int64_t _364;
    if (!a)
    goto _jump262;
    _a2__a3_int64_t _365;
    // Computing bound for m
    _365.d0 = _94.d1;
    if (_94.d1 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing bound for n
    int64_t _366 = 697;
    _365.d1 = _366;
    if (_366 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    // Computing total size of heap memory to allocate
    int64_t _367 = 1;
    _367 *= _94.d1;
    _367 *= _366;
    _367 *= sizeof(_a3_int64_t);
    _365.data = jpl_alloc(_367);
    int64_t _368 = 0; // n
    int64_t _369 = 0; // m
    _jump265:; // Begin body of loop
    _a3_int64_t _370;
    // Computing bound for o
    _370.d0 = _94.d1;
    if (_94.d1 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing bound for p
    _370.d1 = _325;
    if (_325 > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    // Computing bound for q
    _370.d2 = _369;
    if (_369 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing total size of heap memory to allocate
    int64_t _371 = 1;
    _371 *= _94.d1;
    _371 *= _325;
    _371 *= _369;
    _371 *= sizeof(int64_t);
    _370.data = jpl_alloc(_371);
    int64_t _372 = 0; // q
    int64_t _373 = 0; // p
    int64_t _374 = 0; // o
    _jump269:; // Begin body of loop
    int64_t _375 = 0;
    _375 *= _370.d0;
    _375 += _374;
    _375 *= _370.d1;
    _375 += _373;
    _375 *= _370.d2;
    _375 += _372;
    _370.data[_375] = _343;
    _372++;
    if (_372 < _369)
    goto _jump269;
    _372 = 0;
    _373++;
    if (_373 < _325)
    goto _jump269;
    _373 = 0;
    _374++;
    if (_374 < _94.d1)
    goto _jump269;
    // End body of loop
    int64_t _376 = 0;
    _376 *= _365.d0;
    _376 += _369;
    _376 *= _365.d1;
    _376 += _368;
    _365.data[_376] = _370;
    _368++;
    if (_368 < _366)
    goto _jump265;
    _368 = 0;
    _369++;
    if (_369 < _94.d1)
    goto _jump265;
    // End body of loop
    _364 = _365;
    goto _jump270;
    _jump262:;
    _a2__a3_int64_t _377;
    // Computing bound for m
    _377.d0 = _325;
    if (_325 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for n
    bool _378 = true;
    int64_t _379;
    if (!_378)
    goto _jump272;
    _379 = _343;
    goto _jump273;
    _jump272:;
    int64_t _380 = 966;
    _379 = _380;
    _jump273:;
    _377.d1 = _379;
    if (_379 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= _325;
    _381 *= _379;
    _381 *= sizeof(_a3_int64_t);
    _377.data = jpl_alloc(_381);
    int64_t _382 = 0; // n
    int64_t _383 = 0; // m
    _jump275:; // Begin body of loop
    _a3_int64_t _384;
    // Computing bound for o
    int64_t _385 = 207;
    _384.d0 = _385;
    if (_385 > 0) 
    goto _jump276;
    fail_assertion("non-positive loop bound");
    _jump276:;
    // Computing bound for p
    _384.d1 = d;
    if (d > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for q
    _384.d2 = _325;
    if (_325 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing total size of heap memory to allocate
    int64_t _386 = 1;
    _386 *= _385;
    _386 *= d;
    _386 *= _325;
    _386 *= sizeof(int64_t);
    _384.data = jpl_alloc(_386);
    int64_t _387 = 0; // q
    int64_t _388 = 0; // p
    int64_t _389 = 0; // o
    _jump279:; // Begin body of loop
    int64_t _390 = 0;
    _390 *= _384.d0;
    _390 += _389;
    _390 *= _384.d1;
    _390 += _388;
    _390 *= _384.d2;
    _390 += _387;
    _384.data[_390] = _383;
    _387++;
    if (_387 < _325)
    goto _jump279;
    _387 = 0;
    _388++;
    if (_388 < d)
    goto _jump279;
    _388 = 0;
    _389++;
    if (_389 < _385)
    goto _jump279;
    // End body of loop
    int64_t _391 = 0;
    _391 *= _377.d0;
    _391 += _383;
    _391 *= _377.d1;
    _391 += _382;
    _377.data[_391] = _384;
    _382++;
    if (_382 < _379)
    goto _jump275;
    _382 = 0;
    _383++;
    if (_383 < _325)
    goto _jump275;
    // End body of loop
    _364 = _377;
    _jump270:;
    _346 = _364;
    _jump261:;
    int64_t _392 = 0;
    _392 *= _326.d0;
    _392 += _344;
    _392 *= _326.d1;
    _392 += _343;
    _326.data[_392] = _346;
    _343++;
    if (_343 < _94.d1)
    goto _jump247;
    _343 = 0;
    _344++;
    if (_344 < _341)
    goto _jump247;
    // End body of loop
    int64_t _393 = -_325;
    int64_t _394;
    // Computing bound for k
    if (_94.d0 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    // Computing bound for l
    int64_t _395 = 101;
    if (_395 > 0) 
    goto _jump281;
    fail_assertion("non-positive loop bound");
    _jump281:;
    // Computing bound for m
    bool _396 = true;
    int64_t _397;
    if (!_396)
    goto _jump282;
    _397 = _325;
    goto _jump283;
    _jump282:;
    _397 = _94.d1;
    _jump283:;
    int64_t _398 = -_397;
    int64_t _399 = _398 - _94.d1;
    if (_399 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    _394 = 0;
    int64_t _400 = 0; // m
    int64_t _401 = 0; // l
    int64_t _402 = 0; // k
    _jump285:; // Begin body of loop
    _394 += _401;
    _400++;
    if (_400 < _399)
    goto _jump285;
    _400 = 0;
    _401++;
    if (_401 < _395)
    goto _jump285;
    _401 = 0;
    _402++;
    if (_402 < _94.d0)
    goto _jump285;
    // End body of loop
    int64_t _403 = _393 % _394;
    if (_325 >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (_325 < _326.d0)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    if (_403 >= 0)
    goto _jump288;
    fail_assertion("negative array index");
    _jump288:;
    if (_403 < _326.d1)
    goto _jump289;
    fail_assertion("index too large");
    _jump289:;
    int64_t _404 = 0;
    _404 *= _326.d0;
    _404 += _325;
    _404 *= _326.d1;
    _404 += _403;
    _a2__a3_int64_t _405 = _326.data[_404];
    int64_t _406 = 134;
    if (_406 >= 0)
    goto _jump290;
    fail_assertion("negative array index");
    _jump290:;
    if (_406 < _405.d0)
    goto _jump291;
    fail_assertion("index too large");
    _jump291:;
    if (_325 >= 0)
    goto _jump292;
    fail_assertion("negative array index");
    _jump292:;
    if (_325 < _405.d1)
    goto _jump293;
    fail_assertion("index too large");
    _jump293:;
    int64_t _407 = 0;
    _407 *= _405.d0;
    _407 += _406;
    _407 *= _405.d1;
    _407 += _325;
    _a3_int64_t _408 = _405.data[_407];
    _a1_void_t _409;
    if (!b)
    goto _jump294;
    _a2__a1_void_t _410;
    // Computing bound for o
    _410.d0 = _94.d0;
    if (_94.d0 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing bound for p
    _410.d1 = _408.d0;
    if (_408.d0 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing total size of heap memory to allocate
    int64_t _411 = 1;
    _411 *= _94.d0;
    _411 *= _408.d0;
    _411 *= sizeof(_a1_void_t);
    _410.data = jpl_alloc(_411);
    int64_t _412 = 0; // p
    int64_t _413 = 0; // o
    _jump297:; // Begin body of loop
    _a1_void_t _414;
    // Computing bound for q
    _414.d0 = _413;
    if (_413 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing total size of heap memory to allocate
    int64_t _415 = 1;
    _415 *= _413;
    _415 *= sizeof(void_t);
    _414.data = jpl_alloc(_415);
    int64_t _416 = 0; // q
    _jump299:; // Begin body of loop
    int64_t _417 = 0;
    _417 *= _414.d0;
    _417 += _416;
    _414.data[_417] = e;
    _416++;
    if (_416 < _413)
    goto _jump299;
    // End body of loop
    int64_t _418 = 0;
    _418 *= _410.d0;
    _418 += _413;
    _418 *= _410.d1;
    _418 += _412;
    _410.data[_418] = _414;
    _412++;
    if (_412 < _408.d0)
    goto _jump297;
    _412 = 0;
    _413++;
    if (_413 < _94.d0)
    goto _jump297;
    // End body of loop
    if (_94.d0 >= 0)
    goto _jump300;
    fail_assertion("negative array index");
    _jump300:;
    if (_94.d0 < _410.d0)
    goto _jump301;
    fail_assertion("index too large");
    _jump301:;
    if (_94.d1 >= 0)
    goto _jump302;
    fail_assertion("negative array index");
    _jump302:;
    if (_94.d1 < _410.d1)
    goto _jump303;
    fail_assertion("index too large");
    _jump303:;
    int64_t _419 = 0;
    _419 *= _410.d0;
    _419 += _94.d0;
    _419 *= _410.d1;
    _419 += _94.d1;
    _a1_void_t _420 = _410.data[_419];
    _409 = _420;
    goto _jump304;
    _jump294:;
    bool _421 = true;
    _a3_void_t _422;
    if (!_421)
    goto _jump305;
    _a3_void_t _423;
    // Computing bound for o
    _423.d0 = _408.d1;
    if (_408.d1 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for p
    _423.d1 = d;
    if (d > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    // Computing bound for q
    _423.d2 = _94.d1;
    if (_94.d1 > 0) 
    goto _jump308;
    fail_assertion("non-positive loop bound");
    _jump308:;
    // Computing total size of heap memory to allocate
    int64_t _424 = 1;
    _424 *= _408.d1;
    _424 *= d;
    _424 *= _94.d1;
    _424 *= sizeof(void_t);
    _423.data = jpl_alloc(_424);
    int64_t _425 = 0; // q
    int64_t _426 = 0; // p
    int64_t _427 = 0; // o
    _jump309:; // Begin body of loop
    int64_t _428 = 0;
    _428 *= _423.d0;
    _428 += _427;
    _428 *= _423.d1;
    _428 += _426;
    _428 *= _423.d2;
    _428 += _425;
    _423.data[_428] = e;
    _425++;
    if (_425 < _94.d1)
    goto _jump309;
    _425 = 0;
    _426++;
    if (_426 < d)
    goto _jump309;
    _426 = 0;
    _427++;
    if (_427 < _408.d1)
    goto _jump309;
    // End body of loop
    _422 = _423;
    goto _jump310;
    _jump305:;
    _a3_void_t _429;
    // Computing bound for o
    _429.d0 = _408.d0;
    if (_408.d0 > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing bound for p
    _429.d1 = _94.d0;
    if (_94.d0 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for q
    _429.d2 = d;
    if (d > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing total size of heap memory to allocate
    int64_t _430 = 1;
    _430 *= _408.d0;
    _430 *= _94.d0;
    _430 *= d;
    _430 *= sizeof(void_t);
    _429.data = jpl_alloc(_430);
    int64_t _431 = 0; // q
    int64_t _432 = 0; // p
    int64_t _433 = 0; // o
    _jump314:; // Begin body of loop
    int64_t _434 = 0;
    _434 *= _429.d0;
    _434 += _433;
    _434 *= _429.d1;
    _434 += _432;
    _434 *= _429.d2;
    _434 += _431;
    _429.data[_434] = e;
    _431++;
    if (_431 < d)
    goto _jump314;
    _431 = 0;
    _432++;
    if (_432 < _94.d0)
    goto _jump314;
    _432 = 0;
    _433++;
    if (_433 < _408.d0)
    goto _jump314;
    // End body of loop
    _422 = _429;
    _jump310:;
    int64_t _435;
    if (!a)
    goto _jump315;
    _435 = _325;
    goto _jump316;
    _jump315:;
    _435 = _94.d1;
    _jump316:;
    if (_435 >= 0)
    goto _jump317;
    fail_assertion("negative array index");
    _jump317:;
    if (_435 < _422.d0)
    goto _jump318;
    fail_assertion("index too large");
    _jump318:;
    if (_408.d1 >= 0)
    goto _jump319;
    fail_assertion("negative array index");
    _jump319:;
    if (_408.d1 < _422.d1)
    goto _jump320;
    fail_assertion("index too large");
    _jump320:;
    if (_94.d1 >= 0)
    goto _jump321;
    fail_assertion("negative array index");
    _jump321:;
    if (_94.d1 < _422.d2)
    goto _jump322;
    fail_assertion("index too large");
    _jump322:;
    int64_t _436 = 0;
    _436 *= _422.d0;
    _436 += _435;
    _436 *= _422.d1;
    _436 += _408.d1;
    _436 *= _422.d2;
    _436 += _94.d1;
    void_t _437 = _422.data[_436];
    _a1_void_t _438;
    _438.d0 = 1;
    _438.data = jpl_alloc(sizeof(void_t) * 1);
    _438.data[0] = _437;
    _409 = _438;
    _jump304:;
    if (_408.d2 >= 0)
    goto _jump323;
    fail_assertion("negative array index");
    _jump323:;
    if (_408.d2 < _409.d0)
    goto _jump324;
    fail_assertion("index too large");
    _jump324:;
    int64_t _439 = 0;
    _439 *= _409.d0;
    _439 += _408.d2;
    void_t _440 = _409.data[_439];
    double _441 = c(_325, _440);
    return _441;
    _a1__a3_int64_t _442;
    // Computing bound for o
    bool _443 = !a;
    _a2_int64_t _444;
    if (!_443)
    goto _jump325;
    _a2_int64_t _445;
    // Computing bound for o
    int64_t _446 = 757;
    _445.d0 = _446;
    if (_446 > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing bound for p
    _445.d1 = _325;
    if (_325 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= _446;
    _447 *= _325;
    _447 *= sizeof(int64_t);
    _445.data = jpl_alloc(_447);
    int64_t _448 = 0; // p
    int64_t _449 = 0; // o
    _jump328:; // Begin body of loop
    int64_t _450 = 0;
    _450 *= _445.d0;
    _450 += _449;
    _450 *= _445.d1;
    _450 += _448;
    _445.data[_450] = _325;
    _448++;
    if (_448 < _325)
    goto _jump328;
    _448 = 0;
    _449++;
    if (_449 < _446)
    goto _jump328;
    // End body of loop
    _444 = _445;
    goto _jump329;
    _jump325:;
    _a2_int64_t _451;
    // Computing bound for o
    _451.d0 = _408.d1;
    if (_408.d1 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for p
    _451.d1 = _408.d2;
    if (_408.d2 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing total size of heap memory to allocate
    int64_t _452 = 1;
    _452 *= _408.d1;
    _452 *= _408.d2;
    _452 *= sizeof(int64_t);
    _451.data = jpl_alloc(_452);
    int64_t _453 = 0; // p
    int64_t _454 = 0; // o
    _jump332:; // Begin body of loop
    int64_t _455 = 251;
    int64_t _456 = 0;
    _456 *= _451.d0;
    _456 += _454;
    _456 *= _451.d1;
    _456 += _453;
    _451.data[_456] = _455;
    _453++;
    if (_453 < _408.d2)
    goto _jump332;
    _453 = 0;
    _454++;
    if (_454 < _408.d1)
    goto _jump332;
    // End body of loop
    _444 = _451;
    _jump329:;
    bool _458 = false;
    bool _457 = _458;
    if (0 != _458)
    goto _jump333;
    bool _459 = true;
    _457 = _459;
    _jump333:;
    int64_t _460;
    if (!_457)
    goto _jump334;
    int64_t _461;
    // Computing bound for o
    if (_408.d0 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    // Computing bound for p
    int64_t _462 = 566;
    if (_462 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    _461 = 0;
    int64_t _463 = 0; // p
    int64_t _464 = 0; // o
    _jump337:; // Begin body of loop
    _461 += _94.d0;
    _463++;
    if (_463 < _462)
    goto _jump337;
    _463 = 0;
    _464++;
    if (_464 < _408.d0)
    goto _jump337;
    // End body of loop
    _460 = _461;
    goto _jump338;
    _jump334:;
    int64_t _465;
    // Computing bound for o
    if (_408.d0 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    _465 = 0;
    int64_t _466 = 0; // o
    _jump340:; // Begin body of loop
    _465 += _466;
    _466++;
    if (_466 < _408.d0)
    goto _jump340;
    // End body of loop
    _460 = _465;
    _jump338:;
    int64_t _467 = 739;
    _a1_int64_t _468;
    _468.d0 = 1;
    _468.data = jpl_alloc(sizeof(int64_t) * 1);
    _468.data[0] = _467;
    if (_408.d2 >= 0)
    goto _jump341;
    fail_assertion("negative array index");
    _jump341:;
    if (_408.d2 < _468.d0)
    goto _jump342;
    fail_assertion("index too large");
    _jump342:;
    int64_t _469 = 0;
    _469 *= _468.d0;
    _469 += _408.d2;
    int64_t _470 = _468.data[_469];
    if (_460 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (_460 < _444.d0)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (_470 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (_470 < _444.d1)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _471 = 0;
    _471 *= _444.d0;
    _471 += _460;
    _471 *= _444.d1;
    _471 += _470;
    int64_t _472 = _444.data[_471];
    int64_t _473 = -_325;
    if (_94.d0 >= 0)
    goto _jump347;
    fail_assertion("negative array index");
    _jump347:;
    if (_94.d0 < _408.d0)
    goto _jump348;
    fail_assertion("index too large");
    _jump348:;
    if (_472 >= 0)
    goto _jump349;
    fail_assertion("negative array index");
    _jump349:;
    if (_472 < _408.d1)
    goto _jump350;
    fail_assertion("index too large");
    _jump350:;
    if (_473 >= 0)
    goto _jump351;
    fail_assertion("negative array index");
    _jump351:;
    if (_473 < _408.d2)
    goto _jump352;
    fail_assertion("index too large");
    _jump352:;
    int64_t _474 = 0;
    _474 *= _408.d0;
    _474 += _94.d0;
    _474 *= _408.d1;
    _474 += _472;
    _474 *= _408.d2;
    _474 += _473;
    int64_t _475 = _408.data[_474];
    int64_t _476 = _408.d1 * _475;
    int64_t _477 = _94.d1 + _476;
    _442.d0 = _477;
    if (_477 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    // Computing total size of heap memory to allocate
    int64_t _478 = 1;
    _478 *= _477;
    _478 *= sizeof(_a3_int64_t);
    _442.data = jpl_alloc(_478);
    int64_t _479 = 0; // o
    _jump354:; // Begin body of loop
    _a3_int64_t _480;
    // Computing bound for p
    int64_t _481;
    // Computing bound for p
    if (_408.d1 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    _481 = 0;
    int64_t _482 = 0; // p
    _jump356:; // Begin body of loop
    _481 += _94.d0;
    _482++;
    if (_482 < _408.d1)
    goto _jump356;
    // End body of loop
    bool _483 = _481 < _408.d1;
    int64_t _484;
    if (!_483)
    goto _jump357;
    int64_t _485 = -d;
    _484 = _485;
    goto _jump358;
    _jump357:;
    int64_t _486;
    // Computing bound for p
    if (_94.d0 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing bound for q
    if (_94.d0 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing bound for r
    if (_325 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    _486 = 0;
    int64_t _487 = 0; // r
    int64_t _488 = 0; // q
    int64_t _489 = 0; // p
    _jump362:; // Begin body of loop
    _486 += _487;
    _487++;
    if (_487 < _325)
    goto _jump362;
    _487 = 0;
    _488++;
    if (_488 < _94.d0)
    goto _jump362;
    _488 = 0;
    _489++;
    if (_489 < _94.d0)
    goto _jump362;
    // End body of loop
    _484 = _486;
    _jump358:;
    _480.d0 = _484;
    if (_484 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for q
    int64_t _490 = d * _94.d0;
    _480.d1 = _490;
    if (_490 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing bound for r
    int64_t _491;
    // Computing bound for p
    if (_325 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    // Computing bound for q
    if (_94.d0 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    _491 = 0;
    int64_t _492 = 0; // q
    int64_t _493 = 0; // p
    _jump367:; // Begin body of loop
    _491 += _94.d0;
    _492++;
    if (_492 < _94.d0)
    goto _jump367;
    _492 = 0;
    _493++;
    if (_493 < _325)
    goto _jump367;
    // End body of loop
    _480.d2 = _491;
    if (_491 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    // Computing total size of heap memory to allocate
    int64_t _494 = 1;
    _494 *= _484;
    _494 *= _490;
    _494 *= _491;
    _494 *= sizeof(int64_t);
    _480.data = jpl_alloc(_494);
    int64_t _495 = 0; // r
    int64_t _496 = 0; // q
    int64_t _497 = 0; // p
    _jump369:; // Begin body of loop
    int64_t _498 = 523;
    int64_t _499 = 0;
    _499 *= _480.d0;
    _499 += _497;
    _499 *= _480.d1;
    _499 += _496;
    _499 *= _480.d2;
    _499 += _495;
    _480.data[_499] = _498;
    _495++;
    if (_495 < _491)
    goto _jump369;
    _495 = 0;
    _496++;
    if (_496 < _490)
    goto _jump369;
    _496 = 0;
    _497++;
    if (_497 < _484)
    goto _jump369;
    // End body of loop
    int64_t _500 = 0;
    _500 *= _442.d0;
    _500 += _479;
    _442.data[_500] = _480;
    _479++;
    if (_479 < _477)
    goto _jump354;
    // End body of loop
    double _501;
    // Computing bound for q
    if (_442.d0 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    // Computing bound for r
    if (_94.d1 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing bound for s
    int64_t _502 = -_442.d0;
    if (_502 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    _501 = 0;
    int64_t _503 = 0; // s
    int64_t _504 = 0; // r
    int64_t _505 = 0; // q
    _jump373:; // Begin body of loop
    double _506;
    if (!a)
    goto _jump374;
    double _507;
    // Computing bound for t
    if (_505 > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    // Computing bound for u
    if (_408.d1 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    _507 = 0;
    int64_t _508 = 0; // u
    int64_t _509 = 0; // t
    _jump377:; // Begin body of loop
    int64_t _510 = _505 - _442.d0;
    if (_510 >= 0)
    goto _jump378;
    fail_assertion("negative array index");
    _jump378:;
    if (_510 < _94.d0)
    goto _jump379;
    fail_assertion("index too large");
    _jump379:;
    if (_505 >= 0)
    goto _jump380;
    fail_assertion("negative array index");
    _jump380:;
    if (_505 < _94.d1)
    goto _jump381;
    fail_assertion("index too large");
    _jump381:;
    int64_t _511 = 0;
    _511 *= _94.d0;
    _511 += _510;
    _511 *= _94.d1;
    _511 += _505;
    double _512 = _94.data[_511];
    double _513 = 88.0;
    double _514 = -_513;
    double _515 = _512 * _514;
    double _516 = -_515;
    _507 += _516;
    _508++;
    if (_508 < _408.d1)
    goto _jump377;
    _508 = 0;
    _509++;
    if (_509 < _505)
    goto _jump377;
    // End body of loop
    _506 = _507;
    goto _jump382;
    _jump374:;
    double _517;
    if (!b)
    goto _jump383;
    double _518 = 5.0;
    _517 = _518;
    goto _jump384;
    _jump383:;
    _a3__a2_double _519;
    // Computing bound for t
    _519.d0 = _505;
    if (_505 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing bound for u
    _519.d1 = _503;
    if (_503 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing bound for v
    int64_t _520 = -_94.d0;
    _519.d2 = _520;
    if (_520 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    // Computing total size of heap memory to allocate
    int64_t _521 = 1;
    _521 *= _505;
    _521 *= _503;
    _521 *= _520;
    _521 *= sizeof(_a2_double);
    _519.data = jpl_alloc(_521);
    int64_t _522 = 0; // v
    int64_t _523 = 0; // u
    int64_t _524 = 0; // t
    _jump388:; // Begin body of loop
    int64_t _525 = 0;
    _525 *= _519.d0;
    _525 += _524;
    _525 *= _519.d1;
    _525 += _523;
    _525 *= _519.d2;
    _525 += _522;
    _519.data[_525] = _94;
    _522++;
    if (_522 < _520)
    goto _jump388;
    _522 = 0;
    _523++;
    if (_523 < _503)
    goto _jump388;
    _523 = 0;
    _524++;
    if (_524 < _505)
    goto _jump388;
    // End body of loop
    if (_325 >= 0)
    goto _jump389;
    fail_assertion("negative array index");
    _jump389:;
    if (_325 < _519.d0)
    goto _jump390;
    fail_assertion("index too large");
    _jump390:;
    if (_503 >= 0)
    goto _jump391;
    fail_assertion("negative array index");
    _jump391:;
    if (_503 < _519.d1)
    goto _jump392;
    fail_assertion("index too large");
    _jump392:;
    if (_504 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_504 < _519.d2)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    int64_t _526 = 0;
    _526 *= _519.d0;
    _526 += _325;
    _526 *= _519.d1;
    _526 += _503;
    _526 *= _519.d2;
    _526 += _504;
    _a2_double _527 = _519.data[_526];
    if (_408.d0 >= 0)
    goto _jump395;
    fail_assertion("negative array index");
    _jump395:;
    if (_408.d0 < _527.d0)
    goto _jump396;
    fail_assertion("index too large");
    _jump396:;
    if (_325 >= 0)
    goto _jump397;
    fail_assertion("negative array index");
    _jump397:;
    if (_325 < _527.d1)
    goto _jump398;
    fail_assertion("index too large");
    _jump398:;
    int64_t _528 = 0;
    _528 *= _527.d0;
    _528 += _408.d0;
    _528 *= _527.d1;
    _528 += _325;
    double _529 = _527.data[_528];
    _517 = _529;
    _jump384:;
    _506 = _517;
    _jump382:;
    _501 += _506;
    _503++;
    if (_503 < _502)
    goto _jump373;
    _503 = 0;
    _504++;
    if (_504 < _94.d1)
    goto _jump373;
    _504 = 0;
    _505++;
    if (_505 < _442.d0)
    goto _jump373;
    // End body of loop
    return _501;
}

void_t e(void_t f, _a1_void_t g, _a3_double i) {
    bool _0 = true;
    _a3_double _1;
    if (!_0)
    goto _jump461;
    bool _2 = true;
    _a3__a3_double _3;
    if (!_2)
    goto _jump462;
    int64_t _4 = 851;
    void_t _5 = e(f, g, i);
    double _6 = c(_4, _5);
    _a2_double _7;
    // Computing bound for m
    _7.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing bound for n
    int64_t _8 = 25;
    _7.d1 = _8;
    if (_8 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing total size of heap memory to allocate
    int64_t _9 = 1;
    _9 *= i.d1;
    _9 *= _8;
    _9 *= sizeof(double);
    _7.data = jpl_alloc(_9);
    int64_t _10 = 0; // n
    int64_t _11 = 0; // m
    _jump465:; // Begin body of loop
    int64_t _12 = 0;
    _12 *= _7.d0;
    _12 += _11;
    _12 *= _7.d1;
    _12 += _10;
    _7.data[_12] = d;
    _10++;
    if (_10 < _8)
    goto _jump465;
    _10 = 0;
    _11++;
    if (_11 < i.d1)
    goto _jump465;
    // End body of loop
    if (i.d2 >= 0)
    goto _jump466;
    fail_assertion("negative array index");
    _jump466:;
    if (i.d2 < _7.d0)
    goto _jump467;
    fail_assertion("index too large");
    _jump467:;
    if (i.d2 >= 0)
    goto _jump468;
    fail_assertion("negative array index");
    _jump468:;
    if (i.d2 < _7.d1)
    goto _jump469;
    fail_assertion("index too large");
    _jump469:;
    int64_t _13 = 0;
    _13 *= _7.d0;
    _13 += i.d2;
    _13 *= _7.d1;
    _13 += i.d2;
    double _14 = _7.data[_13];
    bool _15 = _6 != _14;
    _a3__a3_double _16;
    if (!_15)
    goto _jump470;
    _a3__a3_double _17;
    // Computing bound for m
    _17.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing bound for n
    int64_t _18 = -i.d2;
    int64_t _19 = -_18;
    _17.d1 = _19;
    if (_19 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for o
    _17.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= g.d0;
    _20 *= _19;
    _20 *= g.d0;
    _20 *= sizeof(_a3_double);
    _17.data = jpl_alloc(_20);
    int64_t _21 = 0; // o
    int64_t _22 = 0; // n
    int64_t _23 = 0; // m
    _jump474:; // Begin body of loop
    int64_t _24 = 0;
    _24 *= _17.d0;
    _24 += _23;
    _24 *= _17.d1;
    _24 += _22;
    _24 *= _17.d2;
    _24 += _21;
    _17.data[_24] = i;
    _21++;
    if (_21 < g.d0)
    goto _jump474;
    _21 = 0;
    _22++;
    if (_22 < _19)
    goto _jump474;
    _22 = 0;
    _23++;
    if (_23 < g.d0)
    goto _jump474;
    // End body of loop
    _16 = _17;
    goto _jump475;
    _jump470:;
    _a3__a3_double _25;
    // Computing bound for m
    _25.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing bound for n
    int64_t _26;
    // Computing bound for m
    int64_t _27;
    // Computing bound for m
    if (i.d0 > 0) 
    goto _jump477;
    fail_assertion("non-positive loop bound");
    _jump477:;
    _27 = 0;
    int64_t _28 = 0; // m
    _jump478:; // Begin body of loop
    _27 += _28;
    _28++;
    if (_28 < i.d0)
    goto _jump478;
    // End body of loop
    if (_27 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    _26 = 0;
    int64_t _29 = 0; // m
    _jump480:; // Begin body of loop
    int64_t _30 = 637;
    _26 += _30;
    _29++;
    if (_29 < _27)
    goto _jump480;
    // End body of loop
    _25.d1 = _26;
    if (_26 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    // Computing bound for o
    _25.d2 = i.d2;
    if (i.d2 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= i.d2;
    _31 *= _26;
    _31 *= i.d2;
    _31 *= sizeof(_a3_double);
    _25.data = jpl_alloc(_31);
    int64_t _32 = 0; // o
    int64_t _33 = 0; // n
    int64_t _34 = 0; // m
    _jump483:; // Begin body of loop
    _a1__a3_double _35;
    // Computing bound for p
    _35.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= i.d1;
    _36 *= sizeof(_a3_double);
    _35.data = jpl_alloc(_36);
    int64_t _37 = 0; // p
    _jump485:; // Begin body of loop
    int64_t _38 = 0;
    _38 *= _35.d0;
    _38 += _37;
    _35.data[_38] = i;
    _37++;
    if (_37 < i.d1)
    goto _jump485;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump486;
    fail_assertion("negative array index");
    _jump486:;
    if (i.d0 < _35.d0)
    goto _jump487;
    fail_assertion("index too large");
    _jump487:;
    int64_t _39 = 0;
    _39 *= _35.d0;
    _39 += i.d0;
    _a3_double _40 = _35.data[_39];
    int64_t _41 = 0;
    _41 *= _25.d0;
    _41 += _34;
    _41 *= _25.d1;
    _41 += _33;
    _41 *= _25.d2;
    _41 += _32;
    _25.data[_41] = _40;
    _32++;
    if (_32 < i.d2)
    goto _jump483;
    _32 = 0;
    _33++;
    if (_33 < _26)
    goto _jump483;
    _33 = 0;
    _34++;
    if (_34 < i.d2)
    goto _jump483;
    // End body of loop
    _16 = _25;
    _jump475:;
    _3 = _16;
    goto _jump488;
    _jump462:;
    bool _43 = b;
    if (0 != b)
    goto _jump489;
    bool _44 = true;
    _43 = _44;
    _jump489:;
    bool _42 = _43;
    if (0 != _43)
    goto _jump490;
    _42 = a;
    _jump490:;
    bool _45 = !_42;
    _a3__a3_double _46;
    if (!_45)
    goto _jump491;
    _a3__a3_double _47;
    // Computing bound for m
    _47.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    // Computing bound for n
    int64_t _48 = 497;
    _47.d1 = _48;
    if (_48 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for o
    int64_t _49 = 423;
    _47.d2 = _49;
    if (_49 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= i.d0;
    _50 *= _48;
    _50 *= _49;
    _50 *= sizeof(_a3_double);
    _47.data = jpl_alloc(_50);
    int64_t _51 = 0; // o
    int64_t _52 = 0; // n
    int64_t _53 = 0; // m
    _jump495:; // Begin body of loop
    _a1__a3_double _54;
    // Computing bound for p
    int64_t _55 = 797;
    _54.d0 = _55;
    if (_55 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= _55;
    _56 *= sizeof(_a3_double);
    _54.data = jpl_alloc(_56);
    int64_t _57 = 0; // p
    _jump497:; // Begin body of loop
    int64_t _58 = 0;
    _58 *= _54.d0;
    _58 += _57;
    _54.data[_58] = i;
    _57++;
    if (_57 < _55)
    goto _jump497;
    // End body of loop
    if (_53 >= 0)
    goto _jump498;
    fail_assertion("negative array index");
    _jump498:;
    if (_53 < _54.d0)
    goto _jump499;
    fail_assertion("index too large");
    _jump499:;
    int64_t _59 = 0;
    _59 *= _54.d0;
    _59 += _53;
    _a3_double _60 = _54.data[_59];
    int64_t _61 = 0;
    _61 *= _47.d0;
    _61 += _53;
    _61 *= _47.d1;
    _61 += _52;
    _61 *= _47.d2;
    _61 += _51;
    _47.data[_61] = _60;
    _51++;
    if (_51 < _49)
    goto _jump495;
    _51 = 0;
    _52++;
    if (_52 < _48)
    goto _jump495;
    _52 = 0;
    _53++;
    if (_53 < i.d0)
    goto _jump495;
    // End body of loop
    _46 = _47;
    goto _jump500;
    _jump491:;
    bool _62 = true;
    _a3__a3_double _63;
    if (!_62)
    goto _jump501;
    _a3__a3_double _64;
    // Computing bound for m
    int64_t _65 = 755;
    int64_t _66 = 598;
    int64_t _67 = _65 * _66;
    _64.d0 = _67;
    if (_67 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    // Computing bound for n
    _64.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing bound for o
    int64_t _68 = -g.d0;
    _64.d2 = _68;
    if (_68 > 0) 
    goto _jump504;
    fail_assertion("non-positive loop bound");
    _jump504:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= _67;
    _69 *= g.d0;
    _69 *= _68;
    _69 *= sizeof(_a3_double);
    _64.data = jpl_alloc(_69);
    int64_t _70 = 0; // o
    int64_t _71 = 0; // n
    int64_t _72 = 0; // m
    _jump505:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _64.d0;
    _73 += _72;
    _73 *= _64.d1;
    _73 += _71;
    _73 *= _64.d2;
    _73 += _70;
    _64.data[_73] = i;
    _70++;
    if (_70 < _68)
    goto _jump505;
    _70 = 0;
    _71++;
    if (_71 < g.d0)
    goto _jump505;
    _71 = 0;
    _72++;
    if (_72 < _67)
    goto _jump505;
    // End body of loop
    _63 = _64;
    goto _jump506;
    _jump501:;
    _a3__a3_double _74;
    // Computing bound for m
    _74.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing bound for n
    int64_t _75 = -i.d1;
    _74.d1 = _75;
    if (_75 > 0) 
    goto _jump508;
    fail_assertion("non-positive loop bound");
    _jump508:;
    // Computing bound for o
    _74.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= i.d0;
    _76 *= _75;
    _76 *= i.d1;
    _76 *= sizeof(_a3_double);
    _74.data = jpl_alloc(_76);
    int64_t _77 = 0; // o
    int64_t _78 = 0; // n
    int64_t _79 = 0; // m
    _jump510:; // Begin body of loop
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += _79;
    _80 *= _74.d1;
    _80 += _78;
    _80 *= _74.d2;
    _80 += _77;
    _74.data[_80] = i;
    _77++;
    if (_77 < i.d1)
    goto _jump510;
    _77 = 0;
    _78++;
    if (_78 < _75)
    goto _jump510;
    _78 = 0;
    _79++;
    if (_79 < i.d0)
    goto _jump510;
    // End body of loop
    _63 = _74;
    _jump506:;
    _46 = _63;
    _jump500:;
    _3 = _46;
    _jump488:;
    int64_t _81;
    // Computing bound for m
    if (i.d0 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    _81 = 0;
    int64_t _82 = 0; // m
    _jump512:; // Begin body of loop
    int64_t _83;
    if (!b)
    goto _jump513;
    _83 = g.d0;
    goto _jump514;
    _jump513:;
    int64_t _84;
    if (!b)
    goto _jump515;
    int64_t _85 = _82 * i.d2;
    _84 = _85;
    goto _jump516;
    _jump515:;
    _84 = i.d0;
    _jump516:;
    int64_t _86 = _82 % _84;
    _83 = _86;
    _jump514:;
    _81 += _83;
    _82++;
    if (_82 < i.d0)
    goto _jump512;
    // End body of loop
    int64_t _87 = -i.d2;
    if (_81 >= 0)
    goto _jump517;
    fail_assertion("negative array index");
    _jump517:;
    if (_81 < _3.d0)
    goto _jump518;
    fail_assertion("index too large");
    _jump518:;
    if (_87 >= 0)
    goto _jump519;
    fail_assertion("negative array index");
    _jump519:;
    if (_87 < _3.d1)
    goto _jump520;
    fail_assertion("index too large");
    _jump520:;
    if (i.d2 >= 0)
    goto _jump521;
    fail_assertion("negative array index");
    _jump521:;
    if (i.d2 < _3.d2)
    goto _jump522;
    fail_assertion("index too large");
    _jump522:;
    int64_t _88 = 0;
    _88 *= _3.d0;
    _88 += _81;
    _88 *= _3.d1;
    _88 += _87;
    _88 *= _3.d2;
    _88 += i.d2;
    _a3_double _89 = _3.data[_88];
    _1 = _89;
    goto _jump523;
    _jump461:;
    bool _91;
    if (!a)
    goto _jump524;
    _91 = a;
    goto _jump525;
    _jump524:;
    _a2_int64_t _92;
    // Computing bound for m
    _92.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump526;
    fail_assertion("non-positive loop bound");
    _jump526:;
    // Computing bound for n
    _92.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= i.d1;
    _93 *= g.d0;
    _93 *= sizeof(int64_t);
    _92.data = jpl_alloc(_93);
    int64_t _94 = 0; // n
    int64_t _95 = 0; // m
    _jump528:; // Begin body of loop
    int64_t _96 = 0;
    _96 *= _92.d0;
    _96 += _95;
    _96 *= _92.d1;
    _96 += _94;
    _92.data[_96] = i.d0;
    _94++;
    if (_94 < g.d0)
    goto _jump528;
    _94 = 0;
    _95++;
    if (_95 < i.d1)
    goto _jump528;
    // End body of loop
    if (i.d2 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (i.d2 < _92.d0)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    if (g.d0 >= 0)
    goto _jump531;
    fail_assertion("negative array index");
    _jump531:;
    if (g.d0 < _92.d1)
    goto _jump532;
    fail_assertion("index too large");
    _jump532:;
    int64_t _97 = 0;
    _97 *= _92.d0;
    _97 += i.d2;
    _97 *= _92.d1;
    _97 += g.d0;
    int64_t _98 = _92.data[_97];
    bool _99 = i.d2 <= _98;
    _91 = _99;
    _jump525:;
    bool _90 = _91;
    if (0 == _91)
    goto _jump533;
    double _100 = 77.0;
    double _101 = 16.0;
    bool _102 = _100 == _101;
    _90 = _102;
    _jump533:;
    _a3_double _103;
    if (!_90)
    goto _jump534;
    _103 = i;
    goto _jump535;
    _jump534:;
    bool _104 = a;
    if (0 != a)
    goto _jump536;
    _a2_bool _105;
    // Computing bound for m
    _105.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for n
    _105.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= i.d0;
    _106 *= i.d0;
    _106 *= sizeof(bool);
    _105.data = jpl_alloc(_106);
    int64_t _107 = 0; // n
    int64_t _108 = 0; // m
    _jump539:; // Begin body of loop
    int64_t _109 = 0;
    _109 *= _105.d0;
    _109 += _108;
    _109 *= _105.d1;
    _109 += _107;
    _105.data[_109] = a;
    _107++;
    if (_107 < i.d0)
    goto _jump539;
    _107 = 0;
    _108++;
    if (_108 < i.d0)
    goto _jump539;
    // End body of loop
    int64_t _110;
    // Computing bound for m
    if (i.d0 > 0) 
    goto _jump540;
    fail_assertion("non-positive loop bound");
    _jump540:;
    // Computing bound for n
    if (i.d2 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing bound for o
    int64_t _111 = 282;
    if (_111 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    _110 = 0;
    int64_t _112 = 0; // o
    int64_t _113 = 0; // n
    int64_t _114 = 0; // m
    _jump543:; // Begin body of loop
    _110 += g.d0;
    _112++;
    if (_112 < _111)
    goto _jump543;
    _112 = 0;
    _113++;
    if (_113 < i.d2)
    goto _jump543;
    _113 = 0;
    _114++;
    if (_114 < i.d0)
    goto _jump543;
    // End body of loop
    if (g.d0 >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (g.d0 < _105.d0)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    if (_110 >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (_110 < _105.d1)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    int64_t _115 = 0;
    _115 *= _105.d0;
    _115 += g.d0;
    _115 *= _105.d1;
    _115 += _110;
    bool _116 = _105.data[_115];
    _104 = _116;
    _jump536:;
    bool _117 = !_104;
    _a3_double _118;
    if (!_117)
    goto _jump548;
    _118 = i;
    goto _jump549;
    _jump548:;
    _118 = i;
    _jump549:;
    _103 = _118;
    _jump535:;
    _1 = _103;
    _jump523:;
    if (0 != b)
    goto _jump550;
    fail_assertion("r");
    _jump550:;
    _a1_double _120;
    // Computing bound for r
    bool _121 = i.d1 != i.d0;
    int64_t _122;
    if (!_121)
    goto _jump551;
    _122 = i.d2;
    goto _jump552;
    _jump551:;
    int64_t _123;
    if (!b)
    goto _jump553;
    _123 = i.d0;
    goto _jump554;
    _jump553:;
    _123 = i.d1;
    _jump554:;
    _122 = _123;
    _jump552:;
    _120.d0 = _122;
    if (_122 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _122;
    _124 *= sizeof(double);
    _120.data = jpl_alloc(_124);
    int64_t _125 = 0; // r
    _jump556:; // Begin body of loop
    double _126 = c(g.d0, f);
    double _127 = c(_125, f);
    double _128 = fmod(_126, _127);
    int64_t _129 = 0;
    _129 *= _120.d0;
    _129 += _125;
    _120.data[_129] = _128;
    _125++;
    if (_125 < _122)
    goto _jump556;
    // End body of loop
    bool _130 = true;
    int64_t _131;
    if (!_130)
    goto _jump557;
    _131 = i.d2;
    goto _jump558;
    _jump557:;
    _131 = i.d0;
    _jump558:;
    if (_131 >= 0)
    goto _jump559;
    fail_assertion("negative array index");
    _jump559:;
    if (_131 < _120.d0)
    goto _jump560;
    fail_assertion("index too large");
    _jump560:;
    int64_t _132 = 0;
    _132 *= _120.d0;
    _132 += _131;
    double _133 = _120.data[_132];
    double _134;
    // Computing bound for r
    if (g.d0 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for s
    int64_t _135 = i.d1 * _1.d2;
    if (_135 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    _134 = 0;
    int64_t _136 = 0; // s
    int64_t _137 = 0; // r
    _jump563:; // Begin body of loop
    double _138;
    // Computing bound for t
    if (g.d0 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing bound for u
    if (g.d0 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing bound for v
    if (_1.d0 > 0) 
    goto _jump566;
    fail_assertion("non-positive loop bound");
    _jump566:;
    _138 = 0;
    int64_t _139 = 0; // v
    int64_t _140 = 0; // u
    int64_t _141 = 0; // t
    _jump567:; // Begin body of loop
    double _142 = 40.0;
    _138 += _142;
    _139++;
    if (_139 < _1.d0)
    goto _jump567;
    _139 = 0;
    _140++;
    if (_140 < g.d0)
    goto _jump567;
    _140 = 0;
    _141++;
    if (_141 < g.d0)
    goto _jump567;
    // End body of loop
    _134 += _138;
    _136++;
    if (_136 < _135)
    goto _jump563;
    _136 = 0;
    _137++;
    if (_137 < g.d0)
    goto _jump563;
    // End body of loop
    bool _143 = i.d0 >= _1.d1;
    double _144;
    if (!_143)
    goto _jump568;
    double _145 = c(_1.d0, f);
    _144 = _145;
    goto _jump569;
    _jump568:;
    double _146 = 16.0;
    _144 = _146;
    _jump569:;
    double _147 = 79.0;
    _a1_double _148;
    _148.d0 = 1;
    _148.data = jpl_alloc(sizeof(double) * 1);
    _148.data[0] = _147;
    if (_1.d2 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (_1.d2 < _148.d0)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    int64_t _149 = 0;
    _149 *= _148.d0;
    _149 += _1.d2;
    double _150 = _148.data[_149];
    _a1_double _151;
    _151.d0 = 3;
    _151.data = jpl_alloc(sizeof(double) * 3);
    _151.data[0] = _134;
    _151.data[1] = _144;
    _151.data[2] = _150;
    int64_t _152 = 945;
    if (_152 >= 0)
    goto _jump572;
    fail_assertion("negative array index");
    _jump572:;
    if (_152 < _151.d0)
    goto _jump573;
    fail_assertion("index too large");
    _jump573:;
    int64_t _153 = 0;
    _153 *= _151.d0;
    _153 += _152;
    double _154 = _151.data[_153];
    bool _155 = _133 < _154;
    bool _119 = _155;
    if (0 == _155)
    goto _jump574;
    double _156 = -d;
    double _157 = c(i.d0, f);
    double _158 = -_157;
    int64_t _159 = g.d0 % g.d0;
    double _160 = c(_159, f);
    rgba _161 = { _156, d, _158, _160 };
    double _162 = _161.a;
    bool _163 = _162 >= d;
    _119 = _163;
    _jump574:;
    bool _164 = !_119;
    if (0 != _164)
    goto _jump575;
    fail_assertion("r");
    _jump575:;
    int64_t _165 = 485;
    double _166;
    if (!a)
    goto _jump576;
    _166 = d;
    goto _jump577;
    _jump576:;
    double _167;
    // Computing bound for s
    _a1_int64_t _168;
    // Computing bound for s
    _168.d0 = _1.d2;
    if (_1.d2 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= _1.d2;
    _169 *= sizeof(int64_t);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // s
    _jump579:; // Begin body of loop
    int64_t _171 = 0;
    _171 *= _168.d0;
    _171 += _170;
    _168.data[_171] = _1.d1;
    _170++;
    if (_170 < _1.d2)
    goto _jump579;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump580;
    fail_assertion("negative array index");
    _jump580:;
    if (i.d0 < _168.d0)
    goto _jump581;
    fail_assertion("index too large");
    _jump581:;
    int64_t _172 = 0;
    _172 *= _168.d0;
    _172 += i.d0;
    int64_t _173 = _168.data[_172];
    if (_173 > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    _167 = 0;
    int64_t _174 = 0; // s
    _jump583:; // Begin body of loop
    double _175;
    // Computing bound for t
    if (g.d0 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing bound for u
    int64_t _176 = _1.d2 * i.d1;
    if (_176 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    _175 = 0;
    int64_t _177 = 0; // u
    int64_t _178 = 0; // t
    _jump586:; // Begin body of loop
    double _179;
    // Computing bound for v
    int64_t _180;
    // Computing bound for v
    if (_1.d2 > 0) 
    goto _jump587;
    fail_assertion("non-positive loop bound");
    _jump587:;
    // Computing bound for w
    if (i.d1 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    _180 = 0;
    int64_t _181 = 0; // w
    int64_t _182 = 0; // v
    _jump589:; // Begin body of loop
    _180 += _1.d1;
    _181++;
    if (_181 < i.d1)
    goto _jump589;
    _181 = 0;
    _182++;
    if (_182 < _1.d2)
    goto _jump589;
    // End body of loop
    if (_180 > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    _179 = 0;
    int64_t _183 = 0; // v
    _jump591:; // Begin body of loop
    double _184;
    // Computing bound for w
    if (_1.d0 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    _184 = 0;
    int64_t _185 = 0; // w
    _jump593:; // Begin body of loop
    double _186 = 91.0;
    _184 += _186;
    _185++;
    if (_185 < _1.d0)
    goto _jump593;
    // End body of loop
    double _187 = d + _184;
    _179 += _187;
    _183++;
    if (_183 < _180)
    goto _jump591;
    // End body of loop
    _175 += _179;
    _177++;
    if (_177 < _176)
    goto _jump586;
    _177 = 0;
    _178++;
    if (_178 < g.d0)
    goto _jump586;
    // End body of loop
    _167 += _175;
    _174++;
    if (_174 < _173)
    goto _jump583;
    // End body of loop
    _166 = _167;
    _jump577:;
    _a3_bool _188;
    // Computing bound for s
    _188.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for t
    int64_t _189;
    if (!b)
    goto _jump595;
    _189 = g.d0;
    goto _jump596;
    _jump595:;
    _189 = i.d1;
    _jump596:;
    _188.d1 = _189;
    if (_189 > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    // Computing bound for u
    int64_t _190;
    // Computing bound for s
    if (_165 > 0) 
    goto _jump598;
    fail_assertion("non-positive loop bound");
    _jump598:;
    _190 = 0;
    int64_t _191 = 0; // s
    _jump599:; // Begin body of loop
    _190 += i.d1;
    _191++;
    if (_191 < _165)
    goto _jump599;
    // End body of loop
    _188.d2 = _190;
    if (_190 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= i.d1;
    _192 *= _189;
    _192 *= _190;
    _192 *= sizeof(bool);
    _188.data = jpl_alloc(_192);
    int64_t _193 = 0; // u
    int64_t _194 = 0; // t
    int64_t _195 = 0; // s
    _jump601:; // Begin body of loop
    bool _196 = a;
    if (0 == a)
    goto _jump602;
    bool _197 = true;
    _196 = _197;
    _jump602:;
    int64_t _198 = 0;
    _198 *= _188.d0;
    _198 += _195;
    _198 *= _188.d1;
    _198 += _194;
    _198 *= _188.d2;
    _198 += _193;
    _188.data[_198] = _196;
    _193++;
    if (_193 < _190)
    goto _jump601;
    _193 = 0;
    _194++;
    if (_194 < _189)
    goto _jump601;
    _194 = 0;
    _195++;
    if (_195 < i.d1)
    goto _jump601;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump603;
    fail_assertion("negative array index");
    _jump603:;
    if (i.d0 < _188.d0)
    goto _jump604;
    fail_assertion("index too large");
    _jump604:;
    if (_1.d1 >= 0)
    goto _jump605;
    fail_assertion("negative array index");
    _jump605:;
    if (_1.d1 < _188.d1)
    goto _jump606;
    fail_assertion("index too large");
    _jump606:;
    if (_1.d0 >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (_1.d0 < _188.d2)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    int64_t _199 = 0;
    _199 *= _188.d0;
    _199 += i.d0;
    _199 *= _188.d1;
    _199 += _1.d1;
    _199 *= _188.d2;
    _199 += _1.d0;
    bool _200 = _188.data[_199];
    double _201;
    if (!_200)
    goto _jump609;
    double _202;
    // Computing bound for s
    if (i.d0 > 0) 
    goto _jump610;
    fail_assertion("non-positive loop bound");
    _jump610:;
    // Computing bound for t
    int64_t _203 = i.d0 % i.d2;
    if (_203 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for u
    if (_1.d2 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    _202 = 0;
    int64_t _204 = 0; // u
    int64_t _205 = 0; // t
    int64_t _206 = 0; // s
    _jump613:; // Begin body of loop
    _a3_double _207;
    // Computing bound for v
    _207.d0 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump614;
    fail_assertion("non-positive loop bound");
    _jump614:;
    // Computing bound for w
    _207.d1 = _165;
    if (_165 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing bound for x
    _207.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing total size of heap memory to allocate
    int64_t _208 = 1;
    _208 *= _1.d0;
    _208 *= _165;
    _208 *= g.d0;
    _208 *= sizeof(double);
    _207.data = jpl_alloc(_208);
    int64_t _209 = 0; // x
    int64_t _210 = 0; // w
    int64_t _211 = 0; // v
    _jump617:; // Begin body of loop
    int64_t _212 = 0;
    _212 *= _207.d0;
    _212 += _211;
    _212 *= _207.d1;
    _212 += _210;
    _212 *= _207.d2;
    _212 += _209;
    _207.data[_212] = d;
    _209++;
    if (_209 < g.d0)
    goto _jump617;
    _209 = 0;
    _210++;
    if (_210 < _165)
    goto _jump617;
    _210 = 0;
    _211++;
    if (_211 < _1.d0)
    goto _jump617;
    // End body of loop
    int64_t _213;
    if (!b)
    goto _jump618;
    _213 = _205;
    goto _jump619;
    _jump618:;
    _213 = i.d2;
    _jump619:;
    if (_1.d0 >= 0)
    goto _jump620;
    fail_assertion("negative array index");
    _jump620:;
    if (_1.d0 < _207.d0)
    goto _jump621;
    fail_assertion("index too large");
    _jump621:;
    if (i.d0 >= 0)
    goto _jump622;
    fail_assertion("negative array index");
    _jump622:;
    if (i.d0 < _207.d1)
    goto _jump623;
    fail_assertion("index too large");
    _jump623:;
    if (_213 >= 0)
    goto _jump624;
    fail_assertion("negative array index");
    _jump624:;
    if (_213 < _207.d2)
    goto _jump625;
    fail_assertion("index too large");
    _jump625:;
    int64_t _214 = 0;
    _214 *= _207.d0;
    _214 += _1.d0;
    _214 *= _207.d1;
    _214 += i.d0;
    _214 *= _207.d2;
    _214 += _213;
    double _215 = _207.data[_214];
    _202 += _215;
    _204++;
    if (_204 < _1.d2)
    goto _jump613;
    _204 = 0;
    _205++;
    if (_205 < _203)
    goto _jump613;
    _205 = 0;
    _206++;
    if (_206 < i.d0)
    goto _jump613;
    // End body of loop
    _201 = _202;
    goto _jump626;
    _jump609:;
    _201 = d;
    _jump626:;
    double _216 = 12.0;
    double _217 = -_216;
    double _218 = _201 + _217;
    double _219 = -_218;
    double _220 = 72.0;
    _a2_rgba _221;
    // Computing bound for s
    bool _222 = false;
    int64_t _223;
    if (!_222)
    goto _jump627;
    _223 = g.d0;
    goto _jump628;
    _jump627:;
    _223 = _165;
    _jump628:;
    _221.d0 = _223;
    if (_223 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    // Computing bound for t
    _221.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump630;
    fail_assertion("non-positive loop bound");
    _jump630:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= _223;
    _224 *= g.d0;
    _224 *= sizeof(rgba);
    _221.data = jpl_alloc(_224);
    int64_t _225 = 0; // t
    int64_t _226 = 0; // s
    _jump631:; // Begin body of loop
    double _227;
    // Computing bound for u
    int64_t _228 = 713;
    if (_228 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for v
    int64_t _229 = g.d0 * _165;
    if (_229 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    _227 = 0;
    int64_t _230 = 0; // v
    int64_t _231 = 0; // u
    _jump634:; // Begin body of loop
    _227 += d;
    _230++;
    if (_230 < _229)
    goto _jump634;
    _230 = 0;
    _231++;
    if (_231 < _228)
    goto _jump634;
    // End body of loop
    double _232 = 16.0;
    double _233;
    // Computing bound for u
    if (i.d1 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    _233 = 0;
    int64_t _234 = 0; // u
    _jump636:; // Begin body of loop
    double _235 = 47.0;
    _233 += _235;
    _234++;
    if (_234 < i.d1)
    goto _jump636;
    // End body of loop
    rgba _236 = { _227, _232, _233, d };
    int64_t _237 = 0;
    _237 *= _221.d0;
    _237 += _226;
    _237 *= _221.d1;
    _237 += _225;
    _221.data[_237] = _236;
    _225++;
    if (_225 < g.d0)
    goto _jump631;
    _225 = 0;
    _226++;
    if (_226 < _223)
    goto _jump631;
    // End body of loop
    if (_1.d2 >= 0)
    goto _jump637;
    fail_assertion("negative array index");
    _jump637:;
    if (_1.d2 < _221.d0)
    goto _jump638;
    fail_assertion("index too large");
    _jump638:;
    if (i.d2 >= 0)
    goto _jump639;
    fail_assertion("negative array index");
    _jump639:;
    if (i.d2 < _221.d1)
    goto _jump640;
    fail_assertion("index too large");
    _jump640:;
    int64_t _238 = 0;
    _238 *= _221.d0;
    _238 += _1.d2;
    _238 *= _221.d1;
    _238 += i.d2;
    rgba _239 = _221.data[_238];
    double _240 = _239.g;
    rgba _241 = { _166, _219, _220, _240 };
    bool _242 = false;
    bool _243 = !_242;
    void_t _244;
    if (!_243)
    goto _jump641;
    _a1_void_t _245;
    // Computing bound for t
    _245.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing total size of heap memory to allocate
    int64_t _246 = 1;
    _246 *= g.d0;
    _246 *= sizeof(void_t);
    _245.data = jpl_alloc(_246);
    int64_t _247 = 0; // t
    _jump643:; // Begin body of loop
    int64_t _248 = 0;
    _248 *= _245.d0;
    _248 += _247;
    _245.data[_248] = f;
    _247++;
    if (_247 < g.d0)
    goto _jump643;
    // End body of loop
    if (_165 >= 0)
    goto _jump644;
    fail_assertion("negative array index");
    _jump644:;
    if (_165 < _245.d0)
    goto _jump645;
    fail_assertion("index too large");
    _jump645:;
    int64_t _249 = 0;
    _249 *= _245.d0;
    _249 += _165;
    void_t _250 = _245.data[_249];
    _244 = _250;
    goto _jump646;
    _jump641:;
    _a2_void_t _251;
    // Computing bound for t
    _251.d0 = _165;
    if (_165 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    // Computing bound for u
    _251.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing total size of heap memory to allocate
    int64_t _252 = 1;
    _252 *= _165;
    _252 *= i.d1;
    _252 *= sizeof(void_t);
    _251.data = jpl_alloc(_252);
    int64_t _253 = 0; // u
    int64_t _254 = 0; // t
    _jump649:; // Begin body of loop
    _a2_void_t _255;
    if (!a)
    goto _jump650;
    _a2_void_t _256;
    // Computing bound for v
    _256.d0 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump651;
    fail_assertion("non-positive loop bound");
    _jump651:;
    // Computing bound for w
    _256.d1 = _165;
    if (_165 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing total size of heap memory to allocate
    int64_t _257 = 1;
    _257 *= _1.d0;
    _257 *= _165;
    _257 *= sizeof(void_t);
    _256.data = jpl_alloc(_257);
    int64_t _258 = 0; // w
    int64_t _259 = 0; // v
    _jump653:; // Begin body of loop
    int64_t _260 = 0;
    _260 *= _256.d0;
    _260 += _259;
    _260 *= _256.d1;
    _260 += _258;
    _256.data[_260] = f;
    _258++;
    if (_258 < _165)
    goto _jump653;
    _258 = 0;
    _259++;
    if (_259 < _1.d0)
    goto _jump653;
    // End body of loop
    _255 = _256;
    goto _jump654;
    _jump650:;
    _a2_void_t _261;
    // Computing bound for v
    _261.d0 = _254;
    if (_254 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for w
    _261.d1 = _254;
    if (_254 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing total size of heap memory to allocate
    int64_t _262 = 1;
    _262 *= _254;
    _262 *= _254;
    _262 *= sizeof(void_t);
    _261.data = jpl_alloc(_262);
    int64_t _263 = 0; // w
    int64_t _264 = 0; // v
    _jump657:; // Begin body of loop
    int64_t _265 = 0;
    _265 *= _261.d0;
    _265 += _264;
    _265 *= _261.d1;
    _265 += _263;
    _261.data[_265] = f;
    _263++;
    if (_263 < _254)
    goto _jump657;
    _263 = 0;
    _264++;
    if (_264 < _254)
    goto _jump657;
    // End body of loop
    _255 = _261;
    _jump654:;
    int64_t _266 = 322;
    if (g.d0 >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (g.d0 < _255.d0)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    if (_266 >= 0)
    goto _jump660;
    fail_assertion("negative array index");
    _jump660:;
    if (_266 < _255.d1)
    goto _jump661;
    fail_assertion("index too large");
    _jump661:;
    int64_t _267 = 0;
    _267 *= _255.d0;
    _267 += g.d0;
    _267 *= _255.d1;
    _267 += _266;
    void_t _268 = _255.data[_267];
    _a3__a1_void_t _269;
    // Computing bound for v
    _269.d0 = _1.d2;
    if (_1.d2 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing bound for w
    _269.d1 = _254;
    if (_254 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing bound for x
    _269.d2 = _253;
    if (_253 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing total size of heap memory to allocate
    int64_t _270 = 1;
    _270 *= _1.d2;
    _270 *= _254;
    _270 *= _253;
    _270 *= sizeof(_a1_void_t);
    _269.data = jpl_alloc(_270);
    int64_t _271 = 0; // x
    int64_t _272 = 0; // w
    int64_t _273 = 0; // v
    _jump665:; // Begin body of loop
    int64_t _274 = 0;
    _274 *= _269.d0;
    _274 += _273;
    _274 *= _269.d1;
    _274 += _272;
    _274 *= _269.d2;
    _274 += _271;
    _269.data[_274] = g;
    _271++;
    if (_271 < _253)
    goto _jump665;
    _271 = 0;
    _272++;
    if (_272 < _254)
    goto _jump665;
    _272 = 0;
    _273++;
    if (_273 < _1.d2)
    goto _jump665;
    // End body of loop
    int64_t _275;
    // Computing bound for v
    int64_t _276;
    if (!a)
    goto _jump666;
    _276 = g.d0;
    goto _jump667;
    _jump666:;
    _276 = _1.d0;
    _jump667:;
    if (_276 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    _275 = 0;
    int64_t _277 = 0; // v
    _jump669:; // Begin body of loop
    int64_t _278;
    // Computing bound for w
    if (g.d0 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    // Computing bound for x
    if (_277 > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    _278 = 0;
    int64_t _279 = 0; // x
    int64_t _280 = 0; // w
    _jump672:; // Begin body of loop
    _278 += _279;
    _279++;
    if (_279 < _277)
    goto _jump672;
    _279 = 0;
    _280++;
    if (_280 < g.d0)
    goto _jump672;
    // End body of loop
    _275 += _278;
    _277++;
    if (_277 < _276)
    goto _jump669;
    // End body of loop
    if (_1.d0 >= 0)
    goto _jump673;
    fail_assertion("negative array index");
    _jump673:;
    if (_1.d0 < _269.d0)
    goto _jump674;
    fail_assertion("index too large");
    _jump674:;
    if (_253 >= 0)
    goto _jump675;
    fail_assertion("negative array index");
    _jump675:;
    if (_253 < _269.d1)
    goto _jump676;
    fail_assertion("index too large");
    _jump676:;
    if (_275 >= 0)
    goto _jump677;
    fail_assertion("negative array index");
    _jump677:;
    if (_275 < _269.d2)
    goto _jump678;
    fail_assertion("index too large");
    _jump678:;
    int64_t _281 = 0;
    _281 *= _269.d0;
    _281 += _1.d0;
    _281 *= _269.d1;
    _281 += _253;
    _281 *= _269.d2;
    _281 += _275;
    _a1_void_t _282 = _269.data[_281];
    void_t _283 = e(_268, _282, i);
    int64_t _284 = 0;
    _284 *= _251.d0;
    _284 += _254;
    _284 *= _251.d1;
    _284 += _253;
    _251.data[_284] = _283;
    _253++;
    if (_253 < i.d1)
    goto _jump649;
    _253 = 0;
    _254++;
    if (_254 < _165)
    goto _jump649;
    // End body of loop
    int64_t _285;
    // Computing bound for t
    if (_1.d1 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    _285 = 0;
    int64_t _286 = 0; // t
    _jump680:; // Begin body of loop
    _285 += i.d1;
    _286++;
    if (_286 < _1.d1)
    goto _jump680;
    // End body of loop
    if (_1.d2 >= 0)
    goto _jump681;
    fail_assertion("negative array index");
    _jump681:;
    if (_1.d2 < _251.d0)
    goto _jump682;
    fail_assertion("index too large");
    _jump682:;
    if (_285 >= 0)
    goto _jump683;
    fail_assertion("negative array index");
    _jump683:;
    if (_285 < _251.d1)
    goto _jump684;
    fail_assertion("index too large");
    _jump684:;
    int64_t _287 = 0;
    _287 *= _251.d0;
    _287 += _1.d2;
    _287 *= _251.d1;
    _287 += _285;
    void_t _288 = _251.data[_287];
    _244 = _288;
    _jump646:;
    return _244;
}

int64_t g(_a1_int64_t h) {
    int64_t _1;
    if (!f)
    goto _jump814;
    int64_t _2 = 583;
    int64_t _3 = -_2;
    _1 = _3;
    goto _jump815;
    _jump814:;
    int64_t _4 = g(h);
    _1 = _4;
    _jump815:;
    int64_t _5;
    // Computing bound for j
    int64_t _6;
    // Computing bound for j
    int64_t _7 = 262;
    if (_7 > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    _6 = 0;
    int64_t _8 = 0; // j
    _jump817:; // Begin body of loop
    int64_t _9;
    // Computing bound for k
    if (h.d0 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    _9 = 0;
    int64_t _10 = 0; // k
    _jump819:; // Begin body of loop
    _9 += _10;
    _10++;
    if (_10 < h.d0)
    goto _jump819;
    // End body of loop
    _6 += _9;
    _8++;
    if (_8 < _7)
    goto _jump817;
    // End body of loop
    if (_6 > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    _5 = 0;
    int64_t _11 = 0; // j
    _jump821:; // Begin body of loop
    _5 += h.d0;
    _11++;
    if (_11 < _6)
    goto _jump821;
    // End body of loop
    bool _12 = _1 <= _5;
    bool _0 = _12;
    if (0 == _12)
    goto _jump822;
    int64_t _14 = 829;
    bool _15 = _14 < h.d0;
    double _16;
    if (!_15)
    goto _jump823;
    double _17 = 44.0;
    double _18 = d * _17;
    _16 = _18;
    goto _jump824;
    _jump823:;
    double _19 = 67.0;
    _16 = _19;
    _jump824:;
    bool _20 = d >= _16;
    bool _13 = _20;
    if (0 == _20)
    goto _jump825;
    _13 = f;
    _jump825:;
    _0 = _13;
    _jump822:;
    bool _21;
    if (!_0)
    goto _jump826;
    bool _23 = a;
    if (0 == a)
    goto _jump827;
    _23 = a;
    _jump827:;
    bool _24;
    if (!_23)
    goto _jump828;
    _24 = a;
    goto _jump829;
    _jump828:;
    bool _25 = false;
    _24 = _25;
    _jump829:;
    bool _22 = _24;
    if (0 != _24)
    goto _jump830;
    bool _27 = f == b;
    bool _26 = _27;
    if (0 != _27)
    goto _jump831;
    bool _28 = f;
    if (0 != f)
    goto _jump832;
    _28 = f;
    _jump832:;
    _26 = _28;
    _jump831:;
    _22 = _26;
    _jump830:;
    bool _29 = !_22;
    bool _30 = !_29;
    _21 = _30;
    goto _jump833;
    _jump826:;
    _21 = f;
    _jump833:;
    _a2__a1_int64_t _31;
    if (!_21)
    goto _jump834;
    _a2__a2__a2__a1_int64_t _32;
    // Computing bound for j
    _32.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing bound for k
    int64_t _33;
    // Computing bound for j
    if (h.d0 > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for k
    int64_t _34 = g(h);
    if (_34 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    _33 = 0;
    int64_t _35 = 0; // k
    int64_t _36 = 0; // j
    _jump838:; // Begin body of loop
    int64_t _37;
    // Computing bound for l
    if (h.d0 > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    _37 = 0;
    int64_t _38 = 0; // l
    _jump840:; // Begin body of loop
    _37 += _36;
    _38++;
    if (_38 < h.d0)
    goto _jump840;
    // End body of loop
    _33 += _37;
    _35++;
    if (_35 < _34)
    goto _jump838;
    _35 = 0;
    _36++;
    if (_36 < h.d0)
    goto _jump838;
    // End body of loop
    int64_t _39 = -h.d0;
    int64_t _40 = _33 - _39;
    _32.d1 = _40;
    if (_40 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= h.d0;
    _41 *= _40;
    _41 *= sizeof(_a2__a2__a1_int64_t);
    _32.data = jpl_alloc(_41);
    int64_t _42 = 0; // k
    int64_t _43 = 0; // j
    _jump842:; // Begin body of loop
    _a2__a2__a1_int64_t _44;
    // Computing bound for l
    _a1_int64_t _45;
    // Computing bound for l
    _45.d0 = _42;
    if (_42 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= _42;
    _46 *= sizeof(int64_t);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // l
    _jump844:; // Begin body of loop
    int64_t _48 = 95;
    int64_t _49 = 0;
    _49 *= _45.d0;
    _49 += _47;
    _45.data[_49] = _48;
    _47++;
    if (_47 < _42)
    goto _jump844;
    // End body of loop
    int64_t _50;
    if (!a)
    goto _jump845;
    int64_t _51 = 696;
    _50 = _51;
    goto _jump846;
    _jump845:;
    _50 = _42;
    _jump846:;
    if (_50 >= 0)
    goto _jump847;
    fail_assertion("negative array index");
    _jump847:;
    if (_50 < _45.d0)
    goto _jump848;
    fail_assertion("index too large");
    _jump848:;
    int64_t _52 = 0;
    _52 *= _45.d0;
    _52 += _50;
    int64_t _53 = _45.data[_52];
    _44.d0 = _53;
    if (_53 > 0) 
    goto _jump849;
    fail_assertion("non-positive loop bound");
    _jump849:;
    // Computing bound for m
    int64_t _54;
    // Computing bound for l
    if (h.d0 > 0) 
    goto _jump850;
    fail_assertion("non-positive loop bound");
    _jump850:;
    // Computing bound for m
    int64_t _55;
    // Computing bound for l
    if (h.d0 > 0) 
    goto _jump851;
    fail_assertion("non-positive loop bound");
    _jump851:;
    // Computing bound for m
    if (_42 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    _55 = 0;
    int64_t _56 = 0; // m
    int64_t _57 = 0; // l
    _jump853:; // Begin body of loop
    int64_t _58 = 522;
    _55 += _58;
    _56++;
    if (_56 < _42)
    goto _jump853;
    _56 = 0;
    _57++;
    if (_57 < h.d0)
    goto _jump853;
    // End body of loop
    if (_55 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing bound for n
    int64_t _59 = 505;
    int64_t _60 = h.d0 - _59;
    if (_60 > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    _54 = 0;
    int64_t _61 = 0; // n
    int64_t _62 = 0; // m
    int64_t _63 = 0; // l
    _jump856:; // Begin body of loop
    _54 += _62;
    _61++;
    if (_61 < _60)
    goto _jump856;
    _61 = 0;
    _62++;
    if (_62 < _55)
    goto _jump856;
    _62 = 0;
    _63++;
    if (_63 < h.d0)
    goto _jump856;
    // End body of loop
    _44.d1 = _54;
    if (_54 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= _53;
    _64 *= _54;
    _64 *= sizeof(_a2__a1_int64_t);
    _44.data = jpl_alloc(_64);
    int64_t _65 = 0; // m
    int64_t _66 = 0; // l
    _jump858:; // Begin body of loop
    _a2__a1_int64_t _67;
    // Computing bound for n
    int64_t _68;
    // Computing bound for n
    if (_65 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    // Computing bound for o
    if (_43 > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    // Computing bound for p
    if (h.d0 > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    _68 = 0;
    int64_t _69 = 0; // p
    int64_t _70 = 0; // o
    int64_t _71 = 0; // n
    _jump862:; // Begin body of loop
    _68 += _66;
    _69++;
    if (_69 < h.d0)
    goto _jump862;
    _69 = 0;
    _70++;
    if (_70 < _43)
    goto _jump862;
    _70 = 0;
    _71++;
    if (_71 < _65)
    goto _jump862;
    // End body of loop
    _67.d0 = _68;
    if (_68 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing bound for o
    int64_t _72;
    // Computing bound for n
    if (_65 > 0) 
    goto _jump864;
    fail_assertion("non-positive loop bound");
    _jump864:;
    // Computing bound for o
    int64_t _73 = 877;
    if (_73 > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    // Computing bound for p
    if (_66 > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    _72 = 0;
    int64_t _74 = 0; // p
    int64_t _75 = 0; // o
    int64_t _76 = 0; // n
    _jump867:; // Begin body of loop
    _72 += _74;
    _74++;
    if (_74 < _66)
    goto _jump867;
    _74 = 0;
    _75++;
    if (_75 < _73)
    goto _jump867;
    _75 = 0;
    _76++;
    if (_76 < _65)
    goto _jump867;
    // End body of loop
    _67.d1 = _72;
    if (_72 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _68;
    _77 *= _72;
    _77 *= sizeof(_a1_int64_t);
    _67.data = jpl_alloc(_77);
    int64_t _78 = 0; // o
    int64_t _79 = 0; // n
    _jump869:; // Begin body of loop
    int64_t _80 = 230;
    _a1_int64_t _81;
    _81.d0 = 3;
    _81.data = jpl_alloc(sizeof(int64_t) * 3);
    _81.data[0] = _78;
    _81.data[1] = _80;
    _81.data[2] = _43;
    int64_t _82 = 0;
    _82 *= _67.d0;
    _82 += _79;
    _82 *= _67.d1;
    _82 += _78;
    _67.data[_82] = _81;
    _78++;
    if (_78 < _72)
    goto _jump869;
    _78 = 0;
    _79++;
    if (_79 < _68)
    goto _jump869;
    // End body of loop
    int64_t _83 = 0;
    _83 *= _44.d0;
    _83 += _66;
    _83 *= _44.d1;
    _83 += _65;
    _44.data[_83] = _67;
    _65++;
    if (_65 < _54)
    goto _jump858;
    _65 = 0;
    _66++;
    if (_66 < _53)
    goto _jump858;
    // End body of loop
    int64_t _84 = 0;
    _84 *= _32.d0;
    _84 += _43;
    _84 *= _32.d1;
    _84 += _42;
    _32.data[_84] = _44;
    _42++;
    if (_42 < _40)
    goto _jump842;
    _42 = 0;
    _43++;
    if (_43 < h.d0)
    goto _jump842;
    // End body of loop
    int64_t _85 = 855;
    int64_t _86 = 439;
    if (_85 >= 0)
    goto _jump870;
    fail_assertion("negative array index");
    _jump870:;
    if (_85 < _32.d0)
    goto _jump871;
    fail_assertion("index too large");
    _jump871:;
    if (_86 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_86 < _32.d1)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    int64_t _87 = 0;
    _87 *= _32.d0;
    _87 += _85;
    _87 *= _32.d1;
    _87 += _86;
    _a2__a2__a1_int64_t _88 = _32.data[_87];
    int64_t _89 = g(h);
    int64_t _90 = -_89;
    _a1_int64_t _91;
    _91.d0 = 1;
    _91.data = jpl_alloc(sizeof(int64_t) * 1);
    _91.data[0] = _90;
    int64_t _92;
    // Computing bound for j
    int64_t _93 = g(h);
    int64_t _94 = -_93;
    if (_94 > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing bound for k
    int64_t _95 = 914;
    if (_95 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    _92 = 0;
    int64_t _96 = 0; // k
    int64_t _97 = 0; // j
    _jump876:; // Begin body of loop
    _92 += h.d0;
    _96++;
    if (_96 < _95)
    goto _jump876;
    _96 = 0;
    _97++;
    if (_97 < _94)
    goto _jump876;
    // End body of loop
    int64_t _98 = -_92;
    if (_98 >= 0)
    goto _jump877;
    fail_assertion("negative array index");
    _jump877:;
    if (_98 < _91.d0)
    goto _jump878;
    fail_assertion("index too large");
    _jump878:;
    int64_t _99 = 0;
    _99 *= _91.d0;
    _99 += _98;
    int64_t _100 = _91.data[_99];
    int64_t _101;
    // Computing bound for j
    _a2_int64_t _102;
    // Computing bound for j
    int64_t _103 = 250;
    int64_t _104 = h.d0 % _103;
    _102.d0 = _104;
    if (_104 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing bound for k
    _102.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _104;
    _105 *= h.d0;
    _105 *= sizeof(int64_t);
    _102.data = jpl_alloc(_105);
    int64_t _106 = 0; // k
    int64_t _107 = 0; // j
    _jump881:; // Begin body of loop
    int64_t _108 = 0;
    _108 *= _102.d0;
    _108 += _107;
    _108 *= _102.d1;
    _108 += _106;
    _102.data[_108] = _106;
    _106++;
    if (_106 < h.d0)
    goto _jump881;
    _106 = 0;
    _107++;
    if (_107 < _104)
    goto _jump881;
    // End body of loop
    int64_t _109 = h.d0 - h.d0;
    int64_t _110 = 290;
    int64_t _111 = -_110;
    int64_t _112 = _109 + _111;
    int64_t _113 = 850;
    if (_112 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_112 < _102.d0)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    if (_113 >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (_113 < _102.d1)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    int64_t _114 = 0;
    _114 *= _102.d0;
    _114 += _112;
    _114 *= _102.d1;
    _114 += _113;
    int64_t _115 = _102.data[_114];
    if (_115 > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    _101 = 0;
    int64_t _116 = 0; // j
    _jump887:; // Begin body of loop
    _a2_int64_t _117;
    // Computing bound for k
    _117.d0 = _116;
    if (_116 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    // Computing bound for l
    _117.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= _116;
    _118 *= h.d0;
    _118 *= sizeof(int64_t);
    _117.data = jpl_alloc(_118);
    int64_t _119 = 0; // l
    int64_t _120 = 0; // k
    _jump890:; // Begin body of loop
    int64_t _121 = 0;
    _121 *= _117.d0;
    _121 += _120;
    _121 *= _117.d1;
    _121 += _119;
    _117.data[_121] = _120;
    _119++;
    if (_119 < h.d0)
    goto _jump890;
    _119 = 0;
    _120++;
    if (_120 < _116)
    goto _jump890;
    // End body of loop
    int64_t _122 = 936;
    int64_t _123 = -_122;
    if (_123 >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (_123 < _117.d0)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    if (_116 >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (_116 < _117.d1)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    int64_t _124 = 0;
    _124 *= _117.d0;
    _124 += _123;
    _124 *= _117.d1;
    _124 += _116;
    int64_t _125 = _117.data[_124];
    _101 += _125;
    _116++;
    if (_116 < _115)
    goto _jump887;
    // End body of loop
    int64_t _126;
    if (!f)
    goto _jump895;
    _126 = h.d0;
    goto _jump896;
    _jump895:;
    int64_t _127 = 489;
    _126 = _127;
    _jump896:;
    int64_t _128 = h.d0 - _126;
    int64_t _129 = -_128;
    int64_t _130 = _101 - _129;
    if (_100 >= 0)
    goto _jump897;
    fail_assertion("negative array index");
    _jump897:;
    if (_100 < _88.d0)
    goto _jump898;
    fail_assertion("index too large");
    _jump898:;
    if (_130 >= 0)
    goto _jump899;
    fail_assertion("negative array index");
    _jump899:;
    if (_130 < _88.d1)
    goto _jump900;
    fail_assertion("index too large");
    _jump900:;
    int64_t _131 = 0;
    _131 *= _88.d0;
    _131 += _100;
    _131 *= _88.d1;
    _131 += _130;
    _a2__a1_int64_t _132 = _88.data[_131];
    _31 = _132;
    goto _jump901;
    _jump834:;
    _a2__a1_int64_t _133;
    // Computing bound for j
    int64_t _135 = 826;
    _a1_int64_t _136;
    _136.d0 = 1;
    _136.data = jpl_alloc(sizeof(int64_t) * 1);
    _136.data[0] = _135;
    int64_t _137 = g(_136);
    bool _138 = _137 == h.d0;
    bool _134 = _138;
    if (0 == _138)
    goto _jump902;
    int64_t _139 = g(h);
    bool _140 = _139 != h.d0;
    bool _141 = !_140;
    _134 = _141;
    _jump902:;
    int64_t _142;
    if (!_134)
    goto _jump903;
    _a3_int64_t _143;
    // Computing bound for j
    int64_t _144 = 524;
    int64_t _145 = -_144;
    int64_t _146 = -_145;
    _143.d0 = _146;
    if (_146 > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for k
    int64_t _147 = g(h);
    if (_147 >= 0)
    goto _jump905;
    fail_assertion("negative array index");
    _jump905:;
    if (_147 < h.d0)
    goto _jump906;
    fail_assertion("index too large");
    _jump906:;
    int64_t _148 = 0;
    _148 *= h.d0;
    _148 += _147;
    int64_t _149 = h.data[_148];
    _143.d1 = _149;
    if (_149 > 0) 
    goto _jump907;
    fail_assertion("non-positive loop bound");
    _jump907:;
    // Computing bound for l
    int64_t _150 = 804;
    _143.d2 = _150;
    if (_150 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= _146;
    _151 *= _149;
    _151 *= _150;
    _151 *= sizeof(int64_t);
    _143.data = jpl_alloc(_151);
    int64_t _152 = 0; // l
    int64_t _153 = 0; // k
    int64_t _154 = 0; // j
    _jump909:; // Begin body of loop
    int64_t _155;
    if (!b)
    goto _jump910;
    int64_t _156 = g(h);
    _155 = _156;
    goto _jump911;
    _jump910:;
    _155 = _153;
    _jump911:;
    int64_t _157 = 0;
    _157 *= _143.d0;
    _157 += _154;
    _157 *= _143.d1;
    _157 += _153;
    _157 *= _143.d2;
    _157 += _152;
    _143.data[_157] = _155;
    _152++;
    if (_152 < _150)
    goto _jump909;
    _152 = 0;
    _153++;
    if (_153 < _149)
    goto _jump909;
    _153 = 0;
    _154++;
    if (_154 < _146)
    goto _jump909;
    // End body of loop
    int64_t _158 = 582;
    int64_t _159 = 394;
    int64_t _160 = -_159;
    int64_t _161 = _158 + _160;
    _a3_int64_t _162;
    // Computing bound for j
    int64_t _163;
    if (!b)
    goto _jump912;
    _163 = h.d0;
    goto _jump913;
    _jump912:;
    _163 = h.d0;
    _jump913:;
    _162.d0 = _163;
    if (_163 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing bound for k
    int64_t _164 = 415;
    int64_t _165 = -_164;
    _162.d1 = _165;
    if (_165 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing bound for l
    int64_t _166 = 53;
    int64_t _167 = -_166;
    _162.d2 = _167;
    if (_167 > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    // Computing total size of heap memory to allocate
    int64_t _168 = 1;
    _168 *= _163;
    _168 *= _165;
    _168 *= _167;
    _168 *= sizeof(int64_t);
    _162.data = jpl_alloc(_168);
    int64_t _169 = 0; // l
    int64_t _170 = 0; // k
    int64_t _171 = 0; // j
    _jump917:; // Begin body of loop
    int64_t _172;
    if (!f)
    goto _jump918;
    _172 = h.d0;
    goto _jump919;
    _jump918:;
    _172 = _169;
    _jump919:;
    int64_t _173 = 0;
    _173 *= _162.d0;
    _173 += _171;
    _173 *= _162.d1;
    _173 += _170;
    _173 *= _162.d2;
    _173 += _169;
    _162.data[_173] = _172;
    _169++;
    if (_169 < _167)
    goto _jump917;
    _169 = 0;
    _170++;
    if (_170 < _165)
    goto _jump917;
    _170 = 0;
    _171++;
    if (_171 < _163)
    goto _jump917;
    // End body of loop
    int64_t _174 = 567;
    int64_t _175 = -_174;
    int64_t _176 = g(h);
    int64_t _177 = _175 % _176;
    int64_t _178 = 321;
    int64_t _179 = g(h);
    int64_t _180 = _178 * _179;
    if (_177 >= 0)
    goto _jump920;
    fail_assertion("negative array index");
    _jump920:;
    if (_177 < _162.d0)
    goto _jump921;
    fail_assertion("index too large");
    _jump921:;
    if (_180 >= 0)
    goto _jump922;
    fail_assertion("negative array index");
    _jump922:;
    if (_180 < _162.d1)
    goto _jump923;
    fail_assertion("index too large");
    _jump923:;
    if (h.d0 >= 0)
    goto _jump924;
    fail_assertion("negative array index");
    _jump924:;
    if (h.d0 < _162.d2)
    goto _jump925;
    fail_assertion("index too large");
    _jump925:;
    int64_t _181 = 0;
    _181 *= _162.d0;
    _181 += _177;
    _181 *= _162.d1;
    _181 += _180;
    _181 *= _162.d2;
    _181 += h.d0;
    int64_t _182 = _162.data[_181];
    if (_161 >= 0)
    goto _jump926;
    fail_assertion("negative array index");
    _jump926:;
    if (_161 < _143.d0)
    goto _jump927;
    fail_assertion("index too large");
    _jump927:;
    if (h.d0 >= 0)
    goto _jump928;
    fail_assertion("negative array index");
    _jump928:;
    if (h.d0 < _143.d1)
    goto _jump929;
    fail_assertion("index too large");
    _jump929:;
    if (_182 >= 0)
    goto _jump930;
    fail_assertion("negative array index");
    _jump930:;
    if (_182 < _143.d2)
    goto _jump931;
    fail_assertion("index too large");
    _jump931:;
    int64_t _183 = 0;
    _183 *= _143.d0;
    _183 += _161;
    _183 *= _143.d1;
    _183 += h.d0;
    _183 *= _143.d2;
    _183 += _182;
    int64_t _184 = _143.data[_183];
    _142 = _184;
    goto _jump932;
    _jump903:;
    _a2_int64_t _185;
    if (!f)
    goto _jump933;
    _a2_int64_t _186;
    // Computing bound for j
    int64_t _187 = 891;
    _186.d0 = _187;
    if (_187 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for k
    int64_t _188 = g(h);
    _186.d1 = _188;
    if (_188 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _189 = 1;
    _189 *= _187;
    _189 *= _188;
    _189 *= sizeof(int64_t);
    _186.data = jpl_alloc(_189);
    int64_t _190 = 0; // k
    int64_t _191 = 0; // j
    _jump936:; // Begin body of loop
    int64_t _192 = 0;
    _192 *= _186.d0;
    _192 += _191;
    _192 *= _186.d1;
    _192 += _190;
    _186.data[_192] = _191;
    _190++;
    if (_190 < _188)
    goto _jump936;
    _190 = 0;
    _191++;
    if (_191 < _187)
    goto _jump936;
    // End body of loop
    _185 = _186;
    goto _jump937;
    _jump933:;
    _a2_int64_t _193;
    // Computing bound for j
    int64_t _194 = -h.d0;
    _193.d0 = _194;
    if (_194 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing bound for k
    if (h.d0 >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (h.d0 < h.d0)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    int64_t _195 = 0;
    _195 *= h.d0;
    _195 += h.d0;
    int64_t _196 = h.data[_195];
    _193.d1 = _196;
    if (_196 > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= _194;
    _197 *= _196;
    _197 *= sizeof(int64_t);
    _193.data = jpl_alloc(_197);
    int64_t _198 = 0; // k
    int64_t _199 = 0; // j
    _jump942:; // Begin body of loop
    int64_t _200 = 0;
    _200 *= _193.d0;
    _200 += _199;
    _200 *= _193.d1;
    _200 += _198;
    _193.data[_200] = _198;
    _198++;
    if (_198 < _196)
    goto _jump942;
    _198 = 0;
    _199++;
    if (_199 < _194)
    goto _jump942;
    // End body of loop
    _185 = _193;
    _jump937:;
    _a1_int64_t _201;
    if (!f)
    goto _jump943;
    _201 = h;
    goto _jump944;
    _jump943:;
    _201 = h;
    _jump944:;
    if (h.d0 >= 0)
    goto _jump945;
    fail_assertion("negative array index");
    _jump945:;
    if (h.d0 < _201.d0)
    goto _jump946;
    fail_assertion("index too large");
    _jump946:;
    int64_t _202 = 0;
    _202 *= _201.d0;
    _202 += h.d0;
    int64_t _203 = _201.data[_202];
    int64_t _204;
    // Computing bound for j
    int64_t _205;
    // Computing bound for j
    int64_t _206 = 828;
    int64_t _207 = _206 + h.d0;
    if (_207 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    _205 = 0;
    int64_t _208 = 0; // j
    _jump948:; // Begin body of loop
    int64_t _209 = _208 + h.d0;
    _205 += _209;
    _208++;
    if (_208 < _207)
    goto _jump948;
    // End body of loop
    if (_205 > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    // Computing bound for k
    int64_t _210;
    if (!f)
    goto _jump950;
    _210 = h.d0;
    goto _jump951;
    _jump950:;
    _210 = h.d0;
    _jump951:;
    if (_210 > 0) 
    goto _jump952;
    fail_assertion("non-positive loop bound");
    _jump952:;
    // Computing bound for l
    int64_t _211;
    // Computing bound for j
    int64_t _212 = 864;
    if (_212 >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (_212 < h.d0)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    int64_t _213 = 0;
    _213 *= h.d0;
    _213 += _212;
    int64_t _214 = h.data[_213];
    if (_214 > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing bound for k
    int64_t _215 = 744;
    if (_215 > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for l
    int64_t _216 = g(h);
    if (_216 > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    _211 = 0;
    int64_t _217 = 0; // l
    int64_t _218 = 0; // k
    int64_t _219 = 0; // j
    _jump958:; // Begin body of loop
    int64_t _220 = 343;
    _211 += _220;
    _217++;
    if (_217 < _216)
    goto _jump958;
    _217 = 0;
    _218++;
    if (_218 < _215)
    goto _jump958;
    _218 = 0;
    _219++;
    if (_219 < _214)
    goto _jump958;
    // End body of loop
    if (_211 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    _204 = 0;
    int64_t _221 = 0; // l
    int64_t _222 = 0; // k
    int64_t _223 = 0; // j
    _jump960:; // Begin body of loop
    _204 += _221;
    _221++;
    if (_221 < _211)
    goto _jump960;
    _221 = 0;
    _222++;
    if (_222 < _210)
    goto _jump960;
    _222 = 0;
    _223++;
    if (_223 < _205)
    goto _jump960;
    // End body of loop
    if (_203 >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (_203 < _185.d0)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    if (_204 >= 0)
    goto _jump963;
    fail_assertion("negative array index");
    _jump963:;
    if (_204 < _185.d1)
    goto _jump964;
    fail_assertion("index too large");
    _jump964:;
    int64_t _224 = 0;
    _224 *= _185.d0;
    _224 += _203;
    _224 *= _185.d1;
    _224 += _204;
    int64_t _225 = _185.data[_224];
    _142 = _225;
    _jump932:;
    _133.d0 = _142;
    if (_142 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing bound for k
    bool _226 = false;
    bool _227;
    if (!_226)
    goto _jump966;
    bool _228 = !a;
    _227 = _228;
    goto _jump967;
    _jump966:;
    double _230 = 84.0;
    bool _231 = _230 == d;
    bool _229 = _231;
    if (0 == _231)
    goto _jump968;
    bool _232 = false;
    _229 = _232;
    _jump968:;
    _227 = _229;
    _jump967:;
    _a3_int64_t _233;
    if (!_227)
    goto _jump969;
    bool _234 = true;
    bool _235;
    if (!_234)
    goto _jump970;
    bool _236 = d > d;
    _235 = _236;
    goto _jump971;
    _jump970:;
    _235 = f;
    _jump971:;
    _a3_int64_t _237;
    if (!_235)
    goto _jump972;
    _a3_int64_t _238;
    // Computing bound for j
    int64_t _239 = 593;
    _238.d0 = _239;
    if (_239 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for k
    int64_t _240 = 947;
    _238.d1 = _240;
    if (_240 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for l
    int64_t _241 = 924;
    _238.d2 = _241;
    if (_241 > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing total size of heap memory to allocate
    int64_t _242 = 1;
    _242 *= _239;
    _242 *= _240;
    _242 *= _241;
    _242 *= sizeof(int64_t);
    _238.data = jpl_alloc(_242);
    int64_t _243 = 0; // l
    int64_t _244 = 0; // k
    int64_t _245 = 0; // j
    _jump976:; // Begin body of loop
    int64_t _246 = 0;
    _246 *= _238.d0;
    _246 += _245;
    _246 *= _238.d1;
    _246 += _244;
    _246 *= _238.d2;
    _246 += _243;
    _238.data[_246] = _245;
    _243++;
    if (_243 < _241)
    goto _jump976;
    _243 = 0;
    _244++;
    if (_244 < _240)
    goto _jump976;
    _244 = 0;
    _245++;
    if (_245 < _239)
    goto _jump976;
    // End body of loop
    _237 = _238;
    goto _jump977;
    _jump972:;
    _a3_int64_t _247;
    // Computing bound for j
    _247.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for k
    int64_t _248 = 59;
    _247.d1 = _248;
    if (_248 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing bound for l
    int64_t _249 = 928;
    int64_t _250 = -_249;
    _247.d2 = _250;
    if (_250 > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing total size of heap memory to allocate
    int64_t _251 = 1;
    _251 *= h.d0;
    _251 *= _248;
    _251 *= _250;
    _251 *= sizeof(int64_t);
    _247.data = jpl_alloc(_251);
    int64_t _252 = 0; // l
    int64_t _253 = 0; // k
    int64_t _254 = 0; // j
    _jump981:; // Begin body of loop
    int64_t _255 = -_254;
    int64_t _256 = 0;
    _256 *= _247.d0;
    _256 += _254;
    _256 *= _247.d1;
    _256 += _253;
    _256 *= _247.d2;
    _256 += _252;
    _247.data[_256] = _255;
    _252++;
    if (_252 < _250)
    goto _jump981;
    _252 = 0;
    _253++;
    if (_253 < _248)
    goto _jump981;
    _253 = 0;
    _254++;
    if (_254 < h.d0)
    goto _jump981;
    // End body of loop
    _237 = _247;
    _jump977:;
    _233 = _237;
    goto _jump982;
    _jump969:;
    _a3_int64_t _257;
    // Computing bound for j
    int64_t _258;
    if (!f)
    goto _jump983;
    int64_t _259 = 798;
    _258 = _259;
    goto _jump984;
    _jump983:;
    _258 = h.d0;
    _jump984:;
    _257.d0 = _258;
    if (_258 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    // Computing bound for k
    _257.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump986;
    fail_assertion("non-positive loop bound");
    _jump986:;
    // Computing bound for l
    int64_t _260 = 908;
    _257.d2 = _260;
    if (_260 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _258;
    _261 *= h.d0;
    _261 *= _260;
    _261 *= sizeof(int64_t);
    _257.data = jpl_alloc(_261);
    int64_t _262 = 0; // l
    int64_t _263 = 0; // k
    int64_t _264 = 0; // j
    _jump988:; // Begin body of loop
    int64_t _265;
    if (!f)
    goto _jump989;
    if (_262 >= 0)
    goto _jump990;
    fail_assertion("negative array index");
    _jump990:;
    if (_262 < h.d0)
    goto _jump991;
    fail_assertion("index too large");
    _jump991:;
    int64_t _266 = 0;
    _266 *= h.d0;
    _266 += _262;
    int64_t _267 = h.data[_266];
    _265 = _267;
    goto _jump992;
    _jump989:;
    _265 = _264;
    _jump992:;
    int64_t _268 = 0;
    _268 *= _257.d0;
    _268 += _264;
    _268 *= _257.d1;
    _268 += _263;
    _268 *= _257.d2;
    _268 += _262;
    _257.data[_268] = _265;
    _262++;
    if (_262 < _260)
    goto _jump988;
    _262 = 0;
    _263++;
    if (_263 < h.d0)
    goto _jump988;
    _263 = 0;
    _264++;
    if (_264 < _258)
    goto _jump988;
    // End body of loop
    _233 = _257;
    _jump982:;
    _a3_int64_t _269;
    // Computing bound for j
    int64_t _270 = 532;
    _269.d0 = _270;
    if (_270 > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing bound for k
    int64_t _271 = g(h);
    _269.d1 = _271;
    if (_271 > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    // Computing bound for l
    int64_t _272 = 591;
    _269.d2 = _272;
    if (_272 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= _270;
    _273 *= _271;
    _273 *= _272;
    _273 *= sizeof(int64_t);
    _269.data = jpl_alloc(_273);
    int64_t _274 = 0; // l
    int64_t _275 = 0; // k
    int64_t _276 = 0; // j
    _jump996:; // Begin body of loop
    int64_t _277 = 0;
    _277 *= _269.d0;
    _277 += _276;
    _277 *= _269.d1;
    _277 += _275;
    _277 *= _269.d2;
    _277 += _274;
    _269.data[_277] = _274;
    _274++;
    if (_274 < _272)
    goto _jump996;
    _274 = 0;
    _275++;
    if (_275 < _271)
    goto _jump996;
    _275 = 0;
    _276++;
    if (_276 < _270)
    goto _jump996;
    // End body of loop
    int64_t _278;
    if (!b)
    goto _jump997;
    int64_t _279 = g(h);
    _278 = _279;
    goto _jump998;
    _jump997:;
    int64_t _280 = 766;
    _278 = _280;
    _jump998:;
    _a1_int64_t _281;
    _281.d0 = 2;
    _281.data = jpl_alloc(sizeof(int64_t) * 2);
    _281.data[0] = h.d0;
    _281.data[1] = h.d0;
    int64_t _282 = g(_281);
    int64_t _283 = 242;
    if (_278 >= 0)
    goto _jump999;
    fail_assertion("negative array index");
    _jump999:;
    if (_278 < _269.d0)
    goto _jump1000;
    fail_assertion("index too large");
    _jump1000:;
    if (_282 >= 0)
    goto _jump1001;
    fail_assertion("negative array index");
    _jump1001:;
    if (_282 < _269.d1)
    goto _jump1002;
    fail_assertion("index too large");
    _jump1002:;
    if (_283 >= 0)
    goto _jump1003;
    fail_assertion("negative array index");
    _jump1003:;
    if (_283 < _269.d2)
    goto _jump1004;
    fail_assertion("index too large");
    _jump1004:;
    int64_t _284 = 0;
    _284 *= _269.d0;
    _284 += _278;
    _284 *= _269.d1;
    _284 += _282;
    _284 *= _269.d2;
    _284 += _283;
    int64_t _285 = _269.data[_284];
    int64_t _286 = g(h);
    bool _289 = true;
    bool _288 = _289;
    if (0 == _289)
    goto _jump1005;
    _288 = f;
    _jump1005:;
    bool _287 = _288;
    if (0 == _288)
    goto _jump1006;
    _287 = b;
    _jump1006:;
    int64_t _290;
    if (!_287)
    goto _jump1007;
    _a1_int64_t _291;
    // Computing bound for j
    int64_t _292 = 676;
    int64_t _293 = 237;
    int64_t _294 = _292 * _293;
    _291.d0 = _294;
    if (_294 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing total size of heap memory to allocate
    int64_t _295 = 1;
    _295 *= _294;
    _295 *= sizeof(int64_t);
    _291.data = jpl_alloc(_295);
    int64_t _296 = 0; // j
    _jump1009:; // Begin body of loop
    int64_t _297;
    // Computing bound for k
    if (_296 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for l
    if (_296 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    _297 = 0;
    int64_t _298 = 0; // l
    int64_t _299 = 0; // k
    _jump1012:; // Begin body of loop
    _297 += _299;
    _298++;
    if (_298 < _296)
    goto _jump1012;
    _298 = 0;
    _299++;
    if (_299 < _296)
    goto _jump1012;
    // End body of loop
    int64_t _300 = 0;
    _300 *= _291.d0;
    _300 += _296;
    _291.data[_300] = _297;
    _296++;
    if (_296 < _294)
    goto _jump1009;
    // End body of loop
    int64_t _301 = g(_291);
    _290 = _301;
    goto _jump1013;
    _jump1007:;
    int64_t _302;
    // Computing bound for j
    if (h.d0 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    _302 = 0;
    int64_t _303 = 0; // j
    _jump1015:; // Begin body of loop
    _302 += _303;
    _303++;
    if (_303 < h.d0)
    goto _jump1015;
    // End body of loop
    int64_t _304 = _302 + h.d0;
    int64_t _305 = -_304;
    _290 = _305;
    _jump1013:;
    if (_285 >= 0)
    goto _jump1016;
    fail_assertion("negative array index");
    _jump1016:;
    if (_285 < _233.d0)
    goto _jump1017;
    fail_assertion("index too large");
    _jump1017:;
    if (_286 >= 0)
    goto _jump1018;
    fail_assertion("negative array index");
    _jump1018:;
    if (_286 < _233.d1)
    goto _jump1019;
    fail_assertion("index too large");
    _jump1019:;
    if (_290 >= 0)
    goto _jump1020;
    fail_assertion("negative array index");
    _jump1020:;
    if (_290 < _233.d2)
    goto _jump1021;
    fail_assertion("index too large");
    _jump1021:;
    int64_t _306 = 0;
    _306 *= _233.d0;
    _306 += _285;
    _306 *= _233.d1;
    _306 += _286;
    _306 *= _233.d2;
    _306 += _290;
    int64_t _307 = _233.data[_306];
    _133.d1 = _307;
    if (_307 > 0) 
    goto _jump1022;
    fail_assertion("non-positive loop bound");
    _jump1022:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= _142;
    _308 *= _307;
    _308 *= sizeof(_a1_int64_t);
    _133.data = jpl_alloc(_308);
    int64_t _309 = 0; // k
    int64_t _310 = 0; // j
    _jump1023:; // Begin body of loop
    int64_t _311 = 917;
    int64_t _312 = g(h);
    int64_t _313 = _311 - _312;
    int64_t _314 = -_313;
    int64_t _315 = _310 % _310;
    _a1_int64_t _316;
    _316.d0 = 3;
    _316.data = jpl_alloc(sizeof(int64_t) * 3);
    _316.data[0] = _310;
    _316.data[1] = _314;
    _316.data[2] = _315;
    int64_t _317 = 0;
    _317 *= _133.d0;
    _317 += _310;
    _317 *= _133.d1;
    _317 += _309;
    _133.data[_317] = _316;
    _309++;
    if (_309 < _307)
    goto _jump1023;
    _309 = 0;
    _310++;
    if (_310 < _142)
    goto _jump1023;
    // End body of loop
    _31 = _133;
    _jump901:;
    int64_t _318 = 299;
    double _319;
    // Computing bound for n
    int64_t _320;
    // Computing bound for n
    if (_318 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    _320 = 0;
    int64_t _321 = 0; // n
    _jump1025:; // Begin body of loop
    bool _322;
    if (!a)
    goto _jump1026;
    _322 = f;
    goto _jump1027;
    _jump1026:;
    _322 = b;
    _jump1027:;
    int64_t _323;
    if (!_322)
    goto _jump1028;
    int64_t _324;
    // Computing bound for o
    int64_t _325 = 682;
    if (_325 > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    // Computing bound for p
    if (_31.d0 > 0) 
    goto _jump1030;
    fail_assertion("non-positive loop bound");
    _jump1030:;
    // Computing bound for q
    if (h.d0 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    _324 = 0;
    int64_t _326 = 0; // q
    int64_t _327 = 0; // p
    int64_t _328 = 0; // o
    _jump1032:; // Begin body of loop
    _324 += _318;
    _326++;
    if (_326 < h.d0)
    goto _jump1032;
    _326 = 0;
    _327++;
    if (_327 < _31.d0)
    goto _jump1032;
    _327 = 0;
    _328++;
    if (_328 < _325)
    goto _jump1032;
    // End body of loop
    _323 = _324;
    goto _jump1033;
    _jump1028:;
    _323 = _31.d1;
    _jump1033:;
    _320 += _323;
    _321++;
    if (_321 < _318)
    goto _jump1025;
    // End body of loop
    if (_320 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing bound for o
    if (h.d0 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    // Computing bound for p
    if (_31.d0 > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    _319 = 0;
    int64_t _329 = 0; // p
    int64_t _330 = 0; // o
    int64_t _331 = 0; // n
    _jump1037:; // Begin body of loop
    double _332;
    // Computing bound for q
    if (_329 > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    _332 = 0;
    int64_t _333 = 0; // q
    _jump1039:; // Begin body of loop
    _332 += d;
    _333++;
    if (_333 < _329)
    goto _jump1039;
    // End body of loop
    _319 += _332;
    _329++;
    if (_329 < _31.d0)
    goto _jump1037;
    _329 = 0;
    _330++;
    if (_330 < h.d0)
    goto _jump1037;
    _330 = 0;
    _331++;
    if (_331 < _320)
    goto _jump1037;
    // End body of loop
    double _334;
    // Computing bound for n
    if (h.d0 > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    _334 = 0;
    int64_t _335 = 0; // n
    _jump1041:; // Begin body of loop
    double _336 = 23.0;
    _334 += _336;
    _335++;
    if (_335 < h.d0)
    goto _jump1041;
    // End body of loop
    double _337 = -_334;
    double _338;
    // Computing bound for n
    if (_318 > 0) 
    goto _jump1042;
    fail_assertion("non-positive loop bound");
    _jump1042:;
    // Computing bound for o
    if (_31.d1 > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing bound for p
    if (_31.d1 > 0) 
    goto _jump1044;
    fail_assertion("non-positive loop bound");
    _jump1044:;
    _338 = 0;
    int64_t _339 = 0; // p
    int64_t _340 = 0; // o
    int64_t _341 = 0; // n
    _jump1045:; // Begin body of loop
    _338 += d;
    _339++;
    if (_339 < _31.d1)
    goto _jump1045;
    _339 = 0;
    _340++;
    if (_340 < _31.d1)
    goto _jump1045;
    _340 = 0;
    _341++;
    if (_341 < _318)
    goto _jump1045;
    // End body of loop
    double _342 = fmod(_338, d);
    double _343;
    // Computing bound for n
    if (h.d0 > 0) 
    goto _jump1046;
    fail_assertion("non-positive loop bound");
    _jump1046:;
    _343 = 0;
    int64_t _344 = 0; // n
    _jump1047:; // Begin body of loop
    double _345;
    // Computing bound for o
    if (_31.d1 > 0) 
    goto _jump1048;
    fail_assertion("non-positive loop bound");
    _jump1048:;
    // Computing bound for p
    if (_31.d0 > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing bound for q
    if (h.d0 > 0) 
    goto _jump1050;
    fail_assertion("non-positive loop bound");
    _jump1050:;
    _345 = 0;
    int64_t _346 = 0; // q
    int64_t _347 = 0; // p
    int64_t _348 = 0; // o
    _jump1051:; // Begin body of loop
    double _349 = 37.0;
    _345 += _349;
    _346++;
    if (_346 < h.d0)
    goto _jump1051;
    _346 = 0;
    _347++;
    if (_347 < _31.d0)
    goto _jump1051;
    _347 = 0;
    _348++;
    if (_348 < _31.d1)
    goto _jump1051;
    // End body of loop
    _343 += _345;
    _344++;
    if (_344 < h.d0)
    goto _jump1047;
    // End body of loop
    rgba _350 = { _337, _342, _343, d };
    double _351 = _350.b;
    bool _352 = _319 != _351;
    bool _353 = !_352;
    bool _354;
    if (!_353)
    goto _jump1052;
    _354 = a;
    goto _jump1053;
    _jump1052:;
    _354 = a;
    _jump1053:;
    if (0 != _354)
    goto _jump1054;
    fail_assertion("n");
    _jump1054:;
    int64_t _355 = 36;
    int64_t _356;
    // Computing bound for n
    if (_318 > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    // Computing bound for o
    int64_t _357 = 621;
    if (_357 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    _356 = 0;
    int64_t _358 = 0; // o
    int64_t _359 = 0; // n
    _jump1057:; // Begin body of loop
    int64_t _360 = -_31.d1;
    _356 += _360;
    _358++;
    if (_358 < _357)
    goto _jump1057;
    _358 = 0;
    _359++;
    if (_359 < _318)
    goto _jump1057;
    // End body of loop
    int64_t _361 = _355 / _356;
    int64_t _362 = -_361;
    bool _363 = _362 < h.d0;
    bool _364 = true;
    bool _365 = !_364;
    bool _366 = _363 != _365;
    bool _367 = !_366;
    if (0 != _367)
    goto _jump1058;
    fail_assertion("n");
    _jump1058:;
    int64_t _368 = 434;
    return _368;
    _a1_bool _369;
    // Computing bound for n
    int64_t _370 = g(h);
    _369.d0 = _370;
    if (_370 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing total size of heap memory to allocate
    int64_t _371 = 1;
    _371 *= _370;
    _371 *= sizeof(bool);
    _369.data = jpl_alloc(_371);
    int64_t _372 = 0; // n
    _jump1060:; // Begin body of loop
    bool _373 = false;
    int64_t _374 = 0;
    _374 *= _369.d0;
    _374 += _372;
    _369.data[_374] = _373;
    _372++;
    if (_372 < _370)
    goto _jump1060;
    // End body of loop
    return _369.d0;
}

_a1_bool h(_a2_double i, _a1_int64_t l, _a1__a3_bool n) {
    _a2__a2__a1_bool _0;
    // Computing bound for p
    bool _1 = !f;
    int64_t _2;
    if (!_1)
    goto _jump1061;
    _2 = i.d0;
    goto _jump1062;
    _jump1061:;
    bool _3;
    if (!b)
    goto _jump1063;
    _3 = a;
    goto _jump1064;
    _jump1063:;
    _3 = a;
    _jump1064:;
    int64_t _4;
    if (!_3)
    goto _jump1065;
    _4 = i.d1;
    goto _jump1066;
    _jump1065:;
    _4 = i.d0;
    _jump1066:;
    _2 = _4;
    _jump1062:;
    int64_t _5;
    // Computing bound for p
    if (i.d0 > 0) 
    goto _jump1067;
    fail_assertion("non-positive loop bound");
    _jump1067:;
    _5 = 0;
    int64_t _6 = 0; // p
    _jump1068:; // Begin body of loop
    int64_t _7 = -n.d0;
    _5 += _7;
    _6++;
    if (_6 < i.d0)
    goto _jump1068;
    // End body of loop
    int64_t _8 = _5 + n.d0;
    int64_t _9 = _2 + _8;
    _0.d0 = _9;
    if (_9 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing bound for q
    _0.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _9;
    _10 *= l.d0;
    _10 *= sizeof(_a2__a1_bool);
    _0.data = jpl_alloc(_10);
    int64_t _11 = 0; // q
    int64_t _12 = 0; // p
    _jump1071:; // Begin body of loop
    _a2__a1_bool _13;
    // Computing bound for r
    _13.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    // Computing bound for s
    int64_t _14 = 662;
    _13.d1 = _14;
    if (_14 > 0) 
    goto _jump1073;
    fail_assertion("non-positive loop bound");
    _jump1073:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= i.d1;
    _15 *= _14;
    _15 *= sizeof(_a1_bool);
    _13.data = jpl_alloc(_15);
    int64_t _16 = 0; // s
    int64_t _17 = 0; // r
    _jump1074:; // Begin body of loop
    _a3__a2_double _18;
    // Computing bound for t
    _18.d0 = _17;
    if (_17 > 0) 
    goto _jump1075;
    fail_assertion("non-positive loop bound");
    _jump1075:;
    // Computing bound for u
    int64_t _19 = 797;
    _18.d1 = _19;
    if (_19 > 0) 
    goto _jump1076;
    fail_assertion("non-positive loop bound");
    _jump1076:;
    // Computing bound for v
    _18.d2 = _17;
    if (_17 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _17;
    _20 *= _19;
    _20 *= _17;
    _20 *= sizeof(_a2_double);
    _18.data = jpl_alloc(_20);
    int64_t _21 = 0; // v
    int64_t _22 = 0; // u
    int64_t _23 = 0; // t
    _jump1078:; // Begin body of loop
    int64_t _24 = 0;
    _24 *= _18.d0;
    _24 += _23;
    _24 *= _18.d1;
    _24 += _22;
    _24 *= _18.d2;
    _24 += _21;
    _18.data[_24] = i;
    _21++;
    if (_21 < _17)
    goto _jump1078;
    _21 = 0;
    _22++;
    if (_22 < _19)
    goto _jump1078;
    _22 = 0;
    _23++;
    if (_23 < _17)
    goto _jump1078;
    // End body of loop
    int64_t _25 = l.d0 / _16;
    if (n.d0 >= 0)
    goto _jump1079;
    fail_assertion("negative array index");
    _jump1079:;
    if (n.d0 < _18.d0)
    goto _jump1080;
    fail_assertion("index too large");
    _jump1080:;
    if (_25 >= 0)
    goto _jump1081;
    fail_assertion("negative array index");
    _jump1081:;
    if (_25 < _18.d1)
    goto _jump1082;
    fail_assertion("index too large");
    _jump1082:;
    if (_12 >= 0)
    goto _jump1083;
    fail_assertion("negative array index");
    _jump1083:;
    if (_12 < _18.d2)
    goto _jump1084;
    fail_assertion("index too large");
    _jump1084:;
    int64_t _26 = 0;
    _26 *= _18.d0;
    _26 += n.d0;
    _26 *= _18.d1;
    _26 += _25;
    _26 *= _18.d2;
    _26 += _12;
    _a2_double _27 = _18.data[_26];
    _a1_int64_t _28;
    // Computing bound for t
    _28.d0 = _12;
    if (_12 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _12;
    _29 *= sizeof(int64_t);
    _28.data = jpl_alloc(_29);
    int64_t _30 = 0; // t
    _jump1086:; // Begin body of loop
    int64_t _31 = 0;
    _31 *= _28.d0;
    _31 += _30;
    _28.data[_31] = n.d0;
    _30++;
    if (_30 < _12)
    goto _jump1086;
    // End body of loop
    _a1_bool _32 = h(_27, _28, n);
    int64_t _33 = 0;
    _33 *= _13.d0;
    _33 += _17;
    _33 *= _13.d1;
    _33 += _16;
    _13.data[_33] = _32;
    _16++;
    if (_16 < _14)
    goto _jump1074;
    _16 = 0;
    _17++;
    if (_17 < i.d1)
    goto _jump1074;
    // End body of loop
    int64_t _34 = 0;
    _34 *= _0.d0;
    _34 += _12;
    _34 *= _0.d1;
    _34 += _11;
    _0.data[_34] = _13;
    _11++;
    if (_11 < l.d0)
    goto _jump1071;
    _11 = 0;
    _12++;
    if (_12 < _9)
    goto _jump1071;
    // End body of loop
    int64_t _35;
    // Computing bound for p
    bool _36 = false;
    int64_t _37;
    if (!_36)
    goto _jump1087;
    _37 = n.d0;
    goto _jump1088;
    _jump1087:;
    _37 = i.d1;
    _jump1088:;
    if (_37 > 0) 
    goto _jump1089;
    fail_assertion("non-positive loop bound");
    _jump1089:;
    // Computing bound for q
    int64_t _38 = 732;
    if (_38 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for r
    if (n.d0 > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    _35 = 0;
    int64_t _39 = 0; // r
    int64_t _40 = 0; // q
    int64_t _41 = 0; // p
    _jump1092:; // Begin body of loop
    int64_t _42;
    if (!b)
    goto _jump1093;
    _42 = n.d0;
    goto _jump1094;
    _jump1093:;
    int64_t _43;
    // Computing bound for s
    if (_41 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing bound for t
    if (i.d0 > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    _43 = 0;
    int64_t _44 = 0; // t
    int64_t _45 = 0; // s
    _jump1097:; // Begin body of loop
    if (i.d1 >= 0)
    goto _jump1098;
    fail_assertion("negative array index");
    _jump1098:;
    if (i.d1 < l.d0)
    goto _jump1099;
    fail_assertion("index too large");
    _jump1099:;
    int64_t _46 = 0;
    _46 *= l.d0;
    _46 += i.d1;
    int64_t _47 = l.data[_46];
    _43 += _47;
    _44++;
    if (_44 < i.d0)
    goto _jump1097;
    _44 = 0;
    _45++;
    if (_45 < _41)
    goto _jump1097;
    // End body of loop
    _42 = _43;
    _jump1094:;
    _35 += _42;
    _39++;
    if (_39 < n.d0)
    goto _jump1092;
    _39 = 0;
    _40++;
    if (_40 < _38)
    goto _jump1092;
    _40 = 0;
    _41++;
    if (_41 < _37)
    goto _jump1092;
    // End body of loop
    int64_t _48 = -_35;
    int64_t _49;
    // Computing bound for p
    int64_t _50 = i.d0 - i.d0;
    _a2_int64_t _51;
    // Computing bound for p
    _51.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing bound for q
    _51.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= l.d0;
    _52 *= l.d0;
    _52 *= sizeof(int64_t);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // q
    int64_t _54 = 0; // p
    _jump1102:; // Begin body of loop
    int64_t _55;
    // Computing bound for r
    if (_53 > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    // Computing bound for s
    if (i.d0 > 0) 
    goto _jump1104;
    fail_assertion("non-positive loop bound");
    _jump1104:;
    // Computing bound for t
    if (i.d1 > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    _55 = 0;
    int64_t _56 = 0; // t
    int64_t _57 = 0; // s
    int64_t _58 = 0; // r
    _jump1106:; // Begin body of loop
    int64_t _59 = 771;
    _55 += _59;
    _56++;
    if (_56 < i.d1)
    goto _jump1106;
    _56 = 0;
    _57++;
    if (_57 < i.d0)
    goto _jump1106;
    _57 = 0;
    _58++;
    if (_58 < _53)
    goto _jump1106;
    // End body of loop
    int64_t _60 = 0;
    _60 *= _51.d0;
    _60 += _54;
    _60 *= _51.d1;
    _60 += _53;
    _51.data[_60] = _55;
    _53++;
    if (_53 < l.d0)
    goto _jump1102;
    _53 = 0;
    _54++;
    if (_54 < l.d0)
    goto _jump1102;
    // End body of loop
    int64_t _61;
    // Computing bound for p
    if (i.d0 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    // Computing bound for q
    if (l.d0 > 0) 
    goto _jump1108;
    fail_assertion("non-positive loop bound");
    _jump1108:;
    // Computing bound for r
    if (l.d0 > 0) 
    goto _jump1109;
    fail_assertion("non-positive loop bound");
    _jump1109:;
    _61 = 0;
    int64_t _62 = 0; // r
    int64_t _63 = 0; // q
    int64_t _64 = 0; // p
    _jump1110:; // Begin body of loop
    _61 += l.d0;
    _62++;
    if (_62 < l.d0)
    goto _jump1110;
    _62 = 0;
    _63++;
    if (_63 < l.d0)
    goto _jump1110;
    _63 = 0;
    _64++;
    if (_64 < i.d0)
    goto _jump1110;
    // End body of loop
    _a3_int64_t _65;
    // Computing bound for p
    _65.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for q
    _65.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing bound for r
    _65.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= i.d0;
    _66 *= i.d1;
    _66 *= i.d0;
    _66 *= sizeof(int64_t);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // r
    int64_t _68 = 0; // q
    int64_t _69 = 0; // p
    _jump1114:; // Begin body of loop
    int64_t _70 = 0;
    _70 *= _65.d0;
    _70 += _69;
    _70 *= _65.d1;
    _70 += _68;
    _70 *= _65.d2;
    _70 += _67;
    _65.data[_70] = _68;
    _67++;
    if (_67 < i.d0)
    goto _jump1114;
    _67 = 0;
    _68++;
    if (_68 < i.d1)
    goto _jump1114;
    _68 = 0;
    _69++;
    if (_69 < i.d0)
    goto _jump1114;
    // End body of loop
    int64_t _71 = 39;
    int64_t _72 = 587;
    if (_71 >= 0)
    goto _jump1115;
    fail_assertion("negative array index");
    _jump1115:;
    if (_71 < _65.d0)
    goto _jump1116;
    fail_assertion("index too large");
    _jump1116:;
    if (i.d0 >= 0)
    goto _jump1117;
    fail_assertion("negative array index");
    _jump1117:;
    if (i.d0 < _65.d1)
    goto _jump1118;
    fail_assertion("index too large");
    _jump1118:;
    if (_72 >= 0)
    goto _jump1119;
    fail_assertion("negative array index");
    _jump1119:;
    if (_72 < _65.d2)
    goto _jump1120;
    fail_assertion("index too large");
    _jump1120:;
    int64_t _73 = 0;
    _73 *= _65.d0;
    _73 += _71;
    _73 *= _65.d1;
    _73 += i.d0;
    _73 *= _65.d2;
    _73 += _72;
    int64_t _74 = _65.data[_73];
    if (_61 >= 0)
    goto _jump1121;
    fail_assertion("negative array index");
    _jump1121:;
    if (_61 < _51.d0)
    goto _jump1122;
    fail_assertion("index too large");
    _jump1122:;
    if (_74 >= 0)
    goto _jump1123;
    fail_assertion("negative array index");
    _jump1123:;
    if (_74 < _51.d1)
    goto _jump1124;
    fail_assertion("index too large");
    _jump1124:;
    int64_t _75 = 0;
    _75 *= _51.d0;
    _75 += _61;
    _75 *= _51.d1;
    _75 += _74;
    int64_t _76 = _51.data[_75];
    int64_t _77 = _50 + _76;
    if (_77 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    // Computing bound for q
    if (l.d0 > 0) 
    goto _jump1126;
    fail_assertion("non-positive loop bound");
    _jump1126:;
    // Computing bound for r
    int64_t _78 = 26;
    int64_t _79 = n.d0 % _78;
    if (_79 > 0) 
    goto _jump1127;
    fail_assertion("non-positive loop bound");
    _jump1127:;
    _49 = 0;
    int64_t _80 = 0; // r
    int64_t _81 = 0; // q
    int64_t _82 = 0; // p
    _jump1128:; // Begin body of loop
    _49 += l.d0;
    _80++;
    if (_80 < _79)
    goto _jump1128;
    _80 = 0;
    _81++;
    if (_81 < l.d0)
    goto _jump1128;
    _81 = 0;
    _82++;
    if (_82 < _77)
    goto _jump1128;
    // End body of loop
    if (_48 >= 0)
    goto _jump1129;
    fail_assertion("negative array index");
    _jump1129:;
    if (_48 < _0.d0)
    goto _jump1130;
    fail_assertion("index too large");
    _jump1130:;
    if (_49 >= 0)
    goto _jump1131;
    fail_assertion("negative array index");
    _jump1131:;
    if (_49 < _0.d1)
    goto _jump1132;
    fail_assertion("index too large");
    _jump1132:;
    int64_t _83 = 0;
    _83 *= _0.d0;
    _83 += _48;
    _83 *= _0.d1;
    _83 += _49;
    _a2__a1_bool _84 = _0.data[_83];
    _a2__a2__a1_int64_t _85;
    // Computing bound for p
    bool _86 = false;
    int64_t _87;
    if (!_86)
    goto _jump1133;
    _87 = i.d1;
    goto _jump1134;
    _jump1133:;
    _87 = i.d1;
    _jump1134:;
    _85.d0 = _87;
    if (_87 > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    // Computing bound for q
    int64_t _88 = -i.d0;
    _85.d1 = _88;
    if (_88 > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _87;
    _89 *= _88;
    _89 *= sizeof(_a2__a1_int64_t);
    _85.data = jpl_alloc(_89);
    int64_t _90 = 0; // q
    int64_t _91 = 0; // p
    _jump1137:; // Begin body of loop
    _a2__a1_int64_t _92;
    // Computing bound for r
    _92.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing bound for s
    _92.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1139;
    fail_assertion("non-positive loop bound");
    _jump1139:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= i.d0;
    _93 *= l.d0;
    _93 *= sizeof(_a1_int64_t);
    _92.data = jpl_alloc(_93);
    int64_t _94 = 0; // s
    int64_t _95 = 0; // r
    _jump1140:; // Begin body of loop
    int64_t _96 = 0;
    _96 *= _92.d0;
    _96 += _95;
    _96 *= _92.d1;
    _96 += _94;
    _92.data[_96] = l;
    _94++;
    if (_94 < l.d0)
    goto _jump1140;
    _94 = 0;
    _95++;
    if (_95 < i.d0)
    goto _jump1140;
    // End body of loop
    int64_t _97 = 0;
    _97 *= _85.d0;
    _97 += _91;
    _97 *= _85.d1;
    _97 += _90;
    _85.data[_97] = _92;
    _90++;
    if (_90 < _88)
    goto _jump1137;
    _90 = 0;
    _91++;
    if (_91 < _87)
    goto _jump1137;
    // End body of loop
    int64_t _98;
    // Computing bound for p
    int64_t _99;
    // Computing bound for p
    if (n.d0 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    // Computing bound for q
    if (i.d1 > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    _99 = 0;
    int64_t _100 = 0; // q
    int64_t _101 = 0; // p
    _jump1143:; // Begin body of loop
    _99 += i.d0;
    _100++;
    if (_100 < i.d1)
    goto _jump1143;
    _100 = 0;
    _101++;
    if (_101 < n.d0)
    goto _jump1143;
    // End body of loop
    if (_99 > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    _98 = 0;
    int64_t _102 = 0; // p
    _jump1145:; // Begin body of loop
    _98 += _102;
    _102++;
    if (_102 < _99)
    goto _jump1145;
    // End body of loop
    int64_t _103 = g(l);
    if (_98 >= 0)
    goto _jump1146;
    fail_assertion("negative array index");
    _jump1146:;
    if (_98 < _85.d0)
    goto _jump1147;
    fail_assertion("index too large");
    _jump1147:;
    if (_103 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (_103 < _85.d1)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    int64_t _104 = 0;
    _104 *= _85.d0;
    _104 += _98;
    _104 *= _85.d1;
    _104 += _103;
    _a2__a1_int64_t _105 = _85.data[_104];
    int64_t _106;
    // Computing bound for p
    bool _107 = b;
    if (0 == b)
    goto _jump1150;
    _107 = a;
    _jump1150:;
    int64_t _108;
    if (!_107)
    goto _jump1151;
    _108 = n.d0;
    goto _jump1152;
    _jump1151:;
    int64_t _109;
    // Computing bound for p
    if (l.d0 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    _109 = 0;
    int64_t _110 = 0; // p
    _jump1154:; // Begin body of loop
    _109 += i.d0;
    _110++;
    if (_110 < l.d0)
    goto _jump1154;
    // End body of loop
    _108 = _109;
    _jump1152:;
    if (_108 > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing bound for q
    int64_t _111 = 177;
    if (_111 > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    _106 = 0;
    int64_t _112 = 0; // q
    int64_t _113 = 0; // p
    _jump1157:; // Begin body of loop
    bool _114 = false;
    int64_t _115;
    if (!_114)
    goto _jump1158;
    _115 = n.d0;
    goto _jump1159;
    _jump1158:;
    _115 = _113;
    _jump1159:;
    int64_t _116 = -_112;
    int64_t _117 = _115 - _116;
    _106 += _117;
    _112++;
    if (_112 < _111)
    goto _jump1157;
    _112 = 0;
    _113++;
    if (_113 < _108)
    goto _jump1157;
    // End body of loop
    _a1_int64_t _118;
    // Computing bound for p
    _118.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= n.d0;
    _119 *= sizeof(int64_t);
    _118.data = jpl_alloc(_119);
    int64_t _120 = 0; // p
    _jump1161:; // Begin body of loop
    int64_t _121 = 0;
    _121 *= _118.d0;
    _121 += _120;
    _118.data[_121] = n.d0;
    _120++;
    if (_120 < n.d0)
    goto _jump1161;
    // End body of loop
    int64_t _122 = g(_118);
    if (_106 >= 0)
    goto _jump1162;
    fail_assertion("negative array index");
    _jump1162:;
    if (_106 < _105.d0)
    goto _jump1163;
    fail_assertion("index too large");
    _jump1163:;
    if (_122 >= 0)
    goto _jump1164;
    fail_assertion("negative array index");
    _jump1164:;
    if (_122 < _105.d1)
    goto _jump1165;
    fail_assertion("index too large");
    _jump1165:;
    int64_t _123 = 0;
    _123 *= _105.d0;
    _123 += _106;
    _123 *= _105.d1;
    _123 += _122;
    _a1_int64_t _124 = _105.data[_123];
    int64_t _125 = g(_124);
    int64_t _126 = i.d0 * _125;
    bool _127 = f;
    if (0 == f)
    goto _jump1166;
    _127 = f;
    _jump1166:;
    int64_t _128;
    if (!_127)
    goto _jump1167;
    int64_t _129 = -i.d1;
    int64_t _130;
    // Computing bound for p
    if (n.d0 > 0) 
    goto _jump1168;
    fail_assertion("non-positive loop bound");
    _jump1168:;
    _130 = 0;
    int64_t _131 = 0; // p
    _jump1169:; // Begin body of loop
    _a1_int64_t _132;
    _132.d0 = 1;
    _132.data = jpl_alloc(sizeof(int64_t) * 1);
    _132.data[0] = l.d0;
    int64_t _133 = g(_132);
    _130 += _133;
    _131++;
    if (_131 < n.d0)
    goto _jump1169;
    // End body of loop
    int64_t _134 = _129 % _130;
    _128 = _134;
    goto _jump1170;
    _jump1167:;
    int64_t _135;
    // Computing bound for p
    if (i.d1 > 0) 
    goto _jump1171;
    fail_assertion("non-positive loop bound");
    _jump1171:;
    _135 = 0;
    int64_t _136 = 0; // p
    _jump1172:; // Begin body of loop
    _a2_int64_t _137;
    // Computing bound for q
    _137.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1173;
    fail_assertion("non-positive loop bound");
    _jump1173:;
    // Computing bound for r
    int64_t _138 = i.d0 * i.d0;
    _137.d1 = _138;
    if (_138 > 0) 
    goto _jump1174;
    fail_assertion("non-positive loop bound");
    _jump1174:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= i.d0;
    _139 *= _138;
    _139 *= sizeof(int64_t);
    _137.data = jpl_alloc(_139);
    int64_t _140 = 0; // r
    int64_t _141 = 0; // q
    _jump1175:; // Begin body of loop
    int64_t _142;
    // Computing bound for s
    if (l.d0 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing bound for t
    if (l.d0 > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    _142 = 0;
    int64_t _143 = 0; // t
    int64_t _144 = 0; // s
    _jump1178:; // Begin body of loop
    _142 += _141;
    _143++;
    if (_143 < l.d0)
    goto _jump1178;
    _143 = 0;
    _144++;
    if (_144 < l.d0)
    goto _jump1178;
    // End body of loop
    int64_t _145 = 0;
    _145 *= _137.d0;
    _145 += _141;
    _145 *= _137.d1;
    _145 += _140;
    _137.data[_145] = _142;
    _140++;
    if (_140 < _138)
    goto _jump1175;
    _140 = 0;
    _141++;
    if (_141 < i.d0)
    goto _jump1175;
    // End body of loop
    int64_t _146;
    if (!a)
    goto _jump1179;
    _146 = _136;
    goto _jump1180;
    _jump1179:;
    _146 = i.d0;
    _jump1180:;
    int64_t _147 = -_146;
    if (_147 >= 0)
    goto _jump1181;
    fail_assertion("negative array index");
    _jump1181:;
    if (_147 < _137.d0)
    goto _jump1182;
    fail_assertion("index too large");
    _jump1182:;
    if (i.d1 >= 0)
    goto _jump1183;
    fail_assertion("negative array index");
    _jump1183:;
    if (i.d1 < _137.d1)
    goto _jump1184;
    fail_assertion("index too large");
    _jump1184:;
    int64_t _148 = 0;
    _148 *= _137.d0;
    _148 += _147;
    _148 *= _137.d1;
    _148 += i.d1;
    int64_t _149 = _137.data[_148];
    _135 += _149;
    _136++;
    if (_136 < i.d1)
    goto _jump1172;
    // End body of loop
    _128 = _135;
    _jump1170:;
    int64_t _150 = -_128;
    if (_126 >= 0)
    goto _jump1185;
    fail_assertion("negative array index");
    _jump1185:;
    if (_126 < _84.d0)
    goto _jump1186;
    fail_assertion("index too large");
    _jump1186:;
    if (_150 >= 0)
    goto _jump1187;
    fail_assertion("negative array index");
    _jump1187:;
    if (_150 < _84.d1)
    goto _jump1188;
    fail_assertion("index too large");
    _jump1188:;
    int64_t _151 = 0;
    _151 *= _84.d0;
    _151 += _126;
    _151 *= _84.d1;
    _151 += _150;
    _a1_bool _152 = _84.data[_151];
    return _152;
    bool _153 = !a;
    _a2_double _154;
    if (!_153)
    goto _jump1189;
    _154 = i;
    goto _jump1190;
    _jump1189:;
    bool _156 = false;
    bool _155 = _156;
    if (0 == _156)
    goto _jump1191;
    bool _157 = true;
    _155 = _157;
    _jump1191:;
    double _158;
    if (!_155)
    goto _jump1192;
    double _159 = 44.0;
    _158 = _159;
    goto _jump1193;
    _jump1192:;
    if (i.d0 >= 0)
    goto _jump1194;
    fail_assertion("negative array index");
    _jump1194:;
    if (i.d0 < i.d0)
    goto _jump1195;
    fail_assertion("index too large");
    _jump1195:;
    if (i.d0 >= 0)
    goto _jump1196;
    fail_assertion("negative array index");
    _jump1196:;
    if (i.d0 < i.d1)
    goto _jump1197;
    fail_assertion("index too large");
    _jump1197:;
    int64_t _160 = 0;
    _160 *= i.d0;
    _160 += i.d0;
    _160 *= i.d1;
    _160 += i.d0;
    double _161 = i.data[_160];
    _158 = _161;
    _jump1193:;
    double _162 = -d;
    double _163 = d + _162;
    bool _164 = _158 >= _163;
    _a3_bool _165;
    if (!_164)
    goto _jump1198;
    _a3_bool _166;
    if (!a)
    goto _jump1199;
    _a3_bool _167;
    // Computing bound for p
    int64_t _168 = 354;
    _167.d0 = _168;
    if (_168 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing bound for q
    int64_t _169 = g(l);
    _167.d1 = _169;
    if (_169 > 0) 
    goto _jump1201;
    fail_assertion("non-positive loop bound");
    _jump1201:;
    // Computing bound for r
    int64_t _170;
    // Computing bound for p
    if (i.d0 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for q
    if (l.d0 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    _170 = 0;
    int64_t _171 = 0; // q
    int64_t _172 = 0; // p
    _jump1204:; // Begin body of loop
    _170 += i.d1;
    _171++;
    if (_171 < l.d0)
    goto _jump1204;
    _171 = 0;
    _172++;
    if (_172 < i.d0)
    goto _jump1204;
    // End body of loop
    _167.d2 = _170;
    if (_170 > 0) 
    goto _jump1205;
    fail_assertion("non-positive loop bound");
    _jump1205:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= _168;
    _173 *= _169;
    _173 *= _170;
    _173 *= sizeof(bool);
    _167.data = jpl_alloc(_173);
    int64_t _174 = 0; // r
    int64_t _175 = 0; // q
    int64_t _176 = 0; // p
    _jump1206:; // Begin body of loop
    int64_t _177 = 0;
    _177 *= _167.d0;
    _177 += _176;
    _177 *= _167.d1;
    _177 += _175;
    _177 *= _167.d2;
    _177 += _174;
    _167.data[_177] = f;
    _174++;
    if (_174 < _170)
    goto _jump1206;
    _174 = 0;
    _175++;
    if (_175 < _169)
    goto _jump1206;
    _175 = 0;
    _176++;
    if (_176 < _168)
    goto _jump1206;
    // End body of loop
    _166 = _167;
    goto _jump1207;
    _jump1199:;
    _a3_bool _178;
    if (!f)
    goto _jump1208;
    _a3_bool _179;
    // Computing bound for p
    _179.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing bound for q
    _179.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1210;
    fail_assertion("non-positive loop bound");
    _jump1210:;
    // Computing bound for r
    _179.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= i.d1;
    _180 *= i.d1;
    _180 *= i.d0;
    _180 *= sizeof(bool);
    _179.data = jpl_alloc(_180);
    int64_t _181 = 0; // r
    int64_t _182 = 0; // q
    int64_t _183 = 0; // p
    _jump1212:; // Begin body of loop
    int64_t _184 = 0;
    _184 *= _179.d0;
    _184 += _183;
    _184 *= _179.d1;
    _184 += _182;
    _184 *= _179.d2;
    _184 += _181;
    _179.data[_184] = f;
    _181++;
    if (_181 < i.d0)
    goto _jump1212;
    _181 = 0;
    _182++;
    if (_182 < i.d1)
    goto _jump1212;
    _182 = 0;
    _183++;
    if (_183 < i.d1)
    goto _jump1212;
    // End body of loop
    _178 = _179;
    goto _jump1213;
    _jump1208:;
    _a3_bool _185;
    // Computing bound for p
    _185.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1214;
    fail_assertion("non-positive loop bound");
    _jump1214:;
    // Computing bound for q
    _185.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    // Computing bound for r
    _185.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= i.d1;
    _186 *= i.d0;
    _186 *= i.d0;
    _186 *= sizeof(bool);
    _185.data = jpl_alloc(_186);
    int64_t _187 = 0; // r
    int64_t _188 = 0; // q
    int64_t _189 = 0; // p
    _jump1217:; // Begin body of loop
    int64_t _190 = 0;
    _190 *= _185.d0;
    _190 += _189;
    _190 *= _185.d1;
    _190 += _188;
    _190 *= _185.d2;
    _190 += _187;
    _185.data[_190] = f;
    _187++;
    if (_187 < i.d0)
    goto _jump1217;
    _187 = 0;
    _188++;
    if (_188 < i.d0)
    goto _jump1217;
    _188 = 0;
    _189++;
    if (_189 < i.d1)
    goto _jump1217;
    // End body of loop
    _178 = _185;
    _jump1213:;
    _166 = _178;
    _jump1207:;
    _165 = _166;
    goto _jump1218;
    _jump1198:;
    _a3_bool _191;
    // Computing bound for p
    _191.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing bound for q
    int64_t _192 = i.d1 / l.d0;
    int64_t _193 = _192 + i.d1;
    _191.d1 = _193;
    if (_193 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing bound for r
    int64_t _194 = 94;
    int64_t _195 = l.d0 + _194;
    int64_t _196 = l.d0 % _195;
    _191.d2 = _196;
    if (_196 > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= l.d0;
    _197 *= _193;
    _197 *= _196;
    _197 *= sizeof(bool);
    _191.data = jpl_alloc(_197);
    int64_t _198 = 0; // r
    int64_t _199 = 0; // q
    int64_t _200 = 0; // p
    _jump1222:; // Begin body of loop
    int64_t _201 = 0;
    _201 *= _191.d0;
    _201 += _200;
    _201 *= _191.d1;
    _201 += _199;
    _201 *= _191.d2;
    _201 += _198;
    _191.data[_201] = a;
    _198++;
    if (_198 < _196)
    goto _jump1222;
    _198 = 0;
    _199++;
    if (_199 < _193)
    goto _jump1222;
    _199 = 0;
    _200++;
    if (_200 < l.d0)
    goto _jump1222;
    // End body of loop
    _165 = _191;
    _jump1218:;
    int64_t _202 = -i.d1;
    int64_t _203 = _202 / n.d0;
    int64_t _204 = g(l);
    int64_t _205 = _203 * _204;
    _a2__a2_int64_t _206;
    // Computing bound for p
    int64_t _207 = 421;
    _206.d0 = _207;
    if (_207 > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing bound for q
    _206.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1224;
    fail_assertion("non-positive loop bound");
    _jump1224:;
    // Computing total size of heap memory to allocate
    int64_t _208 = 1;
    _208 *= _207;
    _208 *= i.d0;
    _208 *= sizeof(_a2_int64_t);
    _206.data = jpl_alloc(_208);
    int64_t _209 = 0; // q
    int64_t _210 = 0; // p
    _jump1225:; // Begin body of loop
    _a2_int64_t _211;
    // Computing bound for r
    _211.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for s
    _211.d1 = _209;
    if (_209 > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= l.d0;
    _212 *= _209;
    _212 *= sizeof(int64_t);
    _211.data = jpl_alloc(_212);
    int64_t _213 = 0; // s
    int64_t _214 = 0; // r
    _jump1228:; // Begin body of loop
    int64_t _215 = 0;
    _215 *= _211.d0;
    _215 += _214;
    _215 *= _211.d1;
    _215 += _213;
    _211.data[_215] = i.d1;
    _213++;
    if (_213 < _209)
    goto _jump1228;
    _213 = 0;
    _214++;
    if (_214 < l.d0)
    goto _jump1228;
    // End body of loop
    int64_t _216 = 0;
    _216 *= _206.d0;
    _216 += _210;
    _216 *= _206.d1;
    _216 += _209;
    _206.data[_216] = _211;
    _209++;
    if (_209 < i.d0)
    goto _jump1225;
    _209 = 0;
    _210++;
    if (_210 < _207)
    goto _jump1225;
    // End body of loop
    _a1_int64_t _217;
    // Computing bound for p
    _217.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    // Computing total size of heap memory to allocate
    int64_t _218 = 1;
    _218 *= n.d0;
    _218 *= sizeof(int64_t);
    _217.data = jpl_alloc(_218);
    int64_t _219 = 0; // p
    _jump1230:; // Begin body of loop
    int64_t _220 = 0;
    _220 *= _217.d0;
    _220 += _219;
    _217.data[_220] = i.d1;
    _219++;
    if (_219 < n.d0)
    goto _jump1230;
    // End body of loop
    int64_t _221 = 571;
    if (_221 >= 0)
    goto _jump1231;
    fail_assertion("negative array index");
    _jump1231:;
    if (_221 < _217.d0)
    goto _jump1232;
    fail_assertion("index too large");
    _jump1232:;
    int64_t _222 = 0;
    _222 *= _217.d0;
    _222 += _221;
    int64_t _223 = _217.data[_222];
    int64_t _224 = 93;
    int64_t _225 = -_224;
    int64_t _226 = -_225;
    if (_223 >= 0)
    goto _jump1233;
    fail_assertion("negative array index");
    _jump1233:;
    if (_223 < _206.d0)
    goto _jump1234;
    fail_assertion("index too large");
    _jump1234:;
    if (_226 >= 0)
    goto _jump1235;
    fail_assertion("negative array index");
    _jump1235:;
    if (_226 < _206.d1)
    goto _jump1236;
    fail_assertion("index too large");
    _jump1236:;
    int64_t _227 = 0;
    _227 *= _206.d0;
    _227 += _223;
    _227 *= _206.d1;
    _227 += _226;
    _a2_int64_t _228 = _206.data[_227];
    _a1_int64_t _229;
    // Computing bound for p
    _229.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= i.d0;
    _230 *= sizeof(int64_t);
    _229.data = jpl_alloc(_230);
    int64_t _231 = 0; // p
    _jump1238:; // Begin body of loop
    int64_t _232 = 0;
    _232 *= _229.d0;
    _232 += _231;
    _229.data[_232] = l.d0;
    _231++;
    if (_231 < i.d0)
    goto _jump1238;
    // End body of loop
    int64_t _233 = g(_229);
    int64_t _234 = -_233;
    int64_t _235 = n.d0 * n.d0;
    bool _236 = n.d0 == _235;
    int64_t _237;
    if (!_236)
    goto _jump1239;
    int64_t _238 = 58;
    _a1_int64_t _239;
    _239.d0 = 2;
    _239.data = jpl_alloc(sizeof(int64_t) * 2);
    _239.data[0] = _238;
    _239.data[1] = n.d0;
    int64_t _240 = g(_239);
    _237 = _240;
    goto _jump1240;
    _jump1239:;
    _237 = i.d0;
    _jump1240:;
    if (_234 >= 0)
    goto _jump1241;
    fail_assertion("negative array index");
    _jump1241:;
    if (_234 < _228.d0)
    goto _jump1242;
    fail_assertion("index too large");
    _jump1242:;
    if (_237 >= 0)
    goto _jump1243;
    fail_assertion("negative array index");
    _jump1243:;
    if (_237 < _228.d1)
    goto _jump1244;
    fail_assertion("index too large");
    _jump1244:;
    int64_t _241 = 0;
    _241 *= _228.d0;
    _241 += _234;
    _241 *= _228.d1;
    _241 += _237;
    int64_t _242 = _228.data[_241];
    if (_205 >= 0)
    goto _jump1245;
    fail_assertion("negative array index");
    _jump1245:;
    if (_205 < _165.d0)
    goto _jump1246;
    fail_assertion("index too large");
    _jump1246:;
    if (i.d0 >= 0)
    goto _jump1247;
    fail_assertion("negative array index");
    _jump1247:;
    if (i.d0 < _165.d1)
    goto _jump1248;
    fail_assertion("index too large");
    _jump1248:;
    if (_242 >= 0)
    goto _jump1249;
    fail_assertion("negative array index");
    _jump1249:;
    if (_242 < _165.d2)
    goto _jump1250;
    fail_assertion("index too large");
    _jump1250:;
    int64_t _243 = 0;
    _243 *= _165.d0;
    _243 += _205;
    _243 *= _165.d1;
    _243 += i.d0;
    _243 *= _165.d2;
    _243 += _242;
    bool _244 = _165.data[_243];
    _a2_double _245;
    if (!_244)
    goto _jump1251;
    _245 = i;
    goto _jump1252;
    _jump1251:;
    bool _247 = false;
    int64_t _248;
    if (!_247)
    goto _jump1253;
    int64_t _249 = 636;
    _248 = _249;
    goto _jump1254;
    _jump1253:;
    int64_t _250 = -i.d0;
    _248 = _250;
    _jump1254:;
    int64_t _251 = g(l);
    int64_t _252 = -_251;
    bool _253 = _248 > _252;
    bool _246 = _253;
    if (0 != _253)
    goto _jump1255;
    bool _254 = false;
    _246 = _254;
    _jump1255:;
    _a2_double _255;
    if (!_246)
    goto _jump1256;
    _a2_double _256;
    // Computing bound for p
    int64_t _257 = 914;
    _256.d0 = _257;
    if (_257 > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    // Computing bound for q
    int64_t _258;
    // Computing bound for p
    int64_t _259 = g(l);
    if (_259 >= 0)
    goto _jump1258;
    fail_assertion("negative array index");
    _jump1258:;
    if (_259 < l.d0)
    goto _jump1259;
    fail_assertion("index too large");
    _jump1259:;
    int64_t _260 = 0;
    _260 *= l.d0;
    _260 += _259;
    int64_t _261 = l.data[_260];
    if (_261 > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    _258 = 0;
    int64_t _262 = 0; // p
    _jump1261:; // Begin body of loop
    _258 += i.d1;
    _262++;
    if (_262 < _261)
    goto _jump1261;
    // End body of loop
    _256.d1 = _258;
    if (_258 > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _257;
    _263 *= _258;
    _263 *= sizeof(double);
    _256.data = jpl_alloc(_263);
    int64_t _264 = 0; // q
    int64_t _265 = 0; // p
    _jump1263:; // Begin body of loop
    double _266;
    if (!f)
    goto _jump1264;
    double _267 = 0.0;
    _266 = _267;
    goto _jump1265;
    _jump1264:;
    double _268;
    // Computing bound for r
    int64_t _269 = 277;
    if (_269 > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    _268 = 0;
    int64_t _270 = 0; // r
    _jump1267:; // Begin body of loop
    _268 += d;
    _270++;
    if (_270 < _269)
    goto _jump1267;
    // End body of loop
    _266 = _268;
    _jump1265:;
    int64_t _271 = 0;
    _271 *= _256.d0;
    _271 += _265;
    _271 *= _256.d1;
    _271 += _264;
    _256.data[_271] = _266;
    _264++;
    if (_264 < _258)
    goto _jump1263;
    _264 = 0;
    _265++;
    if (_265 < _257)
    goto _jump1263;
    // End body of loop
    _255 = _256;
    goto _jump1268;
    _jump1256:;
    _255 = i;
    _jump1268:;
    _245 = _255;
    _jump1252:;
    _154 = _245;
    _jump1190:;
    bool _272 = false;
    if (0 != _272)
    goto _jump1269;
    fail_assertion("s");
    _jump1269:;
    bool _273 = false;
    _a1_int64_t _274;
    if (!_273)
    goto _jump1270;
    _274 = l;
    goto _jump1271;
    _jump1270:;
    _274 = l;
    _jump1271:;
    int64_t _275 = g(_274);
    if (_275 >= 0)
    goto _jump1272;
    fail_assertion("negative array index");
    _jump1272:;
    if (_275 < i.d0)
    goto _jump1273;
    fail_assertion("index too large");
    _jump1273:;
    if (n.d0 >= 0)
    goto _jump1274;
    fail_assertion("negative array index");
    _jump1274:;
    if (n.d0 < i.d1)
    goto _jump1275;
    fail_assertion("index too large");
    _jump1275:;
    int64_t _276 = 0;
    _276 *= i.d0;
    _276 += _275;
    _276 *= i.d1;
    _276 += n.d0;
    double _277 = i.data[_276];
    double _278;
    // Computing bound for t
    int64_t _279 = 804;
    int64_t _280 = l.d0 * _279;
    if (_280 > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    _278 = 0;
    int64_t _281 = 0; // t
    _jump1277:; // Begin body of loop
    _278 += d;
    _281++;
    if (_281 < _280)
    goto _jump1277;
    // End body of loop
    double _282 = 18.0;
    double _283 = -_282;
    _a1_double _284;
    _284.d0 = 3;
    _284.data = jpl_alloc(sizeof(double) * 3);
    _284.data[0] = d;
    _284.data[1] = d;
    _284.data[2] = d;
    if (_154.d0 >= 0)
    goto _jump1278;
    fail_assertion("negative array index");
    _jump1278:;
    if (_154.d0 < _284.d0)
    goto _jump1279;
    fail_assertion("index too large");
    _jump1279:;
    int64_t _285 = 0;
    _285 *= _284.d0;
    _285 += _154.d0;
    double _286 = _284.data[_285];
    double _287 = _283 - _286;
    rgba _288 = { _277, _278, _287, d };
    rgba _289;
    if (!a)
    goto _jump1280;
    double _290;
    if (!b)
    goto _jump1281;
    _290 = d;
    goto _jump1282;
    _jump1281:;
    double _291 = 79.0;
    _290 = _291;
    _jump1282:;
    double _292 = d / d;
    double _293 = _290 * _292;
    double _294 = 18.0;
    double _295 = d * _294;
    rgba _296 = { d, _293, d, _295 };
    _289 = _296;
    goto _jump1283;
    _jump1280:;
    double _297 = -d;
    bool _298 = f;
    if (0 != f)
    goto _jump1284;
    _298 = b;
    _jump1284:;
    double _299;
    if (!_298)
    goto _jump1285;
    _299 = d;
    goto _jump1286;
    _jump1285:;
    double _300 = 20.0;
    _299 = _300;
    _jump1286:;
    double _301 = 35.0;
    rgba _302 = { _297, _299, _301, d };
    _289 = _302;
    _jump1283:;
    _a1_rgba _303;
    _303.d0 = 2;
    _303.data = jpl_alloc(sizeof(rgba) * 2);
    _303.data[0] = _288;
    _303.data[1] = _289;
    if (_154.d1 >= 0)
    goto _jump1287;
    fail_assertion("negative array index");
    _jump1287:;
    if (_154.d1 < _303.d0)
    goto _jump1288;
    fail_assertion("index too large");
    _jump1288:;
    int64_t _304 = 0;
    _304 *= _303.d0;
    _304 += _154.d1;
    rgba _305 = _303.data[_304];
    double _306 = _305.g;
    bool _307 = !a;
    if (0 != _307)
    goto _jump1289;
    fail_assertion("u");
    _jump1289:;
    _a3_bool _309;
    // Computing bound for u
    int64_t _310 = 208;
    _309.d0 = _310;
    if (_310 > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing bound for v
    int64_t _311 = _154.d0 % i.d0;
    _309.d1 = _311;
    if (_311 > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    // Computing bound for w
    int64_t _312;
    // Computing bound for u
    int64_t _313 = 20;
    if (_313 > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing bound for v
    if (l.d0 > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing bound for w
    if (n.d0 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    _312 = 0;
    int64_t _314 = 0; // w
    int64_t _315 = 0; // v
    int64_t _316 = 0; // u
    _jump1295:; // Begin body of loop
    int64_t _317;
    if (!a)
    goto _jump1296;
    _317 = _154.d1;
    goto _jump1297;
    _jump1296:;
    int64_t _318 = 391;
    _317 = _318;
    _jump1297:;
    _312 += _317;
    _314++;
    if (_314 < n.d0)
    goto _jump1295;
    _314 = 0;
    _315++;
    if (_315 < l.d0)
    goto _jump1295;
    _315 = 0;
    _316++;
    if (_316 < _313)
    goto _jump1295;
    // End body of loop
    _309.d2 = _312;
    if (_312 > 0) 
    goto _jump1298;
    fail_assertion("non-positive loop bound");
    _jump1298:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= _310;
    _319 *= _311;
    _319 *= _312;
    _319 *= sizeof(bool);
    _309.data = jpl_alloc(_319);
    int64_t _320 = 0; // w
    int64_t _321 = 0; // v
    int64_t _322 = 0; // u
    _jump1299:; // Begin body of loop
    int64_t _323 = 0;
    _323 *= _309.d0;
    _323 += _322;
    _323 *= _309.d1;
    _323 += _321;
    _323 *= _309.d2;
    _323 += _320;
    _309.data[_323] = b;
    _320++;
    if (_320 < _312)
    goto _jump1299;
    _320 = 0;
    _321++;
    if (_321 < _311)
    goto _jump1299;
    _321 = 0;
    _322++;
    if (_322 < _310)
    goto _jump1299;
    // End body of loop
    _a1_int64_t _324;
    if (!a)
    goto _jump1300;
    _324 = l;
    goto _jump1301;
    _jump1300:;
    _324 = l;
    _jump1301:;
    int64_t _325 = g(_324);
    int64_t _326 = -_325;
    int64_t _327 = -_154.d0;
    int64_t _328 = -_327;
    if (n.d0 >= 0)
    goto _jump1302;
    fail_assertion("negative array index");
    _jump1302:;
    if (n.d0 < _309.d0)
    goto _jump1303;
    fail_assertion("index too large");
    _jump1303:;
    if (_326 >= 0)
    goto _jump1304;
    fail_assertion("negative array index");
    _jump1304:;
    if (_326 < _309.d1)
    goto _jump1305;
    fail_assertion("index too large");
    _jump1305:;
    if (_328 >= 0)
    goto _jump1306;
    fail_assertion("negative array index");
    _jump1306:;
    if (_328 < _309.d2)
    goto _jump1307;
    fail_assertion("index too large");
    _jump1307:;
    int64_t _329 = 0;
    _329 *= _309.d0;
    _329 += n.d0;
    _329 *= _309.d1;
    _329 += _326;
    _329 *= _309.d2;
    _329 += _328;
    bool _330 = _309.data[_329];
    bool _331;
    if (!_330)
    goto _jump1308;
    _331 = a;
    goto _jump1309;
    _jump1308:;
    bool _332 = i.d1 > _154.d0;
    _331 = _332;
    _jump1309:;
    bool _308 = _331;
    if (0 != _331)
    goto _jump1310;
    double _334 = 72.0;
    double _335;
    // Computing bound for u
    if (n.d0 > 0) 
    goto _jump1311;
    fail_assertion("non-positive loop bound");
    _jump1311:;
    // Computing bound for v
    int64_t _336 = 993;
    if (_336 > 0) 
    goto _jump1312;
    fail_assertion("non-positive loop bound");
    _jump1312:;
    _335 = 0;
    int64_t _337 = 0; // v
    int64_t _338 = 0; // u
    _jump1313:; // Begin body of loop
    double _339 = 71.0;
    _335 += _339;
    _337++;
    if (_337 < _336)
    goto _jump1313;
    _337 = 0;
    _338++;
    if (_338 < n.d0)
    goto _jump1313;
    // End body of loop
    bool _340 = _334 != _335;
    bool _341 = !_340;
    bool _333 = _341;
    if (0 != _341)
    goto _jump1314;
    _333 = b;
    _jump1314:;
    bool _342 = !_333;
    _308 = _342;
    _jump1310:;
    _a1_bool _343;
    _343.d0 = 3;
    _343.data = jpl_alloc(sizeof(bool) * 3);
    _343.data[0] = b;
    _343.data[1] = b;
    _343.data[2] = _308;
    return _343;
}

_a1__a1_void_t m() {
    _a2__a2_int64_t _0;
    // Computing bound for n
    int64_t _2 = 680;
    if (_2 >= 0)
    goto _jump1607;
    fail_assertion("negative array index");
    _jump1607:;
    if (_2 < i.d0)
    goto _jump1608;
    fail_assertion("index too large");
    _jump1608:;
    int64_t _3 = 0;
    _3 *= i.d0;
    _3 += _2;
    bool _4 = i.data[_3];
    bool _1 = _4;
    if (0 == _4)
    goto _jump1609;
    _1 = f;
    _jump1609:;
    bool _5;
    if (!_1)
    goto _jump1610;
    bool _6 = false;
    _5 = _6;
    goto _jump1611;
    _jump1610:;
    _5 = f;
    _jump1611:;
    int64_t _7;
    if (!_5)
    goto _jump1612;
    int64_t _8;
    // Computing bound for n
    if (l > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for o
    int64_t _9 = 170;
    if (_9 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    _8 = 0;
    int64_t _10 = 0; // o
    int64_t _11 = 0; // n
    _jump1615:; // Begin body of loop
    int64_t _12;
    // Computing bound for p
    if (j > 0) 
    goto _jump1616;
    fail_assertion("non-positive loop bound");
    _jump1616:;
    _12 = 0;
    int64_t _13 = 0; // p
    _jump1617:; // Begin body of loop
    _12 += l;
    _13++;
    if (_13 < j)
    goto _jump1617;
    // End body of loop
    int64_t _14 = j * _12;
    _8 += _14;
    _10++;
    if (_10 < _9)
    goto _jump1615;
    _10 = 0;
    _11++;
    if (_11 < l)
    goto _jump1615;
    // End body of loop
    int64_t _15 = -l;
    int64_t _16 = _8 - _15;
    _7 = _16;
    goto _jump1618;
    _jump1612:;
    _7 = l;
    _jump1618:;
    _0.d0 = _7;
    if (_7 > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    // Computing bound for o
    int64_t _17;
    // Computing bound for n
    _a2_int64_t _18;
    // Computing bound for n
    int64_t _19;
    // Computing bound for n
    if (l > 0) 
    goto _jump1620;
    fail_assertion("non-positive loop bound");
    _jump1620:;
    _19 = 0;
    int64_t _20 = 0; // n
    _jump1621:; // Begin body of loop
    _19 += _20;
    _20++;
    if (_20 < l)
    goto _jump1621;
    // End body of loop
    int64_t _21 = 899;
    int64_t _22 = _19 + _21;
    _18.d0 = _22;
    if (_22 > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    // Computing bound for o
    _a1_int64_t _23;
    // Computing bound for n
    _23.d0 = l;
    if (l > 0) 
    goto _jump1623;
    fail_assertion("non-positive loop bound");
    _jump1623:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= l;
    _24 *= sizeof(int64_t);
    _23.data = jpl_alloc(_24);
    int64_t _25 = 0; // n
    _jump1624:; // Begin body of loop
    int64_t _26 = 851;
    int64_t _27 = 0;
    _27 *= _23.d0;
    _27 += _25;
    _23.data[_27] = _26;
    _25++;
    if (_25 < l)
    goto _jump1624;
    // End body of loop
    int64_t _28 = g(_23);
    _18.d1 = _28;
    if (_28 > 0) 
    goto _jump1625;
    fail_assertion("non-positive loop bound");
    _jump1625:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _22;
    _29 *= _28;
    _29 *= sizeof(int64_t);
    _18.data = jpl_alloc(_29);
    int64_t _30 = 0; // o
    int64_t _31 = 0; // n
    _jump1626:; // Begin body of loop
    _a1_int64_t _32;
    // Computing bound for p
    _32.d0 = _31;
    if (_31 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= _31;
    _33 *= sizeof(int64_t);
    _32.data = jpl_alloc(_33);
    int64_t _34 = 0; // p
    _jump1628:; // Begin body of loop
    int64_t _35 = 0;
    _35 *= _32.d0;
    _35 += _34;
    _32.data[_35] = _30;
    _34++;
    if (_34 < _31)
    goto _jump1628;
    // End body of loop
    int64_t _36 = g(_32);
    int64_t _37 = 0;
    _37 *= _18.d0;
    _37 += _31;
    _37 *= _18.d1;
    _37 += _30;
    _18.data[_37] = _36;
    _30++;
    if (_30 < _28)
    goto _jump1626;
    _30 = 0;
    _31++;
    if (_31 < _22)
    goto _jump1626;
    // End body of loop
    int64_t _38;
    // Computing bound for n
    int64_t _39;
    if (!b)
    goto _jump1629;
    _39 = j;
    goto _jump1630;
    _jump1629:;
    int64_t _40 = 478;
    int64_t _41 = _40 * j;
    _39 = _41;
    _jump1630:;
    if (_39 > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing bound for o
    int64_t _42 = 848;
    int64_t _43 = _42 % j;
    int64_t _44 = l + _43;
    if (_44 > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    // Computing bound for p
    int64_t _45 = 133;
    if (_45 > 0) 
    goto _jump1633;
    fail_assertion("non-positive loop bound");
    _jump1633:;
    _38 = 0;
    int64_t _46 = 0; // p
    int64_t _47 = 0; // o
    int64_t _48 = 0; // n
    _jump1634:; // Begin body of loop
    _38 += l;
    _46++;
    if (_46 < _45)
    goto _jump1634;
    _46 = 0;
    _47++;
    if (_47 < _44)
    goto _jump1634;
    _47 = 0;
    _48++;
    if (_48 < _39)
    goto _jump1634;
    // End body of loop
    if (_38 >= 0)
    goto _jump1635;
    fail_assertion("negative array index");
    _jump1635:;
    if (_38 < _18.d0)
    goto _jump1636;
    fail_assertion("index too large");
    _jump1636:;
    if (j >= 0)
    goto _jump1637;
    fail_assertion("negative array index");
    _jump1637:;
    if (j < _18.d1)
    goto _jump1638;
    fail_assertion("index too large");
    _jump1638:;
    int64_t _49 = 0;
    _49 *= _18.d0;
    _49 += _38;
    _49 *= _18.d1;
    _49 += j;
    int64_t _50 = _18.data[_49];
    if (_50 > 0) 
    goto _jump1639;
    fail_assertion("non-positive loop bound");
    _jump1639:;
    // Computing bound for o
    double _52 = 37.0;
    double _53 = 1.0;
    bool _54 = _52 > _53;
    bool _51 = _54;
    if (0 != _54)
    goto _jump1640;
    _51 = b;
    _jump1640:;
    bool _55 = !_51;
    int64_t _56;
    if (!_55)
    goto _jump1641;
    int64_t _57 = 547;
    int64_t _58 = -_57;
    _56 = _58;
    goto _jump1642;
    _jump1641:;
    int64_t _59 = 817;
    _56 = _59;
    _jump1642:;
    if (_56 > 0) 
    goto _jump1643;
    fail_assertion("non-positive loop bound");
    _jump1643:;
    // Computing bound for p
    double _60 = 68.0;
    double _61;
    if (!a)
    goto _jump1644;
    _61 = d;
    goto _jump1645;
    _jump1644:;
    double _62 = 78.0;
    _61 = _62;
    _jump1645:;
    bool _63 = _60 == _61;
    int64_t _64;
    if (!_63)
    goto _jump1646;
    _64 = l;
    goto _jump1647;
    _jump1646:;
    int64_t _65 = 77;
    _a1_int64_t _66;
    _66.d0 = 2;
    _66.data = jpl_alloc(sizeof(int64_t) * 2);
    _66.data[0] = j;
    _66.data[1] = _65;
    int64_t _67 = g(_66);
    _64 = _67;
    _jump1647:;
    int64_t _68 = j + l;
    _a1_int64_t _69;
    _69.d0 = 1;
    _69.data = jpl_alloc(sizeof(int64_t) * 1);
    _69.data[0] = _68;
    int64_t _70 = g(_69);
    int64_t _71 = _64 % _70;
    if (_71 > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    _17 = 0;
    int64_t _72 = 0; // p
    int64_t _73 = 0; // o
    int64_t _74 = 0; // n
    _jump1649:; // Begin body of loop
    int64_t _75 = 268;
    _17 += _75;
    _72++;
    if (_72 < _71)
    goto _jump1649;
    _72 = 0;
    _73++;
    if (_73 < _56)
    goto _jump1649;
    _73 = 0;
    _74++;
    if (_74 < _50)
    goto _jump1649;
    // End body of loop
    _0.d1 = _17;
    if (_17 > 0) 
    goto _jump1650;
    fail_assertion("non-positive loop bound");
    _jump1650:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _7;
    _76 *= _17;
    _76 *= sizeof(_a2_int64_t);
    _0.data = jpl_alloc(_76);
    int64_t _77 = 0; // o
    int64_t _78 = 0; // n
    _jump1651:; // Begin body of loop
    bool _79 = !a;
    _a2_int64_t _80;
    if (!_79)
    goto _jump1652;
    _a3__a2_int64_t _81;
    // Computing bound for p
    _81.d0 = l;
    if (l > 0) 
    goto _jump1653;
    fail_assertion("non-positive loop bound");
    _jump1653:;
    // Computing bound for q
    _81.d1 = _78;
    if (_78 > 0) 
    goto _jump1654;
    fail_assertion("non-positive loop bound");
    _jump1654:;
    // Computing bound for r
    int64_t _82 = 593;
    _81.d2 = _82;
    if (_82 > 0) 
    goto _jump1655;
    fail_assertion("non-positive loop bound");
    _jump1655:;
    // Computing total size of heap memory to allocate
    int64_t _83 = 1;
    _83 *= l;
    _83 *= _78;
    _83 *= _82;
    _83 *= sizeof(_a2_int64_t);
    _81.data = jpl_alloc(_83);
    int64_t _84 = 0; // r
    int64_t _85 = 0; // q
    int64_t _86 = 0; // p
    _jump1656:; // Begin body of loop
    _a2_int64_t _87;
    // Computing bound for s
    _87.d0 = _77;
    if (_77 > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    // Computing bound for t
    int64_t _88 = -_86;
    _87.d1 = _88;
    if (_88 > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _77;
    _89 *= _88;
    _89 *= sizeof(int64_t);
    _87.data = jpl_alloc(_89);
    int64_t _90 = 0; // t
    int64_t _91 = 0; // s
    _jump1659:; // Begin body of loop
    int64_t _92 = -_78;
    int64_t _93 = 0;
    _93 *= _87.d0;
    _93 += _91;
    _93 *= _87.d1;
    _93 += _90;
    _87.data[_93] = _92;
    _90++;
    if (_90 < _88)
    goto _jump1659;
    _90 = 0;
    _91++;
    if (_91 < _77)
    goto _jump1659;
    // End body of loop
    int64_t _94 = 0;
    _94 *= _81.d0;
    _94 += _86;
    _94 *= _81.d1;
    _94 += _85;
    _94 *= _81.d2;
    _94 += _84;
    _81.data[_94] = _87;
    _84++;
    if (_84 < _82)
    goto _jump1656;
    _84 = 0;
    _85++;
    if (_85 < _78)
    goto _jump1656;
    _85 = 0;
    _86++;
    if (_86 < l)
    goto _jump1656;
    // End body of loop
    _a1_int64_t _95;
    // Computing bound for p
    _95.d0 = l;
    if (l > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= l;
    _96 *= sizeof(int64_t);
    _95.data = jpl_alloc(_96);
    int64_t _97 = 0; // p
    _jump1661:; // Begin body of loop
    int64_t _98;
    // Computing bound for q
    if (_78 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    _98 = 0;
    int64_t _99 = 0; // q
    _jump1663:; // Begin body of loop
    _98 += j;
    _99++;
    if (_99 < _78)
    goto _jump1663;
    // End body of loop
    int64_t _100 = 0;
    _100 *= _95.d0;
    _100 += _97;
    _95.data[_100] = _98;
    _97++;
    if (_97 < l)
    goto _jump1661;
    // End body of loop
    int64_t _101 = g(_95);
    int64_t _102 = 880;
    if (_101 >= 0)
    goto _jump1664;
    fail_assertion("negative array index");
    _jump1664:;
    if (_101 < _81.d0)
    goto _jump1665;
    fail_assertion("index too large");
    _jump1665:;
    if (_102 >= 0)
    goto _jump1666;
    fail_assertion("negative array index");
    _jump1666:;
    if (_102 < _81.d1)
    goto _jump1667;
    fail_assertion("index too large");
    _jump1667:;
    if (l >= 0)
    goto _jump1668;
    fail_assertion("negative array index");
    _jump1668:;
    if (l < _81.d2)
    goto _jump1669;
    fail_assertion("index too large");
    _jump1669:;
    int64_t _103 = 0;
    _103 *= _81.d0;
    _103 += _101;
    _103 *= _81.d1;
    _103 += _102;
    _103 *= _81.d2;
    _103 += l;
    _a2_int64_t _104 = _81.data[_103];
    _80 = _104;
    goto _jump1670;
    _jump1652:;
    bool _105 = true;
    bool _106 = !_105;
    bool _107;
    if (!_106)
    goto _jump1671;
    _107 = a;
    goto _jump1672;
    _jump1671:;
    bool _108 = b;
    if (0 == b)
    goto _jump1673;
    bool _109 = false;
    _108 = _109;
    _jump1673:;
    _107 = _108;
    _jump1672:;
    _a2_int64_t _110;
    if (!_107)
    goto _jump1674;
    bool _111 = true;
    _a2_int64_t _112;
    if (!_111)
    goto _jump1675;
    _a2_int64_t _113;
    // Computing bound for p
    _113.d0 = _78;
    if (_78 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing bound for q
    _113.d1 = l;
    if (l > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= _78;
    _114 *= l;
    _114 *= sizeof(int64_t);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // q
    int64_t _116 = 0; // p
    _jump1678:; // Begin body of loop
    int64_t _117 = 0;
    _117 *= _113.d0;
    _117 += _116;
    _117 *= _113.d1;
    _117 += _115;
    _113.data[_117] = _78;
    _115++;
    if (_115 < l)
    goto _jump1678;
    _115 = 0;
    _116++;
    if (_116 < _78)
    goto _jump1678;
    // End body of loop
    _112 = _113;
    goto _jump1679;
    _jump1675:;
    _a2_int64_t _118;
    // Computing bound for p
    int64_t _119 = -j;
    _118.d0 = _119;
    if (_119 > 0) 
    goto _jump1680;
    fail_assertion("non-positive loop bound");
    _jump1680:;
    // Computing bound for q
    int64_t _120;
    if (!a)
    goto _jump1681;
    _120 = l;
    goto _jump1682;
    _jump1681:;
    int64_t _121 = 296;
    _120 = _121;
    _jump1682:;
    _118.d1 = _120;
    if (_120 > 0) 
    goto _jump1683;
    fail_assertion("non-positive loop bound");
    _jump1683:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _119;
    _122 *= _120;
    _122 *= sizeof(int64_t);
    _118.data = jpl_alloc(_122);
    int64_t _123 = 0; // q
    int64_t _124 = 0; // p
    _jump1684:; // Begin body of loop
    int64_t _125 = 0;
    _125 *= _118.d0;
    _125 += _124;
    _125 *= _118.d1;
    _125 += _123;
    _118.data[_125] = l;
    _123++;
    if (_123 < _120)
    goto _jump1684;
    _123 = 0;
    _124++;
    if (_124 < _119)
    goto _jump1684;
    // End body of loop
    _112 = _118;
    _jump1679:;
    _110 = _112;
    goto _jump1685;
    _jump1674:;
    _a2__a2_int64_t _126;
    // Computing bound for p
    _126.d0 = j;
    if (j > 0) 
    goto _jump1686;
    fail_assertion("non-positive loop bound");
    _jump1686:;
    // Computing bound for q
    _126.d1 = j;
    if (j > 0) 
    goto _jump1687;
    fail_assertion("non-positive loop bound");
    _jump1687:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= j;
    _127 *= j;
    _127 *= sizeof(_a2_int64_t);
    _126.data = jpl_alloc(_127);
    int64_t _128 = 0; // q
    int64_t _129 = 0; // p
    _jump1688:; // Begin body of loop
    _a2_int64_t _130;
    // Computing bound for r
    _130.d0 = j;
    if (j > 0) 
    goto _jump1689;
    fail_assertion("non-positive loop bound");
    _jump1689:;
    // Computing bound for s
    _130.d1 = l;
    if (l > 0) 
    goto _jump1690;
    fail_assertion("non-positive loop bound");
    _jump1690:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= j;
    _131 *= l;
    _131 *= sizeof(int64_t);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // s
    int64_t _133 = 0; // r
    _jump1691:; // Begin body of loop
    int64_t _134 = 0;
    _134 *= _130.d0;
    _134 += _133;
    _134 *= _130.d1;
    _134 += _132;
    _130.data[_134] = _129;
    _132++;
    if (_132 < l)
    goto _jump1691;
    _132 = 0;
    _133++;
    if (_133 < j)
    goto _jump1691;
    // End body of loop
    int64_t _135 = 0;
    _135 *= _126.d0;
    _135 += _129;
    _135 *= _126.d1;
    _135 += _128;
    _126.data[_135] = _130;
    _128++;
    if (_128 < j)
    goto _jump1688;
    _128 = 0;
    _129++;
    if (_129 < j)
    goto _jump1688;
    // End body of loop
    int64_t _136 = 245;
    int64_t _137;
    if (!f)
    goto _jump1692;
    _137 = _77;
    goto _jump1693;
    _jump1692:;
    bool _138 = true;
    int64_t _139;
    if (!_138)
    goto _jump1694;
    _139 = _78;
    goto _jump1695;
    _jump1694:;
    _139 = _78;
    _jump1695:;
    _137 = _139;
    _jump1693:;
    if (_136 >= 0)
    goto _jump1696;
    fail_assertion("negative array index");
    _jump1696:;
    if (_136 < _126.d0)
    goto _jump1697;
    fail_assertion("index too large");
    _jump1697:;
    if (_137 >= 0)
    goto _jump1698;
    fail_assertion("negative array index");
    _jump1698:;
    if (_137 < _126.d1)
    goto _jump1699;
    fail_assertion("index too large");
    _jump1699:;
    int64_t _140 = 0;
    _140 *= _126.d0;
    _140 += _136;
    _140 *= _126.d1;
    _140 += _137;
    _a2_int64_t _141 = _126.data[_140];
    _110 = _141;
    _jump1685:;
    _80 = _110;
    _jump1670:;
    int64_t _142 = 0;
    _142 *= _0.d0;
    _142 += _78;
    _142 *= _0.d1;
    _142 += _77;
    _0.data[_142] = _80;
    _77++;
    if (_77 < _17)
    goto _jump1651;
    _77 = 0;
    _78++;
    if (_78 < _7)
    goto _jump1651;
    // End body of loop
    int64_t _143;
    // Computing bound for n
    _a1_int64_t _144;
    // Computing bound for n
    int64_t _145 = 637;
    int64_t _146 = 281;
    int64_t _147 = _145 * _146;
    _144.d0 = _147;
    if (_147 > 0) 
    goto _jump1700;
    fail_assertion("non-positive loop bound");
    _jump1700:;
    // Computing total size of heap memory to allocate
    int64_t _148 = 1;
    _148 *= _147;
    _148 *= sizeof(int64_t);
    _144.data = jpl_alloc(_148);
    int64_t _149 = 0; // n
    _jump1701:; // Begin body of loop
    int64_t _150 = 0;
    _150 *= _144.d0;
    _150 += _149;
    _144.data[_150] = l;
    _149++;
    if (_149 < _147)
    goto _jump1701;
    // End body of loop
    _a1__a1_int64_t _151;
    _151.d0 = 1;
    _151.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _151.data[0] = _144;
    if (j >= 0)
    goto _jump1702;
    fail_assertion("negative array index");
    _jump1702:;
    if (j < _151.d0)
    goto _jump1703;
    fail_assertion("index too large");
    _jump1703:;
    int64_t _152 = 0;
    _152 *= _151.d0;
    _152 += j;
    _a1_int64_t _153 = _151.data[_152];
    int64_t _154 = g(_153);
    if (_154 > 0) 
    goto _jump1704;
    fail_assertion("non-positive loop bound");
    _jump1704:;
    _143 = 0;
    int64_t _155 = 0; // n
    _jump1705:; // Begin body of loop
    int64_t _156;
    // Computing bound for o
    int64_t _157 = 225;
    if (_157 > 0) 
    goto _jump1706;
    fail_assertion("non-positive loop bound");
    _jump1706:;
    _156 = 0;
    int64_t _158 = 0; // o
    _jump1707:; // Begin body of loop
    int64_t _159;
    if (!f)
    goto _jump1708;
    int64_t _160 = j * j;
    if (_160 >= 0)
    goto _jump1709;
    fail_assertion("negative array index");
    _jump1709:;
    if (_160 < i.d0)
    goto _jump1710;
    fail_assertion("index too large");
    _jump1710:;
    int64_t _161 = 0;
    _161 *= i.d0;
    _161 += _160;
    bool _162 = i.data[_161];
    int64_t _163;
    if (!_162)
    goto _jump1711;
    _163 = l;
    goto _jump1712;
    _jump1711:;
    int64_t _164 = 40;
    int64_t _165 = _158 % j;
    int64_t _166 = _164 % _165;
    _163 = _166;
    _jump1712:;
    _159 = _163;
    goto _jump1713;
    _jump1708:;
    int64_t _167 = -_155;
    int64_t _168 = _167 / j;
    int64_t _169 = _168 % _158;
    _159 = _169;
    _jump1713:;
    _156 += _159;
    _158++;
    if (_158 < _157)
    goto _jump1707;
    // End body of loop
    _143 += _156;
    _155++;
    if (_155 < _154)
    goto _jump1705;
    // End body of loop
    bool _172 = false;
    bool _173 = !_172;
    bool _171 = _173;
    if (0 == _173)
    goto _jump1714;
    bool _174 = false;
    _171 = _174;
    _jump1714:;
    bool _175;
    if (!_171)
    goto _jump1715;
    _175 = f;
    goto _jump1716;
    _jump1715:;
    bool _176 = b;
    if (0 == b)
    goto _jump1717;
    bool _177 = true;
    bool _178 = !_177;
    _176 = _178;
    _jump1717:;
    _175 = _176;
    _jump1716:;
    bool _170 = _175;
    if (0 == _175)
    goto _jump1718;
    _170 = f;
    _jump1718:;
    _a1_int64_t _179;
    if (!_170)
    goto _jump1719;
    int64_t _180;
    if (!a)
    goto _jump1720;
    _180 = l;
    goto _jump1721;
    _jump1720:;
    _180 = j;
    _jump1721:;
    int64_t _181 = j - _180;
    _a1_int64_t _182;
    _182.d0 = 2;
    _182.data = jpl_alloc(sizeof(int64_t) * 2);
    _182.data[0] = _181;
    _182.data[1] = j;
    _179 = _182;
    goto _jump1722;
    _jump1719:;
    int64_t _183 = -l;
    _a1_int64_t _184;
    _184.d0 = 1;
    _184.data = jpl_alloc(sizeof(int64_t) * 1);
    _184.data[0] = _183;
    _a1_int64_t _185;
    // Computing bound for n
    int64_t _186 = 802;
    _185.d0 = _186;
    if (_186 > 0) 
    goto _jump1723;
    fail_assertion("non-positive loop bound");
    _jump1723:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= _186;
    _187 *= sizeof(int64_t);
    _185.data = jpl_alloc(_187);
    int64_t _188 = 0; // n
    _jump1724:; // Begin body of loop
    int64_t _189 = -j;
    int64_t _190 = 0;
    _190 *= _185.d0;
    _190 += _188;
    _185.data[_190] = _189;
    _188++;
    if (_188 < _186)
    goto _jump1724;
    // End body of loop
    _a1_int64_t _191;
    if (!f)
    goto _jump1725;
    _a1_int64_t _192;
    // Computing bound for n
    _192.d0 = j;
    if (j > 0) 
    goto _jump1726;
    fail_assertion("non-positive loop bound");
    _jump1726:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= j;
    _193 *= sizeof(int64_t);
    _192.data = jpl_alloc(_193);
    int64_t _194 = 0; // n
    _jump1727:; // Begin body of loop
    int64_t _195 = 0;
    _195 *= _192.d0;
    _195 += _194;
    _192.data[_195] = j;
    _194++;
    if (_194 < j)
    goto _jump1727;
    // End body of loop
    _191 = _192;
    goto _jump1728;
    _jump1725:;
    _a1_int64_t _196;
    // Computing bound for n
    int64_t _197 = 752;
    _196.d0 = _197;
    if (_197 > 0) 
    goto _jump1729;
    fail_assertion("non-positive loop bound");
    _jump1729:;
    // Computing total size of heap memory to allocate
    int64_t _198 = 1;
    _198 *= _197;
    _198 *= sizeof(int64_t);
    _196.data = jpl_alloc(_198);
    int64_t _199 = 0; // n
    _jump1730:; // Begin body of loop
    int64_t _200 = 0;
    _200 *= _196.d0;
    _200 += _199;
    _196.data[_200] = j;
    _199++;
    if (_199 < _197)
    goto _jump1730;
    // End body of loop
    _191 = _196;
    _jump1728:;
    _a1__a1_int64_t _201;
    _201.d0 = 3;
    _201.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _201.data[0] = _184;
    _201.data[1] = _185;
    _201.data[2] = _191;
    int64_t _202 = -l;
    int64_t _203;
    // Computing bound for n
    if (j > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    _203 = 0;
    int64_t _204 = 0; // n
    _jump1732:; // Begin body of loop
    _203 += _204;
    _204++;
    if (_204 < j)
    goto _jump1732;
    // End body of loop
    int64_t _205 = _202 / _203;
    int64_t _206 = _205 / l;
    if (_206 >= 0)
    goto _jump1733;
    fail_assertion("negative array index");
    _jump1733:;
    if (_206 < _201.d0)
    goto _jump1734;
    fail_assertion("index too large");
    _jump1734:;
    int64_t _207 = 0;
    _207 *= _201.d0;
    _207 += _206;
    _a1_int64_t _208 = _201.data[_207];
    _179 = _208;
    _jump1722:;
    int64_t _209 = g(_179);
    if (_143 >= 0)
    goto _jump1735;
    fail_assertion("negative array index");
    _jump1735:;
    if (_143 < _0.d0)
    goto _jump1736;
    fail_assertion("index too large");
    _jump1736:;
    if (_209 >= 0)
    goto _jump1737;
    fail_assertion("negative array index");
    _jump1737:;
    if (_209 < _0.d1)
    goto _jump1738;
    fail_assertion("index too large");
    _jump1738:;
    int64_t _210 = 0;
    _210 *= _0.d0;
    _210 += _143;
    _210 *= _0.d1;
    _210 += _209;
    _a2_int64_t _211 = _0.data[_210];
    bool _212 = true;
    _a1__a1_void_t _213;
    if (!_212)
    goto _jump1739;
    _a1__a1_void_t _214;
    // Computing bound for r
    _214.d0 = l;
    if (l > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing total size of heap memory to allocate
    int64_t _215 = 1;
    _215 *= l;
    _215 *= sizeof(_a1_void_t);
    _214.data = jpl_alloc(_215);
    int64_t _216 = 0; // r
    _jump1741:; // Begin body of loop
    _a1_void_t _217;
    // Computing bound for s
    _217.d0 = j;
    if (j > 0) 
    goto _jump1742;
    fail_assertion("non-positive loop bound");
    _jump1742:;
    // Computing total size of heap memory to allocate
    int64_t _218 = 1;
    _218 *= j;
    _218 *= sizeof(void_t);
    _217.data = jpl_alloc(_218);
    int64_t _219 = 0; // s
    _jump1743:; // Begin body of loop
    bool _220 = false;
    _a1__a1_void_t _221;
    if (!_220)
    goto _jump1744;
    _a1__a1_void_t _222 = m();
    _221 = _222;
    goto _jump1745;
    _jump1744:;
    _a1__a1_void_t _223 = m();
    _221 = _223;
    _jump1745:;
    int64_t _224 = -_211.d1;
    if (_224 >= 0)
    goto _jump1746;
    fail_assertion("negative array index");
    _jump1746:;
    if (_224 < _221.d0)
    goto _jump1747;
    fail_assertion("index too large");
    _jump1747:;
    int64_t _225 = 0;
    _225 *= _221.d0;
    _225 += _224;
    _a1_void_t _226 = _221.data[_225];
    if (_211.d1 >= 0)
    goto _jump1748;
    fail_assertion("negative array index");
    _jump1748:;
    if (_211.d1 < _226.d0)
    goto _jump1749;
    fail_assertion("index too large");
    _jump1749:;
    int64_t _227 = 0;
    _227 *= _226.d0;
    _227 += _211.d1;
    void_t _228 = _226.data[_227];
    int64_t _229 = 0;
    _229 *= _217.d0;
    _229 += _219;
    _217.data[_229] = _228;
    _219++;
    if (_219 < j)
    goto _jump1743;
    // End body of loop
    int64_t _230 = 0;
    _230 *= _214.d0;
    _230 += _216;
    _214.data[_230] = _217;
    _216++;
    if (_216 < l)
    goto _jump1741;
    // End body of loop
    _213 = _214;
    goto _jump1750;
    _jump1739:;
    _a1__a1_void_t _231 = m();
    _213 = _231;
    _jump1750:;
    return _213;
    _a1_int64_t _232;
    // Computing bound for r
    _232.d0 = l;
    if (l > 0) 
    goto _jump1751;
    fail_assertion("non-positive loop bound");
    _jump1751:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= l;
    _233 *= sizeof(int64_t);
    _232.data = jpl_alloc(_233);
    int64_t _234 = 0; // r
    _jump1752:; // Begin body of loop
    int64_t _235 = 0;
    _235 *= _232.d0;
    _235 += _234;
    _232.data[_235] = _211.d1;
    _234++;
    if (_234 < l)
    goto _jump1752;
    // End body of loop
    _a2_int64_t _236;
    if (!a)
    goto _jump1753;
    _a3_bool _237;
    if (!b)
    goto _jump1754;
    _a3_bool _238;
    // Computing bound for s
    _238.d0 = l;
    if (l > 0) 
    goto _jump1755;
    fail_assertion("non-positive loop bound");
    _jump1755:;
    // Computing bound for t
    _238.d1 = l;
    if (l > 0) 
    goto _jump1756;
    fail_assertion("non-positive loop bound");
    _jump1756:;
    // Computing bound for u
    int64_t _239 = 421;
    int64_t _240 = 617;
    _a1_int64_t _241;
    _241.d0 = 3;
    _241.data = jpl_alloc(sizeof(int64_t) * 3);
    _241.data[0] = l;
    _241.data[1] = _239;
    _241.data[2] = _240;
    int64_t _242 = g(_241);
    _238.d2 = _242;
    if (_242 > 0) 
    goto _jump1757;
    fail_assertion("non-positive loop bound");
    _jump1757:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= l;
    _243 *= l;
    _243 *= _242;
    _243 *= sizeof(bool);
    _238.data = jpl_alloc(_243);
    int64_t _244 = 0; // u
    int64_t _245 = 0; // t
    int64_t _246 = 0; // s
    _jump1758:; // Begin body of loop
    int64_t _247 = 0;
    _247 *= _238.d0;
    _247 += _246;
    _247 *= _238.d1;
    _247 += _245;
    _247 *= _238.d2;
    _247 += _244;
    _238.data[_247] = b;
    _244++;
    if (_244 < _242)
    goto _jump1758;
    _244 = 0;
    _245++;
    if (_245 < l)
    goto _jump1758;
    _245 = 0;
    _246++;
    if (_246 < l)
    goto _jump1758;
    // End body of loop
    _237 = _238;
    goto _jump1759;
    _jump1754:;
    _a3_bool _248;
    // Computing bound for s
    int64_t _249;
    // Computing bound for s
    if (_211.d0 > 0) 
    goto _jump1760;
    fail_assertion("non-positive loop bound");
    _jump1760:;
    // Computing bound for t
    int64_t _250;
    // Computing bound for s
    if (_211.d0 > 0) 
    goto _jump1761;
    fail_assertion("non-positive loop bound");
    _jump1761:;
    // Computing bound for t
    int64_t _251 = 489;
    if (_251 > 0) 
    goto _jump1762;
    fail_assertion("non-positive loop bound");
    _jump1762:;
    _250 = 0;
    int64_t _252 = 0; // t
    int64_t _253 = 0; // s
    _jump1763:; // Begin body of loop
    _250 += _211.d1;
    _252++;
    if (_252 < _251)
    goto _jump1763;
    _252 = 0;
    _253++;
    if (_253 < _211.d0)
    goto _jump1763;
    // End body of loop
    if (_250 > 0) 
    goto _jump1764;
    fail_assertion("non-positive loop bound");
    _jump1764:;
    // Computing bound for u
    int64_t _254 = 48;
    if (_254 > 0) 
    goto _jump1765;
    fail_assertion("non-positive loop bound");
    _jump1765:;
    _249 = 0;
    int64_t _255 = 0; // u
    int64_t _256 = 0; // t
    int64_t _257 = 0; // s
    _jump1766:; // Begin body of loop
    if (_256 >= 0)
    goto _jump1767;
    fail_assertion("negative array index");
    _jump1767:;
    if (_256 < _211.d0)
    goto _jump1768;
    fail_assertion("index too large");
    _jump1768:;
    if (_211.d1 >= 0)
    goto _jump1769;
    fail_assertion("negative array index");
    _jump1769:;
    if (_211.d1 < _211.d1)
    goto _jump1770;
    fail_assertion("index too large");
    _jump1770:;
    int64_t _258 = 0;
    _258 *= _211.d0;
    _258 += _256;
    _258 *= _211.d1;
    _258 += _211.d1;
    int64_t _259 = _211.data[_258];
    _249 += _259;
    _255++;
    if (_255 < _254)
    goto _jump1766;
    _255 = 0;
    _256++;
    if (_256 < _250)
    goto _jump1766;
    _256 = 0;
    _257++;
    if (_257 < _211.d0)
    goto _jump1766;
    // End body of loop
    _248.d0 = _249;
    if (_249 > 0) 
    goto _jump1771;
    fail_assertion("non-positive loop bound");
    _jump1771:;
    // Computing bound for t
    int64_t _260 = g(_232);
    _248.d1 = _260;
    if (_260 > 0) 
    goto _jump1772;
    fail_assertion("non-positive loop bound");
    _jump1772:;
    // Computing bound for u
    _248.d2 = l;
    if (l > 0) 
    goto _jump1773;
    fail_assertion("non-positive loop bound");
    _jump1773:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _249;
    _261 *= _260;
    _261 *= l;
    _261 *= sizeof(bool);
    _248.data = jpl_alloc(_261);
    int64_t _262 = 0; // u
    int64_t _263 = 0; // t
    int64_t _264 = 0; // s
    _jump1774:; // Begin body of loop
    bool _265;
    if (!a)
    goto _jump1775;
    _265 = a;
    goto _jump1776;
    _jump1775:;
    _265 = f;
    _jump1776:;
    bool _266 = _265 == b;
    int64_t _267 = 0;
    _267 *= _248.d0;
    _267 += _264;
    _267 *= _248.d1;
    _267 += _263;
    _267 *= _248.d2;
    _267 += _262;
    _248.data[_267] = _266;
    _262++;
    if (_262 < l)
    goto _jump1774;
    _262 = 0;
    _263++;
    if (_263 < _260)
    goto _jump1774;
    _263 = 0;
    _264++;
    if (_264 < _249)
    goto _jump1774;
    // End body of loop
    _237 = _248;
    _jump1759:;
    int64_t _268;
    if (!a)
    goto _jump1777;
    int64_t _269;
    // Computing bound for s
    if (_211.d1 > 0) 
    goto _jump1778;
    fail_assertion("non-positive loop bound");
    _jump1778:;
    // Computing bound for t
    if (_211.d1 > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    _269 = 0;
    int64_t _270 = 0; // t
    int64_t _271 = 0; // s
    _jump1780:; // Begin body of loop
    _269 += _211.d0;
    _270++;
    if (_270 < _211.d1)
    goto _jump1780;
    _270 = 0;
    _271++;
    if (_271 < _211.d1)
    goto _jump1780;
    // End body of loop
    _268 = _269;
    goto _jump1781;
    _jump1777:;
    _268 = l;
    _jump1781:;
    int64_t _272 = -_268;
    if (_211.d0 >= 0)
    goto _jump1782;
    fail_assertion("negative array index");
    _jump1782:;
    if (_211.d0 < _237.d0)
    goto _jump1783;
    fail_assertion("index too large");
    _jump1783:;
    if (l >= 0)
    goto _jump1784;
    fail_assertion("negative array index");
    _jump1784:;
    if (l < _237.d1)
    goto _jump1785;
    fail_assertion("index too large");
    _jump1785:;
    if (_272 >= 0)
    goto _jump1786;
    fail_assertion("negative array index");
    _jump1786:;
    if (_272 < _237.d2)
    goto _jump1787;
    fail_assertion("index too large");
    _jump1787:;
    int64_t _273 = 0;
    _273 *= _237.d0;
    _273 += _211.d0;
    _273 *= _237.d1;
    _273 += l;
    _273 *= _237.d2;
    _273 += _272;
    bool _274 = _237.data[_273];
    _a2_int64_t _275;
    if (!_274)
    goto _jump1788;
    bool _276 = _211.d1 > _211.d1;
    _a2_int64_t _277;
    if (!_276)
    goto _jump1789;
    _277 = _211;
    goto _jump1790;
    _jump1789:;
    _277 = _211;
    _jump1790:;
    _275 = _277;
    goto _jump1791;
    _jump1788:;
    _a1__a2__a2_int64_t _278;
    // Computing bound for s
    int64_t _279 = 477;
    int64_t _280 = -_211.d0;
    int64_t _281 = _279 + _280;
    _278.d0 = _281;
    if (_281 > 0) 
    goto _jump1792;
    fail_assertion("non-positive loop bound");
    _jump1792:;
    // Computing total size of heap memory to allocate
    int64_t _282 = 1;
    _282 *= _281;
    _282 *= sizeof(_a2__a2_int64_t);
    _278.data = jpl_alloc(_282);
    int64_t _283 = 0; // s
    _jump1793:; // Begin body of loop
    _a2__a2_int64_t _284;
    // Computing bound for t
    _284.d0 = _283;
    if (_283 > 0) 
    goto _jump1794;
    fail_assertion("non-positive loop bound");
    _jump1794:;
    // Computing bound for u
    _284.d1 = _211.d0;
    if (_211.d0 > 0) 
    goto _jump1795;
    fail_assertion("non-positive loop bound");
    _jump1795:;
    // Computing total size of heap memory to allocate
    int64_t _285 = 1;
    _285 *= _283;
    _285 *= _211.d0;
    _285 *= sizeof(_a2_int64_t);
    _284.data = jpl_alloc(_285);
    int64_t _286 = 0; // u
    int64_t _287 = 0; // t
    _jump1796:; // Begin body of loop
    int64_t _288 = 0;
    _288 *= _284.d0;
    _288 += _287;
    _288 *= _284.d1;
    _288 += _286;
    _284.data[_288] = _211;
    _286++;
    if (_286 < _211.d0)
    goto _jump1796;
    _286 = 0;
    _287++;
    if (_287 < _283)
    goto _jump1796;
    // End body of loop
    int64_t _289 = 0;
    _289 *= _278.d0;
    _289 += _283;
    _278.data[_289] = _284;
    _283++;
    if (_283 < _281)
    goto _jump1793;
    // End body of loop
    if (l >= 0)
    goto _jump1797;
    fail_assertion("negative array index");
    _jump1797:;
    if (l < _278.d0)
    goto _jump1798;
    fail_assertion("index too large");
    _jump1798:;
    int64_t _290 = 0;
    _290 *= _278.d0;
    _290 += l;
    _a2__a2_int64_t _291 = _278.data[_290];
    _a3_int64_t _292;
    // Computing bound for s
    int64_t _293;
    // Computing bound for s
    if (_211.d0 > 0) 
    goto _jump1799;
    fail_assertion("non-positive loop bound");
    _jump1799:;
    _293 = 0;
    int64_t _294 = 0; // s
    _jump1800:; // Begin body of loop
    _293 += _294;
    _294++;
    if (_294 < _211.d0)
    goto _jump1800;
    // End body of loop
    _292.d0 = _293;
    if (_293 > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing bound for t
    _292.d1 = _211.d1;
    if (_211.d1 > 0) 
    goto _jump1802;
    fail_assertion("non-positive loop bound");
    _jump1802:;
    // Computing bound for u
    _292.d2 = _211.d1;
    if (_211.d1 > 0) 
    goto _jump1803;
    fail_assertion("non-positive loop bound");
    _jump1803:;
    // Computing total size of heap memory to allocate
    int64_t _295 = 1;
    _295 *= _293;
    _295 *= _211.d1;
    _295 *= _211.d1;
    _295 *= sizeof(int64_t);
    _292.data = jpl_alloc(_295);
    int64_t _296 = 0; // u
    int64_t _297 = 0; // t
    int64_t _298 = 0; // s
    _jump1804:; // Begin body of loop
    int64_t _299;
    if (!a)
    goto _jump1805;
    _299 = l;
    goto _jump1806;
    _jump1805:;
    _299 = _211.d1;
    _jump1806:;
    int64_t _300 = 0;
    _300 *= _292.d0;
    _300 += _298;
    _300 *= _292.d1;
    _300 += _297;
    _300 *= _292.d2;
    _300 += _296;
    _292.data[_300] = _299;
    _296++;
    if (_296 < _211.d1)
    goto _jump1804;
    _296 = 0;
    _297++;
    if (_297 < _211.d1)
    goto _jump1804;
    _297 = 0;
    _298++;
    if (_298 < _293)
    goto _jump1804;
    // End body of loop
    int64_t _301 = 640;
    int64_t _302 = -j;
    int64_t _303 = j % _302;
    if (_301 >= 0)
    goto _jump1807;
    fail_assertion("negative array index");
    _jump1807:;
    if (_301 < _292.d0)
    goto _jump1808;
    fail_assertion("index too large");
    _jump1808:;
    if (_211.d0 >= 0)
    goto _jump1809;
    fail_assertion("negative array index");
    _jump1809:;
    if (_211.d0 < _292.d1)
    goto _jump1810;
    fail_assertion("index too large");
    _jump1810:;
    if (_303 >= 0)
    goto _jump1811;
    fail_assertion("negative array index");
    _jump1811:;
    if (_303 < _292.d2)
    goto _jump1812;
    fail_assertion("index too large");
    _jump1812:;
    int64_t _304 = 0;
    _304 *= _292.d0;
    _304 += _301;
    _304 *= _292.d1;
    _304 += _211.d0;
    _304 *= _292.d2;
    _304 += _303;
    int64_t _305 = _292.data[_304];
    _a1_int64_t _306;
    _306.d0 = 2;
    _306.data = jpl_alloc(sizeof(int64_t) * 2);
    _306.data[0] = j;
    _306.data[1] = _211.d0;
    int64_t _307 = g(_306);
    int64_t _308 = _305 + _307;
    if (_211.d1 >= 0)
    goto _jump1813;
    fail_assertion("negative array index");
    _jump1813:;
    if (_211.d1 < _291.d0)
    goto _jump1814;
    fail_assertion("index too large");
    _jump1814:;
    if (_308 >= 0)
    goto _jump1815;
    fail_assertion("negative array index");
    _jump1815:;
    if (_308 < _291.d1)
    goto _jump1816;
    fail_assertion("index too large");
    _jump1816:;
    int64_t _309 = 0;
    _309 *= _291.d0;
    _309 += _211.d1;
    _309 *= _291.d1;
    _309 += _308;
    _a2_int64_t _310 = _291.data[_309];
    _275 = _310;
    _jump1791:;
    _236 = _275;
    goto _jump1817;
    _jump1753:;
    _a2_int64_t _311;
    if (!b)
    goto _jump1818;
    _311 = _211;
    goto _jump1819;
    _jump1818:;
    _311 = _211;
    _jump1819:;
    _236 = _311;
    _jump1817:;
    _a3__a3__a1_bool _312;
    // Computing bound for v
    _a1__a3_bool _313;
    // Computing bound for v
    _313.d0 = _236.d1;
    if (_236.d1 > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing total size of heap memory to allocate
    int64_t _314 = 1;
    _314 *= _236.d1;
    _314 *= sizeof(_a3_bool);
    _313.data = jpl_alloc(_314);
    int64_t _315 = 0; // v
    _jump1821:; // Begin body of loop
    _a3_bool _316;
    // Computing bound for w
    _316.d0 = _211.d1;
    if (_211.d1 > 0) 
    goto _jump1822;
    fail_assertion("non-positive loop bound");
    _jump1822:;
    // Computing bound for x
    _316.d1 = j;
    if (j > 0) 
    goto _jump1823;
    fail_assertion("non-positive loop bound");
    _jump1823:;
    // Computing bound for y
    _316.d2 = _211.d1;
    if (_211.d1 > 0) 
    goto _jump1824;
    fail_assertion("non-positive loop bound");
    _jump1824:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= _211.d1;
    _317 *= j;
    _317 *= _211.d1;
    _317 *= sizeof(bool);
    _316.data = jpl_alloc(_317);
    int64_t _318 = 0; // y
    int64_t _319 = 0; // x
    int64_t _320 = 0; // w
    _jump1825:; // Begin body of loop
    int64_t _321 = 0;
    _321 *= _316.d0;
    _321 += _320;
    _321 *= _316.d1;
    _321 += _319;
    _321 *= _316.d2;
    _321 += _318;
    _316.data[_321] = b;
    _318++;
    if (_318 < _211.d1)
    goto _jump1825;
    _318 = 0;
    _319++;
    if (_319 < j)
    goto _jump1825;
    _319 = 0;
    _320++;
    if (_320 < _211.d1)
    goto _jump1825;
    // End body of loop
    int64_t _322 = 0;
    _322 *= _313.d0;
    _322 += _315;
    _313.data[_322] = _316;
    _315++;
    if (_315 < _236.d1)
    goto _jump1821;
    // End body of loop
    int64_t _323;
    if (!b)
    goto _jump1826;
    _323 = l;
    goto _jump1827;
    _jump1826:;
    _323 = _236.d1;
    _jump1827:;
    int64_t _324 = _211.d1 / _323;
    if (_324 >= 0)
    goto _jump1828;
    fail_assertion("negative array index");
    _jump1828:;
    if (_324 < _313.d0)
    goto _jump1829;
    fail_assertion("index too large");
    _jump1829:;
    int64_t _325 = 0;
    _325 *= _313.d0;
    _325 += _324;
    _a3_bool _326 = _313.data[_325];
    int64_t _327;
    // Computing bound for v
    int64_t _328;
    if (!f)
    goto _jump1830;
    _328 = _236.d0;
    goto _jump1831;
    _jump1830:;
    _328 = _211.d0;
    _jump1831:;
    if (_328 > 0) 
    goto _jump1832;
    fail_assertion("non-positive loop bound");
    _jump1832:;
    // Computing bound for w
    int64_t _329;
    // Computing bound for v
    if (_236.d1 > 0) 
    goto _jump1833;
    fail_assertion("non-positive loop bound");
    _jump1833:;
    // Computing bound for w
    if (j > 0) 
    goto _jump1834;
    fail_assertion("non-positive loop bound");
    _jump1834:;
    _329 = 0;
    int64_t _330 = 0; // w
    int64_t _331 = 0; // v
    _jump1835:; // Begin body of loop
    _329 += l;
    _330++;
    if (_330 < j)
    goto _jump1835;
    _330 = 0;
    _331++;
    if (_331 < _236.d1)
    goto _jump1835;
    // End body of loop
    if (_329 > 0) 
    goto _jump1836;
    fail_assertion("non-positive loop bound");
    _jump1836:;
    _327 = 0;
    int64_t _332 = 0; // w
    int64_t _333 = 0; // v
    _jump1837:; // Begin body of loop
    _327 += _211.d0;
    _332++;
    if (_332 < _329)
    goto _jump1837;
    _332 = 0;
    _333++;
    if (_333 < _328)
    goto _jump1837;
    // End body of loop
    int64_t _334 = l + _327;
    _a1_int64_t _335;
    // Computing bound for v
    _335.d0 = _211.d0;
    if (_211.d0 > 0) 
    goto _jump1838;
    fail_assertion("non-positive loop bound");
    _jump1838:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _211.d0;
    _336 *= sizeof(int64_t);
    _335.data = jpl_alloc(_336);
    int64_t _337 = 0; // v
    _jump1839:; // Begin body of loop
    int64_t _338 = 0;
    _338 *= _335.d0;
    _338 += _337;
    _335.data[_338] = l;
    _337++;
    if (_337 < _211.d0)
    goto _jump1839;
    // End body of loop
    int64_t _339 = g(_335);
    if (_334 >= 0)
    goto _jump1840;
    fail_assertion("negative array index");
    _jump1840:;
    if (_334 < _326.d0)
    goto _jump1841;
    fail_assertion("index too large");
    _jump1841:;
    if (_211.d0 >= 0)
    goto _jump1842;
    fail_assertion("negative array index");
    _jump1842:;
    if (_211.d0 < _326.d1)
    goto _jump1843;
    fail_assertion("index too large");
    _jump1843:;
    if (_339 >= 0)
    goto _jump1844;
    fail_assertion("negative array index");
    _jump1844:;
    if (_339 < _326.d2)
    goto _jump1845;
    fail_assertion("index too large");
    _jump1845:;
    int64_t _340 = 0;
    _340 *= _326.d0;
    _340 += _334;
    _340 *= _326.d1;
    _340 += _211.d0;
    _340 *= _326.d2;
    _340 += _339;
    bool _341 = _326.data[_340];
    int64_t _342;
    if (!_341)
    goto _jump1846;
    _342 = _211.d1;
    goto _jump1847;
    _jump1846:;
    _342 = _236.d1;
    _jump1847:;
    _312.d0 = _342;
    if (_342 > 0) 
    goto _jump1848;
    fail_assertion("non-positive loop bound");
    _jump1848:;
    // Computing bound for w
    _312.d1 = _211.d0;
    if (_211.d0 > 0) 
    goto _jump1849;
    fail_assertion("non-positive loop bound");
    _jump1849:;
    // Computing bound for x
    _312.d2 = _211.d1;
    if (_211.d1 > 0) 
    goto _jump1850;
    fail_assertion("non-positive loop bound");
    _jump1850:;
    // Computing total size of heap memory to allocate
    int64_t _343 = 1;
    _343 *= _342;
    _343 *= _211.d0;
    _343 *= _211.d1;
    _343 *= sizeof(_a3__a1_bool);
    _312.data = jpl_alloc(_343);
    int64_t _344 = 0; // x
    int64_t _345 = 0; // w
    int64_t _346 = 0; // v
    _jump1851:; // Begin body of loop
    _a1_int64_t _347;
    // Computing bound for y
    int64_t _348 = 958;
    int64_t _349 = -_348;
    _347.d0 = _349;
    if (_349 > 0) 
    goto _jump1852;
    fail_assertion("non-positive loop bound");
    _jump1852:;
    // Computing total size of heap memory to allocate
    int64_t _350 = 1;
    _350 *= _349;
    _350 *= sizeof(int64_t);
    _347.data = jpl_alloc(_350);
    int64_t _351 = 0; // y
    _jump1853:; // Begin body of loop
    int64_t _352 = -_345;
    int64_t _353 = 0;
    _353 *= _347.d0;
    _353 += _351;
    _347.data[_353] = _352;
    _351++;
    if (_351 < _349)
    goto _jump1853;
    // End body of loop
    int64_t _354 = g(_347);
    bool _355 = !f;
    int64_t _356;
    if (!_355)
    goto _jump1854;
    _356 = l;
    goto _jump1855;
    _jump1854:;
    _356 = _344;
    _jump1855:;
    bool _357 = _354 >= _356;
    _a3__a1_bool _358;
    if (!_357)
    goto _jump1856;
    bool _359 = false;
    bool _360 = !_359;
    bool _361;
    if (!_360)
    goto _jump1857;
    bool _362 = false;
    _361 = _362;
    goto _jump1858;
    _jump1857:;
    bool _363;
    if (!a)
    goto _jump1859;
    _363 = a;
    goto _jump1860;
    _jump1859:;
    bool _364 = false;
    _363 = _364;
    _jump1860:;
    _361 = _363;
    _jump1858:;
    bool _365;
    if (!_361)
    goto _jump1861;
    bool _367 = _236.d0 != _236.d0;
    bool _366 = _367;
    if (0 != _367)
    goto _jump1862;
    _366 = f;
    _jump1862:;
    _365 = _366;
    goto _jump1863;
    _jump1861:;
    bool _368 = true;
    _365 = _368;
    _jump1863:;
    _a3__a1_bool _369;
    if (!_365)
    goto _jump1864;
    _a3__a1_bool _370;
    // Computing bound for y
    _370.d0 = _236.d1;
    if (_236.d1 > 0) 
    goto _jump1865;
    fail_assertion("non-positive loop bound");
    _jump1865:;
    // Computing bound for z
    _a1_int64_t _371;
    // Computing bound for y
    int64_t _372 = 136;
    _371.d0 = _372;
    if (_372 > 0) 
    goto _jump1866;
    fail_assertion("non-positive loop bound");
    _jump1866:;
    // Computing total size of heap memory to allocate
    int64_t _373 = 1;
    _373 *= _372;
    _373 *= sizeof(int64_t);
    _371.data = jpl_alloc(_373);
    int64_t _374 = 0; // y
    _jump1867:; // Begin body of loop
    int64_t _375 = 0;
    _375 *= _371.d0;
    _375 += _374;
    _371.data[_375] = l;
    _374++;
    if (_374 < _372)
    goto _jump1867;
    // End body of loop
    int64_t _376 = g(_371);
    _370.d1 = _376;
    if (_376 > 0) 
    goto _jump1868;
    fail_assertion("non-positive loop bound");
    _jump1868:;
    // Computing bound for A
    int64_t _377 = _345 + _211.d0;
    _370.d2 = _377;
    if (_377 > 0) 
    goto _jump1869;
    fail_assertion("non-positive loop bound");
    _jump1869:;
    // Computing total size of heap memory to allocate
    int64_t _378 = 1;
    _378 *= _236.d1;
    _378 *= _376;
    _378 *= _377;
    _378 *= sizeof(_a1_bool);
    _370.data = jpl_alloc(_378);
    int64_t _379 = 0; // A
    int64_t _380 = 0; // z
    int64_t _381 = 0; // y
    _jump1870:; // Begin body of loop
    int64_t _382 = 0;
    _382 *= _370.d0;
    _382 += _381;
    _382 *= _370.d1;
    _382 += _380;
    _382 *= _370.d2;
    _382 += _379;
    _370.data[_382] = i;
    _379++;
    if (_379 < _377)
    goto _jump1870;
    _379 = 0;
    _380++;
    if (_380 < _376)
    goto _jump1870;
    _380 = 0;
    _381++;
    if (_381 < _236.d1)
    goto _jump1870;
    // End body of loop
    _369 = _370;
    goto _jump1871;
    _jump1864:;
    _a3__a1_bool _383;
    // Computing bound for y
    int64_t _384;
    // Computing bound for y
    int64_t _385 = 704;
    if (_385 > 0) 
    goto _jump1872;
    fail_assertion("non-positive loop bound");
    _jump1872:;
    // Computing bound for z
    if (_211.d0 > 0) 
    goto _jump1873;
    fail_assertion("non-positive loop bound");
    _jump1873:;
    _384 = 0;
    int64_t _386 = 0; // z
    int64_t _387 = 0; // y
    _jump1874:; // Begin body of loop
    int64_t _388 = 659;
    _384 += _388;
    _386++;
    if (_386 < _211.d0)
    goto _jump1874;
    _386 = 0;
    _387++;
    if (_387 < _385)
    goto _jump1874;
    // End body of loop
    _383.d0 = _384;
    if (_384 > 0) 
    goto _jump1875;
    fail_assertion("non-positive loop bound");
    _jump1875:;
    // Computing bound for z
    _383.d1 = _236.d1;
    if (_236.d1 > 0) 
    goto _jump1876;
    fail_assertion("non-positive loop bound");
    _jump1876:;
    // Computing bound for A
    _a1_int64_t _389;
    _389.d0 = 1;
    _389.data = jpl_alloc(sizeof(int64_t) * 1);
    _389.data[0] = _346;
    int64_t _390 = g(_389);
    _383.d2 = _390;
    if (_390 > 0) 
    goto _jump1877;
    fail_assertion("non-positive loop bound");
    _jump1877:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= _384;
    _391 *= _236.d1;
    _391 *= _390;
    _391 *= sizeof(_a1_bool);
    _383.data = jpl_alloc(_391);
    int64_t _392 = 0; // A
    int64_t _393 = 0; // z
    int64_t _394 = 0; // y
    _jump1878:; // Begin body of loop
    double _395 = 44.0;
    double _396 = 22.0;
    bool _397 = _395 == _396;
    _a1_bool _398;
    _398.d0 = 2;
    _398.data = jpl_alloc(sizeof(bool) * 2);
    _398.data[0] = _397;
    _398.data[1] = f;
    int64_t _399 = 0;
    _399 *= _383.d0;
    _399 += _394;
    _399 *= _383.d1;
    _399 += _393;
    _399 *= _383.d2;
    _399 += _392;
    _383.data[_399] = _398;
    _392++;
    if (_392 < _390)
    goto _jump1878;
    _392 = 0;
    _393++;
    if (_393 < _236.d1)
    goto _jump1878;
    _393 = 0;
    _394++;
    if (_394 < _384)
    goto _jump1878;
    // End body of loop
    _369 = _383;
    _jump1871:;
    _358 = _369;
    goto _jump1879;
    _jump1856:;
    _a2__a3__a1_bool _400;
    // Computing bound for y
    _400.d0 = _211.d1;
    if (_211.d1 > 0) 
    goto _jump1880;
    fail_assertion("non-positive loop bound");
    _jump1880:;
    // Computing bound for z
    _400.d1 = _236.d0;
    if (_236.d0 > 0) 
    goto _jump1881;
    fail_assertion("non-positive loop bound");
    _jump1881:;
    // Computing total size of heap memory to allocate
    int64_t _401 = 1;
    _401 *= _211.d1;
    _401 *= _236.d0;
    _401 *= sizeof(_a3__a1_bool);
    _400.data = jpl_alloc(_401);
    int64_t _402 = 0; // z
    int64_t _403 = 0; // y
    _jump1882:; // Begin body of loop
    _a3__a1_bool _404;
    // Computing bound for A
    int64_t _405 = _344 - _211.d0;
    _404.d0 = _405;
    if (_405 > 0) 
    goto _jump1883;
    fail_assertion("non-positive loop bound");
    _jump1883:;
    // Computing bound for B
    _404.d1 = _346;
    if (_346 > 0) 
    goto _jump1884;
    fail_assertion("non-positive loop bound");
    _jump1884:;
    // Computing bound for C
    _404.d2 = _236.d1;
    if (_236.d1 > 0) 
    goto _jump1885;
    fail_assertion("non-positive loop bound");
    _jump1885:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _405;
    _406 *= _346;
    _406 *= _236.d1;
    _406 *= sizeof(_a1_bool);
    _404.data = jpl_alloc(_406);
    int64_t _407 = 0; // C
    int64_t _408 = 0; // B
    int64_t _409 = 0; // A
    _jump1886:; // Begin body of loop
    int64_t _410 = 0;
    _410 *= _404.d0;
    _410 += _409;
    _410 *= _404.d1;
    _410 += _408;
    _410 *= _404.d2;
    _410 += _407;
    _404.data[_410] = i;
    _407++;
    if (_407 < _236.d1)
    goto _jump1886;
    _407 = 0;
    _408++;
    if (_408 < _346)
    goto _jump1886;
    _408 = 0;
    _409++;
    if (_409 < _405)
    goto _jump1886;
    // End body of loop
    int64_t _411 = 0;
    _411 *= _400.d0;
    _411 += _403;
    _411 *= _400.d1;
    _411 += _402;
    _400.data[_411] = _404;
    _402++;
    if (_402 < _236.d0)
    goto _jump1882;
    _402 = 0;
    _403++;
    if (_403 < _211.d1)
    goto _jump1882;
    // End body of loop
    if (_345 >= 0)
    goto _jump1887;
    fail_assertion("negative array index");
    _jump1887:;
    if (_345 < _400.d0)
    goto _jump1888;
    fail_assertion("index too large");
    _jump1888:;
    if (j >= 0)
    goto _jump1889;
    fail_assertion("negative array index");
    _jump1889:;
    if (j < _400.d1)
    goto _jump1890;
    fail_assertion("index too large");
    _jump1890:;
    int64_t _412 = 0;
    _412 *= _400.d0;
    _412 += _345;
    _412 *= _400.d1;
    _412 += j;
    _a3__a1_bool _413 = _400.data[_412];
    _358 = _413;
    _jump1879:;
    int64_t _414 = 0;
    _414 *= _312.d0;
    _414 += _346;
    _414 *= _312.d1;
    _414 += _345;
    _414 *= _312.d2;
    _414 += _344;
    _312.data[_414] = _358;
    _344++;
    if (_344 < _211.d1)
    goto _jump1851;
    _344 = 0;
    _345++;
    if (_345 < _211.d0)
    goto _jump1851;
    _345 = 0;
    _346++;
    if (_346 < _342)
    goto _jump1851;
    // End body of loop
    int64_t _415 = l - l;
    if (_211.d0 >= 0)
    goto _jump1891;
    fail_assertion("negative array index");
    _jump1891:;
    if (_211.d0 < _312.d0)
    goto _jump1892;
    fail_assertion("index too large");
    _jump1892:;
    if (j >= 0)
    goto _jump1893;
    fail_assertion("negative array index");
    _jump1893:;
    if (j < _312.d1)
    goto _jump1894;
    fail_assertion("index too large");
    _jump1894:;
    if (_415 >= 0)
    goto _jump1895;
    fail_assertion("negative array index");
    _jump1895:;
    if (_415 < _312.d2)
    goto _jump1896;
    fail_assertion("index too large");
    _jump1896:;
    int64_t _416 = 0;
    _416 *= _312.d0;
    _416 += _211.d0;
    _416 *= _312.d1;
    _416 += j;
    _416 *= _312.d2;
    _416 += _415;
    _a3__a1_bool _417 = _312.data[_416];
    _a3__a1__a1_void_t _418;
    // Computing bound for z
    _418.d0 = _236.d1;
    if (_236.d1 > 0) 
    goto _jump1897;
    fail_assertion("non-positive loop bound");
    _jump1897:;
    // Computing bound for A
    int64_t _419 = 129;
    int64_t _420 = 358;
    int64_t _421 = _419 % _420;
    _418.d1 = _421;
    if (_421 > 0) 
    goto _jump1898;
    fail_assertion("non-positive loop bound");
    _jump1898:;
    // Computing bound for B
    int64_t _422;
    // Computing bound for z
    if (_417.d2 > 0) 
    goto _jump1899;
    fail_assertion("non-positive loop bound");
    _jump1899:;
    // Computing bound for A
    if (_417.d1 > 0) 
    goto _jump1900;
    fail_assertion("non-positive loop bound");
    _jump1900:;
    // Computing bound for B
    if (_236.d0 > 0) 
    goto _jump1901;
    fail_assertion("non-positive loop bound");
    _jump1901:;
    _422 = 0;
    int64_t _423 = 0; // B
    int64_t _424 = 0; // A
    int64_t _425 = 0; // z
    _jump1902:; // Begin body of loop
    _422 += _236.d0;
    _423++;
    if (_423 < _236.d0)
    goto _jump1902;
    _423 = 0;
    _424++;
    if (_424 < _417.d1)
    goto _jump1902;
    _424 = 0;
    _425++;
    if (_425 < _417.d2)
    goto _jump1902;
    // End body of loop
    int64_t _426 = j + _422;
    _418.d2 = _426;
    if (_426 > 0) 
    goto _jump1903;
    fail_assertion("non-positive loop bound");
    _jump1903:;
    // Computing total size of heap memory to allocate
    int64_t _427 = 1;
    _427 *= _236.d1;
    _427 *= _421;
    _427 *= _426;
    _427 *= sizeof(_a1__a1_void_t);
    _418.data = jpl_alloc(_427);
    int64_t _428 = 0; // B
    int64_t _429 = 0; // A
    int64_t _430 = 0; // z
    _jump1904:; // Begin body of loop
    _a1__a1_void_t _431 = m();
    int64_t _432 = 0;
    _432 *= _418.d0;
    _432 += _430;
    _432 *= _418.d1;
    _432 += _429;
    _432 *= _418.d2;
    _432 += _428;
    _418.data[_432] = _431;
    _428++;
    if (_428 < _426)
    goto _jump1904;
    _428 = 0;
    _429++;
    if (_429 < _421)
    goto _jump1904;
    _429 = 0;
    _430++;
    if (_430 < _236.d1)
    goto _jump1904;
    // End body of loop
    _a3__a1__a1_void_t _433;
    // Computing bound for z
    int64_t _434 = 316;
    _433.d0 = _434;
    if (_434 > 0) 
    goto _jump1905;
    fail_assertion("non-positive loop bound");
    _jump1905:;
    // Computing bound for A
    _433.d1 = _211.d0;
    if (_211.d0 > 0) 
    goto _jump1906;
    fail_assertion("non-positive loop bound");
    _jump1906:;
    // Computing bound for B
    int64_t _435 = 818;
    _433.d2 = _435;
    if (_435 > 0) 
    goto _jump1907;
    fail_assertion("non-positive loop bound");
    _jump1907:;
    // Computing total size of heap memory to allocate
    int64_t _436 = 1;
    _436 *= _434;
    _436 *= _211.d0;
    _436 *= _435;
    _436 *= sizeof(_a1__a1_void_t);
    _433.data = jpl_alloc(_436);
    int64_t _437 = 0; // B
    int64_t _438 = 0; // A
    int64_t _439 = 0; // z
    _jump1908:; // Begin body of loop
    double _440;
    if (!b)
    goto _jump1909;
    _440 = d;
    goto _jump1910;
    _jump1909:;
    _440 = d;
    _jump1910:;
    double _441 = 75.0;
    bool _442 = _440 < _441;
    _a1__a1_void_t _443;
    if (!_442)
    goto _jump1911;
    _a1__a1_void_t _444 = m();
    _443 = _444;
    goto _jump1912;
    _jump1911:;
    _a1__a1_void_t _445 = m();
    _443 = _445;
    _jump1912:;
    int64_t _446 = 0;
    _446 *= _433.d0;
    _446 += _439;
    _446 *= _433.d1;
    _446 += _438;
    _446 *= _433.d2;
    _446 += _437;
    _433.data[_446] = _443;
    _437++;
    if (_437 < _435)
    goto _jump1908;
    _437 = 0;
    _438++;
    if (_438 < _211.d0)
    goto _jump1908;
    _438 = 0;
    _439++;
    if (_439 < _434)
    goto _jump1908;
    // End body of loop
    _a1__a3__a1__a1_void_t _447;
    _447.d0 = 2;
    _447.data = jpl_alloc(sizeof(_a3__a1__a1_void_t) * 2);
    _447.data[0] = _418;
    _447.data[1] = _433;
    if (_236.d1 >= 0)
    goto _jump1913;
    fail_assertion("negative array index");
    _jump1913:;
    if (_236.d1 < _447.d0)
    goto _jump1914;
    fail_assertion("index too large");
    _jump1914:;
    int64_t _448 = 0;
    _448 *= _447.d0;
    _448 += _236.d1;
    _a3__a1__a1_void_t _449 = _447.data[_448];
    if (_211.d1 >= 0)
    goto _jump1915;
    fail_assertion("negative array index");
    _jump1915:;
    if (_211.d1 < _449.d0)
    goto _jump1916;
    fail_assertion("index too large");
    _jump1916:;
    if (j >= 0)
    goto _jump1917;
    fail_assertion("negative array index");
    _jump1917:;
    if (j < _449.d1)
    goto _jump1918;
    fail_assertion("index too large");
    _jump1918:;
    if (_417.d1 >= 0)
    goto _jump1919;
    fail_assertion("negative array index");
    _jump1919:;
    if (_417.d1 < _449.d2)
    goto _jump1920;
    fail_assertion("index too large");
    _jump1920:;
    int64_t _450 = 0;
    _450 *= _449.d0;
    _450 += _211.d1;
    _450 *= _449.d1;
    _450 += j;
    _450 *= _449.d2;
    _450 += _417.d1;
    _a1__a1_void_t _451 = _449.data[_450];
    return _451;
}

int64_t n() {
    _a2_rgba _0;
    // Computing bound for o
    int64_t _1 = -l;
    int64_t _2 = -j;
    int64_t _3 = _1 - _2;
    int64_t _4 = -_3;
    _0.d0 = _4;
    if (_4 > 0) 
    goto _jump1921;
    fail_assertion("non-positive loop bound");
    _jump1921:;
    // Computing bound for p
    int64_t _5 = 213;
    _0.d1 = _5;
    if (_5 > 0) 
    goto _jump1922;
    fail_assertion("non-positive loop bound");
    _jump1922:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _4;
    _6 *= _5;
    _6 *= sizeof(rgba);
    _0.data = jpl_alloc(_6);
    int64_t _7 = 0; // p
    int64_t _8 = 0; // o
    _jump1923:; // Begin body of loop
    double _9;
    // Computing bound for q
    if (_7 > 0) 
    goto _jump1924;
    fail_assertion("non-positive loop bound");
    _jump1924:;
    // Computing bound for r
    int64_t _10 = n();
    if (_10 > 0) 
    goto _jump1925;
    fail_assertion("non-positive loop bound");
    _jump1925:;
    // Computing bound for s
    bool _11 = false;
    int64_t _12;
    if (!_11)
    goto _jump1926;
    int64_t _13 = 626;
    _12 = _13;
    goto _jump1927;
    _jump1926:;
    _12 = _7;
    _jump1927:;
    if (_12 > 0) 
    goto _jump1928;
    fail_assertion("non-positive loop bound");
    _jump1928:;
    _9 = 0;
    int64_t _14 = 0; // s
    int64_t _15 = 0; // r
    int64_t _16 = 0; // q
    _jump1929:; // Begin body of loop
    double _17 = 57.0;
    _9 += _17;
    _14++;
    if (_14 < _12)
    goto _jump1929;
    _14 = 0;
    _15++;
    if (_15 < _10)
    goto _jump1929;
    _15 = 0;
    _16++;
    if (_16 < _7)
    goto _jump1929;
    // End body of loop
    double _18 = 67.0;
    double _19 = -d;
    double _20 = 9.0;
    double _21 = -_20;
    double _22 = -_21;
    rgba _23 = { _9, _18, _19, _22 };
    int64_t _24 = 0;
    _24 *= _0.d0;
    _24 += _8;
    _24 *= _0.d1;
    _24 += _7;
    _0.data[_24] = _23;
    _7++;
    if (_7 < _5)
    goto _jump1923;
    _7 = 0;
    _8++;
    if (_8 < _4)
    goto _jump1923;
    // End body of loop
    if (l >= 0)
    goto _jump1930;
    fail_assertion("negative array index");
    _jump1930:;
    if (l < _0.d0)
    goto _jump1931;
    fail_assertion("index too large");
    _jump1931:;
    if (l >= 0)
    goto _jump1932;
    fail_assertion("negative array index");
    _jump1932:;
    if (l < _0.d1)
    goto _jump1933;
    fail_assertion("index too large");
    _jump1933:;
    int64_t _25 = 0;
    _25 *= _0.d0;
    _25 += l;
    _25 *= _0.d1;
    _25 += l;
    rgba _26 = _0.data[_25];
    double _27 = _26.a;
    _a1__a3__a3_double _28;
    // Computing bound for o
    int64_t _29;
    // Computing bound for o
    int64_t _30 = 201;
    if (_30 > 0) 
    goto _jump1934;
    fail_assertion("non-positive loop bound");
    _jump1934:;
    _29 = 0;
    int64_t _31 = 0; // o
    _jump1935:; // Begin body of loop
    _29 += _31;
    _31++;
    if (_31 < _30)
    goto _jump1935;
    // End body of loop
    _28.d0 = _29;
    if (_29 > 0) 
    goto _jump1936;
    fail_assertion("non-positive loop bound");
    _jump1936:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _29;
    _32 *= sizeof(_a3__a3_double);
    _28.data = jpl_alloc(_32);
    int64_t _33 = 0; // o
    _jump1937:; // Begin body of loop
    _a3__a3_double _34;
    // Computing bound for p
    int64_t _35 = n();
    int64_t _36 = 324;
    int64_t _37 = _35 / _36;
    _34.d0 = _37;
    if (_37 > 0) 
    goto _jump1938;
    fail_assertion("non-positive loop bound");
    _jump1938:;
    // Computing bound for q
    int64_t _38 = 860;
    _34.d1 = _38;
    if (_38 > 0) 
    goto _jump1939;
    fail_assertion("non-positive loop bound");
    _jump1939:;
    // Computing bound for r
    int64_t _39 = n();
    _34.d2 = _39;
    if (_39 > 0) 
    goto _jump1940;
    fail_assertion("non-positive loop bound");
    _jump1940:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= _37;
    _40 *= _38;
    _40 *= _39;
    _40 *= sizeof(_a3_double);
    _34.data = jpl_alloc(_40);
    int64_t _41 = 0; // r
    int64_t _42 = 0; // q
    int64_t _43 = 0; // p
    _jump1941:; // Begin body of loop
    _a3_double _44;
    // Computing bound for s
    _44.d0 = l;
    if (l > 0) 
    goto _jump1942;
    fail_assertion("non-positive loop bound");
    _jump1942:;
    // Computing bound for t
    int64_t _45 = 998;
    _44.d1 = _45;
    if (_45 > 0) 
    goto _jump1943;
    fail_assertion("non-positive loop bound");
    _jump1943:;
    // Computing bound for u
    _44.d2 = j;
    if (j > 0) 
    goto _jump1944;
    fail_assertion("non-positive loop bound");
    _jump1944:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= l;
    _46 *= _45;
    _46 *= j;
    _46 *= sizeof(double);
    _44.data = jpl_alloc(_46);
    int64_t _47 = 0; // u
    int64_t _48 = 0; // t
    int64_t _49 = 0; // s
    _jump1945:; // Begin body of loop
    int64_t _50 = 0;
    _50 *= _44.d0;
    _50 += _49;
    _50 *= _44.d1;
    _50 += _48;
    _50 *= _44.d2;
    _50 += _47;
    _44.data[_50] = d;
    _47++;
    if (_47 < j)
    goto _jump1945;
    _47 = 0;
    _48++;
    if (_48 < _45)
    goto _jump1945;
    _48 = 0;
    _49++;
    if (_49 < l)
    goto _jump1945;
    // End body of loop
    int64_t _51 = 0;
    _51 *= _34.d0;
    _51 += _43;
    _51 *= _34.d1;
    _51 += _42;
    _51 *= _34.d2;
    _51 += _41;
    _34.data[_51] = _44;
    _41++;
    if (_41 < _39)
    goto _jump1941;
    _41 = 0;
    _42++;
    if (_42 < _38)
    goto _jump1941;
    _42 = 0;
    _43++;
    if (_43 < _37)
    goto _jump1941;
    // End body of loop
    int64_t _52 = 0;
    _52 *= _28.d0;
    _52 += _33;
    _28.data[_52] = _34;
    _33++;
    if (_33 < _29)
    goto _jump1937;
    // End body of loop
    int64_t _53 = n();
    int64_t _54 = -_53;
    if (_54 >= 0)
    goto _jump1946;
    fail_assertion("negative array index");
    _jump1946:;
    if (_54 < _28.d0)
    goto _jump1947;
    fail_assertion("index too large");
    _jump1947:;
    int64_t _55 = 0;
    _55 *= _28.d0;
    _55 += _54;
    _a3__a3_double _56 = _28.data[_55];
    _a3__a1_int64_t _57;
    // Computing bound for o
    int64_t _58 = n();
    _57.d0 = _58;
    if (_58 > 0) 
    goto _jump1948;
    fail_assertion("non-positive loop bound");
    _jump1948:;
    // Computing bound for p
    int64_t _59 = l + j;
    _57.d1 = _59;
    if (_59 > 0) 
    goto _jump1949;
    fail_assertion("non-positive loop bound");
    _jump1949:;
    // Computing bound for q
    int64_t _60 = n();
    _57.d2 = _60;
    if (_60 > 0) 
    goto _jump1950;
    fail_assertion("non-positive loop bound");
    _jump1950:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= _58;
    _61 *= _59;
    _61 *= _60;
    _61 *= sizeof(_a1_int64_t);
    _57.data = jpl_alloc(_61);
    int64_t _62 = 0; // q
    int64_t _63 = 0; // p
    int64_t _64 = 0; // o
    _jump1951:; // Begin body of loop
    int64_t _65 = 205;
    _a1_int64_t _66;
    _66.d0 = 3;
    _66.data = jpl_alloc(sizeof(int64_t) * 3);
    _66.data[0] = _63;
    _66.data[1] = _65;
    _66.data[2] = j;
    int64_t _67 = 0;
    _67 *= _57.d0;
    _67 += _64;
    _67 *= _57.d1;
    _67 += _63;
    _67 *= _57.d2;
    _67 += _62;
    _57.data[_67] = _66;
    _62++;
    if (_62 < _60)
    goto _jump1951;
    _62 = 0;
    _63++;
    if (_63 < _59)
    goto _jump1951;
    _63 = 0;
    _64++;
    if (_64 < _58)
    goto _jump1951;
    // End body of loop
    int64_t _68;
    if (!a)
    goto _jump1952;
    _68 = j;
    goto _jump1953;
    _jump1952:;
    int64_t _69 = 179;
    int64_t _70 = -_69;
    _68 = _70;
    _jump1953:;
    bool _71 = true;
    int64_t _72;
    if (!_71)
    goto _jump1954;
    int64_t _73;
    // Computing bound for o
    int64_t _74 = n();
    if (_74 > 0) 
    goto _jump1955;
    fail_assertion("non-positive loop bound");
    _jump1955:;
    _73 = 0;
    int64_t _75 = 0; // o
    _jump1956:; // Begin body of loop
    _73 += l;
    _75++;
    if (_75 < _74)
    goto _jump1956;
    // End body of loop
    _72 = _73;
    goto _jump1957;
    _jump1954:;
    int64_t _76 = n();
    int64_t _77 = n();
    int64_t _78 = _76 / _77;
    _72 = _78;
    _jump1957:;
    if (_68 >= 0)
    goto _jump1958;
    fail_assertion("negative array index");
    _jump1958:;
    if (_68 < _57.d0)
    goto _jump1959;
    fail_assertion("index too large");
    _jump1959:;
    if (_72 >= 0)
    goto _jump1960;
    fail_assertion("negative array index");
    _jump1960:;
    if (_72 < _57.d1)
    goto _jump1961;
    fail_assertion("index too large");
    _jump1961:;
    if (l >= 0)
    goto _jump1962;
    fail_assertion("negative array index");
    _jump1962:;
    if (l < _57.d2)
    goto _jump1963;
    fail_assertion("index too large");
    _jump1963:;
    int64_t _79 = 0;
    _79 *= _57.d0;
    _79 += _68;
    _79 *= _57.d1;
    _79 += _72;
    _79 *= _57.d2;
    _79 += l;
    _a1_int64_t _80 = _57.data[_79];
    int64_t _81 = g(_80);
    _a3_int64_t _82;
    // Computing bound for o
    _82.d0 = l;
    if (l > 0) 
    goto _jump1964;
    fail_assertion("non-positive loop bound");
    _jump1964:;
    // Computing bound for p
    int64_t _83 = n();
    _82.d1 = _83;
    if (_83 > 0) 
    goto _jump1965;
    fail_assertion("non-positive loop bound");
    _jump1965:;
    // Computing bound for q
    _82.d2 = j;
    if (j > 0) 
    goto _jump1966;
    fail_assertion("non-positive loop bound");
    _jump1966:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= l;
    _84 *= _83;
    _84 *= j;
    _84 *= sizeof(int64_t);
    _82.data = jpl_alloc(_84);
    int64_t _85 = 0; // q
    int64_t _86 = 0; // p
    int64_t _87 = 0; // o
    _jump1967:; // Begin body of loop
    int64_t _88 = 0;
    _88 *= _82.d0;
    _88 += _87;
    _88 *= _82.d1;
    _88 += _86;
    _88 *= _82.d2;
    _88 += _85;
    _82.data[_88] = _87;
    _85++;
    if (_85 < j)
    goto _jump1967;
    _85 = 0;
    _86++;
    if (_86 < _83)
    goto _jump1967;
    _86 = 0;
    _87++;
    if (_87 < l)
    goto _jump1967;
    // End body of loop
    int64_t _89 = n();
    int64_t _90 = 878;
    _a1_int64_t _91;
    _91.d0 = 3;
    _91.data = jpl_alloc(sizeof(int64_t) * 3);
    _91.data[0] = _89;
    _91.data[1] = _90;
    _91.data[2] = j;
    int64_t _92 = l - j;
    if (_92 >= 0)
    goto _jump1968;
    fail_assertion("negative array index");
    _jump1968:;
    if (_92 < _91.d0)
    goto _jump1969;
    fail_assertion("index too large");
    _jump1969:;
    int64_t _93 = 0;
    _93 *= _91.d0;
    _93 += _92;
    int64_t _94 = _91.data[_93];
    if (_94 >= 0)
    goto _jump1970;
    fail_assertion("negative array index");
    _jump1970:;
    if (_94 < _82.d0)
    goto _jump1971;
    fail_assertion("index too large");
    _jump1971:;
    if (j >= 0)
    goto _jump1972;
    fail_assertion("negative array index");
    _jump1972:;
    if (j < _82.d1)
    goto _jump1973;
    fail_assertion("index too large");
    _jump1973:;
    if (l >= 0)
    goto _jump1974;
    fail_assertion("negative array index");
    _jump1974:;
    if (l < _82.d2)
    goto _jump1975;
    fail_assertion("index too large");
    _jump1975:;
    int64_t _95 = 0;
    _95 *= _82.d0;
    _95 += _94;
    _95 *= _82.d1;
    _95 += j;
    _95 *= _82.d2;
    _95 += l;
    int64_t _96 = _82.data[_95];
    int64_t _97 = _96 % j;
    if (_81 >= 0)
    goto _jump1976;
    fail_assertion("negative array index");
    _jump1976:;
    if (_81 < _56.d0)
    goto _jump1977;
    fail_assertion("index too large");
    _jump1977:;
    if (j >= 0)
    goto _jump1978;
    fail_assertion("negative array index");
    _jump1978:;
    if (j < _56.d1)
    goto _jump1979;
    fail_assertion("index too large");
    _jump1979:;
    if (_97 >= 0)
    goto _jump1980;
    fail_assertion("negative array index");
    _jump1980:;
    if (_97 < _56.d2)
    goto _jump1981;
    fail_assertion("index too large");
    _jump1981:;
    int64_t _98 = 0;
    _98 *= _56.d0;
    _98 += _81;
    _98 *= _56.d1;
    _98 += j;
    _98 *= _56.d2;
    _98 += _97;
    _a3_double _99 = _56.data[_98];
    int64_t _100 = 529;
    _a1_int64_t _101;
    if (!f)
    goto _jump1982;
    int64_t _102 = -j;
    int64_t _103 = 163;
    int64_t _104 = n();
    int64_t _105 = _103 - _104;
    _a1_int64_t _106;
    _106.d0 = 2;
    _106.data = jpl_alloc(sizeof(int64_t) * 2);
    _106.data[0] = _102;
    _106.data[1] = _105;
    _101 = _106;
    goto _jump1983;
    _jump1982:;
    _a1_int64_t _107;
    _107.d0 = 1;
    _107.data = jpl_alloc(sizeof(int64_t) * 1);
    _107.data[0] = j;
    _101 = _107;
    _jump1983:;
    if (l >= 0)
    goto _jump1984;
    fail_assertion("negative array index");
    _jump1984:;
    if (l < _101.d0)
    goto _jump1985;
    fail_assertion("index too large");
    _jump1985:;
    int64_t _108 = 0;
    _108 *= _101.d0;
    _108 += l;
    int64_t _109 = _101.data[_108];
    int64_t _110 = _100 * _109;
    _a3__a3_int64_t _111;
    // Computing bound for o
    int64_t _112;
    // Computing bound for o
    if (l > 0) 
    goto _jump1986;
    fail_assertion("non-positive loop bound");
    _jump1986:;
    // Computing bound for p
    int64_t _113;
    if (!a)
    goto _jump1987;
    _113 = l;
    goto _jump1988;
    _jump1987:;
    _113 = j;
    _jump1988:;
    if (_113 > 0) 
    goto _jump1989;
    fail_assertion("non-positive loop bound");
    _jump1989:;
    _112 = 0;
    int64_t _114 = 0; // p
    int64_t _115 = 0; // o
    _jump1990:; // Begin body of loop
    int64_t _116 = -l;
    _112 += _116;
    _114++;
    if (_114 < _113)
    goto _jump1990;
    _114 = 0;
    _115++;
    if (_115 < l)
    goto _jump1990;
    // End body of loop
    _111.d0 = _112;
    if (_112 > 0) 
    goto _jump1991;
    fail_assertion("non-positive loop bound");
    _jump1991:;
    // Computing bound for p
    int64_t _117 = 918;
    int64_t _118 = n();
    bool _119 = _117 < _118;
    int64_t _120;
    if (!_119)
    goto _jump1992;
    int64_t _121 = 618;
    _120 = _121;
    goto _jump1993;
    _jump1992:;
    int64_t _122;
    // Computing bound for o
    if (j > 0) 
    goto _jump1994;
    fail_assertion("non-positive loop bound");
    _jump1994:;
    _122 = 0;
    int64_t _123 = 0; // o
    _jump1995:; // Begin body of loop
    _122 += _123;
    _123++;
    if (_123 < j)
    goto _jump1995;
    // End body of loop
    _120 = _122;
    _jump1993:;
    _111.d1 = _120;
    if (_120 > 0) 
    goto _jump1996;
    fail_assertion("non-positive loop bound");
    _jump1996:;
    // Computing bound for q
    _111.d2 = j;
    if (j > 0) 
    goto _jump1997;
    fail_assertion("non-positive loop bound");
    _jump1997:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _112;
    _124 *= _120;
    _124 *= j;
    _124 *= sizeof(_a3_int64_t);
    _111.data = jpl_alloc(_124);
    int64_t _125 = 0; // q
    int64_t _126 = 0; // p
    int64_t _127 = 0; // o
    _jump1998:; // Begin body of loop
    _a3_int64_t _128;
    // Computing bound for r
    _128.d0 = _127;
    if (_127 > 0) 
    goto _jump1999;
    fail_assertion("non-positive loop bound");
    _jump1999:;
    // Computing bound for s
    int64_t _129 = _126 + l;
    _128.d1 = _129;
    if (_129 > 0) 
    goto _jump2000;
    fail_assertion("non-positive loop bound");
    _jump2000:;
    // Computing bound for t
    _128.d2 = _127;
    if (_127 > 0) 
    goto _jump2001;
    fail_assertion("non-positive loop bound");
    _jump2001:;
    // Computing total size of heap memory to allocate
    int64_t _130 = 1;
    _130 *= _127;
    _130 *= _129;
    _130 *= _127;
    _130 *= sizeof(int64_t);
    _128.data = jpl_alloc(_130);
    int64_t _131 = 0; // t
    int64_t _132 = 0; // s
    int64_t _133 = 0; // r
    _jump2002:; // Begin body of loop
    int64_t _134 = n();
    int64_t _135 = 0;
    _135 *= _128.d0;
    _135 += _133;
    _135 *= _128.d1;
    _135 += _132;
    _135 *= _128.d2;
    _135 += _131;
    _128.data[_135] = _134;
    _131++;
    if (_131 < _127)
    goto _jump2002;
    _131 = 0;
    _132++;
    if (_132 < _129)
    goto _jump2002;
    _132 = 0;
    _133++;
    if (_133 < _127)
    goto _jump2002;
    // End body of loop
    int64_t _136 = 0;
    _136 *= _111.d0;
    _136 += _127;
    _136 *= _111.d1;
    _136 += _126;
    _136 *= _111.d2;
    _136 += _125;
    _111.data[_136] = _128;
    _125++;
    if (_125 < j)
    goto _jump1998;
    _125 = 0;
    _126++;
    if (_126 < _120)
    goto _jump1998;
    _126 = 0;
    _127++;
    if (_127 < _112)
    goto _jump1998;
    // End body of loop
    bool _137 = a;
    if (0 != a)
    goto _jump2003;
    _137 = b;
    _jump2003:;
    int64_t _138;
    if (!_137)
    goto _jump2004;
    bool _139 = true;
    int64_t _140;
    if (!_139)
    goto _jump2005;
    int64_t _141 = n();
    int64_t _142 = n();
    int64_t _143 = _141 - _142;
    _140 = _143;
    goto _jump2006;
    _jump2005:;
    int64_t _144 = n();
    _140 = _144;
    _jump2006:;
    _138 = _140;
    goto _jump2007;
    _jump2004:;
    int64_t _145 = 82;
    int64_t _146 = n();
    int64_t _147 = j % _146;
    int64_t _148 = _145 * _147;
    _138 = _148;
    _jump2007:;
    _a1_int64_t _149;
    // Computing bound for o
    _149.d0 = l;
    if (l > 0) 
    goto _jump2008;
    fail_assertion("non-positive loop bound");
    _jump2008:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= l;
    _150 *= sizeof(int64_t);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // o
    _jump2009:; // Begin body of loop
    int64_t _152;
    // Computing bound for p
    int64_t _153 = n();
    if (_153 > 0) 
    goto _jump2010;
    fail_assertion("non-positive loop bound");
    _jump2010:;
    _152 = 0;
    int64_t _154 = 0; // p
    _jump2011:; // Begin body of loop
    _152 += _154;
    _154++;
    if (_154 < _153)
    goto _jump2011;
    // End body of loop
    int64_t _155 = 0;
    _155 *= _149.d0;
    _155 += _151;
    _149.data[_155] = _152;
    _151++;
    if (_151 < l)
    goto _jump2009;
    // End body of loop
    int64_t _156 = g(_149);
    int64_t _157;
    if (!a)
    goto _jump2012;
    int64_t _158 = n();
    _157 = _158;
    goto _jump2013;
    _jump2012:;
    bool _159 = false;
    bool _160 = !_159;
    int64_t _161;
    if (!_160)
    goto _jump2014;
    int64_t _162 = l - l;
    _161 = _162;
    goto _jump2015;
    _jump2014:;
    _161 = j;
    _jump2015:;
    _157 = _161;
    _jump2013:;
    if (_138 >= 0)
    goto _jump2016;
    fail_assertion("negative array index");
    _jump2016:;
    if (_138 < _111.d0)
    goto _jump2017;
    fail_assertion("index too large");
    _jump2017:;
    if (_156 >= 0)
    goto _jump2018;
    fail_assertion("negative array index");
    _jump2018:;
    if (_156 < _111.d1)
    goto _jump2019;
    fail_assertion("index too large");
    _jump2019:;
    if (_157 >= 0)
    goto _jump2020;
    fail_assertion("negative array index");
    _jump2020:;
    if (_157 < _111.d2)
    goto _jump2021;
    fail_assertion("index too large");
    _jump2021:;
    int64_t _163 = 0;
    _163 *= _111.d0;
    _163 += _138;
    _163 *= _111.d1;
    _163 += _156;
    _163 *= _111.d2;
    _163 += _157;
    _a3_int64_t _164 = _111.data[_163];
    bool _165 = false;
    _a3_int64_t _166;
    if (!_165)
    goto _jump2022;
    _a3_int64_t _167;
    // Computing bound for o
    int64_t _168 = 132;
    int64_t _169 = j % _168;
    _167.d0 = _169;
    if (_169 > 0) 
    goto _jump2023;
    fail_assertion("non-positive loop bound");
    _jump2023:;
    // Computing bound for p
    int64_t _170 = -j;
    _167.d1 = _170;
    if (_170 > 0) 
    goto _jump2024;
    fail_assertion("non-positive loop bound");
    _jump2024:;
    // Computing bound for q
    int64_t _171;
    // Computing bound for o
    if (l > 0) 
    goto _jump2025;
    fail_assertion("non-positive loop bound");
    _jump2025:;
    // Computing bound for p
    int64_t _172 = n();
    if (_172 > 0) 
    goto _jump2026;
    fail_assertion("non-positive loop bound");
    _jump2026:;
    // Computing bound for q
    if (j > 0) 
    goto _jump2027;
    fail_assertion("non-positive loop bound");
    _jump2027:;
    _171 = 0;
    int64_t _173 = 0; // q
    int64_t _174 = 0; // p
    int64_t _175 = 0; // o
    _jump2028:; // Begin body of loop
    _171 += _174;
    _173++;
    if (_173 < j)
    goto _jump2028;
    _173 = 0;
    _174++;
    if (_174 < _172)
    goto _jump2028;
    _174 = 0;
    _175++;
    if (_175 < l)
    goto _jump2028;
    // End body of loop
    _167.d2 = _171;
    if (_171 > 0) 
    goto _jump2029;
    fail_assertion("non-positive loop bound");
    _jump2029:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= _169;
    _176 *= _170;
    _176 *= _171;
    _176 *= sizeof(int64_t);
    _167.data = jpl_alloc(_176);
    int64_t _177 = 0; // q
    int64_t _178 = 0; // p
    int64_t _179 = 0; // o
    _jump2030:; // Begin body of loop
    int64_t _180 = 93;
    int64_t _181 = -_180;
    int64_t _182 = 0;
    _182 *= _167.d0;
    _182 += _179;
    _182 *= _167.d1;
    _182 += _178;
    _182 *= _167.d2;
    _182 += _177;
    _167.data[_182] = _181;
    _177++;
    if (_177 < _171)
    goto _jump2030;
    _177 = 0;
    _178++;
    if (_178 < _170)
    goto _jump2030;
    _178 = 0;
    _179++;
    if (_179 < _169)
    goto _jump2030;
    // End body of loop
    _166 = _167;
    goto _jump2031;
    _jump2022:;
    _a3_int64_t _183;
    // Computing bound for o
    _183.d0 = l;
    if (l > 0) 
    goto _jump2032;
    fail_assertion("non-positive loop bound");
    _jump2032:;
    // Computing bound for p
    int64_t _184 = n();
    int64_t _185 = _184 * l;
    _183.d1 = _185;
    if (_185 > 0) 
    goto _jump2033;
    fail_assertion("non-positive loop bound");
    _jump2033:;
    // Computing bound for q
    _183.d2 = j;
    if (j > 0) 
    goto _jump2034;
    fail_assertion("non-positive loop bound");
    _jump2034:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= l;
    _186 *= _185;
    _186 *= j;
    _186 *= sizeof(int64_t);
    _183.data = jpl_alloc(_186);
    int64_t _187 = 0; // q
    int64_t _188 = 0; // p
    int64_t _189 = 0; // o
    _jump2035:; // Begin body of loop
    int64_t _190;
    // Computing bound for r
    if (_188 > 0) 
    goto _jump2036;
    fail_assertion("non-positive loop bound");
    _jump2036:;
    _190 = 0;
    int64_t _191 = 0; // r
    _jump2037:; // Begin body of loop
    int64_t _192 = 738;
    _190 += _192;
    _191++;
    if (_191 < _188)
    goto _jump2037;
    // End body of loop
    int64_t _193 = 0;
    _193 *= _183.d0;
    _193 += _189;
    _193 *= _183.d1;
    _193 += _188;
    _193 *= _183.d2;
    _193 += _187;
    _183.data[_193] = _190;
    _187++;
    if (_187 < j)
    goto _jump2035;
    _187 = 0;
    _188++;
    if (_188 < _185)
    goto _jump2035;
    _188 = 0;
    _189++;
    if (_189 < l)
    goto _jump2035;
    // End body of loop
    _166 = _183;
    _jump2031:;
    int64_t _194 = 506;
    int64_t _195 = 784;
    int64_t _196 = -_195;
    int64_t _197 = 420;
    if (_194 >= 0)
    goto _jump2038;
    fail_assertion("negative array index");
    _jump2038:;
    if (_194 < _166.d0)
    goto _jump2039;
    fail_assertion("index too large");
    _jump2039:;
    if (_196 >= 0)
    goto _jump2040;
    fail_assertion("negative array index");
    _jump2040:;
    if (_196 < _166.d1)
    goto _jump2041;
    fail_assertion("index too large");
    _jump2041:;
    if (_197 >= 0)
    goto _jump2042;
    fail_assertion("negative array index");
    _jump2042:;
    if (_197 < _166.d2)
    goto _jump2043;
    fail_assertion("index too large");
    _jump2043:;
    int64_t _198 = 0;
    _198 *= _166.d0;
    _198 += _194;
    _198 *= _166.d1;
    _198 += _196;
    _198 *= _166.d2;
    _198 += _197;
    int64_t _199 = _166.data[_198];
    int64_t _200;
    // Computing bound for o
    if (j > 0) 
    goto _jump2044;
    fail_assertion("non-positive loop bound");
    _jump2044:;
    _200 = 0;
    int64_t _201 = 0; // o
    _jump2045:; // Begin body of loop
    int64_t _202 = 405;
    _200 += _202;
    _201++;
    if (_201 < j)
    goto _jump2045;
    // End body of loop
    if (_199 >= 0)
    goto _jump2046;
    fail_assertion("negative array index");
    _jump2046:;
    if (_199 < _164.d0)
    goto _jump2047;
    fail_assertion("index too large");
    _jump2047:;
    if (_200 >= 0)
    goto _jump2048;
    fail_assertion("negative array index");
    _jump2048:;
    if (_200 < _164.d1)
    goto _jump2049;
    fail_assertion("index too large");
    _jump2049:;
    if (j >= 0)
    goto _jump2050;
    fail_assertion("negative array index");
    _jump2050:;
    if (j < _164.d2)
    goto _jump2051;
    fail_assertion("index too large");
    _jump2051:;
    int64_t _203 = 0;
    _203 *= _164.d0;
    _203 += _199;
    _203 *= _164.d1;
    _203 += _200;
    _203 *= _164.d2;
    _203 += j;
    int64_t _204 = _164.data[_203];
    if (_110 >= 0)
    goto _jump2052;
    fail_assertion("negative array index");
    _jump2052:;
    if (_110 < _99.d0)
    goto _jump2053;
    fail_assertion("index too large");
    _jump2053:;
    if (_204 >= 0)
    goto _jump2054;
    fail_assertion("negative array index");
    _jump2054:;
    if (_204 < _99.d1)
    goto _jump2055;
    fail_assertion("index too large");
    _jump2055:;
    if (j >= 0)
    goto _jump2056;
    fail_assertion("negative array index");
    _jump2056:;
    if (j < _99.d2)
    goto _jump2057;
    fail_assertion("index too large");
    _jump2057:;
    int64_t _205 = 0;
    _205 *= _99.d0;
    _205 += _110;
    _205 *= _99.d1;
    _205 += _204;
    _205 *= _99.d2;
    _205 += j;
    double _206 = _99.data[_205];
    double _207 = fmod(_27, _206);
    _a1_bool _208;
    if (!a)
    goto _jump2058;
    _a1_bool _209;
    // Computing bound for p
    _a1_int64_t _210;
    // Computing bound for p
    _210.d0 = l;
    if (l > 0) 
    goto _jump2059;
    fail_assertion("non-positive loop bound");
    _jump2059:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= l;
    _211 *= sizeof(int64_t);
    _210.data = jpl_alloc(_211);
    int64_t _212 = 0; // p
    _jump2060:; // Begin body of loop
    int64_t _213 = n();
    int64_t _214 = 0;
    _214 *= _210.d0;
    _214 += _212;
    _210.data[_214] = _213;
    _212++;
    if (_212 < l)
    goto _jump2060;
    // End body of loop
    int64_t _215 = g(_210);
    _209.d0 = _215;
    if (_215 > 0) 
    goto _jump2061;
    fail_assertion("non-positive loop bound");
    _jump2061:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= _215;
    _216 *= sizeof(bool);
    _209.data = jpl_alloc(_216);
    int64_t _217 = 0; // p
    _jump2062:; // Begin body of loop
    bool _218 = a;
    if (0 != a)
    goto _jump2063;
    double _219 = 76.0;
    bool _220 = _219 < _207;
    _218 = _220;
    _jump2063:;
    int64_t _221 = 0;
    _221 *= _209.d0;
    _221 += _217;
    _209.data[_221] = _218;
    _217++;
    if (_217 < _215)
    goto _jump2062;
    // End body of loop
    _208 = _209;
    goto _jump2064;
    _jump2058:;
    bool _222 = false;
    double _223 = 66.0;
    double _224 = d / _207;
    bool _225 = _223 < _224;
    double _226;
    // Computing bound for p
    if (j > 0) 
    goto _jump2065;
    fail_assertion("non-positive loop bound");
    _jump2065:;
    _226 = 0;
    int64_t _227 = 0; // p
    _jump2066:; // Begin body of loop
    _226 += _207;
    _227++;
    if (_227 < j)
    goto _jump2066;
    // End body of loop
    double _228 = 3.0;
    double _229 = 19.0;
    rgba _230 = { _207, _207, _228, _229 };
    double _231 = _230.r;
    bool _232 = _226 >= _231;
    _a1_bool _233;
    _233.d0 = 3;
    _233.data = jpl_alloc(sizeof(bool) * 3);
    _233.data[0] = _222;
    _233.data[1] = _225;
    _233.data[2] = _232;
    _208 = _233;
    _jump2064:;
    int64_t _234 = n();
    int64_t _235 = -j;
    int64_t _236;
    // Computing bound for p
    int64_t _237 = l - j;
    if (_237 > 0) 
    goto _jump2067;
    fail_assertion("non-positive loop bound");
    _jump2067:;
    _236 = 0;
    int64_t _238 = 0; // p
    _jump2068:; // Begin body of loop
    int64_t _239 = n();
    _236 += _239;
    _238++;
    if (_238 < _237)
    goto _jump2068;
    // End body of loop
    int64_t _240 = _235 - _236;
    _a1_int64_t _241;
    _241.d0 = 2;
    _241.data = jpl_alloc(sizeof(int64_t) * 2);
    _241.data[0] = _234;
    _241.data[1] = _240;
    int64_t _242 = g(_241);
    if (_242 >= 0)
    goto _jump2069;
    fail_assertion("negative array index");
    _jump2069:;
    if (_242 < _208.d0)
    goto _jump2070;
    fail_assertion("index too large");
    _jump2070:;
    int64_t _243 = 0;
    _243 *= _208.d0;
    _243 += _242;
    bool _244 = _208.data[_243];
    int64_t _245;
    if (!_244)
    goto _jump2071;
    int64_t _246 = -l;
    _a1_int64_t _247;
    // Computing bound for p
    _247.d0 = j;
    if (j > 0) 
    goto _jump2072;
    fail_assertion("non-positive loop bound");
    _jump2072:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= j;
    _248 *= sizeof(int64_t);
    _247.data = jpl_alloc(_248);
    int64_t _249 = 0; // p
    _jump2073:; // Begin body of loop
    int64_t _250 = 0;
    _250 *= _247.d0;
    _250 += _249;
    _247.data[_250] = l;
    _249++;
    if (_249 < j)
    goto _jump2073;
    // End body of loop
    int64_t _251;
    // Computing bound for p
    int64_t _252 = n();
    if (_252 > 0) 
    goto _jump2074;
    fail_assertion("non-positive loop bound");
    _jump2074:;
    _251 = 0;
    int64_t _253 = 0; // p
    _jump2075:; // Begin body of loop
    _251 += l;
    _253++;
    if (_253 < _252)
    goto _jump2075;
    // End body of loop
    if (_251 >= 0)
    goto _jump2076;
    fail_assertion("negative array index");
    _jump2076:;
    if (_251 < _247.d0)
    goto _jump2077;
    fail_assertion("index too large");
    _jump2077:;
    int64_t _254 = 0;
    _254 *= _247.d0;
    _254 += _251;
    int64_t _255 = _247.data[_254];
    int64_t _256 = l * _255;
    _a1_int64_t _257;
    _257.d0 = 2;
    _257.data = jpl_alloc(sizeof(int64_t) * 2);
    _257.data[0] = _246;
    _257.data[1] = _256;
    int64_t _258 = g(_257);
    _245 = _258;
    goto _jump2078;
    _jump2071:;
    int64_t _259;
    // Computing bound for p
    int64_t _260;
    // Computing bound for p
    if (l > 0) 
    goto _jump2079;
    fail_assertion("non-positive loop bound");
    _jump2079:;
    _260 = 0;
    int64_t _261 = 0; // p
    _jump2080:; // Begin body of loop
    int64_t _262;
    // Computing bound for q
    int64_t _263 = n();
    _a1_int64_t _264;
    _264.d0 = 1;
    _264.data = jpl_alloc(sizeof(int64_t) * 1);
    _264.data[0] = _263;
    int64_t _265;
    // Computing bound for q
    if (_261 > 0) 
    goto _jump2081;
    fail_assertion("non-positive loop bound");
    _jump2081:;
    // Computing bound for r
    int64_t _266 = 338;
    int64_t _267 = j + _266;
    if (_267 > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing bound for s
    int64_t _268 = 138;
    int64_t _269 = 47;
    int64_t _270 = _268 - _269;
    if (_270 > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    _265 = 0;
    int64_t _271 = 0; // s
    int64_t _272 = 0; // r
    int64_t _273 = 0; // q
    _jump2084:; // Begin body of loop
    _265 += l;
    _271++;
    if (_271 < _270)
    goto _jump2084;
    _271 = 0;
    _272++;
    if (_272 < _267)
    goto _jump2084;
    _272 = 0;
    _273++;
    if (_273 < _261)
    goto _jump2084;
    // End body of loop
    if (_265 >= 0)
    goto _jump2085;
    fail_assertion("negative array index");
    _jump2085:;
    if (_265 < _264.d0)
    goto _jump2086;
    fail_assertion("index too large");
    _jump2086:;
    int64_t _274 = 0;
    _274 *= _264.d0;
    _274 += _265;
    int64_t _275 = _264.data[_274];
    if (_275 > 0) 
    goto _jump2087;
    fail_assertion("non-positive loop bound");
    _jump2087:;
    // Computing bound for r
    int64_t _276 = 331;
    if (_276 > 0) 
    goto _jump2088;
    fail_assertion("non-positive loop bound");
    _jump2088:;
    _262 = 0;
    int64_t _277 = 0; // r
    int64_t _278 = 0; // q
    _jump2089:; // Begin body of loop
    _262 += l;
    _277++;
    if (_277 < _276)
    goto _jump2089;
    _277 = 0;
    _278++;
    if (_278 < _275)
    goto _jump2089;
    // End body of loop
    _260 += _262;
    _261++;
    if (_261 < l)
    goto _jump2080;
    // End body of loop
    if (_260 > 0) 
    goto _jump2090;
    fail_assertion("non-positive loop bound");
    _jump2090:;
    _259 = 0;
    int64_t _279 = 0; // p
    _jump2091:; // Begin body of loop
    _a1_int64_t _280;
    if (!f)
    goto _jump2092;
    int64_t _281 = n();
    _a1_int64_t _282;
    _282.d0 = 2;
    _282.data = jpl_alloc(sizeof(int64_t) * 2);
    _282.data[0] = j;
    _282.data[1] = _281;
    _280 = _282;
    goto _jump2093;
    _jump2092:;
    _a1_int64_t _283;
    // Computing bound for q
    _283.d0 = _279;
    if (_279 > 0) 
    goto _jump2094;
    fail_assertion("non-positive loop bound");
    _jump2094:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _279;
    _284 *= sizeof(int64_t);
    _283.data = jpl_alloc(_284);
    int64_t _285 = 0; // q
    _jump2095:; // Begin body of loop
    int64_t _286 = 0;
    _286 *= _283.d0;
    _286 += _285;
    _283.data[_286] = _285;
    _285++;
    if (_285 < _279)
    goto _jump2095;
    // End body of loop
    _280 = _283;
    _jump2093:;
    int64_t _287 = g(_280);
    if (_287 >= 0)
    goto _jump2096;
    fail_assertion("negative array index");
    _jump2096:;
    if (_287 < i.d0)
    goto _jump2097;
    fail_assertion("index too large");
    _jump2097:;
    int64_t _288 = 0;
    _288 *= i.d0;
    _288 += _287;
    bool _289 = i.data[_288];
    int64_t _290;
    if (!_289)
    goto _jump2098;
    int64_t _291 = n();
    _290 = _291;
    goto _jump2099;
    _jump2098:;
    int64_t _292;
    // Computing bound for q
    int64_t _293 = 525;
    if (_293 > 0) 
    goto _jump2100;
    fail_assertion("non-positive loop bound");
    _jump2100:;
    // Computing bound for r
    int64_t _294;
    // Computing bound for q
    if (l > 0) 
    goto _jump2101;
    fail_assertion("non-positive loop bound");
    _jump2101:;
    _294 = 0;
    int64_t _295 = 0; // q
    _jump2102:; // Begin body of loop
    int64_t _296 = 49;
    _294 += _296;
    _295++;
    if (_295 < l)
    goto _jump2102;
    // End body of loop
    if (_294 > 0) 
    goto _jump2103;
    fail_assertion("non-positive loop bound");
    _jump2103:;
    _292 = 0;
    int64_t _297 = 0; // r
    int64_t _298 = 0; // q
    _jump2104:; // Begin body of loop
    int64_t _299 = n();
    int64_t _300 = _299 + l;
    _292 += _300;
    _297++;
    if (_297 < _294)
    goto _jump2104;
    _297 = 0;
    _298++;
    if (_298 < _293)
    goto _jump2104;
    // End body of loop
    _290 = _292;
    _jump2099:;
    _259 += _290;
    _279++;
    if (_279 < _260)
    goto _jump2091;
    // End body of loop
    _245 = _259;
    _jump2078:;
    return _245;
    _a3_bool _301;
    // Computing bound for p
    bool _302 = !a;
    bool _303;
    if (!_302)
    goto _jump2105;
    bool _304 = !b;
    _303 = _304;
    goto _jump2106;
    _jump2105:;
    bool _305 = false;
    bool _306 = !_305;
    _303 = _306;
    _jump2106:;
    _a1_int64_t _307;
    if (!_303)
    goto _jump2107;
    int64_t _308 = n();
    _a1_int64_t _309;
    _309.d0 = 1;
    _309.data = jpl_alloc(sizeof(int64_t) * 1);
    _309.data[0] = _308;
    _307 = _309;
    goto _jump2108;
    _jump2107:;
    _a1_int64_t _310;
    // Computing bound for p
    int64_t _311 = n();
    _310.d0 = _311;
    if (_311 > 0) 
    goto _jump2109;
    fail_assertion("non-positive loop bound");
    _jump2109:;
    // Computing total size of heap memory to allocate
    int64_t _312 = 1;
    _312 *= _311;
    _312 *= sizeof(int64_t);
    _310.data = jpl_alloc(_312);
    int64_t _313 = 0; // p
    _jump2110:; // Begin body of loop
    int64_t _314;
    // Computing bound for q
    int64_t _315 = n();
    if (_315 > 0) 
    goto _jump2111;
    fail_assertion("non-positive loop bound");
    _jump2111:;
    _314 = 0;
    int64_t _316 = 0; // q
    _jump2112:; // Begin body of loop
    _314 += _313;
    _316++;
    if (_316 < _315)
    goto _jump2112;
    // End body of loop
    int64_t _317 = 0;
    _317 *= _310.d0;
    _317 += _313;
    _310.data[_317] = _314;
    _313++;
    if (_313 < _311)
    goto _jump2110;
    // End body of loop
    _307 = _310;
    _jump2108:;
    int64_t _318 = g(_307);
    _301.d0 = _318;
    if (_318 > 0) 
    goto _jump2113;
    fail_assertion("non-positive loop bound");
    _jump2113:;
    // Computing bound for q
    int64_t _319 = j % j;
    int64_t _320 = _319 / j;
    _301.d1 = _320;
    if (_320 > 0) 
    goto _jump2114;
    fail_assertion("non-positive loop bound");
    _jump2114:;
    // Computing bound for r
    _301.d2 = l;
    if (l > 0) 
    goto _jump2115;
    fail_assertion("non-positive loop bound");
    _jump2115:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= _318;
    _321 *= _320;
    _321 *= l;
    _321 *= sizeof(bool);
    _301.data = jpl_alloc(_321);
    int64_t _322 = 0; // r
    int64_t _323 = 0; // q
    int64_t _324 = 0; // p
    _jump2116:; // Begin body of loop
    bool _325 = f;
    if (0 == f)
    goto _jump2117;
    _325 = f;
    _jump2117:;
    bool _326 = _325 == b;
    bool _327;
    if (!_326)
    goto _jump2118;
    _327 = a;
    goto _jump2119;
    _jump2118:;
    _a2_bool _328;
    // Computing bound for s
    _328.d0 = _324;
    if (_324 > 0) 
    goto _jump2120;
    fail_assertion("non-positive loop bound");
    _jump2120:;
    // Computing bound for t
    _328.d1 = _323;
    if (_323 > 0) 
    goto _jump2121;
    fail_assertion("non-positive loop bound");
    _jump2121:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _324;
    _329 *= _323;
    _329 *= sizeof(bool);
    _328.data = jpl_alloc(_329);
    int64_t _330 = 0; // t
    int64_t _331 = 0; // s
    _jump2122:; // Begin body of loop
    int64_t _332 = 0;
    _332 *= _328.d0;
    _332 += _331;
    _332 *= _328.d1;
    _332 += _330;
    _328.data[_332] = a;
    _330++;
    if (_330 < _323)
    goto _jump2122;
    _330 = 0;
    _331++;
    if (_331 < _324)
    goto _jump2122;
    // End body of loop
    int64_t _333 = n();
    if (_322 >= 0)
    goto _jump2123;
    fail_assertion("negative array index");
    _jump2123:;
    if (_322 < _328.d0)
    goto _jump2124;
    fail_assertion("index too large");
    _jump2124:;
    if (_333 >= 0)
    goto _jump2125;
    fail_assertion("negative array index");
    _jump2125:;
    if (_333 < _328.d1)
    goto _jump2126;
    fail_assertion("index too large");
    _jump2126:;
    int64_t _334 = 0;
    _334 *= _328.d0;
    _334 += _322;
    _334 *= _328.d1;
    _334 += _333;
    bool _335 = _328.data[_334];
    bool _336 = !_335;
    _327 = _336;
    _jump2119:;
    int64_t _337 = 0;
    _337 *= _301.d0;
    _337 += _324;
    _337 *= _301.d1;
    _337 += _323;
    _337 *= _301.d2;
    _337 += _322;
    _301.data[_337] = _327;
    _322++;
    if (_322 < l)
    goto _jump2116;
    _322 = 0;
    _323++;
    if (_323 < _320)
    goto _jump2116;
    _323 = 0;
    _324++;
    if (_324 < _318)
    goto _jump2116;
    // End body of loop
    _a2_int64_t _338;
    // Computing bound for p
    bool _339 = true;
    bool _340;
    if (!_339)
    goto _jump2127;
    bool _341 = false;
    _340 = _341;
    goto _jump2128;
    _jump2127:;
    _340 = b;
    _jump2128:;
    int64_t _342;
    if (!_340)
    goto _jump2129;
    bool _343 = true;
    int64_t _344;
    if (!_343)
    goto _jump2130;
    _344 = l;
    goto _jump2131;
    _jump2130:;
    int64_t _345 = 69;
    _344 = _345;
    _jump2131:;
    int64_t _346 = 941;
    int64_t _347 = _344 % _346;
    _342 = _347;
    goto _jump2132;
    _jump2129:;
    int64_t _348 = n();
    _342 = _348;
    _jump2132:;
    _338.d0 = _342;
    if (_342 > 0) 
    goto _jump2133;
    fail_assertion("non-positive loop bound");
    _jump2133:;
    // Computing bound for q
    int64_t _349 = 256;
    int64_t _350 = 627;
    _a1_int64_t _351;
    _351.d0 = 3;
    _351.data = jpl_alloc(sizeof(int64_t) * 3);
    _351.data[0] = l;
    _351.data[1] = _349;
    _351.data[2] = _350;
    int64_t _352 = g(_351);
    int64_t _353 = -_352;
    _338.d1 = _353;
    if (_353 > 0) 
    goto _jump2134;
    fail_assertion("non-positive loop bound");
    _jump2134:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= _342;
    _354 *= _353;
    _354 *= sizeof(int64_t);
    _338.data = jpl_alloc(_354);
    int64_t _355 = 0; // q
    int64_t _356 = 0; // p
    _jump2135:; // Begin body of loop
    int64_t _357 = 0;
    _357 *= _338.d0;
    _357 += _356;
    _357 *= _338.d1;
    _357 += _355;
    _338.data[_357] = _355;
    _355++;
    if (_355 < _353)
    goto _jump2135;
    _355 = 0;
    _356++;
    if (_356 < _342)
    goto _jump2135;
    // End body of loop
    bool _358 = !f;
    bool _359 = !_358;
    int64_t _360;
    if (!_359)
    goto _jump2136;
    _360 = l;
    goto _jump2137;
    _jump2136:;
    _a1_int64_t _361;
    // Computing bound for p
    int64_t _362 = 567;
    _361.d0 = _362;
    if (_362 > 0) 
    goto _jump2138;
    fail_assertion("non-positive loop bound");
    _jump2138:;
    // Computing total size of heap memory to allocate
    int64_t _363 = 1;
    _363 *= _362;
    _363 *= sizeof(int64_t);
    _361.data = jpl_alloc(_363);
    int64_t _364 = 0; // p
    _jump2139:; // Begin body of loop
    int64_t _365 = 357;
    int64_t _366 = _364 % _365;
    int64_t _367 = 0;
    _367 *= _361.d0;
    _367 += _364;
    _361.data[_367] = _366;
    _364++;
    if (_364 < _362)
    goto _jump2139;
    // End body of loop
    int64_t _368 = 658;
    int64_t _369 = j % _368;
    if (_369 >= 0)
    goto _jump2140;
    fail_assertion("negative array index");
    _jump2140:;
    if (_369 < _361.d0)
    goto _jump2141;
    fail_assertion("index too large");
    _jump2141:;
    int64_t _370 = 0;
    _370 *= _361.d0;
    _370 += _369;
    int64_t _371 = _361.data[_370];
    _360 = _371;
    _jump2137:;
    int64_t _372;
    // Computing bound for p
    int64_t _373 = n();
    if (_373 > 0) 
    goto _jump2142;
    fail_assertion("non-positive loop bound");
    _jump2142:;
    // Computing bound for q
    if (l > 0) 
    goto _jump2143;
    fail_assertion("non-positive loop bound");
    _jump2143:;
    _372 = 0;
    int64_t _374 = 0; // q
    int64_t _375 = 0; // p
    _jump2144:; // Begin body of loop
    _372 += _375;
    _374++;
    if (_374 < l)
    goto _jump2144;
    _374 = 0;
    _375++;
    if (_375 < _373)
    goto _jump2144;
    // End body of loop
    if (_360 >= 0)
    goto _jump2145;
    fail_assertion("negative array index");
    _jump2145:;
    if (_360 < _338.d0)
    goto _jump2146;
    fail_assertion("index too large");
    _jump2146:;
    if (_372 >= 0)
    goto _jump2147;
    fail_assertion("negative array index");
    _jump2147:;
    if (_372 < _338.d1)
    goto _jump2148;
    fail_assertion("index too large");
    _jump2148:;
    int64_t _376 = 0;
    _376 *= _338.d0;
    _376 += _360;
    _376 *= _338.d1;
    _376 += _372;
    int64_t _377 = _338.data[_376];
    bool _378 = true;
    _a1_int64_t _379;
    if (!_378)
    goto _jump2149;
    int64_t _380 = -j;
    int64_t _381 = j / _380;
    _a3_int64_t _382;
    // Computing bound for p
    int64_t _383 = 695;
    _382.d0 = _383;
    if (_383 > 0) 
    goto _jump2150;
    fail_assertion("non-positive loop bound");
    _jump2150:;
    // Computing bound for q
    _382.d1 = l;
    if (l > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    // Computing bound for r
    int64_t _384 = 286;
    _382.d2 = _384;
    if (_384 > 0) 
    goto _jump2152;
    fail_assertion("non-positive loop bound");
    _jump2152:;
    // Computing total size of heap memory to allocate
    int64_t _385 = 1;
    _385 *= _383;
    _385 *= l;
    _385 *= _384;
    _385 *= sizeof(int64_t);
    _382.data = jpl_alloc(_385);
    int64_t _386 = 0; // r
    int64_t _387 = 0; // q
    int64_t _388 = 0; // p
    _jump2153:; // Begin body of loop
    int64_t _389 = 0;
    _389 *= _382.d0;
    _389 += _388;
    _389 *= _382.d1;
    _389 += _387;
    _389 *= _382.d2;
    _389 += _386;
    _382.data[_389] = _388;
    _386++;
    if (_386 < _384)
    goto _jump2153;
    _386 = 0;
    _387++;
    if (_387 < l)
    goto _jump2153;
    _387 = 0;
    _388++;
    if (_388 < _383)
    goto _jump2153;
    // End body of loop
    int64_t _390 = -j;
    int64_t _391 = 806;
    int64_t _392 = -_391;
    int64_t _393 = n();
    if (_390 >= 0)
    goto _jump2154;
    fail_assertion("negative array index");
    _jump2154:;
    if (_390 < _382.d0)
    goto _jump2155;
    fail_assertion("index too large");
    _jump2155:;
    if (_392 >= 0)
    goto _jump2156;
    fail_assertion("negative array index");
    _jump2156:;
    if (_392 < _382.d1)
    goto _jump2157;
    fail_assertion("index too large");
    _jump2157:;
    if (_393 >= 0)
    goto _jump2158;
    fail_assertion("negative array index");
    _jump2158:;
    if (_393 < _382.d2)
    goto _jump2159;
    fail_assertion("index too large");
    _jump2159:;
    int64_t _394 = 0;
    _394 *= _382.d0;
    _394 += _390;
    _394 *= _382.d1;
    _394 += _392;
    _394 *= _382.d2;
    _394 += _393;
    int64_t _395 = _382.data[_394];
    int64_t _396 = n();
    int64_t _397 = _396 * j;
    int64_t _398 = n();
    int64_t _399 = _397 - _398;
    _a1_int64_t _400;
    _400.d0 = 3;
    _400.data = jpl_alloc(sizeof(int64_t) * 3);
    _400.data[0] = _381;
    _400.data[1] = _395;
    _400.data[2] = _399;
    _379 = _400;
    goto _jump2160;
    _jump2149:;
    _a1_int64_t _401;
    // Computing bound for p
    int64_t _402 = n();
    _401.d0 = _402;
    if (_402 > 0) 
    goto _jump2161;
    fail_assertion("non-positive loop bound");
    _jump2161:;
    // Computing total size of heap memory to allocate
    int64_t _403 = 1;
    _403 *= _402;
    _403 *= sizeof(int64_t);
    _401.data = jpl_alloc(_403);
    int64_t _404 = 0; // p
    _jump2162:; // Begin body of loop
    int64_t _405 = 0;
    _405 *= _401.d0;
    _405 += _404;
    _401.data[_405] = j;
    _404++;
    if (_404 < _402)
    goto _jump2162;
    // End body of loop
    int64_t _406 = g(_401);
    int64_t _407 = n();
    int64_t _408 = l * j;
    int64_t _409 = 769;
    int64_t _410 = _408 - _409;
    _a1_int64_t _411;
    _411.d0 = 3;
    _411.data = jpl_alloc(sizeof(int64_t) * 3);
    _411.data[0] = _406;
    _411.data[1] = _407;
    _411.data[2] = _410;
    _379 = _411;
    _jump2160:;
    int64_t _412 = g(_379);
    _a1_int64_t _413;
    // Computing bound for p
    _a3_int64_t _414;
    // Computing bound for p
    bool _415 = true;
    int64_t _416;
    if (!_415)
    goto _jump2163;
    int64_t _417 = 213;
    _416 = _417;
    goto _jump2164;
    _jump2163:;
    _416 = j;
    _jump2164:;
    _414.d0 = _416;
    if (_416 > 0) 
    goto _jump2165;
    fail_assertion("non-positive loop bound");
    _jump2165:;
    // Computing bound for q
    int64_t _418 = -l;
    _414.d1 = _418;
    if (_418 > 0) 
    goto _jump2166;
    fail_assertion("non-positive loop bound");
    _jump2166:;
    // Computing bound for r
    int64_t _419 = n();
    _414.d2 = _419;
    if (_419 > 0) 
    goto _jump2167;
    fail_assertion("non-positive loop bound");
    _jump2167:;
    // Computing total size of heap memory to allocate
    int64_t _420 = 1;
    _420 *= _416;
    _420 *= _418;
    _420 *= _419;
    _420 *= sizeof(int64_t);
    _414.data = jpl_alloc(_420);
    int64_t _421 = 0; // r
    int64_t _422 = 0; // q
    int64_t _423 = 0; // p
    _jump2168:; // Begin body of loop
    int64_t _424 = -j;
    int64_t _425 = 0;
    _425 *= _414.d0;
    _425 += _423;
    _425 *= _414.d1;
    _425 += _422;
    _425 *= _414.d2;
    _425 += _421;
    _414.data[_425] = _424;
    _421++;
    if (_421 < _419)
    goto _jump2168;
    _421 = 0;
    _422++;
    if (_422 < _418)
    goto _jump2168;
    _422 = 0;
    _423++;
    if (_423 < _416)
    goto _jump2168;
    // End body of loop
    int64_t _426 = n();
    int64_t _427 = -_426;
    int64_t _428 = -_427;
    bool _429 = b;
    if (0 == b)
    goto _jump2169;
    _429 = b;
    _jump2169:;
    int64_t _430;
    if (!_429)
    goto _jump2170;
    int64_t _431;
    if (!f)
    goto _jump2171;
    int64_t _432 = 271;
    _431 = _432;
    goto _jump2172;
    _jump2171:;
    int64_t _433 = n();
    _431 = _433;
    _jump2172:;
    _430 = _431;
    goto _jump2173;
    _jump2170:;
    int64_t _434 = 985;
    _430 = _434;
    _jump2173:;
    if (l >= 0)
    goto _jump2174;
    fail_assertion("negative array index");
    _jump2174:;
    if (l < _414.d0)
    goto _jump2175;
    fail_assertion("index too large");
    _jump2175:;
    if (_428 >= 0)
    goto _jump2176;
    fail_assertion("negative array index");
    _jump2176:;
    if (_428 < _414.d1)
    goto _jump2177;
    fail_assertion("index too large");
    _jump2177:;
    if (_430 >= 0)
    goto _jump2178;
    fail_assertion("negative array index");
    _jump2178:;
    if (_430 < _414.d2)
    goto _jump2179;
    fail_assertion("index too large");
    _jump2179:;
    int64_t _435 = 0;
    _435 *= _414.d0;
    _435 += l;
    _435 *= _414.d1;
    _435 += _428;
    _435 *= _414.d2;
    _435 += _430;
    int64_t _436 = _414.data[_435];
    _413.d0 = _436;
    if (_436 > 0) 
    goto _jump2180;
    fail_assertion("non-positive loop bound");
    _jump2180:;
    // Computing total size of heap memory to allocate
    int64_t _437 = 1;
    _437 *= _436;
    _437 *= sizeof(int64_t);
    _413.data = jpl_alloc(_437);
    int64_t _438 = 0; // p
    _jump2181:; // Begin body of loop
    int64_t _439 = 867;
    bool _440 = _438 < j;
    int64_t _441;
    if (!_440)
    goto _jump2182;
    int64_t _442;
    // Computing bound for q
    int64_t _443 = 482;
    if (_443 > 0) 
    goto _jump2183;
    fail_assertion("non-positive loop bound");
    _jump2183:;
    // Computing bound for r
    int64_t _444 = n();
    if (_444 > 0) 
    goto _jump2184;
    fail_assertion("non-positive loop bound");
    _jump2184:;
    // Computing bound for s
    if (j > 0) 
    goto _jump2185;
    fail_assertion("non-positive loop bound");
    _jump2185:;
    _442 = 0;
    int64_t _445 = 0; // s
    int64_t _446 = 0; // r
    int64_t _447 = 0; // q
    _jump2186:; // Begin body of loop
    int64_t _448 = 699;
    _442 += _448;
    _445++;
    if (_445 < j)
    goto _jump2186;
    _445 = 0;
    _446++;
    if (_446 < _444)
    goto _jump2186;
    _446 = 0;
    _447++;
    if (_447 < _443)
    goto _jump2186;
    // End body of loop
    _441 = _442;
    goto _jump2187;
    _jump2182:;
    _441 = j;
    _jump2187:;
    int64_t _449 = _439 - _441;
    int64_t _450 = 0;
    _450 *= _413.d0;
    _450 += _438;
    _413.data[_450] = _449;
    _438++;
    if (_438 < _436)
    goto _jump2181;
    // End body of loop
    int64_t _451 = g(_413);
    if (_377 >= 0)
    goto _jump2188;
    fail_assertion("negative array index");
    _jump2188:;
    if (_377 < _301.d0)
    goto _jump2189;
    fail_assertion("index too large");
    _jump2189:;
    if (_412 >= 0)
    goto _jump2190;
    fail_assertion("negative array index");
    _jump2190:;
    if (_412 < _301.d1)
    goto _jump2191;
    fail_assertion("index too large");
    _jump2191:;
    if (_451 >= 0)
    goto _jump2192;
    fail_assertion("negative array index");
    _jump2192:;
    if (_451 < _301.d2)
    goto _jump2193;
    fail_assertion("index too large");
    _jump2193:;
    int64_t _452 = 0;
    _452 *= _301.d0;
    _452 += _377;
    _452 *= _301.d1;
    _452 += _412;
    _452 *= _301.d2;
    _452 += _451;
    bool _453 = _301.data[_452];
    bool _454 = !_453;
    if (0 != _454)
    goto _jump2194;
    fail_assertion("p");
    _jump2194:;
    int64_t _455 = 292;
    _a1_int64_t _457;
    // Computing bound for q
    int64_t _458 = 938;
    _457.d0 = _458;
    if (_458 > 0) 
    goto _jump2195;
    fail_assertion("non-positive loop bound");
    _jump2195:;
    // Computing total size of heap memory to allocate
    int64_t _459 = 1;
    _459 *= _458;
    _459 *= sizeof(int64_t);
    _457.data = jpl_alloc(_459);
    int64_t _460 = 0; // q
    _jump2196:; // Begin body of loop
    int64_t _461 = n();
    int64_t _462 = n();
    int64_t _463 = _461 - _462;
    int64_t _464 = l * _463;
    int64_t _465 = 0;
    _465 *= _457.d0;
    _465 += _460;
    _457.data[_465] = _464;
    _460++;
    if (_460 < _458)
    goto _jump2196;
    // End body of loop
    int64_t _466 = g(_457);
    if (_466 >= 0)
    goto _jump2197;
    fail_assertion("negative array index");
    _jump2197:;
    if (_466 < k.d0)
    goto _jump2198;
    fail_assertion("index too large");
    _jump2198:;
    int64_t _467 = 0;
    _467 *= k.d0;
    _467 += _466;
    bool _468 = k.data[_467];
    bool _456 = _468;
    if (0 == _468)
    goto _jump2199;
    bool _469 = !b;
    _456 = _469;
    _jump2199:;
    _a3_bool _470;
    if (!_456)
    goto _jump2200;
    _a3_bool _471;
    if (!f)
    goto _jump2201;
    bool _472 = true;
    bool _473 = b == _472;
    _a3_bool _474;
    if (!_473)
    goto _jump2202;
    _a1__a3_bool _475;
    // Computing bound for q
    _a1_int64_t _476;
    // Computing bound for q
    int64_t _477 = 597;
    _476.d0 = _477;
    if (_477 > 0) 
    goto _jump2203;
    fail_assertion("non-positive loop bound");
    _jump2203:;
    // Computing total size of heap memory to allocate
    int64_t _478 = 1;
    _478 *= _477;
    _478 *= sizeof(int64_t);
    _476.data = jpl_alloc(_478);
    int64_t _479 = 0; // q
    _jump2204:; // Begin body of loop
    int64_t _480 = n();
    int64_t _481 = 0;
    _481 *= _476.d0;
    _481 += _479;
    _476.data[_481] = _480;
    _479++;
    if (_479 < _477)
    goto _jump2204;
    // End body of loop
    if (_455 >= 0)
    goto _jump2205;
    fail_assertion("negative array index");
    _jump2205:;
    if (_455 < _476.d0)
    goto _jump2206;
    fail_assertion("index too large");
    _jump2206:;
    int64_t _482 = 0;
    _482 *= _476.d0;
    _482 += _455;
    int64_t _483 = _476.data[_482];
    _475.d0 = _483;
    if (_483 > 0) 
    goto _jump2207;
    fail_assertion("non-positive loop bound");
    _jump2207:;
    // Computing total size of heap memory to allocate
    int64_t _484 = 1;
    _484 *= _483;
    _484 *= sizeof(_a3_bool);
    _475.data = jpl_alloc(_484);
    int64_t _485 = 0; // q
    _jump2208:; // Begin body of loop
    _a3_bool _486;
    // Computing bound for r
    int64_t _487 = -_455;
    _486.d0 = _487;
    if (_487 > 0) 
    goto _jump2209;
    fail_assertion("non-positive loop bound");
    _jump2209:;
    // Computing bound for s
    _486.d1 = l;
    if (l > 0) 
    goto _jump2210;
    fail_assertion("non-positive loop bound");
    _jump2210:;
    // Computing bound for t
    int64_t _488 = 955;
    _486.d2 = _488;
    if (_488 > 0) 
    goto _jump2211;
    fail_assertion("non-positive loop bound");
    _jump2211:;
    // Computing total size of heap memory to allocate
    int64_t _489 = 1;
    _489 *= _487;
    _489 *= l;
    _489 *= _488;
    _489 *= sizeof(bool);
    _486.data = jpl_alloc(_489);
    int64_t _490 = 0; // t
    int64_t _491 = 0; // s
    int64_t _492 = 0; // r
    _jump2212:; // Begin body of loop
    bool _493 = f;
    if (0 != f)
    goto _jump2213;
    bool _494 = false;
    _493 = _494;
    _jump2213:;
    int64_t _495 = 0;
    _495 *= _486.d0;
    _495 += _492;
    _495 *= _486.d1;
    _495 += _491;
    _495 *= _486.d2;
    _495 += _490;
    _486.data[_495] = _493;
    _490++;
    if (_490 < _488)
    goto _jump2212;
    _490 = 0;
    _491++;
    if (_491 < l)
    goto _jump2212;
    _491 = 0;
    _492++;
    if (_492 < _487)
    goto _jump2212;
    // End body of loop
    int64_t _496 = 0;
    _496 *= _475.d0;
    _496 += _485;
    _475.data[_496] = _486;
    _485++;
    if (_485 < _483)
    goto _jump2208;
    // End body of loop
    if (l >= 0)
    goto _jump2214;
    fail_assertion("negative array index");
    _jump2214:;
    if (l < _475.d0)
    goto _jump2215;
    fail_assertion("index too large");
    _jump2215:;
    int64_t _497 = 0;
    _497 *= _475.d0;
    _497 += l;
    _a3_bool _498 = _475.data[_497];
    _474 = _498;
    goto _jump2216;
    _jump2202:;
    _a3_bool _499;
    // Computing bound for q
    _499.d0 = _455;
    if (_455 > 0) 
    goto _jump2217;
    fail_assertion("non-positive loop bound");
    _jump2217:;
    // Computing bound for r
    int64_t _500;
    // Computing bound for q
    if (j > 0) 
    goto _jump2218;
    fail_assertion("non-positive loop bound");
    _jump2218:;
    // Computing bound for r
    int64_t _501 = n();
    int64_t _502 = -_501;
    if (_502 > 0) 
    goto _jump2219;
    fail_assertion("non-positive loop bound");
    _jump2219:;
    // Computing bound for s
    int64_t _503 = 886;
    if (_503 > 0) 
    goto _jump2220;
    fail_assertion("non-positive loop bound");
    _jump2220:;
    _500 = 0;
    int64_t _504 = 0; // s
    int64_t _505 = 0; // r
    int64_t _506 = 0; // q
    _jump2221:; // Begin body of loop
    _500 += _505;
    _504++;
    if (_504 < _503)
    goto _jump2221;
    _504 = 0;
    _505++;
    if (_505 < _502)
    goto _jump2221;
    _505 = 0;
    _506++;
    if (_506 < j)
    goto _jump2221;
    // End body of loop
    int64_t _507 = _455 * _500;
    _499.d1 = _507;
    if (_507 > 0) 
    goto _jump2222;
    fail_assertion("non-positive loop bound");
    _jump2222:;
    // Computing bound for s
    int64_t _508;
    // Computing bound for q
    if (j > 0) 
    goto _jump2223;
    fail_assertion("non-positive loop bound");
    _jump2223:;
    // Computing bound for r
    int64_t _509 = 794;
    int64_t _510 = _509 / j;
    int64_t _511 = -_510;
    if (_511 > 0) 
    goto _jump2224;
    fail_assertion("non-positive loop bound");
    _jump2224:;
    // Computing bound for s
    int64_t _512 = n();
    int64_t _513 = -_512;
    if (_513 > 0) 
    goto _jump2225;
    fail_assertion("non-positive loop bound");
    _jump2225:;
    _508 = 0;
    int64_t _514 = 0; // s
    int64_t _515 = 0; // r
    int64_t _516 = 0; // q
    _jump2226:; // Begin body of loop
    int64_t _517 = 950;
    _a1_int64_t _518;
    _518.d0 = 1;
    _518.data = jpl_alloc(sizeof(int64_t) * 1);
    _518.data[0] = _517;
    int64_t _519 = g(_518);
    _508 += _519;
    _514++;
    if (_514 < _513)
    goto _jump2226;
    _514 = 0;
    _515++;
    if (_515 < _511)
    goto _jump2226;
    _515 = 0;
    _516++;
    if (_516 < j)
    goto _jump2226;
    // End body of loop
    _499.d2 = _508;
    if (_508 > 0) 
    goto _jump2227;
    fail_assertion("non-positive loop bound");
    _jump2227:;
    // Computing total size of heap memory to allocate
    int64_t _520 = 1;
    _520 *= _455;
    _520 *= _507;
    _520 *= _508;
    _520 *= sizeof(bool);
    _499.data = jpl_alloc(_520);
    int64_t _521 = 0; // s
    int64_t _522 = 0; // r
    int64_t _523 = 0; // q
    _jump2228:; // Begin body of loop
    bool _524 = true;
    bool _525;
    if (!_524)
    goto _jump2229;
    bool _526 = true;
    bool _527;
    if (!_526)
    goto _jump2230;
    bool _528 = b;
    if (0 != b)
    goto _jump2231;
    bool _529 = false;
    _528 = _529;
    _jump2231:;
    _527 = _528;
    goto _jump2232;
    _jump2230:;
    _527 = b;
    _jump2232:;
    _525 = _527;
    goto _jump2233;
    _jump2229:;
    _525 = b;
    _jump2233:;
    int64_t _530 = 0;
    _530 *= _499.d0;
    _530 += _523;
    _530 *= _499.d1;
    _530 += _522;
    _530 *= _499.d2;
    _530 += _521;
    _499.data[_530] = _525;
    _521++;
    if (_521 < _508)
    goto _jump2228;
    _521 = 0;
    _522++;
    if (_522 < _507)
    goto _jump2228;
    _522 = 0;
    _523++;
    if (_523 < _455)
    goto _jump2228;
    // End body of loop
    _474 = _499;
    _jump2216:;
    _471 = _474;
    goto _jump2234;
    _jump2201:;
    _a3_bool _531;
    if (!a)
    goto _jump2235;
    _a3_bool _532;
    // Computing bound for q
    _532.d0 = j;
    if (j > 0) 
    goto _jump2236;
    fail_assertion("non-positive loop bound");
    _jump2236:;
    // Computing bound for r
    int64_t _533 = 628;
    int64_t _534 = -_533;
    _532.d1 = _534;
    if (_534 > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    // Computing bound for s
    int64_t _535 = n();
    _532.d2 = _535;
    if (_535 > 0) 
    goto _jump2238;
    fail_assertion("non-positive loop bound");
    _jump2238:;
    // Computing total size of heap memory to allocate
    int64_t _536 = 1;
    _536 *= j;
    _536 *= _534;
    _536 *= _535;
    _536 *= sizeof(bool);
    _532.data = jpl_alloc(_536);
    int64_t _537 = 0; // s
    int64_t _538 = 0; // r
    int64_t _539 = 0; // q
    _jump2239:; // Begin body of loop
    int64_t _540 = 0;
    _540 *= _532.d0;
    _540 += _539;
    _540 *= _532.d1;
    _540 += _538;
    _540 *= _532.d2;
    _540 += _537;
    _532.data[_540] = f;
    _537++;
    if (_537 < _535)
    goto _jump2239;
    _537 = 0;
    _538++;
    if (_538 < _534)
    goto _jump2239;
    _538 = 0;
    _539++;
    if (_539 < j)
    goto _jump2239;
    // End body of loop
    int64_t _541 = -_455;
    if (_541 >= 0)
    goto _jump2240;
    fail_assertion("negative array index");
    _jump2240:;
    if (_541 < _532.d0)
    goto _jump2241;
    fail_assertion("index too large");
    _jump2241:;
    if (j >= 0)
    goto _jump2242;
    fail_assertion("negative array index");
    _jump2242:;
    if (j < _532.d1)
    goto _jump2243;
    fail_assertion("index too large");
    _jump2243:;
    if (l >= 0)
    goto _jump2244;
    fail_assertion("negative array index");
    _jump2244:;
    if (l < _532.d2)
    goto _jump2245;
    fail_assertion("index too large");
    _jump2245:;
    int64_t _542 = 0;
    _542 *= _532.d0;
    _542 += _541;
    _542 *= _532.d1;
    _542 += j;
    _542 *= _532.d2;
    _542 += l;
    bool _543 = _532.data[_542];
    _a3_bool _544;
    if (!_543)
    goto _jump2246;
    _a3_bool _545;
    if (!a)
    goto _jump2247;
    _a3_bool _546;
    // Computing bound for q
    int64_t _547;
    // Computing bound for q
    if (l > 0) 
    goto _jump2248;
    fail_assertion("non-positive loop bound");
    _jump2248:;
    // Computing bound for r
    int64_t _548 = n();
    if (_548 > 0) 
    goto _jump2249;
    fail_assertion("non-positive loop bound");
    _jump2249:;
    _547 = 0;
    int64_t _549 = 0; // r
    int64_t _550 = 0; // q
    _jump2250:; // Begin body of loop
    _547 += l;
    _549++;
    if (_549 < _548)
    goto _jump2250;
    _549 = 0;
    _550++;
    if (_550 < l)
    goto _jump2250;
    // End body of loop
    _546.d0 = _547;
    if (_547 > 0) 
    goto _jump2251;
    fail_assertion("non-positive loop bound");
    _jump2251:;
    // Computing bound for r
    int64_t _551 = 593;
    _546.d1 = _551;
    if (_551 > 0) 
    goto _jump2252;
    fail_assertion("non-positive loop bound");
    _jump2252:;
    // Computing bound for s
    _546.d2 = j;
    if (j > 0) 
    goto _jump2253;
    fail_assertion("non-positive loop bound");
    _jump2253:;
    // Computing total size of heap memory to allocate
    int64_t _552 = 1;
    _552 *= _547;
    _552 *= _551;
    _552 *= j;
    _552 *= sizeof(bool);
    _546.data = jpl_alloc(_552);
    int64_t _553 = 0; // s
    int64_t _554 = 0; // r
    int64_t _555 = 0; // q
    _jump2254:; // Begin body of loop
    bool _556 = false;
    int64_t _557 = 0;
    _557 *= _546.d0;
    _557 += _555;
    _557 *= _546.d1;
    _557 += _554;
    _557 *= _546.d2;
    _557 += _553;
    _546.data[_557] = _556;
    _553++;
    if (_553 < j)
    goto _jump2254;
    _553 = 0;
    _554++;
    if (_554 < _551)
    goto _jump2254;
    _554 = 0;
    _555++;
    if (_555 < _547)
    goto _jump2254;
    // End body of loop
    _545 = _546;
    goto _jump2255;
    _jump2247:;
    _a3_bool _558;
    // Computing bound for q
    _558.d0 = j;
    if (j > 0) 
    goto _jump2256;
    fail_assertion("non-positive loop bound");
    _jump2256:;
    // Computing bound for r
    _558.d1 = l;
    if (l > 0) 
    goto _jump2257;
    fail_assertion("non-positive loop bound");
    _jump2257:;
    // Computing bound for s
    _558.d2 = _455;
    if (_455 > 0) 
    goto _jump2258;
    fail_assertion("non-positive loop bound");
    _jump2258:;
    // Computing total size of heap memory to allocate
    int64_t _559 = 1;
    _559 *= j;
    _559 *= l;
    _559 *= _455;
    _559 *= sizeof(bool);
    _558.data = jpl_alloc(_559);
    int64_t _560 = 0; // s
    int64_t _561 = 0; // r
    int64_t _562 = 0; // q
    _jump2259:; // Begin body of loop
    int64_t _563 = 0;
    _563 *= _558.d0;
    _563 += _562;
    _563 *= _558.d1;
    _563 += _561;
    _563 *= _558.d2;
    _563 += _560;
    _558.data[_563] = a;
    _560++;
    if (_560 < _455)
    goto _jump2259;
    _560 = 0;
    _561++;
    if (_561 < l)
    goto _jump2259;
    _561 = 0;
    _562++;
    if (_562 < j)
    goto _jump2259;
    // End body of loop
    _545 = _558;
    _jump2255:;
    _544 = _545;
    goto _jump2260;
    _jump2246:;
    _a2__a3_bool _564;
    // Computing bound for q
    _564.d0 = j;
    if (j > 0) 
    goto _jump2261;
    fail_assertion("non-positive loop bound");
    _jump2261:;
    // Computing bound for r
    int64_t _565 = -j;
    _564.d1 = _565;
    if (_565 > 0) 
    goto _jump2262;
    fail_assertion("non-positive loop bound");
    _jump2262:;
    // Computing total size of heap memory to allocate
    int64_t _566 = 1;
    _566 *= j;
    _566 *= _565;
    _566 *= sizeof(_a3_bool);
    _564.data = jpl_alloc(_566);
    int64_t _567 = 0; // r
    int64_t _568 = 0; // q
    _jump2263:; // Begin body of loop
    _a3_bool _569;
    // Computing bound for s
    _569.d0 = j;
    if (j > 0) 
    goto _jump2264;
    fail_assertion("non-positive loop bound");
    _jump2264:;
    // Computing bound for t
    _569.d1 = j;
    if (j > 0) 
    goto _jump2265;
    fail_assertion("non-positive loop bound");
    _jump2265:;
    // Computing bound for u
    _569.d2 = _568;
    if (_568 > 0) 
    goto _jump2266;
    fail_assertion("non-positive loop bound");
    _jump2266:;
    // Computing total size of heap memory to allocate
    int64_t _570 = 1;
    _570 *= j;
    _570 *= j;
    _570 *= _568;
    _570 *= sizeof(bool);
    _569.data = jpl_alloc(_570);
    int64_t _571 = 0; // u
    int64_t _572 = 0; // t
    int64_t _573 = 0; // s
    _jump2267:; // Begin body of loop
    int64_t _574 = 0;
    _574 *= _569.d0;
    _574 += _573;
    _574 *= _569.d1;
    _574 += _572;
    _574 *= _569.d2;
    _574 += _571;
    _569.data[_574] = f;
    _571++;
    if (_571 < _568)
    goto _jump2267;
    _571 = 0;
    _572++;
    if (_572 < j)
    goto _jump2267;
    _572 = 0;
    _573++;
    if (_573 < j)
    goto _jump2267;
    // End body of loop
    int64_t _575 = 0;
    _575 *= _564.d0;
    _575 += _568;
    _575 *= _564.d1;
    _575 += _567;
    _564.data[_575] = _569;
    _567++;
    if (_567 < _565)
    goto _jump2263;
    _567 = 0;
    _568++;
    if (_568 < j)
    goto _jump2263;
    // End body of loop
    int64_t _576 = 915;
    bool _577 = !f;
    int64_t _578;
    if (!_577)
    goto _jump2268;
    _578 = j;
    goto _jump2269;
    _jump2268:;
    int64_t _579 = n();
    _578 = _579;
    _jump2269:;
    if (_576 >= 0)
    goto _jump2270;
    fail_assertion("negative array index");
    _jump2270:;
    if (_576 < _564.d0)
    goto _jump2271;
    fail_assertion("index too large");
    _jump2271:;
    if (_578 >= 0)
    goto _jump2272;
    fail_assertion("negative array index");
    _jump2272:;
    if (_578 < _564.d1)
    goto _jump2273;
    fail_assertion("index too large");
    _jump2273:;
    int64_t _580 = 0;
    _580 *= _564.d0;
    _580 += _576;
    _580 *= _564.d1;
    _580 += _578;
    _a3_bool _581 = _564.data[_580];
    _544 = _581;
    _jump2260:;
    _531 = _544;
    goto _jump2274;
    _jump2235:;
    _a2__a3_bool _582;
    if (!f)
    goto _jump2275;
    _a2__a3_bool _583;
    // Computing bound for q
    int64_t _584 = 248;
    int64_t _585 = 270;
    int64_t _586 = _584 - _585;
    _583.d0 = _586;
    if (_586 > 0) 
    goto _jump2276;
    fail_assertion("non-positive loop bound");
    _jump2276:;
    // Computing bound for r
    int64_t _587 = 565;
    int64_t _588 = l % _587;
    _583.d1 = _588;
    if (_588 > 0) 
    goto _jump2277;
    fail_assertion("non-positive loop bound");
    _jump2277:;
    // Computing total size of heap memory to allocate
    int64_t _589 = 1;
    _589 *= _586;
    _589 *= _588;
    _589 *= sizeof(_a3_bool);
    _583.data = jpl_alloc(_589);
    int64_t _590 = 0; // r
    int64_t _591 = 0; // q
    _jump2278:; // Begin body of loop
    _a3_bool _592;
    // Computing bound for s
    _592.d0 = _590;
    if (_590 > 0) 
    goto _jump2279;
    fail_assertion("non-positive loop bound");
    _jump2279:;
    // Computing bound for t
    int64_t _593 = n();
    _592.d1 = _593;
    if (_593 > 0) 
    goto _jump2280;
    fail_assertion("non-positive loop bound");
    _jump2280:;
    // Computing bound for u
    _592.d2 = _455;
    if (_455 > 0) 
    goto _jump2281;
    fail_assertion("non-positive loop bound");
    _jump2281:;
    // Computing total size of heap memory to allocate
    int64_t _594 = 1;
    _594 *= _590;
    _594 *= _593;
    _594 *= _455;
    _594 *= sizeof(bool);
    _592.data = jpl_alloc(_594);
    int64_t _595 = 0; // u
    int64_t _596 = 0; // t
    int64_t _597 = 0; // s
    _jump2282:; // Begin body of loop
    bool _598 = true;
    int64_t _599 = 0;
    _599 *= _592.d0;
    _599 += _597;
    _599 *= _592.d1;
    _599 += _596;
    _599 *= _592.d2;
    _599 += _595;
    _592.data[_599] = _598;
    _595++;
    if (_595 < _455)
    goto _jump2282;
    _595 = 0;
    _596++;
    if (_596 < _593)
    goto _jump2282;
    _596 = 0;
    _597++;
    if (_597 < _590)
    goto _jump2282;
    // End body of loop
    int64_t _600 = 0;
    _600 *= _583.d0;
    _600 += _591;
    _600 *= _583.d1;
    _600 += _590;
    _583.data[_600] = _592;
    _590++;
    if (_590 < _588)
    goto _jump2278;
    _590 = 0;
    _591++;
    if (_591 < _586)
    goto _jump2278;
    // End body of loop
    _582 = _583;
    goto _jump2283;
    _jump2275:;
    _a2__a3_bool _601;
    // Computing bound for q
    _601.d0 = _455;
    if (_455 > 0) 
    goto _jump2284;
    fail_assertion("non-positive loop bound");
    _jump2284:;
    // Computing bound for r
    _601.d1 = j;
    if (j > 0) 
    goto _jump2285;
    fail_assertion("non-positive loop bound");
    _jump2285:;
    // Computing total size of heap memory to allocate
    int64_t _602 = 1;
    _602 *= _455;
    _602 *= j;
    _602 *= sizeof(_a3_bool);
    _601.data = jpl_alloc(_602);
    int64_t _603 = 0; // r
    int64_t _604 = 0; // q
    _jump2286:; // Begin body of loop
    _a3_bool _605;
    // Computing bound for s
    _605.d0 = _604;
    if (_604 > 0) 
    goto _jump2287;
    fail_assertion("non-positive loop bound");
    _jump2287:;
    // Computing bound for t
    int64_t _606 = n();
    _605.d1 = _606;
    if (_606 > 0) 
    goto _jump2288;
    fail_assertion("non-positive loop bound");
    _jump2288:;
    // Computing bound for u
    _605.d2 = l;
    if (l > 0) 
    goto _jump2289;
    fail_assertion("non-positive loop bound");
    _jump2289:;
    // Computing total size of heap memory to allocate
    int64_t _607 = 1;
    _607 *= _604;
    _607 *= _606;
    _607 *= l;
    _607 *= sizeof(bool);
    _605.data = jpl_alloc(_607);
    int64_t _608 = 0; // u
    int64_t _609 = 0; // t
    int64_t _610 = 0; // s
    _jump2290:; // Begin body of loop
    bool _611 = true;
    int64_t _612 = 0;
    _612 *= _605.d0;
    _612 += _610;
    _612 *= _605.d1;
    _612 += _609;
    _612 *= _605.d2;
    _612 += _608;
    _605.data[_612] = _611;
    _608++;
    if (_608 < l)
    goto _jump2290;
    _608 = 0;
    _609++;
    if (_609 < _606)
    goto _jump2290;
    _609 = 0;
    _610++;
    if (_610 < _604)
    goto _jump2290;
    // End body of loop
    int64_t _613 = 0;
    _613 *= _601.d0;
    _613 += _604;
    _613 *= _601.d1;
    _613 += _603;
    _601.data[_613] = _605;
    _603++;
    if (_603 < j)
    goto _jump2286;
    _603 = 0;
    _604++;
    if (_604 < _455)
    goto _jump2286;
    // End body of loop
    _582 = _601;
    _jump2283:;
    int64_t _614;
    // Computing bound for q
    int64_t _615;
    // Computing bound for q
    int64_t _616;
    if (!f)
    goto _jump2291;
    _616 = l;
    goto _jump2292;
    _jump2291:;
    int64_t _617 = 699;
    _616 = _617;
    _jump2292:;
    if (_616 > 0) 
    goto _jump2293;
    fail_assertion("non-positive loop bound");
    _jump2293:;
    // Computing bound for r
    if (j > 0) 
    goto _jump2294;
    fail_assertion("non-positive loop bound");
    _jump2294:;
    _615 = 0;
    int64_t _618 = 0; // r
    int64_t _619 = 0; // q
    _jump2295:; // Begin body of loop
    _615 += _619;
    _618++;
    if (_618 < j)
    goto _jump2295;
    _618 = 0;
    _619++;
    if (_619 < _616)
    goto _jump2295;
    // End body of loop
    if (_615 > 0) 
    goto _jump2296;
    fail_assertion("non-positive loop bound");
    _jump2296:;
    _614 = 0;
    int64_t _620 = 0; // q
    _jump2297:; // Begin body of loop
    bool _621 = f;
    if (0 != f)
    goto _jump2298;
    bool _622 = false;
    _621 = _622;
    _jump2298:;
    int64_t _623;
    if (!_621)
    goto _jump2299;
    _623 = j;
    goto _jump2300;
    _jump2299:;
    _623 = _455;
    _jump2300:;
    _614 += _623;
    _620++;
    if (_620 < _615)
    goto _jump2297;
    // End body of loop
    int64_t _624 = 979;
    int64_t _625;
    if (!a)
    goto _jump2301;
    _625 = j;
    goto _jump2302;
    _jump2301:;
    int64_t _626 = n();
    _625 = _626;
    _jump2302:;
    int64_t _627 = _624 / _625;
    if (_614 >= 0)
    goto _jump2303;
    fail_assertion("negative array index");
    _jump2303:;
    if (_614 < _582.d0)
    goto _jump2304;
    fail_assertion("index too large");
    _jump2304:;
    if (_627 >= 0)
    goto _jump2305;
    fail_assertion("negative array index");
    _jump2305:;
    if (_627 < _582.d1)
    goto _jump2306;
    fail_assertion("index too large");
    _jump2306:;
    int64_t _628 = 0;
    _628 *= _582.d0;
    _628 += _614;
    _628 *= _582.d1;
    _628 += _627;
    _a3_bool _629 = _582.data[_628];
    _531 = _629;
    _jump2274:;
    _471 = _531;
    _jump2234:;
    _470 = _471;
    goto _jump2307;
    _jump2200:;
    _a3__a3_bool _630;
    // Computing bound for q
    int64_t _631 = 11;
    _630.d0 = _631;
    if (_631 > 0) 
    goto _jump2308;
    fail_assertion("non-positive loop bound");
    _jump2308:;
    // Computing bound for r
    int64_t _632;
    // Computing bound for q
    int64_t _633 = n();
    if (_633 > 0) 
    goto _jump2309;
    fail_assertion("non-positive loop bound");
    _jump2309:;
    _632 = 0;
    int64_t _634 = 0; // q
    _jump2310:; // Begin body of loop
    int64_t _635 = n();
    _632 += _635;
    _634++;
    if (_634 < _633)
    goto _jump2310;
    // End body of loop
    _630.d1 = _632;
    if (_632 > 0) 
    goto _jump2311;
    fail_assertion("non-positive loop bound");
    _jump2311:;
    // Computing bound for s
    _a1_int64_t _636;
    // Computing bound for q
    _636.d0 = j;
    if (j > 0) 
    goto _jump2312;
    fail_assertion("non-positive loop bound");
    _jump2312:;
    // Computing total size of heap memory to allocate
    int64_t _637 = 1;
    _637 *= j;
    _637 *= sizeof(int64_t);
    _636.data = jpl_alloc(_637);
    int64_t _638 = 0; // q
    _jump2313:; // Begin body of loop
    int64_t _639;
    // Computing bound for r
    if (_455 > 0) 
    goto _jump2314;
    fail_assertion("non-positive loop bound");
    _jump2314:;
    // Computing bound for s
    if (_455 > 0) 
    goto _jump2315;
    fail_assertion("non-positive loop bound");
    _jump2315:;
    _639 = 0;
    int64_t _640 = 0; // s
    int64_t _641 = 0; // r
    _jump2316:; // Begin body of loop
    int64_t _642 = _455 - _640;
    _639 += _642;
    _640++;
    if (_640 < _455)
    goto _jump2316;
    _640 = 0;
    _641++;
    if (_641 < _455)
    goto _jump2316;
    // End body of loop
    int64_t _643 = 0;
    _643 *= _636.d0;
    _643 += _638;
    _636.data[_643] = _639;
    _638++;
    if (_638 < j)
    goto _jump2313;
    // End body of loop
    int64_t _644 = g(_636);
    _630.d2 = _644;
    if (_644 > 0) 
    goto _jump2317;
    fail_assertion("non-positive loop bound");
    _jump2317:;
    // Computing total size of heap memory to allocate
    int64_t _645 = 1;
    _645 *= _631;
    _645 *= _632;
    _645 *= _644;
    _645 *= sizeof(_a3_bool);
    _630.data = jpl_alloc(_645);
    int64_t _646 = 0; // s
    int64_t _647 = 0; // r
    int64_t _648 = 0; // q
    _jump2318:; // Begin body of loop
    double _649 = 83.0;
    double _650 = -_649;
    bool _651 = _650 < _207;
    _a3__a3_bool _652;
    if (!_651)
    goto _jump2319;
    _a3__a3_bool _653;
    // Computing bound for t
    int64_t _654 = 972;
    _653.d0 = _654;
    if (_654 > 0) 
    goto _jump2320;
    fail_assertion("non-positive loop bound");
    _jump2320:;
    // Computing bound for u
    int64_t _655 = n();
    _653.d1 = _655;
    if (_655 > 0) 
    goto _jump2321;
    fail_assertion("non-positive loop bound");
    _jump2321:;
    // Computing bound for v
    _653.d2 = _647;
    if (_647 > 0) 
    goto _jump2322;
    fail_assertion("non-positive loop bound");
    _jump2322:;
    // Computing total size of heap memory to allocate
    int64_t _656 = 1;
    _656 *= _654;
    _656 *= _655;
    _656 *= _647;
    _656 *= sizeof(_a3_bool);
    _653.data = jpl_alloc(_656);
    int64_t _657 = 0; // v
    int64_t _658 = 0; // u
    int64_t _659 = 0; // t
    _jump2323:; // Begin body of loop
    _a3_bool _660;
    // Computing bound for w
    _660.d0 = _658;
    if (_658 > 0) 
    goto _jump2324;
    fail_assertion("non-positive loop bound");
    _jump2324:;
    // Computing bound for x
    _660.d1 = _647;
    if (_647 > 0) 
    goto _jump2325;
    fail_assertion("non-positive loop bound");
    _jump2325:;
    // Computing bound for y
    int64_t _661 = 869;
    _660.d2 = _661;
    if (_661 > 0) 
    goto _jump2326;
    fail_assertion("non-positive loop bound");
    _jump2326:;
    // Computing total size of heap memory to allocate
    int64_t _662 = 1;
    _662 *= _658;
    _662 *= _647;
    _662 *= _661;
    _662 *= sizeof(bool);
    _660.data = jpl_alloc(_662);
    int64_t _663 = 0; // y
    int64_t _664 = 0; // x
    int64_t _665 = 0; // w
    _jump2327:; // Begin body of loop
    int64_t _666 = 0;
    _666 *= _660.d0;
    _666 += _665;
    _666 *= _660.d1;
    _666 += _664;
    _666 *= _660.d2;
    _666 += _663;
    _660.data[_666] = a;
    _663++;
    if (_663 < _661)
    goto _jump2327;
    _663 = 0;
    _664++;
    if (_664 < _647)
    goto _jump2327;
    _664 = 0;
    _665++;
    if (_665 < _658)
    goto _jump2327;
    // End body of loop
    int64_t _667 = 0;
    _667 *= _653.d0;
    _667 += _659;
    _667 *= _653.d1;
    _667 += _658;
    _667 *= _653.d2;
    _667 += _657;
    _653.data[_667] = _660;
    _657++;
    if (_657 < _647)
    goto _jump2323;
    _657 = 0;
    _658++;
    if (_658 < _655)
    goto _jump2323;
    _658 = 0;
    _659++;
    if (_659 < _654)
    goto _jump2323;
    // End body of loop
    _652 = _653;
    goto _jump2328;
    _jump2319:;
    _a3__a3_bool _668;
    // Computing bound for t
    bool _669 = true;
    int64_t _670;
    if (!_669)
    goto _jump2329;
    int64_t _671 = n();
    _670 = _671;
    goto _jump2330;
    _jump2329:;
    _670 = l;
    _jump2330:;
    _668.d0 = _670;
    if (_670 > 0) 
    goto _jump2331;
    fail_assertion("non-positive loop bound");
    _jump2331:;
    // Computing bound for u
    int64_t _672;
    // Computing bound for t
    if (_647 > 0) 
    goto _jump2332;
    fail_assertion("non-positive loop bound");
    _jump2332:;
    // Computing bound for u
    if (_647 > 0) 
    goto _jump2333;
    fail_assertion("non-positive loop bound");
    _jump2333:;
    // Computing bound for v
    int64_t _673 = n();
    if (_673 > 0) 
    goto _jump2334;
    fail_assertion("non-positive loop bound");
    _jump2334:;
    _672 = 0;
    int64_t _674 = 0; // v
    int64_t _675 = 0; // u
    int64_t _676 = 0; // t
    _jump2335:; // Begin body of loop
    _672 += _455;
    _674++;
    if (_674 < _673)
    goto _jump2335;
    _674 = 0;
    _675++;
    if (_675 < _647)
    goto _jump2335;
    _675 = 0;
    _676++;
    if (_676 < _647)
    goto _jump2335;
    // End body of loop
    _668.d1 = _672;
    if (_672 > 0) 
    goto _jump2336;
    fail_assertion("non-positive loop bound");
    _jump2336:;
    // Computing bound for v
    int64_t _677 = -l;
    _668.d2 = _677;
    if (_677 > 0) 
    goto _jump2337;
    fail_assertion("non-positive loop bound");
    _jump2337:;
    // Computing total size of heap memory to allocate
    int64_t _678 = 1;
    _678 *= _670;
    _678 *= _672;
    _678 *= _677;
    _678 *= sizeof(_a3_bool);
    _668.data = jpl_alloc(_678);
    int64_t _679 = 0; // v
    int64_t _680 = 0; // u
    int64_t _681 = 0; // t
    _jump2338:; // Begin body of loop
    _a3_bool _682;
    // Computing bound for w
    _682.d0 = _679;
    if (_679 > 0) 
    goto _jump2339;
    fail_assertion("non-positive loop bound");
    _jump2339:;
    // Computing bound for x
    _682.d1 = _648;
    if (_648 > 0) 
    goto _jump2340;
    fail_assertion("non-positive loop bound");
    _jump2340:;
    // Computing bound for y
    _682.d2 = _648;
    if (_648 > 0) 
    goto _jump2341;
    fail_assertion("non-positive loop bound");
    _jump2341:;
    // Computing total size of heap memory to allocate
    int64_t _683 = 1;
    _683 *= _679;
    _683 *= _648;
    _683 *= _648;
    _683 *= sizeof(bool);
    _682.data = jpl_alloc(_683);
    int64_t _684 = 0; // y
    int64_t _685 = 0; // x
    int64_t _686 = 0; // w
    _jump2342:; // Begin body of loop
    int64_t _687 = 0;
    _687 *= _682.d0;
    _687 += _686;
    _687 *= _682.d1;
    _687 += _685;
    _687 *= _682.d2;
    _687 += _684;
    _682.data[_687] = f;
    _684++;
    if (_684 < _648)
    goto _jump2342;
    _684 = 0;
    _685++;
    if (_685 < _648)
    goto _jump2342;
    _685 = 0;
    _686++;
    if (_686 < _679)
    goto _jump2342;
    // End body of loop
    int64_t _688 = 0;
    _688 *= _668.d0;
    _688 += _681;
    _688 *= _668.d1;
    _688 += _680;
    _688 *= _668.d2;
    _688 += _679;
    _668.data[_688] = _682;
    _679++;
    if (_679 < _677)
    goto _jump2338;
    _679 = 0;
    _680++;
    if (_680 < _672)
    goto _jump2338;
    _680 = 0;
    _681++;
    if (_681 < _670)
    goto _jump2338;
    // End body of loop
    _652 = _668;
    _jump2328:;
    int64_t _689 = n();
    bool _690 = _646 != _689;
    _a2_int64_t _691;
    if (!_690)
    goto _jump2343;
    _a2_int64_t _692;
    // Computing bound for t
    _692.d0 = _647;
    if (_647 > 0) 
    goto _jump2344;
    fail_assertion("non-positive loop bound");
    _jump2344:;
    // Computing bound for u
    _692.d1 = j;
    if (j > 0) 
    goto _jump2345;
    fail_assertion("non-positive loop bound");
    _jump2345:;
    // Computing total size of heap memory to allocate
    int64_t _693 = 1;
    _693 *= _647;
    _693 *= j;
    _693 *= sizeof(int64_t);
    _692.data = jpl_alloc(_693);
    int64_t _694 = 0; // u
    int64_t _695 = 0; // t
    _jump2346:; // Begin body of loop
    int64_t _696 = 0;
    _696 *= _692.d0;
    _696 += _695;
    _696 *= _692.d1;
    _696 += _694;
    _692.data[_696] = _647;
    _694++;
    if (_694 < j)
    goto _jump2346;
    _694 = 0;
    _695++;
    if (_695 < _647)
    goto _jump2346;
    // End body of loop
    _691 = _692;
    goto _jump2347;
    _jump2343:;
    _a2_int64_t _697;
    // Computing bound for t
    _697.d0 = _646;
    if (_646 > 0) 
    goto _jump2348;
    fail_assertion("non-positive loop bound");
    _jump2348:;
    // Computing bound for u
    _697.d1 = l;
    if (l > 0) 
    goto _jump2349;
    fail_assertion("non-positive loop bound");
    _jump2349:;
    // Computing total size of heap memory to allocate
    int64_t _698 = 1;
    _698 *= _646;
    _698 *= l;
    _698 *= sizeof(int64_t);
    _697.data = jpl_alloc(_698);
    int64_t _699 = 0; // u
    int64_t _700 = 0; // t
    _jump2350:; // Begin body of loop
    int64_t _701 = 210;
    int64_t _702 = 0;
    _702 *= _697.d0;
    _702 += _700;
    _702 *= _697.d1;
    _702 += _699;
    _697.data[_702] = _701;
    _699++;
    if (_699 < l)
    goto _jump2350;
    _699 = 0;
    _700++;
    if (_700 < _646)
    goto _jump2350;
    // End body of loop
    _691 = _697;
    _jump2347:;
    int64_t _703 = 684;
    _a1_int64_t _704;
    _704.d0 = 1;
    _704.data = jpl_alloc(sizeof(int64_t) * 1);
    _704.data[0] = _703;
    int64_t _705 = g(_704);
    int64_t _706 = 690;
    if (_705 >= 0)
    goto _jump2351;
    fail_assertion("negative array index");
    _jump2351:;
    if (_705 < _691.d0)
    goto _jump2352;
    fail_assertion("index too large");
    _jump2352:;
    if (_706 >= 0)
    goto _jump2353;
    fail_assertion("negative array index");
    _jump2353:;
    if (_706 < _691.d1)
    goto _jump2354;
    fail_assertion("index too large");
    _jump2354:;
    int64_t _707 = 0;
    _707 *= _691.d0;
    _707 += _705;
    _707 *= _691.d1;
    _707 += _706;
    int64_t _708 = _691.data[_707];
    if (_646 >= 0)
    goto _jump2355;
    fail_assertion("negative array index");
    _jump2355:;
    if (_646 < _652.d0)
    goto _jump2356;
    fail_assertion("index too large");
    _jump2356:;
    if (_647 >= 0)
    goto _jump2357;
    fail_assertion("negative array index");
    _jump2357:;
    if (_647 < _652.d1)
    goto _jump2358;
    fail_assertion("index too large");
    _jump2358:;
    if (_708 >= 0)
    goto _jump2359;
    fail_assertion("negative array index");
    _jump2359:;
    if (_708 < _652.d2)
    goto _jump2360;
    fail_assertion("index too large");
    _jump2360:;
    int64_t _709 = 0;
    _709 *= _652.d0;
    _709 += _646;
    _709 *= _652.d1;
    _709 += _647;
    _709 *= _652.d2;
    _709 += _708;
    _a3_bool _710 = _652.data[_709];
    int64_t _711 = 0;
    _711 *= _630.d0;
    _711 += _648;
    _711 *= _630.d1;
    _711 += _647;
    _711 *= _630.d2;
    _711 += _646;
    _630.data[_711] = _710;
    _646++;
    if (_646 < _644)
    goto _jump2318;
    _646 = 0;
    _647++;
    if (_647 < _632)
    goto _jump2318;
    _647 = 0;
    _648++;
    if (_648 < _631)
    goto _jump2318;
    // End body of loop
    int64_t _712;
    // Computing bound for q
    if (j > 0) 
    goto _jump2361;
    fail_assertion("non-positive loop bound");
    _jump2361:;
    _712 = 0;
    int64_t _713 = 0; // q
    _jump2362:; // Begin body of loop
    bool _714 = false;
    int64_t _715;
    if (!_714)
    goto _jump2363;
    _715 = _713;
    goto _jump2364;
    _jump2363:;
    int64_t _716;
    // Computing bound for r
    int64_t _717 = l % _455;
    int64_t _718 = -_717;
    if (_718 > 0) 
    goto _jump2365;
    fail_assertion("non-positive loop bound");
    _jump2365:;
    _716 = 0;
    int64_t _719 = 0; // r
    _jump2366:; // Begin body of loop
    int64_t _720 = n();
    int64_t _721 = n();
    int64_t _722 = _720 / _721;
    int64_t _723 = -_722;
    _716 += _723;
    _719++;
    if (_719 < _718)
    goto _jump2366;
    // End body of loop
    _715 = _716;
    _jump2364:;
    _712 += _715;
    _713++;
    if (_713 < j)
    goto _jump2362;
    // End body of loop
    int64_t _724 = -_455;
    int64_t _725 = -_724;
    int64_t _726 = n();
    int64_t _727 = -_726;
    int64_t _728 = _725 / _727;
    int64_t _729 = _728 - j;
    int64_t _730 = -_729;
    int64_t _731 = 351;
    if (_712 >= 0)
    goto _jump2367;
    fail_assertion("negative array index");
    _jump2367:;
    if (_712 < _630.d0)
    goto _jump2368;
    fail_assertion("index too large");
    _jump2368:;
    if (_730 >= 0)
    goto _jump2369;
    fail_assertion("negative array index");
    _jump2369:;
    if (_730 < _630.d1)
    goto _jump2370;
    fail_assertion("index too large");
    _jump2370:;
    if (_731 >= 0)
    goto _jump2371;
    fail_assertion("negative array index");
    _jump2371:;
    if (_731 < _630.d2)
    goto _jump2372;
    fail_assertion("index too large");
    _jump2372:;
    int64_t _732 = 0;
    _732 *= _630.d0;
    _732 += _712;
    _732 *= _630.d1;
    _732 += _730;
    _732 *= _630.d2;
    _732 += _731;
    _a3_bool _733 = _630.data[_732];
    _470 = _733;
    _jump2307:;
    return l;
}

void jpl_main(struct args args) {
    bool _0 = false;
    print("b");
    double _1 = get_time();
    bool _2 = !_0;
    _a1_bool _3;
    // Computing bound for b
    int64_t _4;
    if (!_0)
    goto _jump1;
    int64_t _5 = 637;
    int64_t _6 = -_5;
    int64_t _7 = -_6;
    _4 = _7;
    goto _jump2;
    _jump1:;
    int64_t _8 = 753;
    int64_t _9 = -_8;
    _4 = _9;
    _jump2:;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _4;
    _10 *= sizeof(bool);
    _3.data = jpl_alloc(_10);
    int64_t _11 = 0; // b
    _jump4:; // Begin body of loop
    int64_t _12;
    // Computing bound for c
    int64_t _13 = 725;
    if (_13 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing bound for d
    int64_t _14 = 936;
    if (_14 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    _12 = 0;
    int64_t _15 = 0; // d
    int64_t _16 = 0; // c
    _jump7:; // Begin body of loop
    _12 += _11;
    _15++;
    if (_15 < _14)
    goto _jump7;
    _15 = 0;
    _16++;
    if (_16 < _13)
    goto _jump7;
    // End body of loop
    int64_t _17 = 464;
    int64_t _18 = -_17;
    bool _19 = _12 < _18;
    bool _20;
    if (!_19)
    goto _jump8;
    bool _21 = true;
    int64_t _22;
    if (!_21)
    goto _jump9;
    int64_t _23 = 925;
    _22 = _23;
    goto _jump10;
    _jump9:;
    int64_t _24 = 225;
    _22 = _24;
    _jump10:;
    bool _25 = _22 <= _11;
    _20 = _25;
    goto _jump11;
    _jump8:;
    bool _26 = true;
    bool _27 = !_26;
    bool _28;
    if (!_27)
    goto _jump12;
    bool _29 = !_0;
    _28 = _29;
    goto _jump13;
    _jump12:;
    bool _31 = false;
    bool _30 = _31;
    if (0 != _31)
    goto _jump14;
    _30 = _0;
    _jump14:;
    _28 = _30;
    _jump13:;
    _20 = _28;
    _jump11:;
    int64_t _32 = 0;
    _32 *= _3.d0;
    _32 += _11;
    _3.data[_32] = _20;
    _11++;
    if (_11 < _4)
    goto _jump4;
    // End body of loop
    _a3_int64_t _33;
    // Computing bound for b
    int64_t _34 = 366;
    _33.d0 = _34;
    if (_34 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    // Computing bound for c
    int64_t _35 = 391;
    int64_t _36 = 577;
    int64_t _37 = -_36;
    int64_t _38 = _35 / _37;
    _33.d1 = _38;
    if (_38 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    // Computing bound for d
    int64_t _39 = 502;
    int64_t _40 = -_39;
    _33.d2 = _40;
    if (_40 > 0) 
    goto _jump17;
    fail_assertion("non-positive loop bound");
    _jump17:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= _34;
    _41 *= _38;
    _41 *= _40;
    _41 *= sizeof(int64_t);
    _33.data = jpl_alloc(_41);
    int64_t _42 = 0; // d
    int64_t _43 = 0; // c
    int64_t _44 = 0; // b
    _jump18:; // Begin body of loop
    int64_t _45 = 0;
    _45 *= _33.d0;
    _45 += _44;
    _45 *= _33.d1;
    _45 += _43;
    _45 *= _33.d2;
    _45 += _42;
    _33.data[_45] = _43;
    _42++;
    if (_42 < _40)
    goto _jump18;
    _42 = 0;
    _43++;
    if (_43 < _38)
    goto _jump18;
    _43 = 0;
    _44++;
    if (_44 < _34)
    goto _jump18;
    // End body of loop
    int64_t _46;
    // Computing bound for b
    int64_t _47 = 619;
    if (_47 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    // Computing bound for c
    int64_t _48 = 245;
    int64_t _49 = -_48;
    if (_49 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _46 = 0;
    int64_t _50 = 0; // c
    int64_t _51 = 0; // b
    _jump21:; // Begin body of loop
    int64_t _52 = _51 - _51;
    _46 += _52;
    _50++;
    if (_50 < _49)
    goto _jump21;
    _50 = 0;
    _51++;
    if (_51 < _47)
    goto _jump21;
    // End body of loop
    bool _53 = true;
    bool _54 = false;
    bool _55 = _53 != _54;
    bool _56;
    if (!_55)
    goto _jump22;
    bool _57 = true;
    bool _58 = _0 == _57;
    _56 = _58;
    goto _jump23;
    _jump22:;
    bool _59 = !_0;
    _56 = _59;
    _jump23:;
    int64_t _60;
    if (!_56)
    goto _jump24;
    int64_t _61;
    // Computing bound for b
    int64_t _62 = 575;
    if (_62 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for c
    int64_t _63 = 650;
    if (_63 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for d
    int64_t _64 = 700;
    if (_64 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _61 = 0;
    int64_t _65 = 0; // d
    int64_t _66 = 0; // c
    int64_t _67 = 0; // b
    _jump28:; // Begin body of loop
    _61 += _65;
    _65++;
    if (_65 < _64)
    goto _jump28;
    _65 = 0;
    _66++;
    if (_66 < _63)
    goto _jump28;
    _66 = 0;
    _67++;
    if (_67 < _62)
    goto _jump28;
    // End body of loop
    _60 = _61;
    goto _jump29;
    _jump24:;
    int64_t _68 = 669;
    _60 = _68;
    _jump29:;
    int64_t _69 = 5;
    if (_46 >= 0)
    goto _jump30;
    fail_assertion("negative array index");
    _jump30:;
    if (_46 < _33.d0)
    goto _jump31;
    fail_assertion("index too large");
    _jump31:;
    if (_60 >= 0)
    goto _jump32;
    fail_assertion("negative array index");
    _jump32:;
    if (_60 < _33.d1)
    goto _jump33;
    fail_assertion("index too large");
    _jump33:;
    if (_69 >= 0)
    goto _jump34;
    fail_assertion("negative array index");
    _jump34:;
    if (_69 < _33.d2)
    goto _jump35;
    fail_assertion("index too large");
    _jump35:;
    int64_t _70 = 0;
    _70 *= _33.d0;
    _70 += _46;
    _70 *= _33.d1;
    _70 += _60;
    _70 *= _33.d2;
    _70 += _69;
    int64_t _71 = _33.data[_70];
    if (_71 >= 0)
    goto _jump36;
    fail_assertion("negative array index");
    _jump36:;
    if (_71 < _3.d0)
    goto _jump37;
    fail_assertion("index too large");
    _jump37:;
    int64_t _72 = 0;
    _72 *= _3.d0;
    _72 += _71;
    bool _73 = _3.data[_72];
    bool _74 = _2 == _73;
    double _75 = get_time();
    print_time(_75 - _1);
    double _76;
    // Computing bound for d
    bool _80 = _0;
    if (0 == _0)
    goto _jump399;
    bool _81 = true;
    _80 = _81;
    _jump399:;
    bool _79 = _80;
    if (0 == _80)
    goto _jump400;
    _79 = _0;
    _jump400:;
    bool _78 = _79;
    if (0 == _79)
    goto _jump401;
    bool _83 = false;
    bool _82 = _83;
    if (0 != _83)
    goto _jump402;
    _82 = _0;
    _jump402:;
    bool _84;
    if (!_82)
    goto _jump403;
    _84 = _74;
    goto _jump404;
    _jump403:;
    _84 = _0;
    _jump404:;
    _78 = _84;
    _jump401:;
    bool _77 = _78;
    if (0 == _78)
    goto _jump405;
    double _85 = 41.0;
    double _86 = -_85;
    double _87;
    // Computing bound for d
    int64_t _88 = 170;
    if (_88 > 0) 
    goto _jump406;
    fail_assertion("non-positive loop bound");
    _jump406:;
    // Computing bound for e
    int64_t _89 = 631;
    if (_89 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    _87 = 0;
    int64_t _90 = 0; // e
    int64_t _91 = 0; // d
    _jump408:; // Begin body of loop
    double _92 = 94.0;
    _87 += _92;
    _90++;
    if (_90 < _89)
    goto _jump408;
    _90 = 0;
    _91++;
    if (_91 < _88)
    goto _jump408;
    // End body of loop
    double _93 = 51.0;
    double _94 = _87 + _93;
    bool _95 = _86 < _94;
    _77 = _95;
    _jump405:;
    int64_t _96;
    if (!_77)
    goto _jump409;
    bool _97;
    if (!_0)
    goto _jump410;
    _97 = _74;
    goto _jump411;
    _jump410:;
    bool _98 = true;
    bool _99 = _98 == _74;
    _97 = _99;
    _jump411:;
    bool _100 = _0 == _97;
    int64_t _101;
    if (!_100)
    goto _jump412;
    int64_t _102;
    // Computing bound for d
    int64_t _103 = 543;
    int64_t _104 = -_103;
    if (_104 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing bound for e
    int64_t _105 = 184;
    int64_t _106;
    if (!_74)
    goto _jump414;
    int64_t _107 = 259;
    _106 = _107;
    goto _jump415;
    _jump414:;
    int64_t _108 = 69;
    _106 = _108;
    _jump415:;
    int64_t _109 = _105 + _106;
    if (_109 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for f
    double _110 = 83.0;
    double _111 = 21.0;
    bool _112 = _110 < _111;
    int64_t _113;
    if (!_112)
    goto _jump417;
    int64_t _114 = 601;
    _113 = _114;
    goto _jump418;
    _jump417:;
    int64_t _115 = 296;
    int64_t _116 = 53;
    int64_t _117 = _115 / _116;
    _113 = _117;
    _jump418:;
    if (_113 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    _102 = 0;
    int64_t _118 = 0; // f
    int64_t _119 = 0; // e
    int64_t _120 = 0; // d
    _jump420:; // Begin body of loop
    int64_t _121 = _120 - _118;
    _102 += _121;
    _118++;
    if (_118 < _113)
    goto _jump420;
    _118 = 0;
    _119++;
    if (_119 < _109)
    goto _jump420;
    _119 = 0;
    _120++;
    if (_120 < _104)
    goto _jump420;
    // End body of loop
    _101 = _102;
    goto _jump421;
    _jump412:;
    int64_t _122 = 335;
    _101 = _122;
    _jump421:;
    _96 = _101;
    goto _jump422;
    _jump409:;
    int64_t _123;
    // Computing bound for d
    int64_t _124 = 126;
    if (_124 > 0) 
    goto _jump423;
    fail_assertion("non-positive loop bound");
    _jump423:;
    _123 = 0;
    int64_t _125 = 0; // d
    _jump424:; // Begin body of loop
    int64_t _126 = 274;
    _123 += _126;
    _125++;
    if (_125 < _124)
    goto _jump424;
    // End body of loop
    _96 = _123;
    _jump422:;
    int64_t _127 = -_96;
    if (_127 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    _76 = 0;
    int64_t _128 = 0; // d
    _jump426:; // Begin body of loop
    _a2_double _129;
    // Computing bound for e
    _a2_int64_t _130;
    // Computing bound for e
    int64_t _131;
    if (!_74)
    goto _jump427;
    int64_t _132 = 520;
    _131 = _132;
    goto _jump428;
    _jump427:;
    int64_t _133 = 944;
    _131 = _133;
    _jump428:;
    int64_t _134 = -_131;
    _130.d0 = _134;
    if (_134 > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    // Computing bound for f
    int64_t _135 = -_128;
    _130.d1 = _135;
    if (_135 > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _134;
    _136 *= _135;
    _136 *= sizeof(int64_t);
    _130.data = jpl_alloc(_136);
    int64_t _137 = 0; // f
    int64_t _138 = 0; // e
    _jump431:; // Begin body of loop
    int64_t _139 = 0;
    _139 *= _130.d0;
    _139 += _138;
    _139 *= _130.d1;
    _139 += _137;
    _130.data[_139] = _138;
    _137++;
    if (_137 < _135)
    goto _jump431;
    _137 = 0;
    _138++;
    if (_138 < _134)
    goto _jump431;
    // End body of loop
    bool _140 = !_0;
    bool _141 = false;
    bool _142 = _140 != _141;
    int64_t _143;
    if (!_142)
    goto _jump432;
    int64_t _144 = -_128;
    int64_t _145 = -_144;
    _143 = _145;
    goto _jump433;
    _jump432:;
    _143 = _128;
    _jump433:;
    int64_t _146 = -_128;
    int64_t _147 = -_146;
    if (_143 >= 0)
    goto _jump434;
    fail_assertion("negative array index");
    _jump434:;
    if (_143 < _130.d0)
    goto _jump435;
    fail_assertion("index too large");
    _jump435:;
    if (_147 >= 0)
    goto _jump436;
    fail_assertion("negative array index");
    _jump436:;
    if (_147 < _130.d1)
    goto _jump437;
    fail_assertion("index too large");
    _jump437:;
    int64_t _148 = 0;
    _148 *= _130.d0;
    _148 += _143;
    _148 *= _130.d1;
    _148 += _147;
    int64_t _149 = _130.data[_148];
    _129.d0 = _149;
    if (_149 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    // Computing bound for f
    int64_t _150 = 255;
    int64_t _151 = -_150;
    _129.d1 = _151;
    if (_151 > 0) 
    goto _jump439;
    fail_assertion("non-positive loop bound");
    _jump439:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= _149;
    _152 *= _151;
    _152 *= sizeof(double);
    _129.data = jpl_alloc(_152);
    int64_t _153 = 0; // f
    int64_t _154 = 0; // e
    _jump440:; // Begin body of loop
    double _155;
    // Computing bound for g
    if (_153 > 0) 
    goto _jump441;
    fail_assertion("non-positive loop bound");
    _jump441:;
    _155 = 0;
    int64_t _156 = 0; // g
    _jump442:; // Begin body of loop
    double _157;
    // Computing bound for h
    _a1_int64_t _158;
    // Computing bound for h
    _158.d0 = _128;
    if (_128 > 0) 
    goto _jump443;
    fail_assertion("non-positive loop bound");
    _jump443:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _128;
    _159 *= sizeof(int64_t);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // h
    _jump444:; // Begin body of loop
    int64_t _161 = 0;
    _161 *= _158.d0;
    _161 += _160;
    _158.data[_161] = _154;
    _160++;
    if (_160 < _128)
    goto _jump444;
    // End body of loop
    if (_153 >= 0)
    goto _jump445;
    fail_assertion("negative array index");
    _jump445:;
    if (_153 < _158.d0)
    goto _jump446;
    fail_assertion("index too large");
    _jump446:;
    int64_t _162 = 0;
    _162 *= _158.d0;
    _162 += _153;
    int64_t _163 = _158.data[_162];
    if (_163 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    // Computing bound for i
    if (_156 > 0) 
    goto _jump448;
    fail_assertion("non-positive loop bound");
    _jump448:;
    // Computing bound for j
    int64_t _164;
    // Computing bound for h
    int64_t _165 = 786;
    int64_t _166 = 326;
    int64_t _167 = _165 + _166;
    if (_167 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for i
    if (_156 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    _164 = 0;
    int64_t _168 = 0; // i
    int64_t _169 = 0; // h
    _jump451:; // Begin body of loop
    _164 += _169;
    _168++;
    if (_168 < _156)
    goto _jump451;
    _168 = 0;
    _169++;
    if (_169 < _167)
    goto _jump451;
    // End body of loop
    if (_164 > 0) 
    goto _jump452;
    fail_assertion("non-positive loop bound");
    _jump452:;
    _157 = 0;
    int64_t _170 = 0; // j
    int64_t _171 = 0; // i
    int64_t _172 = 0; // h
    _jump453:; // Begin body of loop
    double _173;
    // Computing bound for k
    if (_172 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing bound for l
    if (_156 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    _173 = 0;
    int64_t _174 = 0; // l
    int64_t _175 = 0; // k
    _jump456:; // Begin body of loop
    double _176 = 6.0;
    _173 += _176;
    _174++;
    if (_174 < _156)
    goto _jump456;
    _174 = 0;
    _175++;
    if (_175 < _172)
    goto _jump456;
    // End body of loop
    double _177 = -_173;
    _157 += _177;
    _170++;
    if (_170 < _164)
    goto _jump453;
    _170 = 0;
    _171++;
    if (_171 < _156)
    goto _jump453;
    _171 = 0;
    _172++;
    if (_172 < _163)
    goto _jump453;
    // End body of loop
    _155 += _157;
    _156++;
    if (_156 < _153)
    goto _jump442;
    // End body of loop
    int64_t _178 = 0;
    _178 *= _129.d0;
    _178 += _154;
    _178 *= _129.d1;
    _178 += _153;
    _129.data[_178] = _155;
    _153++;
    if (_153 < _151)
    goto _jump440;
    _153 = 0;
    _154++;
    if (_154 < _149)
    goto _jump440;
    // End body of loop
    int64_t _179 = -_128;
    if (_179 >= 0)
    goto _jump457;
    fail_assertion("negative array index");
    _jump457:;
    if (_179 < _129.d0)
    goto _jump458;
    fail_assertion("index too large");
    _jump458:;
    if (_128 >= 0)
    goto _jump459;
    fail_assertion("negative array index");
    _jump459:;
    if (_128 < _129.d1)
    goto _jump460;
    fail_assertion("index too large");
    _jump460:;
    int64_t _180 = 0;
    _180 *= _129.d0;
    _180 += _179;
    _180 *= _129.d1;
    _180 += _128;
    double _181 = _129.data[_180];
    _76 += _181;
    _128++;
    if (_128 < _127)
    goto _jump426;
    // End body of loop
    int64_t _182;
    // Computing bound for f
    _a3_bool _183;
    // Computing bound for f
    int64_t _184 = 617;
    _183.d0 = _184;
    if (_184 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing bound for g
    int64_t _185 = 365;
    _183.d1 = _185;
    if (_185 > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    // Computing bound for h
    int64_t _186 = 170;
    int64_t _187 = -_186;
    _183.d2 = _187;
    if (_187 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= _184;
    _188 *= _185;
    _188 *= _187;
    _188 *= sizeof(bool);
    _183.data = jpl_alloc(_188);
    int64_t _189 = 0; // h
    int64_t _190 = 0; // g
    int64_t _191 = 0; // f
    _jump688:; // Begin body of loop
    int64_t _192 = 0;
    _192 *= _183.d0;
    _192 += _191;
    _192 *= _183.d1;
    _192 += _190;
    _192 *= _183.d2;
    _192 += _189;
    _183.data[_192] = _0;
    _189++;
    if (_189 < _187)
    goto _jump688;
    _189 = 0;
    _190++;
    if (_190 < _185)
    goto _jump688;
    _190 = 0;
    _191++;
    if (_191 < _184)
    goto _jump688;
    // End body of loop
    int64_t _193 = 519;
    int64_t _194;
    // Computing bound for f
    int64_t _195 = 644;
    if (_195 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    _194 = 0;
    int64_t _196 = 0; // f
    _jump690:; // Begin body of loop
    _194 += _196;
    _196++;
    if (_196 < _195)
    goto _jump690;
    // End body of loop
    int64_t _197 = 610;
    int64_t _198 = -_197;
    if (_193 >= 0)
    goto _jump691;
    fail_assertion("negative array index");
    _jump691:;
    if (_193 < _183.d0)
    goto _jump692;
    fail_assertion("index too large");
    _jump692:;
    if (_194 >= 0)
    goto _jump693;
    fail_assertion("negative array index");
    _jump693:;
    if (_194 < _183.d1)
    goto _jump694;
    fail_assertion("index too large");
    _jump694:;
    if (_198 >= 0)
    goto _jump695;
    fail_assertion("negative array index");
    _jump695:;
    if (_198 < _183.d2)
    goto _jump696;
    fail_assertion("index too large");
    _jump696:;
    int64_t _199 = 0;
    _199 *= _183.d0;
    _199 += _193;
    _199 *= _183.d1;
    _199 += _194;
    _199 *= _183.d2;
    _199 += _198;
    bool _200 = _183.data[_199];
    int64_t _201;
    if (!_200)
    goto _jump697;
    int64_t _202;
    // Computing bound for f
    int64_t _203 = 544;
    int64_t _204 = -_203;
    int64_t _205 = 810;
    int64_t _206 = _204 - _205;
    if (_206 > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    _202 = 0;
    int64_t _207 = 0; // f
    _jump699:; // Begin body of loop
    int64_t _208 = 190;
    _202 += _208;
    _207++;
    if (_207 < _206)
    goto _jump699;
    // End body of loop
    _201 = _202;
    goto _jump700;
    _jump697:;
    int64_t _209 = 689;
    int64_t _210;
    // Computing bound for f
    int64_t _211 = 63;
    if (_211 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing bound for g
    int64_t _212 = 376;
    if (_212 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    _210 = 0;
    int64_t _213 = 0; // g
    int64_t _214 = 0; // f
    _jump703:; // Begin body of loop
    int64_t _215 = 726;
    _210 += _215;
    _213++;
    if (_213 < _212)
    goto _jump703;
    _213 = 0;
    _214++;
    if (_214 < _211)
    goto _jump703;
    // End body of loop
    int64_t _216 = _209 + _210;
    int64_t _217 = -_216;
    _201 = _217;
    _jump700:;
    int64_t _218;
    // Computing bound for f
    int64_t _219;
    if (!_0)
    goto _jump704;
    int64_t _220;
    // Computing bound for f
    int64_t _221 = 866;
    if (_221 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    _220 = 0;
    int64_t _222 = 0; // f
    _jump706:; // Begin body of loop
    _220 += _222;
    _222++;
    if (_222 < _221)
    goto _jump706;
    // End body of loop
    int64_t _223 = -_220;
    _219 = _223;
    goto _jump707;
    _jump704:;
    int64_t _224 = 471;
    int64_t _225;
    // Computing bound for f
    int64_t _226 = 896;
    if (_226 > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    _225 = 0;
    int64_t _227 = 0; // f
    _jump709:; // Begin body of loop
    _225 += _227;
    _227++;
    if (_227 < _226)
    goto _jump709;
    // End body of loop
    int64_t _228 = _224 / _225;
    _219 = _228;
    _jump707:;
    if (_219 > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing bound for g
    int64_t _229 = 462;
    int64_t _230;
    if (!_0)
    goto _jump711;
    int64_t _231 = 428;
    _230 = _231;
    goto _jump712;
    _jump711:;
    int64_t _232 = 957;
    _230 = _232;
    _jump712:;
    int64_t _233 = _229 + _230;
    int64_t _234 = 944;
    int64_t _235 = _233 / _234;
    if (_235 > 0) 
    goto _jump713;
    fail_assertion("non-positive loop bound");
    _jump713:;
    // Computing bound for h
    int64_t _236;
    // Computing bound for f
    int64_t _237 = 150;
    if (_237 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for g
    int64_t _238;
    // Computing bound for f
    int64_t _239 = 704;
    if (_239 > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    _238 = 0;
    int64_t _240 = 0; // f
    _jump716:; // Begin body of loop
    _238 += _240;
    _240++;
    if (_240 < _239)
    goto _jump716;
    // End body of loop
    int64_t _241 = -_238;
    if (_241 > 0) 
    goto _jump717;
    fail_assertion("non-positive loop bound");
    _jump717:;
    // Computing bound for h
    int64_t _242 = 948;
    int64_t _243 = 442;
    int64_t _244 = _242 + _243;
    if (_244 > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    _236 = 0;
    int64_t _245 = 0; // h
    int64_t _246 = 0; // g
    int64_t _247 = 0; // f
    _jump719:; // Begin body of loop
    bool _248 = false;
    bool _249;
    if (!_248)
    goto _jump720;
    bool _250 = true;
    _249 = _250;
    goto _jump721;
    _jump720:;
    _249 = _0;
    _jump721:;
    int64_t _251;
    if (!_249)
    goto _jump722;
    _251 = _245;
    goto _jump723;
    _jump722:;
    _251 = _246;
    _jump723:;
    _236 += _251;
    _245++;
    if (_245 < _244)
    goto _jump719;
    _245 = 0;
    _246++;
    if (_246 < _241)
    goto _jump719;
    _246 = 0;
    _247++;
    if (_247 < _237)
    goto _jump719;
    // End body of loop
    if (_236 > 0) 
    goto _jump724;
    fail_assertion("non-positive loop bound");
    _jump724:;
    _218 = 0;
    int64_t _252 = 0; // h
    int64_t _253 = 0; // g
    int64_t _254 = 0; // f
    _jump725:; // Begin body of loop
    _218 += _254;
    _252++;
    if (_252 < _236)
    goto _jump725;
    _252 = 0;
    _253++;
    if (_253 < _235)
    goto _jump725;
    _253 = 0;
    _254++;
    if (_254 < _219)
    goto _jump725;
    // End body of loop
    int64_t _255 = _201 / _218;
    if (_255 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    // Computing bound for g
    _a1__a1_int64_t _256;
    if (!_74)
    goto _jump727;
    _a1_int64_t _257;
    // Computing bound for f
    int64_t _258 = 613;
    _257.d0 = _258;
    if (_258 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= _258;
    _259 *= sizeof(int64_t);
    _257.data = jpl_alloc(_259);
    int64_t _260 = 0; // f
    _jump729:; // Begin body of loop
    int64_t _261 = 0;
    _261 *= _257.d0;
    _261 += _260;
    _257.data[_261] = _260;
    _260++;
    if (_260 < _258)
    goto _jump729;
    // End body of loop
    _a1__a1_int64_t _262;
    _262.d0 = 1;
    _262.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _262.data[0] = _257;
    _256 = _262;
    goto _jump730;
    _jump727:;
    _a1__a1_int64_t _263;
    // Computing bound for f
    int64_t _264 = 855;
    _263.d0 = _264;
    if (_264 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= _264;
    _265 *= sizeof(_a1_int64_t);
    _263.data = jpl_alloc(_265);
    int64_t _266 = 0; // f
    _jump732:; // Begin body of loop
    _a1_int64_t _267;
    // Computing bound for g
    _267.d0 = _266;
    if (_266 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing total size of heap memory to allocate
    int64_t _268 = 1;
    _268 *= _266;
    _268 *= sizeof(int64_t);
    _267.data = jpl_alloc(_268);
    int64_t _269 = 0; // g
    _jump734:; // Begin body of loop
    int64_t _270 = 0;
    _270 *= _267.d0;
    _270 += _269;
    _267.data[_270] = _266;
    _269++;
    if (_269 < _266)
    goto _jump734;
    // End body of loop
    int64_t _271 = 0;
    _271 *= _263.d0;
    _271 += _266;
    _263.data[_271] = _267;
    _266++;
    if (_266 < _264)
    goto _jump732;
    // End body of loop
    _256 = _263;
    _jump730:;
    int64_t _272;
    if (!_0)
    goto _jump735;
    int64_t _273;
    // Computing bound for f
    int64_t _274 = 671;
    if (_274 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for g
    int64_t _275;
    if (!_74)
    goto _jump737;
    int64_t _276 = 727;
    _275 = _276;
    goto _jump738;
    _jump737:;
    int64_t _277 = 612;
    _275 = _277;
    _jump738:;
    if (_275 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing bound for h
    int64_t _278 = 352;
    if (_278 > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    _273 = 0;
    int64_t _279 = 0; // h
    int64_t _280 = 0; // g
    int64_t _281 = 0; // f
    _jump741:; // Begin body of loop
    _273 += _279;
    _279++;
    if (_279 < _278)
    goto _jump741;
    _279 = 0;
    _280++;
    if (_280 < _275)
    goto _jump741;
    _280 = 0;
    _281++;
    if (_281 < _274)
    goto _jump741;
    // End body of loop
    _272 = _273;
    goto _jump742;
    _jump735:;
    int64_t _282 = 232;
    _272 = _282;
    _jump742:;
    if (_272 >= 0)
    goto _jump743;
    fail_assertion("negative array index");
    _jump743:;
    if (_272 < _256.d0)
    goto _jump744;
    fail_assertion("index too large");
    _jump744:;
    int64_t _283 = 0;
    _283 *= _256.d0;
    _283 += _272;
    _a1_int64_t _284 = _256.data[_283];
    _a2_bool _285;
    // Computing bound for f
    int64_t _286 = 815;
    _285.d0 = _286;
    if (_286 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing bound for g
    int64_t _287 = 668;
    _285.d1 = _287;
    if (_287 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing total size of heap memory to allocate
    int64_t _288 = 1;
    _288 *= _286;
    _288 *= _287;
    _288 *= sizeof(bool);
    _285.data = jpl_alloc(_288);
    int64_t _289 = 0; // g
    int64_t _290 = 0; // f
    _jump747:; // Begin body of loop
    int64_t _291 = 0;
    _291 *= _285.d0;
    _291 += _290;
    _291 *= _285.d1;
    _291 += _289;
    _285.data[_291] = _0;
    _289++;
    if (_289 < _287)
    goto _jump747;
    _289 = 0;
    _290++;
    if (_290 < _286)
    goto _jump747;
    // End body of loop
    int64_t _292;
    if (!_74)
    goto _jump748;
    int64_t _293 = 610;
    int64_t _294 = -_293;
    _292 = _294;
    goto _jump749;
    _jump748:;
    int64_t _295 = 443;
    _292 = _295;
    _jump749:;
    int64_t _296 = 932;
    int64_t _297 = -_296;
    if (_292 >= 0)
    goto _jump750;
    fail_assertion("negative array index");
    _jump750:;
    if (_292 < _285.d0)
    goto _jump751;
    fail_assertion("index too large");
    _jump751:;
    if (_297 >= 0)
    goto _jump752;
    fail_assertion("negative array index");
    _jump752:;
    if (_297 < _285.d1)
    goto _jump753;
    fail_assertion("index too large");
    _jump753:;
    int64_t _298 = 0;
    _298 *= _285.d0;
    _298 += _292;
    _298 *= _285.d1;
    _298 += _297;
    bool _299 = _285.data[_298];
    int64_t _300;
    if (!_299)
    goto _jump754;
    bool _301;
    if (!_0)
    goto _jump755;
    bool _302 = true;
    _301 = _302;
    goto _jump756;
    _jump755:;
    bool _303 = false;
    _301 = _303;
    _jump756:;
    int64_t _304;
    if (!_301)
    goto _jump757;
    int64_t _305 = 962;
    _304 = _305;
    goto _jump758;
    _jump757:;
    int64_t _306 = 423;
    _304 = _306;
    _jump758:;
    int64_t _307;
    // Computing bound for f
    int64_t _308 = 444;
    if (_308 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    _307 = 0;
    int64_t _309 = 0; // f
    _jump760:; // Begin body of loop
    int64_t _310 = 599;
    _307 += _310;
    _309++;
    if (_309 < _308)
    goto _jump760;
    // End body of loop
    int64_t _311 = _304 * _307;
    _300 = _311;
    goto _jump761;
    _jump754:;
    int64_t _312;
    // Computing bound for f
    int64_t _313 = 636;
    if (_313 > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing bound for g
    int64_t _314 = 265;
    if (_314 > 0) 
    goto _jump763;
    fail_assertion("non-positive loop bound");
    _jump763:;
    // Computing bound for h
    int64_t _315 = 129;
    if (_315 > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    _312 = 0;
    int64_t _316 = 0; // h
    int64_t _317 = 0; // g
    int64_t _318 = 0; // f
    _jump765:; // Begin body of loop
    _312 += _318;
    _316++;
    if (_316 < _315)
    goto _jump765;
    _316 = 0;
    _317++;
    if (_317 < _314)
    goto _jump765;
    _317 = 0;
    _318++;
    if (_318 < _313)
    goto _jump765;
    // End body of loop
    int64_t _319 = -_312;
    _300 = _319;
    _jump761:;
    if (_300 >= 0)
    goto _jump766;
    fail_assertion("negative array index");
    _jump766:;
    if (_300 < _284.d0)
    goto _jump767;
    fail_assertion("index too large");
    _jump767:;
    int64_t _320 = 0;
    _320 *= _284.d0;
    _320 += _300;
    int64_t _321 = _284.data[_320];
    if (_321 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    _182 = 0;
    int64_t _322 = 0; // g
    int64_t _323 = 0; // f
    _jump769:; // Begin body of loop
    _a2_int64_t _324;
    // Computing bound for h
    int64_t _325 = 92;
    _a1_int64_t _326;
    _326.d0 = 2;
    _326.data = jpl_alloc(sizeof(int64_t) * 2);
    _326.data[0] = _322;
    _326.data[1] = _325;
    int64_t _327 = 68;
    if (_327 >= 0)
    goto _jump770;
    fail_assertion("negative array index");
    _jump770:;
    if (_327 < _326.d0)
    goto _jump771;
    fail_assertion("index too large");
    _jump771:;
    int64_t _328 = 0;
    _328 *= _326.d0;
    _328 += _327;
    int64_t _329 = _326.data[_328];
    _324.d0 = _329;
    if (_329 > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    // Computing bound for i
    _a1_int64_t _330;
    // Computing bound for h
    int64_t _331 = 533;
    _330.d0 = _331;
    if (_331 > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= _331;
    _332 *= sizeof(int64_t);
    _330.data = jpl_alloc(_332);
    int64_t _333 = 0; // h
    _jump774:; // Begin body of loop
    int64_t _334 = 0;
    _334 *= _330.d0;
    _334 += _333;
    _330.data[_334] = _333;
    _333++;
    if (_333 < _331)
    goto _jump774;
    // End body of loop
    if (_323 >= 0)
    goto _jump775;
    fail_assertion("negative array index");
    _jump775:;
    if (_323 < _330.d0)
    goto _jump776;
    fail_assertion("index too large");
    _jump776:;
    int64_t _335 = 0;
    _335 *= _330.d0;
    _335 += _323;
    int64_t _336 = _330.data[_335];
    _324.d1 = _336;
    if (_336 > 0) 
    goto _jump777;
    fail_assertion("non-positive loop bound");
    _jump777:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= _329;
    _337 *= _336;
    _337 *= sizeof(int64_t);
    _324.data = jpl_alloc(_337);
    int64_t _338 = 0; // i
    int64_t _339 = 0; // h
    _jump778:; // Begin body of loop
    int64_t _340;
    if (!_74)
    goto _jump779;
    _340 = _339;
    goto _jump780;
    _jump779:;
    _340 = _338;
    _jump780:;
    int64_t _341 = -_340;
    int64_t _342 = 0;
    _342 *= _324.d0;
    _342 += _339;
    _342 *= _324.d1;
    _342 += _338;
    _324.data[_342] = _341;
    _338++;
    if (_338 < _336)
    goto _jump778;
    _338 = 0;
    _339++;
    if (_339 < _329)
    goto _jump778;
    // End body of loop
    int64_t _343;
    // Computing bound for h
    int64_t _344 = 694;
    if (_344 > 0) 
    goto _jump781;
    fail_assertion("non-positive loop bound");
    _jump781:;
    // Computing bound for i
    int64_t _345 = 672;
    if (_345 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing bound for j
    if (_323 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    _343 = 0;
    int64_t _346 = 0; // j
    int64_t _347 = 0; // i
    int64_t _348 = 0; // h
    _jump784:; // Begin body of loop
    _343 += _346;
    _346++;
    if (_346 < _323)
    goto _jump784;
    _346 = 0;
    _347++;
    if (_347 < _345)
    goto _jump784;
    _347 = 0;
    _348++;
    if (_348 < _344)
    goto _jump784;
    // End body of loop
    int64_t _349 = -_343;
    int64_t _350;
    // Computing bound for h
    int64_t _351 = 88;
    int64_t _352 = -_351;
    if (_352 > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    // Computing bound for i
    int64_t _353;
    // Computing bound for h
    if (_322 > 0) 
    goto _jump786;
    fail_assertion("non-positive loop bound");
    _jump786:;
    _353 = 0;
    int64_t _354 = 0; // h
    _jump787:; // Begin body of loop
    int64_t _355 = 226;
    _353 += _355;
    _354++;
    if (_354 < _322)
    goto _jump787;
    // End body of loop
    if (_353 > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    _350 = 0;
    int64_t _356 = 0; // i
    int64_t _357 = 0; // h
    _jump789:; // Begin body of loop
    int64_t _358;
    // Computing bound for j
    if (_356 > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for k
    if (_357 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for l
    if (_323 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    _358 = 0;
    int64_t _359 = 0; // l
    int64_t _360 = 0; // k
    int64_t _361 = 0; // j
    _jump793:; // Begin body of loop
    _358 += _361;
    _359++;
    if (_359 < _323)
    goto _jump793;
    _359 = 0;
    _360++;
    if (_360 < _357)
    goto _jump793;
    _360 = 0;
    _361++;
    if (_361 < _356)
    goto _jump793;
    // End body of loop
    _350 += _358;
    _356++;
    if (_356 < _353)
    goto _jump789;
    _356 = 0;
    _357++;
    if (_357 < _352)
    goto _jump789;
    // End body of loop
    int64_t _362 = _349 % _350;
    if (_323 >= 0)
    goto _jump794;
    fail_assertion("negative array index");
    _jump794:;
    if (_323 < _324.d0)
    goto _jump795;
    fail_assertion("index too large");
    _jump795:;
    if (_362 >= 0)
    goto _jump796;
    fail_assertion("negative array index");
    _jump796:;
    if (_362 < _324.d1)
    goto _jump797;
    fail_assertion("index too large");
    _jump797:;
    int64_t _363 = 0;
    _363 *= _324.d0;
    _363 += _323;
    _363 *= _324.d1;
    _363 += _362;
    int64_t _364 = _324.data[_363];
    int64_t _365 = -_364;
    _182 += _365;
    _322++;
    if (_322 < _321)
    goto _jump769;
    _322 = 0;
    _323++;
    if (_323 < _255)
    goto _jump769;
    // End body of loop
    int64_t _366;
    if (!_0)
    goto _jump798;
    int64_t _367;
    // Computing bound for f
    int64_t _368 = 534;
    int64_t _369 = 989;
    _a1_int64_t _370;
    _370.d0 = 2;
    _370.data = jpl_alloc(sizeof(int64_t) * 2);
    _370.data[0] = _368;
    _370.data[1] = _369;
    int64_t _371 = 526;
    int64_t _372 = 182;
    int64_t _373 = _371 + _372;
    if (_373 >= 0)
    goto _jump799;
    fail_assertion("negative array index");
    _jump799:;
    if (_373 < _370.d0)
    goto _jump800;
    fail_assertion("index too large");
    _jump800:;
    int64_t _374 = 0;
    _374 *= _370.d0;
    _374 += _373;
    int64_t _375 = _370.data[_374];
    int64_t _376 = -_375;
    if (_376 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing bound for g
    int64_t _377;
    if (!_74)
    goto _jump802;
    int64_t _378 = 837;
    int64_t _379 = -_378;
    _377 = _379;
    goto _jump803;
    _jump802:;
    _a1_int64_t _380;
    // Computing bound for f
    int64_t _381 = 558;
    _380.d0 = _381;
    if (_381 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing total size of heap memory to allocate
    int64_t _382 = 1;
    _382 *= _381;
    _382 *= sizeof(int64_t);
    _380.data = jpl_alloc(_382);
    int64_t _383 = 0; // f
    _jump805:; // Begin body of loop
    int64_t _384 = 0;
    _384 *= _380.d0;
    _384 += _383;
    _380.data[_384] = _383;
    _383++;
    if (_383 < _381)
    goto _jump805;
    // End body of loop
    int64_t _385 = 78;
    if (_385 >= 0)
    goto _jump806;
    fail_assertion("negative array index");
    _jump806:;
    if (_385 < _380.d0)
    goto _jump807;
    fail_assertion("index too large");
    _jump807:;
    int64_t _386 = 0;
    _386 *= _380.d0;
    _386 += _385;
    int64_t _387 = _380.data[_386];
    _377 = _387;
    _jump803:;
    if (_377 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing bound for h
    int64_t _388 = 207;
    int64_t _389 = -_388;
    int64_t _390 = -_389;
    bool _391 = true;
    bool _392 = _74 != _391;
    int64_t _393;
    if (!_392)
    goto _jump809;
    int64_t _394 = 495;
    int64_t _395 = 770;
    int64_t _396 = _394 * _395;
    _393 = _396;
    goto _jump810;
    _jump809:;
    int64_t _397 = 195;
    _393 = _397;
    _jump810:;
    int64_t _398 = _390 / _393;
    if (_398 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    _367 = 0;
    int64_t _399 = 0; // h
    int64_t _400 = 0; // g
    int64_t _401 = 0; // f
    _jump812:; // Begin body of loop
    _367 += _400;
    _399++;
    if (_399 < _398)
    goto _jump812;
    _399 = 0;
    _400++;
    if (_400 < _377)
    goto _jump812;
    _400 = 0;
    _401++;
    if (_401 < _376)
    goto _jump812;
    // End body of loop
    _366 = _367;
    goto _jump813;
    _jump798:;
    int64_t _402 = 181;
    _366 = _402;
    _jump813:;
    int64_t _403 = -_366;
    bool _404 = _182 <= _403;
    print("h");
    _a3__a1_bool _405;
    // Computing bound for i
    int64_t _406;
    // Computing bound for i
    int64_t _407;
    // Computing bound for i
    int64_t _408 = 386;
    if (_408 > 0) 
    goto _jump1315;
    fail_assertion("non-positive loop bound");
    _jump1315:;
    // Computing bound for j
    int64_t _409 = 537;
    int64_t _410 = -_409;
    if (_410 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    _407 = 0;
    int64_t _411 = 0; // j
    int64_t _412 = 0; // i
    _jump1317:; // Begin body of loop
    int64_t _413 = 951;
    int64_t _414 = _413 - _411;
    _407 += _414;
    _411++;
    if (_411 < _410)
    goto _jump1317;
    _411 = 0;
    _412++;
    if (_412 < _408)
    goto _jump1317;
    // End body of loop
    int64_t _415 = -_407;
    if (_415 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    _406 = 0;
    int64_t _416 = 0; // i
    _jump1319:; // Begin body of loop
    _406 += _416;
    _416++;
    if (_416 < _415)
    goto _jump1319;
    // End body of loop
    _405.d0 = _406;
    if (_406 > 0) 
    goto _jump1320;
    fail_assertion("non-positive loop bound");
    _jump1320:;
    // Computing bound for j
    int64_t _417;
    // Computing bound for i
    int64_t _418 = 322;
    int64_t _419 = -_418;
    int64_t _420 = 191;
    int64_t _421 = _419 * _420;
    int64_t _422;
    // Computing bound for i
    int64_t _423 = 385;
    if (_423 > 0) 
    goto _jump1321;
    fail_assertion("non-positive loop bound");
    _jump1321:;
    // Computing bound for j
    int64_t _424;
    // Computing bound for i
    int64_t _425 = 367;
    if (_425 > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing bound for j
    int64_t _426 = 316;
    if (_426 > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    // Computing bound for k
    int64_t _427 = 876;
    if (_427 > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    _424 = 0;
    int64_t _428 = 0; // k
    int64_t _429 = 0; // j
    int64_t _430 = 0; // i
    _jump1325:; // Begin body of loop
    int64_t _431 = 11;
    _424 += _431;
    _428++;
    if (_428 < _427)
    goto _jump1325;
    _428 = 0;
    _429++;
    if (_429 < _426)
    goto _jump1325;
    _429 = 0;
    _430++;
    if (_430 < _425)
    goto _jump1325;
    // End body of loop
    if (_424 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    _422 = 0;
    int64_t _432 = 0; // j
    int64_t _433 = 0; // i
    _jump1327:; // Begin body of loop
    _422 += _432;
    _432++;
    if (_432 < _424)
    goto _jump1327;
    _432 = 0;
    _433++;
    if (_433 < _423)
    goto _jump1327;
    // End body of loop
    int64_t _434 = _421 * _422;
    int64_t _435 = -_434;
    if (_435 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    // Computing bound for j
    bool _436 = true;
    bool _437;
    if (!_436)
    goto _jump1329;
    bool _438 = !_404;
    _437 = _438;
    goto _jump1330;
    _jump1329:;
    _437 = _404;
    _jump1330:;
    _a1_int64_t _439;
    if (!_437)
    goto _jump1331;
    _a1_int64_t _440;
    // Computing bound for i
    int64_t _441 = 814;
    _440.d0 = _441;
    if (_441 > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    // Computing total size of heap memory to allocate
    int64_t _442 = 1;
    _442 *= _441;
    _442 *= sizeof(int64_t);
    _440.data = jpl_alloc(_442);
    int64_t _443 = 0; // i
    _jump1333:; // Begin body of loop
    int64_t _444 = 600;
    int64_t _445 = 0;
    _445 *= _440.d0;
    _445 += _443;
    _440.data[_445] = _444;
    _443++;
    if (_443 < _441)
    goto _jump1333;
    // End body of loop
    _439 = _440;
    goto _jump1334;
    _jump1331:;
    int64_t _446 = 548;
    int64_t _447 = 647;
    int64_t _448 = -_447;
    _a1_int64_t _449;
    _449.d0 = 2;
    _449.data = jpl_alloc(sizeof(int64_t) * 2);
    _449.data[0] = _446;
    _449.data[1] = _448;
    _439 = _449;
    _jump1334:;
    int64_t _450 = g(_439);
    if (_450 > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    _417 = 0;
    int64_t _451 = 0; // j
    int64_t _452 = 0; // i
    _jump1336:; // Begin body of loop
    bool _453 = false;
    int64_t _454 = 642;
    bool _455 = _452 == _454;
    bool _456 = _453 != _455;
    bool _457 = !_456;
    int64_t _458;
    if (!_457)
    goto _jump1337;
    bool _459;
    if (!_404)
    goto _jump1338;
    bool _460 = false;
    _459 = _460;
    goto _jump1339;
    _jump1338:;
    _459 = _0;
    _jump1339:;
    int64_t _461;
    if (!_459)
    goto _jump1340;
    _a2_int64_t _462;
    // Computing bound for k
    _462.d0 = _451;
    if (_451 > 0) 
    goto _jump1341;
    fail_assertion("non-positive loop bound");
    _jump1341:;
    // Computing bound for l
    _462.d1 = _452;
    if (_452 > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    // Computing total size of heap memory to allocate
    int64_t _463 = 1;
    _463 *= _451;
    _463 *= _452;
    _463 *= sizeof(int64_t);
    _462.data = jpl_alloc(_463);
    int64_t _464 = 0; // l
    int64_t _465 = 0; // k
    _jump1343:; // Begin body of loop
    int64_t _466 = 0;
    _466 *= _462.d0;
    _466 += _465;
    _466 *= _462.d1;
    _466 += _464;
    _462.data[_466] = _465;
    _464++;
    if (_464 < _452)
    goto _jump1343;
    _464 = 0;
    _465++;
    if (_465 < _451)
    goto _jump1343;
    // End body of loop
    int64_t _467 = -_451;
    if (_451 >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (_451 < _462.d0)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    if (_467 >= 0)
    goto _jump1346;
    fail_assertion("negative array index");
    _jump1346:;
    if (_467 < _462.d1)
    goto _jump1347;
    fail_assertion("index too large");
    _jump1347:;
    int64_t _468 = 0;
    _468 *= _462.d0;
    _468 += _451;
    _468 *= _462.d1;
    _468 += _467;
    int64_t _469 = _462.data[_468];
    _461 = _469;
    goto _jump1348;
    _jump1340:;
    _a2_int64_t _470;
    // Computing bound for k
    _470.d0 = _451;
    if (_451 > 0) 
    goto _jump1349;
    fail_assertion("non-positive loop bound");
    _jump1349:;
    // Computing bound for l
    int64_t _471 = 571;
    _470.d1 = _471;
    if (_471 > 0) 
    goto _jump1350;
    fail_assertion("non-positive loop bound");
    _jump1350:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _451;
    _472 *= _471;
    _472 *= sizeof(int64_t);
    _470.data = jpl_alloc(_472);
    int64_t _473 = 0; // l
    int64_t _474 = 0; // k
    _jump1351:; // Begin body of loop
    int64_t _475 = 0;
    _475 *= _470.d0;
    _475 += _474;
    _475 *= _470.d1;
    _475 += _473;
    _470.data[_475] = _473;
    _473++;
    if (_473 < _471)
    goto _jump1351;
    _473 = 0;
    _474++;
    if (_474 < _451)
    goto _jump1351;
    // End body of loop
    if (_452 >= 0)
    goto _jump1352;
    fail_assertion("negative array index");
    _jump1352:;
    if (_452 < _470.d0)
    goto _jump1353;
    fail_assertion("index too large");
    _jump1353:;
    if (_452 >= 0)
    goto _jump1354;
    fail_assertion("negative array index");
    _jump1354:;
    if (_452 < _470.d1)
    goto _jump1355;
    fail_assertion("index too large");
    _jump1355:;
    int64_t _476 = 0;
    _476 *= _470.d0;
    _476 += _452;
    _476 *= _470.d1;
    _476 += _452;
    int64_t _477 = _470.data[_476];
    _461 = _477;
    _jump1348:;
    _458 = _461;
    goto _jump1356;
    _jump1337:;
    int64_t _478 = 282;
    _458 = _478;
    _jump1356:;
    _417 += _458;
    _451++;
    if (_451 < _450)
    goto _jump1336;
    _451 = 0;
    _452++;
    if (_452 < _435)
    goto _jump1336;
    // End body of loop
    _405.d1 = _417;
    if (_417 > 0) 
    goto _jump1357;
    fail_assertion("non-positive loop bound");
    _jump1357:;
    // Computing bound for k
    _a2_bool _479;
    // Computing bound for i
    int64_t _480;
    // Computing bound for i
    int64_t _481 = 838;
    int64_t _482 = -_481;
    if (_482 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    _480 = 0;
    int64_t _483 = 0; // i
    _jump1359:; // Begin body of loop
    int64_t _484 = 837;
    int64_t _485 = _484 - _483;
    _480 += _485;
    _483++;
    if (_483 < _482)
    goto _jump1359;
    // End body of loop
    _479.d0 = _480;
    if (_480 > 0) 
    goto _jump1360;
    fail_assertion("non-positive loop bound");
    _jump1360:;
    // Computing bound for j
    int64_t _486 = 368;
    _479.d1 = _486;
    if (_486 > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing total size of heap memory to allocate
    int64_t _487 = 1;
    _487 *= _480;
    _487 *= _486;
    _487 *= sizeof(bool);
    _479.data = jpl_alloc(_487);
    int64_t _488 = 0; // j
    int64_t _489 = 0; // i
    _jump1362:; // Begin body of loop
    int64_t _490 = 0;
    _490 *= _479.d0;
    _490 += _489;
    _490 *= _479.d1;
    _490 += _488;
    _479.data[_490] = _0;
    _488++;
    if (_488 < _486)
    goto _jump1362;
    _488 = 0;
    _489++;
    if (_489 < _480)
    goto _jump1362;
    // End body of loop
    _a1_int64_t _491;
    // Computing bound for i
    int64_t _492 = 979;
    _491.d0 = _492;
    if (_492 > 0) 
    goto _jump1363;
    fail_assertion("non-positive loop bound");
    _jump1363:;
    // Computing total size of heap memory to allocate
    int64_t _493 = 1;
    _493 *= _492;
    _493 *= sizeof(int64_t);
    _491.data = jpl_alloc(_493);
    int64_t _494 = 0; // i
    _jump1364:; // Begin body of loop
    int64_t _495 = 494;
    int64_t _496 = 0;
    _496 *= _491.d0;
    _496 += _494;
    _491.data[_496] = _495;
    _494++;
    if (_494 < _492)
    goto _jump1364;
    // End body of loop
    int64_t _497 = g(_491);
    int64_t _498;
    // Computing bound for i
    int64_t _499 = 126;
    int64_t _500 = -_499;
    if (_500 > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing bound for j
    int64_t _501 = 149;
    int64_t _502 = -_501;
    if (_502 > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    _498 = 0;
    int64_t _503 = 0; // j
    int64_t _504 = 0; // i
    _jump1367:; // Begin body of loop
    int64_t _505 = -_503;
    _498 += _505;
    _503++;
    if (_503 < _502)
    goto _jump1367;
    _503 = 0;
    _504++;
    if (_504 < _500)
    goto _jump1367;
    // End body of loop
    int64_t _506 = _497 + _498;
    bool _507;
    if (!_0)
    goto _jump1368;
    _507 = _0;
    goto _jump1369;
    _jump1368:;
    _507 = _0;
    _jump1369:;
    int64_t _508;
    if (!_507)
    goto _jump1370;
    bool _509 = true;
    int64_t _510;
    if (!_509)
    goto _jump1371;
    int64_t _511 = 701;
    int64_t _512 = 756;
    int64_t _513 = _511 * _512;
    _510 = _513;
    goto _jump1372;
    _jump1371:;
    int64_t _514 = 787;
    _510 = _514;
    _jump1372:;
    _508 = _510;
    goto _jump1373;
    _jump1370:;
    int64_t _515 = 349;
    int64_t _516 = 437;
    int64_t _517 = _515 / _516;
    _508 = _517;
    _jump1373:;
    if (_506 >= 0)
    goto _jump1374;
    fail_assertion("negative array index");
    _jump1374:;
    if (_506 < _479.d0)
    goto _jump1375;
    fail_assertion("index too large");
    _jump1375:;
    if (_508 >= 0)
    goto _jump1376;
    fail_assertion("negative array index");
    _jump1376:;
    if (_508 < _479.d1)
    goto _jump1377;
    fail_assertion("index too large");
    _jump1377:;
    int64_t _518 = 0;
    _518 *= _479.d0;
    _518 += _506;
    _518 *= _479.d1;
    _518 += _508;
    bool _519 = _479.data[_518];
    int64_t _520;
    if (!_519)
    goto _jump1378;
    _a2_int64_t _521;
    // Computing bound for i
    int64_t _522 = 859;
    int64_t _523 = -_522;
    _521.d0 = _523;
    if (_523 > 0) 
    goto _jump1379;
    fail_assertion("non-positive loop bound");
    _jump1379:;
    // Computing bound for j
    int64_t _524 = 437;
    _521.d1 = _524;
    if (_524 > 0) 
    goto _jump1380;
    fail_assertion("non-positive loop bound");
    _jump1380:;
    // Computing total size of heap memory to allocate
    int64_t _525 = 1;
    _525 *= _523;
    _525 *= _524;
    _525 *= sizeof(int64_t);
    _521.data = jpl_alloc(_525);
    int64_t _526 = 0; // j
    int64_t _527 = 0; // i
    _jump1381:; // Begin body of loop
    int64_t _528 = 108;
    int64_t _529 = 0;
    _529 *= _521.d0;
    _529 += _527;
    _529 *= _521.d1;
    _529 += _526;
    _521.data[_529] = _528;
    _526++;
    if (_526 < _524)
    goto _jump1381;
    _526 = 0;
    _527++;
    if (_527 < _523)
    goto _jump1381;
    // End body of loop
    _a1_int64_t _530;
    // Computing bound for i
    int64_t _531 = 665;
    _530.d0 = _531;
    if (_531 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    // Computing total size of heap memory to allocate
    int64_t _532 = 1;
    _532 *= _531;
    _532 *= sizeof(int64_t);
    _530.data = jpl_alloc(_532);
    int64_t _533 = 0; // i
    _jump1383:; // Begin body of loop
    int64_t _534 = 0;
    _534 *= _530.d0;
    _534 += _533;
    _530.data[_534] = _533;
    _533++;
    if (_533 < _531)
    goto _jump1383;
    // End body of loop
    int64_t _535 = g(_530);
    int64_t _536 = -_535;
    int64_t _537 = 53;
    int64_t _538 = -_537;
    int64_t _539 = -_538;
    int64_t _540 = -_539;
    if (_536 >= 0)
    goto _jump1384;
    fail_assertion("negative array index");
    _jump1384:;
    if (_536 < _521.d0)
    goto _jump1385;
    fail_assertion("index too large");
    _jump1385:;
    if (_540 >= 0)
    goto _jump1386;
    fail_assertion("negative array index");
    _jump1386:;
    if (_540 < _521.d1)
    goto _jump1387;
    fail_assertion("index too large");
    _jump1387:;
    int64_t _541 = 0;
    _541 *= _521.d0;
    _541 += _536;
    _541 *= _521.d1;
    _541 += _540;
    int64_t _542 = _521.data[_541];
    _520 = _542;
    goto _jump1388;
    _jump1378:;
    bool _543 = !_0;
    bool _544 = true;
    bool _545 = !_544;
    bool _546 = _543 == _545;
    int64_t _547;
    if (!_546)
    goto _jump1389;
    int64_t _548 = 884;
    _547 = _548;
    goto _jump1390;
    _jump1389:;
    int64_t _549;
    // Computing bound for i
    int64_t _550 = 237;
    int64_t _551 = -_550;
    if (_551 > 0) 
    goto _jump1391;
    fail_assertion("non-positive loop bound");
    _jump1391:;
    // Computing bound for j
    int64_t _552 = 313;
    if (_552 > 0) 
    goto _jump1392;
    fail_assertion("non-positive loop bound");
    _jump1392:;
    _549 = 0;
    int64_t _553 = 0; // j
    int64_t _554 = 0; // i
    _jump1393:; // Begin body of loop
    _549 += _554;
    _553++;
    if (_553 < _552)
    goto _jump1393;
    _553 = 0;
    _554++;
    if (_554 < _551)
    goto _jump1393;
    // End body of loop
    _547 = _549;
    _jump1390:;
    int64_t _555 = 280;
    int64_t _556 = 153;
    int64_t _557 = _555 - _556;
    int64_t _558 = _547 * _557;
    _520 = _558;
    _jump1388:;
    _405.d2 = _520;
    if (_520 > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing total size of heap memory to allocate
    int64_t _559 = 1;
    _559 *= _406;
    _559 *= _417;
    _559 *= _520;
    _559 *= sizeof(_a1_bool);
    _405.data = jpl_alloc(_559);
    int64_t _560 = 0; // k
    int64_t _561 = 0; // j
    int64_t _562 = 0; // i
    _jump1395:; // Begin body of loop
    _a1_bool _563;
    if (!_404)
    goto _jump1396;
    bool _564 = !_404;
    _a1_bool _565;
    _565.d0 = 1;
    _565.data = jpl_alloc(sizeof(bool) * 1);
    _565.data[0] = _564;
    _a1_bool _566;
    // Computing bound for l
    _566.d0 = _560;
    if (_560 > 0) 
    goto _jump1397;
    fail_assertion("non-positive loop bound");
    _jump1397:;
    // Computing total size of heap memory to allocate
    int64_t _567 = 1;
    _567 *= _560;
    _567 *= sizeof(bool);
    _566.data = jpl_alloc(_567);
    int64_t _568 = 0; // l
    _jump1398:; // Begin body of loop
    bool _569 = _404;
    if (0 != _404)
    goto _jump1399;
    _569 = _0;
    _jump1399:;
    int64_t _570 = 0;
    _570 *= _566.d0;
    _570 += _568;
    _566.data[_570] = _569;
    _568++;
    if (_568 < _560)
    goto _jump1398;
    // End body of loop
    _a1__a1_bool _571;
    _571.d0 = 2;
    _571.data = jpl_alloc(sizeof(_a1_bool) * 2);
    _571.data[0] = _565;
    _571.data[1] = _566;
    bool _572 = false;
    int64_t _573;
    if (!_572)
    goto _jump1400;
    int64_t _574 = 815;
    _573 = _574;
    goto _jump1401;
    _jump1400:;
    int64_t _575 = 222;
    _573 = _575;
    _jump1401:;
    int64_t _576 = _561 / _573;
    _a2_int64_t _577;
    // Computing bound for l
    _577.d0 = _560;
    if (_560 > 0) 
    goto _jump1402;
    fail_assertion("non-positive loop bound");
    _jump1402:;
    // Computing bound for m
    _577.d1 = _561;
    if (_561 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    // Computing total size of heap memory to allocate
    int64_t _578 = 1;
    _578 *= _560;
    _578 *= _561;
    _578 *= sizeof(int64_t);
    _577.data = jpl_alloc(_578);
    int64_t _579 = 0; // m
    int64_t _580 = 0; // l
    _jump1404:; // Begin body of loop
    int64_t _581 = 0;
    _581 *= _577.d0;
    _581 += _580;
    _581 *= _577.d1;
    _581 += _579;
    _577.data[_581] = _562;
    _579++;
    if (_579 < _561)
    goto _jump1404;
    _579 = 0;
    _580++;
    if (_580 < _560)
    goto _jump1404;
    // End body of loop
    bool _582 = true;
    int64_t _583;
    if (!_582)
    goto _jump1405;
    _583 = _560;
    goto _jump1406;
    _jump1405:;
    int64_t _584 = 882;
    _583 = _584;
    _jump1406:;
    if (_583 >= 0)
    goto _jump1407;
    fail_assertion("negative array index");
    _jump1407:;
    if (_583 < _577.d0)
    goto _jump1408;
    fail_assertion("index too large");
    _jump1408:;
    if (_562 >= 0)
    goto _jump1409;
    fail_assertion("negative array index");
    _jump1409:;
    if (_562 < _577.d1)
    goto _jump1410;
    fail_assertion("index too large");
    _jump1410:;
    int64_t _585 = 0;
    _585 *= _577.d0;
    _585 += _583;
    _585 *= _577.d1;
    _585 += _562;
    int64_t _586 = _577.data[_585];
    int64_t _587 = _576 + _586;
    if (_587 >= 0)
    goto _jump1411;
    fail_assertion("negative array index");
    _jump1411:;
    if (_587 < _571.d0)
    goto _jump1412;
    fail_assertion("index too large");
    _jump1412:;
    int64_t _588 = 0;
    _588 *= _571.d0;
    _588 += _587;
    _a1_bool _589 = _571.data[_588];
    _563 = _589;
    goto _jump1413;
    _jump1396:;
    _a2__a1_bool _590;
    // Computing bound for l
    int64_t _591;
    if (!_0)
    goto _jump1414;
    _591 = _561;
    goto _jump1415;
    _jump1414:;
    int64_t _592 = 307;
    int64_t _593 = _560 * _592;
    _591 = _593;
    _jump1415:;
    _590.d0 = _591;
    if (_591 > 0) 
    goto _jump1416;
    fail_assertion("non-positive loop bound");
    _jump1416:;
    // Computing bound for m
    _590.d1 = _560;
    if (_560 > 0) 
    goto _jump1417;
    fail_assertion("non-positive loop bound");
    _jump1417:;
    // Computing total size of heap memory to allocate
    int64_t _594 = 1;
    _594 *= _591;
    _594 *= _560;
    _594 *= sizeof(_a1_bool);
    _590.data = jpl_alloc(_594);
    int64_t _595 = 0; // m
    int64_t _596 = 0; // l
    _jump1418:; // Begin body of loop
    double _597 = 40.0;
    bool _598 = _76 >= _597;
    _a1_bool _599;
    _599.d0 = 3;
    _599.data = jpl_alloc(sizeof(bool) * 3);
    _599.data[0] = _74;
    _599.data[1] = _404;
    _599.data[2] = _598;
    int64_t _600 = 0;
    _600 *= _590.d0;
    _600 += _596;
    _600 *= _590.d1;
    _600 += _595;
    _590.data[_600] = _599;
    _595++;
    if (_595 < _560)
    goto _jump1418;
    _595 = 0;
    _596++;
    if (_596 < _591)
    goto _jump1418;
    // End body of loop
    if (_561 >= 0)
    goto _jump1419;
    fail_assertion("negative array index");
    _jump1419:;
    if (_561 < _590.d0)
    goto _jump1420;
    fail_assertion("index too large");
    _jump1420:;
    if (_562 >= 0)
    goto _jump1421;
    fail_assertion("negative array index");
    _jump1421:;
    if (_562 < _590.d1)
    goto _jump1422;
    fail_assertion("index too large");
    _jump1422:;
    int64_t _601 = 0;
    _601 *= _590.d0;
    _601 += _561;
    _601 *= _590.d1;
    _601 += _562;
    _a1_bool _602 = _590.data[_601];
    _563 = _602;
    _jump1413:;
    int64_t _603 = 0;
    _603 *= _405.d0;
    _603 += _562;
    _603 *= _405.d1;
    _603 += _561;
    _603 *= _405.d2;
    _603 += _560;
    _405.data[_603] = _563;
    _560++;
    if (_560 < _520)
    goto _jump1395;
    _560 = 0;
    _561++;
    if (_561 < _417)
    goto _jump1395;
    _561 = 0;
    _562++;
    if (_562 < _406)
    goto _jump1395;
    // End body of loop
    int64_t _604;
    // Computing bound for i
    _a1_int64_t _605;
    if (!_404)
    goto _jump1423;
    bool _606 = _74;
    if (0 != _74)
    goto _jump1424;
    bool _607 = _404 == _404;
    _606 = _607;
    _jump1424:;
    _a1_int64_t _608;
    if (!_606)
    goto _jump1425;
    _a1_int64_t _609;
    // Computing bound for i
    int64_t _610;
    if (!_404)
    goto _jump1426;
    int64_t _611 = 652;
    _610 = _611;
    goto _jump1427;
    _jump1426:;
    int64_t _612 = 541;
    _610 = _612;
    _jump1427:;
    _609.d0 = _610;
    if (_610 > 0) 
    goto _jump1428;
    fail_assertion("non-positive loop bound");
    _jump1428:;
    // Computing total size of heap memory to allocate
    int64_t _613 = 1;
    _613 *= _610;
    _613 *= sizeof(int64_t);
    _609.data = jpl_alloc(_613);
    int64_t _614 = 0; // i
    _jump1429:; // Begin body of loop
    int64_t _615 = 4;
    int64_t _616 = 0;
    _616 *= _609.d0;
    _616 += _614;
    _609.data[_616] = _615;
    _614++;
    if (_614 < _610)
    goto _jump1429;
    // End body of loop
    _608 = _609;
    goto _jump1430;
    _jump1425:;
    int64_t _617 = 320;
    int64_t _618 = 910;
    int64_t _619 = _617 % _618;
    _a1_int64_t _620;
    _620.d0 = 1;
    _620.data = jpl_alloc(sizeof(int64_t) * 1);
    _620.data[0] = _619;
    _608 = _620;
    _jump1430:;
    _605 = _608;
    goto _jump1431;
    _jump1423:;
    _a1_int64_t _621;
    // Computing bound for i
    int64_t _622;
    if (!_404)
    goto _jump1432;
    int64_t _623 = 680;
    int64_t _624 = -_623;
    _622 = _624;
    goto _jump1433;
    _jump1432:;
    int64_t _625 = 308;
    _622 = _625;
    _jump1433:;
    _621.d0 = _622;
    if (_622 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing total size of heap memory to allocate
    int64_t _626 = 1;
    _626 *= _622;
    _626 *= sizeof(int64_t);
    _621.data = jpl_alloc(_626);
    int64_t _627 = 0; // i
    _jump1435:; // Begin body of loop
    _a1_int64_t _628;
    // Computing bound for j
    _628.d0 = _627;
    if (_627 > 0) 
    goto _jump1436;
    fail_assertion("non-positive loop bound");
    _jump1436:;
    // Computing total size of heap memory to allocate
    int64_t _629 = 1;
    _629 *= _627;
    _629 *= sizeof(int64_t);
    _628.data = jpl_alloc(_629);
    int64_t _630 = 0; // j
    _jump1437:; // Begin body of loop
    int64_t _631 = 0;
    _631 *= _628.d0;
    _631 += _630;
    _628.data[_631] = _630;
    _630++;
    if (_630 < _627)
    goto _jump1437;
    // End body of loop
    int64_t _632 = g(_628);
    int64_t _633 = 0;
    _633 *= _621.d0;
    _633 += _627;
    _621.data[_633] = _632;
    _627++;
    if (_627 < _622)
    goto _jump1435;
    // End body of loop
    _605 = _621;
    _jump1431:;
    int64_t _634 = g(_605);
    if (_634 > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    // Computing bound for j
    bool _636;
    if (!_74)
    goto _jump1439;
    bool _637;
    if (!_404)
    goto _jump1440;
    _637 = _74;
    goto _jump1441;
    _jump1440:;
    _637 = _74;
    _jump1441:;
    bool _638;
    if (!_637)
    goto _jump1442;
    bool _639 = _0;
    if (0 != _0)
    goto _jump1443;
    _639 = _404;
    _jump1443:;
    _638 = _639;
    goto _jump1444;
    _jump1442:;
    _638 = _404;
    _jump1444:;
    _636 = _638;
    goto _jump1445;
    _jump1439:;
    _636 = _74;
    _jump1445:;
    bool _635 = _636;
    if (0 == _636)
    goto _jump1446;
    _a1_bool _640;
    _640.d0 = 1;
    _640.data = jpl_alloc(sizeof(bool) * 1);
    _640.data[0] = _74;
    _a1_int64_t _641;
    // Computing bound for i
    int64_t _642 = 351;
    _641.d0 = _642;
    if (_642 > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    // Computing total size of heap memory to allocate
    int64_t _643 = 1;
    _643 *= _642;
    _643 *= sizeof(int64_t);
    _641.data = jpl_alloc(_643);
    int64_t _644 = 0; // i
    _jump1448:; // Begin body of loop
    int64_t _645 = 795;
    int64_t _646 = 0;
    _646 *= _641.d0;
    _646 += _644;
    _641.data[_646] = _645;
    _644++;
    if (_644 < _642)
    goto _jump1448;
    // End body of loop
    int64_t _647 = 368;
    if (_647 >= 0)
    goto _jump1449;
    fail_assertion("negative array index");
    _jump1449:;
    if (_647 < _641.d0)
    goto _jump1450;
    fail_assertion("index too large");
    _jump1450:;
    int64_t _648 = 0;
    _648 *= _641.d0;
    _648 += _647;
    int64_t _649 = _641.data[_648];
    if (_649 >= 0)
    goto _jump1451;
    fail_assertion("negative array index");
    _jump1451:;
    if (_649 < _640.d0)
    goto _jump1452;
    fail_assertion("index too large");
    _jump1452:;
    int64_t _650 = 0;
    _650 *= _640.d0;
    _650 += _649;
    bool _651 = _640.data[_650];
    _635 = _651;
    _jump1446:;
    int64_t _652;
    if (!_635)
    goto _jump1453;
    int64_t _653 = 665;
    _652 = _653;
    goto _jump1454;
    _jump1453:;
    _a1_int64_t _654;
    // Computing bound for i
    int64_t _655 = 961;
    _654.d0 = _655;
    if (_655 > 0) 
    goto _jump1455;
    fail_assertion("non-positive loop bound");
    _jump1455:;
    // Computing total size of heap memory to allocate
    int64_t _656 = 1;
    _656 *= _655;
    _656 *= sizeof(int64_t);
    _654.data = jpl_alloc(_656);
    int64_t _657 = 0; // i
    _jump1456:; // Begin body of loop
    int64_t _658 = 630;
    int64_t _659 = 0;
    _659 *= _654.d0;
    _659 += _657;
    _654.data[_659] = _658;
    _657++;
    if (_657 < _655)
    goto _jump1456;
    // End body of loop
    int64_t _660 = g(_654);
    _a1_int64_t _661;
    _661.d0 = 1;
    _661.data = jpl_alloc(sizeof(int64_t) * 1);
    _661.data[0] = _660;
    int64_t _662 = g(_661);
    _652 = _662;
    _jump1454:;
    if (_652 > 0) 
    goto _jump1457;
    fail_assertion("non-positive loop bound");
    _jump1457:;
    // Computing bound for k
    int64_t _663;
    // Computing bound for i
    int64_t _664 = 142;
    int64_t _665 = -_664;
    int64_t _666 = -_665;
    if (_666 > 0) 
    goto _jump1458;
    fail_assertion("non-positive loop bound");
    _jump1458:;
    // Computing bound for j
    int64_t _667 = 787;
    if (_667 > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    // Computing bound for k
    int64_t _668 = 284;
    int64_t _669 = 511;
    int64_t _670 = _668 * _669;
    if (_670 > 0) 
    goto _jump1460;
    fail_assertion("non-positive loop bound");
    _jump1460:;
    _663 = 0;
    int64_t _671 = 0; // k
    int64_t _672 = 0; // j
    int64_t _673 = 0; // i
    _jump1461:; // Begin body of loop
    _663 += _673;
    _671++;
    if (_671 < _670)
    goto _jump1461;
    _671 = 0;
    _672++;
    if (_672 < _667)
    goto _jump1461;
    _672 = 0;
    _673++;
    if (_673 < _666)
    goto _jump1461;
    // End body of loop
    bool _674 = true;
    int64_t _675;
    if (!_674)
    goto _jump1462;
    bool _676 = _74;
    if (0 != _74)
    goto _jump1463;
    _676 = _74;
    _jump1463:;
    int64_t _677;
    if (!_676)
    goto _jump1464;
    int64_t _678 = 872;
    _677 = _678;
    goto _jump1465;
    _jump1464:;
    int64_t _679 = 852;
    _677 = _679;
    _jump1465:;
    _675 = _677;
    goto _jump1466;
    _jump1462:;
    int64_t _680 = 164;
    _675 = _680;
    _jump1466:;
    int64_t _681 = _663 * _675;
    _a3_int64_t _682;
    // Computing bound for i
    int64_t _683 = 158;
    _682.d0 = _683;
    if (_683 > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    // Computing bound for j
    int64_t _684 = 415;
    int64_t _685 = -_684;
    _682.d1 = _685;
    if (_685 > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing bound for k
    int64_t _686;
    if (!_404)
    goto _jump1469;
    int64_t _687 = 527;
    _686 = _687;
    goto _jump1470;
    _jump1469:;
    int64_t _688 = 497;
    _686 = _688;
    _jump1470:;
    _682.d2 = _686;
    if (_686 > 0) 
    goto _jump1471;
    fail_assertion("non-positive loop bound");
    _jump1471:;
    // Computing total size of heap memory to allocate
    int64_t _689 = 1;
    _689 *= _683;
    _689 *= _685;
    _689 *= _686;
    _689 *= sizeof(int64_t);
    _682.data = jpl_alloc(_689);
    int64_t _690 = 0; // k
    int64_t _691 = 0; // j
    int64_t _692 = 0; // i
    _jump1472:; // Begin body of loop
    int64_t _693;
    if (!_74)
    goto _jump1473;
    _693 = _692;
    goto _jump1474;
    _jump1473:;
    int64_t _694 = 840;
    _693 = _694;
    _jump1474:;
    int64_t _695 = -_693;
    int64_t _696 = 0;
    _696 *= _682.d0;
    _696 += _692;
    _696 *= _682.d1;
    _696 += _691;
    _696 *= _682.d2;
    _696 += _690;
    _682.data[_696] = _695;
    _690++;
    if (_690 < _686)
    goto _jump1472;
    _690 = 0;
    _691++;
    if (_691 < _685)
    goto _jump1472;
    _691 = 0;
    _692++;
    if (_692 < _683)
    goto _jump1472;
    // End body of loop
    int64_t _697 = 241;
    int64_t _698 = -_697;
    int64_t _699 = -_698;
    int64_t _700 = -_699;
    int64_t _701;
    // Computing bound for i
    _a1_int64_t _702;
    // Computing bound for i
    int64_t _703 = 19;
    _702.d0 = _703;
    if (_703 > 0) 
    goto _jump1475;
    fail_assertion("non-positive loop bound");
    _jump1475:;
    // Computing total size of heap memory to allocate
    int64_t _704 = 1;
    _704 *= _703;
    _704 *= sizeof(int64_t);
    _702.data = jpl_alloc(_704);
    int64_t _705 = 0; // i
    _jump1476:; // Begin body of loop
    int64_t _706 = 276;
    int64_t _707 = 0;
    _707 *= _702.d0;
    _707 += _705;
    _702.data[_707] = _706;
    _705++;
    if (_705 < _703)
    goto _jump1476;
    // End body of loop
    int64_t _708 = g(_702);
    if (_708 > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    _701 = 0;
    int64_t _709 = 0; // i
    _jump1478:; // Begin body of loop
    _a1_int64_t _710;
    _710.d0 = 3;
    _710.data = jpl_alloc(sizeof(int64_t) * 3);
    _710.data[0] = _709;
    _710.data[1] = _709;
    _710.data[2] = _709;
    int64_t _711 = g(_710);
    _701 += _711;
    _709++;
    if (_709 < _708)
    goto _jump1478;
    // End body of loop
    int64_t _712 = 811;
    if (_700 >= 0)
    goto _jump1479;
    fail_assertion("negative array index");
    _jump1479:;
    if (_700 < _682.d0)
    goto _jump1480;
    fail_assertion("index too large");
    _jump1480:;
    if (_701 >= 0)
    goto _jump1481;
    fail_assertion("negative array index");
    _jump1481:;
    if (_701 < _682.d1)
    goto _jump1482;
    fail_assertion("index too large");
    _jump1482:;
    if (_712 >= 0)
    goto _jump1483;
    fail_assertion("negative array index");
    _jump1483:;
    if (_712 < _682.d2)
    goto _jump1484;
    fail_assertion("index too large");
    _jump1484:;
    int64_t _713 = 0;
    _713 *= _682.d0;
    _713 += _700;
    _713 *= _682.d1;
    _713 += _701;
    _713 *= _682.d2;
    _713 += _712;
    int64_t _714 = _682.data[_713];
    int64_t _715 = _681 % _714;
    if (_715 > 0) 
    goto _jump1485;
    fail_assertion("non-positive loop bound");
    _jump1485:;
    _604 = 0;
    int64_t _716 = 0; // k
    int64_t _717 = 0; // j
    int64_t _718 = 0; // i
    _jump1486:; // Begin body of loop
    int64_t _720 = 817;
    bool _721 = _717 != _720;
    bool _719 = _721;
    if (0 == _721)
    goto _jump1487;
    int64_t _722 = 911;
    bool _723 = _722 >= _716;
    bool _724;
    if (!_723)
    goto _jump1488;
    _724 = _74;
    goto _jump1489;
    _jump1488:;
    bool _725 = !_404;
    _724 = _725;
    _jump1489:;
    bool _726 = !_724;
    _719 = _726;
    _jump1487:;
    int64_t _727;
    if (!_719)
    goto _jump1490;
    int64_t _728 = 752;
    _727 = _728;
    goto _jump1491;
    _jump1490:;
    int64_t _729 = _717 % _717;
    int64_t _730 = -_729;
    _727 = _730;
    _jump1491:;
    _604 += _727;
    _716++;
    if (_716 < _715)
    goto _jump1486;
    _716 = 0;
    _717++;
    if (_717 < _652)
    goto _jump1486;
    _717 = 0;
    _718++;
    if (_718 < _634)
    goto _jump1486;
    // End body of loop
    int64_t _731;
    // Computing bound for i
    int64_t _732;
    // Computing bound for i
    int64_t _733 = 762;
    if (_733 > 0) 
    goto _jump1492;
    fail_assertion("non-positive loop bound");
    _jump1492:;
    _732 = 0;
    int64_t _734 = 0; // i
    _jump1493:; // Begin body of loop
    int64_t _735 = 606;
    _732 += _735;
    _734++;
    if (_734 < _733)
    goto _jump1493;
    // End body of loop
    if (_732 > 0) 
    goto _jump1494;
    fail_assertion("non-positive loop bound");
    _jump1494:;
    // Computing bound for j
    _a1_int64_t _736;
    // Computing bound for i
    int64_t _737 = 811;
    _736.d0 = _737;
    if (_737 > 0) 
    goto _jump1495;
    fail_assertion("non-positive loop bound");
    _jump1495:;
    // Computing total size of heap memory to allocate
    int64_t _738 = 1;
    _738 *= _737;
    _738 *= sizeof(int64_t);
    _736.data = jpl_alloc(_738);
    int64_t _739 = 0; // i
    _jump1496:; // Begin body of loop
    int64_t _740 = 0;
    _740 *= _736.d0;
    _740 += _739;
    _736.data[_740] = _739;
    _739++;
    if (_739 < _737)
    goto _jump1496;
    // End body of loop
    int64_t _741 = g(_736);
    int64_t _742 = -_741;
    if (_742 > 0) 
    goto _jump1497;
    fail_assertion("non-positive loop bound");
    _jump1497:;
    // Computing bound for k
    int64_t _743;
    // Computing bound for i
    int64_t _744 = 203;
    if (_744 > 0) 
    goto _jump1498;
    fail_assertion("non-positive loop bound");
    _jump1498:;
    _743 = 0;
    int64_t _745 = 0; // i
    _jump1499:; // Begin body of loop
    int64_t _746;
    // Computing bound for j
    int64_t _747 = 775;
    int64_t _748 = -_747;
    if (_748 > 0) 
    goto _jump1500;
    fail_assertion("non-positive loop bound");
    _jump1500:;
    // Computing bound for k
    int64_t _749 = 605;
    if (_749 > 0) 
    goto _jump1501;
    fail_assertion("non-positive loop bound");
    _jump1501:;
    _746 = 0;
    int64_t _750 = 0; // k
    int64_t _751 = 0; // j
    _jump1502:; // Begin body of loop
    _a1_int64_t _752;
    // Computing bound for l
    _752.d0 = _750;
    if (_750 > 0) 
    goto _jump1503;
    fail_assertion("non-positive loop bound");
    _jump1503:;
    // Computing total size of heap memory to allocate
    int64_t _753 = 1;
    _753 *= _750;
    _753 *= sizeof(int64_t);
    _752.data = jpl_alloc(_753);
    int64_t _754 = 0; // l
    _jump1504:; // Begin body of loop
    int64_t _755 = 0;
    _755 *= _752.d0;
    _755 += _754;
    _752.data[_755] = _745;
    _754++;
    if (_754 < _750)
    goto _jump1504;
    // End body of loop
    int64_t _756 = g(_752);
    _746 += _756;
    _750++;
    if (_750 < _749)
    goto _jump1502;
    _750 = 0;
    _751++;
    if (_751 < _748)
    goto _jump1502;
    // End body of loop
    _743 += _746;
    _745++;
    if (_745 < _744)
    goto _jump1499;
    // End body of loop
    if (_743 > 0) 
    goto _jump1505;
    fail_assertion("non-positive loop bound");
    _jump1505:;
    _731 = 0;
    int64_t _757 = 0; // k
    int64_t _758 = 0; // j
    int64_t _759 = 0; // i
    _jump1506:; // Begin body of loop
    _731 += _759;
    _757++;
    if (_757 < _743)
    goto _jump1506;
    _757 = 0;
    _758++;
    if (_758 < _742)
    goto _jump1506;
    _758 = 0;
    _759++;
    if (_759 < _732)
    goto _jump1506;
    // End body of loop
    int64_t _760 = 778;
    int64_t _761 = 179;
    int64_t _762 = -_761;
    int64_t _763 = _760 % _762;
    _a1_int64_t _764;
    _764.d0 = 1;
    _764.data = jpl_alloc(sizeof(int64_t) * 1);
    _764.data[0] = _763;
    int64_t _765 = 515;
    int64_t _766 = 812;
    _a1_int64_t _767;
    _767.d0 = 1;
    _767.data = jpl_alloc(sizeof(int64_t) * 1);
    _767.data[0] = _766;
    int64_t _768 = 714;
    if (_768 >= 0)
    goto _jump1507;
    fail_assertion("negative array index");
    _jump1507:;
    if (_768 < _767.d0)
    goto _jump1508;
    fail_assertion("index too large");
    _jump1508:;
    int64_t _769 = 0;
    _769 *= _767.d0;
    _769 += _768;
    int64_t _770 = _767.data[_769];
    int64_t _771 = _765 - _770;
    int64_t _772 = 216;
    int64_t _773 = _771 - _772;
    if (_773 >= 0)
    goto _jump1509;
    fail_assertion("negative array index");
    _jump1509:;
    if (_773 < _764.d0)
    goto _jump1510;
    fail_assertion("index too large");
    _jump1510:;
    int64_t _774 = 0;
    _774 *= _764.d0;
    _774 += _773;
    int64_t _775 = _764.data[_774];
    _a1_int64_t _776;
    // Computing bound for i
    int64_t _777 = 134;
    _776.d0 = _777;
    if (_777 > 0) 
    goto _jump1511;
    fail_assertion("non-positive loop bound");
    _jump1511:;
    // Computing total size of heap memory to allocate
    int64_t _778 = 1;
    _778 *= _777;
    _778 *= sizeof(int64_t);
    _776.data = jpl_alloc(_778);
    int64_t _779 = 0; // i
    _jump1512:; // Begin body of loop
    _a1_int64_t _780;
    // Computing bound for j
    _780.d0 = _779;
    if (_779 > 0) 
    goto _jump1513;
    fail_assertion("non-positive loop bound");
    _jump1513:;
    // Computing total size of heap memory to allocate
    int64_t _781 = 1;
    _781 *= _779;
    _781 *= sizeof(int64_t);
    _780.data = jpl_alloc(_781);
    int64_t _782 = 0; // j
    _jump1514:; // Begin body of loop
    int64_t _783 = 714;
    int64_t _784 = 0;
    _784 *= _780.d0;
    _784 += _782;
    _780.data[_784] = _783;
    _782++;
    if (_782 < _779)
    goto _jump1514;
    // End body of loop
    int64_t _785 = g(_780);
    int64_t _786 = 0;
    _786 *= _776.d0;
    _786 += _779;
    _776.data[_786] = _785;
    _779++;
    if (_779 < _777)
    goto _jump1512;
    // End body of loop
    int64_t _787 = g(_776);
    int64_t _788 = _775 / _787;
    if (_604 >= 0)
    goto _jump1515;
    fail_assertion("negative array index");
    _jump1515:;
    if (_604 < _405.d0)
    goto _jump1516;
    fail_assertion("index too large");
    _jump1516:;
    if (_731 >= 0)
    goto _jump1517;
    fail_assertion("negative array index");
    _jump1517:;
    if (_731 < _405.d1)
    goto _jump1518;
    fail_assertion("index too large");
    _jump1518:;
    if (_788 >= 0)
    goto _jump1519;
    fail_assertion("negative array index");
    _jump1519:;
    if (_788 < _405.d2)
    goto _jump1520;
    fail_assertion("index too large");
    _jump1520:;
    int64_t _789 = 0;
    _789 *= _405.d0;
    _789 += _604;
    _789 *= _405.d1;
    _789 += _731;
    _789 *= _405.d2;
    _789 += _788;
    _a1_bool _790 = _405.data[_789];
    _a1__a2_rgba _791;
    // Computing bound for k
    int64_t _792 = -_790.d0;
    _791.d0 = _792;
    if (_792 > 0) 
    goto _jump1521;
    fail_assertion("non-positive loop bound");
    _jump1521:;
    // Computing total size of heap memory to allocate
    int64_t _793 = 1;
    _793 *= _792;
    _793 *= sizeof(_a2_rgba);
    _791.data = jpl_alloc(_793);
    int64_t _794 = 0; // k
    _jump1522:; // Begin body of loop
    bool _795 = _404;
    if (0 != _404)
    goto _jump1523;
    _795 = _404;
    _jump1523:;
    int64_t _796;
    if (!_795)
    goto _jump1524;
    int64_t _797;
    // Computing bound for l
    int64_t _798 = 37;
    if (_798 > 0) 
    goto _jump1525;
    fail_assertion("non-positive loop bound");
    _jump1525:;
    _797 = 0;
    int64_t _799 = 0; // l
    _jump1526:; // Begin body of loop
    _797 += _799;
    _799++;
    if (_799 < _798)
    goto _jump1526;
    // End body of loop
    _796 = _797;
    goto _jump1527;
    _jump1524:;
    _a1_int64_t _800;
    // Computing bound for l
    _800.d0 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump1528;
    fail_assertion("non-positive loop bound");
    _jump1528:;
    // Computing total size of heap memory to allocate
    int64_t _801 = 1;
    _801 *= _790.d0;
    _801 *= sizeof(int64_t);
    _800.data = jpl_alloc(_801);
    int64_t _802 = 0; // l
    _jump1529:; // Begin body of loop
    int64_t _803 = 0;
    _803 *= _800.d0;
    _803 += _802;
    _800.data[_803] = _790.d0;
    _802++;
    if (_802 < _790.d0)
    goto _jump1529;
    // End body of loop
    int64_t _804 = g(_800);
    _796 = _804;
    _jump1527:;
    if (_796 >= 0)
    goto _jump1530;
    fail_assertion("negative array index");
    _jump1530:;
    if (_796 < _790.d0)
    goto _jump1531;
    fail_assertion("index too large");
    _jump1531:;
    int64_t _805 = 0;
    _805 *= _790.d0;
    _805 += _796;
    bool _806 = _790.data[_805];
    _a2_rgba _807;
    if (!_806)
    goto _jump1532;
    _a2_rgba _808;
    // Computing bound for l
    _a3_int64_t _809;
    // Computing bound for l
    int64_t _810;
    // Computing bound for l
    if (_794 > 0) 
    goto _jump1533;
    fail_assertion("non-positive loop bound");
    _jump1533:;
    // Computing bound for m
    if (_790.d0 > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    _810 = 0;
    int64_t _811 = 0; // m
    int64_t _812 = 0; // l
    _jump1535:; // Begin body of loop
    _810 += _812;
    _811++;
    if (_811 < _790.d0)
    goto _jump1535;
    _811 = 0;
    _812++;
    if (_812 < _794)
    goto _jump1535;
    // End body of loop
    _809.d0 = _810;
    if (_810 > 0) 
    goto _jump1536;
    fail_assertion("non-positive loop bound");
    _jump1536:;
    // Computing bound for m
    _809.d1 = _794;
    if (_794 > 0) 
    goto _jump1537;
    fail_assertion("non-positive loop bound");
    _jump1537:;
    // Computing bound for n
    int64_t _813 = 654;
    _809.d2 = _813;
    if (_813 > 0) 
    goto _jump1538;
    fail_assertion("non-positive loop bound");
    _jump1538:;
    // Computing total size of heap memory to allocate
    int64_t _814 = 1;
    _814 *= _810;
    _814 *= _794;
    _814 *= _813;
    _814 *= sizeof(int64_t);
    _809.data = jpl_alloc(_814);
    int64_t _815 = 0; // n
    int64_t _816 = 0; // m
    int64_t _817 = 0; // l
    _jump1539:; // Begin body of loop
    int64_t _818;
    if (!_74)
    goto _jump1540;
    int64_t _819 = 833;
    _818 = _819;
    goto _jump1541;
    _jump1540:;
    _818 = _815;
    _jump1541:;
    int64_t _820 = 0;
    _820 *= _809.d0;
    _820 += _817;
    _820 *= _809.d1;
    _820 += _816;
    _820 *= _809.d2;
    _820 += _815;
    _809.data[_820] = _818;
    _815++;
    if (_815 < _813)
    goto _jump1539;
    _815 = 0;
    _816++;
    if (_816 < _794)
    goto _jump1539;
    _816 = 0;
    _817++;
    if (_817 < _810)
    goto _jump1539;
    // End body of loop
    int64_t _821 = 41;
    bool _822 = _74;
    if (0 != _74)
    goto _jump1542;
    bool _823 = true;
    _822 = _823;
    _jump1542:;
    int64_t _824;
    if (!_822)
    goto _jump1543;
    int64_t _825 = -_790.d0;
    _824 = _825;
    goto _jump1544;
    _jump1543:;
    _824 = _790.d0;
    _jump1544:;
    if (_821 >= 0)
    goto _jump1545;
    fail_assertion("negative array index");
    _jump1545:;
    if (_821 < _809.d0)
    goto _jump1546;
    fail_assertion("index too large");
    _jump1546:;
    if (_794 >= 0)
    goto _jump1547;
    fail_assertion("negative array index");
    _jump1547:;
    if (_794 < _809.d1)
    goto _jump1548;
    fail_assertion("index too large");
    _jump1548:;
    if (_824 >= 0)
    goto _jump1549;
    fail_assertion("negative array index");
    _jump1549:;
    if (_824 < _809.d2)
    goto _jump1550;
    fail_assertion("index too large");
    _jump1550:;
    int64_t _826 = 0;
    _826 *= _809.d0;
    _826 += _821;
    _826 *= _809.d1;
    _826 += _794;
    _826 *= _809.d2;
    _826 += _824;
    int64_t _827 = _809.data[_826];
    _808.d0 = _827;
    if (_827 > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    // Computing bound for m
    int64_t _828 = 948;
    _808.d1 = _828;
    if (_828 > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing total size of heap memory to allocate
    int64_t _829 = 1;
    _829 *= _827;
    _829 *= _828;
    _829 *= sizeof(rgba);
    _808.data = jpl_alloc(_829);
    int64_t _830 = 0; // m
    int64_t _831 = 0; // l
    _jump1553:; // Begin body of loop
    double _832 = 9.0;
    double _833 = -_832;
    double _834 = _76 - _76;
    double _835 = 16.0;
    rgba _836 = { _833, _834, _835, _76 };
    int64_t _837 = 0;
    _837 *= _808.d0;
    _837 += _831;
    _837 *= _808.d1;
    _837 += _830;
    _808.data[_837] = _836;
    _830++;
    if (_830 < _828)
    goto _jump1553;
    _830 = 0;
    _831++;
    if (_831 < _827)
    goto _jump1553;
    // End body of loop
    _807 = _808;
    goto _jump1554;
    _jump1532:;
    _a2_rgba _838;
    // Computing bound for l
    bool _839 = false;
    bool _840;
    if (!_839)
    goto _jump1555;
    _840 = _404;
    goto _jump1556;
    _jump1555:;
    _840 = _404;
    _jump1556:;
    bool _841;
    if (!_840)
    goto _jump1557;
    _841 = _0;
    goto _jump1558;
    _jump1557:;
    bool _842 = true;
    _841 = _842;
    _jump1558:;
    int64_t _843;
    if (!_841)
    goto _jump1559;
    _843 = _794;
    goto _jump1560;
    _jump1559:;
    int64_t _844;
    if (!_74)
    goto _jump1561;
    _844 = _790.d0;
    goto _jump1562;
    _jump1561:;
    int64_t _845 = 214;
    _844 = _845;
    _jump1562:;
    _843 = _844;
    _jump1560:;
    _838.d0 = _843;
    if (_843 > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing bound for m
    bool _846 = false;
    int64_t _847;
    if (!_846)
    goto _jump1564;
    int64_t _848 = 825;
    _847 = _848;
    goto _jump1565;
    _jump1564:;
    int64_t _849 = 122;
    _847 = _849;
    _jump1565:;
    _838.d1 = _847;
    if (_847 > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    // Computing total size of heap memory to allocate
    int64_t _850 = 1;
    _850 *= _843;
    _850 *= _847;
    _850 *= sizeof(rgba);
    _838.data = jpl_alloc(_850);
    int64_t _851 = 0; // m
    int64_t _852 = 0; // l
    _jump1567:; // Begin body of loop
    bool _854 = false;
    bool _853 = _854;
    if (0 == _854)
    goto _jump1568;
    _853 = _0;
    _jump1568:;
    double _855;
    if (!_853)
    goto _jump1569;
    double _856 = 63.0;
    _855 = _856;
    goto _jump1570;
    _jump1569:;
    double _857 = 63.0;
    _855 = _857;
    _jump1570:;
    double _858 = 62.0;
    double _859 = -_76;
    rgba _860 = { _855, _858, _76, _859 };
    int64_t _861 = 0;
    _861 *= _838.d0;
    _861 += _852;
    _861 *= _838.d1;
    _861 += _851;
    _838.data[_861] = _860;
    _851++;
    if (_851 < _847)
    goto _jump1567;
    _851 = 0;
    _852++;
    if (_852 < _843)
    goto _jump1567;
    // End body of loop
    _807 = _838;
    _jump1554:;
    int64_t _862 = 0;
    _862 *= _791.d0;
    _862 += _794;
    _791.data[_862] = _807;
    _794++;
    if (_794 < _792)
    goto _jump1522;
    // End body of loop
    if (_790.d0 >= 0)
    goto _jump1571;
    fail_assertion("negative array index");
    _jump1571:;
    if (_790.d0 < _791.d0)
    goto _jump1572;
    fail_assertion("index too large");
    _jump1572:;
    int64_t _863 = 0;
    _863 *= _791.d0;
    _863 += _790.d0;
    _a2_rgba _864 = _791.data[_863];
    write_image(_864, "k.png");
    _a2_rgba _865;
    // Computing bound for m
    _865.d0 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump1573;
    fail_assertion("non-positive loop bound");
    _jump1573:;
    // Computing bound for n
    int64_t _866 = -_790.d0;
    _865.d1 = _866;
    if (_866 > 0) 
    goto _jump1574;
    fail_assertion("non-positive loop bound");
    _jump1574:;
    // Computing total size of heap memory to allocate
    int64_t _867 = 1;
    _867 *= _790.d0;
    _867 *= _866;
    _867 *= sizeof(rgba);
    _865.data = jpl_alloc(_867);
    int64_t _868 = 0; // n
    int64_t _869 = 0; // m
    _jump1575:; // Begin body of loop
    double _870 = fmod(_76, _76);
    double _871 = -_76;
    double _872 = 77.0;
    double _873 = _872 * _76;
    rgba _874 = { _870, _871, _76, _873 };
    int64_t _875 = 0;
    _875 *= _865.d0;
    _875 += _869;
    _875 *= _865.d1;
    _875 += _868;
    _865.data[_875] = _874;
    _868++;
    if (_868 < _866)
    goto _jump1575;
    _868 = 0;
    _869++;
    if (_869 < _790.d0)
    goto _jump1575;
    // End body of loop
    _a3_int64_t _876;
    // Computing bound for m
    int64_t _877 = 658;
    int64_t _878 = 670;
    int64_t _879 = _877 * _878;
    int64_t _880 = -_879;
    _876.d0 = _880;
    if (_880 > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    // Computing bound for n
    int64_t _881 = 361;
    int64_t _882 = _881 % _790.d0;
    int64_t _883 = _882 + _790.d0;
    _876.d1 = _883;
    if (_883 > 0) 
    goto _jump1577;
    fail_assertion("non-positive loop bound");
    _jump1577:;
    // Computing bound for o
    _876.d2 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump1578;
    fail_assertion("non-positive loop bound");
    _jump1578:;
    // Computing total size of heap memory to allocate
    int64_t _884 = 1;
    _884 *= _880;
    _884 *= _883;
    _884 *= _790.d0;
    _884 *= sizeof(int64_t);
    _876.data = jpl_alloc(_884);
    int64_t _885 = 0; // o
    int64_t _886 = 0; // n
    int64_t _887 = 0; // m
    _jump1579:; // Begin body of loop
    int64_t _888 = 0;
    _888 *= _876.d0;
    _888 += _887;
    _888 *= _876.d1;
    _888 += _886;
    _888 *= _876.d2;
    _888 += _885;
    _876.data[_888] = _885;
    _885++;
    if (_885 < _790.d0)
    goto _jump1579;
    _885 = 0;
    _886++;
    if (_886 < _883)
    goto _jump1579;
    _886 = 0;
    _887++;
    if (_887 < _880)
    goto _jump1579;
    // End body of loop
    int64_t _889;
    // Computing bound for m
    if (_790.d0 > 0) 
    goto _jump1580;
    fail_assertion("non-positive loop bound");
    _jump1580:;
    // Computing bound for n
    int64_t _890 = -_790.d0;
    if (_890 > 0) 
    goto _jump1581;
    fail_assertion("non-positive loop bound");
    _jump1581:;
    // Computing bound for o
    if (_790.d0 > 0) 
    goto _jump1582;
    fail_assertion("non-positive loop bound");
    _jump1582:;
    _889 = 0;
    int64_t _891 = 0; // o
    int64_t _892 = 0; // n
    int64_t _893 = 0; // m
    _jump1583:; // Begin body of loop
    int64_t _894 = 820;
    _a1_int64_t _895;
    _895.d0 = 2;
    _895.data = jpl_alloc(sizeof(int64_t) * 2);
    _895.data[0] = _790.d0;
    _895.data[1] = _894;
    int64_t _896 = g(_895);
    _889 += _896;
    _891++;
    if (_891 < _790.d0)
    goto _jump1583;
    _891 = 0;
    _892++;
    if (_892 < _890)
    goto _jump1583;
    _892 = 0;
    _893++;
    if (_893 < _790.d0)
    goto _jump1583;
    // End body of loop
    int64_t _897;
    // Computing bound for m
    int64_t _898 = 503;
    int64_t _899 = _790.d0 * _898;
    int64_t _900 = _899 / _790.d0;
    if (_900 > 0) 
    goto _jump1584;
    fail_assertion("non-positive loop bound");
    _jump1584:;
    // Computing bound for n
    int64_t _901;
    // Computing bound for m
    int64_t _902 = 511;
    if (_902 > 0) 
    goto _jump1585;
    fail_assertion("non-positive loop bound");
    _jump1585:;
    // Computing bound for n
    if (_790.d0 > 0) 
    goto _jump1586;
    fail_assertion("non-positive loop bound");
    _jump1586:;
    _901 = 0;
    int64_t _903 = 0; // n
    int64_t _904 = 0; // m
    _jump1587:; // Begin body of loop
    int64_t _905 = 737;
    _901 += _905;
    _903++;
    if (_903 < _790.d0)
    goto _jump1587;
    _903 = 0;
    _904++;
    if (_904 < _902)
    goto _jump1587;
    // End body of loop
    int64_t _906;
    if (!_74)
    goto _jump1588;
    _906 = _790.d0;
    goto _jump1589;
    _jump1588:;
    _906 = _790.d0;
    _jump1589:;
    int64_t _907 = _901 % _906;
    if (_907 > 0) 
    goto _jump1590;
    fail_assertion("non-positive loop bound");
    _jump1590:;
    // Computing bound for o
    _a1_int64_t _908;
    _908.d0 = 2;
    _908.data = jpl_alloc(sizeof(int64_t) * 2);
    _908.data[0] = _790.d0;
    _908.data[1] = _790.d0;
    int64_t _909 = g(_908);
    if (_909 > 0) 
    goto _jump1591;
    fail_assertion("non-positive loop bound");
    _jump1591:;
    _897 = 0;
    int64_t _910 = 0; // o
    int64_t _911 = 0; // n
    int64_t _912 = 0; // m
    _jump1592:; // Begin body of loop
    int64_t _913;
    // Computing bound for p
    if (_912 > 0) 
    goto _jump1593;
    fail_assertion("non-positive loop bound");
    _jump1593:;
    // Computing bound for q
    if (_911 > 0) 
    goto _jump1594;
    fail_assertion("non-positive loop bound");
    _jump1594:;
    // Computing bound for r
    if (_911 > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    _913 = 0;
    int64_t _914 = 0; // r
    int64_t _915 = 0; // q
    int64_t _916 = 0; // p
    _jump1596:; // Begin body of loop
    _913 += _790.d0;
    _914++;
    if (_914 < _911)
    goto _jump1596;
    _914 = 0;
    _915++;
    if (_915 < _911)
    goto _jump1596;
    _915 = 0;
    _916++;
    if (_916 < _912)
    goto _jump1596;
    // End body of loop
    int64_t _917 = _911 - _913;
    _897 += _917;
    _910++;
    if (_910 < _909)
    goto _jump1592;
    _910 = 0;
    _911++;
    if (_911 < _907)
    goto _jump1592;
    _911 = 0;
    _912++;
    if (_912 < _900)
    goto _jump1592;
    // End body of loop
    if (_889 >= 0)
    goto _jump1597;
    fail_assertion("negative array index");
    _jump1597:;
    if (_889 < _876.d0)
    goto _jump1598;
    fail_assertion("index too large");
    _jump1598:;
    if (_897 >= 0)
    goto _jump1599;
    fail_assertion("negative array index");
    _jump1599:;
    if (_897 < _876.d1)
    goto _jump1600;
    fail_assertion("index too large");
    _jump1600:;
    if (_790.d0 >= 0)
    goto _jump1601;
    fail_assertion("negative array index");
    _jump1601:;
    if (_790.d0 < _876.d2)
    goto _jump1602;
    fail_assertion("index too large");
    _jump1602:;
    int64_t _918 = 0;
    _918 *= _876.d0;
    _918 += _889;
    _918 *= _876.d1;
    _918 += _897;
    _918 *= _876.d2;
    _918 += _790.d0;
    int64_t _919 = _876.data[_918];
    if (_919 >= 0)
    goto _jump1603;
    fail_assertion("negative array index");
    _jump1603:;
    if (_919 < _865.d0)
    goto _jump1604;
    fail_assertion("index too large");
    _jump1604:;
    if (_790.d0 >= 0)
    goto _jump1605;
    fail_assertion("negative array index");
    _jump1605:;
    if (_790.d0 < _865.d1)
    goto _jump1606;
    fail_assertion("index too large");
    _jump1606:;
    int64_t _920 = 0;
    _920 *= _865.d0;
    _920 += _919;
    _920 *= _865.d1;
    _920 += _790.d0;
    rgba _921 = _865.data[_920];
    double _922 = _921.r;
    bool _923 = _76 < _922;
    show("(BoolType)", &_923);
    print("n");
    print("o");
    print("o");
    print("o");
    bool _924 = true;
    double _925 = get_time();
    int64_t _926 = n();
    _a1_int64_t _927;
    // Computing bound for p
    _927.d0 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2373;
    fail_assertion("non-positive loop bound");
    _jump2373:;
    // Computing total size of heap memory to allocate
    int64_t _928 = 1;
    _928 *= _790.d0;
    _928 *= sizeof(int64_t);
    _927.data = jpl_alloc(_928);
    int64_t _929 = 0; // p
    _jump2374:; // Begin body of loop
    int64_t _930 = n();
    int64_t _931 = 0;
    _931 *= _927.d0;
    _931 += _929;
    _927.data[_931] = _930;
    _929++;
    if (_929 < _790.d0)
    goto _jump2374;
    // End body of loop
    int64_t _932 = g(_927);
    bool _933 = _926 <= _932;
    bool _934 = _74 == _933;
    _a3__a2_bool _935;
    if (!_934)
    goto _jump2375;
    _a3__a2_bool _936;
    // Computing bound for p
    bool _938;
    if (!_924)
    goto _jump2376;
    _938 = _404;
    goto _jump2377;
    _jump2376:;
    _938 = _404;
    _jump2377:;
    bool _937 = _938;
    if (0 != _938)
    goto _jump2378;
    bool _940 = true;
    bool _939 = _940;
    if (0 == _940)
    goto _jump2379;
    _939 = _74;
    _jump2379:;
    _937 = _939;
    _jump2378:;
    int64_t _941;
    if (!_937)
    goto _jump2380;
    int64_t _942;
    // Computing bound for p
    if (_790.d0 > 0) 
    goto _jump2381;
    fail_assertion("non-positive loop bound");
    _jump2381:;
    _942 = 0;
    int64_t _943 = 0; // p
    _jump2382:; // Begin body of loop
    int64_t _944 = 554;
    _942 += _944;
    _943++;
    if (_943 < _790.d0)
    goto _jump2382;
    // End body of loop
    _941 = _942;
    goto _jump2383;
    _jump2380:;
    int64_t _945 = n();
    _941 = _945;
    _jump2383:;
    _936.d0 = _941;
    if (_941 > 0) 
    goto _jump2384;
    fail_assertion("non-positive loop bound");
    _jump2384:;
    // Computing bound for q
    bool _946 = true;
    int64_t _947;
    if (!_946)
    goto _jump2385;
    int64_t _948 = n();
    _947 = _948;
    goto _jump2386;
    _jump2385:;
    int64_t _949;
    if (!_0)
    goto _jump2387;
    int64_t _950;
    // Computing bound for p
    if (_790.d0 > 0) 
    goto _jump2388;
    fail_assertion("non-positive loop bound");
    _jump2388:;
    _950 = 0;
    int64_t _951 = 0; // p
    _jump2389:; // Begin body of loop
    int64_t _952 = n();
    _950 += _952;
    _951++;
    if (_951 < _790.d0)
    goto _jump2389;
    // End body of loop
    _949 = _950;
    goto _jump2390;
    _jump2387:;
    int64_t _953 = 532;
    int64_t _954 = _953 + _790.d0;
    _949 = _954;
    _jump2390:;
    _947 = _949;
    _jump2386:;
    _936.d1 = _947;
    if (_947 > 0) 
    goto _jump2391;
    fail_assertion("non-positive loop bound");
    _jump2391:;
    // Computing bound for r
    _936.d2 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2392;
    fail_assertion("non-positive loop bound");
    _jump2392:;
    // Computing total size of heap memory to allocate
    int64_t _955 = 1;
    _955 *= _941;
    _955 *= _947;
    _955 *= _790.d0;
    _955 *= sizeof(_a2_bool);
    _936.data = jpl_alloc(_955);
    int64_t _956 = 0; // r
    int64_t _957 = 0; // q
    int64_t _958 = 0; // p
    _jump2393:; // Begin body of loop
    bool _959;
    if (!_924)
    goto _jump2394;
    _959 = _924;
    goto _jump2395;
    _jump2394:;
    bool _960 = !_0;
    _959 = _960;
    _jump2395:;
    _a2_bool _961;
    if (!_959)
    goto _jump2396;
    _a2_bool _962;
    // Computing bound for s
    int64_t _963;
    // Computing bound for s
    int64_t _964 = 380;
    if (_964 > 0) 
    goto _jump2397;
    fail_assertion("non-positive loop bound");
    _jump2397:;
    // Computing bound for t
    int64_t _965 = n();
    if (_965 > 0) 
    goto _jump2398;
    fail_assertion("non-positive loop bound");
    _jump2398:;
    _963 = 0;
    int64_t _966 = 0; // t
    int64_t _967 = 0; // s
    _jump2399:; // Begin body of loop
    _963 += _966;
    _966++;
    if (_966 < _965)
    goto _jump2399;
    _966 = 0;
    _967++;
    if (_967 < _964)
    goto _jump2399;
    // End body of loop
    _962.d0 = _963;
    if (_963 > 0) 
    goto _jump2400;
    fail_assertion("non-positive loop bound");
    _jump2400:;
    // Computing bound for t
    _962.d1 = _958;
    if (_958 > 0) 
    goto _jump2401;
    fail_assertion("non-positive loop bound");
    _jump2401:;
    // Computing total size of heap memory to allocate
    int64_t _968 = 1;
    _968 *= _963;
    _968 *= _958;
    _968 *= sizeof(bool);
    _962.data = jpl_alloc(_968);
    int64_t _969 = 0; // t
    int64_t _970 = 0; // s
    _jump2402:; // Begin body of loop
    bool _971 = !_0;
    int64_t _972 = 0;
    _972 *= _962.d0;
    _972 += _970;
    _972 *= _962.d1;
    _972 += _969;
    _962.data[_972] = _971;
    _969++;
    if (_969 < _958)
    goto _jump2402;
    _969 = 0;
    _970++;
    if (_970 < _963)
    goto _jump2402;
    // End body of loop
    _961 = _962;
    goto _jump2403;
    _jump2396:;
    _a2_bool _973;
    // Computing bound for s
    _973.d0 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2404;
    fail_assertion("non-positive loop bound");
    _jump2404:;
    // Computing bound for t
    int64_t _974 = 642;
    _973.d1 = _974;
    if (_974 > 0) 
    goto _jump2405;
    fail_assertion("non-positive loop bound");
    _jump2405:;
    // Computing total size of heap memory to allocate
    int64_t _975 = 1;
    _975 *= _790.d0;
    _975 *= _974;
    _975 *= sizeof(bool);
    _973.data = jpl_alloc(_975);
    int64_t _976 = 0; // t
    int64_t _977 = 0; // s
    _jump2406:; // Begin body of loop
    bool _978 = false;
    bool _979 = !_978;
    int64_t _980 = 0;
    _980 *= _973.d0;
    _980 += _977;
    _980 *= _973.d1;
    _980 += _976;
    _973.data[_980] = _979;
    _976++;
    if (_976 < _974)
    goto _jump2406;
    _976 = 0;
    _977++;
    if (_977 < _790.d0)
    goto _jump2406;
    // End body of loop
    _961 = _973;
    _jump2403:;
    int64_t _981 = 0;
    _981 *= _936.d0;
    _981 += _958;
    _981 *= _936.d1;
    _981 += _957;
    _981 *= _936.d2;
    _981 += _956;
    _936.data[_981] = _961;
    _956++;
    if (_956 < _790.d0)
    goto _jump2393;
    _956 = 0;
    _957++;
    if (_957 < _947)
    goto _jump2393;
    _957 = 0;
    _958++;
    if (_958 < _941)
    goto _jump2393;
    // End body of loop
    _935 = _936;
    goto _jump2407;
    _jump2375:;
    _a3__a2_bool _982;
    // Computing bound for p
    _982.d0 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2408;
    fail_assertion("non-positive loop bound");
    _jump2408:;
    // Computing bound for q
    int64_t _983 = 176;
    _a1_int64_t _984;
    _984.d0 = 2;
    _984.data = jpl_alloc(sizeof(int64_t) * 2);
    _984.data[0] = _983;
    _984.data[1] = _790.d0;
    int64_t _985 = g(_984);
    int64_t _986 = n();
    int64_t _987 = 485;
    _a1_int64_t _988;
    _988.d0 = 3;
    _988.data = jpl_alloc(sizeof(int64_t) * 3);
    _988.data[0] = _986;
    _988.data[1] = _987;
    _988.data[2] = _790.d0;
    int64_t _989 = g(_988);
    int64_t _990 = _985 / _989;
    _982.d1 = _990;
    if (_990 > 0) 
    goto _jump2409;
    fail_assertion("non-positive loop bound");
    _jump2409:;
    // Computing bound for r
    int64_t _991;
    // Computing bound for p
    bool _992 = false;
    int64_t _993;
    if (!_992)
    goto _jump2410;
    int64_t _994 = -_790.d0;
    _993 = _994;
    goto _jump2411;
    _jump2410:;
    _993 = _790.d0;
    _jump2411:;
    if (_993 > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    _991 = 0;
    int64_t _995 = 0; // p
    _jump2413:; // Begin body of loop
    _991 += _995;
    _995++;
    if (_995 < _993)
    goto _jump2413;
    // End body of loop
    _982.d2 = _991;
    if (_991 > 0) 
    goto _jump2414;
    fail_assertion("non-positive loop bound");
    _jump2414:;
    // Computing total size of heap memory to allocate
    int64_t _996 = 1;
    _996 *= _790.d0;
    _996 *= _990;
    _996 *= _991;
    _996 *= sizeof(_a2_bool);
    _982.data = jpl_alloc(_996);
    int64_t _997 = 0; // r
    int64_t _998 = 0; // q
    int64_t _999 = 0; // p
    _jump2415:; // Begin body of loop
    _a2_bool _1000;
    // Computing bound for s
    int64_t _1001 = n();
    int64_t _1002 = -_1001;
    _1000.d0 = _1002;
    if (_1002 > 0) 
    goto _jump2416;
    fail_assertion("non-positive loop bound");
    _jump2416:;
    // Computing bound for t
    _1000.d1 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2417;
    fail_assertion("non-positive loop bound");
    _jump2417:;
    // Computing total size of heap memory to allocate
    int64_t _1003 = 1;
    _1003 *= _1002;
    _1003 *= _790.d0;
    _1003 *= sizeof(bool);
    _1000.data = jpl_alloc(_1003);
    int64_t _1004 = 0; // t
    int64_t _1005 = 0; // s
    _jump2418:; // Begin body of loop
    bool _1006 = _999 >= _1004;
    int64_t _1007 = 0;
    _1007 *= _1000.d0;
    _1007 += _1005;
    _1007 *= _1000.d1;
    _1007 += _1004;
    _1000.data[_1007] = _1006;
    _1004++;
    if (_1004 < _790.d0)
    goto _jump2418;
    _1004 = 0;
    _1005++;
    if (_1005 < _1002)
    goto _jump2418;
    // End body of loop
    int64_t _1008 = 0;
    _1008 *= _982.d0;
    _1008 += _999;
    _1008 *= _982.d1;
    _1008 += _998;
    _1008 *= _982.d2;
    _1008 += _997;
    _982.data[_1008] = _1000;
    _997++;
    if (_997 < _991)
    goto _jump2415;
    _997 = 0;
    _998++;
    if (_998 < _990)
    goto _jump2415;
    _998 = 0;
    _999++;
    if (_999 < _790.d0)
    goto _jump2415;
    // End body of loop
    _935 = _982;
    _jump2407:;
    bool _1009;
    if (!_404)
    goto _jump2419;
    _1009 = _74;
    goto _jump2420;
    _jump2419:;
    _1009 = _924;
    _jump2420:;
    bool _1010;
    if (!_1009)
    goto _jump2421;
    bool _1012 = true;
    bool _1011 = _1012;
    if (0 != _1012)
    goto _jump2422;
    bool _1013 = true;
    _1011 = _1013;
    _jump2422:;
    bool _1014 = !_1011;
    _1010 = _1014;
    goto _jump2423;
    _jump2421:;
    _1010 = _924;
    _jump2423:;
    bool _1015;
    if (!_1010)
    goto _jump2424;
    _1015 = _0;
    goto _jump2425;
    _jump2424:;
    bool _1016 = false;
    int64_t _1017;
    if (!_1016)
    goto _jump2426;
    _1017 = _790.d0;
    goto _jump2427;
    _jump2426:;
    _1017 = _790.d0;
    _jump2427:;
    bool _1018 = true;
    int64_t _1019;
    if (!_1018)
    goto _jump2428;
    _1019 = _790.d0;
    goto _jump2429;
    _jump2428:;
    _1019 = _790.d0;
    _jump2429:;
    int64_t _1020 = 475;
    int64_t _1021 = n();
    int64_t _1022 = _1020 % _1021;
    int64_t _1023 = _1019 % _1022;
    bool _1024 = _1017 <= _1023;
    _1015 = _1024;
    _jump2425:;
    int64_t _1025;
    if (!_1015)
    goto _jump2430;
    bool _1026 = true;
    int64_t _1027;
    if (!_1026)
    goto _jump2431;
    bool _1028 = _404;
    if (0 != _404)
    goto _jump2432;
    _1028 = _404;
    _jump2432:;
    int64_t _1029;
    if (!_1028)
    goto _jump2433;
    int64_t _1030 = n();
    int64_t _1031 = -_1030;
    _1029 = _1031;
    goto _jump2434;
    _jump2433:;
    int64_t _1032 = 156;
    _1029 = _1032;
    _jump2434:;
    _1027 = _1029;
    goto _jump2435;
    _jump2431:;
    _a3_int64_t _1033;
    // Computing bound for p
    int64_t _1034 = n();
    _1033.d0 = _1034;
    if (_1034 > 0) 
    goto _jump2436;
    fail_assertion("non-positive loop bound");
    _jump2436:;
    // Computing bound for q
    int64_t _1035 = 47;
    _1033.d1 = _1035;
    if (_1035 > 0) 
    goto _jump2437;
    fail_assertion("non-positive loop bound");
    _jump2437:;
    // Computing bound for r
    _1033.d2 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2438;
    fail_assertion("non-positive loop bound");
    _jump2438:;
    // Computing total size of heap memory to allocate
    int64_t _1036 = 1;
    _1036 *= _1034;
    _1036 *= _1035;
    _1036 *= _790.d0;
    _1036 *= sizeof(int64_t);
    _1033.data = jpl_alloc(_1036);
    int64_t _1037 = 0; // r
    int64_t _1038 = 0; // q
    int64_t _1039 = 0; // p
    _jump2439:; // Begin body of loop
    int64_t _1040 = 0;
    _1040 *= _1033.d0;
    _1040 += _1039;
    _1040 *= _1033.d1;
    _1040 += _1038;
    _1040 *= _1033.d2;
    _1040 += _1037;
    _1033.data[_1040] = _790.d0;
    _1037++;
    if (_1037 < _790.d0)
    goto _jump2439;
    _1037 = 0;
    _1038++;
    if (_1038 < _1035)
    goto _jump2439;
    _1038 = 0;
    _1039++;
    if (_1039 < _1034)
    goto _jump2439;
    // End body of loop
    int64_t _1041 = 475;
    int64_t _1042;
    if (!_924)
    goto _jump2440;
    _1042 = _790.d0;
    goto _jump2441;
    _jump2440:;
    _1042 = _790.d0;
    _jump2441:;
    if (_1041 >= 0)
    goto _jump2442;
    fail_assertion("negative array index");
    _jump2442:;
    if (_1041 < _1033.d0)
    goto _jump2443;
    fail_assertion("index too large");
    _jump2443:;
    if (_1042 >= 0)
    goto _jump2444;
    fail_assertion("negative array index");
    _jump2444:;
    if (_1042 < _1033.d1)
    goto _jump2445;
    fail_assertion("index too large");
    _jump2445:;
    if (_790.d0 >= 0)
    goto _jump2446;
    fail_assertion("negative array index");
    _jump2446:;
    if (_790.d0 < _1033.d2)
    goto _jump2447;
    fail_assertion("index too large");
    _jump2447:;
    int64_t _1043 = 0;
    _1043 *= _1033.d0;
    _1043 += _1041;
    _1043 *= _1033.d1;
    _1043 += _1042;
    _1043 *= _1033.d2;
    _1043 += _790.d0;
    int64_t _1044 = _1033.data[_1043];
    _1027 = _1044;
    _jump2435:;
    int64_t _1045 = -_1027;
    _1025 = _1045;
    goto _jump2448;
    _jump2430:;
    int64_t _1046 = n();
    _1025 = _1046;
    _jump2448:;
    int64_t _1047 = n();
    _a1__a1_int64_t _1048;
    // Computing bound for p
    _1048.d0 = _790.d0;
    if (_790.d0 > 0) 
    goto _jump2449;
    fail_assertion("non-positive loop bound");
    _jump2449:;
    // Computing total size of heap memory to allocate
    int64_t _1049 = 1;
    _1049 *= _790.d0;
    _1049 *= sizeof(_a1_int64_t);
    _1048.data = jpl_alloc(_1049);
    int64_t _1050 = 0; // p
    _jump2450:; // Begin body of loop
    int64_t _1051 = n();
    int64_t _1052 = 331;
    _a1_int64_t _1053;
    _1053.d0 = 3;
    _1053.data = jpl_alloc(sizeof(int64_t) * 3);
    _1053.data[0] = _790.d0;
    _1053.data[1] = _1051;
    _1053.data[2] = _1052;
    int64_t _1054 = 0;
    _1054 *= _1048.d0;
    _1054 += _1050;
    _1048.data[_1054] = _1053;
    _1050++;
    if (_1050 < _790.d0)
    goto _jump2450;
    // End body of loop
    int64_t _1055 = 738;
    if (_1055 >= 0)
    goto _jump2451;
    fail_assertion("negative array index");
    _jump2451:;
    if (_1055 < _1048.d0)
    goto _jump2452;
    fail_assertion("index too large");
    _jump2452:;
    int64_t _1056 = 0;
    _1056 *= _1048.d0;
    _1056 += _1055;
    _a1_int64_t _1057 = _1048.data[_1056];
    int64_t _1058 = g(_1057);
    int64_t _1059 = _1047 % _1058;
    int64_t _1060 = n();
    _a1_int64_t _1061;
    // Computing bound for p
    int64_t _1062 = n();
    int64_t _1063 = 524;
    int64_t _1064 = _1062 * _1063;
    _1061.d0 = _1064;
    if (_1064 > 0) 
    goto _jump2453;
    fail_assertion("non-positive loop bound");
    _jump2453:;
    // Computing total size of heap memory to allocate
    int64_t _1065 = 1;
    _1065 *= _1064;
    _1065 *= sizeof(int64_t);
    _1061.data = jpl_alloc(_1065);
    int64_t _1066 = 0; // p
    _jump2454:; // Begin body of loop
    int64_t _1067;
    if (!_404)
    goto _jump2455;
    _1067 = _790.d0;
    goto _jump2456;
    _jump2455:;
    int64_t _1068;
    // Computing bound for q
    int64_t _1069 = n();
    if (_1069 > 0) 
    goto _jump2457;
    fail_assertion("non-positive loop bound");
    _jump2457:;
    // Computing bound for r
    int64_t _1070 = n();
    if (_1070 > 0) 
    goto _jump2458;
    fail_assertion("non-positive loop bound");
    _jump2458:;
    // Computing bound for s
    int64_t _1071 = n();
    if (_1071 > 0) 
    goto _jump2459;
    fail_assertion("non-positive loop bound");
    _jump2459:;
    _1068 = 0;
    int64_t _1072 = 0; // s
    int64_t _1073 = 0; // r
    int64_t _1074 = 0; // q
    _jump2460:; // Begin body of loop
    _1068 += _790.d0;
    _1072++;
    if (_1072 < _1071)
    goto _jump2460;
    _1072 = 0;
    _1073++;
    if (_1073 < _1070)
    goto _jump2460;
    _1073 = 0;
    _1074++;
    if (_1074 < _1069)
    goto _jump2460;
    // End body of loop
    _1067 = _1068;
    _jump2456:;
    int64_t _1075 = 0;
    _1075 *= _1061.d0;
    _1075 += _1066;
    _1061.data[_1075] = _1067;
    _1066++;
    if (_1066 < _1064)
    goto _jump2454;
    // End body of loop
    int64_t _1076 = g(_1061);
    int64_t _1077 = _1060 % _1076;
    if (_1025 >= 0)
    goto _jump2461;
    fail_assertion("negative array index");
    _jump2461:;
    if (_1025 < _935.d0)
    goto _jump2462;
    fail_assertion("index too large");
    _jump2462:;
    if (_1059 >= 0)
    goto _jump2463;
    fail_assertion("negative array index");
    _jump2463:;
    if (_1059 < _935.d1)
    goto _jump2464;
    fail_assertion("index too large");
    _jump2464:;
    if (_1077 >= 0)
    goto _jump2465;
    fail_assertion("negative array index");
    _jump2465:;
    if (_1077 < _935.d2)
    goto _jump2466;
    fail_assertion("index too large");
    _jump2466:;
    int64_t _1078 = 0;
    _1078 *= _935.d0;
    _1078 += _1025;
    _1078 *= _935.d1;
    _1078 += _1059;
    _1078 *= _935.d2;
    _1078 += _1077;
    _a2_bool _1079 = _935.data[_1078];
    double _1080 = get_time();
    print_time(_1080 - _925);
    print("s");
}

