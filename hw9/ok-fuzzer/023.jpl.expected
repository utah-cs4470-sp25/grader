
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_int64_t *data;
} _a3__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_bool *data;
} _a3__a2__a3_bool;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_rgba *data;
} _a3__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_rgba *data;
} _a2__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2__a1_int64_t *data;
} _a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1__a2__a1_int64_t *data;
} _a1__a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  _a3__a2_rgba *data;
} _a1__a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_rgba *data;
} _a2__a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_rgba *data;
} _a3__a3__a2_rgba;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a3_bool *data;
} _a2__a1__a3_bool;

typedef struct {
  int64_t d0;
  _a1__a3_bool *data;
} _a1__a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_int64_t *data;
} _a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_rgba *data;
} _a2__a3_rgba;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2_rgba *data;
} _a2__a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_void_t *data;
} _a2__a2_void_t;

typedef struct {
  int64_t d0;
  _a3__a1_int64_t *data;
} _a1__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

double a(rgba b) {
    _a3__a3__a1_int64_t _0;
    // Computing bound for c
    int64_t _1 = 965;
    int64_t _2 = 620;
    int64_t _3 = -_2;
    int64_t _4 = 699;
    int64_t _5 = -_4;
    _a1_int64_t _6;
    _6.d0 = 3;
    _6.data = jpl_alloc(sizeof(int64_t) * 3);
    _6.data[0] = _1;
    _6.data[1] = _3;
    _6.data[2] = _5;
    int64_t _7 = 672;
    if (_7 >= 0)
    goto _jump1;
    fail_assertion("negative array index");
    _jump1:;
    if (_7 < _6.d0)
    goto _jump2;
    fail_assertion("index too large");
    _jump2:;
    int64_t _8 = 0;
    _8 *= _6.d0;
    _8 += _7;
    int64_t _9 = _6.data[_8];
    int64_t _10;
    // Computing bound for c
    int64_t _11 = 28;
    bool _12 = true;
    int64_t _13;
    if (!_12)
    goto _jump3;
    int64_t _14 = 213;
    _13 = _14;
    goto _jump4;
    _jump3:;
    int64_t _15 = 195;
    _13 = _15;
    _jump4:;
    int64_t _16 = _11 - _13;
    if (_16 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing bound for d
    int64_t _17;
    // Computing bound for c
    int64_t _18 = 274;
    if (_18 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    // Computing bound for d
    int64_t _19 = 845;
    if (_19 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing bound for e
    int64_t _20 = 195;
    int64_t _21 = -_20;
    if (_21 > 0) 
    goto _jump8;
    fail_assertion("non-positive loop bound");
    _jump8:;
    _17 = 0;
    int64_t _22 = 0; // e
    int64_t _23 = 0; // d
    int64_t _24 = 0; // c
    _jump9:; // Begin body of loop
    int64_t _25;
    // Computing bound for f
    if (_23 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    // Computing bound for g
    if (_24 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    _25 = 0;
    int64_t _26 = 0; // g
    int64_t _27 = 0; // f
    _jump12:; // Begin body of loop
    _25 += _26;
    _26++;
    if (_26 < _24)
    goto _jump12;
    _26 = 0;
    _27++;
    if (_27 < _23)
    goto _jump12;
    // End body of loop
    _17 += _25;
    _22++;
    if (_22 < _21)
    goto _jump9;
    _22 = 0;
    _23++;
    if (_23 < _19)
    goto _jump9;
    _23 = 0;
    _24++;
    if (_24 < _18)
    goto _jump9;
    // End body of loop
    if (_17 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    // Computing bound for e
    int64_t _28 = 959;
    if (_28 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    _10 = 0;
    int64_t _29 = 0; // e
    int64_t _30 = 0; // d
    int64_t _31 = 0; // c
    _jump15:; // Begin body of loop
    int64_t _32;
    // Computing bound for f
    int64_t _33 = 953;
    if (_33 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    // Computing bound for g
    if (_30 > 0) 
    goto _jump17;
    fail_assertion("non-positive loop bound");
    _jump17:;
    // Computing bound for h
    if (_31 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    _32 = 0;
    int64_t _34 = 0; // h
    int64_t _35 = 0; // g
    int64_t _36 = 0; // f
    _jump19:; // Begin body of loop
    _32 += _30;
    _34++;
    if (_34 < _31)
    goto _jump19;
    _34 = 0;
    _35++;
    if (_35 < _30)
    goto _jump19;
    _35 = 0;
    _36++;
    if (_36 < _33)
    goto _jump19;
    // End body of loop
    _10 += _32;
    _29++;
    if (_29 < _28)
    goto _jump15;
    _29 = 0;
    _30++;
    if (_30 < _17)
    goto _jump15;
    _30 = 0;
    _31++;
    if (_31 < _16)
    goto _jump15;
    // End body of loop
    int64_t _37 = _9 * _10;
    _0.d0 = _37;
    if (_37 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    // Computing bound for d
    int64_t _38;
    // Computing bound for c
    int64_t _39 = 470;
    if (_39 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing bound for d
    int64_t _40 = 138;
    int64_t _41 = 247;
    bool _42 = _40 <= _41;
    int64_t _43;
    if (!_42)
    goto _jump22;
    int64_t _44 = 407;
    _43 = _44;
    goto _jump23;
    _jump22:;
    int64_t _45;
    // Computing bound for c
    int64_t _46 = 2;
    if (_46 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    // Computing bound for d
    int64_t _47 = 537;
    if (_47 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for e
    int64_t _48 = 566;
    if (_48 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    _45 = 0;
    int64_t _49 = 0; // e
    int64_t _50 = 0; // d
    int64_t _51 = 0; // c
    _jump27:; // Begin body of loop
    _45 += _51;
    _49++;
    if (_49 < _48)
    goto _jump27;
    _49 = 0;
    _50++;
    if (_50 < _47)
    goto _jump27;
    _50 = 0;
    _51++;
    if (_51 < _46)
    goto _jump27;
    // End body of loop
    int64_t _52 = -_45;
    _43 = _52;
    _jump23:;
    if (_43 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    // Computing bound for e
    int64_t _53;
    // Computing bound for c
    int64_t _54 = 226;
    int64_t _55 = 672;
    int64_t _56 = 309;
    int64_t _57 = _55 - _56;
    int64_t _58 = _54 / _57;
    if (_58 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    // Computing bound for d
    int64_t _59 = 252;
    int64_t _60 = 625;
    int64_t _61 = -_60;
    int64_t _62 = _59 + _61;
    if (_62 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    // Computing bound for e
    int64_t _63 = 784;
    int64_t _64 = -_63;
    int64_t _65 = 29;
    int64_t _66 = -_65;
    int64_t _67 = _64 % _66;
    if (_67 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    _53 = 0;
    int64_t _68 = 0; // e
    int64_t _69 = 0; // d
    int64_t _70 = 0; // c
    _jump32:; // Begin body of loop
    int64_t _71;
    // Computing bound for f
    if (_69 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing bound for g
    int64_t _72 = 727;
    int64_t _73 = _69 * _72;
    if (_73 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    // Computing bound for h
    int64_t _74;
    // Computing bound for f
    if (_68 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for g
    if (_68 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    // Computing bound for h
    int64_t _75 = 556;
    if (_75 > 0) 
    goto _jump37;
    fail_assertion("non-positive loop bound");
    _jump37:;
    _74 = 0;
    int64_t _76 = 0; // h
    int64_t _77 = 0; // g
    int64_t _78 = 0; // f
    _jump38:; // Begin body of loop
    _74 += _69;
    _76++;
    if (_76 < _75)
    goto _jump38;
    _76 = 0;
    _77++;
    if (_77 < _68)
    goto _jump38;
    _77 = 0;
    _78++;
    if (_78 < _68)
    goto _jump38;
    // End body of loop
    if (_74 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    _71 = 0;
    int64_t _79 = 0; // h
    int64_t _80 = 0; // g
    int64_t _81 = 0; // f
    _jump40:; // Begin body of loop
    _71 += _80;
    _79++;
    if (_79 < _74)
    goto _jump40;
    _79 = 0;
    _80++;
    if (_80 < _73)
    goto _jump40;
    _80 = 0;
    _81++;
    if (_81 < _69)
    goto _jump40;
    // End body of loop
    _53 += _71;
    _68++;
    if (_68 < _67)
    goto _jump32;
    _68 = 0;
    _69++;
    if (_69 < _62)
    goto _jump32;
    _69 = 0;
    _70++;
    if (_70 < _58)
    goto _jump32;
    // End body of loop
    if (_53 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    _38 = 0;
    int64_t _82 = 0; // e
    int64_t _83 = 0; // d
    int64_t _84 = 0; // c
    _jump42:; // Begin body of loop
    int64_t _85 = 941;
    int64_t _86 = 8;
    bool _87 = _85 >= _86;
    bool _88 = !_87;
    int64_t _89;
    if (!_88)
    goto _jump43;
    _89 = _82;
    goto _jump44;
    _jump43:;
    _89 = _83;
    _jump44:;
    _38 += _89;
    _82++;
    if (_82 < _53)
    goto _jump42;
    _82 = 0;
    _83++;
    if (_83 < _43)
    goto _jump42;
    _83 = 0;
    _84++;
    if (_84 < _39)
    goto _jump42;
    // End body of loop
    _0.d1 = _38;
    if (_38 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    // Computing bound for e
    bool _90 = false;
    bool _91 = !_90;
    bool _92 = !_91;
    bool _93 = !_92;
    int64_t _94;
    if (!_93)
    goto _jump46;
    bool _95 = true;
    int64_t _96;
    if (!_95)
    goto _jump47;
    int64_t _97 = 888;
    _96 = _97;
    goto _jump48;
    _jump47:;
    int64_t _98 = 455;
    _96 = _98;
    _jump48:;
    int64_t _99 = 516;
    bool _100 = _96 >= _99;
    int64_t _101;
    if (!_100)
    goto _jump49;
    int64_t _102 = 66;
    _101 = _102;
    goto _jump50;
    _jump49:;
    int64_t _103 = 512;
    _101 = _103;
    _jump50:;
    _94 = _101;
    goto _jump51;
    _jump46:;
    int64_t _104 = 417;
    _94 = _104;
    _jump51:;
    _0.d2 = _94;
    if (_94 > 0) 
    goto _jump52;
    fail_assertion("non-positive loop bound");
    _jump52:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _37;
    _105 *= _38;
    _105 *= _94;
    _105 *= sizeof(_a3__a1_int64_t);
    _0.data = jpl_alloc(_105);
    int64_t _106 = 0; // e
    int64_t _107 = 0; // d
    int64_t _108 = 0; // c
    _jump53:; // Begin body of loop
    _a3_bool _109;
    // Computing bound for f
    int64_t _110 = 153;
    _109.d0 = _110;
    if (_110 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for g
    _109.d1 = _108;
    if (_108 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    // Computing bound for h
    _109.d2 = _106;
    if (_106 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= _110;
    _111 *= _108;
    _111 *= _106;
    _111 *= sizeof(bool);
    _109.data = jpl_alloc(_111);
    int64_t _112 = 0; // h
    int64_t _113 = 0; // g
    int64_t _114 = 0; // f
    _jump57:; // Begin body of loop
    bool _115 = true;
    int64_t _116 = 0;
    _116 *= _109.d0;
    _116 += _114;
    _116 *= _109.d1;
    _116 += _113;
    _116 *= _109.d2;
    _116 += _112;
    _109.data[_116] = _115;
    _112++;
    if (_112 < _106)
    goto _jump57;
    _112 = 0;
    _113++;
    if (_113 < _108)
    goto _jump57;
    _113 = 0;
    _114++;
    if (_114 < _110)
    goto _jump57;
    // End body of loop
    int64_t _117 = -_108;
    int64_t _118 = 554;
    if (_108 >= 0)
    goto _jump58;
    fail_assertion("negative array index");
    _jump58:;
    if (_108 < _109.d0)
    goto _jump59;
    fail_assertion("index too large");
    _jump59:;
    if (_117 >= 0)
    goto _jump60;
    fail_assertion("negative array index");
    _jump60:;
    if (_117 < _109.d1)
    goto _jump61;
    fail_assertion("index too large");
    _jump61:;
    if (_118 >= 0)
    goto _jump62;
    fail_assertion("negative array index");
    _jump62:;
    if (_118 < _109.d2)
    goto _jump63;
    fail_assertion("index too large");
    _jump63:;
    int64_t _119 = 0;
    _119 *= _109.d0;
    _119 += _108;
    _119 *= _109.d1;
    _119 += _117;
    _119 *= _109.d2;
    _119 += _118;
    bool _120 = _109.data[_119];
    _a3__a1_int64_t _121;
    if (!_120)
    goto _jump64;
    _a3__a1_int64_t _122;
    // Computing bound for f
    _122.d0 = _106;
    if (_106 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing bound for g
    _122.d1 = _106;
    if (_106 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing bound for h
    int64_t _123;
    // Computing bound for f
    if (_107 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    // Computing bound for g
    if (_106 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    // Computing bound for h
    if (_107 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    _123 = 0;
    int64_t _124 = 0; // h
    int64_t _125 = 0; // g
    int64_t _126 = 0; // f
    _jump70:; // Begin body of loop
    _123 += _125;
    _124++;
    if (_124 < _107)
    goto _jump70;
    _124 = 0;
    _125++;
    if (_125 < _106)
    goto _jump70;
    _125 = 0;
    _126++;
    if (_126 < _107)
    goto _jump70;
    // End body of loop
    int64_t _127 = -_123;
    _122.d2 = _127;
    if (_127 > 0) 
    goto _jump71;
    fail_assertion("non-positive loop bound");
    _jump71:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _106;
    _128 *= _106;
    _128 *= _127;
    _128 *= sizeof(_a1_int64_t);
    _122.data = jpl_alloc(_128);
    int64_t _129 = 0; // h
    int64_t _130 = 0; // g
    int64_t _131 = 0; // f
    _jump72:; // Begin body of loop
    int64_t _132 = -_130;
    int64_t _133 = 991;
    _a1_int64_t _134;
    _134.d0 = 3;
    _134.data = jpl_alloc(sizeof(int64_t) * 3);
    _134.data[0] = _107;
    _134.data[1] = _132;
    _134.data[2] = _133;
    int64_t _135 = 0;
    _135 *= _122.d0;
    _135 += _131;
    _135 *= _122.d1;
    _135 += _130;
    _135 *= _122.d2;
    _135 += _129;
    _122.data[_135] = _134;
    _129++;
    if (_129 < _127)
    goto _jump72;
    _129 = 0;
    _130++;
    if (_130 < _106)
    goto _jump72;
    _130 = 0;
    _131++;
    if (_131 < _106)
    goto _jump72;
    // End body of loop
    _121 = _122;
    goto _jump73;
    _jump64:;
    _a3__a1_int64_t _136;
    // Computing bound for f
    _136.d0 = _106;
    if (_106 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    // Computing bound for g
    _136.d1 = _108;
    if (_108 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for h
    int64_t _137;
    // Computing bound for f
    if (_107 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    _137 = 0;
    int64_t _138 = 0; // f
    _jump77:; // Begin body of loop
    _137 += _107;
    _138++;
    if (_138 < _107)
    goto _jump77;
    // End body of loop
    int64_t _139 = -_137;
    _136.d2 = _139;
    if (_139 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= _106;
    _140 *= _108;
    _140 *= _139;
    _140 *= sizeof(_a1_int64_t);
    _136.data = jpl_alloc(_140);
    int64_t _141 = 0; // h
    int64_t _142 = 0; // g
    int64_t _143 = 0; // f
    _jump79:; // Begin body of loop
    int64_t _144 = -_108;
    _a1_int64_t _145;
    _145.d0 = 2;
    _145.data = jpl_alloc(sizeof(int64_t) * 2);
    _145.data[0] = _144;
    _145.data[1] = _106;
    int64_t _146 = 0;
    _146 *= _136.d0;
    _146 += _143;
    _146 *= _136.d1;
    _146 += _142;
    _146 *= _136.d2;
    _146 += _141;
    _136.data[_146] = _145;
    _141++;
    if (_141 < _139)
    goto _jump79;
    _141 = 0;
    _142++;
    if (_142 < _108)
    goto _jump79;
    _142 = 0;
    _143++;
    if (_143 < _106)
    goto _jump79;
    // End body of loop
    _121 = _136;
    _jump73:;
    int64_t _147 = 0;
    _147 *= _0.d0;
    _147 += _108;
    _147 *= _0.d1;
    _147 += _107;
    _147 *= _0.d2;
    _147 += _106;
    _0.data[_147] = _121;
    _106++;
    if (_106 < _94)
    goto _jump53;
    _106 = 0;
    _107++;
    if (_107 < _38)
    goto _jump53;
    _107 = 0;
    _108++;
    if (_108 < _37)
    goto _jump53;
    // End body of loop
    bool _149 = false;
    bool _148 = _149;
    if (0 == _149)
    goto _jump80;
    bool _150 = true;
    _148 = _150;
    _jump80:;
    int64_t _151;
    if (!_148)
    goto _jump81;
    int64_t _152;
    // Computing bound for c
    int64_t _153 = 921;
    if (_153 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing bound for d
    int64_t _154 = 778;
    int64_t _155 = 570;
    int64_t _156 = _154 + _155;
    if (_156 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    _152 = 0;
    int64_t _157 = 0; // d
    int64_t _158 = 0; // c
    _jump84:; // Begin body of loop
    bool _159 = false;
    int64_t _160;
    if (!_159)
    goto _jump85;
    int64_t _161;
    // Computing bound for e
    if (_157 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    _161 = 0;
    int64_t _162 = 0; // e
    _jump87:; // Begin body of loop
    int64_t _163 = 763;
    _161 += _163;
    _162++;
    if (_162 < _157)
    goto _jump87;
    // End body of loop
    _160 = _161;
    goto _jump88;
    _jump85:;
    _160 = _157;
    _jump88:;
    _152 += _160;
    _157++;
    if (_157 < _156)
    goto _jump84;
    _157 = 0;
    _158++;
    if (_158 < _153)
    goto _jump84;
    // End body of loop
    _151 = _152;
    goto _jump89;
    _jump81:;
    int64_t _164 = 862;
    int64_t _165 = 318;
    int64_t _166 = _164 * _165;
    _151 = _166;
    _jump89:;
    int64_t _167 = -_151;
    double _168 = b.b;
    double _169 = b.a;
    double _170 = _168 - _169;
    double _171 = -_170;
    double _172 = 77.0;
    _a1_double _173;
    _173.d0 = 1;
    _173.data = jpl_alloc(sizeof(double) * 1);
    _173.data[0] = _172;
    int64_t _174;
    // Computing bound for c
    int64_t _175 = 857;
    if (_175 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    _174 = 0;
    int64_t _176 = 0; // c
    _jump91:; // Begin body of loop
    int64_t _177 = 537;
    int64_t _178 = _177 * _176;
    _174 += _178;
    _176++;
    if (_176 < _175)
    goto _jump91;
    // End body of loop
    if (_174 >= 0)
    goto _jump92;
    fail_assertion("negative array index");
    _jump92:;
    if (_174 < _173.d0)
    goto _jump93;
    fail_assertion("index too large");
    _jump93:;
    int64_t _179 = 0;
    _179 *= _173.d0;
    _179 += _174;
    double _180 = _173.data[_179];
    bool _181 = _171 == _180;
    int64_t _182;
    if (!_181)
    goto _jump94;
    int64_t _183 = 89;
    _182 = _183;
    goto _jump95;
    _jump94:;
    int64_t _184 = 187;
    _182 = _184;
    _jump95:;
    int64_t _185 = 889;
    if (_167 >= 0)
    goto _jump96;
    fail_assertion("negative array index");
    _jump96:;
    if (_167 < _0.d0)
    goto _jump97;
    fail_assertion("index too large");
    _jump97:;
    if (_182 >= 0)
    goto _jump98;
    fail_assertion("negative array index");
    _jump98:;
    if (_182 < _0.d1)
    goto _jump99;
    fail_assertion("index too large");
    _jump99:;
    if (_185 >= 0)
    goto _jump100;
    fail_assertion("negative array index");
    _jump100:;
    if (_185 < _0.d2)
    goto _jump101;
    fail_assertion("index too large");
    _jump101:;
    int64_t _186 = 0;
    _186 *= _0.d0;
    _186 += _167;
    _186 *= _0.d1;
    _186 += _182;
    _186 *= _0.d2;
    _186 += _185;
    _a3__a1_int64_t _187 = _0.data[_186];
    int64_t _188;
    // Computing bound for c
    int64_t _189 = 315;
    if (_189 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    // Computing bound for d
    int64_t _190 = 530;
    if (_190 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    // Computing bound for e
    int64_t _191 = 177;
    if (_191 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    _188 = 0;
    int64_t _192 = 0; // e
    int64_t _193 = 0; // d
    int64_t _194 = 0; // c
    _jump105:; // Begin body of loop
    _a1_int64_t _195;
    // Computing bound for f
    _195.d0 = _192;
    if (_192 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= _192;
    _196 *= sizeof(int64_t);
    _195.data = jpl_alloc(_196);
    int64_t _197 = 0; // f
    _jump107:; // Begin body of loop
    int64_t _198 = 0;
    _198 *= _195.d0;
    _198 += _197;
    _195.data[_198] = _194;
    _197++;
    if (_197 < _192)
    goto _jump107;
    // End body of loop
    bool _199 = false;
    bool _200 = false;
    bool _201 = _199 == _200;
    bool _202 = !_201;
    int64_t _203;
    if (!_202)
    goto _jump108;
    _203 = _194;
    goto _jump109;
    _jump108:;
    int64_t _204 = 619;
    _203 = _204;
    _jump109:;
    if (_203 >= 0)
    goto _jump110;
    fail_assertion("negative array index");
    _jump110:;
    if (_203 < _195.d0)
    goto _jump111;
    fail_assertion("index too large");
    _jump111:;
    int64_t _205 = 0;
    _205 *= _195.d0;
    _205 += _203;
    int64_t _206 = _195.data[_205];
    _188 += _206;
    _192++;
    if (_192 < _191)
    goto _jump105;
    _192 = 0;
    _193++;
    if (_193 < _190)
    goto _jump105;
    _193 = 0;
    _194++;
    if (_194 < _189)
    goto _jump105;
    // End body of loop
    int64_t _207 = -_188;
    bool _208 = false;
    rgba _209;
    if (!_208)
    goto _jump112;
    _209 = b;
    goto _jump113;
    _jump112:;
    _209 = b;
    _jump113:;
    double _210 = a(_209);
    double _211 = a(b);
    bool _212 = _210 < _211;
    bool _213;
    if (!_212)
    goto _jump114;
    bool _214 = true;
    bool _215;
    if (!_214)
    goto _jump115;
    bool _216 = false;
    _215 = _216;
    goto _jump116;
    _jump115:;
    _a1_bool _217;
    // Computing bound for c
    int64_t _218 = 387;
    _217.d0 = _218;
    if (_218 > 0) 
    goto _jump117;
    fail_assertion("non-positive loop bound");
    _jump117:;
    // Computing total size of heap memory to allocate
    int64_t _219 = 1;
    _219 *= _218;
    _219 *= sizeof(bool);
    _217.data = jpl_alloc(_219);
    int64_t _220 = 0; // c
    _jump118:; // Begin body of loop
    bool _221 = true;
    int64_t _222 = 0;
    _222 *= _217.d0;
    _222 += _220;
    _217.data[_222] = _221;
    _220++;
    if (_220 < _218)
    goto _jump118;
    // End body of loop
    int64_t _223 = 371;
    int64_t _224 = -_223;
    int64_t _225 = -_224;
    if (_225 >= 0)
    goto _jump119;
    fail_assertion("negative array index");
    _jump119:;
    if (_225 < _217.d0)
    goto _jump120;
    fail_assertion("index too large");
    _jump120:;
    int64_t _226 = 0;
    _226 *= _217.d0;
    _226 += _225;
    bool _227 = _217.data[_226];
    _215 = _227;
    _jump116:;
    _213 = _215;
    goto _jump121;
    _jump114:;
    int64_t _228 = 500;
    int64_t _229 = -_228;
    int64_t _230 = 193;
    int64_t _231;
    // Computing bound for c
    int64_t _232 = 334;
    if (_232 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing bound for d
    int64_t _233 = 996;
    if (_233 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    _231 = 0;
    int64_t _234 = 0; // d
    int64_t _235 = 0; // c
    _jump124:; // Begin body of loop
    int64_t _236 = 649;
    _231 += _236;
    _234++;
    if (_234 < _233)
    goto _jump124;
    _234 = 0;
    _235++;
    if (_235 < _232)
    goto _jump124;
    // End body of loop
    bool _237 = true;
    int64_t _238;
    if (!_237)
    goto _jump125;
    int64_t _239 = 344;
    _238 = _239;
    goto _jump126;
    _jump125:;
    int64_t _240 = 370;
    _238 = _240;
    _jump126:;
    int64_t _241 = _231 * _238;
    int64_t _242 = _230 % _241;
    bool _243 = _229 == _242;
    _213 = _243;
    _jump121:;
    int64_t _244;
    if (!_213)
    goto _jump127;
    int64_t _245;
    // Computing bound for c
    int64_t _246 = 937;
    if (_246 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    // Computing bound for d
    int64_t _247 = 257;
    _a1_int64_t _248;
    _248.d0 = 1;
    _248.data = jpl_alloc(sizeof(int64_t) * 1);
    _248.data[0] = _247;
    int64_t _249 = 924;
    if (_249 >= 0)
    goto _jump129;
    fail_assertion("negative array index");
    _jump129:;
    if (_249 < _248.d0)
    goto _jump130;
    fail_assertion("index too large");
    _jump130:;
    int64_t _250 = 0;
    _250 *= _248.d0;
    _250 += _249;
    int64_t _251 = _248.data[_250];
    if (_251 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing bound for e
    int64_t _252 = 335;
    int64_t _253 = 773;
    int64_t _254 = -_253;
    int64_t _255 = _252 + _254;
    if (_255 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    _245 = 0;
    int64_t _256 = 0; // e
    int64_t _257 = 0; // d
    int64_t _258 = 0; // c
    _jump133:; // Begin body of loop
    _245 += _257;
    _256++;
    if (_256 < _255)
    goto _jump133;
    _256 = 0;
    _257++;
    if (_257 < _251)
    goto _jump133;
    _257 = 0;
    _258++;
    if (_258 < _246)
    goto _jump133;
    // End body of loop
    int64_t _259 = 385;
    int64_t _260 = 481;
    bool _261 = _259 != _260;
    bool _262 = !_261;
    int64_t _263;
    if (!_262)
    goto _jump134;
    int64_t _264 = 513;
    _263 = _264;
    goto _jump135;
    _jump134:;
    bool _266 = false;
    bool _265 = _266;
    if (0 == _266)
    goto _jump136;
    bool _267 = false;
    _265 = _267;
    _jump136:;
    int64_t _268;
    if (!_265)
    goto _jump137;
    int64_t _269 = 805;
    _268 = _269;
    goto _jump138;
    _jump137:;
    int64_t _270 = 644;
    _268 = _270;
    _jump138:;
    _263 = _268;
    _jump135:;
    int64_t _271 = _245 % _263;
    int64_t _272 = -_271;
    _244 = _272;
    goto _jump139;
    _jump127:;
    _a1_int64_t _273;
    // Computing bound for c
    int64_t _274 = 711;
    int64_t _275 = -_274;
    _273.d0 = _275;
    if (_275 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing total size of heap memory to allocate
    int64_t _276 = 1;
    _276 *= _275;
    _276 *= sizeof(int64_t);
    _273.data = jpl_alloc(_276);
    int64_t _277 = 0; // c
    _jump141:; // Begin body of loop
    int64_t _278;
    // Computing bound for d
    int64_t _279 = 405;
    if (_279 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    _278 = 0;
    int64_t _280 = 0; // d
    _jump143:; // Begin body of loop
    _278 += _280;
    _280++;
    if (_280 < _279)
    goto _jump143;
    // End body of loop
    int64_t _281 = 0;
    _281 *= _273.d0;
    _281 += _277;
    _273.data[_281] = _278;
    _277++;
    if (_277 < _275)
    goto _jump141;
    // End body of loop
    int64_t _282;
    // Computing bound for c
    int64_t _283 = 929;
    int64_t _284 = 137;
    bool _285 = _283 > _284;
    int64_t _286;
    if (!_285)
    goto _jump144;
    int64_t _287 = 390;
    _286 = _287;
    goto _jump145;
    _jump144:;
    int64_t _288 = 160;
    _286 = _288;
    _jump145:;
    if (_286 > 0) 
    goto _jump146;
    fail_assertion("non-positive loop bound");
    _jump146:;
    // Computing bound for d
    int64_t _289 = 858;
    int64_t _290 = 511;
    int64_t _291 = _289 + _290;
    if (_291 > 0) 
    goto _jump147;
    fail_assertion("non-positive loop bound");
    _jump147:;
    _282 = 0;
    int64_t _292 = 0; // d
    int64_t _293 = 0; // c
    _jump148:; // Begin body of loop
    int64_t _294;
    // Computing bound for e
    if (_293 > 0) 
    goto _jump149;
    fail_assertion("non-positive loop bound");
    _jump149:;
    // Computing bound for f
    if (_292 > 0) 
    goto _jump150;
    fail_assertion("non-positive loop bound");
    _jump150:;
    _294 = 0;
    int64_t _295 = 0; // f
    int64_t _296 = 0; // e
    _jump151:; // Begin body of loop
    _294 += _292;
    _295++;
    if (_295 < _292)
    goto _jump151;
    _295 = 0;
    _296++;
    if (_296 < _293)
    goto _jump151;
    // End body of loop
    _282 += _294;
    _292++;
    if (_292 < _291)
    goto _jump148;
    _292 = 0;
    _293++;
    if (_293 < _286)
    goto _jump148;
    // End body of loop
    int64_t _297 = -_282;
    if (_297 >= 0)
    goto _jump152;
    fail_assertion("negative array index");
    _jump152:;
    if (_297 < _273.d0)
    goto _jump153;
    fail_assertion("index too large");
    _jump153:;
    int64_t _298 = 0;
    _298 *= _273.d0;
    _298 += _297;
    int64_t _299 = _273.data[_298];
    _244 = _299;
    _jump139:;
    _a3_bool _300;
    // Computing bound for c
    int64_t _301;
    // Computing bound for c
    int64_t _302 = 531;
    if (_302 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for d
    int64_t _303 = 960;
    if (_303 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    _301 = 0;
    int64_t _304 = 0; // d
    int64_t _305 = 0; // c
    _jump156:; // Begin body of loop
    _301 += _304;
    _304++;
    if (_304 < _303)
    goto _jump156;
    _304 = 0;
    _305++;
    if (_305 < _302)
    goto _jump156;
    // End body of loop
    int64_t _306 = -_301;
    _300.d0 = _306;
    if (_306 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing bound for d
    int64_t _307;
    // Computing bound for c
    int64_t _308 = 160;
    int64_t _309 = 63;
    int64_t _310 = _308 * _309;
    if (_310 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    // Computing bound for d
    int64_t _311 = 992;
    if (_311 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    _307 = 0;
    int64_t _312 = 0; // d
    int64_t _313 = 0; // c
    _jump160:; // Begin body of loop
    int64_t _314 = 529;
    _307 += _314;
    _312++;
    if (_312 < _311)
    goto _jump160;
    _312 = 0;
    _313++;
    if (_313 < _310)
    goto _jump160;
    // End body of loop
    _300.d1 = _307;
    if (_307 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for e
    bool _315 = true;
    int64_t _316;
    if (!_315)
    goto _jump162;
    int64_t _317 = 349;
    _316 = _317;
    goto _jump163;
    _jump162:;
    int64_t _318 = 753;
    int64_t _319 = -_318;
    _316 = _319;
    _jump163:;
    _300.d2 = _316;
    if (_316 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing total size of heap memory to allocate
    int64_t _320 = 1;
    _320 *= _306;
    _320 *= _307;
    _320 *= _316;
    _320 *= sizeof(bool);
    _300.data = jpl_alloc(_320);
    int64_t _321 = 0; // e
    int64_t _322 = 0; // d
    int64_t _323 = 0; // c
    _jump165:; // Begin body of loop
    bool _325 = _322 < _323;
    bool _324 = _325;
    if (0 == _325)
    goto _jump166;
    bool _326 = true;
    bool _327 = !_326;
    _324 = _327;
    _jump166:;
    int64_t _328 = 0;
    _328 *= _300.d0;
    _328 += _323;
    _328 *= _300.d1;
    _328 += _322;
    _328 *= _300.d2;
    _328 += _321;
    _300.data[_328] = _324;
    _321++;
    if (_321 < _316)
    goto _jump165;
    _321 = 0;
    _322++;
    if (_322 < _307)
    goto _jump165;
    _322 = 0;
    _323++;
    if (_323 < _306)
    goto _jump165;
    // End body of loop
    int64_t _329;
    // Computing bound for c
    int64_t _330;
    // Computing bound for c
    int64_t _331 = 270;
    int64_t _332 = -_331;
    if (_332 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing bound for d
    int64_t _333 = 950;
    int64_t _334 = -_333;
    if (_334 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    // Computing bound for e
    int64_t _335 = 719;
    if (_335 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    _330 = 0;
    int64_t _336 = 0; // e
    int64_t _337 = 0; // d
    int64_t _338 = 0; // c
    _jump170:; // Begin body of loop
    int64_t _339 = -_336;
    _330 += _339;
    _336++;
    if (_336 < _335)
    goto _jump170;
    _336 = 0;
    _337++;
    if (_337 < _334)
    goto _jump170;
    _337 = 0;
    _338++;
    if (_338 < _332)
    goto _jump170;
    // End body of loop
    if (_330 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing bound for d
    int64_t _340 = 399;
    int64_t _341 = -_340;
    int64_t _342 = -_341;
    if (_342 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    // Computing bound for e
    int64_t _343 = 638;
    if (_343 > 0) 
    goto _jump173;
    fail_assertion("non-positive loop bound");
    _jump173:;
    _329 = 0;
    int64_t _344 = 0; // e
    int64_t _345 = 0; // d
    int64_t _346 = 0; // c
    _jump174:; // Begin body of loop
    int64_t _347 = 331;
    _329 += _347;
    _344++;
    if (_344 < _343)
    goto _jump174;
    _344 = 0;
    _345++;
    if (_345 < _342)
    goto _jump174;
    _345 = 0;
    _346++;
    if (_346 < _330)
    goto _jump174;
    // End body of loop
    int64_t _348;
    // Computing bound for c
    int64_t _349 = 966;
    if (_349 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing bound for d
    int64_t _350 = 871;
    if (_350 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    // Computing bound for e
    int64_t _351 = 319;
    if (_351 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    _348 = 0;
    int64_t _352 = 0; // e
    int64_t _353 = 0; // d
    int64_t _354 = 0; // c
    _jump178:; // Begin body of loop
    int64_t _355 = 29;
    int64_t _356 = _355 * _354;
    _348 += _356;
    _352++;
    if (_352 < _351)
    goto _jump178;
    _352 = 0;
    _353++;
    if (_353 < _350)
    goto _jump178;
    _353 = 0;
    _354++;
    if (_354 < _349)
    goto _jump178;
    // End body of loop
    int64_t _357 = 21;
    int64_t _358 = -_357;
    int64_t _359 = _348 % _358;
    int64_t _360 = 111;
    int64_t _361 = -_360;
    if (_329 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_329 < _300.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    if (_359 >= 0)
    goto _jump181;
    fail_assertion("negative array index");
    _jump181:;
    if (_359 < _300.d1)
    goto _jump182;
    fail_assertion("index too large");
    _jump182:;
    if (_361 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (_361 < _300.d2)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    int64_t _362 = 0;
    _362 *= _300.d0;
    _362 += _329;
    _362 *= _300.d1;
    _362 += _359;
    _362 *= _300.d2;
    _362 += _361;
    bool _363 = _300.data[_362];
    bool _364 = !_363;
    int64_t _365;
    if (!_364)
    goto _jump185;
    _a1_bool _367;
    // Computing bound for c
    int64_t _368 = 233;
    _367.d0 = _368;
    if (_368 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= _368;
    _369 *= sizeof(bool);
    _367.data = jpl_alloc(_369);
    int64_t _370 = 0; // c
    _jump187:; // Begin body of loop
    bool _371 = false;
    int64_t _372 = 0;
    _372 *= _367.d0;
    _372 += _370;
    _367.data[_372] = _371;
    _370++;
    if (_370 < _368)
    goto _jump187;
    // End body of loop
    int64_t _373 = 806;
    int64_t _374 = -_373;
    int64_t _375 = -_374;
    if (_375 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_375 < _367.d0)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    int64_t _376 = 0;
    _376 *= _367.d0;
    _376 += _375;
    bool _377 = _367.data[_376];
    bool _366 = _377;
    if (0 != _377)
    goto _jump190;
    bool _378 = false;
    _366 = _378;
    _jump190:;
    int64_t _379;
    if (!_366)
    goto _jump191;
    int64_t _380 = 272;
    _379 = _380;
    goto _jump192;
    _jump191:;
    bool _381 = false;
    int64_t _382;
    if (!_381)
    goto _jump193;
    int64_t _383 = 901;
    _a1_int64_t _384;
    _384.d0 = 1;
    _384.data = jpl_alloc(sizeof(int64_t) * 1);
    _384.data[0] = _383;
    int64_t _385;
    // Computing bound for c
    int64_t _386 = 785;
    int64_t _387 = -_386;
    if (_387 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for d
    int64_t _388;
    // Computing bound for c
    int64_t _389 = 660;
    if (_389 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    // Computing bound for d
    int64_t _390 = 295;
    if (_390 > 0) 
    goto _jump196;
    fail_assertion("non-positive loop bound");
    _jump196:;
    _388 = 0;
    int64_t _391 = 0; // d
    int64_t _392 = 0; // c
    _jump197:; // Begin body of loop
    _388 += _392;
    _391++;
    if (_391 < _390)
    goto _jump197;
    _391 = 0;
    _392++;
    if (_392 < _389)
    goto _jump197;
    // End body of loop
    if (_388 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing bound for e
    int64_t _393 = 395;
    if (_393 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    _385 = 0;
    int64_t _394 = 0; // e
    int64_t _395 = 0; // d
    int64_t _396 = 0; // c
    _jump200:; // Begin body of loop
    _385 += _395;
    _394++;
    if (_394 < _393)
    goto _jump200;
    _394 = 0;
    _395++;
    if (_395 < _388)
    goto _jump200;
    _395 = 0;
    _396++;
    if (_396 < _387)
    goto _jump200;
    // End body of loop
    if (_385 >= 0)
    goto _jump201;
    fail_assertion("negative array index");
    _jump201:;
    if (_385 < _384.d0)
    goto _jump202;
    fail_assertion("index too large");
    _jump202:;
    int64_t _397 = 0;
    _397 *= _384.d0;
    _397 += _385;
    int64_t _398 = _384.data[_397];
    _382 = _398;
    goto _jump203;
    _jump193:;
    int64_t _399 = 926;
    int64_t _400 = 211;
    int64_t _401 = 319;
    int64_t _402 = -_401;
    _a1_int64_t _403;
    _403.d0 = 3;
    _403.data = jpl_alloc(sizeof(int64_t) * 3);
    _403.data[0] = _399;
    _403.data[1] = _400;
    _403.data[2] = _402;
    int64_t _404 = 539;
    int64_t _405 = -_404;
    if (_405 >= 0)
    goto _jump204;
    fail_assertion("negative array index");
    _jump204:;
    if (_405 < _403.d0)
    goto _jump205;
    fail_assertion("index too large");
    _jump205:;
    int64_t _406 = 0;
    _406 *= _403.d0;
    _406 += _405;
    int64_t _407 = _403.data[_406];
    _382 = _407;
    _jump203:;
    _379 = _382;
    _jump192:;
    _365 = _379;
    goto _jump206;
    _jump185:;
    _a3__a2_int64_t _408;
    // Computing bound for c
    int64_t _409;
    // Computing bound for c
    int64_t _410 = 164;
    int64_t _411 = -_410;
    if (_411 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing bound for d
    int64_t _412 = 54;
    if (_412 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing bound for e
    int64_t _413 = 301;
    if (_413 > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    _409 = 0;
    int64_t _414 = 0; // e
    int64_t _415 = 0; // d
    int64_t _416 = 0; // c
    _jump210:; // Begin body of loop
    _409 += _414;
    _414++;
    if (_414 < _413)
    goto _jump210;
    _414 = 0;
    _415++;
    if (_415 < _412)
    goto _jump210;
    _415 = 0;
    _416++;
    if (_416 < _411)
    goto _jump210;
    // End body of loop
    _408.d0 = _409;
    if (_409 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for d
    int64_t _417 = 18;
    int64_t _418 = 374;
    int64_t _419 = _417 / _418;
    int64_t _420 = -_419;
    _408.d1 = _420;
    if (_420 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for e
    int64_t _421 = 85;
    int64_t _422 = 887;
    int64_t _423 = -_422;
    int64_t _424 = _421 * _423;
    _408.d2 = _424;
    if (_424 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing total size of heap memory to allocate
    int64_t _425 = 1;
    _425 *= _409;
    _425 *= _420;
    _425 *= _424;
    _425 *= sizeof(_a2_int64_t);
    _408.data = jpl_alloc(_425);
    int64_t _426 = 0; // e
    int64_t _427 = 0; // d
    int64_t _428 = 0; // c
    _jump214:; // Begin body of loop
    _a2_int64_t _429;
    // Computing bound for f
    _429.d0 = _427;
    if (_427 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing bound for g
    int64_t _430 = -_427;
    _429.d1 = _430;
    if (_430 > 0) 
    goto _jump216;
    fail_assertion("non-positive loop bound");
    _jump216:;
    // Computing total size of heap memory to allocate
    int64_t _431 = 1;
    _431 *= _427;
    _431 *= _430;
    _431 *= sizeof(int64_t);
    _429.data = jpl_alloc(_431);
    int64_t _432 = 0; // g
    int64_t _433 = 0; // f
    _jump217:; // Begin body of loop
    int64_t _434 = 0;
    _434 *= _429.d0;
    _434 += _433;
    _434 *= _429.d1;
    _434 += _432;
    _429.data[_434] = _427;
    _432++;
    if (_432 < _430)
    goto _jump217;
    _432 = 0;
    _433++;
    if (_433 < _427)
    goto _jump217;
    // End body of loop
    int64_t _435 = 0;
    _435 *= _408.d0;
    _435 += _428;
    _435 *= _408.d1;
    _435 += _427;
    _435 *= _408.d2;
    _435 += _426;
    _408.data[_435] = _429;
    _426++;
    if (_426 < _424)
    goto _jump214;
    _426 = 0;
    _427++;
    if (_427 < _420)
    goto _jump214;
    _427 = 0;
    _428++;
    if (_428 < _409)
    goto _jump214;
    // End body of loop
    int64_t _436;
    // Computing bound for c
    int64_t _437 = 311;
    if (_437 > 0) 
    goto _jump218;
    fail_assertion("non-positive loop bound");
    _jump218:;
    _436 = 0;
    int64_t _438 = 0; // c
    _jump219:; // Begin body of loop
    int64_t _439 = _438 * _438;
    int64_t _440 = _439 + _438;
    _436 += _440;
    _438++;
    if (_438 < _437)
    goto _jump219;
    // End body of loop
    int64_t _441 = 905;
    int64_t _442 = 232;
    int64_t _443 = -_442;
    int64_t _444 = -_443;
    int64_t _445 = -_444;
    if (_436 >= 0)
    goto _jump220;
    fail_assertion("negative array index");
    _jump220:;
    if (_436 < _408.d0)
    goto _jump221;
    fail_assertion("index too large");
    _jump221:;
    if (_441 >= 0)
    goto _jump222;
    fail_assertion("negative array index");
    _jump222:;
    if (_441 < _408.d1)
    goto _jump223;
    fail_assertion("index too large");
    _jump223:;
    if (_445 >= 0)
    goto _jump224;
    fail_assertion("negative array index");
    _jump224:;
    if (_445 < _408.d2)
    goto _jump225;
    fail_assertion("index too large");
    _jump225:;
    int64_t _446 = 0;
    _446 *= _408.d0;
    _446 += _436;
    _446 *= _408.d1;
    _446 += _441;
    _446 *= _408.d2;
    _446 += _445;
    _a2_int64_t _447 = _408.data[_446];
    int64_t _448 = 403;
    int64_t _449 = 855;
    if (_448 >= 0)
    goto _jump226;
    fail_assertion("negative array index");
    _jump226:;
    if (_448 < _447.d0)
    goto _jump227;
    fail_assertion("index too large");
    _jump227:;
    if (_449 >= 0)
    goto _jump228;
    fail_assertion("negative array index");
    _jump228:;
    if (_449 < _447.d1)
    goto _jump229;
    fail_assertion("index too large");
    _jump229:;
    int64_t _450 = 0;
    _450 *= _447.d0;
    _450 += _448;
    _450 *= _447.d1;
    _450 += _449;
    int64_t _451 = _447.data[_450];
    _365 = _451;
    _jump206:;
    if (_207 >= 0)
    goto _jump230;
    fail_assertion("negative array index");
    _jump230:;
    if (_207 < _187.d0)
    goto _jump231;
    fail_assertion("index too large");
    _jump231:;
    if (_244 >= 0)
    goto _jump232;
    fail_assertion("negative array index");
    _jump232:;
    if (_244 < _187.d1)
    goto _jump233;
    fail_assertion("index too large");
    _jump233:;
    if (_365 >= 0)
    goto _jump234;
    fail_assertion("negative array index");
    _jump234:;
    if (_365 < _187.d2)
    goto _jump235;
    fail_assertion("index too large");
    _jump235:;
    int64_t _452 = 0;
    _452 *= _187.d0;
    _452 += _207;
    _452 *= _187.d1;
    _452 += _244;
    _452 *= _187.d2;
    _452 += _365;
    _a1_int64_t _453 = _187.data[_452];
    _a3_bool _454;
    // Computing bound for e
    _a2_int64_t _455;
    // Computing bound for e
    _455.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing bound for f
    _455.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing total size of heap memory to allocate
    int64_t _456 = 1;
    _456 *= _453.d0;
    _456 *= _453.d0;
    _456 *= sizeof(int64_t);
    _455.data = jpl_alloc(_456);
    int64_t _457 = 0; // f
    int64_t _458 = 0; // e
    _jump238:; // Begin body of loop
    int64_t _459 = 0;
    _459 *= _455.d0;
    _459 += _458;
    _459 *= _455.d1;
    _459 += _457;
    _455.data[_459] = _457;
    _457++;
    if (_457 < _453.d0)
    goto _jump238;
    _457 = 0;
    _458++;
    if (_458 < _453.d0)
    goto _jump238;
    // End body of loop
    int64_t _460 = 500;
    int64_t _461 = _460 % _453.d0;
    if (_453.d0 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (_453.d0 < _455.d0)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    if (_461 >= 0)
    goto _jump241;
    fail_assertion("negative array index");
    _jump241:;
    if (_461 < _455.d1)
    goto _jump242;
    fail_assertion("index too large");
    _jump242:;
    int64_t _462 = 0;
    _462 *= _455.d0;
    _462 += _453.d0;
    _462 *= _455.d1;
    _462 += _461;
    int64_t _463 = _455.data[_462];
    int64_t _464 = 89;
    bool _465 = _463 == _464;
    int64_t _466;
    if (!_465)
    goto _jump243;
    _466 = _453.d0;
    goto _jump244;
    _jump243:;
    int64_t _467;
    // Computing bound for e
    int64_t _468;
    // Computing bound for e
    if (_453.d0 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing bound for f
    int64_t _469 = 714;
    int64_t _470 = -_469;
    if (_470 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    _468 = 0;
    int64_t _471 = 0; // f
    int64_t _472 = 0; // e
    _jump247:; // Begin body of loop
    if (_453.d0 >= 0)
    goto _jump248;
    fail_assertion("negative array index");
    _jump248:;
    if (_453.d0 < _453.d0)
    goto _jump249;
    fail_assertion("index too large");
    _jump249:;
    int64_t _473 = 0;
    _473 *= _453.d0;
    _473 += _453.d0;
    int64_t _474 = _453.data[_473];
    _468 += _474;
    _471++;
    if (_471 < _470)
    goto _jump247;
    _471 = 0;
    _472++;
    if (_472 < _453.d0)
    goto _jump247;
    // End body of loop
    if (_468 > 0) 
    goto _jump250;
    fail_assertion("non-positive loop bound");
    _jump250:;
    // Computing bound for f
    int64_t _475 = -_453.d0;
    bool _476 = false;
    int64_t _477;
    if (!_476)
    goto _jump251;
    _477 = _453.d0;
    goto _jump252;
    _jump251:;
    int64_t _478 = 185;
    _477 = _478;
    _jump252:;
    int64_t _479 = _475 / _477;
    if (_479 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    _467 = 0;
    int64_t _480 = 0; // f
    int64_t _481 = 0; // e
    _jump254:; // Begin body of loop
    _467 += _480;
    _480++;
    if (_480 < _479)
    goto _jump254;
    _480 = 0;
    _481++;
    if (_481 < _468)
    goto _jump254;
    // End body of loop
    _466 = _467;
    _jump244:;
    _454.d0 = _466;
    if (_466 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    // Computing bound for f
    int64_t _483 = 798;
    bool _484 = _453.d0 >= _483;
    bool _482 = _484;
    if (0 != _484)
    goto _jump256;
    bool _485 = true;
    _482 = _485;
    _jump256:;
    _a2_int64_t _486;
    if (!_482)
    goto _jump257;
    _a2_int64_t _487;
    // Computing bound for e
    _487.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    // Computing bound for f
    int64_t _488;
    // Computing bound for e
    int64_t _489 = 402;
    if (_489 > 0) 
    goto _jump259;
    fail_assertion("non-positive loop bound");
    _jump259:;
    // Computing bound for f
    if (_453.d0 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    _488 = 0;
    int64_t _490 = 0; // f
    int64_t _491 = 0; // e
    _jump261:; // Begin body of loop
    _488 += _453.d0;
    _490++;
    if (_490 < _453.d0)
    goto _jump261;
    _490 = 0;
    _491++;
    if (_491 < _489)
    goto _jump261;
    // End body of loop
    _487.d1 = _488;
    if (_488 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing total size of heap memory to allocate
    int64_t _492 = 1;
    _492 *= _453.d0;
    _492 *= _488;
    _492 *= sizeof(int64_t);
    _487.data = jpl_alloc(_492);
    int64_t _493 = 0; // f
    int64_t _494 = 0; // e
    _jump263:; // Begin body of loop
    int64_t _495 = 0;
    _495 *= _487.d0;
    _495 += _494;
    _495 *= _487.d1;
    _495 += _493;
    _487.data[_495] = _453.d0;
    _493++;
    if (_493 < _488)
    goto _jump263;
    _493 = 0;
    _494++;
    if (_494 < _453.d0)
    goto _jump263;
    // End body of loop
    _486 = _487;
    goto _jump264;
    _jump257:;
    _a2_int64_t _496;
    // Computing bound for e
    int64_t _497 = 984;
    _496.d0 = _497;
    if (_497 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing bound for f
    int64_t _498 = 524;
    _496.d1 = _498;
    if (_498 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing total size of heap memory to allocate
    int64_t _499 = 1;
    _499 *= _497;
    _499 *= _498;
    _499 *= sizeof(int64_t);
    _496.data = jpl_alloc(_499);
    int64_t _500 = 0; // f
    int64_t _501 = 0; // e
    _jump267:; // Begin body of loop
    int64_t _502 = 0;
    _502 *= _496.d0;
    _502 += _501;
    _502 *= _496.d1;
    _502 += _500;
    _496.data[_502] = _500;
    _500++;
    if (_500 < _498)
    goto _jump267;
    _500 = 0;
    _501++;
    if (_501 < _497)
    goto _jump267;
    // End body of loop
    _486 = _496;
    _jump264:;
    int64_t _503;
    // Computing bound for e
    int64_t _504 = 838;
    if (_504 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for f
    int64_t _505 = 348;
    if (_505 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    // Computing bound for g
    int64_t _506 = 491;
    if (_506 > 0) 
    goto _jump270;
    fail_assertion("non-positive loop bound");
    _jump270:;
    _503 = 0;
    int64_t _507 = 0; // g
    int64_t _508 = 0; // f
    int64_t _509 = 0; // e
    _jump271:; // Begin body of loop
    _503 += _507;
    _507++;
    if (_507 < _506)
    goto _jump271;
    _507 = 0;
    _508++;
    if (_508 < _505)
    goto _jump271;
    _508 = 0;
    _509++;
    if (_509 < _504)
    goto _jump271;
    // End body of loop
    int64_t _510;
    // Computing bound for e
    int64_t _511 = 881;
    int64_t _512 = -_511;
    int64_t _513 = 635;
    int64_t _514 = _512 % _513;
    if (_514 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    _510 = 0;
    int64_t _515 = 0; // e
    _jump273:; // Begin body of loop
    int64_t _516;
    // Computing bound for f
    int64_t _517 = 896;
    if (_517 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    _516 = 0;
    int64_t _518 = 0; // f
    _jump275:; // Begin body of loop
    _516 += _453.d0;
    _518++;
    if (_518 < _517)
    goto _jump275;
    // End body of loop
    _510 += _516;
    _515++;
    if (_515 < _514)
    goto _jump273;
    // End body of loop
    if (_503 >= 0)
    goto _jump276;
    fail_assertion("negative array index");
    _jump276:;
    if (_503 < _486.d0)
    goto _jump277;
    fail_assertion("index too large");
    _jump277:;
    if (_510 >= 0)
    goto _jump278;
    fail_assertion("negative array index");
    _jump278:;
    if (_510 < _486.d1)
    goto _jump279;
    fail_assertion("index too large");
    _jump279:;
    int64_t _519 = 0;
    _519 *= _486.d0;
    _519 += _503;
    _519 *= _486.d1;
    _519 += _510;
    int64_t _520 = _486.data[_519];
    _454.d1 = _520;
    if (_520 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    // Computing bound for g
    int64_t _521;
    // Computing bound for e
    bool _522 = false;
    int64_t _523;
    if (!_522)
    goto _jump281;
    _523 = _453.d0;
    goto _jump282;
    _jump281:;
    int64_t _524 = -_453.d0;
    _523 = _524;
    _jump282:;
    if (_523 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    // Computing bound for f
    _a3_int64_t _525;
    // Computing bound for e
    _525.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    // Computing bound for f
    _525.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump285;
    fail_assertion("non-positive loop bound");
    _jump285:;
    // Computing bound for g
    int64_t _526 = 331;
    _525.d2 = _526;
    if (_526 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing total size of heap memory to allocate
    int64_t _527 = 1;
    _527 *= _453.d0;
    _527 *= _453.d0;
    _527 *= _526;
    _527 *= sizeof(int64_t);
    _525.data = jpl_alloc(_527);
    int64_t _528 = 0; // g
    int64_t _529 = 0; // f
    int64_t _530 = 0; // e
    _jump287:; // Begin body of loop
    int64_t _531 = 611;
    int64_t _532 = 0;
    _532 *= _525.d0;
    _532 += _530;
    _532 *= _525.d1;
    _532 += _529;
    _532 *= _525.d2;
    _532 += _528;
    _525.data[_532] = _531;
    _528++;
    if (_528 < _526)
    goto _jump287;
    _528 = 0;
    _529++;
    if (_529 < _453.d0)
    goto _jump287;
    _529 = 0;
    _530++;
    if (_530 < _453.d0)
    goto _jump287;
    // End body of loop
    if (_453.d0 >= 0)
    goto _jump288;
    fail_assertion("negative array index");
    _jump288:;
    if (_453.d0 < _525.d0)
    goto _jump289;
    fail_assertion("index too large");
    _jump289:;
    if (_453.d0 >= 0)
    goto _jump290;
    fail_assertion("negative array index");
    _jump290:;
    if (_453.d0 < _525.d1)
    goto _jump291;
    fail_assertion("index too large");
    _jump291:;
    if (_453.d0 >= 0)
    goto _jump292;
    fail_assertion("negative array index");
    _jump292:;
    if (_453.d0 < _525.d2)
    goto _jump293;
    fail_assertion("index too large");
    _jump293:;
    int64_t _533 = 0;
    _533 *= _525.d0;
    _533 += _453.d0;
    _533 *= _525.d1;
    _533 += _453.d0;
    _533 *= _525.d2;
    _533 += _453.d0;
    int64_t _534 = _525.data[_533];
    if (_534 > 0) 
    goto _jump294;
    fail_assertion("non-positive loop bound");
    _jump294:;
    _521 = 0;
    int64_t _535 = 0; // f
    int64_t _536 = 0; // e
    _jump295:; // Begin body of loop
    _521 += _536;
    _535++;
    if (_535 < _534)
    goto _jump295;
    _535 = 0;
    _536++;
    if (_536 < _523)
    goto _jump295;
    // End body of loop
    int64_t _537 = _453.d0 / _521;
    _454.d2 = _537;
    if (_537 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing total size of heap memory to allocate
    int64_t _538 = 1;
    _538 *= _466;
    _538 *= _520;
    _538 *= _537;
    _538 *= sizeof(bool);
    _454.data = jpl_alloc(_538);
    int64_t _539 = 0; // g
    int64_t _540 = 0; // f
    int64_t _541 = 0; // e
    _jump297:; // Begin body of loop
    bool _542 = true;
    bool _543 = !_542;
    int64_t _544 = 0;
    _544 *= _454.d0;
    _544 += _541;
    _544 *= _454.d1;
    _544 += _540;
    _544 *= _454.d2;
    _544 += _539;
    _454.data[_544] = _543;
    _539++;
    if (_539 < _537)
    goto _jump297;
    _539 = 0;
    _540++;
    if (_540 < _520)
    goto _jump297;
    _540 = 0;
    _541++;
    if (_541 < _466)
    goto _jump297;
    // End body of loop
    _a3_bool _545;
    // Computing bound for e
    int64_t _546 = _453.d0 % _453.d0;
    _545.d0 = _546;
    if (_546 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing bound for f
    int64_t _547 = 794;
    int64_t _548 = -_547;
    _545.d1 = _548;
    if (_548 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for g
    int64_t _549 = 229;
    _545.d2 = _549;
    if (_549 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing total size of heap memory to allocate
    int64_t _550 = 1;
    _550 *= _546;
    _550 *= _548;
    _550 *= _549;
    _550 *= sizeof(bool);
    _545.data = jpl_alloc(_550);
    int64_t _551 = 0; // g
    int64_t _552 = 0; // f
    int64_t _553 = 0; // e
    _jump301:; // Begin body of loop
    bool _554 = _553 == _551;
    bool _555 = !_554;
    int64_t _556 = 0;
    _556 *= _545.d0;
    _556 += _553;
    _556 *= _545.d1;
    _556 += _552;
    _556 *= _545.d2;
    _556 += _551;
    _545.data[_556] = _555;
    _551++;
    if (_551 < _549)
    goto _jump301;
    _551 = 0;
    _552++;
    if (_552 < _548)
    goto _jump301;
    _552 = 0;
    _553++;
    if (_553 < _546)
    goto _jump301;
    // End body of loop
    int64_t _557 = 198;
    int64_t _558 = 465;
    bool _559 = true;
    bool _560;
    if (!_559)
    goto _jump302;
    int64_t _561 = 330;
    bool _562 = _453.d0 != _561;
    _560 = _562;
    goto _jump303;
    _jump302:;
    bool _563 = false;
    _560 = _563;
    _jump303:;
    int64_t _564;
    if (!_560)
    goto _jump304;
    int64_t _565;
    // Computing bound for e
    bool _566 = true;
    int64_t _567;
    if (!_566)
    goto _jump305;
    _567 = _453.d0;
    goto _jump306;
    _jump305:;
    _567 = _453.d0;
    _jump306:;
    if (_567 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    _565 = 0;
    int64_t _568 = 0; // e
    _jump308:; // Begin body of loop
    _565 += _568;
    _568++;
    if (_568 < _567)
    goto _jump308;
    // End body of loop
    _564 = _565;
    goto _jump309;
    _jump304:;
    int64_t _569;
    // Computing bound for e
    int64_t _570 = 805;
    if (_570 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    // Computing bound for f
    if (_453.d0 > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing bound for g
    if (_453.d0 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    _569 = 0;
    int64_t _571 = 0; // g
    int64_t _572 = 0; // f
    int64_t _573 = 0; // e
    _jump313:; // Begin body of loop
    _569 += _573;
    _571++;
    if (_571 < _453.d0)
    goto _jump313;
    _571 = 0;
    _572++;
    if (_572 < _453.d0)
    goto _jump313;
    _572 = 0;
    _573++;
    if (_573 < _570)
    goto _jump313;
    // End body of loop
    int64_t _574 = _569 % _453.d0;
    _564 = _574;
    _jump309:;
    if (_557 >= 0)
    goto _jump314;
    fail_assertion("negative array index");
    _jump314:;
    if (_557 < _545.d0)
    goto _jump315;
    fail_assertion("index too large");
    _jump315:;
    if (_558 >= 0)
    goto _jump316;
    fail_assertion("negative array index");
    _jump316:;
    if (_558 < _545.d1)
    goto _jump317;
    fail_assertion("index too large");
    _jump317:;
    if (_564 >= 0)
    goto _jump318;
    fail_assertion("negative array index");
    _jump318:;
    if (_564 < _545.d2)
    goto _jump319;
    fail_assertion("index too large");
    _jump319:;
    int64_t _575 = 0;
    _575 *= _545.d0;
    _575 += _557;
    _575 *= _545.d1;
    _575 += _558;
    _575 *= _545.d2;
    _575 += _564;
    bool _576 = _545.data[_575];
    int64_t _577;
    if (!_576)
    goto _jump320;
    bool _578 = false;
    int64_t _579 = 627;
    int64_t _580 = 718;
    bool _581 = _579 > _580;
    bool _582 = _578 != _581;
    int64_t _583;
    if (!_582)
    goto _jump321;
    bool _584 = false;
    int64_t _585;
    if (!_584)
    goto _jump322;
    _585 = _453.d0;
    goto _jump323;
    _jump322:;
    int64_t _586 = 131;
    _585 = _586;
    _jump323:;
    int64_t _587 = -_453.d0;
    int64_t _588 = _585 - _587;
    _583 = _588;
    goto _jump324;
    _jump321:;
    _583 = _453.d0;
    _jump324:;
    int64_t _589 = -_583;
    _577 = _589;
    goto _jump325;
    _jump320:;
    _577 = _453.d0;
    _jump325:;
    int64_t _590;
    // Computing bound for e
    bool _592 = false;
    bool _591 = _592;
    if (0 == _592)
    goto _jump326;
    bool _593 = true;
    _591 = _593;
    _jump326:;
    int64_t _594;
    if (!_591)
    goto _jump327;
    int64_t _595 = 388;
    int64_t _596 = _453.d0 + _595;
    _594 = _596;
    goto _jump328;
    _jump327:;
    _594 = _453.d0;
    _jump328:;
    if (_594 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    _590 = 0;
    int64_t _597 = 0; // e
    _jump330:; // Begin body of loop
    int64_t _598;
    // Computing bound for f
    int64_t _599;
    // Computing bound for f
    int64_t _600 = 246;
    if (_600 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing bound for g
    if (_597 > 0) 
    goto _jump332;
    fail_assertion("non-positive loop bound");
    _jump332:;
    _599 = 0;
    int64_t _601 = 0; // g
    int64_t _602 = 0; // f
    _jump333:; // Begin body of loop
    int64_t _603 = 480;
    int64_t _604 = 187;
    int64_t _605 = _603 * _604;
    _599 += _605;
    _601++;
    if (_601 < _597)
    goto _jump333;
    _601 = 0;
    _602++;
    if (_602 < _600)
    goto _jump333;
    // End body of loop
    if (_599 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    _598 = 0;
    int64_t _606 = 0; // f
    _jump335:; // Begin body of loop
    int64_t _607 = 228;
    _598 += _607;
    _606++;
    if (_606 < _599)
    goto _jump335;
    // End body of loop
    _590 += _598;
    _597++;
    if (_597 < _594)
    goto _jump330;
    // End body of loop
    int64_t _608 = 274;
    if (_577 >= 0)
    goto _jump336;
    fail_assertion("negative array index");
    _jump336:;
    if (_577 < _454.d0)
    goto _jump337;
    fail_assertion("index too large");
    _jump337:;
    if (_590 >= 0)
    goto _jump338;
    fail_assertion("negative array index");
    _jump338:;
    if (_590 < _454.d1)
    goto _jump339;
    fail_assertion("index too large");
    _jump339:;
    if (_608 >= 0)
    goto _jump340;
    fail_assertion("negative array index");
    _jump340:;
    if (_608 < _454.d2)
    goto _jump341;
    fail_assertion("index too large");
    _jump341:;
    int64_t _609 = 0;
    _609 *= _454.d0;
    _609 += _577;
    _609 *= _454.d1;
    _609 += _590;
    _609 *= _454.d2;
    _609 += _608;
    bool _610 = _454.data[_609];
    _a2_double _611;
    if (!_610)
    goto _jump342;
    _a2__a2_bool _612;
    // Computing bound for e
    int64_t _613 = _453.d0 / _453.d0;
    int64_t _614 = _613 / _453.d0;
    _612.d0 = _614;
    if (_614 > 0) 
    goto _jump343;
    fail_assertion("non-positive loop bound");
    _jump343:;
    // Computing bound for f
    int64_t _615;
    // Computing bound for e
    int64_t _616 = 267;
    if (_616 > 0) 
    goto _jump344;
    fail_assertion("non-positive loop bound");
    _jump344:;
    _615 = 0;
    int64_t _617 = 0; // e
    _jump345:; // Begin body of loop
    _615 += _453.d0;
    _617++;
    if (_617 < _616)
    goto _jump345;
    // End body of loop
    int64_t _618 = -_615;
    _612.d1 = _618;
    if (_618 > 0) 
    goto _jump346;
    fail_assertion("non-positive loop bound");
    _jump346:;
    // Computing total size of heap memory to allocate
    int64_t _619 = 1;
    _619 *= _614;
    _619 *= _618;
    _619 *= sizeof(_a2_bool);
    _612.data = jpl_alloc(_619);
    int64_t _620 = 0; // f
    int64_t _621 = 0; // e
    _jump347:; // Begin body of loop
    _a2_bool _622;
    // Computing bound for g
    _622.d0 = _621;
    if (_621 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing bound for h
    int64_t _623 = 280;
    int64_t _624 = -_623;
    _622.d1 = _624;
    if (_624 > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing total size of heap memory to allocate
    int64_t _625 = 1;
    _625 *= _621;
    _625 *= _624;
    _625 *= sizeof(bool);
    _622.data = jpl_alloc(_625);
    int64_t _626 = 0; // h
    int64_t _627 = 0; // g
    _jump350:; // Begin body of loop
    bool _628 = false;
    bool _629;
    if (!_628)
    goto _jump351;
    bool _630 = true;
    _629 = _630;
    goto _jump352;
    _jump351:;
    bool _631 = true;
    _629 = _631;
    _jump352:;
    int64_t _632 = 0;
    _632 *= _622.d0;
    _632 += _627;
    _632 *= _622.d1;
    _632 += _626;
    _622.data[_632] = _629;
    _626++;
    if (_626 < _624)
    goto _jump350;
    _626 = 0;
    _627++;
    if (_627 < _621)
    goto _jump350;
    // End body of loop
    int64_t _633 = 0;
    _633 *= _612.d0;
    _633 += _621;
    _633 *= _612.d1;
    _633 += _620;
    _612.data[_633] = _622;
    _620++;
    if (_620 < _618)
    goto _jump347;
    _620 = 0;
    _621++;
    if (_621 < _614)
    goto _jump347;
    // End body of loop
    int64_t _634;
    // Computing bound for e
    int64_t _635 = 733;
    int64_t _636 = -_635;
    if (_636 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    _634 = 0;
    int64_t _637 = 0; // e
    _jump354:; // Begin body of loop
    int64_t _638 = 121;
    _634 += _638;
    _637++;
    if (_637 < _636)
    goto _jump354;
    // End body of loop
    if (_634 >= 0)
    goto _jump355;
    fail_assertion("negative array index");
    _jump355:;
    if (_634 < _612.d0)
    goto _jump356;
    fail_assertion("index too large");
    _jump356:;
    if (_453.d0 >= 0)
    goto _jump357;
    fail_assertion("negative array index");
    _jump357:;
    if (_453.d0 < _612.d1)
    goto _jump358;
    fail_assertion("index too large");
    _jump358:;
    int64_t _639 = 0;
    _639 *= _612.d0;
    _639 += _634;
    _639 *= _612.d1;
    _639 += _453.d0;
    _a2_bool _640 = _612.data[_639];
    _a3_int64_t _641;
    // Computing bound for e
    if (_453.d0 >= 0)
    goto _jump359;
    fail_assertion("negative array index");
    _jump359:;
    if (_453.d0 < _453.d0)
    goto _jump360;
    fail_assertion("index too large");
    _jump360:;
    int64_t _642 = 0;
    _642 *= _453.d0;
    _642 += _453.d0;
    int64_t _643 = _453.data[_642];
    int64_t _644 = -_643;
    _641.d0 = _644;
    if (_644 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    // Computing bound for f
    int64_t _645;
    // Computing bound for e
    int64_t _646 = -_453.d0;
    if (_646 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing bound for f
    if (_453.d0 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    _645 = 0;
    int64_t _647 = 0; // f
    int64_t _648 = 0; // e
    _jump364:; // Begin body of loop
    int64_t _649 = 280;
    int64_t _650 = _647 % _649;
    _645 += _650;
    _647++;
    if (_647 < _453.d0)
    goto _jump364;
    _647 = 0;
    _648++;
    if (_648 < _646)
    goto _jump364;
    // End body of loop
    _641.d1 = _645;
    if (_645 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    // Computing bound for g
    _641.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing total size of heap memory to allocate
    int64_t _651 = 1;
    _651 *= _644;
    _651 *= _645;
    _651 *= _453.d0;
    _651 *= sizeof(int64_t);
    _641.data = jpl_alloc(_651);
    int64_t _652 = 0; // g
    int64_t _653 = 0; // f
    int64_t _654 = 0; // e
    _jump367:; // Begin body of loop
    int64_t _655 = 125;
    int64_t _656 = -_655;
    int64_t _657 = 0;
    _657 *= _641.d0;
    _657 += _654;
    _657 *= _641.d1;
    _657 += _653;
    _657 *= _641.d2;
    _657 += _652;
    _641.data[_657] = _656;
    _652++;
    if (_652 < _453.d0)
    goto _jump367;
    _652 = 0;
    _653++;
    if (_653 < _645)
    goto _jump367;
    _653 = 0;
    _654++;
    if (_654 < _644)
    goto _jump367;
    // End body of loop
    int64_t _658 = 21;
    int64_t _659 = 208;
    int64_t _660 = 386;
    bool _661 = _659 >= _660;
    int64_t _662;
    if (!_661)
    goto _jump368;
    int64_t _663;
    // Computing bound for e
    int64_t _664 = _453.d0 - _453.d0;
    if (_664 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    _663 = 0;
    int64_t _665 = 0; // e
    _jump370:; // Begin body of loop
    _663 += _665;
    _665++;
    if (_665 < _664)
    goto _jump370;
    // End body of loop
    _662 = _663;
    goto _jump371;
    _jump368:;
    bool _666 = false;
    int64_t _667;
    if (!_666)
    goto _jump372;
    int64_t _668 = 710;
    _667 = _668;
    goto _jump373;
    _jump372:;
    _667 = _453.d0;
    _jump373:;
    int64_t _669 = _667 / _453.d0;
    _662 = _669;
    _jump371:;
    if (_658 >= 0)
    goto _jump374;
    fail_assertion("negative array index");
    _jump374:;
    if (_658 < _641.d0)
    goto _jump375;
    fail_assertion("index too large");
    _jump375:;
    if (_453.d0 >= 0)
    goto _jump376;
    fail_assertion("negative array index");
    _jump376:;
    if (_453.d0 < _641.d1)
    goto _jump377;
    fail_assertion("index too large");
    _jump377:;
    if (_662 >= 0)
    goto _jump378;
    fail_assertion("negative array index");
    _jump378:;
    if (_662 < _641.d2)
    goto _jump379;
    fail_assertion("index too large");
    _jump379:;
    int64_t _670 = 0;
    _670 *= _641.d0;
    _670 += _658;
    _670 *= _641.d1;
    _670 += _453.d0;
    _670 *= _641.d2;
    _670 += _662;
    int64_t _671 = _641.data[_670];
    double _672 = 56.0;
    double _673;
    // Computing bound for e
    int64_t _674 = 274;
    if (_674 > 0) 
    goto _jump380;
    fail_assertion("non-positive loop bound");
    _jump380:;
    _673 = 0;
    int64_t _675 = 0; // e
    _jump381:; // Begin body of loop
    double _676 = 2.0;
    _673 += _676;
    _675++;
    if (_675 < _674)
    goto _jump381;
    // End body of loop
    bool _677 = _672 <= _673;
    _a3_int64_t _678;
    if (!_677)
    goto _jump382;
    _a3_int64_t _679;
    // Computing bound for e
    int64_t _680 = 885;
    _679.d0 = _680;
    if (_680 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing bound for f
    int64_t _681 = 615;
    _679.d1 = _681;
    if (_681 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    // Computing bound for g
    _679.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing total size of heap memory to allocate
    int64_t _682 = 1;
    _682 *= _680;
    _682 *= _681;
    _682 *= _453.d0;
    _682 *= sizeof(int64_t);
    _679.data = jpl_alloc(_682);
    int64_t _683 = 0; // g
    int64_t _684 = 0; // f
    int64_t _685 = 0; // e
    _jump386:; // Begin body of loop
    int64_t _686 = 0;
    _686 *= _679.d0;
    _686 += _685;
    _686 *= _679.d1;
    _686 += _684;
    _686 *= _679.d2;
    _686 += _683;
    _679.data[_686] = _683;
    _683++;
    if (_683 < _453.d0)
    goto _jump386;
    _683 = 0;
    _684++;
    if (_684 < _681)
    goto _jump386;
    _684 = 0;
    _685++;
    if (_685 < _680)
    goto _jump386;
    // End body of loop
    _678 = _679;
    goto _jump387;
    _jump382:;
    _a3_int64_t _687;
    // Computing bound for e
    int64_t _688 = 192;
    int64_t _689 = -_688;
    _687.d0 = _689;
    if (_689 > 0) 
    goto _jump388;
    fail_assertion("non-positive loop bound");
    _jump388:;
    // Computing bound for f
    int64_t _690 = 932;
    _687.d1 = _690;
    if (_690 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing bound for g
    int64_t _691;
    // Computing bound for e
    int64_t _692 = 164;
    if (_692 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for f
    if (_453.d0 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for g
    int64_t _693 = 868;
    if (_693 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    _691 = 0;
    int64_t _694 = 0; // g
    int64_t _695 = 0; // f
    int64_t _696 = 0; // e
    _jump393:; // Begin body of loop
    _691 += _694;
    _694++;
    if (_694 < _693)
    goto _jump393;
    _694 = 0;
    _695++;
    if (_695 < _453.d0)
    goto _jump393;
    _695 = 0;
    _696++;
    if (_696 < _692)
    goto _jump393;
    // End body of loop
    _687.d2 = _691;
    if (_691 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing total size of heap memory to allocate
    int64_t _697 = 1;
    _697 *= _689;
    _697 *= _690;
    _697 *= _691;
    _697 *= sizeof(int64_t);
    _687.data = jpl_alloc(_697);
    int64_t _698 = 0; // g
    int64_t _699 = 0; // f
    int64_t _700 = 0; // e
    _jump395:; // Begin body of loop
    int64_t _701;
    // Computing bound for h
    if (_453.d0 > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    _701 = 0;
    int64_t _702 = 0; // h
    _jump397:; // Begin body of loop
    _701 += _699;
    _702++;
    if (_702 < _453.d0)
    goto _jump397;
    // End body of loop
    int64_t _703 = 0;
    _703 *= _687.d0;
    _703 += _700;
    _703 *= _687.d1;
    _703 += _699;
    _703 *= _687.d2;
    _703 += _698;
    _687.data[_703] = _701;
    _698++;
    if (_698 < _691)
    goto _jump395;
    _698 = 0;
    _699++;
    if (_699 < _690)
    goto _jump395;
    _699 = 0;
    _700++;
    if (_700 < _689)
    goto _jump395;
    // End body of loop
    _678 = _687;
    _jump387:;
    _a1_int64_t _704;
    // Computing bound for e
    _704.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    // Computing total size of heap memory to allocate
    int64_t _705 = 1;
    _705 *= _453.d0;
    _705 *= sizeof(int64_t);
    _704.data = jpl_alloc(_705);
    int64_t _706 = 0; // e
    _jump399:; // Begin body of loop
    int64_t _707 = -_453.d0;
    int64_t _708 = 0;
    _708 *= _704.d0;
    _708 += _706;
    _704.data[_708] = _707;
    _706++;
    if (_706 < _453.d0)
    goto _jump399;
    // End body of loop
    int64_t _709;
    // Computing bound for e
    int64_t _710 = -_453.d0;
    if (_710 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for f
    int64_t _711 = 790;
    if (_711 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    _709 = 0;
    int64_t _712 = 0; // f
    int64_t _713 = 0; // e
    _jump402:; // Begin body of loop
    int64_t _714 = -_712;
    _709 += _714;
    _712++;
    if (_712 < _711)
    goto _jump402;
    _712 = 0;
    _713++;
    if (_713 < _710)
    goto _jump402;
    // End body of loop
    if (_709 >= 0)
    goto _jump403;
    fail_assertion("negative array index");
    _jump403:;
    if (_709 < _704.d0)
    goto _jump404;
    fail_assertion("index too large");
    _jump404:;
    int64_t _715 = 0;
    _715 *= _704.d0;
    _715 += _709;
    int64_t _716 = _704.data[_715];
    int64_t _717 = 564;
    bool _718 = true;
    bool _719 = !_718;
    bool _720 = !_719;
    int64_t _721;
    if (!_720)
    goto _jump405;
    int64_t _722 = 610;
    int64_t _723 = -_722;
    int64_t _724 = -_723;
    _721 = _724;
    goto _jump406;
    _jump405:;
    int64_t _725 = 915;
    _721 = _725;
    _jump406:;
    if (_716 >= 0)
    goto _jump407;
    fail_assertion("negative array index");
    _jump407:;
    if (_716 < _678.d0)
    goto _jump408;
    fail_assertion("index too large");
    _jump408:;
    if (_717 >= 0)
    goto _jump409;
    fail_assertion("negative array index");
    _jump409:;
    if (_717 < _678.d1)
    goto _jump410;
    fail_assertion("index too large");
    _jump410:;
    if (_721 >= 0)
    goto _jump411;
    fail_assertion("negative array index");
    _jump411:;
    if (_721 < _678.d2)
    goto _jump412;
    fail_assertion("index too large");
    _jump412:;
    int64_t _726 = 0;
    _726 *= _678.d0;
    _726 += _716;
    _726 *= _678.d1;
    _726 += _717;
    _726 *= _678.d2;
    _726 += _721;
    int64_t _727 = _678.data[_726];
    if (_671 >= 0)
    goto _jump413;
    fail_assertion("negative array index");
    _jump413:;
    if (_671 < _640.d0)
    goto _jump414;
    fail_assertion("index too large");
    _jump414:;
    if (_727 >= 0)
    goto _jump415;
    fail_assertion("negative array index");
    _jump415:;
    if (_727 < _640.d1)
    goto _jump416;
    fail_assertion("index too large");
    _jump416:;
    int64_t _728 = 0;
    _728 *= _640.d0;
    _728 += _671;
    _728 *= _640.d1;
    _728 += _727;
    bool _729 = _640.data[_728];
    _a2_double _730;
    if (!_729)
    goto _jump417;
    double _731 = b.b;
    double _732 = 30.0;
    double _733 = 37.0;
    double _734 = 40.0;
    double _735 = 88.0;
    rgba _736 = { _732, _733, _734, _735 };
    double _737 = a(_736);
    bool _738 = _731 == _737;
    bool _739;
    if (!_738)
    goto _jump418;
    int64_t _740 = 423;
    int64_t _741 = 883;
    int64_t _742 = _741 % _453.d0;
    int64_t _743 = -_742;
    bool _744 = _740 < _743;
    _739 = _744;
    goto _jump419;
    _jump418:;
    double _745;
    // Computing bound for e
    if (_453.d0 > 0) 
    goto _jump420;
    fail_assertion("non-positive loop bound");
    _jump420:;
    // Computing bound for f
    if (_453.d0 > 0) 
    goto _jump421;
    fail_assertion("non-positive loop bound");
    _jump421:;
    _745 = 0;
    int64_t _746 = 0; // f
    int64_t _747 = 0; // e
    _jump422:; // Begin body of loop
    double _748 = 82.0;
    _745 += _748;
    _746++;
    if (_746 < _453.d0)
    goto _jump422;
    _746 = 0;
    _747++;
    if (_747 < _453.d0)
    goto _jump422;
    // End body of loop
    double _749 = b.g;
    bool _750 = _745 < _749;
    bool _751;
    if (!_750)
    goto _jump423;
    bool _752 = true;
    bool _753;
    if (!_752)
    goto _jump424;
    bool _754 = true;
    _753 = _754;
    goto _jump425;
    _jump424:;
    bool _755 = false;
    _753 = _755;
    _jump425:;
    _751 = _753;
    goto _jump426;
    _jump423:;
    bool _757 = true;
    bool _758 = !_757;
    bool _756 = _758;
    if (0 == _758)
    goto _jump427;
    bool _759 = true;
    _756 = _759;
    _jump427:;
    _751 = _756;
    _jump426:;
    _739 = _751;
    _jump419:;
    _a2_double _760;
    if (!_739)
    goto _jump428;
    bool _761 = false;
    int64_t _762;
    if (!_761)
    goto _jump429;
    int64_t _763 = _453.d0 % _453.d0;
    _762 = _763;
    goto _jump430;
    _jump429:;
    _762 = _453.d0;
    _jump430:;
    int64_t _764 = 8;
    int64_t _765 = -_764;
    bool _766 = _762 < _765;
    _a2_double _767;
    if (!_766)
    goto _jump431;
    _a2_double _768;
    // Computing bound for e
    bool _769 = true;
    int64_t _770;
    if (!_769)
    goto _jump432;
    int64_t _771 = 132;
    int64_t _772 = -_771;
    _770 = _772;
    goto _jump433;
    _jump432:;
    int64_t _773 = 66;
    _770 = _773;
    _jump433:;
    _768.d0 = _770;
    if (_770 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing bound for f
    int64_t _774 = 143;
    bool _775 = _774 == _453.d0;
    int64_t _776;
    if (!_775)
    goto _jump435;
    int64_t _777 = -_453.d0;
    _776 = _777;
    goto _jump436;
    _jump435:;
    int64_t _778 = 513;
    _776 = _778;
    _jump436:;
    _768.d1 = _776;
    if (_776 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _779 = 1;
    _779 *= _770;
    _779 *= _776;
    _779 *= sizeof(double);
    _768.data = jpl_alloc(_779);
    int64_t _780 = 0; // f
    int64_t _781 = 0; // e
    _jump438:; // Begin body of loop
    double _782 = 73.0;
    int64_t _783 = 0;
    _783 *= _768.d0;
    _783 += _781;
    _783 *= _768.d1;
    _783 += _780;
    _768.data[_783] = _782;
    _780++;
    if (_780 < _776)
    goto _jump438;
    _780 = 0;
    _781++;
    if (_781 < _770)
    goto _jump438;
    // End body of loop
    _767 = _768;
    goto _jump439;
    _jump431:;
    int64_t _784 = 599;
    int64_t _785 = 854;
    bool _786 = _784 >= _785;
    _a2_double _787;
    if (!_786)
    goto _jump440;
    _a2_double _788;
    // Computing bound for e
    _788.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump441;
    fail_assertion("non-positive loop bound");
    _jump441:;
    // Computing bound for f
    int64_t _789 = 651;
    int64_t _790 = 12;
    int64_t _791 = _789 + _790;
    _788.d1 = _791;
    if (_791 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    // Computing total size of heap memory to allocate
    int64_t _792 = 1;
    _792 *= _453.d0;
    _792 *= _791;
    _792 *= sizeof(double);
    _788.data = jpl_alloc(_792);
    int64_t _793 = 0; // f
    int64_t _794 = 0; // e
    _jump443:; // Begin body of loop
    double _795 = 12.0;
    int64_t _796 = 0;
    _796 *= _788.d0;
    _796 += _794;
    _796 *= _788.d1;
    _796 += _793;
    _788.data[_796] = _795;
    _793++;
    if (_793 < _791)
    goto _jump443;
    _793 = 0;
    _794++;
    if (_794 < _453.d0)
    goto _jump443;
    // End body of loop
    _787 = _788;
    goto _jump444;
    _jump440:;
    _a2_double _797;
    // Computing bound for e
    int64_t _798 = 336;
    int64_t _799 = -_798;
    _797.d0 = _799;
    if (_799 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    // Computing bound for f
    bool _800 = false;
    int64_t _801;
    if (!_800)
    goto _jump446;
    _801 = _453.d0;
    goto _jump447;
    _jump446:;
    int64_t _802 = 611;
    _801 = _802;
    _jump447:;
    _797.d1 = _801;
    if (_801 > 0) 
    goto _jump448;
    fail_assertion("non-positive loop bound");
    _jump448:;
    // Computing total size of heap memory to allocate
    int64_t _803 = 1;
    _803 *= _799;
    _803 *= _801;
    _803 *= sizeof(double);
    _797.data = jpl_alloc(_803);
    int64_t _804 = 0; // f
    int64_t _805 = 0; // e
    _jump449:; // Begin body of loop
    double _806 = b.b;
    int64_t _807 = 0;
    _807 *= _797.d0;
    _807 += _805;
    _807 *= _797.d1;
    _807 += _804;
    _797.data[_807] = _806;
    _804++;
    if (_804 < _801)
    goto _jump449;
    _804 = 0;
    _805++;
    if (_805 < _799)
    goto _jump449;
    // End body of loop
    _787 = _797;
    _jump444:;
    _767 = _787;
    _jump439:;
    _760 = _767;
    goto _jump450;
    _jump428:;
    _a2_double _808;
    // Computing bound for e
    int64_t _809;
    // Computing bound for e
    int64_t _810 = 716;
    int64_t _811 = _453.d0 % _810;
    int64_t _812 = -_811;
    if (_812 > 0) 
    goto _jump451;
    fail_assertion("non-positive loop bound");
    _jump451:;
    // Computing bound for f
    bool _813 = false;
    bool _814 = !_813;
    int64_t _815;
    if (!_814)
    goto _jump452;
    int64_t _816 = 9;
    int64_t _817 = 240;
    int64_t _818 = _816 % _817;
    _815 = _818;
    goto _jump453;
    _jump452:;
    int64_t _819;
    // Computing bound for e
    if (_453.d0 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing bound for f
    int64_t _820 = 99;
    if (_820 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    _819 = 0;
    int64_t _821 = 0; // f
    int64_t _822 = 0; // e
    _jump456:; // Begin body of loop
    _819 += _822;
    _821++;
    if (_821 < _820)
    goto _jump456;
    _821 = 0;
    _822++;
    if (_822 < _453.d0)
    goto _jump456;
    // End body of loop
    _815 = _819;
    _jump453:;
    if (_815 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    _809 = 0;
    int64_t _823 = 0; // f
    int64_t _824 = 0; // e
    _jump458:; // Begin body of loop
    _809 += _823;
    _823++;
    if (_823 < _815)
    goto _jump458;
    _823 = 0;
    _824++;
    if (_824 < _812)
    goto _jump458;
    // End body of loop
    _808.d0 = _809;
    if (_809 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    // Computing bound for f
    _808.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing total size of heap memory to allocate
    int64_t _825 = 1;
    _825 *= _809;
    _825 *= _453.d0;
    _825 *= sizeof(double);
    _808.data = jpl_alloc(_825);
    int64_t _826 = 0; // f
    int64_t _827 = 0; // e
    _jump461:; // Begin body of loop
    double _828 = 82.0;
    int64_t _829 = 0;
    _829 *= _808.d0;
    _829 += _827;
    _829 *= _808.d1;
    _829 += _826;
    _808.data[_829] = _828;
    _826++;
    if (_826 < _453.d0)
    goto _jump461;
    _826 = 0;
    _827++;
    if (_827 < _809)
    goto _jump461;
    // End body of loop
    _760 = _808;
    _jump450:;
    _730 = _760;
    goto _jump462;
    _jump417:;
    _a2_double _830;
    // Computing bound for e
    _830.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing bound for f
    int64_t _831 = 585;
    _830.d1 = _831;
    if (_831 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing total size of heap memory to allocate
    int64_t _832 = 1;
    _832 *= _453.d0;
    _832 *= _831;
    _832 *= sizeof(double);
    _830.data = jpl_alloc(_832);
    int64_t _833 = 0; // f
    int64_t _834 = 0; // e
    _jump465:; // Begin body of loop
    double _835;
    // Computing bound for g
    if (_834 > 0) 
    goto _jump466;
    fail_assertion("non-positive loop bound");
    _jump466:;
    _835 = 0;
    int64_t _836 = 0; // g
    _jump467:; // Begin body of loop
    double _837 = 55.0;
    double _838 = b.a;
    double _839 = 19.0;
    double _840 = fmod(_838, _839);
    double _841 = _837 * _840;
    _835 += _841;
    _836++;
    if (_836 < _834)
    goto _jump467;
    // End body of loop
    int64_t _842 = 0;
    _842 *= _830.d0;
    _842 += _834;
    _842 *= _830.d1;
    _842 += _833;
    _830.data[_842] = _835;
    _833++;
    if (_833 < _831)
    goto _jump465;
    _833 = 0;
    _834++;
    if (_834 < _453.d0)
    goto _jump465;
    // End body of loop
    _730 = _830;
    _jump462:;
    _611 = _730;
    goto _jump468;
    _jump342:;
    _a2_double _843;
    // Computing bound for e
    _a3_int64_t _844;
    // Computing bound for e
    _844.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    // Computing bound for f
    int64_t _845 = 716;
    _844.d1 = _845;
    if (_845 > 0) 
    goto _jump470;
    fail_assertion("non-positive loop bound");
    _jump470:;
    // Computing bound for g
    _844.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing total size of heap memory to allocate
    int64_t _846 = 1;
    _846 *= _453.d0;
    _846 *= _845;
    _846 *= _453.d0;
    _846 *= sizeof(int64_t);
    _844.data = jpl_alloc(_846);
    int64_t _847 = 0; // g
    int64_t _848 = 0; // f
    int64_t _849 = 0; // e
    _jump472:; // Begin body of loop
    int64_t _850 = 0;
    _850 *= _844.d0;
    _850 += _849;
    _850 *= _844.d1;
    _850 += _848;
    _850 *= _844.d2;
    _850 += _847;
    _844.data[_850] = _847;
    _847++;
    if (_847 < _453.d0)
    goto _jump472;
    _847 = 0;
    _848++;
    if (_848 < _845)
    goto _jump472;
    _848 = 0;
    _849++;
    if (_849 < _453.d0)
    goto _jump472;
    // End body of loop
    _a1__a3_int64_t _851;
    _851.d0 = 1;
    _851.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _851.data[0] = _844;
    int64_t _852;
    // Computing bound for e
    int64_t _853 = _453.d0 + _453.d0;
    int64_t _854 = -_853;
    if (_854 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for f
    bool _855 = false;
    bool _856;
    if (!_855)
    goto _jump474;
    bool _857 = true;
    _856 = _857;
    goto _jump475;
    _jump474:;
    bool _858 = false;
    _856 = _858;
    _jump475:;
    int64_t _859;
    if (!_856)
    goto _jump476;
    int64_t _860 = -_453.d0;
    _859 = _860;
    goto _jump477;
    _jump476:;
    _859 = _453.d0;
    _jump477:;
    if (_859 > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    // Computing bound for g
    int64_t _861;
    // Computing bound for e
    int64_t _862 = 192;
    if (_862 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing bound for f
    if (_453.d0 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for g
    if (_453.d0 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    _861 = 0;
    int64_t _863 = 0; // g
    int64_t _864 = 0; // f
    int64_t _865 = 0; // e
    _jump482:; // Begin body of loop
    _861 += _453.d0;
    _863++;
    if (_863 < _453.d0)
    goto _jump482;
    _863 = 0;
    _864++;
    if (_864 < _453.d0)
    goto _jump482;
    _864 = 0;
    _865++;
    if (_865 < _862)
    goto _jump482;
    // End body of loop
    if (_861 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    _852 = 0;
    int64_t _866 = 0; // g
    int64_t _867 = 0; // f
    int64_t _868 = 0; // e
    _jump484:; // Begin body of loop
    int64_t _869 = 832;
    int64_t _870 = -_869;
    int64_t _871 = -_870;
    _852 += _871;
    _866++;
    if (_866 < _861)
    goto _jump484;
    _866 = 0;
    _867++;
    if (_867 < _859)
    goto _jump484;
    _867 = 0;
    _868++;
    if (_868 < _854)
    goto _jump484;
    // End body of loop
    if (_852 >= 0)
    goto _jump485;
    fail_assertion("negative array index");
    _jump485:;
    if (_852 < _851.d0)
    goto _jump486;
    fail_assertion("index too large");
    _jump486:;
    int64_t _872 = 0;
    _872 *= _851.d0;
    _872 += _852;
    _a3_int64_t _873 = _851.data[_872];
    int64_t _874 = 895;
    int64_t _875 = -_874;
    int64_t _876 = 956;
    if (_453.d0 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_453.d0 < _873.d0)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (_875 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_875 < _873.d1)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    if (_876 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_876 < _873.d2)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    int64_t _877 = 0;
    _877 *= _873.d0;
    _877 += _453.d0;
    _877 *= _873.d1;
    _877 += _875;
    _877 *= _873.d2;
    _877 += _876;
    int64_t _878 = _873.data[_877];
    _843.d0 = _878;
    if (_878 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for f
    int64_t _879 = 635;
    _843.d1 = _879;
    if (_879 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing total size of heap memory to allocate
    int64_t _880 = 1;
    _880 *= _878;
    _880 *= _879;
    _880 *= sizeof(double);
    _843.data = jpl_alloc(_880);
    int64_t _881 = 0; // f
    int64_t _882 = 0; // e
    _jump495:; // Begin body of loop
    _a1__a2_double _883;
    // Computing bound for g
    _883.d0 = _881;
    if (_881 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing total size of heap memory to allocate
    int64_t _884 = 1;
    _884 *= _881;
    _884 *= sizeof(_a2_double);
    _883.data = jpl_alloc(_884);
    int64_t _885 = 0; // g
    _jump497:; // Begin body of loop
    _a2_double _886;
    // Computing bound for h
    _886.d0 = _881;
    if (_881 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing bound for i
    int64_t _887 = 819;
    _886.d1 = _887;
    if (_887 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing total size of heap memory to allocate
    int64_t _888 = 1;
    _888 *= _881;
    _888 *= _887;
    _888 *= sizeof(double);
    _886.data = jpl_alloc(_888);
    int64_t _889 = 0; // i
    int64_t _890 = 0; // h
    _jump500:; // Begin body of loop
    double _891 = a(b);
    int64_t _892 = 0;
    _892 *= _886.d0;
    _892 += _890;
    _892 *= _886.d1;
    _892 += _889;
    _886.data[_892] = _891;
    _889++;
    if (_889 < _887)
    goto _jump500;
    _889 = 0;
    _890++;
    if (_890 < _881)
    goto _jump500;
    // End body of loop
    int64_t _893 = 0;
    _893 *= _883.d0;
    _893 += _885;
    _883.data[_893] = _886;
    _885++;
    if (_885 < _881)
    goto _jump497;
    // End body of loop
    bool _895 = _453.d0 < _453.d0;
    bool _894 = _895;
    if (0 == _895)
    goto _jump501;
    bool _896 = true;
    _894 = _896;
    _jump501:;
    int64_t _897;
    if (!_894)
    goto _jump502;
    _897 = _881;
    goto _jump503;
    _jump502:;
    int64_t _898 = -_881;
    _897 = _898;
    _jump503:;
    if (_897 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (_897 < _883.d0)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    int64_t _899 = 0;
    _899 *= _883.d0;
    _899 += _897;
    _a2_double _900 = _883.data[_899];
    _a2_int64_t _901;
    // Computing bound for g
    int64_t _902 = _453.d0 * _882;
    _901.d0 = _902;
    if (_902 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for h
    int64_t _903 = _881 + _882;
    _901.d1 = _903;
    if (_903 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing total size of heap memory to allocate
    int64_t _904 = 1;
    _904 *= _902;
    _904 *= _903;
    _904 *= sizeof(int64_t);
    _901.data = jpl_alloc(_904);
    int64_t _905 = 0; // h
    int64_t _906 = 0; // g
    _jump508:; // Begin body of loop
    int64_t _907 = 0;
    _907 *= _901.d0;
    _907 += _906;
    _907 *= _901.d1;
    _907 += _905;
    _901.data[_907] = _453.d0;
    _905++;
    if (_905 < _903)
    goto _jump508;
    _905 = 0;
    _906++;
    if (_906 < _902)
    goto _jump508;
    // End body of loop
    if (_882 >= 0)
    goto _jump509;
    fail_assertion("negative array index");
    _jump509:;
    if (_882 < _901.d0)
    goto _jump510;
    fail_assertion("index too large");
    _jump510:;
    if (_881 >= 0)
    goto _jump511;
    fail_assertion("negative array index");
    _jump511:;
    if (_881 < _901.d1)
    goto _jump512;
    fail_assertion("index too large");
    _jump512:;
    int64_t _908 = 0;
    _908 *= _901.d0;
    _908 += _882;
    _908 *= _901.d1;
    _908 += _881;
    int64_t _909 = _901.data[_908];
    _a2_bool _910;
    // Computing bound for g
    _910.d0 = _882;
    if (_882 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing bound for h
    _910.d1 = _881;
    if (_881 > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing total size of heap memory to allocate
    int64_t _911 = 1;
    _911 *= _882;
    _911 *= _881;
    _911 *= sizeof(bool);
    _910.data = jpl_alloc(_911);
    int64_t _912 = 0; // h
    int64_t _913 = 0; // g
    _jump515:; // Begin body of loop
    bool _914 = false;
    int64_t _915 = 0;
    _915 *= _910.d0;
    _915 += _913;
    _915 *= _910.d1;
    _915 += _912;
    _910.data[_915] = _914;
    _912++;
    if (_912 < _881)
    goto _jump515;
    _912 = 0;
    _913++;
    if (_913 < _882)
    goto _jump515;
    // End body of loop
    _a3_int64_t _916;
    // Computing bound for g
    _916.d0 = _881;
    if (_881 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for h
    _916.d1 = _882;
    if (_882 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for i
    _916.d2 = _881;
    if (_881 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    // Computing total size of heap memory to allocate
    int64_t _917 = 1;
    _917 *= _881;
    _917 *= _882;
    _917 *= _881;
    _917 *= sizeof(int64_t);
    _916.data = jpl_alloc(_917);
    int64_t _918 = 0; // i
    int64_t _919 = 0; // h
    int64_t _920 = 0; // g
    _jump519:; // Begin body of loop
    int64_t _921 = 0;
    _921 *= _916.d0;
    _921 += _920;
    _921 *= _916.d1;
    _921 += _919;
    _921 *= _916.d2;
    _921 += _918;
    _916.data[_921] = _918;
    _918++;
    if (_918 < _881)
    goto _jump519;
    _918 = 0;
    _919++;
    if (_919 < _882)
    goto _jump519;
    _919 = 0;
    _920++;
    if (_920 < _881)
    goto _jump519;
    // End body of loop
    int64_t _922 = 218;
    if (_922 >= 0)
    goto _jump520;
    fail_assertion("negative array index");
    _jump520:;
    if (_922 < _916.d0)
    goto _jump521;
    fail_assertion("index too large");
    _jump521:;
    if (_453.d0 >= 0)
    goto _jump522;
    fail_assertion("negative array index");
    _jump522:;
    if (_453.d0 < _916.d1)
    goto _jump523;
    fail_assertion("index too large");
    _jump523:;
    if (_881 >= 0)
    goto _jump524;
    fail_assertion("negative array index");
    _jump524:;
    if (_881 < _916.d2)
    goto _jump525;
    fail_assertion("index too large");
    _jump525:;
    int64_t _923 = 0;
    _923 *= _916.d0;
    _923 += _922;
    _923 *= _916.d1;
    _923 += _453.d0;
    _923 *= _916.d2;
    _923 += _881;
    int64_t _924 = _916.data[_923];
    if (_882 >= 0)
    goto _jump526;
    fail_assertion("negative array index");
    _jump526:;
    if (_882 < _910.d0)
    goto _jump527;
    fail_assertion("index too large");
    _jump527:;
    if (_924 >= 0)
    goto _jump528;
    fail_assertion("negative array index");
    _jump528:;
    if (_924 < _910.d1)
    goto _jump529;
    fail_assertion("index too large");
    _jump529:;
    int64_t _925 = 0;
    _925 *= _910.d0;
    _925 += _882;
    _925 *= _910.d1;
    _925 += _924;
    bool _926 = _910.data[_925];
    int64_t _927;
    if (!_926)
    goto _jump530;
    int64_t _928 = 220;
    int64_t _929 = _453.d0 % _928;
    int64_t _930 = 300;
    int64_t _931 = _930 - _882;
    bool _932 = _929 <= _931;
    int64_t _933;
    if (!_932)
    goto _jump531;
    bool _934 = true;
    int64_t _935;
    if (!_934)
    goto _jump532;
    int64_t _936;
    // Computing bound for g
    if (_453.d0 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for h
    if (_453.d0 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing bound for i
    int64_t _937 = 307;
    if (_937 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    _936 = 0;
    int64_t _938 = 0; // i
    int64_t _939 = 0; // h
    int64_t _940 = 0; // g
    _jump536:; // Begin body of loop
    _936 += _882;
    _938++;
    if (_938 < _937)
    goto _jump536;
    _938 = 0;
    _939++;
    if (_939 < _453.d0)
    goto _jump536;
    _939 = 0;
    _940++;
    if (_940 < _453.d0)
    goto _jump536;
    // End body of loop
    _935 = _936;
    goto _jump537;
    _jump532:;
    int64_t _941 = 910;
    _935 = _941;
    _jump537:;
    _933 = _935;
    goto _jump538;
    _jump531:;
    int64_t _942 = _881 % _882;
    _933 = _942;
    _jump538:;
    _927 = _933;
    goto _jump539;
    _jump530:;
    bool _943 = _453.d0 > _881;
    int64_t _944;
    if (!_943)
    goto _jump540;
    _944 = _882;
    goto _jump541;
    _jump540:;
    _944 = _882;
    _jump541:;
    _927 = _944;
    _jump539:;
    if (_909 >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (_909 < _900.d0)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    if (_927 >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (_927 < _900.d1)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    int64_t _945 = 0;
    _945 *= _900.d0;
    _945 += _909;
    _945 *= _900.d1;
    _945 += _927;
    double _946 = _900.data[_945];
    int64_t _947 = 0;
    _947 *= _843.d0;
    _947 += _882;
    _947 *= _843.d1;
    _947 += _881;
    _843.data[_947] = _946;
    _881++;
    if (_881 < _879)
    goto _jump495;
    _881 = 0;
    _882++;
    if (_882 < _878)
    goto _jump495;
    // End body of loop
    _611 = _843;
    _jump468:;
    _a3__a2__a3_bool _948;
    // Computing bound for h
    bool _950 = false;
    bool _949 = _950;
    if (0 == _950)
    goto _jump546;
    bool _951 = true;
    _949 = _951;
    _jump546:;
    int64_t _952;
    if (!_949)
    goto _jump547;
    _952 = _453.d0;
    goto _jump548;
    _jump547:;
    int64_t _953 = -_611.d0;
    int64_t _954 = _453.d0 * _953;
    _952 = _954;
    _jump548:;
    _948.d0 = _952;
    if (_952 > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    // Computing bound for i
    int64_t _955 = -_453.d0;
    int64_t _956 = -_955;
    _948.d1 = _956;
    if (_956 > 0) 
    goto _jump550;
    fail_assertion("non-positive loop bound");
    _jump550:;
    // Computing bound for j
    _948.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing total size of heap memory to allocate
    int64_t _957 = 1;
    _957 *= _952;
    _957 *= _956;
    _957 *= _453.d0;
    _957 *= sizeof(_a2__a3_bool);
    _948.data = jpl_alloc(_957);
    int64_t _958 = 0; // j
    int64_t _959 = 0; // i
    int64_t _960 = 0; // h
    _jump552:; // Begin body of loop
    _a2__a3_bool _961;
    // Computing bound for k
    int64_t _962;
    // Computing bound for k
    if (_958 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    _962 = 0;
    int64_t _963 = 0; // k
    _jump554:; // Begin body of loop
    _962 += _611.d1;
    _963++;
    if (_963 < _958)
    goto _jump554;
    // End body of loop
    _961.d0 = _962;
    if (_962 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing bound for l
    _961.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing total size of heap memory to allocate
    int64_t _964 = 1;
    _964 *= _962;
    _964 *= _453.d0;
    _964 *= sizeof(_a3_bool);
    _961.data = jpl_alloc(_964);
    int64_t _965 = 0; // l
    int64_t _966 = 0; // k
    _jump557:; // Begin body of loop
    _a3_bool _967;
    // Computing bound for m
    _967.d0 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing bound for n
    _967.d1 = _965;
    if (_965 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    // Computing bound for o
    _967.d2 = _611.d1;
    if (_611.d1 > 0) 
    goto _jump560;
    fail_assertion("non-positive loop bound");
    _jump560:;
    // Computing total size of heap memory to allocate
    int64_t _968 = 1;
    _968 *= _611.d0;
    _968 *= _965;
    _968 *= _611.d1;
    _968 *= sizeof(bool);
    _967.data = jpl_alloc(_968);
    int64_t _969 = 0; // o
    int64_t _970 = 0; // n
    int64_t _971 = 0; // m
    _jump561:; // Begin body of loop
    bool _972 = false;
    int64_t _973 = 0;
    _973 *= _967.d0;
    _973 += _971;
    _973 *= _967.d1;
    _973 += _970;
    _973 *= _967.d2;
    _973 += _969;
    _967.data[_973] = _972;
    _969++;
    if (_969 < _611.d1)
    goto _jump561;
    _969 = 0;
    _970++;
    if (_970 < _965)
    goto _jump561;
    _970 = 0;
    _971++;
    if (_971 < _611.d0)
    goto _jump561;
    // End body of loop
    int64_t _974 = 0;
    _974 *= _961.d0;
    _974 += _966;
    _974 *= _961.d1;
    _974 += _965;
    _961.data[_974] = _967;
    _965++;
    if (_965 < _453.d0)
    goto _jump557;
    _965 = 0;
    _966++;
    if (_966 < _962)
    goto _jump557;
    // End body of loop
    int64_t _975 = 0;
    _975 *= _948.d0;
    _975 += _960;
    _975 *= _948.d1;
    _975 += _959;
    _975 *= _948.d2;
    _975 += _958;
    _948.data[_975] = _961;
    _958++;
    if (_958 < _453.d0)
    goto _jump552;
    _958 = 0;
    _959++;
    if (_959 < _956)
    goto _jump552;
    _959 = 0;
    _960++;
    if (_960 < _952)
    goto _jump552;
    // End body of loop
    int64_t _976 = 858;
    int64_t _977 = 388;
    int64_t _978 = _453.d0 - _977;
    if (_976 >= 0)
    goto _jump562;
    fail_assertion("negative array index");
    _jump562:;
    if (_976 < _948.d0)
    goto _jump563;
    fail_assertion("index too large");
    _jump563:;
    if (_978 >= 0)
    goto _jump564;
    fail_assertion("negative array index");
    _jump564:;
    if (_978 < _948.d1)
    goto _jump565;
    fail_assertion("index too large");
    _jump565:;
    if (_611.d0 >= 0)
    goto _jump566;
    fail_assertion("negative array index");
    _jump566:;
    if (_611.d0 < _948.d2)
    goto _jump567;
    fail_assertion("index too large");
    _jump567:;
    int64_t _979 = 0;
    _979 *= _948.d0;
    _979 += _976;
    _979 *= _948.d1;
    _979 += _978;
    _979 *= _948.d2;
    _979 += _611.d0;
    _a2__a3_bool _980 = _948.data[_979];
    if (_453.d0 >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (_453.d0 < _980.d0)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    if (_611.d0 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (_611.d0 < _980.d1)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    int64_t _981 = 0;
    _981 *= _980.d0;
    _981 += _453.d0;
    _981 *= _980.d1;
    _981 += _611.d0;
    _a3_bool _982 = _980.data[_981];
    int64_t _983 = 341;
    int64_t _984;
    // Computing bound for h
    int64_t _985 = 535;
    if (_985 > 0) 
    goto _jump572;
    fail_assertion("non-positive loop bound");
    _jump572:;
    // Computing bound for i
    if (_611.d1 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    // Computing bound for j
    _a2_int64_t _986;
    // Computing bound for h
    int64_t _987 = 763;
    _986.d0 = _987;
    if (_987 > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing bound for i
    _986.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    // Computing total size of heap memory to allocate
    int64_t _988 = 1;
    _988 *= _987;
    _988 *= _453.d0;
    _988 *= sizeof(int64_t);
    _986.data = jpl_alloc(_988);
    int64_t _989 = 0; // i
    int64_t _990 = 0; // h
    _jump576:; // Begin body of loop
    int64_t _991 = 0;
    _991 *= _986.d0;
    _991 += _990;
    _991 *= _986.d1;
    _991 += _989;
    _986.data[_991] = _990;
    _989++;
    if (_989 < _453.d0)
    goto _jump576;
    _989 = 0;
    _990++;
    if (_990 < _987)
    goto _jump576;
    // End body of loop
    if (_453.d0 >= 0)
    goto _jump577;
    fail_assertion("negative array index");
    _jump577:;
    if (_453.d0 < _986.d0)
    goto _jump578;
    fail_assertion("index too large");
    _jump578:;
    if (_611.d0 >= 0)
    goto _jump579;
    fail_assertion("negative array index");
    _jump579:;
    if (_611.d0 < _986.d1)
    goto _jump580;
    fail_assertion("index too large");
    _jump580:;
    int64_t _992 = 0;
    _992 *= _986.d0;
    _992 += _453.d0;
    _992 *= _986.d1;
    _992 += _611.d0;
    int64_t _993 = _986.data[_992];
    if (_993 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    _984 = 0;
    int64_t _994 = 0; // j
    int64_t _995 = 0; // i
    int64_t _996 = 0; // h
    _jump582:; // Begin body of loop
    _a3_int64_t _997;
    // Computing bound for k
    int64_t _998 = -_611.d1;
    _997.d0 = _998;
    if (_998 > 0) 
    goto _jump583;
    fail_assertion("non-positive loop bound");
    _jump583:;
    // Computing bound for l
    _997.d1 = _995;
    if (_995 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing bound for m
    _997.d2 = _995;
    if (_995 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing total size of heap memory to allocate
    int64_t _999 = 1;
    _999 *= _998;
    _999 *= _995;
    _999 *= _995;
    _999 *= sizeof(int64_t);
    _997.data = jpl_alloc(_999);
    int64_t _1000 = 0; // m
    int64_t _1001 = 0; // l
    int64_t _1002 = 0; // k
    _jump586:; // Begin body of loop
    int64_t _1003 = 0;
    _1003 *= _997.d0;
    _1003 += _1002;
    _1003 *= _997.d1;
    _1003 += _1001;
    _1003 *= _997.d2;
    _1003 += _1000;
    _997.data[_1003] = _611.d1;
    _1000++;
    if (_1000 < _995)
    goto _jump586;
    _1000 = 0;
    _1001++;
    if (_1001 < _995)
    goto _jump586;
    _1001 = 0;
    _1002++;
    if (_1002 < _998)
    goto _jump586;
    // End body of loop
    _a2_int64_t _1004;
    // Computing bound for k
    int64_t _1005 = 915;
    _1004.d0 = _1005;
    if (_1005 > 0) 
    goto _jump587;
    fail_assertion("non-positive loop bound");
    _jump587:;
    // Computing bound for l
    _1004.d1 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing total size of heap memory to allocate
    int64_t _1006 = 1;
    _1006 *= _1005;
    _1006 *= _611.d0;
    _1006 *= sizeof(int64_t);
    _1004.data = jpl_alloc(_1006);
    int64_t _1007 = 0; // l
    int64_t _1008 = 0; // k
    _jump589:; // Begin body of loop
    int64_t _1009 = 0;
    _1009 *= _1004.d0;
    _1009 += _1008;
    _1009 *= _1004.d1;
    _1009 += _1007;
    _1004.data[_1009] = _995;
    _1007++;
    if (_1007 < _611.d0)
    goto _jump589;
    _1007 = 0;
    _1008++;
    if (_1008 < _1005)
    goto _jump589;
    // End body of loop
    int64_t _1010 = 613;
    int64_t _1011 = -_1010;
    if (_1011 >= 0)
    goto _jump590;
    fail_assertion("negative array index");
    _jump590:;
    if (_1011 < _1004.d0)
    goto _jump591;
    fail_assertion("index too large");
    _jump591:;
    if (_996 >= 0)
    goto _jump592;
    fail_assertion("negative array index");
    _jump592:;
    if (_996 < _1004.d1)
    goto _jump593;
    fail_assertion("index too large");
    _jump593:;
    int64_t _1012 = 0;
    _1012 *= _1004.d0;
    _1012 += _1011;
    _1012 *= _1004.d1;
    _1012 += _996;
    int64_t _1013 = _1004.data[_1012];
    bool _1014 = true;
    int64_t _1015;
    if (!_1014)
    goto _jump594;
    bool _1016 = false;
    int64_t _1017;
    if (!_1016)
    goto _jump595;
    int64_t _1018 = 907;
    _1017 = _1018;
    goto _jump596;
    _jump595:;
    _1017 = _994;
    _jump596:;
    _1015 = _1017;
    goto _jump597;
    _jump594:;
    _1015 = _995;
    _jump597:;
    if (_1013 >= 0)
    goto _jump598;
    fail_assertion("negative array index");
    _jump598:;
    if (_1013 < _997.d0)
    goto _jump599;
    fail_assertion("index too large");
    _jump599:;
    if (_995 >= 0)
    goto _jump600;
    fail_assertion("negative array index");
    _jump600:;
    if (_995 < _997.d1)
    goto _jump601;
    fail_assertion("index too large");
    _jump601:;
    if (_1015 >= 0)
    goto _jump602;
    fail_assertion("negative array index");
    _jump602:;
    if (_1015 < _997.d2)
    goto _jump603;
    fail_assertion("index too large");
    _jump603:;
    int64_t _1019 = 0;
    _1019 *= _997.d0;
    _1019 += _1013;
    _1019 *= _997.d1;
    _1019 += _995;
    _1019 *= _997.d2;
    _1019 += _1015;
    int64_t _1020 = _997.data[_1019];
    _984 += _1020;
    _994++;
    if (_994 < _993)
    goto _jump582;
    _994 = 0;
    _995++;
    if (_995 < _611.d1)
    goto _jump582;
    _995 = 0;
    _996++;
    if (_996 < _985)
    goto _jump582;
    // End body of loop
    int64_t _1021 = -_984;
    int64_t _1022;
    // Computing bound for h
    if (_453.d0 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    // Computing bound for i
    if (_611.d0 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for j
    if (_611.d1 > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    _1022 = 0;
    int64_t _1023 = 0; // j
    int64_t _1024 = 0; // i
    int64_t _1025 = 0; // h
    _jump607:; // Begin body of loop
    bool _1027 = true;
    bool _1026 = _1027;
    if (0 != _1027)
    goto _jump608;
    bool _1028 = false;
    _1026 = _1028;
    _jump608:;
    int64_t _1029;
    if (!_1026)
    goto _jump609;
    _1029 = _611.d0;
    goto _jump610;
    _jump609:;
    bool _1030 = false;
    int64_t _1031;
    if (!_1030)
    goto _jump611;
    _1031 = _611.d0;
    goto _jump612;
    _jump611:;
    _1031 = _453.d0;
    _jump612:;
    _1029 = _1031;
    _jump610:;
    _1022 += _1029;
    _1023++;
    if (_1023 < _611.d1)
    goto _jump607;
    _1023 = 0;
    _1024++;
    if (_1024 < _611.d0)
    goto _jump607;
    _1024 = 0;
    _1025++;
    if (_1025 < _453.d0)
    goto _jump607;
    // End body of loop
    int64_t _1032 = -_1022;
    int64_t _1033 = -_1032;
    int64_t _1034 = _1021 % _1033;
    if (_983 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (_983 < _982.d0)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    if (_1034 >= 0)
    goto _jump615;
    fail_assertion("negative array index");
    _jump615:;
    if (_1034 < _982.d1)
    goto _jump616;
    fail_assertion("index too large");
    _jump616:;
    if (_453.d0 >= 0)
    goto _jump617;
    fail_assertion("negative array index");
    _jump617:;
    if (_453.d0 < _982.d2)
    goto _jump618;
    fail_assertion("index too large");
    _jump618:;
    int64_t _1035 = 0;
    _1035 *= _982.d0;
    _1035 += _983;
    _1035 *= _982.d1;
    _1035 += _1034;
    _1035 *= _982.d2;
    _1035 += _453.d0;
    bool _1036 = _982.data[_1035];
    if (0 != _1036)
    goto _jump619;
    fail_assertion("h");
    _jump619:;
    _a3__a1_int64_t _1037;
    // Computing bound for h
    int64_t _1038;
    // Computing bound for h
    bool _1039 = true;
    bool _1040 = !_1039;
    bool _1041 = _611.d1 != _453.d0;
    bool _1042 = _1040 == _1041;
    _a1_int64_t _1043;
    if (!_1042)
    goto _jump620;
    _1043 = _453;
    goto _jump621;
    _jump620:;
    _1043 = _453;
    _jump621:;
    int64_t _1044;
    // Computing bound for h
    int64_t _1045 = -_453.d0;
    if (_1045 > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    _1044 = 0;
    int64_t _1046 = 0; // h
    _jump623:; // Begin body of loop
    bool _1047 = true;
    int64_t _1048;
    if (!_1047)
    goto _jump624;
    _1048 = _1046;
    goto _jump625;
    _jump624:;
    int64_t _1049 = _611.d1 % _453.d0;
    _1048 = _1049;
    _jump625:;
    _1044 += _1048;
    _1046++;
    if (_1046 < _1045)
    goto _jump623;
    // End body of loop
    if (_1044 >= 0)
    goto _jump626;
    fail_assertion("negative array index");
    _jump626:;
    if (_1044 < _1043.d0)
    goto _jump627;
    fail_assertion("index too large");
    _jump627:;
    int64_t _1050 = 0;
    _1050 *= _1043.d0;
    _1050 += _1044;
    int64_t _1051 = _1043.data[_1050];
    if (_1051 > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    _1038 = 0;
    int64_t _1052 = 0; // h
    _jump629:; // Begin body of loop
    _a3_int64_t _1053;
    // Computing bound for i
    _1053.d0 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump630;
    fail_assertion("non-positive loop bound");
    _jump630:;
    // Computing bound for j
    _1053.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump631;
    fail_assertion("non-positive loop bound");
    _jump631:;
    // Computing bound for k
    _1053.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing total size of heap memory to allocate
    int64_t _1054 = 1;
    _1054 *= _611.d0;
    _1054 *= _453.d0;
    _1054 *= _453.d0;
    _1054 *= sizeof(int64_t);
    _1053.data = jpl_alloc(_1054);
    int64_t _1055 = 0; // k
    int64_t _1056 = 0; // j
    int64_t _1057 = 0; // i
    _jump633:; // Begin body of loop
    int64_t _1058 = 0;
    _1058 *= _1053.d0;
    _1058 += _1057;
    _1058 *= _1053.d1;
    _1058 += _1056;
    _1058 *= _1053.d2;
    _1058 += _1055;
    _1053.data[_1058] = _1052;
    _1055++;
    if (_1055 < _453.d0)
    goto _jump633;
    _1055 = 0;
    _1056++;
    if (_1056 < _453.d0)
    goto _jump633;
    _1056 = 0;
    _1057++;
    if (_1057 < _611.d0)
    goto _jump633;
    // End body of loop
    bool _1059 = false;
    int64_t _1060;
    if (!_1059)
    goto _jump634;
    _1060 = _611.d0;
    goto _jump635;
    _jump634:;
    _1060 = _1052;
    _jump635:;
    if (_611.d1 >= 0)
    goto _jump636;
    fail_assertion("negative array index");
    _jump636:;
    if (_611.d1 < _1053.d0)
    goto _jump637;
    fail_assertion("index too large");
    _jump637:;
    if (_1052 >= 0)
    goto _jump638;
    fail_assertion("negative array index");
    _jump638:;
    if (_1052 < _1053.d1)
    goto _jump639;
    fail_assertion("index too large");
    _jump639:;
    if (_1060 >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (_1060 < _1053.d2)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    int64_t _1061 = 0;
    _1061 *= _1053.d0;
    _1061 += _611.d1;
    _1061 *= _1053.d1;
    _1061 += _1052;
    _1061 *= _1053.d2;
    _1061 += _1060;
    int64_t _1062 = _1053.data[_1061];
    int64_t _1063 = _611.d1 / _1062;
    int64_t _1064 = 368;
    int64_t _1065 = _1063 % _1064;
    _1038 += _1065;
    _1052++;
    if (_1052 < _1051)
    goto _jump629;
    // End body of loop
    _1037.d0 = _1038;
    if (_1038 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing bound for i
    double _1066 = a(b);
    int64_t _1067 = 377;
    if (_1067 >= 0)
    goto _jump643;
    fail_assertion("negative array index");
    _jump643:;
    if (_1067 < _611.d0)
    goto _jump644;
    fail_assertion("index too large");
    _jump644:;
    if (_453.d0 >= 0)
    goto _jump645;
    fail_assertion("negative array index");
    _jump645:;
    if (_453.d0 < _611.d1)
    goto _jump646;
    fail_assertion("index too large");
    _jump646:;
    int64_t _1068 = 0;
    _1068 *= _611.d0;
    _1068 += _1067;
    _1068 *= _611.d1;
    _1068 += _453.d0;
    double _1069 = _611.data[_1068];
    double _1070 = _1066 / _1069;
    double _1071 = 7.0;
    bool _1072 = _1070 > _1071;
    bool _1073 = !_1072;
    int64_t _1074;
    if (!_1073)
    goto _jump647;
    _1074 = _611.d1;
    goto _jump648;
    _jump647:;
    _1074 = _453.d0;
    _jump648:;
    _1037.d1 = _1074;
    if (_1074 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    // Computing bound for j
    _a3_bool _1075;
    // Computing bound for h
    _1075.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump650;
    fail_assertion("non-positive loop bound");
    _jump650:;
    // Computing bound for i
    _1075.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump651;
    fail_assertion("non-positive loop bound");
    _jump651:;
    // Computing bound for j
    bool _1076 = _453.d0 == _611.d1;
    int64_t _1077;
    if (!_1076)
    goto _jump652;
    bool _1078 = true;
    int64_t _1079;
    if (!_1078)
    goto _jump653;
    _1079 = _453.d0;
    goto _jump654;
    _jump653:;
    _1079 = _453.d0;
    _jump654:;
    _1077 = _1079;
    goto _jump655;
    _jump652:;
    _1077 = _611.d0;
    _jump655:;
    _1075.d2 = _1077;
    if (_1077 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing total size of heap memory to allocate
    int64_t _1080 = 1;
    _1080 *= _453.d0;
    _1080 *= _453.d0;
    _1080 *= _1077;
    _1080 *= sizeof(bool);
    _1075.data = jpl_alloc(_1080);
    int64_t _1081 = 0; // j
    int64_t _1082 = 0; // i
    int64_t _1083 = 0; // h
    _jump657:; // Begin body of loop
    bool _1085 = false;
    bool _1084 = _1085;
    if (0 != _1085)
    goto _jump658;
    bool _1086 = true;
    _1084 = _1086;
    _jump658:;
    int64_t _1087 = 0;
    _1087 *= _1075.d0;
    _1087 += _1083;
    _1087 *= _1075.d1;
    _1087 += _1082;
    _1087 *= _1075.d2;
    _1087 += _1081;
    _1075.data[_1087] = _1084;
    _1081++;
    if (_1081 < _1077)
    goto _jump657;
    _1081 = 0;
    _1082++;
    if (_1082 < _453.d0)
    goto _jump657;
    _1082 = 0;
    _1083++;
    if (_1083 < _453.d0)
    goto _jump657;
    // End body of loop
    int64_t _1088 = -_453.d0;
    int64_t _1089 = _453.d0 / _1088;
    bool _1090 = false;
    int64_t _1091;
    if (!_1090)
    goto _jump659;
    _1091 = _453.d0;
    goto _jump660;
    _jump659:;
    bool _1092 = _611.d1 < _453.d0;
    int64_t _1093;
    if (!_1092)
    goto _jump661;
    _1093 = _611.d0;
    goto _jump662;
    _jump661:;
    int64_t _1094 = -_611.d1;
    _1093 = _1094;
    _jump662:;
    _1091 = _1093;
    _jump660:;
    int64_t _1095;
    // Computing bound for h
    bool _1096 = true;
    int64_t _1097;
    if (!_1096)
    goto _jump663;
    _1097 = _611.d0;
    goto _jump664;
    _jump663:;
    _1097 = _611.d0;
    _jump664:;
    if (_1097 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for i
    int64_t _1098;
    // Computing bound for h
    if (_611.d0 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing bound for i
    int64_t _1099 = 338;
    int64_t _1100 = _1099 + _611.d0;
    if (_1100 > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    // Computing bound for j
    int64_t _1101;
    // Computing bound for h
    if (_611.d0 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    _1101 = 0;
    int64_t _1102 = 0; // h
    _jump669:; // Begin body of loop
    _1101 += _611.d1;
    _1102++;
    if (_1102 < _611.d0)
    goto _jump669;
    // End body of loop
    if (_1101 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    _1098 = 0;
    int64_t _1103 = 0; // j
    int64_t _1104 = 0; // i
    int64_t _1105 = 0; // h
    _jump671:; // Begin body of loop
    _1098 += _1104;
    _1103++;
    if (_1103 < _1101)
    goto _jump671;
    _1103 = 0;
    _1104++;
    if (_1104 < _1100)
    goto _jump671;
    _1104 = 0;
    _1105++;
    if (_1105 < _611.d0)
    goto _jump671;
    // End body of loop
    if (_1098 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing bound for j
    if (_611.d1 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    _1095 = 0;
    int64_t _1106 = 0; // j
    int64_t _1107 = 0; // i
    int64_t _1108 = 0; // h
    _jump674:; // Begin body of loop
    _a2_int64_t _1109;
    // Computing bound for k
    _1109.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    // Computing bound for l
    _1109.d1 = _1107;
    if (_1107 > 0) 
    goto _jump676;
    fail_assertion("non-positive loop bound");
    _jump676:;
    // Computing total size of heap memory to allocate
    int64_t _1110 = 1;
    _1110 *= _453.d0;
    _1110 *= _1107;
    _1110 *= sizeof(int64_t);
    _1109.data = jpl_alloc(_1110);
    int64_t _1111 = 0; // l
    int64_t _1112 = 0; // k
    _jump677:; // Begin body of loop
    int64_t _1113 = 0;
    _1113 *= _1109.d0;
    _1113 += _1112;
    _1113 *= _1109.d1;
    _1113 += _1111;
    _1109.data[_1113] = _1111;
    _1111++;
    if (_1111 < _1107)
    goto _jump677;
    _1111 = 0;
    _1112++;
    if (_1112 < _453.d0)
    goto _jump677;
    // End body of loop
    int64_t _1114 = -_1107;
    if (_1106 >= 0)
    goto _jump678;
    fail_assertion("negative array index");
    _jump678:;
    if (_1106 < _1109.d0)
    goto _jump679;
    fail_assertion("index too large");
    _jump679:;
    if (_1114 >= 0)
    goto _jump680;
    fail_assertion("negative array index");
    _jump680:;
    if (_1114 < _1109.d1)
    goto _jump681;
    fail_assertion("index too large");
    _jump681:;
    int64_t _1115 = 0;
    _1115 *= _1109.d0;
    _1115 += _1106;
    _1115 *= _1109.d1;
    _1115 += _1114;
    int64_t _1116 = _1109.data[_1115];
    _1095 += _1116;
    _1106++;
    if (_1106 < _611.d1)
    goto _jump674;
    _1106 = 0;
    _1107++;
    if (_1107 < _1098)
    goto _jump674;
    _1107 = 0;
    _1108++;
    if (_1108 < _1097)
    goto _jump674;
    // End body of loop
    if (_1089 >= 0)
    goto _jump682;
    fail_assertion("negative array index");
    _jump682:;
    if (_1089 < _1075.d0)
    goto _jump683;
    fail_assertion("index too large");
    _jump683:;
    if (_1091 >= 0)
    goto _jump684;
    fail_assertion("negative array index");
    _jump684:;
    if (_1091 < _1075.d1)
    goto _jump685;
    fail_assertion("index too large");
    _jump685:;
    if (_1095 >= 0)
    goto _jump686;
    fail_assertion("negative array index");
    _jump686:;
    if (_1095 < _1075.d2)
    goto _jump687;
    fail_assertion("index too large");
    _jump687:;
    int64_t _1117 = 0;
    _1117 *= _1075.d0;
    _1117 += _1089;
    _1117 *= _1075.d1;
    _1117 += _1091;
    _1117 *= _1075.d2;
    _1117 += _1095;
    bool _1118 = _1075.data[_1117];
    int64_t _1119;
    if (!_1118)
    goto _jump688;
    int64_t _1120;
    // Computing bound for h
    if (_611.d1 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing bound for i
    if (_611.d1 > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    // Computing bound for j
    int64_t _1121;
    // Computing bound for h
    bool _1122 = true;
    bool _1123 = !_1122;
    int64_t _1124;
    if (!_1123)
    goto _jump691;
    int64_t _1125 = -_453.d0;
    _1124 = _1125;
    goto _jump692;
    _jump691:;
    int64_t _1126 = _611.d0 / _611.d1;
    _1124 = _1126;
    _jump692:;
    if (_1124 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    // Computing bound for i
    int64_t _1127 = 176;
    if (_1127 > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    _1121 = 0;
    int64_t _1128 = 0; // i
    int64_t _1129 = 0; // h
    _jump695:; // Begin body of loop
    _1121 += _453.d0;
    _1128++;
    if (_1128 < _1127)
    goto _jump695;
    _1128 = 0;
    _1129++;
    if (_1129 < _1124)
    goto _jump695;
    // End body of loop
    if (_1121 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    _1120 = 0;
    int64_t _1130 = 0; // j
    int64_t _1131 = 0; // i
    int64_t _1132 = 0; // h
    _jump697:; // Begin body of loop
    _1120 += _1131;
    _1130++;
    if (_1130 < _1121)
    goto _jump697;
    _1130 = 0;
    _1131++;
    if (_1131 < _611.d1)
    goto _jump697;
    _1131 = 0;
    _1132++;
    if (_1132 < _611.d1)
    goto _jump697;
    // End body of loop
    _1119 = _1120;
    goto _jump698;
    _jump688:;
    _1119 = _453.d0;
    _jump698:;
    _1037.d2 = _1119;
    if (_1119 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    // Computing total size of heap memory to allocate
    int64_t _1133 = 1;
    _1133 *= _1038;
    _1133 *= _1074;
    _1133 *= _1119;
    _1133 *= sizeof(_a1_int64_t);
    _1037.data = jpl_alloc(_1133);
    int64_t _1134 = 0; // j
    int64_t _1135 = 0; // i
    int64_t _1136 = 0; // h
    _jump700:; // Begin body of loop
    int64_t _1137 = 0;
    _1137 *= _1037.d0;
    _1137 += _1136;
    _1137 *= _1037.d1;
    _1137 += _1135;
    _1137 *= _1037.d2;
    _1137 += _1134;
    _1037.data[_1137] = _453;
    _1134++;
    if (_1134 < _1119)
    goto _jump700;
    _1134 = 0;
    _1135++;
    if (_1135 < _1074)
    goto _jump700;
    _1135 = 0;
    _1136++;
    if (_1136 < _1038)
    goto _jump700;
    // End body of loop
    int64_t _1138 = 574;
    double _1139 = a(b);
    double _1140 = 17.0;
    bool _1141 = _1139 == _1140;
    _a3_int64_t _1142;
    if (!_1141)
    goto _jump701;
    double _1143 = 16.0;
    double _1144 = 95.0;
    double _1145 = _1143 / _1144;
    double _1146 = a(b);
    bool _1147 = _1145 > _1146;
    _a3_int64_t _1148;
    if (!_1147)
    goto _jump702;
    int64_t _1149 = 581;
    bool _1150 = _1149 > _611.d1;
    bool _1151 = !_1150;
    _a3_int64_t _1152;
    if (!_1151)
    goto _jump703;
    _a3_int64_t _1153;
    // Computing bound for h
    _1153.d0 = _611.d1;
    if (_611.d1 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for i
    int64_t _1154 = 715;
    int64_t _1155 = -_1154;
    _1153.d1 = _1155;
    if (_1155 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing bound for j
    _1153.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    // Computing total size of heap memory to allocate
    int64_t _1156 = 1;
    _1156 *= _611.d1;
    _1156 *= _1155;
    _1156 *= _453.d0;
    _1156 *= sizeof(int64_t);
    _1153.data = jpl_alloc(_1156);
    int64_t _1157 = 0; // j
    int64_t _1158 = 0; // i
    int64_t _1159 = 0; // h
    _jump707:; // Begin body of loop
    int64_t _1160 = 0;
    _1160 *= _1153.d0;
    _1160 += _1159;
    _1160 *= _1153.d1;
    _1160 += _1158;
    _1160 *= _1153.d2;
    _1160 += _1157;
    _1153.data[_1160] = _611.d0;
    _1157++;
    if (_1157 < _453.d0)
    goto _jump707;
    _1157 = 0;
    _1158++;
    if (_1158 < _1155)
    goto _jump707;
    _1158 = 0;
    _1159++;
    if (_1159 < _611.d1)
    goto _jump707;
    // End body of loop
    _1152 = _1153;
    goto _jump708;
    _jump703:;
    _a3_int64_t _1161;
    // Computing bound for h
    _1161.d0 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump709;
    fail_assertion("non-positive loop bound");
    _jump709:;
    // Computing bound for i
    _1161.d1 = _611.d1;
    if (_611.d1 > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing bound for j
    _1161.d2 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    // Computing total size of heap memory to allocate
    int64_t _1162 = 1;
    _1162 *= _611.d0;
    _1162 *= _611.d1;
    _1162 *= _611.d0;
    _1162 *= sizeof(int64_t);
    _1161.data = jpl_alloc(_1162);
    int64_t _1163 = 0; // j
    int64_t _1164 = 0; // i
    int64_t _1165 = 0; // h
    _jump712:; // Begin body of loop
    int64_t _1166 = 0;
    _1166 *= _1161.d0;
    _1166 += _1165;
    _1166 *= _1161.d1;
    _1166 += _1164;
    _1166 *= _1161.d2;
    _1166 += _1163;
    _1161.data[_1166] = _611.d1;
    _1163++;
    if (_1163 < _611.d0)
    goto _jump712;
    _1163 = 0;
    _1164++;
    if (_1164 < _611.d1)
    goto _jump712;
    _1164 = 0;
    _1165++;
    if (_1165 < _611.d0)
    goto _jump712;
    // End body of loop
    _1152 = _1161;
    _jump708:;
    _1148 = _1152;
    goto _jump713;
    _jump702:;
    _a3_int64_t _1167;
    // Computing bound for h
    int64_t _1168;
    // Computing bound for h
    if (_453.d0 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for i
    int64_t _1169 = 306;
    int64_t _1170 = _1169 - _611.d0;
    if (_1170 > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    // Computing bound for j
    if (_611.d0 > 0) 
    goto _jump716;
    fail_assertion("non-positive loop bound");
    _jump716:;
    _1168 = 0;
    int64_t _1171 = 0; // j
    int64_t _1172 = 0; // i
    int64_t _1173 = 0; // h
    _jump717:; // Begin body of loop
    _1168 += _611.d1;
    _1171++;
    if (_1171 < _611.d0)
    goto _jump717;
    _1171 = 0;
    _1172++;
    if (_1172 < _1170)
    goto _jump717;
    _1172 = 0;
    _1173++;
    if (_1173 < _453.d0)
    goto _jump717;
    // End body of loop
    _1167.d0 = _1168;
    if (_1168 > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for i
    bool _1174 = true;
    bool _1175 = false;
    bool _1176 = _1174 != _1175;
    int64_t _1177;
    if (!_1176)
    goto _jump719;
    _1177 = _611.d1;
    goto _jump720;
    _jump719:;
    _1177 = _453.d0;
    _jump720:;
    _1167.d1 = _1177;
    if (_1177 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for j
    int64_t _1178;
    // Computing bound for h
    int64_t _1179 = -_611.d1;
    if (_1179 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    _1178 = 0;
    int64_t _1180 = 0; // h
    _jump723:; // Begin body of loop
    bool _1181 = false;
    int64_t _1182;
    if (!_1181)
    goto _jump724;
    _1182 = _453.d0;
    goto _jump725;
    _jump724:;
    _1182 = _1180;
    _jump725:;
    _1178 += _1182;
    _1180++;
    if (_1180 < _1179)
    goto _jump723;
    // End body of loop
    _1167.d2 = _1178;
    if (_1178 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    // Computing total size of heap memory to allocate
    int64_t _1183 = 1;
    _1183 *= _1168;
    _1183 *= _1177;
    _1183 *= _1178;
    _1183 *= sizeof(int64_t);
    _1167.data = jpl_alloc(_1183);
    int64_t _1184 = 0; // j
    int64_t _1185 = 0; // i
    int64_t _1186 = 0; // h
    _jump727:; // Begin body of loop
    _a1_int64_t _1187;
    // Computing bound for k
    _1187.d0 = _611.d1;
    if (_611.d1 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing total size of heap memory to allocate
    int64_t _1188 = 1;
    _1188 *= _611.d1;
    _1188 *= sizeof(int64_t);
    _1187.data = jpl_alloc(_1188);
    int64_t _1189 = 0; // k
    _jump729:; // Begin body of loop
    int64_t _1190 = 0;
    _1190 *= _1187.d0;
    _1190 += _1189;
    _1187.data[_1190] = _1186;
    _1189++;
    if (_1189 < _611.d1)
    goto _jump729;
    // End body of loop
    if (_453.d0 >= 0)
    goto _jump730;
    fail_assertion("negative array index");
    _jump730:;
    if (_453.d0 < _1187.d0)
    goto _jump731;
    fail_assertion("index too large");
    _jump731:;
    int64_t _1191 = 0;
    _1191 *= _1187.d0;
    _1191 += _453.d0;
    int64_t _1192 = _1187.data[_1191];
    int64_t _1193 = 0;
    _1193 *= _1167.d0;
    _1193 += _1186;
    _1193 *= _1167.d1;
    _1193 += _1185;
    _1193 *= _1167.d2;
    _1193 += _1184;
    _1167.data[_1193] = _1192;
    _1184++;
    if (_1184 < _1178)
    goto _jump727;
    _1184 = 0;
    _1185++;
    if (_1185 < _1177)
    goto _jump727;
    _1185 = 0;
    _1186++;
    if (_1186 < _1168)
    goto _jump727;
    // End body of loop
    _1148 = _1167;
    _jump713:;
    _1142 = _1148;
    goto _jump732;
    _jump701:;
    _a3_int64_t _1194;
    // Computing bound for h
    _1194.d0 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for i
    _1194.d1 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing bound for j
    _a1_int64_t _1195;
    // Computing bound for h
    int64_t _1196;
    // Computing bound for h
    if (_453.d0 > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing bound for i
    if (_611.d1 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for j
    int64_t _1197 = 719;
    if (_1197 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    _1196 = 0;
    int64_t _1198 = 0; // j
    int64_t _1199 = 0; // i
    int64_t _1200 = 0; // h
    _jump738:; // Begin body of loop
    _1196 += _1198;
    _1198++;
    if (_1198 < _1197)
    goto _jump738;
    _1198 = 0;
    _1199++;
    if (_1199 < _611.d1)
    goto _jump738;
    _1199 = 0;
    _1200++;
    if (_1200 < _453.d0)
    goto _jump738;
    // End body of loop
    _1195.d0 = _1196;
    if (_1196 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing total size of heap memory to allocate
    int64_t _1201 = 1;
    _1201 *= _1196;
    _1201 *= sizeof(int64_t);
    _1195.data = jpl_alloc(_1201);
    int64_t _1202 = 0; // h
    _jump740:; // Begin body of loop
    int64_t _1203;
    // Computing bound for i
    if (_453.d0 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for j
    if (_1202 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    _1203 = 0;
    int64_t _1204 = 0; // j
    int64_t _1205 = 0; // i
    _jump743:; // Begin body of loop
    _1203 += _1204;
    _1204++;
    if (_1204 < _1202)
    goto _jump743;
    _1204 = 0;
    _1205++;
    if (_1205 < _453.d0)
    goto _jump743;
    // End body of loop
    int64_t _1206 = 0;
    _1206 *= _1195.d0;
    _1206 += _1202;
    _1195.data[_1206] = _1203;
    _1202++;
    if (_1202 < _1196)
    goto _jump740;
    // End body of loop
    int64_t _1207 = 722;
    if (_1207 >= 0)
    goto _jump744;
    fail_assertion("negative array index");
    _jump744:;
    if (_1207 < _1195.d0)
    goto _jump745;
    fail_assertion("index too large");
    _jump745:;
    int64_t _1208 = 0;
    _1208 *= _1195.d0;
    _1208 += _1207;
    int64_t _1209 = _1195.data[_1208];
    _1194.d2 = _1209;
    if (_1209 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing total size of heap memory to allocate
    int64_t _1210 = 1;
    _1210 *= _453.d0;
    _1210 *= _453.d0;
    _1210 *= _1209;
    _1210 *= sizeof(int64_t);
    _1194.data = jpl_alloc(_1210);
    int64_t _1211 = 0; // j
    int64_t _1212 = 0; // i
    int64_t _1213 = 0; // h
    _jump747:; // Begin body of loop
    int64_t _1214 = 0;
    _1214 *= _1194.d0;
    _1214 += _1213;
    _1214 *= _1194.d1;
    _1214 += _1212;
    _1214 *= _1194.d2;
    _1214 += _1211;
    _1194.data[_1214] = _453.d0;
    _1211++;
    if (_1211 < _1209)
    goto _jump747;
    _1211 = 0;
    _1212++;
    if (_1212 < _453.d0)
    goto _jump747;
    _1212 = 0;
    _1213++;
    if (_1213 < _453.d0)
    goto _jump747;
    // End body of loop
    _1142 = _1194;
    _jump732:;
    int64_t _1215 = 372;
    bool _1216 = _1215 < _611.d0;
    bool _1217;
    if (!_1216)
    goto _jump748;
    bool _1218 = true;
    _1217 = _1218;
    goto _jump749;
    _jump748:;
    bool _1219 = true;
    bool _1220 = !_1219;
    _1217 = _1220;
    _jump749:;
    bool _1221 = !_1217;
    int64_t _1222;
    if (!_1221)
    goto _jump750;
    int64_t _1223 = -_611.d0;
    _1222 = _1223;
    goto _jump751;
    _jump750:;
    int64_t _1224;
    // Computing bound for h
    int64_t _1225;
    // Computing bound for h
    if (_611.d1 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for i
    int64_t _1226 = 482;
    if (_1226 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing bound for j
    if (_611.d0 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    _1225 = 0;
    int64_t _1227 = 0; // j
    int64_t _1228 = 0; // i
    int64_t _1229 = 0; // h
    _jump755:; // Begin body of loop
    _1225 += _1228;
    _1227++;
    if (_1227 < _611.d0)
    goto _jump755;
    _1227 = 0;
    _1228++;
    if (_1228 < _1226)
    goto _jump755;
    _1228 = 0;
    _1229++;
    if (_1229 < _611.d1)
    goto _jump755;
    // End body of loop
    if (_1225 > 0) 
    goto _jump756;
    fail_assertion("non-positive loop bound");
    _jump756:;
    // Computing bound for i
    if (_453.d0 > 0) 
    goto _jump757;
    fail_assertion("non-positive loop bound");
    _jump757:;
    // Computing bound for j
    int64_t _1230 = -_453.d0;
    if (_1230 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    _1224 = 0;
    int64_t _1231 = 0; // j
    int64_t _1232 = 0; // i
    int64_t _1233 = 0; // h
    _jump759:; // Begin body of loop
    _1224 += _611.d1;
    _1231++;
    if (_1231 < _1230)
    goto _jump759;
    _1231 = 0;
    _1232++;
    if (_1232 < _453.d0)
    goto _jump759;
    _1232 = 0;
    _1233++;
    if (_1233 < _1225)
    goto _jump759;
    // End body of loop
    int64_t _1234 = -_1224;
    _1222 = _1234;
    _jump751:;
    if (_611.d1 >= 0)
    goto _jump760;
    fail_assertion("negative array index");
    _jump760:;
    if (_611.d1 < _1142.d0)
    goto _jump761;
    fail_assertion("index too large");
    _jump761:;
    if (_1222 >= 0)
    goto _jump762;
    fail_assertion("negative array index");
    _jump762:;
    if (_1222 < _1142.d1)
    goto _jump763;
    fail_assertion("index too large");
    _jump763:;
    if (_611.d1 >= 0)
    goto _jump764;
    fail_assertion("negative array index");
    _jump764:;
    if (_611.d1 < _1142.d2)
    goto _jump765;
    fail_assertion("index too large");
    _jump765:;
    int64_t _1235 = 0;
    _1235 *= _1142.d0;
    _1235 += _611.d1;
    _1235 *= _1142.d1;
    _1235 += _1222;
    _1235 *= _1142.d2;
    _1235 += _611.d1;
    int64_t _1236 = _1142.data[_1235];
    bool _1237 = false;
    bool _1238 = !_1237;
    bool _1239;
    if (!_1238)
    goto _jump766;
    _a2_bool _1240;
    // Computing bound for h
    _1240.d0 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for i
    _a2_int64_t _1241;
    // Computing bound for h
    int64_t _1242 = 537;
    _1241.d0 = _1242;
    if (_1242 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    // Computing bound for i
    int64_t _1243 = 136;
    _1241.d1 = _1243;
    if (_1243 > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    // Computing total size of heap memory to allocate
    int64_t _1244 = 1;
    _1244 *= _1242;
    _1244 *= _1243;
    _1244 *= sizeof(int64_t);
    _1241.data = jpl_alloc(_1244);
    int64_t _1245 = 0; // i
    int64_t _1246 = 0; // h
    _jump770:; // Begin body of loop
    int64_t _1247 = 0;
    _1247 *= _1241.d0;
    _1247 += _1246;
    _1247 *= _1241.d1;
    _1247 += _1245;
    _1241.data[_1247] = _1246;
    _1245++;
    if (_1245 < _1243)
    goto _jump770;
    _1245 = 0;
    _1246++;
    if (_1246 < _1242)
    goto _jump770;
    // End body of loop
    int64_t _1248;
    // Computing bound for h
    int64_t _1249 = 454;
    if (_1249 > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    // Computing bound for i
    if (_453.d0 > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    _1248 = 0;
    int64_t _1250 = 0; // i
    int64_t _1251 = 0; // h
    _jump773:; // Begin body of loop
    _1248 += _611.d0;
    _1250++;
    if (_1250 < _453.d0)
    goto _jump773;
    _1250 = 0;
    _1251++;
    if (_1251 < _1249)
    goto _jump773;
    // End body of loop
    if (_611.d1 >= 0)
    goto _jump774;
    fail_assertion("negative array index");
    _jump774:;
    if (_611.d1 < _1241.d0)
    goto _jump775;
    fail_assertion("index too large");
    _jump775:;
    if (_1248 >= 0)
    goto _jump776;
    fail_assertion("negative array index");
    _jump776:;
    if (_1248 < _1241.d1)
    goto _jump777;
    fail_assertion("index too large");
    _jump777:;
    int64_t _1252 = 0;
    _1252 *= _1241.d0;
    _1252 += _611.d1;
    _1252 *= _1241.d1;
    _1252 += _1248;
    int64_t _1253 = _1241.data[_1252];
    _1240.d1 = _1253;
    if (_1253 > 0) 
    goto _jump778;
    fail_assertion("non-positive loop bound");
    _jump778:;
    // Computing total size of heap memory to allocate
    int64_t _1254 = 1;
    _1254 *= _611.d0;
    _1254 *= _1253;
    _1254 *= sizeof(bool);
    _1240.data = jpl_alloc(_1254);
    int64_t _1255 = 0; // i
    int64_t _1256 = 0; // h
    _jump779:; // Begin body of loop
    bool _1257 = true;
    bool _1258 = !_1257;
    int64_t _1259 = 0;
    _1259 *= _1240.d0;
    _1259 += _1256;
    _1259 *= _1240.d1;
    _1259 += _1255;
    _1240.data[_1259] = _1258;
    _1255++;
    if (_1255 < _1253)
    goto _jump779;
    _1255 = 0;
    _1256++;
    if (_1256 < _611.d0)
    goto _jump779;
    // End body of loop
    int64_t _1260;
    // Computing bound for h
    if (_611.d1 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing bound for i
    int64_t _1261 = 880;
    if (_1261 > 0) 
    goto _jump781;
    fail_assertion("non-positive loop bound");
    _jump781:;
    // Computing bound for j
    bool _1262 = false;
    int64_t _1263;
    if (!_1262)
    goto _jump782;
    int64_t _1264 = 960;
    _1263 = _1264;
    goto _jump783;
    _jump782:;
    _1263 = _453.d0;
    _jump783:;
    if (_1263 > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    _1260 = 0;
    int64_t _1265 = 0; // j
    int64_t _1266 = 0; // i
    int64_t _1267 = 0; // h
    _jump785:; // Begin body of loop
    _1260 += _1267;
    _1265++;
    if (_1265 < _1263)
    goto _jump785;
    _1265 = 0;
    _1266++;
    if (_1266 < _1261)
    goto _jump785;
    _1266 = 0;
    _1267++;
    if (_1267 < _611.d1)
    goto _jump785;
    // End body of loop
    int64_t _1268 = -_1260;
    if (_453.d0 >= 0)
    goto _jump786;
    fail_assertion("negative array index");
    _jump786:;
    if (_453.d0 < _1240.d0)
    goto _jump787;
    fail_assertion("index too large");
    _jump787:;
    if (_1268 >= 0)
    goto _jump788;
    fail_assertion("negative array index");
    _jump788:;
    if (_1268 < _1240.d1)
    goto _jump789;
    fail_assertion("index too large");
    _jump789:;
    int64_t _1269 = 0;
    _1269 *= _1240.d0;
    _1269 += _453.d0;
    _1269 *= _1240.d1;
    _1269 += _1268;
    bool _1270 = _1240.data[_1269];
    _1239 = _1270;
    goto _jump790;
    _jump766:;
    bool _1272 = false;
    _a1_bool _1273;
    _1273.d0 = 1;
    _1273.data = jpl_alloc(sizeof(bool) * 1);
    _1273.data[0] = _1272;
    if (_611.d1 >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (_611.d1 < _1273.d0)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    int64_t _1274 = 0;
    _1274 *= _1273.d0;
    _1274 += _611.d1;
    bool _1275 = _1273.data[_1274];
    bool _1276;
    if (!_1275)
    goto _jump793;
    if (_453.d0 >= 0)
    goto _jump794;
    fail_assertion("negative array index");
    _jump794:;
    if (_453.d0 < _453.d0)
    goto _jump795;
    fail_assertion("index too large");
    _jump795:;
    int64_t _1277 = 0;
    _1277 *= _453.d0;
    _1277 += _453.d0;
    int64_t _1278 = _453.data[_1277];
    bool _1279 = _1278 <= _611.d0;
    _1276 = _1279;
    goto _jump796;
    _jump793:;
    int64_t _1280 = -_453.d0;
    bool _1281 = _611.d1 < _1280;
    _1276 = _1281;
    _jump796:;
    bool _1271 = _1276;
    if (0 == _1276)
    goto _jump797;
    bool _1282 = true;
    bool _1283 = !_1282;
    bool _1284 = !_1283;
    bool _1285 = !_1284;
    _1271 = _1285;
    _jump797:;
    _1239 = _1271;
    _jump790:;
    int64_t _1286;
    if (!_1239)
    goto _jump798;
    _1286 = _611.d0;
    goto _jump799;
    _jump798:;
    int64_t _1287 = -_611.d0;
    _1286 = _1287;
    _jump799:;
    if (_1138 >= 0)
    goto _jump800;
    fail_assertion("negative array index");
    _jump800:;
    if (_1138 < _1037.d0)
    goto _jump801;
    fail_assertion("index too large");
    _jump801:;
    if (_1236 >= 0)
    goto _jump802;
    fail_assertion("negative array index");
    _jump802:;
    if (_1236 < _1037.d1)
    goto _jump803;
    fail_assertion("index too large");
    _jump803:;
    if (_1286 >= 0)
    goto _jump804;
    fail_assertion("negative array index");
    _jump804:;
    if (_1286 < _1037.d2)
    goto _jump805;
    fail_assertion("index too large");
    _jump805:;
    int64_t _1288 = 0;
    _1288 *= _1037.d0;
    _1288 += _1138;
    _1288 *= _1037.d1;
    _1288 += _1236;
    _1288 *= _1037.d2;
    _1288 += _1286;
    _a1_int64_t _1289 = _1037.data[_1288];
    _a3_int64_t _1290;
    // Computing bound for k
    _1290.d0 = _611.d1;
    if (_611.d1 > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    // Computing bound for l
    _1290.d1 = _1289.d0;
    if (_1289.d0 > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing bound for m
    _1290.d2 = _1289.d0;
    if (_1289.d0 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing total size of heap memory to allocate
    int64_t _1291 = 1;
    _1291 *= _611.d1;
    _1291 *= _1289.d0;
    _1291 *= _1289.d0;
    _1291 *= sizeof(int64_t);
    _1290.data = jpl_alloc(_1291);
    int64_t _1292 = 0; // m
    int64_t _1293 = 0; // l
    int64_t _1294 = 0; // k
    _jump809:; // Begin body of loop
    int64_t _1295 = 0;
    _1295 *= _1290.d0;
    _1295 += _1294;
    _1295 *= _1290.d1;
    _1295 += _1293;
    _1295 *= _1290.d2;
    _1295 += _1292;
    _1290.data[_1295] = _611.d1;
    _1292++;
    if (_1292 < _1289.d0)
    goto _jump809;
    _1292 = 0;
    _1293++;
    if (_1293 < _1289.d0)
    goto _jump809;
    _1293 = 0;
    _1294++;
    if (_1294 < _611.d1)
    goto _jump809;
    // End body of loop
    if (_1289.d0 >= 0)
    goto _jump810;
    fail_assertion("negative array index");
    _jump810:;
    if (_1289.d0 < _1290.d0)
    goto _jump811;
    fail_assertion("index too large");
    _jump811:;
    if (_1289.d0 >= 0)
    goto _jump812;
    fail_assertion("negative array index");
    _jump812:;
    if (_1289.d0 < _1290.d1)
    goto _jump813;
    fail_assertion("index too large");
    _jump813:;
    if (_611.d1 >= 0)
    goto _jump814;
    fail_assertion("negative array index");
    _jump814:;
    if (_611.d1 < _1290.d2)
    goto _jump815;
    fail_assertion("index too large");
    _jump815:;
    int64_t _1296 = 0;
    _1296 *= _1290.d0;
    _1296 += _1289.d0;
    _1296 *= _1290.d1;
    _1296 += _1289.d0;
    _1296 *= _1290.d2;
    _1296 += _611.d1;
    int64_t _1297 = _1290.data[_1296];
    int64_t _1298 = _611.d1 + _1297;
    int64_t _1299 = -_1298;
    bool _1301 = false;
    bool _1300 = _1301;
    if (0 != _1301)
    goto _jump816;
    bool _1303 = false;
    bool _1304 = true;
    bool _1305 = _1303 != _1304;
    bool _1302 = _1305;
    if (0 == _1305)
    goto _jump817;
    bool _1306 = true;
    _1302 = _1306;
    _jump817:;
    _1300 = _1302;
    _jump816:;
    _a3_bool _1307;
    if (!_1300)
    goto _jump818;
    _a2__a3_bool _1308;
    // Computing bound for l
    int64_t _1309 = 397;
    int64_t _1310 = _1309 % _1289.d0;
    _1308.d0 = _1310;
    if (_1310 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    // Computing bound for m
    _1308.d1 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    // Computing total size of heap memory to allocate
    int64_t _1311 = 1;
    _1311 *= _1310;
    _1311 *= _611.d0;
    _1311 *= sizeof(_a3_bool);
    _1308.data = jpl_alloc(_1311);
    int64_t _1312 = 0; // m
    int64_t _1313 = 0; // l
    _jump821:; // Begin body of loop
    _a3_bool _1314;
    // Computing bound for n
    _1314.d0 = _611.d1;
    if (_611.d1 > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    // Computing bound for o
    _1314.d1 = _1299;
    if (_1299 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing bound for p
    _1314.d2 = _453.d0;
    if (_453.d0 > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    // Computing total size of heap memory to allocate
    int64_t _1315 = 1;
    _1315 *= _611.d1;
    _1315 *= _1299;
    _1315 *= _453.d0;
    _1315 *= sizeof(bool);
    _1314.data = jpl_alloc(_1315);
    int64_t _1316 = 0; // p
    int64_t _1317 = 0; // o
    int64_t _1318 = 0; // n
    _jump825:; // Begin body of loop
    bool _1319 = false;
    int64_t _1320 = 0;
    _1320 *= _1314.d0;
    _1320 += _1318;
    _1320 *= _1314.d1;
    _1320 += _1317;
    _1320 *= _1314.d2;
    _1320 += _1316;
    _1314.data[_1320] = _1319;
    _1316++;
    if (_1316 < _453.d0)
    goto _jump825;
    _1316 = 0;
    _1317++;
    if (_1317 < _1299)
    goto _jump825;
    _1317 = 0;
    _1318++;
    if (_1318 < _611.d1)
    goto _jump825;
    // End body of loop
    int64_t _1321 = 0;
    _1321 *= _1308.d0;
    _1321 += _1313;
    _1321 *= _1308.d1;
    _1321 += _1312;
    _1308.data[_1321] = _1314;
    _1312++;
    if (_1312 < _611.d0)
    goto _jump821;
    _1312 = 0;
    _1313++;
    if (_1313 < _1310)
    goto _jump821;
    // End body of loop
    bool _1323 = true;
    bool _1322 = _1323;
    if (0 != _1323)
    goto _jump826;
    bool _1324 = false;
    _1322 = _1324;
    _jump826:;
    int64_t _1325;
    if (!_1322)
    goto _jump827;
    int64_t _1326;
    // Computing bound for l
    if (_611.d0 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    _1326 = 0;
    int64_t _1327 = 0; // l
    _jump829:; // Begin body of loop
    _1326 += _611.d1;
    _1327++;
    if (_1327 < _611.d0)
    goto _jump829;
    // End body of loop
    _1325 = _1326;
    goto _jump830;
    _jump827:;
    _1325 = _1299;
    _jump830:;
    if (_1289.d0 >= 0)
    goto _jump831;
    fail_assertion("negative array index");
    _jump831:;
    if (_1289.d0 < _1308.d0)
    goto _jump832;
    fail_assertion("index too large");
    _jump832:;
    if (_1325 >= 0)
    goto _jump833;
    fail_assertion("negative array index");
    _jump833:;
    if (_1325 < _1308.d1)
    goto _jump834;
    fail_assertion("index too large");
    _jump834:;
    int64_t _1328 = 0;
    _1328 *= _1308.d0;
    _1328 += _1289.d0;
    _1328 *= _1308.d1;
    _1328 += _1325;
    _a3_bool _1329 = _1308.data[_1328];
    _1307 = _1329;
    goto _jump835;
    _jump818:;
    _a3_bool _1330;
    // Computing bound for l
    _1330.d0 = _611.d0;
    if (_611.d0 > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for m
    _1330.d1 = _1299;
    if (_1299 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for n
    int64_t _1331 = 307;
    int64_t _1332 = 646;
    int64_t _1333 = _1331 / _1332;
    _1330.d2 = _1333;
    if (_1333 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing total size of heap memory to allocate
    int64_t _1334 = 1;
    _1334 *= _611.d0;
    _1334 *= _1299;
    _1334 *= _1333;
    _1334 *= sizeof(bool);
    _1330.data = jpl_alloc(_1334);
    int64_t _1335 = 0; // n
    int64_t _1336 = 0; // m
    int64_t _1337 = 0; // l
    _jump839:; // Begin body of loop
    bool _1338 = true;
    int64_t _1339 = 0;
    _1339 *= _1330.d0;
    _1339 += _1337;
    _1339 *= _1330.d1;
    _1339 += _1336;
    _1339 *= _1330.d2;
    _1339 += _1335;
    _1330.data[_1339] = _1338;
    _1335++;
    if (_1335 < _1333)
    goto _jump839;
    _1335 = 0;
    _1336++;
    if (_1336 < _1299)
    goto _jump839;
    _1336 = 0;
    _1337++;
    if (_1337 < _611.d0)
    goto _jump839;
    // End body of loop
    _1307 = _1330;
    _jump835:;
    if (_1299 >= 0)
    goto _jump840;
    fail_assertion("negative array index");
    _jump840:;
    if (_1299 < _1307.d0)
    goto _jump841;
    fail_assertion("index too large");
    _jump841:;
    if (_611.d1 >= 0)
    goto _jump842;
    fail_assertion("negative array index");
    _jump842:;
    if (_611.d1 < _1307.d1)
    goto _jump843;
    fail_assertion("index too large");
    _jump843:;
    if (_611.d0 >= 0)
    goto _jump844;
    fail_assertion("negative array index");
    _jump844:;
    if (_611.d0 < _1307.d2)
    goto _jump845;
    fail_assertion("index too large");
    _jump845:;
    int64_t _1340 = 0;
    _1340 *= _1307.d0;
    _1340 += _1299;
    _1340 *= _1307.d1;
    _1340 += _611.d1;
    _1340 *= _1307.d2;
    _1340 += _611.d0;
    bool _1341 = _1307.data[_1340];
    rgba _1342;
    if (!_1341)
    goto _jump846;
    _1342 = b;
    goto _jump847;
    _jump846:;
    _1342 = b;
    _jump847:;
    double _1343 = _1342.b;
    return _1343;
}

void_t b(_a1_rgba c, _a1_int64_t e) {
    int64_t _0;
    // Computing bound for h
    int64_t _1 = -c.d0;
    int64_t _2 = 992;
    int64_t _3 = _1 / _2;
    if (_3 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    _0 = 0;
    int64_t _4 = 0; // h
    _jump849:; // Begin body of loop
    _0 += _4;
    _4++;
    if (_4 < _3)
    goto _jump849;
    // End body of loop
    _a2_bool _5;
    // Computing bound for i
    _a2_int64_t _6;
    // Computing bound for i
    int64_t _7;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump850;
    fail_assertion("non-positive loop bound");
    _jump850:;
    // Computing bound for j
    if (_0 > 0) 
    goto _jump851;
    fail_assertion("non-positive loop bound");
    _jump851:;
    _7 = 0;
    int64_t _8 = 0; // j
    int64_t _9 = 0; // i
    _jump852:; // Begin body of loop
    int64_t _10 = 503;
    _7 += _10;
    _8++;
    if (_8 < _0)
    goto _jump852;
    _8 = 0;
    _9++;
    if (_9 < c.d0)
    goto _jump852;
    // End body of loop
    int64_t _11 = _7 % c.d0;
    _6.d0 = _11;
    if (_11 > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing bound for j
    _6.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _11;
    _12 *= e.d0;
    _12 *= sizeof(int64_t);
    _6.data = jpl_alloc(_12);
    int64_t _13 = 0; // j
    int64_t _14 = 0; // i
    _jump855:; // Begin body of loop
    int64_t _15 = c.d0 + e.d0;
    int64_t _16 = 0;
    _16 *= _6.d0;
    _16 += _14;
    _16 *= _6.d1;
    _16 += _13;
    _6.data[_16] = _15;
    _13++;
    if (_13 < e.d0)
    goto _jump855;
    _13 = 0;
    _14++;
    if (_14 < _11)
    goto _jump855;
    // End body of loop
    int64_t _17;
    // Computing bound for i
    if (_0 > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    _17 = 0;
    int64_t _18 = 0; // i
    _jump857:; // Begin body of loop
    _17 += _18;
    _18++;
    if (_18 < _0)
    goto _jump857;
    // End body of loop
    _a1_int64_t _19;
    _19.d0 = 1;
    _19.data = jpl_alloc(sizeof(int64_t) * 1);
    _19.data[0] = _17;
    if (e.d0 >= 0)
    goto _jump858;
    fail_assertion("negative array index");
    _jump858:;
    if (e.d0 < _19.d0)
    goto _jump859;
    fail_assertion("index too large");
    _jump859:;
    int64_t _20 = 0;
    _20 *= _19.d0;
    _20 += e.d0;
    int64_t _21 = _19.data[_20];
    bool _22 = c.d0 <= e.d0;
    bool _23;
    if (!_22)
    goto _jump860;
    double _24 = 67.0;
    double _25 = 17.0;
    bool _26 = _24 >= _25;
    _23 = _26;
    goto _jump861;
    _jump860:;
    int64_t _27 = 572;
    bool _28 = _27 > _0;
    _23 = _28;
    _jump861:;
    int64_t _29;
    if (!_23)
    goto _jump862;
    _29 = c.d0;
    goto _jump863;
    _jump862:;
    int64_t _30;
    // Computing bound for i
    bool _31 = false;
    int64_t _32;
    if (!_31)
    goto _jump864;
    int64_t _33 = 531;
    _32 = _33;
    goto _jump865;
    _jump864:;
    _32 = _0;
    _jump865:;
    if (_32 > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    // Computing bound for j
    int64_t _34 = 527;
    int64_t _35 = _0 % _34;
    if (_35 > 0) 
    goto _jump867;
    fail_assertion("non-positive loop bound");
    _jump867:;
    // Computing bound for k
    if (e.d0 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    _30 = 0;
    int64_t _36 = 0; // k
    int64_t _37 = 0; // j
    int64_t _38 = 0; // i
    _jump869:; // Begin body of loop
    int64_t _39 = _37 % _38;
    _30 += _39;
    _36++;
    if (_36 < e.d0)
    goto _jump869;
    _36 = 0;
    _37++;
    if (_37 < _35)
    goto _jump869;
    _37 = 0;
    _38++;
    if (_38 < _32)
    goto _jump869;
    // End body of loop
    _29 = _30;
    _jump863:;
    if (_21 >= 0)
    goto _jump870;
    fail_assertion("negative array index");
    _jump870:;
    if (_21 < _6.d0)
    goto _jump871;
    fail_assertion("index too large");
    _jump871:;
    if (_29 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_29 < _6.d1)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    int64_t _40 = 0;
    _40 *= _6.d0;
    _40 += _21;
    _40 *= _6.d1;
    _40 += _29;
    int64_t _41 = _6.data[_40];
    _5.d0 = _41;
    if (_41 > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing bound for j
    _a3_int64_t _42;
    // Computing bound for i
    int64_t _43 = 591;
    _42.d0 = _43;
    if (_43 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for j
    int64_t _44;
    // Computing bound for i
    int64_t _45 = 776;
    if (_45 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    _44 = 0;
    int64_t _46 = 0; // i
    _jump877:; // Begin body of loop
    _44 += c.d0;
    _46++;
    if (_46 < _45)
    goto _jump877;
    // End body of loop
    _42.d1 = _44;
    if (_44 > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing bound for k
    int64_t _47 = 419;
    int64_t _48 = -_47;
    _42.d2 = _48;
    if (_48 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= _43;
    _49 *= _44;
    _49 *= _48;
    _49 *= sizeof(int64_t);
    _42.data = jpl_alloc(_49);
    int64_t _50 = 0; // k
    int64_t _51 = 0; // j
    int64_t _52 = 0; // i
    _jump880:; // Begin body of loop
    int64_t _53 = 0;
    _53 *= _42.d0;
    _53 += _52;
    _53 *= _42.d1;
    _53 += _51;
    _53 *= _42.d2;
    _53 += _50;
    _42.data[_53] = e.d0;
    _50++;
    if (_50 < _48)
    goto _jump880;
    _50 = 0;
    _51++;
    if (_51 < _44)
    goto _jump880;
    _51 = 0;
    _52++;
    if (_52 < _43)
    goto _jump880;
    // End body of loop
    _a2_int64_t _54;
    // Computing bound for i
    int64_t _55 = 926;
    _54.d0 = _55;
    if (_55 > 0) 
    goto _jump881;
    fail_assertion("non-positive loop bound");
    _jump881:;
    // Computing bound for j
    _54.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump882;
    fail_assertion("non-positive loop bound");
    _jump882:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= _55;
    _56 *= e.d0;
    _56 *= sizeof(int64_t);
    _54.data = jpl_alloc(_56);
    int64_t _57 = 0; // j
    int64_t _58 = 0; // i
    _jump883:; // Begin body of loop
    int64_t _59 = 160;
    int64_t _60 = 0;
    _60 *= _54.d0;
    _60 += _58;
    _60 *= _54.d1;
    _60 += _57;
    _54.data[_60] = _59;
    _57++;
    if (_57 < e.d0)
    goto _jump883;
    _57 = 0;
    _58++;
    if (_58 < _55)
    goto _jump883;
    // End body of loop
    int64_t _61 = 877;
    if (e.d0 >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (e.d0 < _54.d0)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    if (_61 >= 0)
    goto _jump886;
    fail_assertion("negative array index");
    _jump886:;
    if (_61 < _54.d1)
    goto _jump887;
    fail_assertion("index too large");
    _jump887:;
    int64_t _62 = 0;
    _62 *= _54.d0;
    _62 += e.d0;
    _62 *= _54.d1;
    _62 += _61;
    int64_t _63 = _54.data[_62];
    int64_t _64;
    // Computing bound for i
    int64_t _65 = _0 + c.d0;
    if (_65 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    // Computing bound for j
    int64_t _66 = -_0;
    if (_66 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing bound for k
    int64_t _67 = -c.d0;
    if (_67 > 0) 
    goto _jump890;
    fail_assertion("non-positive loop bound");
    _jump890:;
    _64 = 0;
    int64_t _68 = 0; // k
    int64_t _69 = 0; // j
    int64_t _70 = 0; // i
    _jump891:; // Begin body of loop
    int64_t _71;
    // Computing bound for l
    if (_70 > 0) 
    goto _jump892;
    fail_assertion("non-positive loop bound");
    _jump892:;
    _71 = 0;
    int64_t _72 = 0; // l
    _jump893:; // Begin body of loop
    int64_t _73 = 629;
    _71 += _73;
    _72++;
    if (_72 < _70)
    goto _jump893;
    // End body of loop
    _64 += _71;
    _68++;
    if (_68 < _67)
    goto _jump891;
    _68 = 0;
    _69++;
    if (_69 < _66)
    goto _jump891;
    _69 = 0;
    _70++;
    if (_70 < _65)
    goto _jump891;
    // End body of loop
    if (_63 >= 0)
    goto _jump894;
    fail_assertion("negative array index");
    _jump894:;
    if (_63 < _42.d0)
    goto _jump895;
    fail_assertion("index too large");
    _jump895:;
    if (_64 >= 0)
    goto _jump896;
    fail_assertion("negative array index");
    _jump896:;
    if (_64 < _42.d1)
    goto _jump897;
    fail_assertion("index too large");
    _jump897:;
    if (e.d0 >= 0)
    goto _jump898;
    fail_assertion("negative array index");
    _jump898:;
    if (e.d0 < _42.d2)
    goto _jump899;
    fail_assertion("index too large");
    _jump899:;
    int64_t _74 = 0;
    _74 *= _42.d0;
    _74 += _63;
    _74 *= _42.d1;
    _74 += _64;
    _74 *= _42.d2;
    _74 += e.d0;
    int64_t _75 = _42.data[_74];
    int64_t _76 = 604;
    bool _77 = _76 == _0;
    bool _78 = true;
    bool _79 = _77 != _78;
    int64_t _80;
    if (!_79)
    goto _jump900;
    _80 = _0;
    goto _jump901;
    _jump900:;
    bool _81 = false;
    bool _82 = !_81;
    int64_t _83;
    if (!_82)
    goto _jump902;
    int64_t _84 = -e.d0;
    _83 = _84;
    goto _jump903;
    _jump902:;
    _83 = e.d0;
    _jump903:;
    _80 = _83;
    _jump901:;
    int64_t _85 = _75 % _80;
    _5.d1 = _85;
    if (_85 > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= _41;
    _86 *= _85;
    _86 *= sizeof(bool);
    _5.data = jpl_alloc(_86);
    int64_t _87 = 0; // j
    int64_t _88 = 0; // i
    _jump905:; // Begin body of loop
    bool _89 = _0 == _88;
    int64_t _90 = 0;
    _90 *= _5.d0;
    _90 += _88;
    _90 *= _5.d1;
    _90 += _87;
    _5.data[_90] = _89;
    _87++;
    if (_87 < _85)
    goto _jump905;
    _87 = 0;
    _88++;
    if (_88 < _41)
    goto _jump905;
    // End body of loop
    if (c.d0 >= 0)
    goto _jump906;
    fail_assertion("negative array index");
    _jump906:;
    if (c.d0 < _5.d0)
    goto _jump907;
    fail_assertion("index too large");
    _jump907:;
    if (c.d0 >= 0)
    goto _jump908;
    fail_assertion("negative array index");
    _jump908:;
    if (c.d0 < _5.d1)
    goto _jump909;
    fail_assertion("index too large");
    _jump909:;
    int64_t _91 = 0;
    _91 *= _5.d0;
    _91 += c.d0;
    _91 *= _5.d1;
    _91 += c.d0;
    bool _92 = _5.data[_91];
    void_t _93;
    if (!_92)
    goto _jump910;
    int64_t _96 = c.d0 + _0;
    int64_t _97 = 435;
    bool _98 = _96 < _97;
    bool _95 = _98;
    if (0 != _98)
    goto _jump911;
    int64_t _99;
    // Computing bound for i
    int64_t _100 = 600;
    if (_100 > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    // Computing bound for j
    int64_t _101 = 717;
    if (_101 > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    _99 = 0;
    int64_t _102 = 0; // j
    int64_t _103 = 0; // i
    _jump914:; // Begin body of loop
    _99 += _103;
    _102++;
    if (_102 < _101)
    goto _jump914;
    _102 = 0;
    _103++;
    if (_103 < _100)
    goto _jump914;
    // End body of loop
    int64_t _104;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing bound for j
    if (e.d0 > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    _104 = 0;
    int64_t _105 = 0; // j
    int64_t _106 = 0; // i
    _jump917:; // Begin body of loop
    _104 += _105;
    _105++;
    if (_105 < e.d0)
    goto _jump917;
    _105 = 0;
    _106++;
    if (_106 < c.d0)
    goto _jump917;
    // End body of loop
    bool _107 = _99 < _104;
    _95 = _107;
    _jump911:;
    bool _94 = _95;
    if (0 != _95)
    goto _jump918;
    _a1_bool _108;
    // Computing bound for i
    _108.d0 = _0;
    if (_0 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= _0;
    _109 *= sizeof(bool);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // i
    _jump920:; // Begin body of loop
    bool _111 = true;
    int64_t _112 = 0;
    _112 *= _108.d0;
    _112 += _110;
    _108.data[_112] = _111;
    _110++;
    if (_110 < _0)
    goto _jump920;
    // End body of loop
    if (_0 >= 0)
    goto _jump921;
    fail_assertion("negative array index");
    _jump921:;
    if (_0 < _108.d0)
    goto _jump922;
    fail_assertion("index too large");
    _jump922:;
    int64_t _113 = 0;
    _113 *= _108.d0;
    _113 += _0;
    bool _114 = _108.data[_113];
    _94 = _114;
    _jump918:;
    _a1_void_t _115;
    if (!_94)
    goto _jump923;
    _a1_void_t _116;
    // Computing bound for i
    _116.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump924;
    fail_assertion("non-positive loop bound");
    _jump924:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= c.d0;
    _117 *= sizeof(void_t);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // i
    _jump925:; // Begin body of loop
    double _119 = 71.0;
    double _120 = 57.0;
    bool _121 = _119 >= _120;
    _a1_rgba _122;
    if (!_121)
    goto _jump926;
    _122 = c;
    goto _jump927;
    _jump926:;
    _122 = c;
    _jump927:;
    _a1_int64_t _123;
    // Computing bound for j
    _123.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump928;
    fail_assertion("non-positive loop bound");
    _jump928:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= c.d0;
    _124 *= sizeof(int64_t);
    _123.data = jpl_alloc(_124);
    int64_t _125 = 0; // j
    _jump929:; // Begin body of loop
    int64_t _126 = _0 + c.d0;
    int64_t _127 = 0;
    _127 *= _123.d0;
    _127 += _125;
    _123.data[_127] = _126;
    _125++;
    if (_125 < c.d0)
    goto _jump929;
    // End body of loop
    void_t _128 = b(_122, _123);
    int64_t _129 = 0;
    _129 *= _116.d0;
    _129 += _118;
    _116.data[_129] = _128;
    _118++;
    if (_118 < c.d0)
    goto _jump925;
    // End body of loop
    _115 = _116;
    goto _jump930;
    _jump923:;
    _a1_void_t _130;
    // Computing bound for i
    int64_t _131;
    // Computing bound for i
    if (_0 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for j
    int64_t _132 = -e.d0;
    int64_t _133 = -c.d0;
    int64_t _134 = _132 % _133;
    if (_134 > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    _131 = 0;
    int64_t _135 = 0; // j
    int64_t _136 = 0; // i
    _jump933:; // Begin body of loop
    _131 += _135;
    _135++;
    if (_135 < _134)
    goto _jump933;
    _135 = 0;
    _136++;
    if (_136 < _0)
    goto _jump933;
    // End body of loop
    _130.d0 = _131;
    if (_131 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing total size of heap memory to allocate
    int64_t _137 = 1;
    _137 *= _131;
    _137 *= sizeof(void_t);
    _130.data = jpl_alloc(_137);
    int64_t _138 = 0; // i
    _jump935:; // Begin body of loop
    bool _139 = true;
    bool _140 = !_139;
    _a1_int64_t _141;
    if (!_140)
    goto _jump936;
    _a1_int64_t _142;
    _142.d0 = 1;
    _142.data = jpl_alloc(sizeof(int64_t) * 1);
    _142.data[0] = c.d0;
    _141 = _142;
    goto _jump937;
    _jump936:;
    int64_t _143 = 500;
    _a1_int64_t _144;
    _144.d0 = 2;
    _144.data = jpl_alloc(sizeof(int64_t) * 2);
    _144.data[0] = _138;
    _144.data[1] = _143;
    _141 = _144;
    _jump937:;
    void_t _145 = b(c, _141);
    int64_t _146 = 0;
    _146 *= _130.d0;
    _146 += _138;
    _130.data[_146] = _145;
    _138++;
    if (_138 < _131)
    goto _jump935;
    // End body of loop
    _115 = _130;
    _jump930:;
    int64_t _147 = 550;
    if (_147 >= 0)
    goto _jump938;
    fail_assertion("negative array index");
    _jump938:;
    if (_147 < _115.d0)
    goto _jump939;
    fail_assertion("index too large");
    _jump939:;
    int64_t _148 = 0;
    _148 *= _115.d0;
    _148 += _147;
    void_t _149 = _115.data[_148];
    _93 = _149;
    goto _jump940;
    _jump910:;
    bool _152 = true;
    bool _151 = _152;
    if (0 == _152)
    goto _jump941;
    bool _153 = e.d0 != c.d0;
    _151 = _153;
    _jump941:;
    bool _150 = _151;
    if (0 != _151)
    goto _jump942;
    bool _154 = true;
    int64_t _155;
    if (!_154)
    goto _jump943;
    int64_t _156 = 254;
    _155 = _156;
    goto _jump944;
    _jump943:;
    int64_t _157 = 500;
    _155 = _157;
    _jump944:;
    bool _158 = _155 == c.d0;
    _150 = _158;
    _jump942:;
    _a3__a1_rgba _159;
    if (!_150)
    goto _jump945;
    _a3__a1_rgba _160;
    // Computing bound for i
    int64_t _161 = 578;
    _160.d0 = _161;
    if (_161 > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    // Computing bound for j
    _160.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for k
    _160.d2 = e.d0;
    if (e.d0 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing total size of heap memory to allocate
    int64_t _162 = 1;
    _162 *= _161;
    _162 *= e.d0;
    _162 *= e.d0;
    _162 *= sizeof(_a1_rgba);
    _160.data = jpl_alloc(_162);
    int64_t _163 = 0; // k
    int64_t _164 = 0; // j
    int64_t _165 = 0; // i
    _jump949:; // Begin body of loop
    _a2__a1_rgba _166;
    // Computing bound for l
    _166.d0 = _0;
    if (_0 > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing bound for m
    _166.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump951;
    fail_assertion("non-positive loop bound");
    _jump951:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= _0;
    _167 *= e.d0;
    _167 *= sizeof(_a1_rgba);
    _166.data = jpl_alloc(_167);
    int64_t _168 = 0; // m
    int64_t _169 = 0; // l
    _jump952:; // Begin body of loop
    int64_t _170 = 0;
    _170 *= _166.d0;
    _170 += _169;
    _170 *= _166.d1;
    _170 += _168;
    _166.data[_170] = c;
    _168++;
    if (_168 < e.d0)
    goto _jump952;
    _168 = 0;
    _169++;
    if (_169 < _0)
    goto _jump952;
    // End body of loop
    if (_163 >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (_163 < _166.d0)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    if (_163 >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (_163 < _166.d1)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    int64_t _171 = 0;
    _171 *= _166.d0;
    _171 += _163;
    _171 *= _166.d1;
    _171 += _163;
    _a1_rgba _172 = _166.data[_171];
    int64_t _173 = 0;
    _173 *= _160.d0;
    _173 += _165;
    _173 *= _160.d1;
    _173 += _164;
    _173 *= _160.d2;
    _173 += _163;
    _160.data[_173] = _172;
    _163++;
    if (_163 < e.d0)
    goto _jump949;
    _163 = 0;
    _164++;
    if (_164 < e.d0)
    goto _jump949;
    _164 = 0;
    _165++;
    if (_165 < _161)
    goto _jump949;
    // End body of loop
    _159 = _160;
    goto _jump957;
    _jump945:;
    _a3__a1_rgba _174;
    // Computing bound for i
    int64_t _175 = 840;
    int64_t _176 = _0 + _175;
    int64_t _177;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing bound for k
    int64_t _178 = 303;
    if (_178 > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    _177 = 0;
    int64_t _179 = 0; // k
    int64_t _180 = 0; // j
    int64_t _181 = 0; // i
    _jump961:; // Begin body of loop
    _177 += c.d0;
    _179++;
    if (_179 < _178)
    goto _jump961;
    _179 = 0;
    _180++;
    if (_180 < c.d0)
    goto _jump961;
    _180 = 0;
    _181++;
    if (_181 < c.d0)
    goto _jump961;
    // End body of loop
    int64_t _182 = _176 + _177;
    _174.d0 = _182;
    if (_182 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing bound for j
    int64_t _183;
    // Computing bound for i
    int64_t _184 = -e.d0;
    if (_184 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    _183 = 0;
    int64_t _185 = 0; // i
    _jump964:; // Begin body of loop
    int64_t _186 = -c.d0;
    _183 += _186;
    _185++;
    if (_185 < _184)
    goto _jump964;
    // End body of loop
    _174.d1 = _183;
    if (_183 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing bound for k
    _174.d2 = _0;
    if (_0 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= _182;
    _187 *= _183;
    _187 *= _0;
    _187 *= sizeof(_a1_rgba);
    _174.data = jpl_alloc(_187);
    int64_t _188 = 0; // k
    int64_t _189 = 0; // j
    int64_t _190 = 0; // i
    _jump967:; // Begin body of loop
    int64_t _191 = 0;
    _191 *= _174.d0;
    _191 += _190;
    _191 *= _174.d1;
    _191 += _189;
    _191 *= _174.d2;
    _191 += _188;
    _174.data[_191] = c;
    _188++;
    if (_188 < _0)
    goto _jump967;
    _188 = 0;
    _189++;
    if (_189 < _183)
    goto _jump967;
    _189 = 0;
    _190++;
    if (_190 < _182)
    goto _jump967;
    // End body of loop
    _159 = _174;
    _jump957:;
    int64_t _192 = -e.d0;
    if (_0 >= 0)
    goto _jump968;
    fail_assertion("negative array index");
    _jump968:;
    if (_0 < _159.d0)
    goto _jump969;
    fail_assertion("index too large");
    _jump969:;
    if (_0 >= 0)
    goto _jump970;
    fail_assertion("negative array index");
    _jump970:;
    if (_0 < _159.d1)
    goto _jump971;
    fail_assertion("index too large");
    _jump971:;
    if (_192 >= 0)
    goto _jump972;
    fail_assertion("negative array index");
    _jump972:;
    if (_192 < _159.d2)
    goto _jump973;
    fail_assertion("index too large");
    _jump973:;
    int64_t _193 = 0;
    _193 *= _159.d0;
    _193 += _0;
    _193 *= _159.d1;
    _193 += _0;
    _193 *= _159.d2;
    _193 += _192;
    _a1_rgba _194 = _159.data[_193];
    void_t _195 = b(_194, e);
    _93 = _195;
    _jump940:;
    return _93;
    bool _197 = false;
    bool _196 = _197;
    if (0 != _197)
    goto _jump974;
    bool _198 = true;
    _196 = _198;
    _jump974:;
    bool _199 = !_196;
    bool _200;
    if (!_199)
    goto _jump975;
    bool _202 = false;
    int64_t _203;
    if (!_202)
    goto _jump976;
    _203 = _0;
    goto _jump977;
    _jump976:;
    int64_t _204 = 875;
    _203 = _204;
    _jump977:;
    bool _205 = e.d0 == _203;
    bool _206 = !_205;
    bool _207 = !_206;
    bool _201 = _207;
    if (0 == _207)
    goto _jump978;
    bool _208 = false;
    int64_t _209;
    if (!_208)
    goto _jump979;
    int64_t _210;
    // Computing bound for i
    int64_t _211 = 102;
    if (_211 > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    _210 = 0;
    int64_t _212 = 0; // i
    _jump981:; // Begin body of loop
    _210 += _0;
    _212++;
    if (_212 < _211)
    goto _jump981;
    // End body of loop
    _209 = _210;
    goto _jump982;
    _jump979:;
    _209 = e.d0;
    _jump982:;
    int64_t _213;
    // Computing bound for i
    int64_t _214 = c.d0 - e.d0;
    if (_214 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for j
    if (e.d0 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    _213 = 0;
    int64_t _215 = 0; // j
    int64_t _216 = 0; // i
    _jump985:; // Begin body of loop
    int64_t _217 = 799;
    int64_t _218 = _0 + _217;
    int64_t _219 = -_218;
    _213 += _219;
    _215++;
    if (_215 < e.d0)
    goto _jump985;
    _215 = 0;
    _216++;
    if (_216 < _214)
    goto _jump985;
    // End body of loop
    bool _220 = _209 > _213;
    _201 = _220;
    _jump978:;
    _200 = _201;
    goto _jump986;
    _jump975:;
    bool _222 = true;
    bool _223 = !_222;
    _a1_bool _224;
    _224.d0 = 1;
    _224.data = jpl_alloc(sizeof(bool) * 1);
    _224.data[0] = _223;
    _a3_int64_t _225;
    // Computing bound for i
    _225.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing bound for j
    _225.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing bound for k
    _225.d2 = e.d0;
    if (e.d0 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing total size of heap memory to allocate
    int64_t _226 = 1;
    _226 *= e.d0;
    _226 *= c.d0;
    _226 *= e.d0;
    _226 *= sizeof(int64_t);
    _225.data = jpl_alloc(_226);
    int64_t _227 = 0; // k
    int64_t _228 = 0; // j
    int64_t _229 = 0; // i
    _jump990:; // Begin body of loop
    int64_t _230 = 0;
    _230 *= _225.d0;
    _230 += _229;
    _230 *= _225.d1;
    _230 += _228;
    _230 *= _225.d2;
    _230 += _227;
    _225.data[_230] = c.d0;
    _227++;
    if (_227 < e.d0)
    goto _jump990;
    _227 = 0;
    _228++;
    if (_228 < c.d0)
    goto _jump990;
    _228 = 0;
    _229++;
    if (_229 < e.d0)
    goto _jump990;
    // End body of loop
    int64_t _231 = _0 - c.d0;
    if (_231 >= 0)
    goto _jump991;
    fail_assertion("negative array index");
    _jump991:;
    if (_231 < _225.d0)
    goto _jump992;
    fail_assertion("index too large");
    _jump992:;
    if (_0 >= 0)
    goto _jump993;
    fail_assertion("negative array index");
    _jump993:;
    if (_0 < _225.d1)
    goto _jump994;
    fail_assertion("index too large");
    _jump994:;
    if (_0 >= 0)
    goto _jump995;
    fail_assertion("negative array index");
    _jump995:;
    if (_0 < _225.d2)
    goto _jump996;
    fail_assertion("index too large");
    _jump996:;
    int64_t _232 = 0;
    _232 *= _225.d0;
    _232 += _231;
    _232 *= _225.d1;
    _232 += _0;
    _232 *= _225.d2;
    _232 += _0;
    int64_t _233 = _225.data[_232];
    if (_233 >= 0)
    goto _jump997;
    fail_assertion("negative array index");
    _jump997:;
    if (_233 < _224.d0)
    goto _jump998;
    fail_assertion("index too large");
    _jump998:;
    int64_t _234 = 0;
    _234 *= _224.d0;
    _234 += _233;
    bool _235 = _224.data[_234];
    bool _236 = false;
    bool _237 = _235 != _236;
    bool _221 = _237;
    if (0 != _237)
    goto _jump999;
    _a1_int64_t _238;
    // Computing bound for i
    _238.d0 = _0;
    if (_0 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing total size of heap memory to allocate
    int64_t _239 = 1;
    _239 *= _0;
    _239 *= sizeof(int64_t);
    _238.data = jpl_alloc(_239);
    int64_t _240 = 0; // i
    _jump1001:; // Begin body of loop
    int64_t _241 = 0;
    _241 *= _238.d0;
    _241 += _240;
    _238.data[_241] = _0;
    _240++;
    if (_240 < _0)
    goto _jump1001;
    // End body of loop
    if (c.d0 >= 0)
    goto _jump1002;
    fail_assertion("negative array index");
    _jump1002:;
    if (c.d0 < _238.d0)
    goto _jump1003;
    fail_assertion("index too large");
    _jump1003:;
    int64_t _242 = 0;
    _242 *= _238.d0;
    _242 += c.d0;
    int64_t _243 = _238.data[_242];
    int64_t _244 = 35;
    bool _245 = _243 <= _244;
    bool _246 = !_245;
    _221 = _246;
    _jump999:;
    _200 = _221;
    _jump986:;
    double _247;
    if (!_200)
    goto _jump1004;
    _a3_rgba _248;
    // Computing bound for i
    _248.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing bound for j
    bool _249 = true;
    bool _250 = !_249;
    bool _251 = !_250;
    int64_t _252;
    if (!_251)
    goto _jump1006;
    int64_t _253 = _0 / e.d0;
    _252 = _253;
    goto _jump1007;
    _jump1006:;
    _252 = c.d0;
    _jump1007:;
    _248.d1 = _252;
    if (_252 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for k
    bool _254 = false;
    _a1_int64_t _255;
    if (!_254)
    goto _jump1009;
    _a1_int64_t _256;
    // Computing bound for i
    _256.d0 = _0;
    if (_0 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing total size of heap memory to allocate
    int64_t _257 = 1;
    _257 *= _0;
    _257 *= sizeof(int64_t);
    _256.data = jpl_alloc(_257);
    int64_t _258 = 0; // i
    _jump1011:; // Begin body of loop
    int64_t _259 = 0;
    _259 *= _256.d0;
    _259 += _258;
    _256.data[_259] = _258;
    _258++;
    if (_258 < _0)
    goto _jump1011;
    // End body of loop
    _255 = _256;
    goto _jump1012;
    _jump1009:;
    int64_t _260 = 463;
    _a1_int64_t _261;
    _261.d0 = 3;
    _261.data = jpl_alloc(sizeof(int64_t) * 3);
    _261.data[0] = _260;
    _261.data[1] = _0;
    _261.data[2] = _0;
    _255 = _261;
    _jump1012:;
    if (e.d0 >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (e.d0 < _255.d0)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    int64_t _262 = 0;
    _262 *= _255.d0;
    _262 += e.d0;
    int64_t _263 = _255.data[_262];
    _248.d2 = _263;
    if (_263 > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= e.d0;
    _264 *= _252;
    _264 *= _263;
    _264 *= sizeof(rgba);
    _248.data = jpl_alloc(_264);
    int64_t _265 = 0; // k
    int64_t _266 = 0; // j
    int64_t _267 = 0; // i
    _jump1016:; // Begin body of loop
    double _268;
    // Computing bound for l
    if (_267 > 0) 
    goto _jump1017;
    fail_assertion("non-positive loop bound");
    _jump1017:;
    // Computing bound for m
    if (_0 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    _268 = 0;
    int64_t _269 = 0; // m
    int64_t _270 = 0; // l
    _jump1019:; // Begin body of loop
    double _271 = 93.0;
    double _272 = -_271;
    _268 += _272;
    _269++;
    if (_269 < _0)
    goto _jump1019;
    _269 = 0;
    _270++;
    if (_270 < _267)
    goto _jump1019;
    // End body of loop
    int64_t _273 = 20;
    if (_273 >= 0)
    goto _jump1020;
    fail_assertion("negative array index");
    _jump1020:;
    if (_273 < c.d0)
    goto _jump1021;
    fail_assertion("index too large");
    _jump1021:;
    int64_t _274 = 0;
    _274 *= c.d0;
    _274 += _273;
    rgba _275 = c.data[_274];
    double _276 = _275.a;
    double _277 = 28.0;
    _a3_double _278;
    // Computing bound for l
    _278.d0 = _266;
    if (_266 > 0) 
    goto _jump1022;
    fail_assertion("non-positive loop bound");
    _jump1022:;
    // Computing bound for m
    _278.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing bound for n
    _278.d2 = _267;
    if (_267 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing total size of heap memory to allocate
    int64_t _279 = 1;
    _279 *= _266;
    _279 *= c.d0;
    _279 *= _267;
    _279 *= sizeof(double);
    _278.data = jpl_alloc(_279);
    int64_t _280 = 0; // n
    int64_t _281 = 0; // m
    int64_t _282 = 0; // l
    _jump1025:; // Begin body of loop
    double _283 = 54.0;
    int64_t _284 = 0;
    _284 *= _278.d0;
    _284 += _282;
    _284 *= _278.d1;
    _284 += _281;
    _284 *= _278.d2;
    _284 += _280;
    _278.data[_284] = _283;
    _280++;
    if (_280 < _267)
    goto _jump1025;
    _280 = 0;
    _281++;
    if (_281 < c.d0)
    goto _jump1025;
    _281 = 0;
    _282++;
    if (_282 < _266)
    goto _jump1025;
    // End body of loop
    if (_0 >= 0)
    goto _jump1026;
    fail_assertion("negative array index");
    _jump1026:;
    if (_0 < _278.d0)
    goto _jump1027;
    fail_assertion("index too large");
    _jump1027:;
    if (e.d0 >= 0)
    goto _jump1028;
    fail_assertion("negative array index");
    _jump1028:;
    if (e.d0 < _278.d1)
    goto _jump1029;
    fail_assertion("index too large");
    _jump1029:;
    if (c.d0 >= 0)
    goto _jump1030;
    fail_assertion("negative array index");
    _jump1030:;
    if (c.d0 < _278.d2)
    goto _jump1031;
    fail_assertion("index too large");
    _jump1031:;
    int64_t _285 = 0;
    _285 *= _278.d0;
    _285 += _0;
    _285 *= _278.d1;
    _285 += e.d0;
    _285 *= _278.d2;
    _285 += c.d0;
    double _286 = _278.data[_285];
    rgba _287 = { _268, _276, _277, _286 };
    int64_t _288 = 0;
    _288 *= _248.d0;
    _288 += _267;
    _288 *= _248.d1;
    _288 += _266;
    _288 *= _248.d2;
    _288 += _265;
    _248.data[_288] = _287;
    _265++;
    if (_265 < _263)
    goto _jump1016;
    _265 = 0;
    _266++;
    if (_266 < _252)
    goto _jump1016;
    _266 = 0;
    _267++;
    if (_267 < e.d0)
    goto _jump1016;
    // End body of loop
    int64_t _289;
    // Computing bound for i
    if (e.d0 > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    _289 = 0;
    int64_t _290 = 0; // i
    _jump1033:; // Begin body of loop
    _a2_int64_t _291;
    // Computing bound for j
    int64_t _292 = -c.d0;
    _291.d0 = _292;
    if (_292 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing bound for k
    _291.d1 = _290;
    if (_290 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    // Computing total size of heap memory to allocate
    int64_t _293 = 1;
    _293 *= _292;
    _293 *= _290;
    _293 *= sizeof(int64_t);
    _291.data = jpl_alloc(_293);
    int64_t _294 = 0; // k
    int64_t _295 = 0; // j
    _jump1036:; // Begin body of loop
    int64_t _296 = 0;
    _296 *= _291.d0;
    _296 += _295;
    _296 *= _291.d1;
    _296 += _294;
    _291.data[_296] = c.d0;
    _294++;
    if (_294 < _290)
    goto _jump1036;
    _294 = 0;
    _295++;
    if (_295 < _292)
    goto _jump1036;
    // End body of loop
    bool _297 = false;
    int64_t _298;
    if (!_297)
    goto _jump1037;
    int64_t _299 = 173;
    int64_t _300 = -_299;
    _298 = _300;
    goto _jump1038;
    _jump1037:;
    int64_t _301;
    // Computing bound for j
    if (e.d0 > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    _301 = 0;
    int64_t _302 = 0; // k
    int64_t _303 = 0; // j
    _jump1041:; // Begin body of loop
    _301 += c.d0;
    _302++;
    if (_302 < c.d0)
    goto _jump1041;
    _302 = 0;
    _303++;
    if (_303 < e.d0)
    goto _jump1041;
    // End body of loop
    _298 = _301;
    _jump1038:;
    int64_t _304;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump1042;
    fail_assertion("non-positive loop bound");
    _jump1042:;
    // Computing bound for k
    int64_t _305 = 513;
    int64_t _306 = -_305;
    if (_306 > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    _304 = 0;
    int64_t _307 = 0; // k
    int64_t _308 = 0; // j
    _jump1044:; // Begin body of loop
    int64_t _309 = _308 % _307;
    _304 += _309;
    _307++;
    if (_307 < _306)
    goto _jump1044;
    _307 = 0;
    _308++;
    if (_308 < c.d0)
    goto _jump1044;
    // End body of loop
    if (_298 >= 0)
    goto _jump1045;
    fail_assertion("negative array index");
    _jump1045:;
    if (_298 < _291.d0)
    goto _jump1046;
    fail_assertion("index too large");
    _jump1046:;
    if (_304 >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (_304 < _291.d1)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    int64_t _310 = 0;
    _310 *= _291.d0;
    _310 += _298;
    _310 *= _291.d1;
    _310 += _304;
    int64_t _311 = _291.data[_310];
    _289 += _311;
    _290++;
    if (_290 < e.d0)
    goto _jump1033;
    // End body of loop
    int64_t _312;
    // Computing bound for i
    int64_t _313 = 226;
    if (_313 > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing bound for j
    _a2_int64_t _314;
    // Computing bound for i
    int64_t _315 = -_0;
    _314.d0 = _315;
    if (_315 > 0) 
    goto _jump1050;
    fail_assertion("non-positive loop bound");
    _jump1050:;
    // Computing bound for j
    int64_t _316 = 676;
    int64_t _317 = -_316;
    _314.d1 = _317;
    if (_317 > 0) 
    goto _jump1051;
    fail_assertion("non-positive loop bound");
    _jump1051:;
    // Computing total size of heap memory to allocate
    int64_t _318 = 1;
    _318 *= _315;
    _318 *= _317;
    _318 *= sizeof(int64_t);
    _314.data = jpl_alloc(_318);
    int64_t _319 = 0; // j
    int64_t _320 = 0; // i
    _jump1052:; // Begin body of loop
    int64_t _321 = 0;
    _321 *= _314.d0;
    _321 += _320;
    _321 *= _314.d1;
    _321 += _319;
    _314.data[_321] = _319;
    _319++;
    if (_319 < _317)
    goto _jump1052;
    _319 = 0;
    _320++;
    if (_320 < _315)
    goto _jump1052;
    // End body of loop
    int64_t _322 = 275;
    int64_t _323 = 681;
    if (_322 >= 0)
    goto _jump1053;
    fail_assertion("negative array index");
    _jump1053:;
    if (_322 < _314.d0)
    goto _jump1054;
    fail_assertion("index too large");
    _jump1054:;
    if (_323 >= 0)
    goto _jump1055;
    fail_assertion("negative array index");
    _jump1055:;
    if (_323 < _314.d1)
    goto _jump1056;
    fail_assertion("index too large");
    _jump1056:;
    int64_t _324 = 0;
    _324 *= _314.d0;
    _324 += _322;
    _324 *= _314.d1;
    _324 += _323;
    int64_t _325 = _314.data[_324];
    if (_325 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing bound for k
    int64_t _326 = -_0;
    if (_326 > 0) 
    goto _jump1058;
    fail_assertion("non-positive loop bound");
    _jump1058:;
    _312 = 0;
    int64_t _327 = 0; // k
    int64_t _328 = 0; // j
    int64_t _329 = 0; // i
    _jump1059:; // Begin body of loop
    _312 += _327;
    _327++;
    if (_327 < _326)
    goto _jump1059;
    _327 = 0;
    _328++;
    if (_328 < _325)
    goto _jump1059;
    _328 = 0;
    _329++;
    if (_329 < _313)
    goto _jump1059;
    // End body of loop
    if (_289 >= 0)
    goto _jump1060;
    fail_assertion("negative array index");
    _jump1060:;
    if (_289 < _248.d0)
    goto _jump1061;
    fail_assertion("index too large");
    _jump1061:;
    if (_312 >= 0)
    goto _jump1062;
    fail_assertion("negative array index");
    _jump1062:;
    if (_312 < _248.d1)
    goto _jump1063;
    fail_assertion("index too large");
    _jump1063:;
    if (e.d0 >= 0)
    goto _jump1064;
    fail_assertion("negative array index");
    _jump1064:;
    if (e.d0 < _248.d2)
    goto _jump1065;
    fail_assertion("index too large");
    _jump1065:;
    int64_t _330 = 0;
    _330 *= _248.d0;
    _330 += _289;
    _330 *= _248.d1;
    _330 += _312;
    _330 *= _248.d2;
    _330 += e.d0;
    rgba _331 = _248.data[_330];
    double _332 = _331.r;
    _247 = _332;
    goto _jump1066;
    _jump1004:;
    if (_0 >= 0)
    goto _jump1067;
    fail_assertion("negative array index");
    _jump1067:;
    if (_0 < c.d0)
    goto _jump1068;
    fail_assertion("index too large");
    _jump1068:;
    int64_t _333 = 0;
    _333 *= c.d0;
    _333 += _0;
    rgba _334 = c.data[_333];
    double _335 = _334.a;
    double _336 = -_335;
    _a2_double _337;
    // Computing bound for i
    _337.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing bound for j
    int64_t _338 = 789;
    _337.d1 = _338;
    if (_338 > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing total size of heap memory to allocate
    int64_t _339 = 1;
    _339 *= c.d0;
    _339 *= _338;
    _339 *= sizeof(double);
    _337.data = jpl_alloc(_339);
    int64_t _340 = 0; // j
    int64_t _341 = 0; // i
    _jump1071:; // Begin body of loop
    double _342 = 33.0;
    int64_t _343 = 0;
    _343 *= _337.d0;
    _343 += _341;
    _343 *= _337.d1;
    _343 += _340;
    _337.data[_343] = _342;
    _340++;
    if (_340 < _338)
    goto _jump1071;
    _340 = 0;
    _341++;
    if (_341 < c.d0)
    goto _jump1071;
    // End body of loop
    int64_t _344 = 347;
    int64_t _345 = 532;
    if (_344 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (_344 < _337.d0)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    if (_345 >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (_345 < _337.d1)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    int64_t _346 = 0;
    _346 *= _337.d0;
    _346 += _344;
    _346 *= _337.d1;
    _346 += _345;
    double _347 = _337.data[_346];
    double _348 = 21.0;
    double _349 = -_348;
    double _350 = _347 - _349;
    double _351 = _336 + _350;
    bool _352 = true;
    bool _353 = !_352;
    double _354;
    if (!_353)
    goto _jump1076;
    double _355;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    // Computing bound for j
    bool _356 = true;
    int64_t _357;
    if (!_356)
    goto _jump1078;
    _357 = e.d0;
    goto _jump1079;
    _jump1078:;
    _357 = c.d0;
    _jump1079:;
    if (_357 > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump1081;
    fail_assertion("non-positive loop bound");
    _jump1081:;
    _355 = 0;
    int64_t _358 = 0; // k
    int64_t _359 = 0; // j
    int64_t _360 = 0; // i
    _jump1082:; // Begin body of loop
    double _361 = 27.0;
    _355 += _361;
    _358++;
    if (_358 < c.d0)
    goto _jump1082;
    _358 = 0;
    _359++;
    if (_359 < _357)
    goto _jump1082;
    _359 = 0;
    _360++;
    if (_360 < c.d0)
    goto _jump1082;
    // End body of loop
    _354 = _355;
    goto _jump1083;
    _jump1076:;
    if (c.d0 >= 0)
    goto _jump1084;
    fail_assertion("negative array index");
    _jump1084:;
    if (c.d0 < c.d0)
    goto _jump1085;
    fail_assertion("index too large");
    _jump1085:;
    int64_t _362 = 0;
    _362 *= c.d0;
    _362 += c.d0;
    rgba _363 = c.data[_362];
    double _364 = a(_363);
    _354 = _364;
    _jump1083:;
    bool _365 = false;
    double _366;
    if (!_365)
    goto _jump1086;
    double _367 = 1.0;
    _366 = _367;
    goto _jump1087;
    _jump1086:;
    double _368;
    // Computing bound for i
    int64_t _369 = 186;
    if (_369 > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    // Computing bound for j
    int64_t _370 = -_0;
    if (_370 > 0) 
    goto _jump1089;
    fail_assertion("non-positive loop bound");
    _jump1089:;
    // Computing bound for k
    if (_0 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    _368 = 0;
    int64_t _371 = 0; // k
    int64_t _372 = 0; // j
    int64_t _373 = 0; // i
    _jump1091:; // Begin body of loop
    double _374 = 24.0;
    _368 += _374;
    _371++;
    if (_371 < _0)
    goto _jump1091;
    _371 = 0;
    _372++;
    if (_372 < _370)
    goto _jump1091;
    _372 = 0;
    _373++;
    if (_373 < _369)
    goto _jump1091;
    // End body of loop
    _366 = _368;
    _jump1087:;
    double _375 = _354 + _366;
    double _376 = -_375;
    double _377 = _351 * _376;
    _247 = _377;
    _jump1066:;
    bool _378 = false;
    bool _379 = !_378;
    int64_t _380;
    if (!_379)
    goto _jump1092;
    _380 = e.d0;
    goto _jump1093;
    _jump1092:;
    int64_t _381 = 649;
    int64_t _382 = -_381;
    _380 = _382;
    _jump1093:;
    bool _383 = false;
    int64_t _384;
    if (!_383)
    goto _jump1094;
    _384 = _0;
    goto _jump1095;
    _jump1094:;
    _384 = e.d0;
    _jump1095:;
    int64_t _385 = 719;
    int64_t _386 = _0 * _385;
    int64_t _387 = _384 % _386;
    bool _388 = _380 < _387;
    _a3_bool _389;
    if (!_388)
    goto _jump1096;
    _a3_bool _390;
    // Computing bound for j
    _390.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for k
    _390.d1 = _0;
    if (_0 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    // Computing bound for l
    int64_t _391;
    // Computing bound for j
    int64_t _392;
    // Computing bound for j
    if (_0 > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    // Computing bound for k
    int64_t _393 = 830;
    if (_393 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing bound for l
    if (e.d0 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    _392 = 0;
    int64_t _394 = 0; // l
    int64_t _395 = 0; // k
    int64_t _396 = 0; // j
    _jump1102:; // Begin body of loop
    int64_t _397 = 35;
    _392 += _397;
    _394++;
    if (_394 < e.d0)
    goto _jump1102;
    _394 = 0;
    _395++;
    if (_395 < _393)
    goto _jump1102;
    _395 = 0;
    _396++;
    if (_396 < _0)
    goto _jump1102;
    // End body of loop
    if (_392 > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    _391 = 0;
    int64_t _398 = 0; // j
    _jump1104:; // Begin body of loop
    int64_t _399 = 794;
    _391 += _399;
    _398++;
    if (_398 < _392)
    goto _jump1104;
    // End body of loop
    _390.d2 = _391;
    if (_391 > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing total size of heap memory to allocate
    int64_t _400 = 1;
    _400 *= e.d0;
    _400 *= _0;
    _400 *= _391;
    _400 *= sizeof(bool);
    _390.data = jpl_alloc(_400);
    int64_t _401 = 0; // l
    int64_t _402 = 0; // k
    int64_t _403 = 0; // j
    _jump1106:; // Begin body of loop
    _a2_bool _404;
    // Computing bound for m
    _404.d0 = _402;
    if (_402 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    // Computing bound for n
    _404.d1 = _401;
    if (_401 > 0) 
    goto _jump1108;
    fail_assertion("non-positive loop bound");
    _jump1108:;
    // Computing total size of heap memory to allocate
    int64_t _405 = 1;
    _405 *= _402;
    _405 *= _401;
    _405 *= sizeof(bool);
    _404.data = jpl_alloc(_405);
    int64_t _406 = 0; // n
    int64_t _407 = 0; // m
    _jump1109:; // Begin body of loop
    bool _408 = false;
    int64_t _409 = 0;
    _409 *= _404.d0;
    _409 += _407;
    _409 *= _404.d1;
    _409 += _406;
    _404.data[_409] = _408;
    _406++;
    if (_406 < _401)
    goto _jump1109;
    _406 = 0;
    _407++;
    if (_407 < _402)
    goto _jump1109;
    // End body of loop
    int64_t _410 = -_403;
    int64_t _411 = _402 * _403;
    if (_410 >= 0)
    goto _jump1110;
    fail_assertion("negative array index");
    _jump1110:;
    if (_410 < _404.d0)
    goto _jump1111;
    fail_assertion("index too large");
    _jump1111:;
    if (_411 >= 0)
    goto _jump1112;
    fail_assertion("negative array index");
    _jump1112:;
    if (_411 < _404.d1)
    goto _jump1113;
    fail_assertion("index too large");
    _jump1113:;
    int64_t _412 = 0;
    _412 *= _404.d0;
    _412 += _410;
    _412 *= _404.d1;
    _412 += _411;
    bool _413 = _404.data[_412];
    int64_t _414 = 0;
    _414 *= _390.d0;
    _414 += _403;
    _414 *= _390.d1;
    _414 += _402;
    _414 *= _390.d2;
    _414 += _401;
    _390.data[_414] = _413;
    _401++;
    if (_401 < _391)
    goto _jump1106;
    _401 = 0;
    _402++;
    if (_402 < _0)
    goto _jump1106;
    _402 = 0;
    _403++;
    if (_403 < e.d0)
    goto _jump1106;
    // End body of loop
    _389 = _390;
    goto _jump1114;
    _jump1096:;
    _a3__a3_bool _415;
    // Computing bound for j
    _415.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump1115;
    fail_assertion("non-positive loop bound");
    _jump1115:;
    // Computing bound for k
    _415.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for l
    int64_t _416 = -c.d0;
    _415.d2 = _416;
    if (_416 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing total size of heap memory to allocate
    int64_t _417 = 1;
    _417 *= e.d0;
    _417 *= c.d0;
    _417 *= _416;
    _417 *= sizeof(_a3_bool);
    _415.data = jpl_alloc(_417);
    int64_t _418 = 0; // l
    int64_t _419 = 0; // k
    int64_t _420 = 0; // j
    _jump1118:; // Begin body of loop
    _a3_bool _421;
    // Computing bound for m
    _421.d0 = _0;
    if (_0 > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing bound for n
    int64_t _422 = 986;
    _421.d1 = _422;
    if (_422 > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing bound for o
    _421.d2 = _419;
    if (_419 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing total size of heap memory to allocate
    int64_t _423 = 1;
    _423 *= _0;
    _423 *= _422;
    _423 *= _419;
    _423 *= sizeof(bool);
    _421.data = jpl_alloc(_423);
    int64_t _424 = 0; // o
    int64_t _425 = 0; // n
    int64_t _426 = 0; // m
    _jump1122:; // Begin body of loop
    bool _427 = true;
    int64_t _428 = 0;
    _428 *= _421.d0;
    _428 += _426;
    _428 *= _421.d1;
    _428 += _425;
    _428 *= _421.d2;
    _428 += _424;
    _421.data[_428] = _427;
    _424++;
    if (_424 < _419)
    goto _jump1122;
    _424 = 0;
    _425++;
    if (_425 < _422)
    goto _jump1122;
    _425 = 0;
    _426++;
    if (_426 < _0)
    goto _jump1122;
    // End body of loop
    int64_t _429 = 0;
    _429 *= _415.d0;
    _429 += _420;
    _429 *= _415.d1;
    _429 += _419;
    _429 *= _415.d2;
    _429 += _418;
    _415.data[_429] = _421;
    _418++;
    if (_418 < _416)
    goto _jump1118;
    _418 = 0;
    _419++;
    if (_419 < c.d0)
    goto _jump1118;
    _419 = 0;
    _420++;
    if (_420 < e.d0)
    goto _jump1118;
    // End body of loop
    int64_t _430 = -c.d0;
    if (e.d0 >= 0)
    goto _jump1123;
    fail_assertion("negative array index");
    _jump1123:;
    if (e.d0 < _415.d0)
    goto _jump1124;
    fail_assertion("index too large");
    _jump1124:;
    if (_0 >= 0)
    goto _jump1125;
    fail_assertion("negative array index");
    _jump1125:;
    if (_0 < _415.d1)
    goto _jump1126;
    fail_assertion("index too large");
    _jump1126:;
    if (_430 >= 0)
    goto _jump1127;
    fail_assertion("negative array index");
    _jump1127:;
    if (_430 < _415.d2)
    goto _jump1128;
    fail_assertion("index too large");
    _jump1128:;
    int64_t _431 = 0;
    _431 *= _415.d0;
    _431 += e.d0;
    _431 *= _415.d1;
    _431 += _0;
    _431 *= _415.d2;
    _431 += _430;
    _a3_bool _432 = _415.data[_431];
    _389 = _432;
    _jump1114:;
    int64_t _433 = 829;
    int64_t _434 = 895;
    _a2_int64_t _435;
    // Computing bound for j
    int64_t _436;
    // Computing bound for j
    int64_t _437;
    // Computing bound for j
    if (e.d0 > 0) 
    goto _jump1129;
    fail_assertion("non-positive loop bound");
    _jump1129:;
    _437 = 0;
    int64_t _438 = 0; // j
    _jump1130:; // Begin body of loop
    _437 += c.d0;
    _438++;
    if (_438 < e.d0)
    goto _jump1130;
    // End body of loop
    if (_437 > 0) 
    goto _jump1131;
    fail_assertion("non-positive loop bound");
    _jump1131:;
    // Computing bound for k
    int64_t _439 = 931;
    if (_439 > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    _436 = 0;
    int64_t _440 = 0; // l
    int64_t _441 = 0; // k
    int64_t _442 = 0; // j
    _jump1134:; // Begin body of loop
    _436 += _441;
    _440++;
    if (_440 < c.d0)
    goto _jump1134;
    _440 = 0;
    _441++;
    if (_441 < _439)
    goto _jump1134;
    _441 = 0;
    _442++;
    if (_442 < _437)
    goto _jump1134;
    // End body of loop
    _435.d0 = _436;
    if (_436 > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    // Computing bound for k
    _435.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= _436;
    _443 *= e.d0;
    _443 *= sizeof(int64_t);
    _435.data = jpl_alloc(_443);
    int64_t _444 = 0; // k
    int64_t _445 = 0; // j
    _jump1137:; // Begin body of loop
    int64_t _446 = -_0;
    int64_t _447 = 0;
    _447 *= _435.d0;
    _447 += _445;
    _447 *= _435.d1;
    _447 += _444;
    _435.data[_447] = _446;
    _444++;
    if (_444 < e.d0)
    goto _jump1137;
    _444 = 0;
    _445++;
    if (_445 < _436)
    goto _jump1137;
    // End body of loop
    int64_t _448;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump1139;
    fail_assertion("non-positive loop bound");
    _jump1139:;
    // Computing bound for l
    int64_t _449 = 162;
    if (_449 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    _448 = 0;
    int64_t _450 = 0; // l
    int64_t _451 = 0; // k
    int64_t _452 = 0; // j
    _jump1141:; // Begin body of loop
    _448 += _452;
    _450++;
    if (_450 < _449)
    goto _jump1141;
    _450 = 0;
    _451++;
    if (_451 < c.d0)
    goto _jump1141;
    _451 = 0;
    _452++;
    if (_452 < c.d0)
    goto _jump1141;
    // End body of loop
    if (c.d0 >= 0)
    goto _jump1142;
    fail_assertion("negative array index");
    _jump1142:;
    if (c.d0 < _435.d0)
    goto _jump1143;
    fail_assertion("index too large");
    _jump1143:;
    if (_448 >= 0)
    goto _jump1144;
    fail_assertion("negative array index");
    _jump1144:;
    if (_448 < _435.d1)
    goto _jump1145;
    fail_assertion("index too large");
    _jump1145:;
    int64_t _453 = 0;
    _453 *= _435.d0;
    _453 += c.d0;
    _453 *= _435.d1;
    _453 += _448;
    int64_t _454 = _435.data[_453];
    if (_433 >= 0)
    goto _jump1146;
    fail_assertion("negative array index");
    _jump1146:;
    if (_433 < _389.d0)
    goto _jump1147;
    fail_assertion("index too large");
    _jump1147:;
    if (_434 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (_434 < _389.d1)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    if (_454 >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (_454 < _389.d2)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _455 = 0;
    _455 *= _389.d0;
    _455 += _433;
    _455 *= _389.d1;
    _455 += _434;
    _455 *= _389.d2;
    _455 += _454;
    bool _456 = _389.data[_455];
    double _457;
    if (!_456)
    goto _jump1152;
    _457 = _247;
    goto _jump1153;
    _jump1152:;
    double _458;
    // Computing bound for j
    int64_t _459;
    // Computing bound for j
    int64_t _460 = 646;
    if (_460 > 0) 
    goto _jump1154;
    fail_assertion("non-positive loop bound");
    _jump1154:;
    // Computing bound for k
    int64_t _461 = 808;
    int64_t _462 = -_0;
    int64_t _463 = _461 - _462;
    if (_463 > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing bound for l
    bool _464 = false;
    bool _465 = !_464;
    bool _466;
    if (!_465)
    goto _jump1156;
    bool _468 = true;
    bool _467 = _468;
    if (0 == _468)
    goto _jump1157;
    bool _469 = true;
    _467 = _469;
    _jump1157:;
    _466 = _467;
    goto _jump1158;
    _jump1156:;
    bool _470 = true;
    _466 = _470;
    _jump1158:;
    int64_t _471;
    if (!_466)
    goto _jump1159;
    _471 = _0;
    goto _jump1160;
    _jump1159:;
    _471 = e.d0;
    _jump1160:;
    if (_471 > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    _459 = 0;
    int64_t _472 = 0; // l
    int64_t _473 = 0; // k
    int64_t _474 = 0; // j
    _jump1162:; // Begin body of loop
    int64_t _475;
    // Computing bound for m
    _a3_int64_t _476;
    // Computing bound for m
    _476.d0 = _474;
    if (_474 > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing bound for n
    _476.d1 = _0;
    if (_0 > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    // Computing bound for o
    _476.d2 = _473;
    if (_473 > 0) 
    goto _jump1165;
    fail_assertion("non-positive loop bound");
    _jump1165:;
    // Computing total size of heap memory to allocate
    int64_t _477 = 1;
    _477 *= _474;
    _477 *= _0;
    _477 *= _473;
    _477 *= sizeof(int64_t);
    _476.data = jpl_alloc(_477);
    int64_t _478 = 0; // o
    int64_t _479 = 0; // n
    int64_t _480 = 0; // m
    _jump1166:; // Begin body of loop
    int64_t _481 = 0;
    _481 *= _476.d0;
    _481 += _480;
    _481 *= _476.d1;
    _481 += _479;
    _481 *= _476.d2;
    _481 += _478;
    _476.data[_481] = _0;
    _478++;
    if (_478 < _473)
    goto _jump1166;
    _478 = 0;
    _479++;
    if (_479 < _0)
    goto _jump1166;
    _479 = 0;
    _480++;
    if (_480 < _474)
    goto _jump1166;
    // End body of loop
    int64_t _482 = _473 * e.d0;
    if (_482 >= 0)
    goto _jump1167;
    fail_assertion("negative array index");
    _jump1167:;
    if (_482 < _476.d0)
    goto _jump1168;
    fail_assertion("index too large");
    _jump1168:;
    if (_472 >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (_472 < _476.d1)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    if (_474 >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (_474 < _476.d2)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    int64_t _483 = 0;
    _483 *= _476.d0;
    _483 += _482;
    _483 *= _476.d1;
    _483 += _472;
    _483 *= _476.d2;
    _483 += _474;
    int64_t _484 = _476.data[_483];
    if (_484 > 0) 
    goto _jump1173;
    fail_assertion("non-positive loop bound");
    _jump1173:;
    _475 = 0;
    int64_t _485 = 0; // m
    _jump1174:; // Begin body of loop
    _475 += _472;
    _485++;
    if (_485 < _484)
    goto _jump1174;
    // End body of loop
    _459 += _475;
    _472++;
    if (_472 < _471)
    goto _jump1162;
    _472 = 0;
    _473++;
    if (_473 < _463)
    goto _jump1162;
    _473 = 0;
    _474++;
    if (_474 < _460)
    goto _jump1162;
    // End body of loop
    if (_459 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    _458 = 0;
    int64_t _486 = 0; // j
    _jump1176:; // Begin body of loop
    _458 += _247;
    _486++;
    if (_486 < _459)
    goto _jump1176;
    // End body of loop
    _457 = _458;
    _jump1153:;
    double _487 = -_457;
    int64_t _488 = 818;
}

_a1_int64_t c(_a2__a1_int64_t d, void_t g) {
    bool _0 = true;
    _a1__a2__a1_int64_t _1;
    if (!_0)
    goto _jump1364;
    int64_t _2 = -d.d1;
    int64_t _3 = -d.d0;
    bool _4 = _2 != _3;
    _a1__a2__a1_int64_t _5;
    if (!_4)
    goto _jump1365;
    _a1__a1__a2__a1_int64_t _6;
    // Computing bound for h
    _6.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= d.d1;
    _7 *= sizeof(_a1__a2__a1_int64_t);
    _6.data = jpl_alloc(_7);
    int64_t _8 = 0; // h
    _jump1367:; // Begin body of loop
    _a1__a2__a1_int64_t _9;
    _9.d0 = 3;
    _9.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 3);
    _9.data[0] = d;
    _9.data[1] = d;
    _9.data[2] = d;
    int64_t _10 = 0;
    _10 *= _6.d0;
    _10 += _8;
    _6.data[_10] = _9;
    _8++;
    if (_8 < d.d1)
    goto _jump1367;
    // End body of loop
    _a3_int64_t _11;
    // Computing bound for h
    _11.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1368;
    fail_assertion("non-positive loop bound");
    _jump1368:;
    // Computing bound for i
    _11.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump1369;
    fail_assertion("non-positive loop bound");
    _jump1369:;
    // Computing bound for j
    _11.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1370;
    fail_assertion("non-positive loop bound");
    _jump1370:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= d.d1;
    _12 *= d.d0;
    _12 *= d.d0;
    _12 *= sizeof(int64_t);
    _11.data = jpl_alloc(_12);
    int64_t _13 = 0; // j
    int64_t _14 = 0; // i
    int64_t _15 = 0; // h
    _jump1371:; // Begin body of loop
    int64_t _16 = 0;
    _16 *= _11.d0;
    _16 += _15;
    _16 *= _11.d1;
    _16 += _14;
    _16 *= _11.d2;
    _16 += _13;
    _11.data[_16] = _13;
    _13++;
    if (_13 < d.d0)
    goto _jump1371;
    _13 = 0;
    _14++;
    if (_14 < d.d0)
    goto _jump1371;
    _14 = 0;
    _15++;
    if (_15 < d.d1)
    goto _jump1371;
    // End body of loop
    int64_t _17 = 541;
    if (d.d1 >= 0)
    goto _jump1372;
    fail_assertion("negative array index");
    _jump1372:;
    if (d.d1 < _11.d0)
    goto _jump1373;
    fail_assertion("index too large");
    _jump1373:;
    if (d.d1 >= 0)
    goto _jump1374;
    fail_assertion("negative array index");
    _jump1374:;
    if (d.d1 < _11.d1)
    goto _jump1375;
    fail_assertion("index too large");
    _jump1375:;
    if (_17 >= 0)
    goto _jump1376;
    fail_assertion("negative array index");
    _jump1376:;
    if (_17 < _11.d2)
    goto _jump1377;
    fail_assertion("index too large");
    _jump1377:;
    int64_t _18 = 0;
    _18 *= _11.d0;
    _18 += d.d1;
    _18 *= _11.d1;
    _18 += d.d1;
    _18 *= _11.d2;
    _18 += _17;
    int64_t _19 = _11.data[_18];
    if (_19 >= 0)
    goto _jump1378;
    fail_assertion("negative array index");
    _jump1378:;
    if (_19 < _6.d0)
    goto _jump1379;
    fail_assertion("index too large");
    _jump1379:;
    int64_t _20 = 0;
    _20 *= _6.d0;
    _20 += _19;
    _a1__a2__a1_int64_t _21 = _6.data[_20];
    _5 = _21;
    goto _jump1380;
    _jump1365:;
    _a1__a2__a1_int64_t _22;
    // Computing bound for h
    int64_t _23 = -d.d1;
    int64_t _24 = _23 % d.d1;
    _22.d0 = _24;
    if (_24 > 0) 
    goto _jump1381;
    fail_assertion("non-positive loop bound");
    _jump1381:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= _24;
    _25 *= sizeof(_a2__a1_int64_t);
    _22.data = jpl_alloc(_25);
    int64_t _26 = 0; // h
    _jump1382:; // Begin body of loop
    _a1__a2__a1_int64_t _27;
    _27.d0 = 1;
    _27.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 1);
    _27.data[0] = d;
    int64_t _28 = 139;
    if (_28 >= 0)
    goto _jump1383;
    fail_assertion("negative array index");
    _jump1383:;
    if (_28 < _27.d0)
    goto _jump1384;
    fail_assertion("index too large");
    _jump1384:;
    int64_t _29 = 0;
    _29 *= _27.d0;
    _29 += _28;
    _a2__a1_int64_t _30 = _27.data[_29];
    int64_t _31 = 0;
    _31 *= _22.d0;
    _31 += _26;
    _22.data[_31] = _30;
    _26++;
    if (_26 < _24)
    goto _jump1382;
    // End body of loop
    _5 = _22;
    _jump1380:;
    _1 = _5;
    goto _jump1385;
    _jump1364:;
    bool _32 = false;
    bool _33;
    if (!_32)
    goto _jump1386;
    int64_t _34 = 800;
    int64_t _35 = -_34;
    int64_t _36 = -d.d0;
    bool _37 = _35 != _36;
    _33 = _37;
    goto _jump1387;
    _jump1386:;
    bool _38 = false;
    _33 = _38;
    _jump1387:;
    _a1__a2__a1_int64_t _39;
    if (!_33)
    goto _jump1388;
    bool _41 = true;
    bool _40 = _41;
    if (0 == _41)
    goto _jump1389;
    bool _42 = false;
    _40 = _42;
    _jump1389:;
    _a1__a2__a1_int64_t _43;
    if (!_40)
    goto _jump1390;
    _a1__a2__a1_int64_t _44;
    _44.d0 = 3;
    _44.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 3);
    _44.data[0] = d;
    _44.data[1] = d;
    _44.data[2] = d;
    _43 = _44;
    goto _jump1391;
    _jump1390:;
    _a1__a2__a1_int64_t _45;
    // Computing bound for h
    int64_t _46 = -d.d0;
    _45.d0 = _46;
    if (_46 > 0) 
    goto _jump1392;
    fail_assertion("non-positive loop bound");
    _jump1392:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= _46;
    _47 *= sizeof(_a2__a1_int64_t);
    _45.data = jpl_alloc(_47);
    int64_t _48 = 0; // h
    _jump1393:; // Begin body of loop
    int64_t _49 = 0;
    _49 *= _45.d0;
    _49 += _48;
    _45.data[_49] = d;
    _48++;
    if (_48 < _46)
    goto _jump1393;
    // End body of loop
    _43 = _45;
    _jump1391:;
    _39 = _43;
    goto _jump1394;
    _jump1388:;
    bool _50 = true;
    _a1__a2__a1_int64_t _51;
    if (!_50)
    goto _jump1395;
    _a1__a2__a1_int64_t _52;
    // Computing bound for h
    _52.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1396;
    fail_assertion("non-positive loop bound");
    _jump1396:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= d.d1;
    _53 *= sizeof(_a2__a1_int64_t);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // h
    _jump1397:; // Begin body of loop
    int64_t _55 = 0;
    _55 *= _52.d0;
    _55 += _54;
    _52.data[_55] = d;
    _54++;
    if (_54 < d.d1)
    goto _jump1397;
    // End body of loop
    _51 = _52;
    goto _jump1398;
    _jump1395:;
    _a1__a2__a1_int64_t _56;
    // Computing bound for h
    _56.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1399;
    fail_assertion("non-positive loop bound");
    _jump1399:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= d.d1;
    _57 *= sizeof(_a2__a1_int64_t);
    _56.data = jpl_alloc(_57);
    int64_t _58 = 0; // h
    _jump1400:; // Begin body of loop
    bool _59 = true;
    _a2__a1_int64_t _60;
    if (!_59)
    goto _jump1401;
    _60 = d;
    goto _jump1402;
    _jump1401:;
    _60 = d;
    _jump1402:;
    int64_t _61 = 0;
    _61 *= _56.d0;
    _61 += _58;
    _56.data[_61] = _60;
    _58++;
    if (_58 < d.d1)
    goto _jump1400;
    // End body of loop
    _51 = _56;
    _jump1398:;
    _39 = _51;
    _jump1394:;
    _1 = _39;
    _jump1385:;
    int64_t _62;
    // Computing bound for h
    int64_t _63 = 56;
    if (_63 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    _62 = 0;
    int64_t _64 = 0; // h
    _jump1404:; // Begin body of loop
    _62 += d.d0;
    _64++;
    if (_64 < _63)
    goto _jump1404;
    // End body of loop
    if (_62 >= 0)
    goto _jump1405;
    fail_assertion("negative array index");
    _jump1405:;
    if (_62 < _1.d0)
    goto _jump1406;
    fail_assertion("index too large");
    _jump1406:;
    int64_t _65 = 0;
    _65 *= _1.d0;
    _65 += _62;
    _a2__a1_int64_t _66 = _1.data[_65];
    _a3_bool _67;
    // Computing bound for h
    _67.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1407;
    fail_assertion("non-positive loop bound");
    _jump1407:;
    // Computing bound for i
    _67.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump1408;
    fail_assertion("non-positive loop bound");
    _jump1408:;
    // Computing bound for j
    _67.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1409;
    fail_assertion("non-positive loop bound");
    _jump1409:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= d.d1;
    _68 *= d.d0;
    _68 *= d.d0;
    _68 *= sizeof(bool);
    _67.data = jpl_alloc(_68);
    int64_t _69 = 0; // j
    int64_t _70 = 0; // i
    int64_t _71 = 0; // h
    _jump1410:; // Begin body of loop
    bool _72 = false;
    int64_t _73 = 0;
    _73 *= _67.d0;
    _73 += _71;
    _73 *= _67.d1;
    _73 += _70;
    _73 *= _67.d2;
    _73 += _69;
    _67.data[_73] = _72;
    _69++;
    if (_69 < d.d0)
    goto _jump1410;
    _69 = 0;
    _70++;
    if (_70 < d.d0)
    goto _jump1410;
    _70 = 0;
    _71++;
    if (_71 < d.d1)
    goto _jump1410;
    // End body of loop
    int64_t _74 = 22;
    int64_t _75 = 27;
    if (d.d0 >= 0)
    goto _jump1411;
    fail_assertion("negative array index");
    _jump1411:;
    if (d.d0 < _67.d0)
    goto _jump1412;
    fail_assertion("index too large");
    _jump1412:;
    if (_74 >= 0)
    goto _jump1413;
    fail_assertion("negative array index");
    _jump1413:;
    if (_74 < _67.d1)
    goto _jump1414;
    fail_assertion("index too large");
    _jump1414:;
    if (_75 >= 0)
    goto _jump1415;
    fail_assertion("negative array index");
    _jump1415:;
    if (_75 < _67.d2)
    goto _jump1416;
    fail_assertion("index too large");
    _jump1416:;
    int64_t _76 = 0;
    _76 *= _67.d0;
    _76 += d.d0;
    _76 *= _67.d1;
    _76 += _74;
    _76 *= _67.d2;
    _76 += _75;
    bool _77 = _67.data[_76];
    int64_t _78;
    if (!_77)
    goto _jump1417;
    int64_t _79;
    // Computing bound for h
    int64_t _80;
    // Computing bound for h
    int64_t _81 = 689;
    if (_81 > 0) 
    goto _jump1418;
    fail_assertion("non-positive loop bound");
    _jump1418:;
    // Computing bound for i
    int64_t _82;
    // Computing bound for h
    int64_t _83 = 486;
    if (_83 > 0) 
    goto _jump1419;
    fail_assertion("non-positive loop bound");
    _jump1419:;
    _82 = 0;
    int64_t _84 = 0; // h
    _jump1420:; // Begin body of loop
    _82 += _84;
    _84++;
    if (_84 < _83)
    goto _jump1420;
    // End body of loop
    if (_82 > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    _80 = 0;
    int64_t _85 = 0; // i
    int64_t _86 = 0; // h
    _jump1422:; // Begin body of loop
    _80 += d.d1;
    _85++;
    if (_85 < _82)
    goto _jump1422;
    _85 = 0;
    _86++;
    if (_86 < _81)
    goto _jump1422;
    // End body of loop
    if (_80 > 0) 
    goto _jump1423;
    fail_assertion("non-positive loop bound");
    _jump1423:;
    _79 = 0;
    int64_t _87 = 0; // h
    _jump1424:; // Begin body of loop
    int64_t _88;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1425;
    fail_assertion("non-positive loop bound");
    _jump1425:;
    // Computing bound for j
    int64_t _89;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1426;
    fail_assertion("non-positive loop bound");
    _jump1426:;
    // Computing bound for j
    int64_t _90 = 164;
    if (_90 > 0) 
    goto _jump1427;
    fail_assertion("non-positive loop bound");
    _jump1427:;
    // Computing bound for k
    if (_87 > 0) 
    goto _jump1428;
    fail_assertion("non-positive loop bound");
    _jump1428:;
    _89 = 0;
    int64_t _91 = 0; // k
    int64_t _92 = 0; // j
    int64_t _93 = 0; // i
    _jump1429:; // Begin body of loop
    _89 += _92;
    _91++;
    if (_91 < _87)
    goto _jump1429;
    _91 = 0;
    _92++;
    if (_92 < _90)
    goto _jump1429;
    _92 = 0;
    _93++;
    if (_93 < d.d1)
    goto _jump1429;
    // End body of loop
    if (_89 > 0) 
    goto _jump1430;
    fail_assertion("non-positive loop bound");
    _jump1430:;
    _88 = 0;
    int64_t _94 = 0; // j
    int64_t _95 = 0; // i
    _jump1431:; // Begin body of loop
    int64_t _96 = -_87;
    _88 += _96;
    _94++;
    if (_94 < _89)
    goto _jump1431;
    _94 = 0;
    _95++;
    if (_95 < d.d1)
    goto _jump1431;
    // End body of loop
    _79 += _88;
    _87++;
    if (_87 < _80)
    goto _jump1424;
    // End body of loop
    _78 = _79;
    goto _jump1432;
    _jump1417:;
    int64_t _97 = 736;
    _78 = _97;
    _jump1432:;
    int64_t _98;
    // Computing bound for h
    if (d.d1 > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    _98 = 0;
    int64_t _99 = 0; // i
    int64_t _100 = 0; // h
    _jump1435:; // Begin body of loop
    int64_t _101;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump1436;
    fail_assertion("non-positive loop bound");
    _jump1436:;
    _101 = 0;
    int64_t _102 = 0; // j
    _jump1437:; // Begin body of loop
    int64_t _103;
    // Computing bound for k
    if (d.d0 > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    _103 = 0;
    int64_t _104 = 0; // k
    _jump1439:; // Begin body of loop
    _103 += _102;
    _104++;
    if (_104 < d.d0)
    goto _jump1439;
    // End body of loop
    _101 += _103;
    _102++;
    if (_102 < d.d0)
    goto _jump1437;
    // End body of loop
    _98 += _101;
    _99++;
    if (_99 < d.d1)
    goto _jump1435;
    _99 = 0;
    _100++;
    if (_100 < d.d1)
    goto _jump1435;
    // End body of loop
    int64_t _105 = -_98;
    int64_t _106 = _78 % _105;
    int64_t _107 = -_106;
    double _108 = 13.0;
    double _109;
    // Computing bound for h
    if (d.d1 > 0) 
    goto _jump1440;
    fail_assertion("non-positive loop bound");
    _jump1440:;
    _109 = 0;
    int64_t _110 = 0; // h
    _jump1441:; // Begin body of loop
    double _111 = 2.0;
    _109 += _111;
    _110++;
    if (_110 < d.d1)
    goto _jump1441;
    // End body of loop
    double _112 = _108 + _109;
    _a1_double _113;
    // Computing bound for h
    int64_t _114 = 577;
    _113.d0 = _114;
    if (_114 > 0) 
    goto _jump1442;
    fail_assertion("non-positive loop bound");
    _jump1442:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _114;
    _115 *= sizeof(double);
    _113.data = jpl_alloc(_115);
    int64_t _116 = 0; // h
    _jump1443:; // Begin body of loop
    double _117 = 31.0;
    int64_t _118 = 0;
    _118 *= _113.d0;
    _118 += _116;
    _113.data[_118] = _117;
    _116++;
    if (_116 < _114)
    goto _jump1443;
    // End body of loop
    int64_t _119 = 921;
    if (_119 >= 0)
    goto _jump1444;
    fail_assertion("negative array index");
    _jump1444:;
    if (_119 < _113.d0)
    goto _jump1445;
    fail_assertion("index too large");
    _jump1445:;
    int64_t _120 = 0;
    _120 *= _113.d0;
    _120 += _119;
    double _121 = _113.data[_120];
    bool _122 = _112 > _121;
    bool _123;
    if (!_122)
    goto _jump1446;
    int64_t _124 = 950;
    int64_t _125 = 684;
    bool _126 = _124 > _125;
    bool _127 = !_126;
    _123 = _127;
    goto _jump1447;
    _jump1446:;
    bool _128 = true;
    bool _129 = false;
    bool _130 = !_129;
    bool _131;
    if (!_130)
    goto _jump1448;
    int64_t _132 = 377;
    bool _133 = _132 == d.d0;
    _131 = _133;
    goto _jump1449;
    _jump1448:;
    bool _134 = false;
    bool _135 = !_134;
    _131 = _135;
    _jump1449:;
    bool _136 = _128 != _131;
    _123 = _136;
    _jump1447:;
    bool _137;
    if (!_123)
    goto _jump1450;
    int64_t _138 = -d.d1;
    bool _139 = false;
    int64_t _140;
    if (!_139)
    goto _jump1451;
    _140 = d.d0;
    goto _jump1452;
    _jump1451:;
    _140 = d.d1;
    _jump1452:;
    bool _141 = _138 >= _140;
    bool _142 = !_141;
    bool _143;
    if (!_142)
    goto _jump1453;
    int64_t _144 = 665;
    bool _145 = d.d1 >= _144;
    _143 = _145;
    goto _jump1454;
    _jump1453:;
    bool _146 = true;
    _143 = _146;
    _jump1454:;
    _137 = _143;
    goto _jump1455;
    _jump1450:;
    double _147 = 27.0;
    double _148 = 2.0;
    bool _149 = _147 < _148;
    _137 = _149;
    _jump1455:;
    int64_t _150;
    if (!_137)
    goto _jump1456;
    _150 = d.d0;
    goto _jump1457;
    _jump1456:;
    int64_t _151 = 381;
    _150 = _151;
    _jump1457:;
    if (_107 >= 0)
    goto _jump1458;
    fail_assertion("negative array index");
    _jump1458:;
    if (_107 < _66.d0)
    goto _jump1459;
    fail_assertion("index too large");
    _jump1459:;
    if (_150 >= 0)
    goto _jump1460;
    fail_assertion("negative array index");
    _jump1460:;
    if (_150 < _66.d1)
    goto _jump1461;
    fail_assertion("index too large");
    _jump1461:;
    int64_t _152 = 0;
    _152 *= _66.d0;
    _152 += _107;
    _152 *= _66.d1;
    _152 += _150;
    _a1_int64_t _153 = _66.data[_152];
    return _153;
    _a1_double _154;
    // Computing bound for h
    int64_t _155 = -d.d0;
    _154.d0 = _155;
    if (_155 > 0) 
    goto _jump1462;
    fail_assertion("non-positive loop bound");
    _jump1462:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= _155;
    _156 *= sizeof(double);
    _154.data = jpl_alloc(_156);
    int64_t _157 = 0; // h
    _jump1463:; // Begin body of loop
    double _158 = 79.0;
    int64_t _159 = 0;
    _159 *= _154.d0;
    _159 += _157;
    _154.data[_159] = _158;
    _157++;
    if (_157 < _155)
    goto _jump1463;
    // End body of loop
    int64_t _160 = 573;
    if (_160 >= 0)
    goto _jump1464;
    fail_assertion("negative array index");
    _jump1464:;
    if (_160 < _154.d0)
    goto _jump1465;
    fail_assertion("index too large");
    _jump1465:;
    int64_t _161 = 0;
    _161 *= _154.d0;
    _161 += _160;
    double _162 = _154.data[_161];
    double _163 = 46.0;
    double _164 = -_163;
    double _165 = _162 * _164;
    double _166 = 51.0;
    double _167 = 4.0;
    double _168 = 38.0;
    double _169 = -_168;
    double _170 = 54.0;
    double _171 = 43.0;
    double _172 = _170 + _171;
    double _173 = -_172;
    rgba _174 = { _166, _167, _169, _173 };
    double _175 = _174.b;
    double _176 = 43.0;
    double _177 = 5.0;
    double _178 = 42.0;
    double _179 = 47.0;
    double _180 = fmod(_178, _179);
    double _181 = _177 * _180;
    rgba _182 = { _165, _175, _176, _181 };
    double _183 = a(_182);
    _a1_double _184;
    // Computing bound for h
    int64_t _185 = -d.d0;
    _184.d0 = _185;
    if (_185 > 0) 
    goto _jump1466;
    fail_assertion("non-positive loop bound");
    _jump1466:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= _185;
    _186 *= sizeof(double);
    _184.data = jpl_alloc(_186);
    int64_t _187 = 0; // h
    _jump1467:; // Begin body of loop
    double _188;
    // Computing bound for i
    if (_187 > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump1469;
    fail_assertion("non-positive loop bound");
    _jump1469:;
    _188 = 0;
    int64_t _189 = 0; // j
    int64_t _190 = 0; // i
    _jump1470:; // Begin body of loop
    double _191 = 99.0;
    _188 += _191;
    _189++;
    if (_189 < d.d1)
    goto _jump1470;
    _189 = 0;
    _190++;
    if (_190 < _187)
    goto _jump1470;
    // End body of loop
    int64_t _192 = 0;
    _192 *= _184.d0;
    _192 += _187;
    _184.data[_192] = _188;
    _187++;
    if (_187 < _185)
    goto _jump1467;
    // End body of loop
    double _193 = 73.0;
    double _194 = 63.0;
    bool _195 = _193 < _194;
    int64_t _196;
    if (!_195)
    goto _jump1471;
    _a2_int64_t _197;
    // Computing bound for h
    _197.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1472;
    fail_assertion("non-positive loop bound");
    _jump1472:;
    // Computing bound for i
    bool _198 = true;
    int64_t _199;
    if (!_198)
    goto _jump1473;
    _199 = d.d1;
    goto _jump1474;
    _jump1473:;
    _199 = d.d0;
    _jump1474:;
    _197.d1 = _199;
    if (_199 > 0) 
    goto _jump1475;
    fail_assertion("non-positive loop bound");
    _jump1475:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= d.d1;
    _200 *= _199;
    _200 *= sizeof(int64_t);
    _197.data = jpl_alloc(_200);
    int64_t _201 = 0; // i
    int64_t _202 = 0; // h
    _jump1476:; // Begin body of loop
    int64_t _203 = 0;
    _203 *= _197.d0;
    _203 += _202;
    _203 *= _197.d1;
    _203 += _201;
    _197.data[_203] = d.d1;
    _201++;
    if (_201 < _199)
    goto _jump1476;
    _201 = 0;
    _202++;
    if (_202 < d.d1)
    goto _jump1476;
    // End body of loop
    int64_t _204;
    // Computing bound for h
    if (d.d1 > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1478;
    fail_assertion("non-positive loop bound");
    _jump1478:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump1479;
    fail_assertion("non-positive loop bound");
    _jump1479:;
    _204 = 0;
    int64_t _205 = 0; // j
    int64_t _206 = 0; // i
    int64_t _207 = 0; // h
    _jump1480:; // Begin body of loop
    _204 += _205;
    _205++;
    if (_205 < d.d1)
    goto _jump1480;
    _205 = 0;
    _206++;
    if (_206 < d.d0)
    goto _jump1480;
    _206 = 0;
    _207++;
    if (_207 < d.d1)
    goto _jump1480;
    // End body of loop
    int64_t _208 = _204 - d.d0;
    if (d.d1 >= 0)
    goto _jump1481;
    fail_assertion("negative array index");
    _jump1481:;
    if (d.d1 < _197.d0)
    goto _jump1482;
    fail_assertion("index too large");
    _jump1482:;
    if (_208 >= 0)
    goto _jump1483;
    fail_assertion("negative array index");
    _jump1483:;
    if (_208 < _197.d1)
    goto _jump1484;
    fail_assertion("index too large");
    _jump1484:;
    int64_t _209 = 0;
    _209 *= _197.d0;
    _209 += d.d1;
    _209 *= _197.d1;
    _209 += _208;
    int64_t _210 = _197.data[_209];
    int64_t _211 = _210 / d.d1;
    _196 = _211;
    goto _jump1485;
    _jump1471:;
    int64_t _212 = 0;
    _196 = _212;
    _jump1485:;
    if (_196 >= 0)
    goto _jump1486;
    fail_assertion("negative array index");
    _jump1486:;
    if (_196 < _184.d0)
    goto _jump1487;
    fail_assertion("index too large");
    _jump1487:;
    int64_t _213 = 0;
    _213 *= _184.d0;
    _213 += _196;
    double _214 = _184.data[_213];
    bool _215 = _183 < _214;
    if (0 != _215)
    goto _jump1488;
    fail_assertion("h");
    _jump1488:;
    double _216;
    // Computing bound for h
    if (d.d1 > 0) 
    goto _jump1489;
    fail_assertion("non-positive loop bound");
    _jump1489:;
    // Computing bound for i
    int64_t _217 = 19;
    int64_t _218 = d.d0 % _217;
    int64_t _219 = -_218;
    bool _220 = _219 < d.d0;
    int64_t _221;
    if (!_220)
    goto _jump1490;
    bool _222 = false;
    int64_t _223;
    if (!_222)
    goto _jump1491;
    int64_t _224 = d.d1 - d.d1;
    _223 = _224;
    goto _jump1492;
    _jump1491:;
    int64_t _225 = -d.d0;
    int64_t _226 = _225 / d.d1;
    _223 = _226;
    _jump1492:;
    _221 = _223;
    goto _jump1493;
    _jump1490:;
    int64_t _227 = 19;
    int64_t _228 = 369;
    int64_t _229 = _227 % _228;
    int64_t _230 = -_229;
    _221 = _230;
    _jump1493:;
    if (_221 > 0) 
    goto _jump1494;
    fail_assertion("non-positive loop bound");
    _jump1494:;
    // Computing bound for j
    _a2_bool _231;
    // Computing bound for h
    int64_t _232 = 81;
    _231.d0 = _232;
    if (_232 > 0) 
    goto _jump1495;
    fail_assertion("non-positive loop bound");
    _jump1495:;
    // Computing bound for i
    _231.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump1496;
    fail_assertion("non-positive loop bound");
    _jump1496:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= _232;
    _233 *= d.d1;
    _233 *= sizeof(bool);
    _231.data = jpl_alloc(_233);
    int64_t _234 = 0; // i
    int64_t _235 = 0; // h
    _jump1497:; // Begin body of loop
    bool _237 = true;
    bool _236 = _237;
    if (0 == _237)
    goto _jump1498;
    bool _238 = true;
    _236 = _238;
    _jump1498:;
    int64_t _239 = 0;
    _239 *= _231.d0;
    _239 += _235;
    _239 *= _231.d1;
    _239 += _234;
    _231.data[_239] = _236;
    _234++;
    if (_234 < d.d1)
    goto _jump1497;
    _234 = 0;
    _235++;
    if (_235 < _232)
    goto _jump1497;
    // End body of loop
    int64_t _240 = 198;
    int64_t _241 = 17;
    int64_t _242;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump1499;
    fail_assertion("non-positive loop bound");
    _jump1499:;
    _242 = 0;
    int64_t _243 = 0; // h
    _jump1500:; // Begin body of loop
    _242 += d.d0;
    _243++;
    if (_243 < d.d0)
    goto _jump1500;
    // End body of loop
    int64_t _244 = _241 % _242;
    if (_240 >= 0)
    goto _jump1501;
    fail_assertion("negative array index");
    _jump1501:;
    if (_240 < _231.d0)
    goto _jump1502;
    fail_assertion("index too large");
    _jump1502:;
    if (_244 >= 0)
    goto _jump1503;
    fail_assertion("negative array index");
    _jump1503:;
    if (_244 < _231.d1)
    goto _jump1504;
    fail_assertion("index too large");
    _jump1504:;
    int64_t _245 = 0;
    _245 *= _231.d0;
    _245 += _240;
    _245 *= _231.d1;
    _245 += _244;
    bool _246 = _231.data[_245];
    int64_t _247;
    if (!_246)
    goto _jump1505;
    _247 = d.d1;
    goto _jump1506;
    _jump1505:;
    int64_t _248 = 183;
    int64_t _249 = -d.d0;
    int64_t _250 = 911;
    int64_t _251 = _250 - d.d0;
    int64_t _252 = _249 - _251;
    int64_t _253 = _248 - _252;
    _247 = _253;
    _jump1506:;
    if (_247 > 0) 
    goto _jump1507;
    fail_assertion("non-positive loop bound");
    _jump1507:;
    _216 = 0;
    int64_t _254 = 0; // j
    int64_t _255 = 0; // i
    int64_t _256 = 0; // h
    _jump1508:; // Begin body of loop
    int64_t _257;
    // Computing bound for k
    if (d.d0 > 0) 
    goto _jump1509;
    fail_assertion("non-positive loop bound");
    _jump1509:;
    _257 = 0;
    int64_t _258 = 0; // k
    _jump1510:; // Begin body of loop
    int64_t _259 = _254 + d.d0;
    _257 += _259;
    _258++;
    if (_258 < d.d0)
    goto _jump1510;
    // End body of loop
    bool _260 = d.d1 > _257;
    double _261;
    if (!_260)
    goto _jump1511;
    double _262 = 5.0;
    double _263;
    // Computing bound for k
    if (d.d1 > 0) 
    goto _jump1512;
    fail_assertion("non-positive loop bound");
    _jump1512:;
    _263 = 0;
    int64_t _264 = 0; // k
    _jump1513:; // Begin body of loop
    double _265 = 7.0;
    double _266 = -_265;
    _263 += _266;
    _264++;
    if (_264 < d.d1)
    goto _jump1513;
    // End body of loop
    double _267 = fmod(_262, _263);
    _261 = _267;
    goto _jump1514;
    _jump1511:;
    _a1_bool _268;
    // Computing bound for k
    int64_t _269 = 138;
    _268.d0 = _269;
    if (_269 > 0) 
    goto _jump1515;
    fail_assertion("non-positive loop bound");
    _jump1515:;
    // Computing total size of heap memory to allocate
    int64_t _270 = 1;
    _270 *= _269;
    _270 *= sizeof(bool);
    _268.data = jpl_alloc(_270);
    int64_t _271 = 0; // k
    _jump1516:; // Begin body of loop
    bool _272 = false;
    int64_t _273 = 0;
    _273 *= _268.d0;
    _273 += _271;
    _268.data[_273] = _272;
    _271++;
    if (_271 < _269)
    goto _jump1516;
    // End body of loop
    int64_t _274;
    // Computing bound for k
    if (_254 > 0) 
    goto _jump1517;
    fail_assertion("non-positive loop bound");
    _jump1517:;
    // Computing bound for l
    if (_255 > 0) 
    goto _jump1518;
    fail_assertion("non-positive loop bound");
    _jump1518:;
    // Computing bound for m
    if (d.d0 > 0) 
    goto _jump1519;
    fail_assertion("non-positive loop bound");
    _jump1519:;
    _274 = 0;
    int64_t _275 = 0; // m
    int64_t _276 = 0; // l
    int64_t _277 = 0; // k
    _jump1520:; // Begin body of loop
    _274 += _276;
    _275++;
    if (_275 < d.d0)
    goto _jump1520;
    _275 = 0;
    _276++;
    if (_276 < _255)
    goto _jump1520;
    _276 = 0;
    _277++;
    if (_277 < _254)
    goto _jump1520;
    // End body of loop
    if (_274 >= 0)
    goto _jump1521;
    fail_assertion("negative array index");
    _jump1521:;
    if (_274 < _268.d0)
    goto _jump1522;
    fail_assertion("index too large");
    _jump1522:;
    int64_t _278 = 0;
    _278 *= _268.d0;
    _278 += _274;
    bool _279 = _268.data[_278];
    double _280;
    if (!_279)
    goto _jump1523;
    double _281;
    // Computing bound for k
    int64_t _282 = 538;
    if (_282 > 0) 
    goto _jump1524;
    fail_assertion("non-positive loop bound");
    _jump1524:;
    _281 = 0;
    int64_t _283 = 0; // k
    _jump1525:; // Begin body of loop
    double _284 = 24.0;
    _281 += _284;
    _283++;
    if (_283 < _282)
    goto _jump1525;
    // End body of loop
    _280 = _281;
    goto _jump1526;
    _jump1523:;
    double _285 = 68.0;
    double _286 = -_285;
    _280 = _286;
    _jump1526:;
    _261 = _280;
    _jump1514:;
    _216 += _261;
    _254++;
    if (_254 < _247)
    goto _jump1508;
    _254 = 0;
    _255++;
    if (_255 < _221)
    goto _jump1508;
    _255 = 0;
    _256++;
    if (_256 < d.d1)
    goto _jump1508;
    // End body of loop
    double _287 = -_216;
    double _288 = 83.0;
    double _289;
    // Computing bound for h
    _a3_int64_t _290;
    // Computing bound for h
    _290.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing bound for i
    _290.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump1528;
    fail_assertion("non-positive loop bound");
    _jump1528:;
    // Computing bound for j
    _290.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1529;
    fail_assertion("non-positive loop bound");
    _jump1529:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= d.d1;
    _291 *= d.d0;
    _291 *= d.d0;
    _291 *= sizeof(int64_t);
    _290.data = jpl_alloc(_291);
    int64_t _292 = 0; // j
    int64_t _293 = 0; // i
    int64_t _294 = 0; // h
    _jump1530:; // Begin body of loop
    int64_t _295 = 325;
    int64_t _296 = 0;
    _296 *= _290.d0;
    _296 += _294;
    _296 *= _290.d1;
    _296 += _293;
    _296 *= _290.d2;
    _296 += _292;
    _290.data[_296] = _295;
    _292++;
    if (_292 < d.d0)
    goto _jump1530;
    _292 = 0;
    _293++;
    if (_293 < d.d0)
    goto _jump1530;
    _293 = 0;
    _294++;
    if (_294 < d.d1)
    goto _jump1530;
    // End body of loop
    int64_t _297 = -d.d1;
    int64_t _298 = 673;
    int64_t _299 = _298 + d.d0;
    if (_297 >= 0)
    goto _jump1531;
    fail_assertion("negative array index");
    _jump1531:;
    if (_297 < _290.d0)
    goto _jump1532;
    fail_assertion("index too large");
    _jump1532:;
    if (d.d0 >= 0)
    goto _jump1533;
    fail_assertion("negative array index");
    _jump1533:;
    if (d.d0 < _290.d1)
    goto _jump1534;
    fail_assertion("index too large");
    _jump1534:;
    if (_299 >= 0)
    goto _jump1535;
    fail_assertion("negative array index");
    _jump1535:;
    if (_299 < _290.d2)
    goto _jump1536;
    fail_assertion("index too large");
    _jump1536:;
    int64_t _300 = 0;
    _300 *= _290.d0;
    _300 += _297;
    _300 *= _290.d1;
    _300 += d.d0;
    _300 *= _290.d2;
    _300 += _299;
    int64_t _301 = _290.data[_300];
    if (_301 > 0) 
    goto _jump1537;
    fail_assertion("non-positive loop bound");
    _jump1537:;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1538;
    fail_assertion("non-positive loop bound");
    _jump1538:;
    _289 = 0;
    int64_t _302 = 0; // i
    int64_t _303 = 0; // h
    _jump1539:; // Begin body of loop
    double _304 = 84.0;
    _289 += _304;
    _302++;
    if (_302 < d.d1)
    goto _jump1539;
    _302 = 0;
    _303++;
    if (_303 < _301)
    goto _jump1539;
    // End body of loop
    double _305 = _288 * _289;
    double _306 = -_305;
    double _307 = -_306;
    bool _308 = true;
    bool _309;
    if (!_308)
    goto _jump1540;
    bool _310 = d.d1 == d.d1;
    bool _311 = !_310;
    _309 = _311;
    goto _jump1541;
    _jump1540:;
    int64_t _312 = 318;
    int64_t _313;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump1542;
    fail_assertion("non-positive loop bound");
    _jump1542:;
    _313 = 0;
    int64_t _314 = 0; // h
    _jump1543:; // Begin body of loop
    int64_t _315 = 366;
    _313 += _315;
    _314++;
    if (_314 < d.d0)
    goto _jump1543;
    // End body of loop
    bool _316 = _312 <= _313;
    _309 = _316;
    _jump1541:;
    _a3_double _317;
    if (!_309)
    goto _jump1544;
    _a3_double _318;
    // Computing bound for h
    int64_t _319 = 791;
    _318.d0 = _319;
    if (_319 > 0) 
    goto _jump1545;
    fail_assertion("non-positive loop bound");
    _jump1545:;
    // Computing bound for i
    int64_t _320 = 167;
    int64_t _321 = -_320;
    _318.d1 = _321;
    if (_321 > 0) 
    goto _jump1546;
    fail_assertion("non-positive loop bound");
    _jump1546:;
    // Computing bound for j
    int64_t _322 = 37;
    int64_t _323 = d.d0 + _322;
    _318.d2 = _323;
    if (_323 > 0) 
    goto _jump1547;
    fail_assertion("non-positive loop bound");
    _jump1547:;
    // Computing total size of heap memory to allocate
    int64_t _324 = 1;
    _324 *= _319;
    _324 *= _321;
    _324 *= _323;
    _324 *= sizeof(double);
    _318.data = jpl_alloc(_324);
    int64_t _325 = 0; // j
    int64_t _326 = 0; // i
    int64_t _327 = 0; // h
    _jump1548:; // Begin body of loop
    double _328 = 74.0;
    double _329 = -_328;
    double _330;
    // Computing bound for k
    if (d.d0 > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    // Computing bound for l
    int64_t _331 = 180;
    if (_331 > 0) 
    goto _jump1550;
    fail_assertion("non-positive loop bound");
    _jump1550:;
    _330 = 0;
    int64_t _332 = 0; // l
    int64_t _333 = 0; // k
    _jump1551:; // Begin body of loop
    double _334 = 26.0;
    _330 += _334;
    _332++;
    if (_332 < _331)
    goto _jump1551;
    _332 = 0;
    _333++;
    if (_333 < d.d0)
    goto _jump1551;
    // End body of loop
    double _335 = _329 - _330;
    int64_t _336 = 0;
    _336 *= _318.d0;
    _336 += _327;
    _336 *= _318.d1;
    _336 += _326;
    _336 *= _318.d2;
    _336 += _325;
    _318.data[_336] = _335;
    _325++;
    if (_325 < _323)
    goto _jump1548;
    _325 = 0;
    _326++;
    if (_326 < _321)
    goto _jump1548;
    _326 = 0;
    _327++;
    if (_327 < _319)
    goto _jump1548;
    // End body of loop
    _317 = _318;
    goto _jump1552;
    _jump1544:;
    _a3_double _337;
    // Computing bound for h
    int64_t _338;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump1553;
    fail_assertion("non-positive loop bound");
    _jump1553:;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1554;
    fail_assertion("non-positive loop bound");
    _jump1554:;
    // Computing bound for j
    int64_t _339 = -d.d0;
    if (_339 > 0) 
    goto _jump1555;
    fail_assertion("non-positive loop bound");
    _jump1555:;
    _338 = 0;
    int64_t _340 = 0; // j
    int64_t _341 = 0; // i
    int64_t _342 = 0; // h
    _jump1556:; // Begin body of loop
    int64_t _343 = 560;
    _338 += _343;
    _340++;
    if (_340 < _339)
    goto _jump1556;
    _340 = 0;
    _341++;
    if (_341 < d.d0)
    goto _jump1556;
    _341 = 0;
    _342++;
    if (_342 < d.d0)
    goto _jump1556;
    // End body of loop
    _337.d0 = _338;
    if (_338 > 0) 
    goto _jump1557;
    fail_assertion("non-positive loop bound");
    _jump1557:;
    // Computing bound for i
    int64_t _344;
    // Computing bound for h
    int64_t _345 = d.d0 + d.d1;
    if (_345 > 0) 
    goto _jump1558;
    fail_assertion("non-positive loop bound");
    _jump1558:;
    _344 = 0;
    int64_t _346 = 0; // h
    _jump1559:; // Begin body of loop
    _344 += _346;
    _346++;
    if (_346 < _345)
    goto _jump1559;
    // End body of loop
    _337.d1 = _344;
    if (_344 > 0) 
    goto _jump1560;
    fail_assertion("non-positive loop bound");
    _jump1560:;
    // Computing bound for j
    int64_t _347 = d.d0 / d.d0;
    int64_t _348 = -_347;
    _337.d2 = _348;
    if (_348 > 0) 
    goto _jump1561;
    fail_assertion("non-positive loop bound");
    _jump1561:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= _338;
    _349 *= _344;
    _349 *= _348;
    _349 *= sizeof(double);
    _337.data = jpl_alloc(_349);
    int64_t _350 = 0; // j
    int64_t _351 = 0; // i
    int64_t _352 = 0; // h
    _jump1562:; // Begin body of loop
    double _353;
    // Computing bound for k
    if (_350 > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing bound for l
    if (d.d1 > 0) 
    goto _jump1564;
    fail_assertion("non-positive loop bound");
    _jump1564:;
    _353 = 0;
    int64_t _354 = 0; // l
    int64_t _355 = 0; // k
    _jump1565:; // Begin body of loop
    double _356;
    // Computing bound for m
    if (_354 > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    // Computing bound for n
    if (_350 > 0) 
    goto _jump1567;
    fail_assertion("non-positive loop bound");
    _jump1567:;
    _356 = 0;
    int64_t _357 = 0; // n
    int64_t _358 = 0; // m
    _jump1568:; // Begin body of loop
    double _359 = 62.0;
    _356 += _359;
    _357++;
    if (_357 < _350)
    goto _jump1568;
    _357 = 0;
    _358++;
    if (_358 < _354)
    goto _jump1568;
    // End body of loop
    _353 += _356;
    _354++;
    if (_354 < d.d1)
    goto _jump1565;
    _354 = 0;
    _355++;
    if (_355 < _350)
    goto _jump1565;
    // End body of loop
    int64_t _360 = 0;
    _360 *= _337.d0;
    _360 += _352;
    _360 *= _337.d1;
    _360 += _351;
    _360 *= _337.d2;
    _360 += _350;
    _337.data[_360] = _353;
    _350++;
    if (_350 < _348)
    goto _jump1562;
    _350 = 0;
    _351++;
    if (_351 < _344)
    goto _jump1562;
    _351 = 0;
    _352++;
    if (_352 < _338)
    goto _jump1562;
    // End body of loop
    _317 = _337;
    _jump1552:;
    int64_t _361;
    // Computing bound for h
    int64_t _362 = 57;
    int64_t _363 = _362 % d.d0;
    if (_363 > 0) 
    goto _jump1569;
    fail_assertion("non-positive loop bound");
    _jump1569:;
    // Computing bound for i
    int64_t _364 = 714;
    if (_364 > 0) 
    goto _jump1570;
    fail_assertion("non-positive loop bound");
    _jump1570:;
    _361 = 0;
    int64_t _365 = 0; // i
    int64_t _366 = 0; // h
    _jump1571:; // Begin body of loop
    bool _367 = _366 > d.d1;
    int64_t _368;
    if (!_367)
    goto _jump1572;
    int64_t _369 = 326;
    int64_t _370 = _369 / _366;
    int64_t _371 = _370 * _366;
    _368 = _371;
    goto _jump1573;
    _jump1572:;
    _368 = d.d1;
    _jump1573:;
    _361 += _368;
    _365++;
    if (_365 < _364)
    goto _jump1571;
    _365 = 0;
    _366++;
    if (_366 < _363)
    goto _jump1571;
    // End body of loop
    _a1__a1_int64_t _372;
    // Computing bound for h
    int64_t _373 = -d.d1;
    _372.d0 = _373;
    if (_373 > 0) 
    goto _jump1574;
    fail_assertion("non-positive loop bound");
    _jump1574:;
    // Computing total size of heap memory to allocate
    int64_t _374 = 1;
    _374 *= _373;
    _374 *= sizeof(_a1_int64_t);
    _372.data = jpl_alloc(_374);
    int64_t _375 = 0; // h
    _jump1575:; // Begin body of loop
    _a1_int64_t _376;
    _376.d0 = 1;
    _376.data = jpl_alloc(sizeof(int64_t) * 1);
    _376.data[0] = d.d0;
    int64_t _377 = 0;
    _377 *= _372.d0;
    _377 += _375;
    _372.data[_377] = _376;
    _375++;
    if (_375 < _373)
    goto _jump1575;
    // End body of loop
    int64_t _378;
    // Computing bound for h
    if (d.d1 > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    _378 = 0;
    int64_t _379 = 0; // h
    _jump1577:; // Begin body of loop
    _378 += d.d0;
    _379++;
    if (_379 < d.d1)
    goto _jump1577;
    // End body of loop
    int64_t _380 = -_378;
    if (_380 >= 0)
    goto _jump1578;
    fail_assertion("negative array index");
    _jump1578:;
    if (_380 < _372.d0)
    goto _jump1579;
    fail_assertion("index too large");
    _jump1579:;
    int64_t _381 = 0;
    _381 *= _372.d0;
    _381 += _380;
    _a1_int64_t _382 = _372.data[_381];
    bool _383 = false;
    bool _384 = false;
    bool _385 = _383 != _384;
    int64_t _386;
    if (!_385)
    goto _jump1580;
    int64_t _387 = d.d0 - d.d1;
    _386 = _387;
    goto _jump1581;
    _jump1580:;
    int64_t _388 = 536;
    _386 = _388;
    _jump1581:;
    if (_386 >= 0)
    goto _jump1582;
    fail_assertion("negative array index");
    _jump1582:;
    if (_386 < _382.d0)
    goto _jump1583;
    fail_assertion("index too large");
    _jump1583:;
    int64_t _389 = 0;
    _389 *= _382.d0;
    _389 += _386;
    int64_t _390 = _382.data[_389];
    int64_t _391 = 727;
    if (_361 >= 0)
    goto _jump1584;
    fail_assertion("negative array index");
    _jump1584:;
    if (_361 < _317.d0)
    goto _jump1585;
    fail_assertion("index too large");
    _jump1585:;
    if (_390 >= 0)
    goto _jump1586;
    fail_assertion("negative array index");
    _jump1586:;
    if (_390 < _317.d1)
    goto _jump1587;
    fail_assertion("index too large");
    _jump1587:;
    if (_391 >= 0)
    goto _jump1588;
    fail_assertion("negative array index");
    _jump1588:;
    if (_391 < _317.d2)
    goto _jump1589;
    fail_assertion("index too large");
    _jump1589:;
    int64_t _392 = 0;
    _392 *= _317.d0;
    _392 += _361;
    _392 *= _317.d1;
    _392 += _390;
    _392 *= _317.d2;
    _392 += _391;
    double _393 = _317.data[_392];
    double _394 = -_393;
    bool _395 = false;
    bool _396;
    if (!_395)
    goto _jump1590;
    int64_t _397 = 660;
    bool _398 = d.d0 >= _397;
    bool _399 = d.d0 > d.d1;
    bool _400 = true;
    bool _401 = !_400;
    bool _402 = _399 != _401;
    bool _403 = _398 == _402;
    bool _404;
    if (!_403)
    goto _jump1591;
    double _405 = 62.0;
    double _406 = -_405;
    double _407 = 43.0;
    double _408 = -_407;
    bool _409 = _406 <= _408;
    bool _410 = !_409;
    _404 = _410;
    goto _jump1592;
    _jump1591:;
    bool _411 = false;
    _404 = _411;
    _jump1592:;
    _396 = _404;
    goto _jump1593;
    _jump1590:;
    int64_t _412 = -d.d1;
    bool _413 = _412 < d.d0;
    bool _414;
    if (!_413)
    goto _jump1594;
    bool _415 = true;
    bool _416;
    if (!_415)
    goto _jump1595;
    bool _417 = true;
    bool _418 = true;
    _a1_bool _419;
    _419.d0 = 2;
    _419.data = jpl_alloc(sizeof(bool) * 2);
    _419.data[0] = _417;
    _419.data[1] = _418;
    int64_t _420;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    _420 = 0;
    int64_t _421 = 0; // h
    _jump1597:; // Begin body of loop
    _420 += d.d1;
    _421++;
    if (_421 < d.d0)
    goto _jump1597;
    // End body of loop
    if (_420 >= 0)
    goto _jump1598;
    fail_assertion("negative array index");
    _jump1598:;
    if (_420 < _419.d0)
    goto _jump1599;
    fail_assertion("index too large");
    _jump1599:;
    int64_t _422 = 0;
    _422 *= _419.d0;
    _422 += _420;
    bool _423 = _419.data[_422];
    _416 = _423;
    goto _jump1600;
    _jump1595:;
    bool _424 = true;
    _416 = _424;
    _jump1600:;
    _414 = _416;
    goto _jump1601;
    _jump1594:;
    bool _425 = false;
    _414 = _425;
    _jump1601:;
    _396 = _414;
    _jump1593:;
    double _426;
    if (!_396)
    goto _jump1602;
    _a1_double _427;
    // Computing bound for h
    _427.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= d.d0;
    _428 *= sizeof(double);
    _427.data = jpl_alloc(_428);
    int64_t _429 = 0; // h
    _jump1604:; // Begin body of loop
    double _430 = 62.0;
    int64_t _431 = 0;
    _431 *= _427.d0;
    _431 += _429;
    _427.data[_431] = _430;
    _429++;
    if (_429 < d.d0)
    goto _jump1604;
    // End body of loop
    if (d.d1 >= 0)
    goto _jump1605;
    fail_assertion("negative array index");
    _jump1605:;
    if (d.d1 < _427.d0)
    goto _jump1606;
    fail_assertion("index too large");
    _jump1606:;
    int64_t _432 = 0;
    _432 *= _427.d0;
    _432 += d.d1;
    double _433 = _427.data[_432];
    double _434 = -_433;
    double _435 = -_434;
    _426 = _435;
    goto _jump1607;
    _jump1602:;
    double _436;
    // Computing bound for h
    _a3_int64_t _437;
    // Computing bound for h
    _437.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump1608;
    fail_assertion("non-positive loop bound");
    _jump1608:;
    // Computing bound for i
    int64_t _438 = -d.d0;
    _437.d1 = _438;
    if (_438 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing bound for j
    _437.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1610;
    fail_assertion("non-positive loop bound");
    _jump1610:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= d.d0;
    _439 *= _438;
    _439 *= d.d0;
    _439 *= sizeof(int64_t);
    _437.data = jpl_alloc(_439);
    int64_t _440 = 0; // j
    int64_t _441 = 0; // i
    int64_t _442 = 0; // h
    _jump1611:; // Begin body of loop
    int64_t _443 = 0;
    _443 *= _437.d0;
    _443 += _442;
    _443 *= _437.d1;
    _443 += _441;
    _443 *= _437.d2;
    _443 += _440;
    _437.data[_443] = d.d0;
    _440++;
    if (_440 < d.d0)
    goto _jump1611;
    _440 = 0;
    _441++;
    if (_441 < _438)
    goto _jump1611;
    _441 = 0;
    _442++;
    if (_442 < d.d0)
    goto _jump1611;
    // End body of loop
    int64_t _444 = 778;
    int64_t _445 = 18;
    int64_t _446 = -_445;
    int64_t _447 = 33;
    int64_t _448 = -_447;
    int64_t _449 = -_448;
    if (_444 >= 0)
    goto _jump1612;
    fail_assertion("negative array index");
    _jump1612:;
    if (_444 < _437.d0)
    goto _jump1613;
    fail_assertion("index too large");
    _jump1613:;
    if (_446 >= 0)
    goto _jump1614;
    fail_assertion("negative array index");
    _jump1614:;
    if (_446 < _437.d1)
    goto _jump1615;
    fail_assertion("index too large");
    _jump1615:;
    if (_449 >= 0)
    goto _jump1616;
    fail_assertion("negative array index");
    _jump1616:;
    if (_449 < _437.d2)
    goto _jump1617;
    fail_assertion("index too large");
    _jump1617:;
    int64_t _450 = 0;
    _450 *= _437.d0;
    _450 += _444;
    _450 *= _437.d1;
    _450 += _446;
    _450 *= _437.d2;
    _450 += _449;
    int64_t _451 = _437.data[_450];
    if (_451 > 0) 
    goto _jump1618;
    fail_assertion("non-positive loop bound");
    _jump1618:;
    // Computing bound for i
    int64_t _452;
    // Computing bound for h
    int64_t _453 = 989;
    if (_453 > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    // Computing bound for i
    int64_t _454 = -d.d0;
    if (_454 > 0) 
    goto _jump1620;
    fail_assertion("non-positive loop bound");
    _jump1620:;
    // Computing bound for j
    int64_t _455 = 448;
    if (_455 > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    _452 = 0;
    int64_t _456 = 0; // j
    int64_t _457 = 0; // i
    int64_t _458 = 0; // h
    _jump1622:; // Begin body of loop
    int64_t _459;
    // Computing bound for k
    int64_t _460 = 822;
    if (_460 > 0) 
    goto _jump1623;
    fail_assertion("non-positive loop bound");
    _jump1623:;
    _459 = 0;
    int64_t _461 = 0; // k
    _jump1624:; // Begin body of loop
    int64_t _462;
    // Computing bound for l
    int64_t _463;
    // Computing bound for l
    int64_t _464 = 438;
    if (_464 > 0) 
    goto _jump1625;
    fail_assertion("non-positive loop bound");
    _jump1625:;
    // Computing bound for m
    if (d.d1 > 0) 
    goto _jump1626;
    fail_assertion("non-positive loop bound");
    _jump1626:;
    // Computing bound for n
    if (_457 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    _463 = 0;
    int64_t _465 = 0; // n
    int64_t _466 = 0; // m
    int64_t _467 = 0; // l
    _jump1628:; // Begin body of loop
    _463 += _465;
    _465++;
    if (_465 < _457)
    goto _jump1628;
    _465 = 0;
    _466++;
    if (_466 < d.d1)
    goto _jump1628;
    _466 = 0;
    _467++;
    if (_467 < _464)
    goto _jump1628;
    // End body of loop
    if (_463 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing bound for m
    int64_t _468;
    // Computing bound for l
    if (_457 > 0) 
    goto _jump1630;
    fail_assertion("non-positive loop bound");
    _jump1630:;
    // Computing bound for m
    if (_457 > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing bound for n
    if (_461 > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    _468 = 0;
    int64_t _469 = 0; // n
    int64_t _470 = 0; // m
    int64_t _471 = 0; // l
    _jump1633:; // Begin body of loop
    _468 += _461;
    _469++;
    if (_469 < _461)
    goto _jump1633;
    _469 = 0;
    _470++;
    if (_470 < _457)
    goto _jump1633;
    _470 = 0;
    _471++;
    if (_471 < _457)
    goto _jump1633;
    // End body of loop
    if (_468 > 0) 
    goto _jump1634;
    fail_assertion("non-positive loop bound");
    _jump1634:;
    // Computing bound for n
    if (d.d0 > 0) 
    goto _jump1635;
    fail_assertion("non-positive loop bound");
    _jump1635:;
    _462 = 0;
    int64_t _472 = 0; // n
    int64_t _473 = 0; // m
    int64_t _474 = 0; // l
    _jump1636:; // Begin body of loop
    int64_t _475;
    // Computing bound for o
    if (_474 > 0) 
    goto _jump1637;
    fail_assertion("non-positive loop bound");
    _jump1637:;
    // Computing bound for p
    if (_472 > 0) 
    goto _jump1638;
    fail_assertion("non-positive loop bound");
    _jump1638:;
    _475 = 0;
    int64_t _476 = 0; // p
    int64_t _477 = 0; // o
    _jump1639:; // Begin body of loop
    _475 += _457;
    _476++;
    if (_476 < _472)
    goto _jump1639;
    _476 = 0;
    _477++;
    if (_477 < _474)
    goto _jump1639;
    // End body of loop
    _462 += _475;
    _472++;
    if (_472 < d.d0)
    goto _jump1636;
    _472 = 0;
    _473++;
    if (_473 < _468)
    goto _jump1636;
    _473 = 0;
    _474++;
    if (_474 < _463)
    goto _jump1636;
    // End body of loop
    _459 += _462;
    _461++;
    if (_461 < _460)
    goto _jump1624;
    // End body of loop
    _452 += _459;
    _456++;
    if (_456 < _455)
    goto _jump1622;
    _456 = 0;
    _457++;
    if (_457 < _454)
    goto _jump1622;
    _457 = 0;
    _458++;
    if (_458 < _453)
    goto _jump1622;
    // End body of loop
    if (_452 > 0) 
    goto _jump1640;
    fail_assertion("non-positive loop bound");
    _jump1640:;
    // Computing bound for j
    int64_t _478 = -d.d1;
    int64_t _479 = -_478;
    int64_t _480 = -_479;
    int64_t _481 = 876;
    int64_t _482 = d.d0 / _481;
    int64_t _483 = _480 * _482;
    if (_483 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    _436 = 0;
    int64_t _484 = 0; // j
    int64_t _485 = 0; // i
    int64_t _486 = 0; // h
    _jump1642:; // Begin body of loop
    bool _488 = true;
    bool _489 = !_488;
    bool _490 = !_489;
    bool _487 = _490;
    if (0 != _490)
    goto _jump1643;
    bool _492 = false;
    bool _493;
    if (!_492)
    goto _jump1644;
    bool _494 = false;
    _493 = _494;
    goto _jump1645;
    _jump1644:;
    bool _495 = true;
    _493 = _495;
    _jump1645:;
    bool _491 = _493;
    if (0 == _493)
    goto _jump1646;
    bool _496 = false;
    _491 = _496;
    _jump1646:;
    _487 = _491;
    _jump1643:;
    double _497;
    if (!_487)
    goto _jump1647;
    double _498;
    // Computing bound for k
    if (d.d1 > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    // Computing bound for l
    if (d.d1 > 0) 
    goto _jump1649;
    fail_assertion("non-positive loop bound");
    _jump1649:;
    _498 = 0;
    int64_t _499 = 0; // l
    int64_t _500 = 0; // k
    _jump1650:; // Begin body of loop
    double _501 = 55.0;
    _498 += _501;
    _499++;
    if (_499 < d.d1)
    goto _jump1650;
    _499 = 0;
    _500++;
    if (_500 < d.d1)
    goto _jump1650;
    // End body of loop
    double _502 = 74.0;
    double _503 = _498 + _502;
    double _504 = 57.0;
    double _505 = _503 / _504;
    _497 = _505;
    goto _jump1651;
    _jump1647:;
    bool _507 = true;
    bool _506 = _507;
    if (0 == _507)
    goto _jump1652;
    int64_t _508 = 387;
    bool _509 = _508 != _484;
    _506 = _509;
    _jump1652:;
    double _510;
    if (!_506)
    goto _jump1653;
    double _511 = 53.0;
    _510 = _511;
    goto _jump1654;
    _jump1653:;
    double _512 = 30.0;
    double _513 = -_512;
    _510 = _513;
    _jump1654:;
    _497 = _510;
    _jump1651:;
    _436 += _497;
    _484++;
    if (_484 < _483)
    goto _jump1642;
    _484 = 0;
    _485++;
    if (_485 < _452)
    goto _jump1642;
    _485 = 0;
    _486++;
    if (_486 < _451)
    goto _jump1642;
    // End body of loop
    _426 = _436;
    _jump1607:;
    rgba _514 = { _287, _307, _394, _426 };
    _a2__a1_int64_t _515;
    // Computing bound for i
    int64_t _516 = 622;
    _515.d0 = _516;
    if (_516 > 0) 
    goto _jump1655;
    fail_assertion("non-positive loop bound");
    _jump1655:;
    // Computing bound for j
    int64_t _517;
    // Computing bound for i
    int64_t _518;
    // Computing bound for i
    int64_t _519 = 69;
    if (_519 > 0) 
    goto _jump1656;
    fail_assertion("non-positive loop bound");
    _jump1656:;
    // Computing bound for j
    int64_t _520;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    _520 = 0;
    int64_t _521 = 0; // i
    _jump1658:; // Begin body of loop
    _520 += d.d0;
    _521++;
    if (_521 < d.d0)
    goto _jump1658;
    // End body of loop
    if (_520 > 0) 
    goto _jump1659;
    fail_assertion("non-positive loop bound");
    _jump1659:;
    _518 = 0;
    int64_t _522 = 0; // j
    int64_t _523 = 0; // i
    _jump1660:; // Begin body of loop
    _518 += _522;
    _522++;
    if (_522 < _520)
    goto _jump1660;
    _522 = 0;
    _523++;
    if (_523 < _519)
    goto _jump1660;
    // End body of loop
    if (_518 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    _517 = 0;
    int64_t _524 = 0; // i
    _jump1662:; // Begin body of loop
    _517 += d.d0;
    _524++;
    if (_524 < _518)
    goto _jump1662;
    // End body of loop
    int64_t _525 = 918;
    _a1_int64_t _526;
    _526.d0 = 2;
    _526.data = jpl_alloc(sizeof(int64_t) * 2);
    _526.data[0] = _517;
    _526.data[1] = _525;
    bool _527 = true;
    bool _528 = !_527;
    _a2_int64_t _529;
    if (!_528)
    goto _jump1663;
    _a2_int64_t _530;
    // Computing bound for i
    int64_t _531 = 917;
    _530.d0 = _531;
    if (_531 > 0) 
    goto _jump1664;
    fail_assertion("non-positive loop bound");
    _jump1664:;
    // Computing bound for j
    int64_t _532 = 399;
    _530.d1 = _532;
    if (_532 > 0) 
    goto _jump1665;
    fail_assertion("non-positive loop bound");
    _jump1665:;
    // Computing total size of heap memory to allocate
    int64_t _533 = 1;
    _533 *= _531;
    _533 *= _532;
    _533 *= sizeof(int64_t);
    _530.data = jpl_alloc(_533);
    int64_t _534 = 0; // j
    int64_t _535 = 0; // i
    _jump1666:; // Begin body of loop
    int64_t _536 = 0;
    _536 *= _530.d0;
    _536 += _535;
    _536 *= _530.d1;
    _536 += _534;
    _530.data[_536] = d.d1;
    _534++;
    if (_534 < _532)
    goto _jump1666;
    _534 = 0;
    _535++;
    if (_535 < _531)
    goto _jump1666;
    // End body of loop
    _529 = _530;
    goto _jump1667;
    _jump1663:;
    _a2_int64_t _537;
    // Computing bound for i
    int64_t _538 = -d.d1;
    _537.d0 = _538;
    if (_538 > 0) 
    goto _jump1668;
    fail_assertion("non-positive loop bound");
    _jump1668:;
    // Computing bound for j
    _537.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump1669;
    fail_assertion("non-positive loop bound");
    _jump1669:;
    // Computing total size of heap memory to allocate
    int64_t _539 = 1;
    _539 *= _538;
    _539 *= d.d1;
    _539 *= sizeof(int64_t);
    _537.data = jpl_alloc(_539);
    int64_t _540 = 0; // j
    int64_t _541 = 0; // i
    _jump1670:; // Begin body of loop
    int64_t _542 = 0;
    _542 *= _537.d0;
    _542 += _541;
    _542 *= _537.d1;
    _542 += _540;
    _537.data[_542] = _541;
    _540++;
    if (_540 < d.d1)
    goto _jump1670;
    _540 = 0;
    _541++;
    if (_541 < _538)
    goto _jump1670;
    // End body of loop
    _529 = _537;
    _jump1667:;
    bool _543 = true;
    _a2__a1_int64_t _544;
    if (!_543)
    goto _jump1671;
    _544 = d;
    goto _jump1672;
    _jump1671:;
    _544 = d;
    _jump1672:;
    _a1_int64_t _545 = c(_544, g);
    if (d.d1 >= 0)
    goto _jump1673;
    fail_assertion("negative array index");
    _jump1673:;
    if (d.d1 < _545.d0)
    goto _jump1674;
    fail_assertion("index too large");
    _jump1674:;
    int64_t _546 = 0;
    _546 *= _545.d0;
    _546 += d.d1;
    int64_t _547 = _545.data[_546];
    int64_t _548;
    // Computing bound for i
    int64_t _549 = 535;
    if (_549 > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    // Computing bound for j
    int64_t _550;
    // Computing bound for i
    int64_t _551 = -d.d0;
    if (_551 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing bound for j
    int64_t _552 = 539;
    if (_552 > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    // Computing bound for k
    if (d.d1 > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    _550 = 0;
    int64_t _553 = 0; // k
    int64_t _554 = 0; // j
    int64_t _555 = 0; // i
    _jump1679:; // Begin body of loop
    _550 += d.d1;
    _553++;
    if (_553 < d.d1)
    goto _jump1679;
    _553 = 0;
    _554++;
    if (_554 < _552)
    goto _jump1679;
    _554 = 0;
    _555++;
    if (_555 < _551)
    goto _jump1679;
    // End body of loop
    if (_550 > 0) 
    goto _jump1680;
    fail_assertion("non-positive loop bound");
    _jump1680:;
    _548 = 0;
    int64_t _556 = 0; // j
    int64_t _557 = 0; // i
    _jump1681:; // Begin body of loop
    _548 += d.d1;
    _556++;
    if (_556 < _550)
    goto _jump1681;
    _556 = 0;
    _557++;
    if (_557 < _549)
    goto _jump1681;
    // End body of loop
    if (_547 >= 0)
    goto _jump1682;
    fail_assertion("negative array index");
    _jump1682:;
    if (_547 < _529.d0)
    goto _jump1683;
    fail_assertion("index too large");
    _jump1683:;
    if (_548 >= 0)
    goto _jump1684;
    fail_assertion("negative array index");
    _jump1684:;
    if (_548 < _529.d1)
    goto _jump1685;
    fail_assertion("index too large");
    _jump1685:;
    int64_t _558 = 0;
    _558 *= _529.d0;
    _558 += _547;
    _558 *= _529.d1;
    _558 += _548;
    int64_t _559 = _529.data[_558];
    if (_559 >= 0)
    goto _jump1686;
    fail_assertion("negative array index");
    _jump1686:;
    if (_559 < _526.d0)
    goto _jump1687;
    fail_assertion("index too large");
    _jump1687:;
    int64_t _560 = 0;
    _560 *= _526.d0;
    _560 += _559;
    int64_t _561 = _526.data[_560];
    _515.d1 = _561;
    if (_561 > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing total size of heap memory to allocate
    int64_t _562 = 1;
    _562 *= _516;
    _562 *= _561;
    _562 *= sizeof(_a1_int64_t);
    _515.data = jpl_alloc(_562);
    int64_t _563 = 0; // j
    int64_t _564 = 0; // i
    _jump1689:; // Begin body of loop
    int64_t _565 = 845;
    if (_564 >= 0)
    goto _jump1690;
    fail_assertion("negative array index");
    _jump1690:;
    if (_564 < d.d0)
    goto _jump1691;
    fail_assertion("index too large");
    _jump1691:;
    if (_565 >= 0)
    goto _jump1692;
    fail_assertion("negative array index");
    _jump1692:;
    if (_565 < d.d1)
    goto _jump1693;
    fail_assertion("index too large");
    _jump1693:;
    int64_t _566 = 0;
    _566 *= d.d0;
    _566 += _564;
    _566 *= d.d1;
    _566 += _565;
    _a1_int64_t _567 = d.data[_566];
    int64_t _568 = 0;
    _568 *= _515.d0;
    _568 += _564;
    _568 *= _515.d1;
    _568 += _563;
    _515.data[_568] = _567;
    _563++;
    if (_563 < _561)
    goto _jump1689;
    _563 = 0;
    _564++;
    if (_564 < _516)
    goto _jump1689;
    // End body of loop
    bool _569 = false;
    void_t _570;
    if (!_569)
    goto _jump1694;
    _a3_bool _571;
    // Computing bound for i
    _571.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump1695;
    fail_assertion("non-positive loop bound");
    _jump1695:;
    // Computing bound for j
    int64_t _572 = 605;
    _571.d1 = _572;
    if (_572 > 0) 
    goto _jump1696;
    fail_assertion("non-positive loop bound");
    _jump1696:;
    // Computing bound for k
    _571.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1697;
    fail_assertion("non-positive loop bound");
    _jump1697:;
    // Computing total size of heap memory to allocate
    int64_t _573 = 1;
    _573 *= d.d0;
    _573 *= _572;
    _573 *= d.d0;
    _573 *= sizeof(bool);
    _571.data = jpl_alloc(_573);
    int64_t _574 = 0; // k
    int64_t _575 = 0; // j
    int64_t _576 = 0; // i
    _jump1698:; // Begin body of loop
    int64_t _577 = 326;
    bool _578 = _574 <= _577;
    int64_t _579 = 0;
    _579 *= _571.d0;
    _579 += _576;
    _579 *= _571.d1;
    _579 += _575;
    _579 *= _571.d2;
    _579 += _574;
    _571.data[_579] = _578;
    _574++;
    if (_574 < d.d0)
    goto _jump1698;
    _574 = 0;
    _575++;
    if (_575 < _572)
    goto _jump1698;
    _575 = 0;
    _576++;
    if (_576 < d.d0)
    goto _jump1698;
    // End body of loop
    _a1_int64_t _580;
    _580.d0 = 2;
    _580.data = jpl_alloc(sizeof(int64_t) * 2);
    _580.data[0] = d.d0;
    _580.data[1] = d.d1;
    int64_t _581 = -d.d1;
    if (_581 >= 0)
    goto _jump1699;
    fail_assertion("negative array index");
    _jump1699:;
    if (_581 < _580.d0)
    goto _jump1700;
    fail_assertion("index too large");
    _jump1700:;
    int64_t _582 = 0;
    _582 *= _580.d0;
    _582 += _581;
    int64_t _583 = _580.data[_582];
    int64_t _584 = -_583;
    int64_t _585 = 952;
    int64_t _586 = _585 % d.d1;
    int64_t _587 = 872;
    bool _588 = _586 >= _587;
    int64_t _589;
    if (!_588)
    goto _jump1701;
    int64_t _590 = 210;
    int64_t _591 = d.d1 % _590;
    int64_t _592 = d.d0 - _591;
    _589 = _592;
    goto _jump1702;
    _jump1701:;
    _589 = d.d1;
    _jump1702:;
    int64_t _593 = 528;
    int64_t _594 = 144;
    int64_t _595 = _593 / _594;
    if (_584 >= 0)
    goto _jump1703;
    fail_assertion("negative array index");
    _jump1703:;
    if (_584 < _571.d0)
    goto _jump1704;
    fail_assertion("index too large");
    _jump1704:;
    if (_589 >= 0)
    goto _jump1705;
    fail_assertion("negative array index");
    _jump1705:;
    if (_589 < _571.d1)
    goto _jump1706;
    fail_assertion("index too large");
    _jump1706:;
    if (_595 >= 0)
    goto _jump1707;
    fail_assertion("negative array index");
    _jump1707:;
    if (_595 < _571.d2)
    goto _jump1708;
    fail_assertion("index too large");
    _jump1708:;
    int64_t _596 = 0;
    _596 *= _571.d0;
    _596 += _584;
    _596 *= _571.d1;
    _596 += _589;
    _596 *= _571.d2;
    _596 += _595;
    bool _597 = _571.data[_596];
    void_t _598;
    if (!_597)
    goto _jump1709;
    _a3_void_t _599;
    // Computing bound for i
    int64_t _600 = 575;
    int64_t _601 = _600 + d.d1;
    _599.d0 = _601;
    if (_601 > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    // Computing bound for j
    int64_t _602 = 248;
    _599.d1 = _602;
    if (_602 > 0) 
    goto _jump1711;
    fail_assertion("non-positive loop bound");
    _jump1711:;
    // Computing bound for k
    _599.d2 = d.d1;
    if (d.d1 > 0) 
    goto _jump1712;
    fail_assertion("non-positive loop bound");
    _jump1712:;
    // Computing total size of heap memory to allocate
    int64_t _603 = 1;
    _603 *= _601;
    _603 *= _602;
    _603 *= d.d1;
    _603 *= sizeof(void_t);
    _599.data = jpl_alloc(_603);
    int64_t _604 = 0; // k
    int64_t _605 = 0; // j
    int64_t _606 = 0; // i
    _jump1713:; // Begin body of loop
    _a1_void_t _607;
    _607.d0 = 1;
    _607.data = jpl_alloc(sizeof(void_t) * 1);
    _607.data[0] = g;
    int64_t _608 = -d.d0;
    if (_608 >= 0)
    goto _jump1714;
    fail_assertion("negative array index");
    _jump1714:;
    if (_608 < _607.d0)
    goto _jump1715;
    fail_assertion("index too large");
    _jump1715:;
    int64_t _609 = 0;
    _609 *= _607.d0;
    _609 += _608;
    void_t _610 = _607.data[_609];
    int64_t _611 = 0;
    _611 *= _599.d0;
    _611 += _606;
    _611 *= _599.d1;
    _611 += _605;
    _611 *= _599.d2;
    _611 += _604;
    _599.data[_611] = _610;
    _604++;
    if (_604 < d.d1)
    goto _jump1713;
    _604 = 0;
    _605++;
    if (_605 < _602)
    goto _jump1713;
    _605 = 0;
    _606++;
    if (_606 < _601)
    goto _jump1713;
    // End body of loop
    if (d.d0 >= 0)
    goto _jump1716;
    fail_assertion("negative array index");
    _jump1716:;
    if (d.d0 < _599.d0)
    goto _jump1717;
    fail_assertion("index too large");
    _jump1717:;
    if (d.d0 >= 0)
    goto _jump1718;
    fail_assertion("negative array index");
    _jump1718:;
    if (d.d0 < _599.d1)
    goto _jump1719;
    fail_assertion("index too large");
    _jump1719:;
    if (d.d0 >= 0)
    goto _jump1720;
    fail_assertion("negative array index");
    _jump1720:;
    if (d.d0 < _599.d2)
    goto _jump1721;
    fail_assertion("index too large");
    _jump1721:;
    int64_t _612 = 0;
    _612 *= _599.d0;
    _612 += d.d0;
    _612 *= _599.d1;
    _612 += d.d0;
    _612 *= _599.d2;
    _612 += d.d0;
    void_t _613 = _599.data[_612];
    _598 = _613;
    goto _jump1722;
    _jump1709:;
    _a1_rgba _614;
    _614.d0 = 1;
    _614.data = jpl_alloc(sizeof(rgba) * 1);
    _614.data[0] = _514;
    if (d.d0 >= 0)
    goto _jump1723;
    fail_assertion("negative array index");
    _jump1723:;
    if (d.d0 < _614.d0)
    goto _jump1724;
    fail_assertion("index too large");
    _jump1724:;
    int64_t _615 = 0;
    _615 *= _614.d0;
    _615 += d.d0;
    rgba _616 = _614.data[_615];
    _a1_rgba _617;
    _617.d0 = 2;
    _617.data = jpl_alloc(sizeof(rgba) * 2);
    _617.data[0] = _616;
    _617.data[1] = _514;
    _a1_int64_t _618;
    // Computing bound for i
    _618.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1725;
    fail_assertion("non-positive loop bound");
    _jump1725:;
    // Computing total size of heap memory to allocate
    int64_t _619 = 1;
    _619 *= d.d1;
    _619 *= sizeof(int64_t);
    _618.data = jpl_alloc(_619);
    int64_t _620 = 0; // i
    _jump1726:; // Begin body of loop
    int64_t _621 = 0;
    _621 *= _618.d0;
    _621 += _620;
    _618.data[_621] = _620;
    _620++;
    if (_620 < d.d1)
    goto _jump1726;
    // End body of loop
    void_t _622 = b(_617, _618);
    _598 = _622;
    _jump1722:;
    _570 = _598;
    goto _jump1727;
    _jump1694:;
    double _623 = 36.0;
    double _624 = 48.0;
    double _625 = a(_514);
    double _626 = fmod(_624, _625);
    bool _627 = _623 != _626;
    bool _628 = !_627;
    void_t _629;
    if (!_628)
    goto _jump1728;
    _a2_void_t _630;
    // Computing bound for i
    int64_t _631;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1729;
    fail_assertion("non-positive loop bound");
    _jump1729:;
    _631 = 0;
    int64_t _632 = 0; // i
    _jump1730:; // Begin body of loop
    _631 += d.d0;
    _632++;
    if (_632 < d.d1)
    goto _jump1730;
    // End body of loop
    _630.d0 = _631;
    if (_631 > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    // Computing bound for j
    int64_t _633 = 694;
    int64_t _634 = d.d0 / _633;
    int64_t _635 = d.d0 % _634;
    _630.d1 = _635;
    if (_635 > 0) 
    goto _jump1732;
    fail_assertion("non-positive loop bound");
    _jump1732:;
    // Computing total size of heap memory to allocate
    int64_t _636 = 1;
    _636 *= _631;
    _636 *= _635;
    _636 *= sizeof(void_t);
    _630.data = jpl_alloc(_636);
    int64_t _637 = 0; // j
    int64_t _638 = 0; // i
    _jump1733:; // Begin body of loop
    int64_t _639 = 0;
    _639 *= _630.d0;
    _639 += _638;
    _639 *= _630.d1;
    _639 += _637;
    _630.data[_639] = g;
    _637++;
    if (_637 < _635)
    goto _jump1733;
    _637 = 0;
    _638++;
    if (_638 < _631)
    goto _jump1733;
    // End body of loop
    _a3_int64_t _640;
    // Computing bound for i
    int64_t _641;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1734;
    fail_assertion("non-positive loop bound");
    _jump1734:;
    _641 = 0;
    int64_t _642 = 0; // i
    _jump1735:; // Begin body of loop
    _641 += d.d1;
    _642++;
    if (_642 < d.d1)
    goto _jump1735;
    // End body of loop
    _640.d0 = _641;
    if (_641 > 0) 
    goto _jump1736;
    fail_assertion("non-positive loop bound");
    _jump1736:;
    // Computing bound for j
    int64_t _643;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1737;
    fail_assertion("non-positive loop bound");
    _jump1737:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump1738;
    fail_assertion("non-positive loop bound");
    _jump1738:;
    _643 = 0;
    int64_t _644 = 0; // j
    int64_t _645 = 0; // i
    _jump1739:; // Begin body of loop
    _643 += _645;
    _644++;
    if (_644 < d.d1)
    goto _jump1739;
    _644 = 0;
    _645++;
    if (_645 < d.d0)
    goto _jump1739;
    // End body of loop
    _640.d1 = _643;
    if (_643 > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing bound for k
    int64_t _646 = 438;
    int64_t _647 = 408;
    int64_t _648 = _646 % _647;
    _640.d2 = _648;
    if (_648 > 0) 
    goto _jump1741;
    fail_assertion("non-positive loop bound");
    _jump1741:;
    // Computing total size of heap memory to allocate
    int64_t _649 = 1;
    _649 *= _641;
    _649 *= _643;
    _649 *= _648;
    _649 *= sizeof(int64_t);
    _640.data = jpl_alloc(_649);
    int64_t _650 = 0; // k
    int64_t _651 = 0; // j
    int64_t _652 = 0; // i
    _jump1742:; // Begin body of loop
    int64_t _653 = 864;
    int64_t _654 = 0;
    _654 *= _640.d0;
    _654 += _652;
    _654 *= _640.d1;
    _654 += _651;
    _654 *= _640.d2;
    _654 += _650;
    _640.data[_654] = _653;
    _650++;
    if (_650 < _648)
    goto _jump1742;
    _650 = 0;
    _651++;
    if (_651 < _643)
    goto _jump1742;
    _651 = 0;
    _652++;
    if (_652 < _641)
    goto _jump1742;
    // End body of loop
    int64_t _655 = 628;
    int64_t _656 = 930;
    if (d.d0 >= 0)
    goto _jump1743;
    fail_assertion("negative array index");
    _jump1743:;
    if (d.d0 < _640.d0)
    goto _jump1744;
    fail_assertion("index too large");
    _jump1744:;
    if (_655 >= 0)
    goto _jump1745;
    fail_assertion("negative array index");
    _jump1745:;
    if (_655 < _640.d1)
    goto _jump1746;
    fail_assertion("index too large");
    _jump1746:;
    if (_656 >= 0)
    goto _jump1747;
    fail_assertion("negative array index");
    _jump1747:;
    if (_656 < _640.d2)
    goto _jump1748;
    fail_assertion("index too large");
    _jump1748:;
    int64_t _657 = 0;
    _657 *= _640.d0;
    _657 += d.d0;
    _657 *= _640.d1;
    _657 += _655;
    _657 *= _640.d2;
    _657 += _656;
    int64_t _658 = _640.data[_657];
    int64_t _659;
    // Computing bound for i
    int64_t _660 = 786;
    if (_660 > 0) 
    goto _jump1749;
    fail_assertion("non-positive loop bound");
    _jump1749:;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump1750;
    fail_assertion("non-positive loop bound");
    _jump1750:;
    _659 = 0;
    int64_t _661 = 0; // j
    int64_t _662 = 0; // i
    _jump1751:; // Begin body of loop
    int64_t _663 = 250;
    _659 += _663;
    _661++;
    if (_661 < d.d0)
    goto _jump1751;
    _661 = 0;
    _662++;
    if (_662 < _660)
    goto _jump1751;
    // End body of loop
    int64_t _664 = 751;
    _a1_int64_t _665;
    _665.d0 = 3;
    _665.data = jpl_alloc(sizeof(int64_t) * 3);
    _665.data[0] = _659;
    _665.data[1] = d.d0;
    _665.data[2] = _664;
    if (d.d0 >= 0)
    goto _jump1752;
    fail_assertion("negative array index");
    _jump1752:;
    if (d.d0 < _665.d0)
    goto _jump1753;
    fail_assertion("index too large");
    _jump1753:;
    int64_t _666 = 0;
    _666 *= _665.d0;
    _666 += d.d0;
    int64_t _667 = _665.data[_666];
    if (_658 >= 0)
    goto _jump1754;
    fail_assertion("negative array index");
    _jump1754:;
    if (_658 < _630.d0)
    goto _jump1755;
    fail_assertion("index too large");
    _jump1755:;
    if (_667 >= 0)
    goto _jump1756;
    fail_assertion("negative array index");
    _jump1756:;
    if (_667 < _630.d1)
    goto _jump1757;
    fail_assertion("index too large");
    _jump1757:;
    int64_t _668 = 0;
    _668 *= _630.d0;
    _668 += _658;
    _668 *= _630.d1;
    _668 += _667;
    void_t _669 = _630.data[_668];
    _629 = _669;
    goto _jump1758;
    _jump1728:;
    bool _670 = false;
    void_t _671;
    if (!_670)
    goto _jump1759;
    bool _672 = true;
    void_t _673;
    if (!_672)
    goto _jump1760;
    _a1_rgba _674;
    _674.d0 = 3;
    _674.data = jpl_alloc(sizeof(rgba) * 3);
    _674.data[0] = _514;
    _674.data[1] = _514;
    _674.data[2] = _514;
    _a1_int64_t _675;
    // Computing bound for i
    int64_t _676 = 729;
    _675.d0 = _676;
    if (_676 > 0) 
    goto _jump1761;
    fail_assertion("non-positive loop bound");
    _jump1761:;
    // Computing total size of heap memory to allocate
    int64_t _677 = 1;
    _677 *= _676;
    _677 *= sizeof(int64_t);
    _675.data = jpl_alloc(_677);
    int64_t _678 = 0; // i
    _jump1762:; // Begin body of loop
    int64_t _679 = 0;
    _679 *= _675.d0;
    _679 += _678;
    _675.data[_679] = d.d0;
    _678++;
    if (_678 < _676)
    goto _jump1762;
    // End body of loop
    void_t _680 = b(_674, _675);
    _673 = _680;
    goto _jump1763;
    _jump1760:;
    _673 = g;
    _jump1763:;
    _671 = _673;
    goto _jump1764;
    _jump1759:;
    _671 = g;
    _jump1764:;
    _629 = _671;
    _jump1758:;
    _570 = _629;
    _jump1727:;
    _a1_int64_t _681 = c(_515, _570);
    return _681;
    bool _682 = true;
    _a2__a1_int64_t _683;
    if (!_682)
    goto _jump1765;
    _683 = d;
    goto _jump1766;
    _jump1765:;
    bool _684 = false;
    _a2__a1_int64_t _685;
    if (!_684)
    goto _jump1767;
    _a1__a2__a1_int64_t _686;
    _686.d0 = 2;
    _686.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 2);
    _686.data[0] = d;
    _686.data[1] = d;
    bool _687 = true;
    bool _688 = !_687;
    int64_t _689;
    if (!_688)
    goto _jump1768;
    int64_t _690;
    // Computing bound for i
    int64_t _691 = 369;
    int64_t _692 = d.d1 + _691;
    if (_692 > 0) 
    goto _jump1769;
    fail_assertion("non-positive loop bound");
    _jump1769:;
    // Computing bound for j
    int64_t _693 = 945;
    int64_t _694 = -_693;
    if (_694 > 0) 
    goto _jump1770;
    fail_assertion("non-positive loop bound");
    _jump1770:;
    // Computing bound for k
    int64_t _695 = 362;
    if (_695 > 0) 
    goto _jump1771;
    fail_assertion("non-positive loop bound");
    _jump1771:;
    _690 = 0;
    int64_t _696 = 0; // k
    int64_t _697 = 0; // j
    int64_t _698 = 0; // i
    _jump1772:; // Begin body of loop
    int64_t _699 = 90;
    _690 += _699;
    _696++;
    if (_696 < _695)
    goto _jump1772;
    _696 = 0;
    _697++;
    if (_697 < _694)
    goto _jump1772;
    _697 = 0;
    _698++;
    if (_698 < _692)
    goto _jump1772;
    // End body of loop
    _689 = _690;
    goto _jump1773;
    _jump1768:;
    int64_t _700 = -d.d1;
    _689 = _700;
    _jump1773:;
    if (_689 >= 0)
    goto _jump1774;
    fail_assertion("negative array index");
    _jump1774:;
    if (_689 < _686.d0)
    goto _jump1775;
    fail_assertion("index too large");
    _jump1775:;
    int64_t _701 = 0;
    _701 *= _686.d0;
    _701 += _689;
    _a2__a1_int64_t _702 = _686.data[_701];
    _685 = _702;
    goto _jump1776;
    _jump1767:;
    _a2__a1_int64_t _703;
    // Computing bound for i
    int64_t _704 = 575;
    _703.d0 = _704;
    if (_704 > 0) 
    goto _jump1777;
    fail_assertion("non-positive loop bound");
    _jump1777:;
    // Computing bound for j
    int64_t _705 = d.d0 + d.d0;
    _703.d1 = _705;
    if (_705 > 0) 
    goto _jump1778;
    fail_assertion("non-positive loop bound");
    _jump1778:;
    // Computing total size of heap memory to allocate
    int64_t _706 = 1;
    _706 *= _704;
    _706 *= _705;
    _706 *= sizeof(_a1_int64_t);
    _703.data = jpl_alloc(_706);
    int64_t _707 = 0; // j
    int64_t _708 = 0; // i
    _jump1779:; // Begin body of loop
    _a1_int64_t _709 = c(d, g);
    int64_t _710 = 0;
    _710 *= _703.d0;
    _710 += _708;
    _710 *= _703.d1;
    _710 += _707;
    _703.data[_710] = _709;
    _707++;
    if (_707 < _705)
    goto _jump1779;
    _707 = 0;
    _708++;
    if (_708 < _704)
    goto _jump1779;
    // End body of loop
    _a2__a1_int64_t _711;
    // Computing bound for i
    int64_t _712 = -d.d1;
    _711.d0 = _712;
    if (_712 > 0) 
    goto _jump1780;
    fail_assertion("non-positive loop bound");
    _jump1780:;
    // Computing bound for j
    _711.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump1781;
    fail_assertion("non-positive loop bound");
    _jump1781:;
    // Computing total size of heap memory to allocate
    int64_t _713 = 1;
    _713 *= _712;
    _713 *= d.d0;
    _713 *= sizeof(_a1_int64_t);
    _711.data = jpl_alloc(_713);
    int64_t _714 = 0; // j
    int64_t _715 = 0; // i
    _jump1782:; // Begin body of loop
    int64_t _716 = 581;
    int64_t _717 = 823;
    _a1_int64_t _718;
    _718.d0 = 3;
    _718.data = jpl_alloc(sizeof(int64_t) * 3);
    _718.data[0] = _716;
    _718.data[1] = _717;
    _718.data[2] = _715;
    int64_t _719 = 0;
    _719 *= _711.d0;
    _719 += _715;
    _719 *= _711.d1;
    _719 += _714;
    _711.data[_719] = _718;
    _714++;
    if (_714 < d.d0)
    goto _jump1782;
    _714 = 0;
    _715++;
    if (_715 < _712)
    goto _jump1782;
    // End body of loop
    _a1__a2__a1_int64_t _720;
    _720.d0 = 3;
    _720.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 3);
    _720.data[0] = _703;
    _720.data[1] = _711;
    _720.data[2] = d;
    int64_t _721 = -d.d1;
    if (_721 >= 0)
    goto _jump1783;
    fail_assertion("negative array index");
    _jump1783:;
    if (_721 < _720.d0)
    goto _jump1784;
    fail_assertion("index too large");
    _jump1784:;
    int64_t _722 = 0;
    _722 *= _720.d0;
    _722 += _721;
    _a2__a1_int64_t _723 = _720.data[_722];
    _685 = _723;
    _jump1776:;
    _683 = _685;
    _jump1766:;
    bool _724 = false;
    bool _725 = !_724;
    bool _726 = !_725;
    bool _727;
    if (!_726)
    goto _jump1785;
    _a1_bool _728;
    // Computing bound for i
    int64_t _729 = 538;
    _728.d0 = _729;
    if (_729 > 0) 
    goto _jump1786;
    fail_assertion("non-positive loop bound");
    _jump1786:;
    // Computing total size of heap memory to allocate
    int64_t _730 = 1;
    _730 *= _729;
    _730 *= sizeof(bool);
    _728.data = jpl_alloc(_730);
    int64_t _731 = 0; // i
    _jump1787:; // Begin body of loop
    bool _732 = true;
    int64_t _733 = 0;
    _733 *= _728.d0;
    _733 += _731;
    _728.data[_733] = _732;
    _731++;
    if (_731 < _729)
    goto _jump1787;
    // End body of loop
    int64_t _734 = 31;
    if (_734 >= 0)
    goto _jump1788;
    fail_assertion("negative array index");
    _jump1788:;
    if (_734 < _728.d0)
    goto _jump1789;
    fail_assertion("index too large");
    _jump1789:;
    int64_t _735 = 0;
    _735 *= _728.d0;
    _735 += _734;
    bool _736 = _728.data[_735];
    _727 = _736;
    goto _jump1790;
    _jump1785:;
    bool _737 = d.d0 >= d.d1;
    _727 = _737;
    _jump1790:;
    bool _738 = !_727;
    _a3_int64_t _739;
    if (!_738)
    goto _jump1791;
    _a3_int64_t _740;
    // Computing bound for i
    _a3_int64_t _741;
    // Computing bound for i
    int64_t _742 = 111;
    _741.d0 = _742;
    if (_742 > 0) 
    goto _jump1792;
    fail_assertion("non-positive loop bound");
    _jump1792:;
    // Computing bound for j
    int64_t _743 = 792;
    int64_t _744 = -_743;
    _741.d1 = _744;
    if (_744 > 0) 
    goto _jump1793;
    fail_assertion("non-positive loop bound");
    _jump1793:;
    // Computing bound for k
    int64_t _745;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1794;
    fail_assertion("non-positive loop bound");
    _jump1794:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump1795;
    fail_assertion("non-positive loop bound");
    _jump1795:;
    // Computing bound for k
    if (d.d0 > 0) 
    goto _jump1796;
    fail_assertion("non-positive loop bound");
    _jump1796:;
    _745 = 0;
    int64_t _746 = 0; // k
    int64_t _747 = 0; // j
    int64_t _748 = 0; // i
    _jump1797:; // Begin body of loop
    _745 += _747;
    _746++;
    if (_746 < d.d0)
    goto _jump1797;
    _746 = 0;
    _747++;
    if (_747 < d.d1)
    goto _jump1797;
    _747 = 0;
    _748++;
    if (_748 < d.d1)
    goto _jump1797;
    // End body of loop
    _741.d2 = _745;
    if (_745 > 0) 
    goto _jump1798;
    fail_assertion("non-positive loop bound");
    _jump1798:;
    // Computing total size of heap memory to allocate
    int64_t _749 = 1;
    _749 *= _742;
    _749 *= _744;
    _749 *= _745;
    _749 *= sizeof(int64_t);
    _741.data = jpl_alloc(_749);
    int64_t _750 = 0; // k
    int64_t _751 = 0; // j
    int64_t _752 = 0; // i
    _jump1799:; // Begin body of loop
    int64_t _753 = 0;
    _753 *= _741.d0;
    _753 += _752;
    _753 *= _741.d1;
    _753 += _751;
    _753 *= _741.d2;
    _753 += _750;
    _741.data[_753] = _752;
    _750++;
    if (_750 < _745)
    goto _jump1799;
    _750 = 0;
    _751++;
    if (_751 < _744)
    goto _jump1799;
    _751 = 0;
    _752++;
    if (_752 < _742)
    goto _jump1799;
    // End body of loop
    int64_t _754;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    _754 = 0;
    int64_t _755 = 0; // i
    _jump1801:; // Begin body of loop
    _754 += d.d1;
    _755++;
    if (_755 < d.d1)
    goto _jump1801;
    // End body of loop
    int64_t _756 = _754 + d.d0;
    int64_t _757 = 618;
    int64_t _758 = -_757;
    int64_t _759 = 106;
    int64_t _760 = _759 + d.d0;
    if (_756 >= 0)
    goto _jump1802;
    fail_assertion("negative array index");
    _jump1802:;
    if (_756 < _741.d0)
    goto _jump1803;
    fail_assertion("index too large");
    _jump1803:;
    if (_758 >= 0)
    goto _jump1804;
    fail_assertion("negative array index");
    _jump1804:;
    if (_758 < _741.d1)
    goto _jump1805;
    fail_assertion("index too large");
    _jump1805:;
    if (_760 >= 0)
    goto _jump1806;
    fail_assertion("negative array index");
    _jump1806:;
    if (_760 < _741.d2)
    goto _jump1807;
    fail_assertion("index too large");
    _jump1807:;
    int64_t _761 = 0;
    _761 *= _741.d0;
    _761 += _756;
    _761 *= _741.d1;
    _761 += _758;
    _761 *= _741.d2;
    _761 += _760;
    int64_t _762 = _741.data[_761];
    _740.d0 = _762;
    if (_762 > 0) 
    goto _jump1808;
    fail_assertion("non-positive loop bound");
    _jump1808:;
    // Computing bound for j
    _740.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump1809;
    fail_assertion("non-positive loop bound");
    _jump1809:;
    // Computing bound for k
    int64_t _763 = 816;
    int64_t _764 = -_763;
    _740.d2 = _764;
    if (_764 > 0) 
    goto _jump1810;
    fail_assertion("non-positive loop bound");
    _jump1810:;
    // Computing total size of heap memory to allocate
    int64_t _765 = 1;
    _765 *= _762;
    _765 *= d.d1;
    _765 *= _764;
    _765 *= sizeof(int64_t);
    _740.data = jpl_alloc(_765);
    int64_t _766 = 0; // k
    int64_t _767 = 0; // j
    int64_t _768 = 0; // i
    _jump1811:; // Begin body of loop
    int64_t _769 = -d.d1;
    int64_t _770 = 0;
    _770 *= _740.d0;
    _770 += _768;
    _770 *= _740.d1;
    _770 += _767;
    _770 *= _740.d2;
    _770 += _766;
    _740.data[_770] = _769;
    _766++;
    if (_766 < _764)
    goto _jump1811;
    _766 = 0;
    _767++;
    if (_767 < d.d1)
    goto _jump1811;
    _767 = 0;
    _768++;
    if (_768 < _762)
    goto _jump1811;
    // End body of loop
    _739 = _740;
    goto _jump1812;
    _jump1791:;
    _a3_int64_t _771;
    // Computing bound for i
    _771.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump1813;
    fail_assertion("non-positive loop bound");
    _jump1813:;
    // Computing bound for j
    int64_t _772;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1814;
    fail_assertion("non-positive loop bound");
    _jump1814:;
    // Computing bound for j
    int64_t _773;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1815;
    fail_assertion("non-positive loop bound");
    _jump1815:;
    // Computing bound for j
    int64_t _774 = 998;
    if (_774 > 0) 
    goto _jump1816;
    fail_assertion("non-positive loop bound");
    _jump1816:;
    _773 = 0;
    int64_t _775 = 0; // j
    int64_t _776 = 0; // i
    _jump1817:; // Begin body of loop
    _773 += _776;
    _775++;
    if (_775 < _774)
    goto _jump1817;
    _775 = 0;
    _776++;
    if (_776 < d.d1)
    goto _jump1817;
    // End body of loop
    int64_t _777 = -_773;
    if (_777 > 0) 
    goto _jump1818;
    fail_assertion("non-positive loop bound");
    _jump1818:;
    // Computing bound for k
    int64_t _778;
    // Computing bound for i
    int64_t _779 = 146;
    int64_t _780 = -_779;
    if (_780 > 0) 
    goto _jump1819;
    fail_assertion("non-positive loop bound");
    _jump1819:;
    // Computing bound for j
    int64_t _781 = 348;
    if (_781 > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing bound for k
    int64_t _782 = 76;
    if (_782 > 0) 
    goto _jump1821;
    fail_assertion("non-positive loop bound");
    _jump1821:;
    _778 = 0;
    int64_t _783 = 0; // k
    int64_t _784 = 0; // j
    int64_t _785 = 0; // i
    _jump1822:; // Begin body of loop
    _778 += _784;
    _783++;
    if (_783 < _782)
    goto _jump1822;
    _783 = 0;
    _784++;
    if (_784 < _781)
    goto _jump1822;
    _784 = 0;
    _785++;
    if (_785 < _780)
    goto _jump1822;
    // End body of loop
    if (_778 > 0) 
    goto _jump1823;
    fail_assertion("non-positive loop bound");
    _jump1823:;
    _772 = 0;
    int64_t _786 = 0; // k
    int64_t _787 = 0; // j
    int64_t _788 = 0; // i
    _jump1824:; // Begin body of loop
    _772 += _788;
    _786++;
    if (_786 < _778)
    goto _jump1824;
    _786 = 0;
    _787++;
    if (_787 < _777)
    goto _jump1824;
    _787 = 0;
    _788++;
    if (_788 < d.d0)
    goto _jump1824;
    // End body of loop
    _771.d1 = _772;
    if (_772 > 0) 
    goto _jump1825;
    fail_assertion("non-positive loop bound");
    _jump1825:;
    // Computing bound for k
    _a3_int64_t _789;
    // Computing bound for i
    _789.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1826;
    fail_assertion("non-positive loop bound");
    _jump1826:;
    // Computing bound for j
    int64_t _790 = -d.d1;
    _789.d1 = _790;
    if (_790 > 0) 
    goto _jump1827;
    fail_assertion("non-positive loop bound");
    _jump1827:;
    // Computing bound for k
    int64_t _791;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1828;
    fail_assertion("non-positive loop bound");
    _jump1828:;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump1829;
    fail_assertion("non-positive loop bound");
    _jump1829:;
    _791 = 0;
    int64_t _792 = 0; // j
    int64_t _793 = 0; // i
    _jump1830:; // Begin body of loop
    _791 += _792;
    _792++;
    if (_792 < d.d0)
    goto _jump1830;
    _792 = 0;
    _793++;
    if (_793 < d.d1)
    goto _jump1830;
    // End body of loop
    _789.d2 = _791;
    if (_791 > 0) 
    goto _jump1831;
    fail_assertion("non-positive loop bound");
    _jump1831:;
    // Computing total size of heap memory to allocate
    int64_t _794 = 1;
    _794 *= d.d1;
    _794 *= _790;
    _794 *= _791;
    _794 *= sizeof(int64_t);
    _789.data = jpl_alloc(_794);
    int64_t _795 = 0; // k
    int64_t _796 = 0; // j
    int64_t _797 = 0; // i
    _jump1832:; // Begin body of loop
    int64_t _798 = 0;
    _798 *= _789.d0;
    _798 += _797;
    _798 *= _789.d1;
    _798 += _796;
    _798 *= _789.d2;
    _798 += _795;
    _789.data[_798] = d.d1;
    _795++;
    if (_795 < _791)
    goto _jump1832;
    _795 = 0;
    _796++;
    if (_796 < _790)
    goto _jump1832;
    _796 = 0;
    _797++;
    if (_797 < d.d1)
    goto _jump1832;
    // End body of loop
    int64_t _799 = 545;
    int64_t _800 = -d.d1;
    int64_t _801 = _799 % _800;
    bool _802 = false;
    int64_t _803;
    if (!_802)
    goto _jump1833;
    _803 = d.d1;
    goto _jump1834;
    _jump1833:;
    _803 = d.d1;
    _jump1834:;
    if (_801 >= 0)
    goto _jump1835;
    fail_assertion("negative array index");
    _jump1835:;
    if (_801 < _789.d0)
    goto _jump1836;
    fail_assertion("index too large");
    _jump1836:;
    if (_803 >= 0)
    goto _jump1837;
    fail_assertion("negative array index");
    _jump1837:;
    if (_803 < _789.d1)
    goto _jump1838;
    fail_assertion("index too large");
    _jump1838:;
    if (d.d1 >= 0)
    goto _jump1839;
    fail_assertion("negative array index");
    _jump1839:;
    if (d.d1 < _789.d2)
    goto _jump1840;
    fail_assertion("index too large");
    _jump1840:;
    int64_t _804 = 0;
    _804 *= _789.d0;
    _804 += _801;
    _804 *= _789.d1;
    _804 += _803;
    _804 *= _789.d2;
    _804 += d.d1;
    int64_t _805 = _789.data[_804];
    _771.d2 = _805;
    if (_805 > 0) 
    goto _jump1841;
    fail_assertion("non-positive loop bound");
    _jump1841:;
    // Computing total size of heap memory to allocate
    int64_t _806 = 1;
    _806 *= d.d0;
    _806 *= _772;
    _806 *= _805;
    _806 *= sizeof(int64_t);
    _771.data = jpl_alloc(_806);
    int64_t _807 = 0; // k
    int64_t _808 = 0; // j
    int64_t _809 = 0; // i
    _jump1842:; // Begin body of loop
    int64_t _810 = 0;
    _810 *= _771.d0;
    _810 += _809;
    _810 *= _771.d1;
    _810 += _808;
    _810 *= _771.d2;
    _810 += _807;
    _771.data[_810] = _808;
    _807++;
    if (_807 < _805)
    goto _jump1842;
    _807 = 0;
    _808++;
    if (_808 < _772)
    goto _jump1842;
    _808 = 0;
    _809++;
    if (_809 < d.d0)
    goto _jump1842;
    // End body of loop
    _739 = _771;
    _jump1812:;
    _a3_bool _811;
    // Computing bound for i
    bool _812 = true;
    int64_t _813;
    if (!_812)
    goto _jump1843;
    _813 = d.d0;
    goto _jump1844;
    _jump1843:;
    int64_t _814 = 229;
    _813 = _814;
    _jump1844:;
    _811.d0 = _813;
    if (_813 > 0) 
    goto _jump1845;
    fail_assertion("non-positive loop bound");
    _jump1845:;
    // Computing bound for j
    _811.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump1846;
    fail_assertion("non-positive loop bound");
    _jump1846:;
    // Computing bound for k
    _811.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1847;
    fail_assertion("non-positive loop bound");
    _jump1847:;
    // Computing total size of heap memory to allocate
    int64_t _815 = 1;
    _815 *= _813;
    _815 *= d.d0;
    _815 *= d.d0;
    _815 *= sizeof(bool);
    _811.data = jpl_alloc(_815);
    int64_t _816 = 0; // k
    int64_t _817 = 0; // j
    int64_t _818 = 0; // i
    _jump1848:; // Begin body of loop
    bool _819 = false;
    int64_t _820 = 0;
    _820 *= _811.d0;
    _820 += _818;
    _820 *= _811.d1;
    _820 += _817;
    _820 *= _811.d2;
    _820 += _816;
    _811.data[_820] = _819;
    _816++;
    if (_816 < d.d0)
    goto _jump1848;
    _816 = 0;
    _817++;
    if (_817 < d.d0)
    goto _jump1848;
    _817 = 0;
    _818++;
    if (_818 < _813)
    goto _jump1848;
    // End body of loop
    _a1_int64_t _821 = c(d, g);
    int64_t _822 = -d.d0;
    if (_822 >= 0)
    goto _jump1849;
    fail_assertion("negative array index");
    _jump1849:;
    if (_822 < _821.d0)
    goto _jump1850;
    fail_assertion("index too large");
    _jump1850:;
    int64_t _823 = 0;
    _823 *= _821.d0;
    _823 += _822;
    int64_t _824 = _821.data[_823];
    int64_t _825 = 543;
    if (_824 >= 0)
    goto _jump1851;
    fail_assertion("negative array index");
    _jump1851:;
    if (_824 < _811.d0)
    goto _jump1852;
    fail_assertion("index too large");
    _jump1852:;
    if (_825 >= 0)
    goto _jump1853;
    fail_assertion("negative array index");
    _jump1853:;
    if (_825 < _811.d1)
    goto _jump1854;
    fail_assertion("index too large");
    _jump1854:;
    if (d.d1 >= 0)
    goto _jump1855;
    fail_assertion("negative array index");
    _jump1855:;
    if (d.d1 < _811.d2)
    goto _jump1856;
    fail_assertion("index too large");
    _jump1856:;
    int64_t _826 = 0;
    _826 *= _811.d0;
    _826 += _824;
    _826 *= _811.d1;
    _826 += _825;
    _826 *= _811.d2;
    _826 += d.d1;
    bool _827 = _811.data[_826];
    int64_t _828;
    if (!_827)
    goto _jump1857;
    int64_t _829 = 7;
    int64_t _830 = 251;
    bool _831 = _829 != _830;
    int64_t _832 = 750;
    bool _833 = _832 == d.d1;
    bool _834 = _831 != _833;
    int64_t _835;
    if (!_834)
    goto _jump1858;
    _835 = d.d1;
    goto _jump1859;
    _jump1858:;
    _835 = d.d1;
    _jump1859:;
    _828 = _835;
    goto _jump1860;
    _jump1857:;
    int64_t _836;
    // Computing bound for i
    int64_t _837 = -d.d1;
    if (_837 > 0) 
    goto _jump1861;
    fail_assertion("non-positive loop bound");
    _jump1861:;
    // Computing bound for j
    bool _838 = true;
    int64_t _839;
    if (!_838)
    goto _jump1862;
    int64_t _840 = 112;
    _839 = _840;
    goto _jump1863;
    _jump1862:;
    int64_t _841 = 59;
    _839 = _841;
    _jump1863:;
    if (_839 > 0) 
    goto _jump1864;
    fail_assertion("non-positive loop bound");
    _jump1864:;
    _836 = 0;
    int64_t _842 = 0; // j
    int64_t _843 = 0; // i
    _jump1865:; // Begin body of loop
    _836 += d.d1;
    _842++;
    if (_842 < _839)
    goto _jump1865;
    _842 = 0;
    _843++;
    if (_843 < _837)
    goto _jump1865;
    // End body of loop
    int64_t _844;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1866;
    fail_assertion("non-positive loop bound");
    _jump1866:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump1867;
    fail_assertion("non-positive loop bound");
    _jump1867:;
    // Computing bound for k
    if (d.d1 > 0) 
    goto _jump1868;
    fail_assertion("non-positive loop bound");
    _jump1868:;
    _844 = 0;
    int64_t _845 = 0; // k
    int64_t _846 = 0; // j
    int64_t _847 = 0; // i
    _jump1869:; // Begin body of loop
    _844 += d.d0;
    _845++;
    if (_845 < d.d1)
    goto _jump1869;
    _845 = 0;
    _846++;
    if (_846 < d.d1)
    goto _jump1869;
    _846 = 0;
    _847++;
    if (_847 < d.d1)
    goto _jump1869;
    // End body of loop
    int64_t _848 = _836 + _844;
    _828 = _848;
    _jump1860:;
    int64_t _849;
    // Computing bound for i
    int64_t _850 = 387;
    _a1_int64_t _851;
    _851.d0 = 1;
    _851.data = jpl_alloc(sizeof(int64_t) * 1);
    _851.data[0] = _850;
    int64_t _852 = -d.d1;
    if (_852 >= 0)
    goto _jump1870;
    fail_assertion("negative array index");
    _jump1870:;
    if (_852 < _851.d0)
    goto _jump1871;
    fail_assertion("index too large");
    _jump1871:;
    int64_t _853 = 0;
    _853 *= _851.d0;
    _853 += _852;
    int64_t _854 = _851.data[_853];
    if (_854 > 0) 
    goto _jump1872;
    fail_assertion("non-positive loop bound");
    _jump1872:;
    _849 = 0;
    int64_t _855 = 0; // i
    _jump1873:; // Begin body of loop
    _849 += d.d0;
    _855++;
    if (_855 < _854)
    goto _jump1873;
    // End body of loop
    int64_t _856 = 423;
    int64_t _857 = 714;
    int64_t _858 = _856 * _857;
    int64_t _859 = _849 / _858;
    int64_t _860 = _828 * _859;
    int64_t _861 = 553;
    int64_t _862 = 759;
    if (_861 >= 0)
    goto _jump1874;
    fail_assertion("negative array index");
    _jump1874:;
    if (_861 < d.d0)
    goto _jump1875;
    fail_assertion("index too large");
    _jump1875:;
    if (_862 >= 0)
    goto _jump1876;
    fail_assertion("negative array index");
    _jump1876:;
    if (_862 < d.d1)
    goto _jump1877;
    fail_assertion("index too large");
    _jump1877:;
    int64_t _863 = 0;
    _863 *= d.d0;
    _863 += _861;
    _863 *= d.d1;
    _863 += _862;
    _a1_int64_t _864 = d.data[_863];
    int64_t _865 = 84;
    if (_865 >= 0)
    goto _jump1878;
    fail_assertion("negative array index");
    _jump1878:;
    if (_865 < _864.d0)
    goto _jump1879;
    fail_assertion("index too large");
    _jump1879:;
    int64_t _866 = 0;
    _866 *= _864.d0;
    _866 += _865;
    int64_t _867 = _864.data[_866];
    if (_860 >= 0)
    goto _jump1880;
    fail_assertion("negative array index");
    _jump1880:;
    if (_860 < _739.d0)
    goto _jump1881;
    fail_assertion("index too large");
    _jump1881:;
    if (d.d1 >= 0)
    goto _jump1882;
    fail_assertion("negative array index");
    _jump1882:;
    if (d.d1 < _739.d1)
    goto _jump1883;
    fail_assertion("index too large");
    _jump1883:;
    if (_867 >= 0)
    goto _jump1884;
    fail_assertion("negative array index");
    _jump1884:;
    if (_867 < _739.d2)
    goto _jump1885;
    fail_assertion("index too large");
    _jump1885:;
    int64_t _868 = 0;
    _868 *= _739.d0;
    _868 += _860;
    _868 *= _739.d1;
    _868 += d.d1;
    _868 *= _739.d2;
    _868 += _867;
    int64_t _869 = _739.data[_868];
    _a3_bool _870;
    // Computing bound for i
    _870.d0 = d.d1;
    if (d.d1 > 0) 
    goto _jump1886;
    fail_assertion("non-positive loop bound");
    _jump1886:;
    // Computing bound for j
    _a1_int64_t _871;
    // Computing bound for i
    int64_t _872;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1887;
    fail_assertion("non-positive loop bound");
    _jump1887:;
    // Computing bound for j
    int64_t _873 = 691;
    if (_873 > 0) 
    goto _jump1888;
    fail_assertion("non-positive loop bound");
    _jump1888:;
    // Computing bound for k
    if (d.d0 > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    _872 = 0;
    int64_t _874 = 0; // k
    int64_t _875 = 0; // j
    int64_t _876 = 0; // i
    _jump1890:; // Begin body of loop
    _872 += d.d1;
    _874++;
    if (_874 < d.d0)
    goto _jump1890;
    _874 = 0;
    _875++;
    if (_875 < _873)
    goto _jump1890;
    _875 = 0;
    _876++;
    if (_876 < d.d0)
    goto _jump1890;
    // End body of loop
    _871.d0 = _872;
    if (_872 > 0) 
    goto _jump1891;
    fail_assertion("non-positive loop bound");
    _jump1891:;
    // Computing total size of heap memory to allocate
    int64_t _877 = 1;
    _877 *= _872;
    _877 *= sizeof(int64_t);
    _871.data = jpl_alloc(_877);
    int64_t _878 = 0; // i
    _jump1892:; // Begin body of loop
    int64_t _879 = 96;
    int64_t _880 = 0;
    _880 *= _871.d0;
    _880 += _878;
    _871.data[_880] = _879;
    _878++;
    if (_878 < _872)
    goto _jump1892;
    // End body of loop
    if (d.d0 >= 0)
    goto _jump1893;
    fail_assertion("negative array index");
    _jump1893:;
    if (d.d0 < _871.d0)
    goto _jump1894;
    fail_assertion("index too large");
    _jump1894:;
    int64_t _881 = 0;
    _881 *= _871.d0;
    _881 += d.d0;
    int64_t _882 = _871.data[_881];
    _870.d1 = _882;
    if (_882 > 0) 
    goto _jump1895;
    fail_assertion("non-positive loop bound");
    _jump1895:;
    // Computing bound for k
    int64_t _883;
    // Computing bound for i
    if (d.d1 > 0) 
    goto _jump1896;
    fail_assertion("non-positive loop bound");
    _jump1896:;
    // Computing bound for j
    bool _884 = false;
    int64_t _885;
    if (!_884)
    goto _jump1897;
    _885 = d.d0;
    goto _jump1898;
    _jump1897:;
    _885 = d.d0;
    _jump1898:;
    int64_t _886 = -_885;
    if (_886 > 0) 
    goto _jump1899;
    fail_assertion("non-positive loop bound");
    _jump1899:;
    _883 = 0;
    int64_t _887 = 0; // j
    int64_t _888 = 0; // i
    _jump1900:; // Begin body of loop
    _883 += d.d1;
    _887++;
    if (_887 < _886)
    goto _jump1900;
    _887 = 0;
    _888++;
    if (_888 < d.d1)
    goto _jump1900;
    // End body of loop
    _870.d2 = _883;
    if (_883 > 0) 
    goto _jump1901;
    fail_assertion("non-positive loop bound");
    _jump1901:;
    // Computing total size of heap memory to allocate
    int64_t _889 = 1;
    _889 *= d.d1;
    _889 *= _882;
    _889 *= _883;
    _889 *= sizeof(bool);
    _870.data = jpl_alloc(_889);
    int64_t _890 = 0; // k
    int64_t _891 = 0; // j
    int64_t _892 = 0; // i
    _jump1902:; // Begin body of loop
    _a1_bool _893;
    // Computing bound for l
    _893.d0 = _892;
    if (_892 > 0) 
    goto _jump1903;
    fail_assertion("non-positive loop bound");
    _jump1903:;
    // Computing total size of heap memory to allocate
    int64_t _894 = 1;
    _894 *= _892;
    _894 *= sizeof(bool);
    _893.data = jpl_alloc(_894);
    int64_t _895 = 0; // l
    _jump1904:; // Begin body of loop
    bool _896 = _891 < _891;
    int64_t _897 = 0;
    _897 *= _893.d0;
    _897 += _895;
    _893.data[_897] = _896;
    _895++;
    if (_895 < _892)
    goto _jump1904;
    // End body of loop
    if (_890 >= 0)
    goto _jump1905;
    fail_assertion("negative array index");
    _jump1905:;
    if (_890 < _893.d0)
    goto _jump1906;
    fail_assertion("index too large");
    _jump1906:;
    int64_t _898 = 0;
    _898 *= _893.d0;
    _898 += _890;
    bool _899 = _893.data[_898];
    int64_t _900 = 0;
    _900 *= _870.d0;
    _900 += _892;
    _900 *= _870.d1;
    _900 += _891;
    _900 *= _870.d2;
    _900 += _890;
    _870.data[_900] = _899;
    _890++;
    if (_890 < _883)
    goto _jump1902;
    _890 = 0;
    _891++;
    if (_891 < _882)
    goto _jump1902;
    _891 = 0;
    _892++;
    if (_892 < d.d1)
    goto _jump1902;
    // End body of loop
    int64_t _901;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump1907;
    fail_assertion("non-positive loop bound");
    _jump1907:;
    // Computing bound for j
    int64_t _902;
    // Computing bound for i
    bool _903 = false;
    int64_t _904;
    if (!_903)
    goto _jump1908;
    _904 = d.d0;
    goto _jump1909;
    _jump1908:;
    int64_t _905 = 674;
    _904 = _905;
    _jump1909:;
    if (_904 > 0) 
    goto _jump1910;
    fail_assertion("non-positive loop bound");
    _jump1910:;
    _902 = 0;
    int64_t _906 = 0; // i
    _jump1911:; // Begin body of loop
    int64_t _907 = -d.d0;
    _902 += _907;
    _906++;
    if (_906 < _904)
    goto _jump1911;
    // End body of loop
    if (_902 > 0) 
    goto _jump1912;
    fail_assertion("non-positive loop bound");
    _jump1912:;
    _901 = 0;
    int64_t _908 = 0; // j
    int64_t _909 = 0; // i
    _jump1913:; // Begin body of loop
    int64_t _910 = _908 / d.d0;
    _901 += _910;
    _908++;
    if (_908 < _902)
    goto _jump1913;
    _908 = 0;
    _909++;
    if (_909 < d.d0)
    goto _jump1913;
    // End body of loop
    int64_t _911;
    // Computing bound for i
    int64_t _912 = 789;
    int64_t _913 = -_912;
    if (_913 > 0) 
    goto _jump1914;
    fail_assertion("non-positive loop bound");
    _jump1914:;
    _911 = 0;
    int64_t _914 = 0; // i
    _jump1915:; // Begin body of loop
    int64_t _915 = 949;
    _911 += _915;
    _914++;
    if (_914 < _913)
    goto _jump1915;
    // End body of loop
    int64_t _916 = -_911;
    int64_t _917 = 342;
    if (_901 >= 0)
    goto _jump1916;
    fail_assertion("negative array index");
    _jump1916:;
    if (_901 < _870.d0)
    goto _jump1917;
    fail_assertion("index too large");
    _jump1917:;
    if (_916 >= 0)
    goto _jump1918;
    fail_assertion("negative array index");
    _jump1918:;
    if (_916 < _870.d1)
    goto _jump1919;
    fail_assertion("index too large");
    _jump1919:;
    if (_917 >= 0)
    goto _jump1920;
    fail_assertion("negative array index");
    _jump1920:;
    if (_917 < _870.d2)
    goto _jump1921;
    fail_assertion("index too large");
    _jump1921:;
    int64_t _918 = 0;
    _918 *= _870.d0;
    _918 += _901;
    _918 *= _870.d1;
    _918 += _916;
    _918 *= _870.d2;
    _918 += _917;
    bool _919 = _870.data[_918];
    int64_t _920;
    if (!_919)
    goto _jump1922;
    _920 = d.d1;
    goto _jump1923;
    _jump1922:;
    bool _921 = true;
    _a3_int64_t _922;
    if (!_921)
    goto _jump1924;
    _a3_int64_t _923;
    // Computing bound for i
    int64_t _924 = 716;
    int64_t _925 = -_924;
    _923.d0 = _925;
    if (_925 > 0) 
    goto _jump1925;
    fail_assertion("non-positive loop bound");
    _jump1925:;
    // Computing bound for j
    int64_t _926 = 544;
    _923.d1 = _926;
    if (_926 > 0) 
    goto _jump1926;
    fail_assertion("non-positive loop bound");
    _jump1926:;
    // Computing bound for k
    _923.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump1927;
    fail_assertion("non-positive loop bound");
    _jump1927:;
    // Computing total size of heap memory to allocate
    int64_t _927 = 1;
    _927 *= _925;
    _927 *= _926;
    _927 *= d.d0;
    _927 *= sizeof(int64_t);
    _923.data = jpl_alloc(_927);
    int64_t _928 = 0; // k
    int64_t _929 = 0; // j
    int64_t _930 = 0; // i
    _jump1928:; // Begin body of loop
    int64_t _931 = d.d1 / _928;
    int64_t _932 = 0;
    _932 *= _923.d0;
    _932 += _930;
    _932 *= _923.d1;
    _932 += _929;
    _932 *= _923.d2;
    _932 += _928;
    _923.data[_932] = _931;
    _928++;
    if (_928 < d.d0)
    goto _jump1928;
    _928 = 0;
    _929++;
    if (_929 < _926)
    goto _jump1928;
    _929 = 0;
    _930++;
    if (_930 < _925)
    goto _jump1928;
    // End body of loop
    _922 = _923;
    goto _jump1929;
    _jump1924:;
    _a3_int64_t _933;
    // Computing bound for i
    int64_t _934 = 127;
    int64_t _935 = -_934;
    _933.d0 = _935;
    if (_935 > 0) 
    goto _jump1930;
    fail_assertion("non-positive loop bound");
    _jump1930:;
    // Computing bound for j
    int64_t _936 = 604;
    int64_t _937 = -_936;
    _933.d1 = _937;
    if (_937 > 0) 
    goto _jump1931;
    fail_assertion("non-positive loop bound");
    _jump1931:;
    // Computing bound for k
    int64_t _938 = -d.d0;
    _933.d2 = _938;
    if (_938 > 0) 
    goto _jump1932;
    fail_assertion("non-positive loop bound");
    _jump1932:;
    // Computing total size of heap memory to allocate
    int64_t _939 = 1;
    _939 *= _935;
    _939 *= _937;
    _939 *= _938;
    _939 *= sizeof(int64_t);
    _933.data = jpl_alloc(_939);
    int64_t _940 = 0; // k
    int64_t _941 = 0; // j
    int64_t _942 = 0; // i
    _jump1933:; // Begin body of loop
    int64_t _943;
    // Computing bound for l
    if (d.d1 > 0) 
    goto _jump1934;
    fail_assertion("non-positive loop bound");
    _jump1934:;
    // Computing bound for m
    if (d.d0 > 0) 
    goto _jump1935;
    fail_assertion("non-positive loop bound");
    _jump1935:;
    // Computing bound for n
    if (_941 > 0) 
    goto _jump1936;
    fail_assertion("non-positive loop bound");
    _jump1936:;
    _943 = 0;
    int64_t _944 = 0; // n
    int64_t _945 = 0; // m
    int64_t _946 = 0; // l
    _jump1937:; // Begin body of loop
    _943 += _940;
    _944++;
    if (_944 < _941)
    goto _jump1937;
    _944 = 0;
    _945++;
    if (_945 < d.d0)
    goto _jump1937;
    _945 = 0;
    _946++;
    if (_946 < d.d1)
    goto _jump1937;
    // End body of loop
    int64_t _947 = 0;
    _947 *= _933.d0;
    _947 += _942;
    _947 *= _933.d1;
    _947 += _941;
    _947 *= _933.d2;
    _947 += _940;
    _933.data[_947] = _943;
    _940++;
    if (_940 < _938)
    goto _jump1933;
    _940 = 0;
    _941++;
    if (_941 < _937)
    goto _jump1933;
    _941 = 0;
    _942++;
    if (_942 < _935)
    goto _jump1933;
    // End body of loop
    _922 = _933;
    _jump1929:;
    int64_t _948;
    // Computing bound for i
    int64_t _949;
    // Computing bound for i
    int64_t _950 = 962;
    if (_950 > 0) 
    goto _jump1938;
    fail_assertion("non-positive loop bound");
    _jump1938:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump1939;
    fail_assertion("non-positive loop bound");
    _jump1939:;
    // Computing bound for k
    int64_t _951 = 359;
    if (_951 > 0) 
    goto _jump1940;
    fail_assertion("non-positive loop bound");
    _jump1940:;
    _949 = 0;
    int64_t _952 = 0; // k
    int64_t _953 = 0; // j
    int64_t _954 = 0; // i
    _jump1941:; // Begin body of loop
    _949 += d.d0;
    _952++;
    if (_952 < _951)
    goto _jump1941;
    _952 = 0;
    _953++;
    if (_953 < d.d1)
    goto _jump1941;
    _953 = 0;
    _954++;
    if (_954 < _950)
    goto _jump1941;
    // End body of loop
    if (_949 > 0) 
    goto _jump1942;
    fail_assertion("non-positive loop bound");
    _jump1942:;
    _948 = 0;
    int64_t _955 = 0; // i
    _jump1943:; // Begin body of loop
    _948 += d.d0;
    _955++;
    if (_955 < _949)
    goto _jump1943;
    // End body of loop
    if (d.d1 >= 0)
    goto _jump1944;
    fail_assertion("negative array index");
    _jump1944:;
    if (d.d1 < _922.d0)
    goto _jump1945;
    fail_assertion("index too large");
    _jump1945:;
    if (_948 >= 0)
    goto _jump1946;
    fail_assertion("negative array index");
    _jump1946:;
    if (_948 < _922.d1)
    goto _jump1947;
    fail_assertion("index too large");
    _jump1947:;
    if (d.d1 >= 0)
    goto _jump1948;
    fail_assertion("negative array index");
    _jump1948:;
    if (d.d1 < _922.d2)
    goto _jump1949;
    fail_assertion("index too large");
    _jump1949:;
    int64_t _956 = 0;
    _956 *= _922.d0;
    _956 += d.d1;
    _956 *= _922.d1;
    _956 += _948;
    _956 *= _922.d2;
    _956 += d.d1;
    int64_t _957 = _922.data[_956];
    int64_t _958 = -_957;
    _920 = _958;
    _jump1923:;
    if (_869 >= 0)
    goto _jump1950;
    fail_assertion("negative array index");
    _jump1950:;
    if (_869 < _683.d0)
    goto _jump1951;
    fail_assertion("index too large");
    _jump1951:;
    if (_920 >= 0)
    goto _jump1952;
    fail_assertion("negative array index");
    _jump1952:;
    if (_920 < _683.d1)
    goto _jump1953;
    fail_assertion("index too large");
    _jump1953:;
    int64_t _959 = 0;
    _959 *= _683.d0;
    _959 += _869;
    _959 *= _683.d1;
    _959 += _920;
    _a1_int64_t _960 = _683.data[_959];
    _a1__a1_int64_t _961;
    // Computing bound for k
    int64_t _962;
    // Computing bound for k
    int64_t _963 = -d.d1;
    int64_t _964 = -_963;
    if (_964 > 0) 
    goto _jump1954;
    fail_assertion("non-positive loop bound");
    _jump1954:;
    // Computing bound for l
    if (d.d1 > 0) 
    goto _jump1955;
    fail_assertion("non-positive loop bound");
    _jump1955:;
    // Computing bound for m
    if (d.d1 > 0) 
    goto _jump1956;
    fail_assertion("non-positive loop bound");
    _jump1956:;
    _962 = 0;
    int64_t _965 = 0; // m
    int64_t _966 = 0; // l
    int64_t _967 = 0; // k
    _jump1957:; // Begin body of loop
    int64_t _968 = 77;
    int64_t _969 = _968 % d.d1;
    int64_t _970 = -_969;
    int64_t _971 = 808;
    int64_t _972 = _971 - _966;
    int64_t _973 = _970 + _972;
    int64_t _974 = -_973;
    _962 += _974;
    _965++;
    if (_965 < d.d1)
    goto _jump1957;
    _965 = 0;
    _966++;
    if (_966 < d.d1)
    goto _jump1957;
    _966 = 0;
    _967++;
    if (_967 < _964)
    goto _jump1957;
    // End body of loop
    _961.d0 = _962;
    if (_962 > 0) 
    goto _jump1958;
    fail_assertion("non-positive loop bound");
    _jump1958:;
    // Computing total size of heap memory to allocate
    int64_t _975 = 1;
    _975 *= _962;
    _975 *= sizeof(_a1_int64_t);
    _961.data = jpl_alloc(_975);
    int64_t _976 = 0; // k
    _jump1959:; // Begin body of loop
    int64_t _977 = 0;
    _977 *= _961.d0;
    _977 += _976;
    _961.data[_977] = _960;
    _976++;
    if (_976 < _962)
    goto _jump1959;
    // End body of loop
    int64_t _978 = _960.d0 % d.d0;
    int64_t _979 = -_978;
    if (_979 >= 0)
    goto _jump1960;
    fail_assertion("negative array index");
    _jump1960:;
    if (_979 < _961.d0)
    goto _jump1961;
    fail_assertion("index too large");
    _jump1961:;
    int64_t _980 = 0;
    _980 *= _961.d0;
    _980 += _979;
    _a1_int64_t _981 = _961.data[_980];
    return _981;
    _a1_int64_t _982;
    // Computing bound for k
    int64_t _983;
    // Computing bound for k
    int64_t _984 = -_960.d0;
    if (_984 > 0) 
    goto _jump1962;
    fail_assertion("non-positive loop bound");
    _jump1962:;
    // Computing bound for l
    if (d.d0 > 0) 
    goto _jump1963;
    fail_assertion("non-positive loop bound");
    _jump1963:;
    // Computing bound for m
    int64_t _985 = 96;
    if (_985 > 0) 
    goto _jump1964;
    fail_assertion("non-positive loop bound");
    _jump1964:;
    _983 = 0;
    int64_t _986 = 0; // m
    int64_t _987 = 0; // l
    int64_t _988 = 0; // k
    _jump1965:; // Begin body of loop
    int64_t _989 = _988 - _988;
    _983 += _989;
    _986++;
    if (_986 < _985)
    goto _jump1965;
    _986 = 0;
    _987++;
    if (_987 < d.d0)
    goto _jump1965;
    _987 = 0;
    _988++;
    if (_988 < _984)
    goto _jump1965;
    // End body of loop
    int64_t _990 = 92;
    bool _991 = _983 == _990;
    bool _992 = d.d0 >= _960.d0;
    bool _993 = _991 != _992;
    int64_t _994;
    if (!_993)
    goto _jump1966;
    int64_t _995 = -d.d0;
    _994 = _995;
    goto _jump1967;
    _jump1966:;
    _994 = d.d1;
    _jump1967:;
    _982.d0 = _994;
    if (_994 > 0) 
    goto _jump1968;
    fail_assertion("non-positive loop bound");
    _jump1968:;
    // Computing total size of heap memory to allocate
    int64_t _996 = 1;
    _996 *= _994;
    _996 *= sizeof(int64_t);
    _982.data = jpl_alloc(_996);
    int64_t _997 = 0; // k
    _jump1969:; // Begin body of loop
    int64_t _998 = 0;
    _998 *= _982.d0;
    _998 += _997;
    _982.data[_998] = _997;
    _997++;
    if (_997 < _994)
    goto _jump1969;
    // End body of loop
    return _982;
}

_a2_bool h(void_t i, _a1_int64_t j) {
    int64_t _0;
    // Computing bound for l
    if (f > 0) 
    goto _jump2104;
    fail_assertion("non-positive loop bound");
    _jump2104:;
    _0 = 0;
    int64_t _1 = 0; // l
    _jump2105:; // Begin body of loop
    int64_t _2 = 526;
    _0 += _2;
    _1++;
    if (_1 < f)
    goto _jump2105;
    // End body of loop
    _a1_bool _3;
    // Computing bound for o
    int64_t _4 = 263;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump2106;
    fail_assertion("non-positive loop bound");
    _jump2106:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _4;
    _5 *= sizeof(bool);
    _3.data = jpl_alloc(_5);
    int64_t _6 = 0; // o
    _jump2107:; // Begin body of loop
    double _7;
    // Computing bound for p
    int64_t _8 = 528;
    if (_8 > 0) 
    goto _jump2108;
    fail_assertion("non-positive loop bound");
    _jump2108:;
    _7 = 0;
    int64_t _9 = 0; // p
    _jump2109:; // Begin body of loop
    _7 += d;
    _9++;
    if (_9 < _8)
    goto _jump2109;
    // End body of loop
    double _10 = 87.0;
    bool _11 = _7 <= _10;
    bool _12;
    if (!_11)
    goto _jump2110;
    _a2_bool _13;
    // Computing bound for p
    _13.d0 = _6;
    if (_6 > 0) 
    goto _jump2111;
    fail_assertion("non-positive loop bound");
    _jump2111:;
    // Computing bound for q
    _13.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump2112;
    fail_assertion("non-positive loop bound");
    _jump2112:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _6;
    _14 *= j.d0;
    _14 *= sizeof(bool);
    _13.data = jpl_alloc(_14);
    int64_t _15 = 0; // q
    int64_t _16 = 0; // p
    _jump2113:; // Begin body of loop
    bool _17 = false;
    int64_t _18 = 0;
    _18 *= _13.d0;
    _18 += _16;
    _18 *= _13.d1;
    _18 += _15;
    _13.data[_18] = _17;
    _15++;
    if (_15 < j.d0)
    goto _jump2113;
    _15 = 0;
    _16++;
    if (_16 < _6)
    goto _jump2113;
    // End body of loop
    if (_0 >= 0)
    goto _jump2114;
    fail_assertion("negative array index");
    _jump2114:;
    if (_0 < _13.d0)
    goto _jump2115;
    fail_assertion("index too large");
    _jump2115:;
    if (f >= 0)
    goto _jump2116;
    fail_assertion("negative array index");
    _jump2116:;
    if (f < _13.d1)
    goto _jump2117;
    fail_assertion("index too large");
    _jump2117:;
    int64_t _19 = 0;
    _19 *= _13.d0;
    _19 += _0;
    _19 *= _13.d1;
    _19 += f;
    bool _20 = _13.data[_19];
    _12 = _20;
    goto _jump2118;
    _jump2110:;
    bool _22 = j.d0 >= g;
    bool _21 = _22;
    if (0 == _22)
    goto _jump2119;
    bool _23 = true;
    _21 = _23;
    _jump2119:;
    _12 = _21;
    _jump2118:;
    int64_t _24 = 0;
    _24 *= _3.d0;
    _24 += _6;
    _3.data[_24] = _12;
    _6++;
    if (_6 < _4)
    goto _jump2107;
    // End body of loop
    if (j.d0 >= 0)
    goto _jump2120;
    fail_assertion("negative array index");
    _jump2120:;
    if (j.d0 < _3.d0)
    goto _jump2121;
    fail_assertion("index too large");
    _jump2121:;
    int64_t _25 = 0;
    _25 *= _3.d0;
    _25 += j.d0;
    bool _26 = _3.data[_25];
    _a1_rgba _27;
    if (!_26)
    goto _jump2122;
    bool _28 = false;
    rgba _29;
    if (!_28)
    goto _jump2123;
    double _30 = 89.0;
    double _31 = 88.0;
    double _32 = 54.0;
    rgba _33 = { _30, _31, _32, d };
    double _34 = _33.g;
    double _35 = 26.0;
    double _36 = 85.0;
    double _37 = 24.0;
    rgba _38 = { _36, d, _37, d };
    double _39 = a(_38);
    double _40;
    // Computing bound for o
    if (g > 0) 
    goto _jump2124;
    fail_assertion("non-positive loop bound");
    _jump2124:;
    // Computing bound for p
    if (j.d0 > 0) 
    goto _jump2125;
    fail_assertion("non-positive loop bound");
    _jump2125:;
    // Computing bound for q
    if (f > 0) 
    goto _jump2126;
    fail_assertion("non-positive loop bound");
    _jump2126:;
    _40 = 0;
    int64_t _41 = 0; // q
    int64_t _42 = 0; // p
    int64_t _43 = 0; // o
    _jump2127:; // Begin body of loop
    _40 += d;
    _41++;
    if (_41 < f)
    goto _jump2127;
    _41 = 0;
    _42++;
    if (_42 < j.d0)
    goto _jump2127;
    _42 = 0;
    _43++;
    if (_43 < g)
    goto _jump2127;
    // End body of loop
    double _44 = -_40;
    rgba _45 = { _34, _35, _39, _44 };
    _29 = _45;
    goto _jump2128;
    _jump2123:;
    _a3__a2_rgba _46;
    // Computing bound for o
    _46.d0 = g;
    if (g > 0) 
    goto _jump2129;
    fail_assertion("non-positive loop bound");
    _jump2129:;
    // Computing bound for p
    _46.d1 = g;
    if (g > 0) 
    goto _jump2130;
    fail_assertion("non-positive loop bound");
    _jump2130:;
    // Computing bound for q
    int64_t _47 = 925;
    _46.d2 = _47;
    if (_47 > 0) 
    goto _jump2131;
    fail_assertion("non-positive loop bound");
    _jump2131:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= g;
    _48 *= g;
    _48 *= _47;
    _48 *= sizeof(_a2_rgba);
    _46.data = jpl_alloc(_48);
    int64_t _49 = 0; // q
    int64_t _50 = 0; // p
    int64_t _51 = 0; // o
    _jump2132:; // Begin body of loop
    int64_t _52 = 0;
    _52 *= _46.d0;
    _52 += _51;
    _52 *= _46.d1;
    _52 += _50;
    _52 *= _46.d2;
    _52 += _49;
    _46.data[_52] = e;
    _49++;
    if (_49 < _47)
    goto _jump2132;
    _49 = 0;
    _50++;
    if (_50 < g)
    goto _jump2132;
    _50 = 0;
    _51++;
    if (_51 < g)
    goto _jump2132;
    // End body of loop
    int64_t _53 = -j.d0;
    int64_t _54 = -_0;
    if (_0 >= 0)
    goto _jump2133;
    fail_assertion("negative array index");
    _jump2133:;
    if (_0 < _46.d0)
    goto _jump2134;
    fail_assertion("index too large");
    _jump2134:;
    if (_53 >= 0)
    goto _jump2135;
    fail_assertion("negative array index");
    _jump2135:;
    if (_53 < _46.d1)
    goto _jump2136;
    fail_assertion("index too large");
    _jump2136:;
    if (_54 >= 0)
    goto _jump2137;
    fail_assertion("negative array index");
    _jump2137:;
    if (_54 < _46.d2)
    goto _jump2138;
    fail_assertion("index too large");
    _jump2138:;
    int64_t _55 = 0;
    _55 *= _46.d0;
    _55 += _0;
    _55 *= _46.d1;
    _55 += _53;
    _55 *= _46.d2;
    _55 += _54;
    _a2_rgba _56 = _46.data[_55];
    int64_t _57 = -f;
    int64_t _58 = _57 / _0;
    if (j.d0 >= 0)
    goto _jump2139;
    fail_assertion("negative array index");
    _jump2139:;
    if (j.d0 < _56.d0)
    goto _jump2140;
    fail_assertion("index too large");
    _jump2140:;
    if (_58 >= 0)
    goto _jump2141;
    fail_assertion("negative array index");
    _jump2141:;
    if (_58 < _56.d1)
    goto _jump2142;
    fail_assertion("index too large");
    _jump2142:;
    int64_t _59 = 0;
    _59 *= _56.d0;
    _59 += j.d0;
    _59 *= _56.d1;
    _59 += _58;
    rgba _60 = _56.data[_59];
    _29 = _60;
    _jump2128:;
    _a3_double _61;
    // Computing bound for o
    int64_t _62 = 786;
    int64_t _63 = -_62;
    _61.d0 = _63;
    if (_63 > 0) 
    goto _jump2143;
    fail_assertion("non-positive loop bound");
    _jump2143:;
    // Computing bound for p
    _61.d1 = _0;
    if (_0 > 0) 
    goto _jump2144;
    fail_assertion("non-positive loop bound");
    _jump2144:;
    // Computing bound for q
    int64_t _64 = 82;
    int64_t _65 = _64 - g;
    _61.d2 = _65;
    if (_65 > 0) 
    goto _jump2145;
    fail_assertion("non-positive loop bound");
    _jump2145:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= _63;
    _66 *= _0;
    _66 *= _65;
    _66 *= sizeof(double);
    _61.data = jpl_alloc(_66);
    int64_t _67 = 0; // q
    int64_t _68 = 0; // p
    int64_t _69 = 0; // o
    _jump2146:; // Begin body of loop
    double _70 = 21.0;
    int64_t _71 = 0;
    _71 *= _61.d0;
    _71 += _69;
    _71 *= _61.d1;
    _71 += _68;
    _71 *= _61.d2;
    _71 += _67;
    _61.data[_71] = _70;
    _67++;
    if (_67 < _65)
    goto _jump2146;
    _67 = 0;
    _68++;
    if (_68 < _0)
    goto _jump2146;
    _68 = 0;
    _69++;
    if (_69 < _63)
    goto _jump2146;
    // End body of loop
    bool _72 = f < _0;
    int64_t _73;
    if (!_72)
    goto _jump2147;
    int64_t _74 = j.d0 * g;
    _73 = _74;
    goto _jump2148;
    _jump2147:;
    if (j.d0 >= 0)
    goto _jump2149;
    fail_assertion("negative array index");
    _jump2149:;
    if (j.d0 < j.d0)
    goto _jump2150;
    fail_assertion("index too large");
    _jump2150:;
    int64_t _75 = 0;
    _75 *= j.d0;
    _75 += j.d0;
    int64_t _76 = j.data[_75];
    _73 = _76;
    _jump2148:;
    bool _77 = j.d0 > f;
    int64_t _78;
    if (!_77)
    goto _jump2151;
    if (j.d0 >= 0)
    goto _jump2152;
    fail_assertion("negative array index");
    _jump2152:;
    if (j.d0 < j.d0)
    goto _jump2153;
    fail_assertion("index too large");
    _jump2153:;
    int64_t _79 = 0;
    _79 *= j.d0;
    _79 += j.d0;
    int64_t _80 = j.data[_79];
    _78 = _80;
    goto _jump2154;
    _jump2151:;
    _78 = _0;
    _jump2154:;
    _a3_int64_t _81;
    // Computing bound for o
    int64_t _82 = 877;
    _81.d0 = _82;
    if (_82 > 0) 
    goto _jump2155;
    fail_assertion("non-positive loop bound");
    _jump2155:;
    // Computing bound for p
    _81.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump2156;
    fail_assertion("non-positive loop bound");
    _jump2156:;
    // Computing bound for q
    int64_t _83 = 316;
    _81.d2 = _83;
    if (_83 > 0) 
    goto _jump2157;
    fail_assertion("non-positive loop bound");
    _jump2157:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= _82;
    _84 *= j.d0;
    _84 *= _83;
    _84 *= sizeof(int64_t);
    _81.data = jpl_alloc(_84);
    int64_t _85 = 0; // q
    int64_t _86 = 0; // p
    int64_t _87 = 0; // o
    _jump2158:; // Begin body of loop
    int64_t _88 = 0;
    _88 *= _81.d0;
    _88 += _87;
    _88 *= _81.d1;
    _88 += _86;
    _88 *= _81.d2;
    _88 += _85;
    _81.data[_88] = j.d0;
    _85++;
    if (_85 < _83)
    goto _jump2158;
    _85 = 0;
    _86++;
    if (_86 < j.d0)
    goto _jump2158;
    _86 = 0;
    _87++;
    if (_87 < _82)
    goto _jump2158;
    // End body of loop
    bool _89 = true;
    int64_t _90;
    if (!_89)
    goto _jump2159;
    _90 = j.d0;
    goto _jump2160;
    _jump2159:;
    _90 = j.d0;
    _jump2160:;
    if (_90 >= 0)
    goto _jump2161;
    fail_assertion("negative array index");
    _jump2161:;
    if (_90 < _81.d0)
    goto _jump2162;
    fail_assertion("index too large");
    _jump2162:;
    if (j.d0 >= 0)
    goto _jump2163;
    fail_assertion("negative array index");
    _jump2163:;
    if (j.d0 < _81.d1)
    goto _jump2164;
    fail_assertion("index too large");
    _jump2164:;
    if (j.d0 >= 0)
    goto _jump2165;
    fail_assertion("negative array index");
    _jump2165:;
    if (j.d0 < _81.d2)
    goto _jump2166;
    fail_assertion("index too large");
    _jump2166:;
    int64_t _91 = 0;
    _91 *= _81.d0;
    _91 += _90;
    _91 *= _81.d1;
    _91 += j.d0;
    _91 *= _81.d2;
    _91 += j.d0;
    int64_t _92 = _81.data[_91];
    if (_73 >= 0)
    goto _jump2167;
    fail_assertion("negative array index");
    _jump2167:;
    if (_73 < _61.d0)
    goto _jump2168;
    fail_assertion("index too large");
    _jump2168:;
    if (_78 >= 0)
    goto _jump2169;
    fail_assertion("negative array index");
    _jump2169:;
    if (_78 < _61.d1)
    goto _jump2170;
    fail_assertion("index too large");
    _jump2170:;
    if (_92 >= 0)
    goto _jump2171;
    fail_assertion("negative array index");
    _jump2171:;
    if (_92 < _61.d2)
    goto _jump2172;
    fail_assertion("index too large");
    _jump2172:;
    int64_t _93 = 0;
    _93 *= _61.d0;
    _93 += _73;
    _93 *= _61.d1;
    _93 += _78;
    _93 *= _61.d2;
    _93 += _92;
    double _94 = _61.data[_93];
    double _95 = 13.0;
    _a2_double _96;
    // Computing bound for o
    _96.d0 = g;
    if (g > 0) 
    goto _jump2173;
    fail_assertion("non-positive loop bound");
    _jump2173:;
    // Computing bound for p
    _96.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump2174;
    fail_assertion("non-positive loop bound");
    _jump2174:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= g;
    _97 *= j.d0;
    _97 *= sizeof(double);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // p
    int64_t _99 = 0; // o
    _jump2175:; // Begin body of loop
    double _100 = 51.0;
    double _101 = fmod(_100, d);
    int64_t _102 = 0;
    _102 *= _96.d0;
    _102 += _99;
    _102 *= _96.d1;
    _102 += _98;
    _96.data[_102] = _101;
    _98++;
    if (_98 < j.d0)
    goto _jump2175;
    _98 = 0;
    _99++;
    if (_99 < g)
    goto _jump2175;
    // End body of loop
    int64_t _103 = 924;
    int64_t _104 = _103 + _0;
    if (_104 >= 0)
    goto _jump2176;
    fail_assertion("negative array index");
    _jump2176:;
    if (_104 < _96.d0)
    goto _jump2177;
    fail_assertion("index too large");
    _jump2177:;
    if (j.d0 >= 0)
    goto _jump2178;
    fail_assertion("negative array index");
    _jump2178:;
    if (j.d0 < _96.d1)
    goto _jump2179;
    fail_assertion("index too large");
    _jump2179:;
    int64_t _105 = 0;
    _105 *= _96.d0;
    _105 += _104;
    _105 *= _96.d1;
    _105 += j.d0;
    double _106 = _96.data[_105];
    rgba _107 = { _94, _95, d, _106 };
    double _108 = 85.0;
    _a2_double _109;
    // Computing bound for o
    _109.d0 = j.d0;
    if (j.d0 > 0) 
    goto _jump2180;
    fail_assertion("non-positive loop bound");
    _jump2180:;
    // Computing bound for p
    _109.d1 = _0;
    if (_0 > 0) 
    goto _jump2181;
    fail_assertion("non-positive loop bound");
    _jump2181:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= j.d0;
    _110 *= _0;
    _110 *= sizeof(double);
    _109.data = jpl_alloc(_110);
    int64_t _111 = 0; // p
    int64_t _112 = 0; // o
    _jump2182:; // Begin body of loop
    int64_t _113 = 0;
    _113 *= _109.d0;
    _113 += _112;
    _113 *= _109.d1;
    _113 += _111;
    _109.data[_113] = d;
    _111++;
    if (_111 < _0)
    goto _jump2182;
    _111 = 0;
    _112++;
    if (_112 < j.d0)
    goto _jump2182;
    // End body of loop
    int64_t _114 = -_0;
    if (_114 >= 0)
    goto _jump2183;
    fail_assertion("negative array index");
    _jump2183:;
    if (_114 < _109.d0)
    goto _jump2184;
    fail_assertion("index too large");
    _jump2184:;
    if (j.d0 >= 0)
    goto _jump2185;
    fail_assertion("negative array index");
    _jump2185:;
    if (j.d0 < _109.d1)
    goto _jump2186;
    fail_assertion("index too large");
    _jump2186:;
    int64_t _115 = 0;
    _115 *= _109.d0;
    _115 += _114;
    _115 *= _109.d1;
    _115 += j.d0;
    double _116 = _109.data[_115];
    double _117 = _108 - _116;
    double _118;
    // Computing bound for o
    if (_0 > 0) 
    goto _jump2187;
    fail_assertion("non-positive loop bound");
    _jump2187:;
    // Computing bound for p
    int64_t _119 = 295;
    if (_119 > 0) 
    goto _jump2188;
    fail_assertion("non-positive loop bound");
    _jump2188:;
    // Computing bound for q
    int64_t _120 = 517;
    int64_t _121 = -_120;
    if (_121 > 0) 
    goto _jump2189;
    fail_assertion("non-positive loop bound");
    _jump2189:;
    _118 = 0;
    int64_t _122 = 0; // q
    int64_t _123 = 0; // p
    int64_t _124 = 0; // o
    _jump2190:; // Begin body of loop
    _118 += d;
    _122++;
    if (_122 < _121)
    goto _jump2190;
    _122 = 0;
    _123++;
    if (_123 < _119)
    goto _jump2190;
    _123 = 0;
    _124++;
    if (_124 < _0)
    goto _jump2190;
    // End body of loop
    double _125 = -_118;
    double _126 = 21.0;
    double _127 = _126 - d;
    rgba _128 = { _117, _125, _127, d };
    _a1_rgba _129;
    _129.d0 = 3;
    _129.data = jpl_alloc(sizeof(rgba) * 3);
    _129.data[0] = _29;
    _129.data[1] = _107;
    _129.data[2] = _128;
    _27 = _129;
    goto _jump2191;
    _jump2122:;
    _a1_rgba _130;
    // Computing bound for o
    _130.d0 = j.d0;
    if (j.d0 > 0) 
    goto _jump2192;
    fail_assertion("non-positive loop bound");
    _jump2192:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= j.d0;
    _131 *= sizeof(rgba);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // o
    _jump2193:; // Begin body of loop
    double _133;
    // Computing bound for p
    if (_132 > 0) 
    goto _jump2194;
    fail_assertion("non-positive loop bound");
    _jump2194:;
    // Computing bound for q
    if (j.d0 > 0) 
    goto _jump2195;
    fail_assertion("non-positive loop bound");
    _jump2195:;
    _133 = 0;
    int64_t _134 = 0; // q
    int64_t _135 = 0; // p
    _jump2196:; // Begin body of loop
    _133 += d;
    _134++;
    if (_134 < j.d0)
    goto _jump2196;
    _134 = 0;
    _135++;
    if (_135 < _132)
    goto _jump2196;
    // End body of loop
    double _136;
    // Computing bound for p
    if (_0 > 0) 
    goto _jump2197;
    fail_assertion("non-positive loop bound");
    _jump2197:;
    // Computing bound for q
    if (j.d0 > 0) 
    goto _jump2198;
    fail_assertion("non-positive loop bound");
    _jump2198:;
    // Computing bound for r
    if (_0 > 0) 
    goto _jump2199;
    fail_assertion("non-positive loop bound");
    _jump2199:;
    _136 = 0;
    int64_t _137 = 0; // r
    int64_t _138 = 0; // q
    int64_t _139 = 0; // p
    _jump2200:; // Begin body of loop
    double _140 = 71.0;
    double _141 = _140 + d;
    double _142 = -_141;
    _136 += _142;
    _137++;
    if (_137 < _0)
    goto _jump2200;
    _137 = 0;
    _138++;
    if (_138 < j.d0)
    goto _jump2200;
    _138 = 0;
    _139++;
    if (_139 < _0)
    goto _jump2200;
    // End body of loop
    double _143;
    // Computing bound for p
    if (_132 > 0) 
    goto _jump2201;
    fail_assertion("non-positive loop bound");
    _jump2201:;
    // Computing bound for q
    if (_0 > 0) 
    goto _jump2202;
    fail_assertion("non-positive loop bound");
    _jump2202:;
    _143 = 0;
    int64_t _144 = 0; // q
    int64_t _145 = 0; // p
    _jump2203:; // Begin body of loop
    double _146 = 12.0;
    _143 += _146;
    _144++;
    if (_144 < _0)
    goto _jump2203;
    _144 = 0;
    _145++;
    if (_145 < _132)
    goto _jump2203;
    // End body of loop
    double _147 = 36.0;
    rgba _148 = { _133, _136, _143, _147 };
    int64_t _149 = 0;
    _149 *= _130.d0;
    _149 += _132;
    _130.data[_149] = _148;
    _132++;
    if (_132 < j.d0)
    goto _jump2193;
    // End body of loop
    _27 = _130;
    _jump2191:;
    int64_t _150 = 655;
    int64_t _151;
    // Computing bound for o
    if (g > 0) 
    goto _jump2204;
    fail_assertion("non-positive loop bound");
    _jump2204:;
    // Computing bound for p
    if (j.d0 > 0) 
    goto _jump2205;
    fail_assertion("non-positive loop bound");
    _jump2205:;
    _151 = 0;
    int64_t _152 = 0; // p
    int64_t _153 = 0; // o
    _jump2206:; // Begin body of loop
    _151 += _153;
    _152++;
    if (_152 < j.d0)
    goto _jump2206;
    _152 = 0;
    _153++;
    if (_153 < g)
    goto _jump2206;
    // End body of loop
    bool _154 = _150 == _151;
    _a2__a1_int64_t _155;
    if (!_154)
    goto _jump2207;
    _a2__a1_int64_t _156;
    // Computing bound for o
    _156.d0 = f;
    if (f > 0) 
    goto _jump2208;
    fail_assertion("non-positive loop bound");
    _jump2208:;
    // Computing bound for p
    int64_t _157 = 417;
    int64_t _158 = -_157;
    _156.d1 = _158;
    if (_158 > 0) 
    goto _jump2209;
    fail_assertion("non-positive loop bound");
    _jump2209:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= f;
    _159 *= _158;
    _159 *= sizeof(_a1_int64_t);
    _156.data = jpl_alloc(_159);
    int64_t _160 = 0; // p
    int64_t _161 = 0; // o
    _jump2210:; // Begin body of loop
    int64_t _162 = 0;
    _162 *= _156.d0;
    _162 += _161;
    _162 *= _156.d1;
    _162 += _160;
    _156.data[_162] = j;
    _160++;
    if (_160 < _158)
    goto _jump2210;
    _160 = 0;
    _161++;
    if (_161 < f)
    goto _jump2210;
    // End body of loop
    _155 = _156;
    goto _jump2211;
    _jump2207:;
    bool _164 = true;
    bool _163 = _164;
    if (0 != _164)
    goto _jump2212;
    bool _165 = true;
    _163 = _165;
    _jump2212:;
    bool _166;
    if (!_163)
    goto _jump2213;
    bool _167 = d == d;
    _166 = _167;
    goto _jump2214;
    _jump2213:;
    bool _168 = true;
    _166 = _168;
    _jump2214:;
    bool _169;
    if (!_166)
    goto _jump2215;
    bool _170 = j.d0 == _0;
    _169 = _170;
    goto _jump2216;
    _jump2215:;
    int64_t _171 = 908;
    bool _172 = _171 != g;
    _169 = _172;
    _jump2216:;
    _a2__a1_int64_t _173;
    if (!_169)
    goto _jump2217;
    _a2__a1_int64_t _174;
    // Computing bound for o
    int64_t _175 = 855;
    _a1_int64_t _176;
    _176.d0 = 2;
    _176.data = jpl_alloc(sizeof(int64_t) * 2);
    _176.data[0] = _0;
    _176.data[1] = _175;
    if (g >= 0)
    goto _jump2218;
    fail_assertion("negative array index");
    _jump2218:;
    if (g < _176.d0)
    goto _jump2219;
    fail_assertion("index too large");
    _jump2219:;
    int64_t _177 = 0;
    _177 *= _176.d0;
    _177 += g;
    int64_t _178 = _176.data[_177];
    _174.d0 = _178;
    if (_178 > 0) 
    goto _jump2220;
    fail_assertion("non-positive loop bound");
    _jump2220:;
    // Computing bound for p
    int64_t _179;
    // Computing bound for o
    if (g > 0) 
    goto _jump2221;
    fail_assertion("non-positive loop bound");
    _jump2221:;
    // Computing bound for p
    if (_0 > 0) 
    goto _jump2222;
    fail_assertion("non-positive loop bound");
    _jump2222:;
    _179 = 0;
    int64_t _180 = 0; // p
    int64_t _181 = 0; // o
    _jump2223:; // Begin body of loop
    _179 += _180;
    _180++;
    if (_180 < _0)
    goto _jump2223;
    _180 = 0;
    _181++;
    if (_181 < g)
    goto _jump2223;
    // End body of loop
    _174.d1 = _179;
    if (_179 > 0) 
    goto _jump2224;
    fail_assertion("non-positive loop bound");
    _jump2224:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= _178;
    _182 *= _179;
    _182 *= sizeof(_a1_int64_t);
    _174.data = jpl_alloc(_182);
    int64_t _183 = 0; // p
    int64_t _184 = 0; // o
    _jump2225:; // Begin body of loop
    int64_t _185 = 0;
    _185 *= _174.d0;
    _185 += _184;
    _185 *= _174.d1;
    _185 += _183;
    _174.data[_185] = j;
    _183++;
    if (_183 < _179)
    goto _jump2225;
    _183 = 0;
    _184++;
    if (_184 < _178)
    goto _jump2225;
    // End body of loop
    _173 = _174;
    goto _jump2226;
    _jump2217:;
    _a2__a1_int64_t _186;
    // Computing bound for o
    _186.d0 = g;
    if (g > 0) 
    goto _jump2227;
    fail_assertion("non-positive loop bound");
    _jump2227:;
    // Computing bound for p
    _186.d1 = f;
    if (f > 0) 
    goto _jump2228;
    fail_assertion("non-positive loop bound");
    _jump2228:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= g;
    _187 *= f;
    _187 *= sizeof(_a1_int64_t);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // p
    int64_t _189 = 0; // o
    _jump2229:; // Begin body of loop
    bool _190 = _188 != _189;
    _a1_int64_t _191;
    if (!_190)
    goto _jump2230;
    _191 = j;
    goto _jump2231;
    _jump2230:;
    _191 = j;
    _jump2231:;
    int64_t _192 = 0;
    _192 *= _186.d0;
    _192 += _189;
    _192 *= _186.d1;
    _192 += _188;
    _186.data[_192] = _191;
    _188++;
    if (_188 < f)
    goto _jump2229;
    _188 = 0;
    _189++;
    if (_189 < g)
    goto _jump2229;
    // End body of loop
    _173 = _186;
    _jump2226:;
    _155 = _173;
    _jump2211:;
    _a1_int64_t _193 = c(_155, i);
    void_t _194 = b(_27, _193);
    double _195 = 49.0;
    int64_t _196 = 408;
    int64_t _197 = 660;
    int64_t _198 = 154;
    _a1_int64_t _199;
    _199.d0 = 3;
    _199.data = jpl_alloc(sizeof(int64_t) * 3);
    _199.data[0] = _197;
    _199.data[1] = _198;
    _199.data[2] = f;
    int64_t _200 = 306;
    if (_200 >= 0)
    goto _jump2232;
    fail_assertion("negative array index");
    _jump2232:;
    if (_200 < _199.d0)
    goto _jump2233;
    fail_assertion("index too large");
    _jump2233:;
    int64_t _201 = 0;
    _201 *= _199.d0;
    _201 += _200;
    int64_t _202 = _199.data[_201];
    bool _203 = _196 != _202;
    _a3__a2_rgba _204;
    if (!_203)
    goto _jump2234;
    _a3__a2_rgba _205;
    // Computing bound for q
    _205.d0 = j.d0;
    if (j.d0 > 0) 
    goto _jump2235;
    fail_assertion("non-positive loop bound");
    _jump2235:;
    // Computing bound for r
    _205.d1 = _0;
    if (_0 > 0) 
    goto _jump2236;
    fail_assertion("non-positive loop bound");
    _jump2236:;
    // Computing bound for s
    int64_t _206 = 128;
    int64_t _207 = _206 - j.d0;
    _205.d2 = _207;
    if (_207 > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    // Computing total size of heap memory to allocate
    int64_t _208 = 1;
    _208 *= j.d0;
    _208 *= _0;
    _208 *= _207;
    _208 *= sizeof(_a2_rgba);
    _205.data = jpl_alloc(_208);
    int64_t _209 = 0; // s
    int64_t _210 = 0; // r
    int64_t _211 = 0; // q
    _jump2238:; // Begin body of loop
    _a2__a2_rgba _212;
    // Computing bound for t
    _212.d0 = _210;
    if (_210 > 0) 
    goto _jump2239;
    fail_assertion("non-positive loop bound");
    _jump2239:;
    // Computing bound for u
    int64_t _213 = 156;
    _212.d1 = _213;
    if (_213 > 0) 
    goto _jump2240;
    fail_assertion("non-positive loop bound");
    _jump2240:;
    // Computing total size of heap memory to allocate
    int64_t _214 = 1;
    _214 *= _210;
    _214 *= _213;
    _214 *= sizeof(_a2_rgba);
    _212.data = jpl_alloc(_214);
    int64_t _215 = 0; // u
    int64_t _216 = 0; // t
    _jump2241:; // Begin body of loop
    int64_t _217 = 0;
    _217 *= _212.d0;
    _217 += _216;
    _217 *= _212.d1;
    _217 += _215;
    _212.data[_217] = e;
    _215++;
    if (_215 < _213)
    goto _jump2241;
    _215 = 0;
    _216++;
    if (_216 < _210)
    goto _jump2241;
    // End body of loop
    if (j.d0 >= 0)
    goto _jump2242;
    fail_assertion("negative array index");
    _jump2242:;
    if (j.d0 < _212.d0)
    goto _jump2243;
    fail_assertion("index too large");
    _jump2243:;
    if (j.d0 >= 0)
    goto _jump2244;
    fail_assertion("negative array index");
    _jump2244:;
    if (j.d0 < _212.d1)
    goto _jump2245;
    fail_assertion("index too large");
    _jump2245:;
    int64_t _218 = 0;
    _218 *= _212.d0;
    _218 += j.d0;
    _218 *= _212.d1;
    _218 += j.d0;
    _a2_rgba _219 = _212.data[_218];
    int64_t _220 = 0;
    _220 *= _205.d0;
    _220 += _211;
    _220 *= _205.d1;
    _220 += _210;
    _220 *= _205.d2;
    _220 += _209;
    _205.data[_220] = _219;
    _209++;
    if (_209 < _207)
    goto _jump2238;
    _209 = 0;
    _210++;
    if (_210 < _0)
    goto _jump2238;
    _210 = 0;
    _211++;
    if (_211 < j.d0)
    goto _jump2238;
    // End body of loop
    _a3__a2_rgba _221;
    // Computing bound for q
    bool _222 = false;
    int64_t _223;
    if (!_222)
    goto _jump2246;
    int64_t _224 = 90;
    _223 = _224;
    goto _jump2247;
    _jump2246:;
    _223 = _0;
    _jump2247:;
    _221.d0 = _223;
    if (_223 > 0) 
    goto _jump2248;
    fail_assertion("non-positive loop bound");
    _jump2248:;
    // Computing bound for r
    _a2_int64_t _225;
    // Computing bound for q
    _225.d0 = j.d0;
    if (j.d0 > 0) 
    goto _jump2249;
    fail_assertion("non-positive loop bound");
    _jump2249:;
    // Computing bound for r
    _225.d1 = g;
    if (g > 0) 
    goto _jump2250;
    fail_assertion("non-positive loop bound");
    _jump2250:;
    // Computing total size of heap memory to allocate
    int64_t _226 = 1;
    _226 *= j.d0;
    _226 *= g;
    _226 *= sizeof(int64_t);
    _225.data = jpl_alloc(_226);
    int64_t _227 = 0; // r
    int64_t _228 = 0; // q
    _jump2251:; // Begin body of loop
    int64_t _229 = 0;
    _229 *= _225.d0;
    _229 += _228;
    _229 *= _225.d1;
    _229 += _227;
    _225.data[_229] = _228;
    _227++;
    if (_227 < g)
    goto _jump2251;
    _227 = 0;
    _228++;
    if (_228 < j.d0)
    goto _jump2251;
    // End body of loop
    int64_t _230;
    // Computing bound for q
    if (j.d0 > 0) 
    goto _jump2252;
    fail_assertion("non-positive loop bound");
    _jump2252:;
    _230 = 0;
    int64_t _231 = 0; // q
    _jump2253:; // Begin body of loop
    _230 += j.d0;
    _231++;
    if (_231 < j.d0)
    goto _jump2253;
    // End body of loop
    if (_230 >= 0)
    goto _jump2254;
    fail_assertion("negative array index");
    _jump2254:;
    if (_230 < _225.d0)
    goto _jump2255;
    fail_assertion("index too large");
    _jump2255:;
    if (j.d0 >= 0)
    goto _jump2256;
    fail_assertion("negative array index");
    _jump2256:;
    if (j.d0 < _225.d1)
    goto _jump2257;
    fail_assertion("index too large");
    _jump2257:;
    int64_t _232 = 0;
    _232 *= _225.d0;
    _232 += _230;
    _232 *= _225.d1;
    _232 += j.d0;
    int64_t _233 = _225.data[_232];
    _221.d1 = _233;
    if (_233 > 0) 
    goto _jump2258;
    fail_assertion("non-positive loop bound");
    _jump2258:;
    // Computing bound for s
    _221.d2 = _0;
    if (_0 > 0) 
    goto _jump2259;
    fail_assertion("non-positive loop bound");
    _jump2259:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= _223;
    _234 *= _233;
    _234 *= _0;
    _234 *= sizeof(_a2_rgba);
    _221.data = jpl_alloc(_234);
    int64_t _235 = 0; // s
    int64_t _236 = 0; // r
    int64_t _237 = 0; // q
    _jump2260:; // Begin body of loop
    int64_t _238 = 0;
    _238 *= _221.d0;
    _238 += _237;
    _238 *= _221.d1;
    _238 += _236;
    _238 *= _221.d2;
    _238 += _235;
    _221.data[_238] = e;
    _235++;
    if (_235 < _0)
    goto _jump2260;
    _235 = 0;
    _236++;
    if (_236 < _233)
    goto _jump2260;
    _236 = 0;
    _237++;
    if (_237 < _223)
    goto _jump2260;
    // End body of loop
    _a1__a3__a2_rgba _239;
    _239.d0 = 2;
    _239.data = jpl_alloc(sizeof(_a3__a2_rgba) * 2);
    _239.data[0] = _205;
    _239.data[1] = _221;
    int64_t _240 = 9;
    if (_240 >= 0)
    goto _jump2261;
    fail_assertion("negative array index");
    _jump2261:;
    if (_240 < _239.d0)
    goto _jump2262;
    fail_assertion("index too large");
    _jump2262:;
    int64_t _241 = 0;
    _241 *= _239.d0;
    _241 += _240;
    _a3__a2_rgba _242 = _239.data[_241];
    _204 = _242;
    goto _jump2263;
    _jump2234:;
    double _243 = 25.0;
    bool _244 = _243 <= _195;
    int64_t _245;
    if (!_244)
    goto _jump2264;
    int64_t _246 = 656;
    _245 = _246;
    goto _jump2265;
    _jump2264:;
    _245 = j.d0;
    _jump2265:;
    int64_t _247;
    // Computing bound for q
    bool _248 = true;
    int64_t _249;
    if (!_248)
    goto _jump2266;
    _249 = j.d0;
    goto _jump2267;
    _jump2266:;
    _249 = f;
    _jump2267:;
    if (_249 > 0) 
    goto _jump2268;
    fail_assertion("non-positive loop bound");
    _jump2268:;
    // Computing bound for r
    if (j.d0 > 0) 
    goto _jump2269;
    fail_assertion("non-positive loop bound");
    _jump2269:;
    // Computing bound for s
    int64_t _250 = j.d0 * g;
    if (_250 > 0) 
    goto _jump2270;
    fail_assertion("non-positive loop bound");
    _jump2270:;
    _247 = 0;
    int64_t _251 = 0; // s
    int64_t _252 = 0; // r
    int64_t _253 = 0; // q
    _jump2271:; // Begin body of loop
    _247 += j.d0;
    _251++;
    if (_251 < _250)
    goto _jump2271;
    _251 = 0;
    _252++;
    if (_252 < j.d0)
    goto _jump2271;
    _252 = 0;
    _253++;
    if (_253 < _249)
    goto _jump2271;
    // End body of loop
    bool _254 = _245 == _247;
    bool _255;
    if (!_254)
    goto _jump2272;
    _a2_bool _256;
    // Computing bound for q
    _256.d0 = _0;
    if (_0 > 0) 
    goto _jump2273;
    fail_assertion("non-positive loop bound");
    _jump2273:;
    // Computing bound for r
    _256.d1 = g;
    if (g > 0) 
    goto _jump2274;
    fail_assertion("non-positive loop bound");
    _jump2274:;
    // Computing total size of heap memory to allocate
    int64_t _257 = 1;
    _257 *= _0;
    _257 *= g;
    _257 *= sizeof(bool);
    _256.data = jpl_alloc(_257);
    int64_t _258 = 0; // r
    int64_t _259 = 0; // q
    _jump2275:; // Begin body of loop
    bool _260 = false;
    bool _261 = !_260;
    int64_t _262 = 0;
    _262 *= _256.d0;
    _262 += _259;
    _262 *= _256.d1;
    _262 += _258;
    _256.data[_262] = _261;
    _258++;
    if (_258 < g)
    goto _jump2275;
    _258 = 0;
    _259++;
    if (_259 < _0)
    goto _jump2275;
    // End body of loop
    int64_t _263 = 195;
    int64_t _264 = -_263;
    int64_t _265;
    // Computing bound for q
    int64_t _266;
    // Computing bound for q
    if (_0 > 0) 
    goto _jump2276;
    fail_assertion("non-positive loop bound");
    _jump2276:;
    // Computing bound for r
    int64_t _267 = 637;
    if (_267 > 0) 
    goto _jump2277;
    fail_assertion("non-positive loop bound");
    _jump2277:;
    // Computing bound for s
    if (j.d0 > 0) 
    goto _jump2278;
    fail_assertion("non-positive loop bound");
    _jump2278:;
    _266 = 0;
    int64_t _268 = 0; // s
    int64_t _269 = 0; // r
    int64_t _270 = 0; // q
    _jump2279:; // Begin body of loop
    _266 += _0;
    _268++;
    if (_268 < j.d0)
    goto _jump2279;
    _268 = 0;
    _269++;
    if (_269 < _267)
    goto _jump2279;
    _269 = 0;
    _270++;
    if (_270 < _0)
    goto _jump2279;
    // End body of loop
    if (_266 > 0) 
    goto _jump2280;
    fail_assertion("non-positive loop bound");
    _jump2280:;
    // Computing bound for r
    int64_t _271;
    // Computing bound for q
    int64_t _272 = 407;
    if (_272 > 0) 
    goto _jump2281;
    fail_assertion("non-positive loop bound");
    _jump2281:;
    // Computing bound for r
    if (f > 0) 
    goto _jump2282;
    fail_assertion("non-positive loop bound");
    _jump2282:;
    _271 = 0;
    int64_t _273 = 0; // r
    int64_t _274 = 0; // q
    _jump2283:; // Begin body of loop
    _271 += _273;
    _273++;
    if (_273 < f)
    goto _jump2283;
    _273 = 0;
    _274++;
    if (_274 < _272)
    goto _jump2283;
    // End body of loop
    if (_271 > 0) 
    goto _jump2284;
    fail_assertion("non-positive loop bound");
    _jump2284:;
    _265 = 0;
    int64_t _275 = 0; // r
    int64_t _276 = 0; // q
    _jump2285:; // Begin body of loop
    _265 += j.d0;
    _275++;
    if (_275 < _271)
    goto _jump2285;
    _275 = 0;
    _276++;
    if (_276 < _266)
    goto _jump2285;
    // End body of loop
    if (_264 >= 0)
    goto _jump2286;
    fail_assertion("negative array index");
    _jump2286:;
    if (_264 < _256.d0)
    goto _jump2287;
    fail_assertion("index too large");
    _jump2287:;
    if (_265 >= 0)
    goto _jump2288;
    fail_assertion("negative array index");
    _jump2288:;
    if (_265 < _256.d1)
    goto _jump2289;
    fail_assertion("index too large");
    _jump2289:;
    int64_t _277 = 0;
    _277 *= _256.d0;
    _277 += _264;
    _277 *= _256.d1;
    _277 += _265;
    bool _278 = _256.data[_277];
    _255 = _278;
    goto _jump2290;
    _jump2272:;
    bool _279 = true;
    bool _280 = true;
    bool _281 = _279 == _280;
    bool _282 = !_281;
    int64_t _283 = 577;
    int64_t _284;
    // Computing bound for q
    if (j.d0 > 0) 
    goto _jump2291;
    fail_assertion("non-positive loop bound");
    _jump2291:;
    // Computing bound for r
    if (f > 0) 
    goto _jump2292;
    fail_assertion("non-positive loop bound");
    _jump2292:;
    // Computing bound for s
    if (_0 > 0) 
    goto _jump2293;
    fail_assertion("non-positive loop bound");
    _jump2293:;
    _284 = 0;
    int64_t _285 = 0; // s
    int64_t _286 = 0; // r
    int64_t _287 = 0; // q
    _jump2294:; // Begin body of loop
    _284 += _285;
    _285++;
    if (_285 < _0)
    goto _jump2294;
    _285 = 0;
    _286++;
    if (_286 < f)
    goto _jump2294;
    _286 = 0;
    _287++;
    if (_287 < j.d0)
    goto _jump2294;
    // End body of loop
    bool _288 = _283 >= _284;
    bool _289 = _282 == _288;
    _255 = _289;
    _jump2290:;
    _a3__a2_rgba _290;
    if (!_255)
    goto _jump2295;
    bool _292 = true;
    bool _291 = _292;
    if (0 == _292)
    goto _jump2296;
    bool _293 = true;
    bool _294 = true;
    bool _295 = _293 != _294;
    _291 = _295;
    _jump2296:;
    bool _296 = !_291;
    _a3__a2_rgba _297;
    if (!_296)
    goto _jump2297;
    _a1__a3__a2_rgba _298;
    // Computing bound for q
    _298.d0 = j.d0;
    if (j.d0 > 0) 
    goto _jump2298;
    fail_assertion("non-positive loop bound");
    _jump2298:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= j.d0;
    _299 *= sizeof(_a3__a2_rgba);
    _298.data = jpl_alloc(_299);
    int64_t _300 = 0; // q
    _jump2299:; // Begin body of loop
    _a3__a2_rgba _301;
    // Computing bound for r
    _301.d0 = _0;
    if (_0 > 0) 
    goto _jump2300;
    fail_assertion("non-positive loop bound");
    _jump2300:;
    // Computing bound for s
    _301.d1 = _0;
    if (_0 > 0) 
    goto _jump2301;
    fail_assertion("non-positive loop bound");
    _jump2301:;
    // Computing bound for t
    _301.d2 = j.d0;
    if (j.d0 > 0) 
    goto _jump2302;
    fail_assertion("non-positive loop bound");
    _jump2302:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _0;
    _302 *= _0;
    _302 *= j.d0;
    _302 *= sizeof(_a2_rgba);
    _301.data = jpl_alloc(_302);
    int64_t _303 = 0; // t
    int64_t _304 = 0; // s
    int64_t _305 = 0; // r
    _jump2303:; // Begin body of loop
    int64_t _306 = 0;
    _306 *= _301.d0;
    _306 += _305;
    _306 *= _301.d1;
    _306 += _304;
    _306 *= _301.d2;
    _306 += _303;
    _301.data[_306] = e;
    _303++;
    if (_303 < j.d0)
    goto _jump2303;
    _303 = 0;
    _304++;
    if (_304 < _0)
    goto _jump2303;
    _304 = 0;
    _305++;
    if (_305 < _0)
    goto _jump2303;
    // End body of loop
    int64_t _307 = 0;
    _307 *= _298.d0;
    _307 += _300;
    _298.data[_307] = _301;
    _300++;
    if (_300 < j.d0)
    goto _jump2299;
    // End body of loop
    int64_t _308 = -j.d0;
    int64_t _309 = _308 + f;
    if (_309 >= 0)
    goto _jump2304;
    fail_assertion("negative array index");
    _jump2304:;
    if (_309 < _298.d0)
    goto _jump2305;
    fail_assertion("index too large");
    _jump2305:;
    int64_t _310 = 0;
    _310 *= _298.d0;
    _310 += _309;
    _a3__a2_rgba _311 = _298.data[_310];
    _297 = _311;
    goto _jump2306;
    _jump2297:;
    _a3__a2_rgba _312;
    // Computing bound for q
    _312.d0 = _0;
    if (_0 > 0) 
    goto _jump2307;
    fail_assertion("non-positive loop bound");
    _jump2307:;
    // Computing bound for r
    bool _314 = false;
    bool _313 = _314;
    if (0 == _314)
    goto _jump2308;
    bool _315 = false;
    _313 = _315;
    _jump2308:;
    int64_t _316;
    if (!_313)
    goto _jump2309;
    _316 = g;
    goto _jump2310;
    _jump2309:;
    int64_t _317 = 453;
    _316 = _317;
    _jump2310:;
    _312.d1 = _316;
    if (_316 > 0) 
    goto _jump2311;
    fail_assertion("non-positive loop bound");
    _jump2311:;
    // Computing bound for s
    _a2_int64_t _318;
    // Computing bound for q
    _318.d0 = f;
    if (f > 0) 
    goto _jump2312;
    fail_assertion("non-positive loop bound");
    _jump2312:;
    // Computing bound for r
    _318.d1 = _0;
    if (_0 > 0) 
    goto _jump2313;
    fail_assertion("non-positive loop bound");
    _jump2313:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= f;
    _319 *= _0;
    _319 *= sizeof(int64_t);
    _318.data = jpl_alloc(_319);
    int64_t _320 = 0; // r
    int64_t _321 = 0; // q
    _jump2314:; // Begin body of loop
    int64_t _322 = 0;
    _322 *= _318.d0;
    _322 += _321;
    _322 *= _318.d1;
    _322 += _320;
    _318.data[_322] = _0;
    _320++;
    if (_320 < _0)
    goto _jump2314;
    _320 = 0;
    _321++;
    if (_321 < f)
    goto _jump2314;
    // End body of loop
    int64_t _323 = _0 - g;
    if (_323 >= 0)
    goto _jump2315;
    fail_assertion("negative array index");
    _jump2315:;
    if (_323 < _318.d0)
    goto _jump2316;
    fail_assertion("index too large");
    _jump2316:;
    if (g >= 0)
    goto _jump2317;
    fail_assertion("negative array index");
    _jump2317:;
    if (g < _318.d1)
    goto _jump2318;
    fail_assertion("index too large");
    _jump2318:;
    int64_t _324 = 0;
    _324 *= _318.d0;
    _324 += _323;
    _324 *= _318.d1;
    _324 += g;
    int64_t _325 = _318.data[_324];
    _312.d2 = _325;
    if (_325 > 0) 
    goto _jump2319;
    fail_assertion("non-positive loop bound");
    _jump2319:;
    // Computing total size of heap memory to allocate
    int64_t _326 = 1;
    _326 *= _0;
    _326 *= _316;
    _326 *= _325;
    _326 *= sizeof(_a2_rgba);
    _312.data = jpl_alloc(_326);
    int64_t _327 = 0; // s
    int64_t _328 = 0; // r
    int64_t _329 = 0; // q
    _jump2320:; // Begin body of loop
    int64_t _330 = 0;
    _330 *= _312.d0;
    _330 += _329;
    _330 *= _312.d1;
    _330 += _328;
    _330 *= _312.d2;
    _330 += _327;
    _312.data[_330] = e;
    _327++;
    if (_327 < _325)
    goto _jump2320;
    _327 = 0;
    _328++;
    if (_328 < _316)
    goto _jump2320;
    _328 = 0;
    _329++;
    if (_329 < _0)
    goto _jump2320;
    // End body of loop
    _297 = _312;
    _jump2306:;
    _290 = _297;
    goto _jump2321;
    _jump2295:;
    bool _331 = true;
    _a3__a2_rgba _332;
    if (!_331)
    goto _jump2322;
    _a2__a3__a2_rgba _333;
    // Computing bound for q
    _333.d0 = g;
    if (g > 0) 
    goto _jump2323;
    fail_assertion("non-positive loop bound");
    _jump2323:;
    // Computing bound for r
    int64_t _334;
    // Computing bound for q
    if (g > 0) 
    goto _jump2324;
    fail_assertion("non-positive loop bound");
    _jump2324:;
    // Computing bound for r
    if (_0 > 0) 
    goto _jump2325;
    fail_assertion("non-positive loop bound");
    _jump2325:;
    // Computing bound for s
    if (_0 > 0) 
    goto _jump2326;
    fail_assertion("non-positive loop bound");
    _jump2326:;
    _334 = 0;
    int64_t _335 = 0; // s
    int64_t _336 = 0; // r
    int64_t _337 = 0; // q
    _jump2327:; // Begin body of loop
    _334 += j.d0;
    _335++;
    if (_335 < _0)
    goto _jump2327;
    _335 = 0;
    _336++;
    if (_336 < _0)
    goto _jump2327;
    _336 = 0;
    _337++;
    if (_337 < g)
    goto _jump2327;
    // End body of loop
    _333.d1 = _334;
    if (_334 > 0) 
    goto _jump2328;
    fail_assertion("non-positive loop bound");
    _jump2328:;
    // Computing total size of heap memory to allocate
    int64_t _338 = 1;
    _338 *= g;
    _338 *= _334;
    _338 *= sizeof(_a3__a2_rgba);
    _333.data = jpl_alloc(_338);
    int64_t _339 = 0; // r
    int64_t _340 = 0; // q
    _jump2329:; // Begin body of loop
    _a3__a2_rgba _341;
    // Computing bound for s
    int64_t _342 = 868;
    _341.d0 = _342;
    if (_342 > 0) 
    goto _jump2330;
    fail_assertion("non-positive loop bound");
    _jump2330:;
    // Computing bound for t
    _341.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump2331;
    fail_assertion("non-positive loop bound");
    _jump2331:;
    // Computing bound for u
    int64_t _343 = 477;
    _341.d2 = _343;
    if (_343 > 0) 
    goto _jump2332;
    fail_assertion("non-positive loop bound");
    _jump2332:;
    // Computing total size of heap memory to allocate
    int64_t _344 = 1;
    _344 *= _342;
    _344 *= j.d0;
    _344 *= _343;
    _344 *= sizeof(_a2_rgba);
    _341.data = jpl_alloc(_344);
    int64_t _345 = 0; // u
    int64_t _346 = 0; // t
    int64_t _347 = 0; // s
    _jump2333:; // Begin body of loop
    int64_t _348 = 0;
    _348 *= _341.d0;
    _348 += _347;
    _348 *= _341.d1;
    _348 += _346;
    _348 *= _341.d2;
    _348 += _345;
    _341.data[_348] = e;
    _345++;
    if (_345 < _343)
    goto _jump2333;
    _345 = 0;
    _346++;
    if (_346 < j.d0)
    goto _jump2333;
    _346 = 0;
    _347++;
    if (_347 < _342)
    goto _jump2333;
    // End body of loop
    int64_t _349 = 0;
    _349 *= _333.d0;
    _349 += _340;
    _349 *= _333.d1;
    _349 += _339;
    _333.data[_349] = _341;
    _339++;
    if (_339 < _334)
    goto _jump2329;
    _339 = 0;
    _340++;
    if (_340 < g)
    goto _jump2329;
    // End body of loop
    int64_t _350 = -f;
    if (_350 >= 0)
    goto _jump2334;
    fail_assertion("negative array index");
    _jump2334:;
    if (_350 < _333.d0)
    goto _jump2335;
    fail_assertion("index too large");
    _jump2335:;
    if (j.d0 >= 0)
    goto _jump2336;
    fail_assertion("negative array index");
    _jump2336:;
    if (j.d0 < _333.d1)
    goto _jump2337;
    fail_assertion("index too large");
    _jump2337:;
    int64_t _351 = 0;
    _351 *= _333.d0;
    _351 += _350;
    _351 *= _333.d1;
    _351 += j.d0;
    _a3__a2_rgba _352 = _333.data[_351];
    _332 = _352;
    goto _jump2338;
    _jump2322:;
    _a3__a3__a2_rgba _353;
    // Computing bound for q
    _353.d0 = _0;
    if (_0 > 0) 
    goto _jump2339;
    fail_assertion("non-positive loop bound");
    _jump2339:;
    // Computing bound for r
    _353.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump2340;
    fail_assertion("non-positive loop bound");
    _jump2340:;
    // Computing bound for s
    _353.d2 = g;
    if (g > 0) 
    goto _jump2341;
    fail_assertion("non-positive loop bound");
    _jump2341:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= _0;
    _354 *= j.d0;
    _354 *= g;
    _354 *= sizeof(_a3__a2_rgba);
    _353.data = jpl_alloc(_354);
    int64_t _355 = 0; // s
    int64_t _356 = 0; // r
    int64_t _357 = 0; // q
    _jump2342:; // Begin body of loop
    _a3__a2_rgba _358;
    // Computing bound for t
    _358.d0 = f;
    if (f > 0) 
    goto _jump2343;
    fail_assertion("non-positive loop bound");
    _jump2343:;
    // Computing bound for u
    _358.d1 = _355;
    if (_355 > 0) 
    goto _jump2344;
    fail_assertion("non-positive loop bound");
    _jump2344:;
    // Computing bound for v
    int64_t _359 = 725;
    _358.d2 = _359;
    if (_359 > 0) 
    goto _jump2345;
    fail_assertion("non-positive loop bound");
    _jump2345:;
    // Computing total size of heap memory to allocate
    int64_t _360 = 1;
    _360 *= f;
    _360 *= _355;
    _360 *= _359;
    _360 *= sizeof(_a2_rgba);
    _358.data = jpl_alloc(_360);
    int64_t _361 = 0; // v
    int64_t _362 = 0; // u
    int64_t _363 = 0; // t
    _jump2346:; // Begin body of loop
    int64_t _364 = 0;
    _364 *= _358.d0;
    _364 += _363;
    _364 *= _358.d1;
    _364 += _362;
    _364 *= _358.d2;
    _364 += _361;
    _358.data[_364] = e;
    _361++;
    if (_361 < _359)
    goto _jump2346;
    _361 = 0;
    _362++;
    if (_362 < _355)
    goto _jump2346;
    _362 = 0;
    _363++;
    if (_363 < f)
    goto _jump2346;
    // End body of loop
    int64_t _365 = 0;
    _365 *= _353.d0;
    _365 += _357;
    _365 *= _353.d1;
    _365 += _356;
    _365 *= _353.d2;
    _365 += _355;
    _353.data[_365] = _358;
    _355++;
    if (_355 < g)
    goto _jump2342;
    _355 = 0;
    _356++;
    if (_356 < j.d0)
    goto _jump2342;
    _356 = 0;
    _357++;
    if (_357 < _0)
    goto _jump2342;
    // End body of loop
    int64_t _366 = 711;
    int64_t _367 = -_366;
    bool _368 = false;
    int64_t _369;
    if (!_368)
    goto _jump2347;
    _369 = f;
    goto _jump2348;
    _jump2347:;
    _369 = g;
    _jump2348:;
    if (_367 >= 0)
    goto _jump2349;
    fail_assertion("negative array index");
    _jump2349:;
    if (_367 < _353.d0)
    goto _jump2350;
    fail_assertion("index too large");
    _jump2350:;
    if (g >= 0)
    goto _jump2351;
    fail_assertion("negative array index");
    _jump2351:;
    if (g < _353.d1)
    goto _jump2352;
    fail_assertion("index too large");
    _jump2352:;
    if (_369 >= 0)
    goto _jump2353;
    fail_assertion("negative array index");
    _jump2353:;
    if (_369 < _353.d2)
    goto _jump2354;
    fail_assertion("index too large");
    _jump2354:;
    int64_t _370 = 0;
    _370 *= _353.d0;
    _370 += _367;
    _370 *= _353.d1;
    _370 += g;
    _370 *= _353.d2;
    _370 += _369;
    _a3__a2_rgba _371 = _353.data[_370];
    _332 = _371;
    _jump2338:;
    _290 = _332;
    _jump2321:;
    _204 = _290;
    _jump2263:;
    int64_t _372 = -f;
    if (_372 >= 0)
    goto _jump2355;
    fail_assertion("negative array index");
    _jump2355:;
    if (_372 < _204.d0)
    goto _jump2356;
    fail_assertion("index too large");
    _jump2356:;
    if (g >= 0)
    goto _jump2357;
    fail_assertion("negative array index");
    _jump2357:;
    if (g < _204.d1)
    goto _jump2358;
    fail_assertion("index too large");
    _jump2358:;
    if (_0 >= 0)
    goto _jump2359;
    fail_assertion("negative array index");
    _jump2359:;
    if (_0 < _204.d2)
    goto _jump2360;
    fail_assertion("index too large");
    _jump2360:;
    int64_t _373 = 0;
    _373 *= _204.d0;
    _373 += _372;
    _373 *= _204.d1;
    _373 += g;
    _373 *= _204.d2;
    _373 += _0;
    _a2_rgba _374 = _204.data[_373];
    _a2_bool _375;
    // Computing bound for t
    _375.d0 = _374.d1;
    if (_374.d1 > 0) 
    goto _jump2361;
    fail_assertion("non-positive loop bound");
    _jump2361:;
    // Computing bound for u
    _375.d1 = _0;
    if (_0 > 0) 
    goto _jump2362;
    fail_assertion("non-positive loop bound");
    _jump2362:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= _374.d1;
    _376 *= _0;
    _376 *= sizeof(bool);
    _375.data = jpl_alloc(_376);
    int64_t _377 = 0; // u
    int64_t _378 = 0; // t
    _jump2363:; // Begin body of loop
    double _379 = fmod(d, d);
    double _380 = _195 * _379;
    double _381 = -d;
    bool _382 = _380 < _381;
    bool _383;
    if (!_382)
    goto _jump2364;
    bool _384 = false;
    bool _385 = !_384;
    _383 = _385;
    goto _jump2365;
    _jump2364:;
    if (g >= 0)
    goto _jump2366;
    fail_assertion("negative array index");
    _jump2366:;
    if (g < _374.d0)
    goto _jump2367;
    fail_assertion("index too large");
    _jump2367:;
    if (j.d0 >= 0)
    goto _jump2368;
    fail_assertion("negative array index");
    _jump2368:;
    if (j.d0 < _374.d1)
    goto _jump2369;
    fail_assertion("index too large");
    _jump2369:;
    int64_t _386 = 0;
    _386 *= _374.d0;
    _386 += g;
    _386 *= _374.d1;
    _386 += j.d0;
    rgba _387 = _374.data[_386];
    double _388 = a(_387);
    double _389;
    // Computing bound for v
    if (_374.d0 > 0) 
    goto _jump2370;
    fail_assertion("non-positive loop bound");
    _jump2370:;
    // Computing bound for w
    if (f > 0) 
    goto _jump2371;
    fail_assertion("non-positive loop bound");
    _jump2371:;
    _389 = 0;
    int64_t _390 = 0; // w
    int64_t _391 = 0; // v
    _jump2372:; // Begin body of loop
    double _392 = 87.0;
    _389 += _392;
    _390++;
    if (_390 < f)
    goto _jump2372;
    _390 = 0;
    _391++;
    if (_391 < _374.d0)
    goto _jump2372;
    // End body of loop
    double _393 = -_389;
    bool _394 = _388 == _393;
    _383 = _394;
    _jump2365:;
    bool _395;
    if (!_383)
    goto _jump2373;
    _a3_double _396;
    // Computing bound for v
    int64_t _397 = 265;
    _396.d0 = _397;
    if (_397 > 0) 
    goto _jump2374;
    fail_assertion("non-positive loop bound");
    _jump2374:;
    // Computing bound for w
    _396.d1 = _377;
    if (_377 > 0) 
    goto _jump2375;
    fail_assertion("non-positive loop bound");
    _jump2375:;
    // Computing bound for x
    int64_t _398 = -_374.d1;
    _396.d2 = _398;
    if (_398 > 0) 
    goto _jump2376;
    fail_assertion("non-positive loop bound");
    _jump2376:;
    // Computing total size of heap memory to allocate
    int64_t _399 = 1;
    _399 *= _397;
    _399 *= _377;
    _399 *= _398;
    _399 *= sizeof(double);
    _396.data = jpl_alloc(_399);
    int64_t _400 = 0; // x
    int64_t _401 = 0; // w
    int64_t _402 = 0; // v
    _jump2377:; // Begin body of loop
    int64_t _403 = 0;
    _403 *= _396.d0;
    _403 += _402;
    _403 *= _396.d1;
    _403 += _401;
    _403 *= _396.d2;
    _403 += _400;
    _396.data[_403] = d;
    _400++;
    if (_400 < _398)
    goto _jump2377;
    _400 = 0;
    _401++;
    if (_401 < _377)
    goto _jump2377;
    _401 = 0;
    _402++;
    if (_402 < _397)
    goto _jump2377;
    // End body of loop
    if (_374.d0 >= 0)
    goto _jump2378;
    fail_assertion("negative array index");
    _jump2378:;
    if (_374.d0 < j.d0)
    goto _jump2379;
    fail_assertion("index too large");
    _jump2379:;
    int64_t _404 = 0;
    _404 *= j.d0;
    _404 += _374.d0;
    int64_t _405 = j.data[_404];
    if (f >= 0)
    goto _jump2380;
    fail_assertion("negative array index");
    _jump2380:;
    if (f < _396.d0)
    goto _jump2381;
    fail_assertion("index too large");
    _jump2381:;
    if (_405 >= 0)
    goto _jump2382;
    fail_assertion("negative array index");
    _jump2382:;
    if (_405 < _396.d1)
    goto _jump2383;
    fail_assertion("index too large");
    _jump2383:;
    if (g >= 0)
    goto _jump2384;
    fail_assertion("negative array index");
    _jump2384:;
    if (g < _396.d2)
    goto _jump2385;
    fail_assertion("index too large");
    _jump2385:;
    int64_t _406 = 0;
    _406 *= _396.d0;
    _406 += f;
    _406 *= _396.d1;
    _406 += _405;
    _406 *= _396.d2;
    _406 += g;
    double _407 = _396.data[_406];
    bool _408 = _195 != _407;
    _395 = _408;
    goto _jump2386;
    _jump2373:;
    bool _409 = false;
    _395 = _409;
    _jump2386:;
    bool _410 = !_395;
    int64_t _411 = 0;
    _411 *= _375.d0;
    _411 += _378;
    _411 *= _375.d1;
    _411 += _377;
    _375.data[_411] = _410;
    _377++;
    if (_377 < _0)
    goto _jump2363;
    _377 = 0;
    _378++;
    if (_378 < _374.d1)
    goto _jump2363;
    // End body of loop
    return _375;
}

rgba j() {
    _a2__a1__a3_bool _0;
    // Computing bound for k
    _a2_int64_t _1;
    // Computing bound for k
    int64_t _2 = 353;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump2449;
    fail_assertion("non-positive loop bound");
    _jump2449:;
    // Computing bound for l
    int64_t _3 = -f;
    int64_t _4 = 507;
    int64_t _5 = 199;
    int64_t _6 = _4 - _5;
    int64_t _7 = _3 / _6;
    _1.d1 = _7;
    if (_7 > 0) 
    goto _jump2450;
    fail_assertion("non-positive loop bound");
    _jump2450:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= _2;
    _8 *= _7;
    _8 *= sizeof(int64_t);
    _1.data = jpl_alloc(_8);
    int64_t _9 = 0; // l
    int64_t _10 = 0; // k
    _jump2451:; // Begin body of loop
    int64_t _11 = 0;
    _11 *= _1.d0;
    _11 += _10;
    _11 *= _1.d1;
    _11 += _9;
    _1.data[_11] = _10;
    _9++;
    if (_9 < _7)
    goto _jump2451;
    _9 = 0;
    _10++;
    if (_10 < _2)
    goto _jump2451;
    // End body of loop
    int64_t _12;
    // Computing bound for k
    int64_t _13 = -f;
    int64_t _14 = f * _13;
    if (_14 > 0) 
    goto _jump2452;
    fail_assertion("non-positive loop bound");
    _jump2452:;
    _12 = 0;
    int64_t _15 = 0; // k
    _jump2453:; // Begin body of loop
    _12 += _15;
    _15++;
    if (_15 < _14)
    goto _jump2453;
    // End body of loop
    if (f >= 0)
    goto _jump2454;
    fail_assertion("negative array index");
    _jump2454:;
    if (f < _1.d0)
    goto _jump2455;
    fail_assertion("index too large");
    _jump2455:;
    if (_12 >= 0)
    goto _jump2456;
    fail_assertion("negative array index");
    _jump2456:;
    if (_12 < _1.d1)
    goto _jump2457;
    fail_assertion("index too large");
    _jump2457:;
    int64_t _16 = 0;
    _16 *= _1.d0;
    _16 += f;
    _16 *= _1.d1;
    _16 += _12;
    int64_t _17 = _1.data[_16];
    _0.d0 = _17;
    if (_17 > 0) 
    goto _jump2458;
    fail_assertion("non-positive loop bound");
    _jump2458:;
    // Computing bound for l
    int64_t _18 = 434;
    int64_t _19 = _18 % f;
    _0.d1 = _19;
    if (_19 > 0) 
    goto _jump2459;
    fail_assertion("non-positive loop bound");
    _jump2459:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _17;
    _20 *= _19;
    _20 *= sizeof(_a1__a3_bool);
    _0.data = jpl_alloc(_20);
    int64_t _21 = 0; // l
    int64_t _22 = 0; // k
    _jump2460:; // Begin body of loop
    _a1__a3_bool _23;
    // Computing bound for m
    _23.d0 = _21;
    if (_21 > 0) 
    goto _jump2461;
    fail_assertion("non-positive loop bound");
    _jump2461:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= _21;
    _24 *= sizeof(_a3_bool);
    _23.data = jpl_alloc(_24);
    int64_t _25 = 0; // m
    _jump2462:; // Begin body of loop
    _a3_bool _26;
    // Computing bound for n
    _26.d0 = _25;
    if (_25 > 0) 
    goto _jump2463;
    fail_assertion("non-positive loop bound");
    _jump2463:;
    // Computing bound for o
    _26.d1 = g;
    if (g > 0) 
    goto _jump2464;
    fail_assertion("non-positive loop bound");
    _jump2464:;
    // Computing bound for p
    _26.d2 = f;
    if (f > 0) 
    goto _jump2465;
    fail_assertion("non-positive loop bound");
    _jump2465:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= _25;
    _27 *= g;
    _27 *= f;
    _27 *= sizeof(bool);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // p
    int64_t _29 = 0; // o
    int64_t _30 = 0; // n
    _jump2466:; // Begin body of loop
    bool _31 = false;
    int64_t _32 = 0;
    _32 *= _26.d0;
    _32 += _30;
    _32 *= _26.d1;
    _32 += _29;
    _32 *= _26.d2;
    _32 += _28;
    _26.data[_32] = _31;
    _28++;
    if (_28 < f)
    goto _jump2466;
    _28 = 0;
    _29++;
    if (_29 < g)
    goto _jump2466;
    _29 = 0;
    _30++;
    if (_30 < _25)
    goto _jump2466;
    // End body of loop
    int64_t _33 = 0;
    _33 *= _23.d0;
    _33 += _25;
    _23.data[_33] = _26;
    _25++;
    if (_25 < _21)
    goto _jump2462;
    // End body of loop
    _a1__a3_bool _34;
    // Computing bound for m
    _34.d0 = g;
    if (g > 0) 
    goto _jump2467;
    fail_assertion("non-positive loop bound");
    _jump2467:;
    // Computing total size of heap memory to allocate
    int64_t _35 = 1;
    _35 *= g;
    _35 *= sizeof(_a3_bool);
    _34.data = jpl_alloc(_35);
    int64_t _36 = 0; // m
    _jump2468:; // Begin body of loop
    _a3_bool _37;
    // Computing bound for n
    _37.d0 = _22;
    if (_22 > 0) 
    goto _jump2469;
    fail_assertion("non-positive loop bound");
    _jump2469:;
    // Computing bound for o
    _37.d1 = f;
    if (f > 0) 
    goto _jump2470;
    fail_assertion("non-positive loop bound");
    _jump2470:;
    // Computing bound for p
    _37.d2 = _22;
    if (_22 > 0) 
    goto _jump2471;
    fail_assertion("non-positive loop bound");
    _jump2471:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= _22;
    _38 *= f;
    _38 *= _22;
    _38 *= sizeof(bool);
    _37.data = jpl_alloc(_38);
    int64_t _39 = 0; // p
    int64_t _40 = 0; // o
    int64_t _41 = 0; // n
    _jump2472:; // Begin body of loop
    bool _42 = false;
    int64_t _43 = 0;
    _43 *= _37.d0;
    _43 += _41;
    _43 *= _37.d1;
    _43 += _40;
    _43 *= _37.d2;
    _43 += _39;
    _37.data[_43] = _42;
    _39++;
    if (_39 < _22)
    goto _jump2472;
    _39 = 0;
    _40++;
    if (_40 < f)
    goto _jump2472;
    _40 = 0;
    _41++;
    if (_41 < _22)
    goto _jump2472;
    // End body of loop
    int64_t _44 = 0;
    _44 *= _34.d0;
    _44 += _36;
    _34.data[_44] = _37;
    _36++;
    if (_36 < g)
    goto _jump2468;
    // End body of loop
    _a1__a1__a3_bool _45;
    _45.d0 = 2;
    _45.data = jpl_alloc(sizeof(_a1__a3_bool) * 2);
    _45.data[0] = _23;
    _45.data[1] = _34;
    int64_t _46 = -_21;
    if (_46 >= 0)
    goto _jump2473;
    fail_assertion("negative array index");
    _jump2473:;
    if (_46 < _45.d0)
    goto _jump2474;
    fail_assertion("index too large");
    _jump2474:;
    int64_t _47 = 0;
    _47 *= _45.d0;
    _47 += _46;
    _a1__a3_bool _48 = _45.data[_47];
    int64_t _49 = 0;
    _49 *= _0.d0;
    _49 += _22;
    _49 *= _0.d1;
    _49 += _21;
    _0.data[_49] = _48;
    _21++;
    if (_21 < _19)
    goto _jump2460;
    _21 = 0;
    _22++;
    if (_22 < _17)
    goto _jump2460;
    // End body of loop
    _a2_bool _50;
    // Computing bound for k
    _50.d0 = g;
    if (g > 0) 
    goto _jump2475;
    fail_assertion("non-positive loop bound");
    _jump2475:;
    // Computing bound for l
    int64_t _51 = 377;
    _50.d1 = _51;
    if (_51 > 0) 
    goto _jump2476;
    fail_assertion("non-positive loop bound");
    _jump2476:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= g;
    _52 *= _51;
    _52 *= sizeof(bool);
    _50.data = jpl_alloc(_52);
    int64_t _53 = 0; // l
    int64_t _54 = 0; // k
    _jump2477:; // Begin body of loop
    bool _55 = true;
    int64_t _56 = 0;
    _56 *= _50.d0;
    _56 += _54;
    _56 *= _50.d1;
    _56 += _53;
    _50.data[_56] = _55;
    _53++;
    if (_53 < _51)
    goto _jump2477;
    _53 = 0;
    _54++;
    if (_54 < g)
    goto _jump2477;
    // End body of loop
    int64_t _57;
    // Computing bound for k
    int64_t _58;
    // Computing bound for k
    int64_t _59 = 497;
    int64_t _60 = f * _59;
    if (_60 > 0) 
    goto _jump2478;
    fail_assertion("non-positive loop bound");
    _jump2478:;
    _58 = 0;
    int64_t _61 = 0; // k
    _jump2479:; // Begin body of loop
    _58 += f;
    _61++;
    if (_61 < _60)
    goto _jump2479;
    // End body of loop
    if (_58 > 0) 
    goto _jump2480;
    fail_assertion("non-positive loop bound");
    _jump2480:;
    // Computing bound for l
    if (g > 0) 
    goto _jump2481;
    fail_assertion("non-positive loop bound");
    _jump2481:;
    _57 = 0;
    int64_t _62 = 0; // l
    int64_t _63 = 0; // k
    _jump2482:; // Begin body of loop
    _57 += g;
    _62++;
    if (_62 < g)
    goto _jump2482;
    _62 = 0;
    _63++;
    if (_63 < _58)
    goto _jump2482;
    // End body of loop
    bool _64 = true;
    bool _65 = !_64;
    _a3_int64_t _66;
    if (!_65)
    goto _jump2483;
    _a3_int64_t _67;
    // Computing bound for k
    int64_t _68 = 180;
    _67.d0 = _68;
    if (_68 > 0) 
    goto _jump2484;
    fail_assertion("non-positive loop bound");
    _jump2484:;
    // Computing bound for l
    _67.d1 = g;
    if (g > 0) 
    goto _jump2485;
    fail_assertion("non-positive loop bound");
    _jump2485:;
    // Computing bound for m
    int64_t _69 = 255;
    _67.d2 = _69;
    if (_69 > 0) 
    goto _jump2486;
    fail_assertion("non-positive loop bound");
    _jump2486:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= _68;
    _70 *= g;
    _70 *= _69;
    _70 *= sizeof(int64_t);
    _67.data = jpl_alloc(_70);
    int64_t _71 = 0; // m
    int64_t _72 = 0; // l
    int64_t _73 = 0; // k
    _jump2487:; // Begin body of loop
    int64_t _74 = 0;
    _74 *= _67.d0;
    _74 += _73;
    _74 *= _67.d1;
    _74 += _72;
    _74 *= _67.d2;
    _74 += _71;
    _67.data[_74] = _72;
    _71++;
    if (_71 < _69)
    goto _jump2487;
    _71 = 0;
    _72++;
    if (_72 < g)
    goto _jump2487;
    _72 = 0;
    _73++;
    if (_73 < _68)
    goto _jump2487;
    // End body of loop
    _66 = _67;
    goto _jump2488;
    _jump2483:;
    _a3_int64_t _75;
    // Computing bound for k
    int64_t _76 = 310;
    _75.d0 = _76;
    if (_76 > 0) 
    goto _jump2489;
    fail_assertion("non-positive loop bound");
    _jump2489:;
    // Computing bound for l
    _75.d1 = g;
    if (g > 0) 
    goto _jump2490;
    fail_assertion("non-positive loop bound");
    _jump2490:;
    // Computing bound for m
    _75.d2 = f;
    if (f > 0) 
    goto _jump2491;
    fail_assertion("non-positive loop bound");
    _jump2491:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _76;
    _77 *= g;
    _77 *= f;
    _77 *= sizeof(int64_t);
    _75.data = jpl_alloc(_77);
    int64_t _78 = 0; // m
    int64_t _79 = 0; // l
    int64_t _80 = 0; // k
    _jump2492:; // Begin body of loop
    int64_t _81 = 0;
    _81 *= _75.d0;
    _81 += _80;
    _81 *= _75.d1;
    _81 += _79;
    _81 *= _75.d2;
    _81 += _78;
    _75.data[_81] = f;
    _78++;
    if (_78 < f)
    goto _jump2492;
    _78 = 0;
    _79++;
    if (_79 < g)
    goto _jump2492;
    _79 = 0;
    _80++;
    if (_80 < _76)
    goto _jump2492;
    // End body of loop
    _66 = _75;
    _jump2488:;
    int64_t _82 = 751;
    int64_t _83 = -f;
    if (g >= 0)
    goto _jump2493;
    fail_assertion("negative array index");
    _jump2493:;
    if (g < _66.d0)
    goto _jump2494;
    fail_assertion("index too large");
    _jump2494:;
    if (_82 >= 0)
    goto _jump2495;
    fail_assertion("negative array index");
    _jump2495:;
    if (_82 < _66.d1)
    goto _jump2496;
    fail_assertion("index too large");
    _jump2496:;
    if (_83 >= 0)
    goto _jump2497;
    fail_assertion("negative array index");
    _jump2497:;
    if (_83 < _66.d2)
    goto _jump2498;
    fail_assertion("index too large");
    _jump2498:;
    int64_t _84 = 0;
    _84 *= _66.d0;
    _84 += g;
    _84 *= _66.d1;
    _84 += _82;
    _84 *= _66.d2;
    _84 += _83;
    int64_t _85 = _66.data[_84];
    if (_57 >= 0)
    goto _jump2499;
    fail_assertion("negative array index");
    _jump2499:;
    if (_57 < _50.d0)
    goto _jump2500;
    fail_assertion("index too large");
    _jump2500:;
    if (_85 >= 0)
    goto _jump2501;
    fail_assertion("negative array index");
    _jump2501:;
    if (_85 < _50.d1)
    goto _jump2502;
    fail_assertion("index too large");
    _jump2502:;
    int64_t _86 = 0;
    _86 *= _50.d0;
    _86 += _57;
    _86 *= _50.d1;
    _86 += _85;
    bool _87 = _50.data[_86];
    int64_t _88;
    if (!_87)
    goto _jump2503;
    int64_t _89 = 526;
    _88 = _89;
    goto _jump2504;
    _jump2503:;
    int64_t _90 = 930;
    _88 = _90;
    _jump2504:;
    bool _91 = true;
    bool _92 = false;
    bool _93 = _91 != _92;
    bool _94 = !_93;
    bool _95 = !_94;
    bool _96 = false;
    bool _97 = _95 == _96;
    int64_t _98;
    if (!_97)
    goto _jump2505;
    _a3_int64_t _99;
    // Computing bound for k
    _99.d0 = g;
    if (g > 0) 
    goto _jump2506;
    fail_assertion("non-positive loop bound");
    _jump2506:;
    // Computing bound for l
    int64_t _100 = 737;
    _99.d1 = _100;
    if (_100 > 0) 
    goto _jump2507;
    fail_assertion("non-positive loop bound");
    _jump2507:;
    // Computing bound for m
    int64_t _101 = 22;
    _99.d2 = _101;
    if (_101 > 0) 
    goto _jump2508;
    fail_assertion("non-positive loop bound");
    _jump2508:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= g;
    _102 *= _100;
    _102 *= _101;
    _102 *= sizeof(int64_t);
    _99.data = jpl_alloc(_102);
    int64_t _103 = 0; // m
    int64_t _104 = 0; // l
    int64_t _105 = 0; // k
    _jump2509:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _99.d0;
    _106 += _105;
    _106 *= _99.d1;
    _106 += _104;
    _106 *= _99.d2;
    _106 += _103;
    _99.data[_106] = _104;
    _103++;
    if (_103 < _101)
    goto _jump2509;
    _103 = 0;
    _104++;
    if (_104 < _100)
    goto _jump2509;
    _104 = 0;
    _105++;
    if (_105 < g)
    goto _jump2509;
    // End body of loop
    int64_t _107 = 184;
    if (g >= 0)
    goto _jump2510;
    fail_assertion("negative array index");
    _jump2510:;
    if (g < _99.d0)
    goto _jump2511;
    fail_assertion("index too large");
    _jump2511:;
    if (g >= 0)
    goto _jump2512;
    fail_assertion("negative array index");
    _jump2512:;
    if (g < _99.d1)
    goto _jump2513;
    fail_assertion("index too large");
    _jump2513:;
    if (_107 >= 0)
    goto _jump2514;
    fail_assertion("negative array index");
    _jump2514:;
    if (_107 < _99.d2)
    goto _jump2515;
    fail_assertion("index too large");
    _jump2515:;
    int64_t _108 = 0;
    _108 *= _99.d0;
    _108 += g;
    _108 *= _99.d1;
    _108 += g;
    _108 *= _99.d2;
    _108 += _107;
    int64_t _109 = _99.data[_108];
    int64_t _110 = -_109;
    int64_t _111 = -_110;
    _98 = _111;
    goto _jump2516;
    _jump2505:;
    _98 = g;
    _jump2516:;
    if (_88 >= 0)
    goto _jump2517;
    fail_assertion("negative array index");
    _jump2517:;
    if (_88 < _0.d0)
    goto _jump2518;
    fail_assertion("index too large");
    _jump2518:;
    if (_98 >= 0)
    goto _jump2519;
    fail_assertion("negative array index");
    _jump2519:;
    if (_98 < _0.d1)
    goto _jump2520;
    fail_assertion("index too large");
    _jump2520:;
    int64_t _112 = 0;
    _112 *= _0.d0;
    _112 += _88;
    _112 *= _0.d1;
    _112 += _98;
    _a1__a3_bool _113 = _0.data[_112];
    int64_t _114 = 869;
    if (_114 >= 0)
    goto _jump2521;
    fail_assertion("negative array index");
    _jump2521:;
    if (_114 < _113.d0)
    goto _jump2522;
    fail_assertion("index too large");
    _jump2522:;
    int64_t _115 = 0;
    _115 *= _113.d0;
    _115 += _114;
    _a3_bool _116 = _113.data[_115];
    rgba _117 = j();
    return _117;
    rgba _118 = j();
    double _119 = a(_118);
    bool _122 = _116.d0 >= _116.d0;
    bool _121 = _122;
    if (0 != _122)
    goto _jump2523;
    bool _123 = true;
    _121 = _123;
    _jump2523:;
    bool _120 = _121;
    if (0 != _121)
    goto _jump2524;
    bool _125 = false;
    bool _124 = _125;
    if (0 != _125)
    goto _jump2525;
    int64_t _126 = 709;
    if (_116.d1 >= 0)
    goto _jump2526;
    fail_assertion("negative array index");
    _jump2526:;
    if (_116.d1 < _116.d0)
    goto _jump2527;
    fail_assertion("index too large");
    _jump2527:;
    if (_126 >= 0)
    goto _jump2528;
    fail_assertion("negative array index");
    _jump2528:;
    if (_126 < _116.d1)
    goto _jump2529;
    fail_assertion("index too large");
    _jump2529:;
    if (_116.d1 >= 0)
    goto _jump2530;
    fail_assertion("negative array index");
    _jump2530:;
    if (_116.d1 < _116.d2)
    goto _jump2531;
    fail_assertion("index too large");
    _jump2531:;
    int64_t _127 = 0;
    _127 *= _116.d0;
    _127 += _116.d1;
    _127 *= _116.d1;
    _127 += _126;
    _127 *= _116.d2;
    _127 += _116.d1;
    bool _128 = _116.data[_127];
    _124 = _128;
    _jump2525:;
    _120 = _124;
    _jump2524:;
    double _129 = -i;
    bool _130 = _129 == d;
    bool _131;
    if (!_130)
    goto _jump2532;
    _a2_bool _132;
    // Computing bound for v
    _132.d0 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2533;
    fail_assertion("non-positive loop bound");
    _jump2533:;
    // Computing bound for w
    _132.d1 = f;
    if (f > 0) 
    goto _jump2534;
    fail_assertion("non-positive loop bound");
    _jump2534:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _116.d1;
    _133 *= f;
    _133 *= sizeof(bool);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // w
    int64_t _135 = 0; // v
    _jump2535:; // Begin body of loop
    bool _136 = false;
    int64_t _137 = 0;
    _137 *= _132.d0;
    _137 += _135;
    _137 *= _132.d1;
    _137 += _134;
    _132.data[_137] = _136;
    _134++;
    if (_134 < f)
    goto _jump2535;
    _134 = 0;
    _135++;
    if (_135 < _116.d1)
    goto _jump2535;
    // End body of loop
    int64_t _138 = 386;
    int64_t _139 = e.d1 * _138;
    if (_139 >= 0)
    goto _jump2536;
    fail_assertion("negative array index");
    _jump2536:;
    if (_139 < _132.d0)
    goto _jump2537;
    fail_assertion("index too large");
    _jump2537:;
    if (_116.d0 >= 0)
    goto _jump2538;
    fail_assertion("negative array index");
    _jump2538:;
    if (_116.d0 < _132.d1)
    goto _jump2539;
    fail_assertion("index too large");
    _jump2539:;
    int64_t _140 = 0;
    _140 *= _132.d0;
    _140 += _139;
    _140 *= _132.d1;
    _140 += _116.d0;
    bool _141 = _132.data[_140];
    _131 = _141;
    goto _jump2540;
    _jump2532:;
    bool _142 = false;
    _131 = _142;
    _jump2540:;
    bool _143 = _120 != _131;
    double _144;
    if (!_143)
    goto _jump2541;
    double _145 = 41.0;
    double _146 = _145 + i;
    double _147 = -_146;
    _144 = _147;
    goto _jump2542;
    _jump2541:;
    double _148 = 53.0;
    double _149 = 69.0;
    double _150 = -_149;
    double _151 = _148 + _150;
    _144 = _151;
    _jump2542:;
    double _152 = d / d;
    double _153 = _144 * _152;
    rgba _154 = { d, _119, i, _153 };
    _a2__a2__a1_int64_t _155;
    // Computing bound for w
    int64_t _156;
    // Computing bound for w
    if (_116.d2 > 0) 
    goto _jump2543;
    fail_assertion("non-positive loop bound");
    _jump2543:;
    // Computing bound for x
    bool _157 = g != f;
    _a2_int64_t _158;
    if (!_157)
    goto _jump2544;
    _a2_int64_t _159;
    // Computing bound for w
    _159.d0 = f;
    if (f > 0) 
    goto _jump2545;
    fail_assertion("non-positive loop bound");
    _jump2545:;
    // Computing bound for x
    _159.d1 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2546;
    fail_assertion("non-positive loop bound");
    _jump2546:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= f;
    _160 *= _116.d1;
    _160 *= sizeof(int64_t);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // x
    int64_t _162 = 0; // w
    _jump2547:; // Begin body of loop
    int64_t _163 = 0;
    _163 *= _159.d0;
    _163 += _162;
    _163 *= _159.d1;
    _163 += _161;
    _159.data[_163] = e.d1;
    _161++;
    if (_161 < _116.d1)
    goto _jump2547;
    _161 = 0;
    _162++;
    if (_162 < f)
    goto _jump2547;
    // End body of loop
    _158 = _159;
    goto _jump2548;
    _jump2544:;
    _a2_int64_t _164;
    // Computing bound for w
    _164.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump2549;
    fail_assertion("non-positive loop bound");
    _jump2549:;
    // Computing bound for x
    _164.d1 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2550;
    fail_assertion("non-positive loop bound");
    _jump2550:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= e.d1;
    _165 *= _116.d1;
    _165 *= sizeof(int64_t);
    _164.data = jpl_alloc(_165);
    int64_t _166 = 0; // x
    int64_t _167 = 0; // w
    _jump2551:; // Begin body of loop
    int64_t _168 = 0;
    _168 *= _164.d0;
    _168 += _167;
    _168 *= _164.d1;
    _168 += _166;
    _164.data[_168] = _166;
    _166++;
    if (_166 < _116.d1)
    goto _jump2551;
    _166 = 0;
    _167++;
    if (_167 < e.d1)
    goto _jump2551;
    // End body of loop
    _158 = _164;
    _jump2548:;
    int64_t _169 = f % _116.d0;
    if (_169 >= 0)
    goto _jump2552;
    fail_assertion("negative array index");
    _jump2552:;
    if (_169 < _158.d0)
    goto _jump2553;
    fail_assertion("index too large");
    _jump2553:;
    if (_116.d1 >= 0)
    goto _jump2554;
    fail_assertion("negative array index");
    _jump2554:;
    if (_116.d1 < _158.d1)
    goto _jump2555;
    fail_assertion("index too large");
    _jump2555:;
    int64_t _170 = 0;
    _170 *= _158.d0;
    _170 += _169;
    _170 *= _158.d1;
    _170 += _116.d1;
    int64_t _171 = _158.data[_170];
    if (_171 > 0) 
    goto _jump2556;
    fail_assertion("non-positive loop bound");
    _jump2556:;
    _156 = 0;
    int64_t _172 = 0; // x
    int64_t _173 = 0; // w
    _jump2557:; // Begin body of loop
    _156 += _116.d1;
    _172++;
    if (_172 < _171)
    goto _jump2557;
    _172 = 0;
    _173++;
    if (_173 < _116.d2)
    goto _jump2557;
    // End body of loop
    _155.d0 = _156;
    if (_156 > 0) 
    goto _jump2558;
    fail_assertion("non-positive loop bound");
    _jump2558:;
    // Computing bound for x
    _155.d1 = _116.d0;
    if (_116.d0 > 0) 
    goto _jump2559;
    fail_assertion("non-positive loop bound");
    _jump2559:;
    // Computing total size of heap memory to allocate
    int64_t _174 = 1;
    _174 *= _156;
    _174 *= _116.d0;
    _174 *= sizeof(_a2__a1_int64_t);
    _155.data = jpl_alloc(_174);
    int64_t _175 = 0; // x
    int64_t _176 = 0; // w
    _jump2560:; // Begin body of loop
    double _177 = 85.0;
    double _178 = i + i;
    bool _179 = _177 > _178;
    bool _180 = !_179;
    _a2__a1_int64_t _181;
    if (!_180)
    goto _jump2561;
    _a2__a1_int64_t _182;
    // Computing bound for y
    _182.d0 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2562;
    fail_assertion("non-positive loop bound");
    _jump2562:;
    // Computing bound for z
    _182.d1 = _116.d2;
    if (_116.d2 > 0) 
    goto _jump2563;
    fail_assertion("non-positive loop bound");
    _jump2563:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= _116.d1;
    _183 *= _116.d2;
    _183 *= sizeof(_a1_int64_t);
    _182.data = jpl_alloc(_183);
    int64_t _184 = 0; // z
    int64_t _185 = 0; // y
    _jump2564:; // Begin body of loop
    int64_t _186 = _116.d1 + _116.d1;
    _a1_int64_t _187;
    _187.d0 = 1;
    _187.data = jpl_alloc(sizeof(int64_t) * 1);
    _187.data[0] = _186;
    int64_t _188 = 0;
    _188 *= _182.d0;
    _188 += _185;
    _188 *= _182.d1;
    _188 += _184;
    _182.data[_188] = _187;
    _184++;
    if (_184 < _116.d2)
    goto _jump2564;
    _184 = 0;
    _185++;
    if (_185 < _116.d1)
    goto _jump2564;
    // End body of loop
    _181 = _182;
    goto _jump2565;
    _jump2561:;
    _a2__a1_int64_t _189;
    // Computing bound for y
    _189.d0 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2566;
    fail_assertion("non-positive loop bound");
    _jump2566:;
    // Computing bound for z
    bool _190 = _116.d1 > e.d0;
    int64_t _191;
    if (!_190)
    goto _jump2567;
    _191 = _176;
    goto _jump2568;
    _jump2567:;
    _191 = _116.d2;
    _jump2568:;
    _189.d1 = _191;
    if (_191 > 0) 
    goto _jump2569;
    fail_assertion("non-positive loop bound");
    _jump2569:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= _116.d1;
    _192 *= _191;
    _192 *= sizeof(_a1_int64_t);
    _189.data = jpl_alloc(_192);
    int64_t _193 = 0; // z
    int64_t _194 = 0; // y
    _jump2570:; // Begin body of loop
    bool _195 = i == d;
    _a1_int64_t _196;
    if (!_195)
    goto _jump2571;
    _a1_int64_t _197;
    _197.d0 = 1;
    _197.data = jpl_alloc(sizeof(int64_t) * 1);
    _197.data[0] = _116.d2;
    _196 = _197;
    goto _jump2572;
    _jump2571:;
    _a1_int64_t _198;
    // Computing bound for A
    int64_t _199 = 557;
    _198.d0 = _199;
    if (_199 > 0) 
    goto _jump2573;
    fail_assertion("non-positive loop bound");
    _jump2573:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= _199;
    _200 *= sizeof(int64_t);
    _198.data = jpl_alloc(_200);
    int64_t _201 = 0; // A
    _jump2574:; // Begin body of loop
    int64_t _202 = 0;
    _202 *= _198.d0;
    _202 += _201;
    _198.data[_202] = _116.d1;
    _201++;
    if (_201 < _199)
    goto _jump2574;
    // End body of loop
    _196 = _198;
    _jump2572:;
    int64_t _203 = 0;
    _203 *= _189.d0;
    _203 += _194;
    _203 *= _189.d1;
    _203 += _193;
    _189.data[_203] = _196;
    _193++;
    if (_193 < _191)
    goto _jump2570;
    _193 = 0;
    _194++;
    if (_194 < _116.d1)
    goto _jump2570;
    // End body of loop
    _181 = _189;
    _jump2565:;
    int64_t _204 = 0;
    _204 *= _155.d0;
    _204 += _176;
    _204 *= _155.d1;
    _204 += _175;
    _155.data[_204] = _181;
    _175++;
    if (_175 < _116.d0)
    goto _jump2560;
    _175 = 0;
    _176++;
    if (_176 < _156)
    goto _jump2560;
    // End body of loop
    int64_t _205 = -_116.d0;
    if (_116.d1 >= 0)
    goto _jump2575;
    fail_assertion("negative array index");
    _jump2575:;
    if (_116.d1 < _155.d0)
    goto _jump2576;
    fail_assertion("index too large");
    _jump2576:;
    if (_205 >= 0)
    goto _jump2577;
    fail_assertion("negative array index");
    _jump2577:;
    if (_205 < _155.d1)
    goto _jump2578;
    fail_assertion("index too large");
    _jump2578:;
    int64_t _206 = 0;
    _206 *= _155.d0;
    _206 += _116.d1;
    _206 *= _155.d1;
    _206 += _205;
    _a2__a1_int64_t _207 = _155.data[_206];
    int64_t _209 = _116.d0 * _116.d1;
    bool _210 = e.d1 == _209;
    int64_t _211 = 694;
    bool _212 = e.d0 == _211;
    _a1_bool _213;
    _213.d0 = 2;
    _213.data = jpl_alloc(sizeof(bool) * 2);
    _213.data[0] = _210;
    _213.data[1] = _212;
    _a3_int64_t _214;
    // Computing bound for w
    int64_t _215 = _116.d2 * _116.d1;
    _214.d0 = _215;
    if (_215 > 0) 
    goto _jump2579;
    fail_assertion("non-positive loop bound");
    _jump2579:;
    // Computing bound for x
    _214.d1 = g;
    if (g > 0) 
    goto _jump2580;
    fail_assertion("non-positive loop bound");
    _jump2580:;
    // Computing bound for y
    _214.d2 = _116.d2;
    if (_116.d2 > 0) 
    goto _jump2581;
    fail_assertion("non-positive loop bound");
    _jump2581:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= _215;
    _216 *= g;
    _216 *= _116.d2;
    _216 *= sizeof(int64_t);
    _214.data = jpl_alloc(_216);
    int64_t _217 = 0; // y
    int64_t _218 = 0; // x
    int64_t _219 = 0; // w
    _jump2582:; // Begin body of loop
    int64_t _220 = 0;
    _220 *= _214.d0;
    _220 += _219;
    _220 *= _214.d1;
    _220 += _218;
    _220 *= _214.d2;
    _220 += _217;
    _214.data[_220] = _219;
    _217++;
    if (_217 < _116.d2)
    goto _jump2582;
    _217 = 0;
    _218++;
    if (_218 < g)
    goto _jump2582;
    _218 = 0;
    _219++;
    if (_219 < _215)
    goto _jump2582;
    // End body of loop
    if (_116.d0 >= 0)
    goto _jump2583;
    fail_assertion("negative array index");
    _jump2583:;
    if (_116.d0 < _214.d0)
    goto _jump2584;
    fail_assertion("index too large");
    _jump2584:;
    if (_116.d2 >= 0)
    goto _jump2585;
    fail_assertion("negative array index");
    _jump2585:;
    if (_116.d2 < _214.d1)
    goto _jump2586;
    fail_assertion("index too large");
    _jump2586:;
    if (_116.d0 >= 0)
    goto _jump2587;
    fail_assertion("negative array index");
    _jump2587:;
    if (_116.d0 < _214.d2)
    goto _jump2588;
    fail_assertion("index too large");
    _jump2588:;
    int64_t _221 = 0;
    _221 *= _214.d0;
    _221 += _116.d0;
    _221 *= _214.d1;
    _221 += _116.d2;
    _221 *= _214.d2;
    _221 += _116.d0;
    int64_t _222 = _214.data[_221];
    if (_222 >= 0)
    goto _jump2589;
    fail_assertion("negative array index");
    _jump2589:;
    if (_222 < _213.d0)
    goto _jump2590;
    fail_assertion("index too large");
    _jump2590:;
    int64_t _223 = 0;
    _223 *= _213.d0;
    _223 += _222;
    bool _224 = _213.data[_223];
    bool _208 = _224;
    if (0 == _224)
    goto _jump2591;
    bool _225 = true;
    bool _226 = !_225;
    _208 = _226;
    _jump2591:;
    void_t _227;
    if (!_208)
    goto _jump2592;
    _a3_void_t _228;
    // Computing bound for w
    bool _229 = false;
    bool _230 = !_229;
    _a3_int64_t _231;
    if (!_230)
    goto _jump2593;
    _a3_int64_t _232;
    // Computing bound for w
    _232.d0 = g;
    if (g > 0) 
    goto _jump2594;
    fail_assertion("non-positive loop bound");
    _jump2594:;
    // Computing bound for x
    _232.d1 = g;
    if (g > 0) 
    goto _jump2595;
    fail_assertion("non-positive loop bound");
    _jump2595:;
    // Computing bound for y
    _232.d2 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2596;
    fail_assertion("non-positive loop bound");
    _jump2596:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= g;
    _233 *= g;
    _233 *= _116.d1;
    _233 *= sizeof(int64_t);
    _232.data = jpl_alloc(_233);
    int64_t _234 = 0; // y
    int64_t _235 = 0; // x
    int64_t _236 = 0; // w
    _jump2597:; // Begin body of loop
    int64_t _237 = 0;
    _237 *= _232.d0;
    _237 += _236;
    _237 *= _232.d1;
    _237 += _235;
    _237 *= _232.d2;
    _237 += _234;
    _232.data[_237] = _234;
    _234++;
    if (_234 < _116.d1)
    goto _jump2597;
    _234 = 0;
    _235++;
    if (_235 < g)
    goto _jump2597;
    _235 = 0;
    _236++;
    if (_236 < g)
    goto _jump2597;
    // End body of loop
    _231 = _232;
    goto _jump2598;
    _jump2593:;
    _a3_int64_t _238;
    // Computing bound for w
    _238.d0 = g;
    if (g > 0) 
    goto _jump2599;
    fail_assertion("non-positive loop bound");
    _jump2599:;
    // Computing bound for x
    _238.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump2600;
    fail_assertion("non-positive loop bound");
    _jump2600:;
    // Computing bound for y
    _238.d2 = _116.d0;
    if (_116.d0 > 0) 
    goto _jump2601;
    fail_assertion("non-positive loop bound");
    _jump2601:;
    // Computing total size of heap memory to allocate
    int64_t _239 = 1;
    _239 *= g;
    _239 *= e.d0;
    _239 *= _116.d0;
    _239 *= sizeof(int64_t);
    _238.data = jpl_alloc(_239);
    int64_t _240 = 0; // y
    int64_t _241 = 0; // x
    int64_t _242 = 0; // w
    _jump2602:; // Begin body of loop
    int64_t _243 = 0;
    _243 *= _238.d0;
    _243 += _242;
    _243 *= _238.d1;
    _243 += _241;
    _243 *= _238.d2;
    _243 += _240;
    _238.data[_243] = _116.d0;
    _240++;
    if (_240 < _116.d0)
    goto _jump2602;
    _240 = 0;
    _241++;
    if (_241 < e.d0)
    goto _jump2602;
    _241 = 0;
    _242++;
    if (_242 < g)
    goto _jump2602;
    // End body of loop
    _231 = _238;
    _jump2598:;
    int64_t _244 = 211;
    bool _245 = true;
    bool _246 = !_245;
    int64_t _247;
    if (!_246)
    goto _jump2603;
    _247 = _116.d2;
    goto _jump2604;
    _jump2603:;
    _247 = e.d1;
    _jump2604:;
    if (_244 >= 0)
    goto _jump2605;
    fail_assertion("negative array index");
    _jump2605:;
    if (_244 < _231.d0)
    goto _jump2606;
    fail_assertion("index too large");
    _jump2606:;
    if (_116.d2 >= 0)
    goto _jump2607;
    fail_assertion("negative array index");
    _jump2607:;
    if (_116.d2 < _231.d1)
    goto _jump2608;
    fail_assertion("index too large");
    _jump2608:;
    if (_247 >= 0)
    goto _jump2609;
    fail_assertion("negative array index");
    _jump2609:;
    if (_247 < _231.d2)
    goto _jump2610;
    fail_assertion("index too large");
    _jump2610:;
    int64_t _248 = 0;
    _248 *= _231.d0;
    _248 += _244;
    _248 *= _231.d1;
    _248 += _116.d2;
    _248 *= _231.d2;
    _248 += _247;
    int64_t _249 = _231.data[_248];
    _228.d0 = _249;
    if (_249 > 0) 
    goto _jump2611;
    fail_assertion("non-positive loop bound");
    _jump2611:;
    // Computing bound for x
    _228.d1 = g;
    if (g > 0) 
    goto _jump2612;
    fail_assertion("non-positive loop bound");
    _jump2612:;
    // Computing bound for y
    _228.d2 = _116.d0;
    if (_116.d0 > 0) 
    goto _jump2613;
    fail_assertion("non-positive loop bound");
    _jump2613:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= _249;
    _250 *= g;
    _250 *= _116.d0;
    _250 *= sizeof(void_t);
    _228.data = jpl_alloc(_250);
    int64_t _251 = 0; // y
    int64_t _252 = 0; // x
    int64_t _253 = 0; // w
    _jump2614:; // Begin body of loop
    double _254 = 1.0;
    double _255 = _154.r;
    bool _256 = _254 == _255;
    void_t _257;
    if (!_256)
    goto _jump2615;
    rgba _258 = j();
    _a1_rgba _259;
    _259.d0 = 2;
    _259.data = jpl_alloc(sizeof(rgba) * 2);
    _259.data[0] = _154;
    _259.data[1] = _258;
    _a1_int64_t _260;
    _260.d0 = 1;
    _260.data = jpl_alloc(sizeof(int64_t) * 1);
    _260.data[0] = _116.d0;
    void_t _261 = b(_259, _260);
    _257 = _261;
    goto _jump2616;
    _jump2615:;
    _a1_rgba _262;
    // Computing bound for z
    _262.d0 = _252;
    if (_252 > 0) 
    goto _jump2617;
    fail_assertion("non-positive loop bound");
    _jump2617:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _252;
    _263 *= sizeof(rgba);
    _262.data = jpl_alloc(_263);
    int64_t _264 = 0; // z
    _jump2618:; // Begin body of loop
    int64_t _265 = 0;
    _265 *= _262.d0;
    _265 += _264;
    _262.data[_265] = _154;
    _264++;
    if (_264 < _252)
    goto _jump2618;
    // End body of loop
    _a1_int64_t _266;
    // Computing bound for z
    _266.d0 = g;
    if (g > 0) 
    goto _jump2619;
    fail_assertion("non-positive loop bound");
    _jump2619:;
    // Computing total size of heap memory to allocate
    int64_t _267 = 1;
    _267 *= g;
    _267 *= sizeof(int64_t);
    _266.data = jpl_alloc(_267);
    int64_t _268 = 0; // z
    _jump2620:; // Begin body of loop
    int64_t _269 = 0;
    _269 *= _266.d0;
    _269 += _268;
    _266.data[_269] = e.d1;
    _268++;
    if (_268 < g)
    goto _jump2620;
    // End body of loop
    void_t _270 = b(_262, _266);
    _257 = _270;
    _jump2616:;
    int64_t _271 = 0;
    _271 *= _228.d0;
    _271 += _253;
    _271 *= _228.d1;
    _271 += _252;
    _271 *= _228.d2;
    _271 += _251;
    _228.data[_271] = _257;
    _251++;
    if (_251 < _116.d0)
    goto _jump2614;
    _251 = 0;
    _252++;
    if (_252 < g)
    goto _jump2614;
    _252 = 0;
    _253++;
    if (_253 < _249)
    goto _jump2614;
    // End body of loop
    int64_t _272;
    // Computing bound for w
    if (_116.d0 > 0) 
    goto _jump2621;
    fail_assertion("non-positive loop bound");
    _jump2621:;
    // Computing bound for x
    if (g > 0) 
    goto _jump2622;
    fail_assertion("non-positive loop bound");
    _jump2622:;
    _272 = 0;
    int64_t _273 = 0; // x
    int64_t _274 = 0; // w
    _jump2623:; // Begin body of loop
    int64_t _275 = 811;
    _272 += _275;
    _273++;
    if (_273 < g)
    goto _jump2623;
    _273 = 0;
    _274++;
    if (_274 < _116.d0)
    goto _jump2623;
    // End body of loop
    int64_t _276 = -_272;
    bool _278 = false;
    bool _279 = !_278;
    bool _280 = !_279;
    bool _277 = _280;
    if (0 != _280)
    goto _jump2624;
    double _281 = 88.0;
    bool _282 = _281 != i;
    bool _283 = !_282;
    _277 = _283;
    _jump2624:;
    int64_t _284;
    if (!_277)
    goto _jump2625;
    _284 = _116.d0;
    goto _jump2626;
    _jump2625:;
    int64_t _285;
    // Computing bound for w
    _a2_int64_t _286;
    // Computing bound for w
    _286.d0 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2627;
    fail_assertion("non-positive loop bound");
    _jump2627:;
    // Computing bound for x
    _286.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump2628;
    fail_assertion("non-positive loop bound");
    _jump2628:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= _116.d1;
    _287 *= e.d0;
    _287 *= sizeof(int64_t);
    _286.data = jpl_alloc(_287);
    int64_t _288 = 0; // x
    int64_t _289 = 0; // w
    _jump2629:; // Begin body of loop
    int64_t _290 = 0;
    _290 *= _286.d0;
    _290 += _289;
    _290 *= _286.d1;
    _290 += _288;
    _286.data[_290] = g;
    _288++;
    if (_288 < e.d0)
    goto _jump2629;
    _288 = 0;
    _289++;
    if (_289 < _116.d1)
    goto _jump2629;
    // End body of loop
    if (_116.d1 >= 0)
    goto _jump2630;
    fail_assertion("negative array index");
    _jump2630:;
    if (_116.d1 < _286.d0)
    goto _jump2631;
    fail_assertion("index too large");
    _jump2631:;
    if (_116.d2 >= 0)
    goto _jump2632;
    fail_assertion("negative array index");
    _jump2632:;
    if (_116.d2 < _286.d1)
    goto _jump2633;
    fail_assertion("index too large");
    _jump2633:;
    int64_t _291 = 0;
    _291 *= _286.d0;
    _291 += _116.d1;
    _291 *= _286.d1;
    _291 += _116.d2;
    int64_t _292 = _286.data[_291];
    if (_292 > 0) 
    goto _jump2634;
    fail_assertion("non-positive loop bound");
    _jump2634:;
    // Computing bound for x
    int64_t _293;
    // Computing bound for w
    int64_t _294 = -f;
    if (_294 > 0) 
    goto _jump2635;
    fail_assertion("non-positive loop bound");
    _jump2635:;
    // Computing bound for x
    int64_t _295 = 740;
    if (_295 > 0) 
    goto _jump2636;
    fail_assertion("non-positive loop bound");
    _jump2636:;
    // Computing bound for y
    if (g > 0) 
    goto _jump2637;
    fail_assertion("non-positive loop bound");
    _jump2637:;
    _293 = 0;
    int64_t _296 = 0; // y
    int64_t _297 = 0; // x
    int64_t _298 = 0; // w
    _jump2638:; // Begin body of loop
    _293 += _116.d0;
    _296++;
    if (_296 < g)
    goto _jump2638;
    _296 = 0;
    _297++;
    if (_297 < _295)
    goto _jump2638;
    _297 = 0;
    _298++;
    if (_298 < _294)
    goto _jump2638;
    // End body of loop
    if (_293 > 0) 
    goto _jump2639;
    fail_assertion("non-positive loop bound");
    _jump2639:;
    _285 = 0;
    int64_t _299 = 0; // x
    int64_t _300 = 0; // w
    _jump2640:; // Begin body of loop
    _285 += _299;
    _299++;
    if (_299 < _293)
    goto _jump2640;
    _299 = 0;
    _300++;
    if (_300 < _292)
    goto _jump2640;
    // End body of loop
    _284 = _285;
    _jump2626:;
    if (_276 >= 0)
    goto _jump2641;
    fail_assertion("negative array index");
    _jump2641:;
    if (_276 < _228.d0)
    goto _jump2642;
    fail_assertion("index too large");
    _jump2642:;
    if (_116.d1 >= 0)
    goto _jump2643;
    fail_assertion("negative array index");
    _jump2643:;
    if (_116.d1 < _228.d1)
    goto _jump2644;
    fail_assertion("index too large");
    _jump2644:;
    if (_284 >= 0)
    goto _jump2645;
    fail_assertion("negative array index");
    _jump2645:;
    if (_284 < _228.d2)
    goto _jump2646;
    fail_assertion("index too large");
    _jump2646:;
    int64_t _301 = 0;
    _301 *= _228.d0;
    _301 += _276;
    _301 *= _228.d1;
    _301 += _116.d1;
    _301 *= _228.d2;
    _301 += _284;
    void_t _302 = _228.data[_301];
    _227 = _302;
    goto _jump2647;
    _jump2592:;
    _a3_void_t _303;
    // Computing bound for w
    int64_t _304 = 576;
    int64_t _305 = _304 + _116.d0;
    _303.d0 = _305;
    if (_305 > 0) 
    goto _jump2648;
    fail_assertion("non-positive loop bound");
    _jump2648:;
    // Computing bound for x
    _303.d1 = _116.d0;
    if (_116.d0 > 0) 
    goto _jump2649;
    fail_assertion("non-positive loop bound");
    _jump2649:;
    // Computing bound for y
    int64_t _306 = -e.d0;
    _303.d2 = _306;
    if (_306 > 0) 
    goto _jump2650;
    fail_assertion("non-positive loop bound");
    _jump2650:;
    // Computing total size of heap memory to allocate
    int64_t _307 = 1;
    _307 *= _305;
    _307 *= _116.d0;
    _307 *= _306;
    _307 *= sizeof(void_t);
    _303.data = jpl_alloc(_307);
    int64_t _308 = 0; // y
    int64_t _309 = 0; // x
    int64_t _310 = 0; // w
    _jump2651:; // Begin body of loop
    int64_t _311 = 264;
    bool _312 = _311 == _116.d0;
    bool _313;
    if (!_312)
    goto _jump2652;
    bool _314 = true;
    _313 = _314;
    goto _jump2653;
    _jump2652:;
    bool _315 = false;
    _313 = _315;
    _jump2653:;
    void_t _316;
    if (!_313)
    goto _jump2654;
    _a1_rgba _317;
    // Computing bound for z
    _317.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump2655;
    fail_assertion("non-positive loop bound");
    _jump2655:;
    // Computing total size of heap memory to allocate
    int64_t _318 = 1;
    _318 *= e.d1;
    _318 *= sizeof(rgba);
    _317.data = jpl_alloc(_318);
    int64_t _319 = 0; // z
    _jump2656:; // Begin body of loop
    int64_t _320 = 0;
    _320 *= _317.d0;
    _320 += _319;
    _317.data[_320] = _154;
    _319++;
    if (_319 < e.d1)
    goto _jump2656;
    // End body of loop
    _a1_int64_t _321;
    // Computing bound for z
    int64_t _322 = 303;
    _321.d0 = _322;
    if (_322 > 0) 
    goto _jump2657;
    fail_assertion("non-positive loop bound");
    _jump2657:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= _322;
    _323 *= sizeof(int64_t);
    _321.data = jpl_alloc(_323);
    int64_t _324 = 0; // z
    _jump2658:; // Begin body of loop
    int64_t _325 = 0;
    _325 *= _321.d0;
    _325 += _324;
    _321.data[_325] = e.d1;
    _324++;
    if (_324 < _322)
    goto _jump2658;
    // End body of loop
    void_t _326 = b(_317, _321);
    _316 = _326;
    goto _jump2659;
    _jump2654:;
    _a1_rgba _327;
    // Computing bound for z
    _327.d0 = f;
    if (f > 0) 
    goto _jump2660;
    fail_assertion("non-positive loop bound");
    _jump2660:;
    // Computing total size of heap memory to allocate
    int64_t _328 = 1;
    _328 *= f;
    _328 *= sizeof(rgba);
    _327.data = jpl_alloc(_328);
    int64_t _329 = 0; // z
    _jump2661:; // Begin body of loop
    int64_t _330 = 0;
    _330 *= _327.d0;
    _330 += _329;
    _327.data[_330] = _154;
    _329++;
    if (_329 < f)
    goto _jump2661;
    // End body of loop
    _a1_int64_t _331;
    _331.d0 = 1;
    _331.data = jpl_alloc(sizeof(int64_t) * 1);
    _331.data[0] = f;
    void_t _332 = b(_327, _331);
    _316 = _332;
    _jump2659:;
    int64_t _333 = 0;
    _333 *= _303.d0;
    _333 += _310;
    _333 *= _303.d1;
    _333 += _309;
    _333 *= _303.d2;
    _333 += _308;
    _303.data[_333] = _316;
    _308++;
    if (_308 < _306)
    goto _jump2651;
    _308 = 0;
    _309++;
    if (_309 < _116.d0)
    goto _jump2651;
    _309 = 0;
    _310++;
    if (_310 < _305)
    goto _jump2651;
    // End body of loop
    int64_t _334 = _116.d1 % e.d0;
    if (_116.d2 >= 0)
    goto _jump2662;
    fail_assertion("negative array index");
    _jump2662:;
    if (_116.d2 < _303.d0)
    goto _jump2663;
    fail_assertion("index too large");
    _jump2663:;
    if (_116.d2 >= 0)
    goto _jump2664;
    fail_assertion("negative array index");
    _jump2664:;
    if (_116.d2 < _303.d1)
    goto _jump2665;
    fail_assertion("index too large");
    _jump2665:;
    if (_334 >= 0)
    goto _jump2666;
    fail_assertion("negative array index");
    _jump2666:;
    if (_334 < _303.d2)
    goto _jump2667;
    fail_assertion("index too large");
    _jump2667:;
    int64_t _335 = 0;
    _335 *= _303.d0;
    _335 += _116.d2;
    _335 *= _303.d1;
    _335 += _116.d2;
    _335 *= _303.d2;
    _335 += _334;
    void_t _336 = _303.data[_335];
    _227 = _336;
    _jump2647:;
    _a1_int64_t _337 = c(_207, _227);
    double _338 = _154.r;
    _a2_double _339;
    // Computing bound for y
    _339.d0 = _116.d0;
    if (_116.d0 > 0) 
    goto _jump2668;
    fail_assertion("non-positive loop bound");
    _jump2668:;
    // Computing bound for z
    _339.d1 = g;
    if (g > 0) 
    goto _jump2669;
    fail_assertion("non-positive loop bound");
    _jump2669:;
    // Computing total size of heap memory to allocate
    int64_t _340 = 1;
    _340 *= _116.d0;
    _340 *= g;
    _340 *= sizeof(double);
    _339.data = jpl_alloc(_340);
    int64_t _341 = 0; // z
    int64_t _342 = 0; // y
    _jump2670:; // Begin body of loop
    double _343 = 39.0;
    int64_t _344 = 0;
    _344 *= _339.d0;
    _344 += _342;
    _344 *= _339.d1;
    _344 += _341;
    _339.data[_344] = _343;
    _341++;
    if (_341 < g)
    goto _jump2670;
    _341 = 0;
    _342++;
    if (_342 < _116.d0)
    goto _jump2670;
    // End body of loop
    int64_t _345 = 391;
    if (_116.d2 >= 0)
    goto _jump2671;
    fail_assertion("negative array index");
    _jump2671:;
    if (_116.d2 < _339.d0)
    goto _jump2672;
    fail_assertion("index too large");
    _jump2672:;
    if (_345 >= 0)
    goto _jump2673;
    fail_assertion("negative array index");
    _jump2673:;
    if (_345 < _339.d1)
    goto _jump2674;
    fail_assertion("index too large");
    _jump2674:;
    int64_t _346 = 0;
    _346 *= _339.d0;
    _346 += _116.d2;
    _346 *= _339.d1;
    _346 += _345;
    double _347 = _339.data[_346];
    double _348 = _338 / _347;
    double _349 = -_348;
    bool _350 = _349 < d;
    _a3_rgba _351;
    if (!_350)
    goto _jump2675;
    _a2__a3_rgba _352;
    // Computing bound for y
    int64_t _353;
    // Computing bound for y
    if (e.d1 > 0) 
    goto _jump2676;
    fail_assertion("non-positive loop bound");
    _jump2676:;
    // Computing bound for z
    if (_116.d2 > 0) 
    goto _jump2677;
    fail_assertion("non-positive loop bound");
    _jump2677:;
    // Computing bound for A
    if (_337.d0 > 0) 
    goto _jump2678;
    fail_assertion("non-positive loop bound");
    _jump2678:;
    _353 = 0;
    int64_t _354 = 0; // A
    int64_t _355 = 0; // z
    int64_t _356 = 0; // y
    _jump2679:; // Begin body of loop
    _353 += g;
    _354++;
    if (_354 < _337.d0)
    goto _jump2679;
    _354 = 0;
    _355++;
    if (_355 < _116.d2)
    goto _jump2679;
    _355 = 0;
    _356++;
    if (_356 < e.d1)
    goto _jump2679;
    // End body of loop
    _352.d0 = _353;
    if (_353 > 0) 
    goto _jump2680;
    fail_assertion("non-positive loop bound");
    _jump2680:;
    // Computing bound for z
    _352.d1 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2681;
    fail_assertion("non-positive loop bound");
    _jump2681:;
    // Computing total size of heap memory to allocate
    int64_t _357 = 1;
    _357 *= _353;
    _357 *= _116.d1;
    _357 *= sizeof(_a3_rgba);
    _352.data = jpl_alloc(_357);
    int64_t _358 = 0; // z
    int64_t _359 = 0; // y
    _jump2682:; // Begin body of loop
    bool _360 = true;
    _a3_rgba _361;
    if (!_360)
    goto _jump2683;
    _a3_rgba _362;
    // Computing bound for A
    _362.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump2684;
    fail_assertion("non-positive loop bound");
    _jump2684:;
    // Computing bound for B
    _362.d1 = f;
    if (f > 0) 
    goto _jump2685;
    fail_assertion("non-positive loop bound");
    _jump2685:;
    // Computing bound for C
    int64_t _363 = -f;
    _362.d2 = _363;
    if (_363 > 0) 
    goto _jump2686;
    fail_assertion("non-positive loop bound");
    _jump2686:;
    // Computing total size of heap memory to allocate
    int64_t _364 = 1;
    _364 *= e.d0;
    _364 *= f;
    _364 *= _363;
    _364 *= sizeof(rgba);
    _362.data = jpl_alloc(_364);
    int64_t _365 = 0; // C
    int64_t _366 = 0; // B
    int64_t _367 = 0; // A
    _jump2687:; // Begin body of loop
    int64_t _368 = 0;
    _368 *= _362.d0;
    _368 += _367;
    _368 *= _362.d1;
    _368 += _366;
    _368 *= _362.d2;
    _368 += _365;
    _362.data[_368] = _154;
    _365++;
    if (_365 < _363)
    goto _jump2687;
    _365 = 0;
    _366++;
    if (_366 < f)
    goto _jump2687;
    _366 = 0;
    _367++;
    if (_367 < e.d0)
    goto _jump2687;
    // End body of loop
    _361 = _362;
    goto _jump2688;
    _jump2683:;
    _a3_rgba _369;
    // Computing bound for A
    if (_116.d2 >= 0)
    goto _jump2689;
    fail_assertion("negative array index");
    _jump2689:;
    if (_116.d2 < _337.d0)
    goto _jump2690;
    fail_assertion("index too large");
    _jump2690:;
    int64_t _370 = 0;
    _370 *= _337.d0;
    _370 += _116.d2;
    int64_t _371 = _337.data[_370];
    _369.d0 = _371;
    if (_371 > 0) 
    goto _jump2691;
    fail_assertion("non-positive loop bound");
    _jump2691:;
    // Computing bound for B
    int64_t _372;
    // Computing bound for A
    if (_116.d0 > 0) 
    goto _jump2692;
    fail_assertion("non-positive loop bound");
    _jump2692:;
    // Computing bound for B
    if (f > 0) 
    goto _jump2693;
    fail_assertion("non-positive loop bound");
    _jump2693:;
    _372 = 0;
    int64_t _373 = 0; // B
    int64_t _374 = 0; // A
    _jump2694:; // Begin body of loop
    _372 += _116.d2;
    _373++;
    if (_373 < f)
    goto _jump2694;
    _373 = 0;
    _374++;
    if (_374 < _116.d0)
    goto _jump2694;
    // End body of loop
    _369.d1 = _372;
    if (_372 > 0) 
    goto _jump2695;
    fail_assertion("non-positive loop bound");
    _jump2695:;
    // Computing bound for C
    _369.d2 = e.d0;
    if (e.d0 > 0) 
    goto _jump2696;
    fail_assertion("non-positive loop bound");
    _jump2696:;
    // Computing total size of heap memory to allocate
    int64_t _375 = 1;
    _375 *= _371;
    _375 *= _372;
    _375 *= e.d0;
    _375 *= sizeof(rgba);
    _369.data = jpl_alloc(_375);
    int64_t _376 = 0; // C
    int64_t _377 = 0; // B
    int64_t _378 = 0; // A
    _jump2697:; // Begin body of loop
    rgba _379 = j();
    int64_t _380 = 0;
    _380 *= _369.d0;
    _380 += _378;
    _380 *= _369.d1;
    _380 += _377;
    _380 *= _369.d2;
    _380 += _376;
    _369.data[_380] = _379;
    _376++;
    if (_376 < e.d0)
    goto _jump2697;
    _376 = 0;
    _377++;
    if (_377 < _372)
    goto _jump2697;
    _377 = 0;
    _378++;
    if (_378 < _371)
    goto _jump2697;
    // End body of loop
    _361 = _369;
    _jump2688:;
    int64_t _381 = 0;
    _381 *= _352.d0;
    _381 += _359;
    _381 *= _352.d1;
    _381 += _358;
    _352.data[_381] = _361;
    _358++;
    if (_358 < _116.d1)
    goto _jump2682;
    _358 = 0;
    _359++;
    if (_359 < _353)
    goto _jump2682;
    // End body of loop
    int64_t _382;
    // Computing bound for y
    if (_116.d1 > 0) 
    goto _jump2698;
    fail_assertion("non-positive loop bound");
    _jump2698:;
    // Computing bound for z
    if (g > 0) 
    goto _jump2699;
    fail_assertion("non-positive loop bound");
    _jump2699:;
    // Computing bound for A
    if (_116.d1 > 0) 
    goto _jump2700;
    fail_assertion("non-positive loop bound");
    _jump2700:;
    _382 = 0;
    int64_t _383 = 0; // A
    int64_t _384 = 0; // z
    int64_t _385 = 0; // y
    _jump2701:; // Begin body of loop
    _382 += _116.d1;
    _383++;
    if (_383 < _116.d1)
    goto _jump2701;
    _383 = 0;
    _384++;
    if (_384 < g)
    goto _jump2701;
    _384 = 0;
    _385++;
    if (_385 < _116.d1)
    goto _jump2701;
    // End body of loop
    if (_382 >= 0)
    goto _jump2702;
    fail_assertion("negative array index");
    _jump2702:;
    if (_382 < _352.d0)
    goto _jump2703;
    fail_assertion("index too large");
    _jump2703:;
    if (_116.d0 >= 0)
    goto _jump2704;
    fail_assertion("negative array index");
    _jump2704:;
    if (_116.d0 < _352.d1)
    goto _jump2705;
    fail_assertion("index too large");
    _jump2705:;
    int64_t _386 = 0;
    _386 *= _352.d0;
    _386 += _382;
    _386 *= _352.d1;
    _386 += _116.d0;
    _a3_rgba _387 = _352.data[_386];
    _351 = _387;
    goto _jump2706;
    _jump2675:;
    _a3_rgba _388;
    // Computing bound for y
    _388.d0 = _116.d1;
    if (_116.d1 > 0) 
    goto _jump2707;
    fail_assertion("non-positive loop bound");
    _jump2707:;
    // Computing bound for z
    _388.d1 = f;
    if (f > 0) 
    goto _jump2708;
    fail_assertion("non-positive loop bound");
    _jump2708:;
    // Computing bound for A
    _388.d2 = _337.d0;
    if (_337.d0 > 0) 
    goto _jump2709;
    fail_assertion("non-positive loop bound");
    _jump2709:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _116.d1;
    _389 *= f;
    _389 *= _337.d0;
    _389 *= sizeof(rgba);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // A
    int64_t _391 = 0; // z
    int64_t _392 = 0; // y
    _jump2710:; // Begin body of loop
    int64_t _393 = 0;
    _393 *= _388.d0;
    _393 += _392;
    _393 *= _388.d1;
    _393 += _391;
    _393 *= _388.d2;
    _393 += _390;
    _388.data[_393] = _154;
    _390++;
    if (_390 < _337.d0)
    goto _jump2710;
    _390 = 0;
    _391++;
    if (_391 < f)
    goto _jump2710;
    _391 = 0;
    _392++;
    if (_392 < _116.d1)
    goto _jump2710;
    // End body of loop
    _351 = _388;
    _jump2706:;
    int64_t _394;
    // Computing bound for y
    if (_337.d0 > 0) 
    goto _jump2711;
    fail_assertion("non-positive loop bound");
    _jump2711:;
    // Computing bound for z
    if (_116.d0 > 0) 
    goto _jump2712;
    fail_assertion("non-positive loop bound");
    _jump2712:;
    // Computing bound for A
    int64_t _395;
    // Computing bound for y
    if (_116.d1 > 0) 
    goto _jump2713;
    fail_assertion("non-positive loop bound");
    _jump2713:;
    _395 = 0;
    int64_t _396 = 0; // y
    _jump2714:; // Begin body of loop
    int64_t _397;
    // Computing bound for z
    _a2_int64_t _398;
    // Computing bound for z
    int64_t _399 = -g;
    _398.d0 = _399;
    if (_399 > 0) 
    goto _jump2715;
    fail_assertion("non-positive loop bound");
    _jump2715:;
    // Computing bound for A
    _398.d1 = _116.d2;
    if (_116.d2 > 0) 
    goto _jump2716;
    fail_assertion("non-positive loop bound");
    _jump2716:;
    // Computing total size of heap memory to allocate
    int64_t _400 = 1;
    _400 *= _399;
    _400 *= _116.d2;
    _400 *= sizeof(int64_t);
    _398.data = jpl_alloc(_400);
    int64_t _401 = 0; // A
    int64_t _402 = 0; // z
    _jump2717:; // Begin body of loop
    int64_t _403 = 0;
    _403 *= _398.d0;
    _403 += _402;
    _403 *= _398.d1;
    _403 += _401;
    _398.data[_403] = _337.d0;
    _401++;
    if (_401 < _116.d2)
    goto _jump2717;
    _401 = 0;
    _402++;
    if (_402 < _399)
    goto _jump2717;
    // End body of loop
    int64_t _404;
    // Computing bound for z
    if (f > 0) 
    goto _jump2718;
    fail_assertion("non-positive loop bound");
    _jump2718:;
    // Computing bound for A
    if (f > 0) 
    goto _jump2719;
    fail_assertion("non-positive loop bound");
    _jump2719:;
    _404 = 0;
    int64_t _405 = 0; // A
    int64_t _406 = 0; // z
    _jump2720:; // Begin body of loop
    _404 += _405;
    _405++;
    if (_405 < f)
    goto _jump2720;
    _405 = 0;
    _406++;
    if (_406 < f)
    goto _jump2720;
    // End body of loop
    int64_t _407 = _404 % _116.d2;
    int64_t _408 = 900;
    if (_407 >= 0)
    goto _jump2721;
    fail_assertion("negative array index");
    _jump2721:;
    if (_407 < _398.d0)
    goto _jump2722;
    fail_assertion("index too large");
    _jump2722:;
    if (_408 >= 0)
    goto _jump2723;
    fail_assertion("negative array index");
    _jump2723:;
    if (_408 < _398.d1)
    goto _jump2724;
    fail_assertion("index too large");
    _jump2724:;
    int64_t _409 = 0;
    _409 *= _398.d0;
    _409 += _407;
    _409 *= _398.d1;
    _409 += _408;
    int64_t _410 = _398.data[_409];
    if (_410 > 0) 
    goto _jump2725;
    fail_assertion("non-positive loop bound");
    _jump2725:;
    _397 = 0;
    int64_t _411 = 0; // z
    _jump2726:; // Begin body of loop
    _397 += _116.d0;
    _411++;
    if (_411 < _410)
    goto _jump2726;
    // End body of loop
    _395 += _397;
    _396++;
    if (_396 < _116.d1)
    goto _jump2714;
    // End body of loop
    if (_395 > 0) 
    goto _jump2727;
    fail_assertion("non-positive loop bound");
    _jump2727:;
    _394 = 0;
    int64_t _412 = 0; // A
    int64_t _413 = 0; // z
    int64_t _414 = 0; // y
    _jump2728:; // Begin body of loop
    int64_t _415 = 407;
    _394 += _415;
    _412++;
    if (_412 < _395)
    goto _jump2728;
    _412 = 0;
    _413++;
    if (_413 < _116.d0)
    goto _jump2728;
    _413 = 0;
    _414++;
    if (_414 < _337.d0)
    goto _jump2728;
    // End body of loop
    if (g >= 0)
    goto _jump2729;
    fail_assertion("negative array index");
    _jump2729:;
    if (g < _351.d0)
    goto _jump2730;
    fail_assertion("index too large");
    _jump2730:;
    if (_394 >= 0)
    goto _jump2731;
    fail_assertion("negative array index");
    _jump2731:;
    if (_394 < _351.d1)
    goto _jump2732;
    fail_assertion("index too large");
    _jump2732:;
    if (e.d1 >= 0)
    goto _jump2733;
    fail_assertion("negative array index");
    _jump2733:;
    if (e.d1 < _351.d2)
    goto _jump2734;
    fail_assertion("index too large");
    _jump2734:;
    int64_t _416 = 0;
    _416 *= _351.d0;
    _416 += g;
    _416 *= _351.d1;
    _416 += _394;
    _416 *= _351.d2;
    _416 += e.d1;
    rgba _417 = _351.data[_416];
    return _417;
}

void_t s(rgba t, double u, _a3_double v) {
    int64_t _0 = g + n;
    bool _1 = l == _0;
    bool _2 = !_1;
    void_t _3;
    if (!_2)
    goto _jump3223;
    bool _4 = true;
    bool _5;
    if (!_4)
    goto _jump3224;
    bool _7 = f != q;
    bool _8;
    if (!_7)
    goto _jump3225;
    bool _9 = true;
    _8 = _9;
    goto _jump3226;
    _jump3225:;
    bool _10 = true;
    _8 = _10;
    _jump3226:;
    bool _6 = _8;
    if (0 == _8)
    goto _jump3227;
    bool _11 = false;
    bool _12 = !_11;
    _6 = _12;
    _jump3227:;
    _5 = _6;
    goto _jump3228;
    _jump3224:;
    bool _14 = false;
    bool _15 = !_14;
    bool _13 = _15;
    if (0 == _15)
    goto _jump3229;
    bool _17 = true;
    bool _18 = !_17;
    bool _16 = _18;
    if (0 != _18)
    goto _jump3230;
    bool _19 = r > g;
    _16 = _19;
    _jump3230:;
    _13 = _16;
    _jump3229:;
    _5 = _13;
    _jump3228:;
    double _20;
    if (!_5)
    goto _jump3231;
    double _21;
    // Computing bound for z
    if (r > 0) 
    goto _jump3232;
    fail_assertion("non-positive loop bound");
    _jump3232:;
    _21 = 0;
    int64_t _22 = 0; // z
    _jump3233:; // Begin body of loop
    _21 += u;
    _22++;
    if (_22 < r)
    goto _jump3233;
    // End body of loop
    _20 = _21;
    goto _jump3234;
    _jump3231:;
    double _23;
    // Computing bound for z
    if (v.d1 > 0) 
    goto _jump3235;
    fail_assertion("non-positive loop bound");
    _jump3235:;
    _23 = 0;
    int64_t _24 = 0; // z
    _jump3236:; // Begin body of loop
    _23 += i;
    _24++;
    if (_24 < v.d1)
    goto _jump3236;
    // End body of loop
    _20 = _23;
    _jump3234:;
    _a3_double _25;
    // Computing bound for z
    _25.d0 = v.d2;
    if (v.d2 > 0) 
    goto _jump3237;
    fail_assertion("non-positive loop bound");
    _jump3237:;
    // Computing bound for A
    _25.d1 = v.d0;
    if (v.d0 > 0) 
    goto _jump3238;
    fail_assertion("non-positive loop bound");
    _jump3238:;
    // Computing bound for B
    _25.d2 = m;
    if (m > 0) 
    goto _jump3239;
    fail_assertion("non-positive loop bound");
    _jump3239:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= v.d2;
    _26 *= v.d0;
    _26 *= m;
    _26 *= sizeof(double);
    _25.data = jpl_alloc(_26);
    int64_t _27 = 0; // B
    int64_t _28 = 0; // A
    int64_t _29 = 0; // z
    _jump3240:; // Begin body of loop
    double _30 = 70.0;
    double _31 = fmod(i, _30);
    int64_t _32 = 0;
    _32 *= _25.d0;
    _32 += _29;
    _32 *= _25.d1;
    _32 += _28;
    _32 *= _25.d2;
    _32 += _27;
    _25.data[_32] = _31;
    _27++;
    if (_27 < m)
    goto _jump3240;
    _27 = 0;
    _28++;
    if (_28 < v.d0)
    goto _jump3240;
    _28 = 0;
    _29++;
    if (_29 < v.d2)
    goto _jump3240;
    // End body of loop
    void_t _33 = s(t, _20, _25);
    _3 = _33;
    goto _jump3241;
    _jump3223:;
    double _34 = i - d;
    double _35 = 50.0;
    double _36;
    // Computing bound for z
    if (m > 0) 
    goto _jump3242;
    fail_assertion("non-positive loop bound");
    _jump3242:;
    // Computing bound for A
    if (v.d2 > 0) 
    goto _jump3243;
    fail_assertion("non-positive loop bound");
    _jump3243:;
    // Computing bound for B
    if (q > 0) 
    goto _jump3244;
    fail_assertion("non-positive loop bound");
    _jump3244:;
    _36 = 0;
    int64_t _37 = 0; // B
    int64_t _38 = 0; // A
    int64_t _39 = 0; // z
    _jump3245:; // Begin body of loop
    _36 += d;
    _37++;
    if (_37 < q)
    goto _jump3245;
    _37 = 0;
    _38++;
    if (_38 < v.d2)
    goto _jump3245;
    _38 = 0;
    _39++;
    if (_39 < m)
    goto _jump3245;
    // End body of loop
    double _40 = _35 / _36;
    bool _41 = _34 == _40;
    bool _42 = !_41;
    _a2_void_t _43;
    if (!_42)
    goto _jump3246;
    bool _44 = false;
    bool _45 = false;
    bool _46 = _44 != _45;
    bool _47 = true;
    bool _48 = _46 == _47;
    bool _49;
    if (!_48)
    goto _jump3247;
    bool _50 = false;
    bool _51 = !_50;
    bool _52;
    if (!_51)
    goto _jump3248;
    bool _53 = true;
    bool _54 = !_53;
    _52 = _54;
    goto _jump3249;
    _jump3248:;
    bool _55 = u != u;
    _52 = _55;
    _jump3249:;
    _49 = _52;
    goto _jump3250;
    _jump3247:;
    bool _56 = true;
    int64_t _57 = 914;
    if (p >= 0)
    goto _jump3251;
    fail_assertion("negative array index");
    _jump3251:;
    if (p < k.d0)
    goto _jump3252;
    fail_assertion("index too large");
    _jump3252:;
    if (q >= 0)
    goto _jump3253;
    fail_assertion("negative array index");
    _jump3253:;
    if (q < k.d1)
    goto _jump3254;
    fail_assertion("index too large");
    _jump3254:;
    if (_57 >= 0)
    goto _jump3255;
    fail_assertion("negative array index");
    _jump3255:;
    if (_57 < k.d2)
    goto _jump3256;
    fail_assertion("index too large");
    _jump3256:;
    int64_t _58 = 0;
    _58 *= k.d0;
    _58 += p;
    _58 *= k.d1;
    _58 += q;
    _58 *= k.d2;
    _58 += _57;
    bool _59 = k.data[_58];
    bool _60 = _56 == _59;
    _49 = _60;
    _jump3250:;
    _a2_void_t _61;
    if (!_49)
    goto _jump3257;
    _a2_void_t _62;
    // Computing bound for z
    int64_t _63 = -n;
    _62.d0 = _63;
    if (_63 > 0) 
    goto _jump3258;
    fail_assertion("non-positive loop bound");
    _jump3258:;
    // Computing bound for A
    int64_t _64 = r * v.d0;
    int64_t _65 = v.d2 + _64;
    _62.d1 = _65;
    if (_65 > 0) 
    goto _jump3259;
    fail_assertion("non-positive loop bound");
    _jump3259:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= _63;
    _66 *= _65;
    _66 *= sizeof(void_t);
    _62.data = jpl_alloc(_66);
    int64_t _67 = 0; // A
    int64_t _68 = 0; // z
    _jump3260:; // Begin body of loop
    _a1_rgba _69;
    // Computing bound for B
    _69.d0 = f;
    if (f > 0) 
    goto _jump3261;
    fail_assertion("non-positive loop bound");
    _jump3261:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= f;
    _70 *= sizeof(rgba);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // B
    _jump3262:; // Begin body of loop
    rgba _72 = j();
    int64_t _73 = 0;
    _73 *= _69.d0;
    _73 += _71;
    _69.data[_73] = _72;
    _71++;
    if (_71 < f)
    goto _jump3262;
    // End body of loop
    _a1_int64_t _74;
    _74.d0 = 2;
    _74.data = jpl_alloc(sizeof(int64_t) * 2);
    _74.data[0] = _67;
    _74.data[1] = p;
    void_t _75 = b(_69, _74);
    int64_t _76 = 0;
    _76 *= _62.d0;
    _76 += _68;
    _76 *= _62.d1;
    _76 += _67;
    _62.data[_76] = _75;
    _67++;
    if (_67 < _65)
    goto _jump3260;
    _67 = 0;
    _68++;
    if (_68 < _63)
    goto _jump3260;
    // End body of loop
    _61 = _62;
    goto _jump3263;
    _jump3257:;
    _a2_void_t _77;
    // Computing bound for z
    _77.d0 = p;
    if (p > 0) 
    goto _jump3264;
    fail_assertion("non-positive loop bound");
    _jump3264:;
    // Computing bound for A
    _77.d1 = n;
    if (n > 0) 
    goto _jump3265;
    fail_assertion("non-positive loop bound");
    _jump3265:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= p;
    _78 *= n;
    _78 *= sizeof(void_t);
    _77.data = jpl_alloc(_78);
    int64_t _79 = 0; // A
    int64_t _80 = 0; // z
    _jump3266:; // Begin body of loop
    void_t _81 = s(t, u, v);
    int64_t _82 = 0;
    _82 *= _77.d0;
    _82 += _80;
    _82 *= _77.d1;
    _82 += _79;
    _77.data[_82] = _81;
    _79++;
    if (_79 < n)
    goto _jump3266;
    _79 = 0;
    _80++;
    if (_80 < p)
    goto _jump3266;
    // End body of loop
    _61 = _77;
    _jump3263:;
    _43 = _61;
    goto _jump3267;
    _jump3246:;
    _a2__a2_void_t _83;
    // Computing bound for z
    _83.d0 = f;
    if (f > 0) 
    goto _jump3268;
    fail_assertion("non-positive loop bound");
    _jump3268:;
    // Computing bound for A
    _83.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump3269;
    fail_assertion("non-positive loop bound");
    _jump3269:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= f;
    _84 *= v.d2;
    _84 *= sizeof(_a2_void_t);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // A
    int64_t _86 = 0; // z
    _jump3270:; // Begin body of loop
    _a2_void_t _87;
    // Computing bound for B
    _87.d0 = _85;
    if (_85 > 0) 
    goto _jump3271;
    fail_assertion("non-positive loop bound");
    _jump3271:;
    // Computing bound for C
    _87.d1 = f;
    if (f > 0) 
    goto _jump3272;
    fail_assertion("non-positive loop bound");
    _jump3272:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= _85;
    _88 *= f;
    _88 *= sizeof(void_t);
    _87.data = jpl_alloc(_88);
    int64_t _89 = 0; // C
    int64_t _90 = 0; // B
    _jump3273:; // Begin body of loop
    rgba _91 = j();
    void_t _92 = s(_91, u, v);
    int64_t _93 = 0;
    _93 *= _87.d0;
    _93 += _90;
    _93 *= _87.d1;
    _93 += _89;
    _87.data[_93] = _92;
    _89++;
    if (_89 < f)
    goto _jump3273;
    _89 = 0;
    _90++;
    if (_90 < _85)
    goto _jump3273;
    // End body of loop
    int64_t _94 = 0;
    _94 *= _83.d0;
    _94 += _86;
    _94 *= _83.d1;
    _94 += _85;
    _83.data[_94] = _87;
    _85++;
    if (_85 < v.d2)
    goto _jump3270;
    _85 = 0;
    _86++;
    if (_86 < f)
    goto _jump3270;
    // End body of loop
    if (q >= 0)
    goto _jump3274;
    fail_assertion("negative array index");
    _jump3274:;
    if (q < _83.d0)
    goto _jump3275;
    fail_assertion("index too large");
    _jump3275:;
    if (l >= 0)
    goto _jump3276;
    fail_assertion("negative array index");
    _jump3276:;
    if (l < _83.d1)
    goto _jump3277;
    fail_assertion("index too large");
    _jump3277:;
    int64_t _95 = 0;
    _95 *= _83.d0;
    _95 += q;
    _95 *= _83.d1;
    _95 += l;
    _a2_void_t _96 = _83.data[_95];
    _43 = _96;
    _jump3267:;
    int64_t _97 = -m;
    if (m >= 0)
    goto _jump3278;
    fail_assertion("negative array index");
    _jump3278:;
    if (m < _43.d0)
    goto _jump3279;
    fail_assertion("index too large");
    _jump3279:;
    if (_97 >= 0)
    goto _jump3280;
    fail_assertion("negative array index");
    _jump3280:;
    if (_97 < _43.d1)
    goto _jump3281;
    fail_assertion("index too large");
    _jump3281:;
    int64_t _98 = 0;
    _98 *= _43.d0;
    _98 += m;
    _98 *= _43.d1;
    _98 += _97;
    void_t _99 = _43.data[_98];
    _3 = _99;
    _jump3241:;
    return _3;
    bool _100 = r != f;
    bool _101;
    if (!_100)
    goto _jump3282;
    bool _102 = false;
    _101 = _102;
    goto _jump3283;
    _jump3282:;
    bool _103 = false;
    _101 = _103;
    _jump3283:;
    int64_t _104;
    if (!_101)
    goto _jump3284;
    _a1_int64_t _105;
    _105.d0 = 1;
    _105.data = jpl_alloc(sizeof(int64_t) * 1);
    _105.data[0] = f;
    if (n >= 0)
    goto _jump3285;
    fail_assertion("negative array index");
    _jump3285:;
    if (n < _105.d0)
    goto _jump3286;
    fail_assertion("index too large");
    _jump3286:;
    int64_t _106 = 0;
    _106 *= _105.d0;
    _106 += n;
    int64_t _107 = _105.data[_106];
    _104 = _107;
    goto _jump3287;
    _jump3284:;
    _104 = p;
    _jump3287:;
    _a1_int64_t _108;
    _108.d0 = 1;
    _108.data = jpl_alloc(sizeof(int64_t) * 1);
    _108.data[0] = _104;
    bool _109 = false;
    _a1_int64_t _110;
    // Computing bound for C
    int64_t _111;
    // Computing bound for C
    if (p > 0) 
    goto _jump3288;
    fail_assertion("non-positive loop bound");
    _jump3288:;
    // Computing bound for D
    if (g > 0) 
    goto _jump3289;
    fail_assertion("non-positive loop bound");
    _jump3289:;
    _111 = 0;
    int64_t _112 = 0; // D
    int64_t _113 = 0; // C
    _jump3290:; // Begin body of loop
    _111 += v.d0;
    _112++;
    if (_112 < g)
    goto _jump3290;
    _112 = 0;
    _113++;
    if (_113 < p)
    goto _jump3290;
    // End body of loop
    int64_t _114 = n + _111;
    _110.d0 = _114;
    if (_114 > 0) 
    goto _jump3291;
    fail_assertion("non-positive loop bound");
    _jump3291:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _114;
    _115 *= sizeof(int64_t);
    _110.data = jpl_alloc(_115);
    int64_t _116 = 0; // C
    _jump3292:; // Begin body of loop
    int64_t _117 = 0;
    _117 *= _110.d0;
    _117 += _116;
    _110.data[_117] = g;
    _116++;
    if (_116 < _114)
    goto _jump3292;
    // End body of loop
    _a3__a1_int64_t _118;
    // Computing bound for C
    _118.d0 = p;
    if (p > 0) 
    goto _jump3293;
    fail_assertion("non-positive loop bound");
    _jump3293:;
    // Computing bound for D
    int64_t _119;
    // Computing bound for C
    if (l > 0) 
    goto _jump3294;
    fail_assertion("non-positive loop bound");
    _jump3294:;
    // Computing bound for D
    if (f > 0) 
    goto _jump3295;
    fail_assertion("non-positive loop bound");
    _jump3295:;
    // Computing bound for E
    if (q > 0) 
    goto _jump3296;
    fail_assertion("non-positive loop bound");
    _jump3296:;
    _119 = 0;
    int64_t _120 = 0; // E
    int64_t _121 = 0; // D
    int64_t _122 = 0; // C
    _jump3297:; // Begin body of loop
    _119 += _120;
    _120++;
    if (_120 < q)
    goto _jump3297;
    _120 = 0;
    _121++;
    if (_121 < f)
    goto _jump3297;
    _121 = 0;
    _122++;
    if (_122 < l)
    goto _jump3297;
    // End body of loop
    _118.d1 = _119;
    if (_119 > 0) 
    goto _jump3298;
    fail_assertion("non-positive loop bound");
    _jump3298:;
    // Computing bound for E
    _118.d2 = v.d1;
    if (v.d1 > 0) 
    goto _jump3299;
    fail_assertion("non-positive loop bound");
    _jump3299:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= p;
    _123 *= _119;
    _123 *= v.d1;
    _123 *= sizeof(_a1_int64_t);
    _118.data = jpl_alloc(_123);
    int64_t _124 = 0; // E
    int64_t _125 = 0; // D
    int64_t _126 = 0; // C
    _jump3300:; // Begin body of loop
    int64_t _127 = 0;
    _127 *= _118.d0;
    _127 += _126;
    _127 *= _118.d1;
    _127 += _125;
    _127 *= _118.d2;
    _127 += _124;
    _118.data[_127] = _108;
    _124++;
    if (_124 < v.d1)
    goto _jump3300;
    _124 = 0;
    _125++;
    if (_125 < _119)
    goto _jump3300;
    _125 = 0;
    _126++;
    if (_126 < p)
    goto _jump3300;
    // End body of loop
    _a1__a3__a1_int64_t _128;
    _128.d0 = 1;
    _128.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 1);
    _128.data[0] = _118;
    int64_t _129;
    // Computing bound for C
    if (v.d0 > 0) 
    goto _jump3301;
    fail_assertion("non-positive loop bound");
    _jump3301:;
    // Computing bound for D
    int64_t _130;
    if (!_109)
    goto _jump3302;
    _130 = v.d0;
    goto _jump3303;
    _jump3302:;
    _130 = l;
    _jump3303:;
    int64_t _131 = _130 + v.d1;
    if (_131 > 0) 
    goto _jump3304;
    fail_assertion("non-positive loop bound");
    _jump3304:;
    // Computing bound for E
    int64_t _132;
    // Computing bound for C
    if (_108.d0 > 0) 
    goto _jump3305;
    fail_assertion("non-positive loop bound");
    _jump3305:;
    _132 = 0;
    int64_t _133 = 0; // C
    _jump3306:; // Begin body of loop
    _132 += n;
    _133++;
    if (_133 < _108.d0)
    goto _jump3306;
    // End body of loop
    if (_132 > 0) 
    goto _jump3307;
    fail_assertion("non-positive loop bound");
    _jump3307:;
    _129 = 0;
    int64_t _134 = 0; // E
    int64_t _135 = 0; // D
    int64_t _136 = 0; // C
    _jump3308:; // Begin body of loop
    _129 += v.d1;
    _134++;
    if (_134 < _132)
    goto _jump3308;
    _134 = 0;
    _135++;
    if (_135 < _131)
    goto _jump3308;
    _135 = 0;
    _136++;
    if (_136 < v.d0)
    goto _jump3308;
    // End body of loop
    if (_129 >= 0)
    goto _jump3309;
    fail_assertion("negative array index");
    _jump3309:;
    if (_129 < _128.d0)
    goto _jump3310;
    fail_assertion("index too large");
    _jump3310:;
    int64_t _137 = 0;
    _137 *= _128.d0;
    _137 += _129;
    _a3__a1_int64_t _138 = _128.data[_137];
    int64_t _139 = 659;
    if (r >= 0)
    goto _jump3311;
    fail_assertion("negative array index");
    _jump3311:;
    if (r < _138.d0)
    goto _jump3312;
    fail_assertion("index too large");
    _jump3312:;
    if (q >= 0)
    goto _jump3313;
    fail_assertion("negative array index");
    _jump3313:;
    if (q < _138.d1)
    goto _jump3314;
    fail_assertion("index too large");
    _jump3314:;
    if (_139 >= 0)
    goto _jump3315;
    fail_assertion("negative array index");
    _jump3315:;
    if (_139 < _138.d2)
    goto _jump3316;
    fail_assertion("index too large");
    _jump3316:;
    int64_t _140 = 0;
    _140 *= _138.d0;
    _140 += r;
    _140 *= _138.d1;
    _140 += q;
    _140 *= _138.d2;
    _140 += _139;
    _a1_int64_t _141 = _138.data[_140];
    bool _142 = i == u;
    bool _143;
    if (!_142)
    goto _jump3317;
    bool _144 = !_109;
    _143 = _144;
    goto _jump3318;
    _jump3317:;
    int64_t _145 = 488;
    bool _146 = _145 < v.d1;
    _143 = _146;
    _jump3318:;
    bool _147;
    if (!_143)
    goto _jump3319;
    int64_t _148 = 53;
    if (v.d2 >= 0)
    goto _jump3320;
    fail_assertion("negative array index");
    _jump3320:;
    if (v.d2 < k.d0)
    goto _jump3321;
    fail_assertion("index too large");
    _jump3321:;
    if (_148 >= 0)
    goto _jump3322;
    fail_assertion("negative array index");
    _jump3322:;
    if (_148 < k.d1)
    goto _jump3323;
    fail_assertion("index too large");
    _jump3323:;
    if (v.d2 >= 0)
    goto _jump3324;
    fail_assertion("negative array index");
    _jump3324:;
    if (v.d2 < k.d2)
    goto _jump3325;
    fail_assertion("index too large");
    _jump3325:;
    int64_t _149 = 0;
    _149 *= k.d0;
    _149 += v.d2;
    _149 *= k.d1;
    _149 += _148;
    _149 *= k.d2;
    _149 += v.d2;
    bool _150 = k.data[_149];
    _147 = _150;
    goto _jump3326;
    _jump3319:;
    bool _151 = true;
    bool _152 = !_151;
    _147 = _152;
    _jump3326:;
    bool _153 = !_147;
    _a1_int64_t _154;
    if (!_153)
    goto _jump3327;
    bool _155 = true;
    _a1_int64_t _156;
    if (!_155)
    goto _jump3328;
    _a1_int64_t _157;
    // Computing bound for C
    _157.d0 = g;
    if (g > 0) 
    goto _jump3329;
    fail_assertion("non-positive loop bound");
    _jump3329:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= g;
    _158 *= sizeof(int64_t);
    _157.data = jpl_alloc(_158);
    int64_t _159 = 0; // C
    _jump3330:; // Begin body of loop
    int64_t _160 = 0;
    _160 *= _157.d0;
    _160 += _159;
    _157.data[_160] = v.d2;
    _159++;
    if (_159 < g)
    goto _jump3330;
    // End body of loop
    if (n >= 0)
    goto _jump3331;
    fail_assertion("negative array index");
    _jump3331:;
    if (n < _157.d0)
    goto _jump3332;
    fail_assertion("index too large");
    _jump3332:;
    int64_t _161 = 0;
    _161 *= _157.d0;
    _161 += n;
    int64_t _162 = _157.data[_161];
    _a1_int64_t _163;
    _163.d0 = 1;
    _163.data = jpl_alloc(sizeof(int64_t) * 1);
    _163.data[0] = _162;
    _156 = _163;
    goto _jump3333;
    _jump3328:;
    _a1_int64_t _164;
    // Computing bound for C
    _164.d0 = g;
    if (g > 0) 
    goto _jump3334;
    fail_assertion("non-positive loop bound");
    _jump3334:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= g;
    _165 *= sizeof(int64_t);
    _164.data = jpl_alloc(_165);
    int64_t _166 = 0; // C
    _jump3335:; // Begin body of loop
    int64_t _167 = 0;
    _167 *= _164.d0;
    _167 += _166;
    _164.data[_167] = _108.d0;
    _166++;
    if (_166 < g)
    goto _jump3335;
    // End body of loop
    _156 = _164;
    _jump3333:;
    _154 = _156;
    goto _jump3336;
    _jump3327:;
    double _168 = 88.0;
    bool _169 = true;
    rgba _170;
    if (!_169)
    goto _jump3337;
    _170 = t;
    goto _jump3338;
    _jump3337:;
    _170 = t;
    _jump3338:;
    double _171 = a(_170);
    bool _172 = _168 != _171;
    _a1_int64_t _173;
    if (!_172)
    goto _jump3339;
    _a2__a1_int64_t _174;
    // Computing bound for C
    int64_t _175;
    // Computing bound for C
    if (g > 0) 
    goto _jump3340;
    fail_assertion("non-positive loop bound");
    _jump3340:;
    // Computing bound for D
    if (n > 0) 
    goto _jump3341;
    fail_assertion("non-positive loop bound");
    _jump3341:;
    _175 = 0;
    int64_t _176 = 0; // D
    int64_t _177 = 0; // C
    _jump3342:; // Begin body of loop
    _175 += r;
    _176++;
    if (_176 < n)
    goto _jump3342;
    _176 = 0;
    _177++;
    if (_177 < g)
    goto _jump3342;
    // End body of loop
    _174.d0 = _175;
    if (_175 > 0) 
    goto _jump3343;
    fail_assertion("non-positive loop bound");
    _jump3343:;
    // Computing bound for D
    _174.d1 = _108.d0;
    if (_108.d0 > 0) 
    goto _jump3344;
    fail_assertion("non-positive loop bound");
    _jump3344:;
    // Computing total size of heap memory to allocate
    int64_t _178 = 1;
    _178 *= _175;
    _178 *= _108.d0;
    _178 *= sizeof(_a1_int64_t);
    _174.data = jpl_alloc(_178);
    int64_t _179 = 0; // D
    int64_t _180 = 0; // C
    _jump3345:; // Begin body of loop
    _a1_int64_t _181;
    _181.d0 = 1;
    _181.data = jpl_alloc(sizeof(int64_t) * 1);
    _181.data[0] = n;
    int64_t _182 = 0;
    _182 *= _174.d0;
    _182 += _180;
    _182 *= _174.d1;
    _182 += _179;
    _174.data[_182] = _181;
    _179++;
    if (_179 < _108.d0)
    goto _jump3345;
    _179 = 0;
    _180++;
    if (_180 < _175)
    goto _jump3345;
    // End body of loop
    double _183 = 57.0;
    double _184 = _183 / u;
    _a3_double _185;
    // Computing bound for C
    _185.d0 = v.d2;
    if (v.d2 > 0) 
    goto _jump3346;
    fail_assertion("non-positive loop bound");
    _jump3346:;
    // Computing bound for D
    _185.d1 = g;
    if (g > 0) 
    goto _jump3347;
    fail_assertion("non-positive loop bound");
    _jump3347:;
    // Computing bound for E
    _185.d2 = n;
    if (n > 0) 
    goto _jump3348;
    fail_assertion("non-positive loop bound");
    _jump3348:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= v.d2;
    _186 *= g;
    _186 *= n;
    _186 *= sizeof(double);
    _185.data = jpl_alloc(_186);
    int64_t _187 = 0; // E
    int64_t _188 = 0; // D
    int64_t _189 = 0; // C
    _jump3349:; // Begin body of loop
    int64_t _190 = 0;
    _190 *= _185.d0;
    _190 += _189;
    _190 *= _185.d1;
    _190 += _188;
    _190 *= _185.d2;
    _190 += _187;
    _185.data[_190] = u;
    _187++;
    if (_187 < n)
    goto _jump3349;
    _187 = 0;
    _188++;
    if (_188 < g)
    goto _jump3349;
    _188 = 0;
    _189++;
    if (_189 < v.d2)
    goto _jump3349;
    // End body of loop
    void_t _191 = s(t, _184, _185);
    _a1_int64_t _192 = c(_174, _191);
    _173 = _192;
    goto _jump3350;
    _jump3339:;
    _a1_int64_t _193;
    _193.d0 = 2;
    _193.data = jpl_alloc(sizeof(int64_t) * 2);
    _193.data[0] = p;
    _193.data[1] = q;
    _173 = _193;
    _jump3350:;
    _154 = _173;
    _jump3336:;
    _a1__a1_int64_t _194;
    _194.d0 = 3;
    _194.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _194.data[0] = _110;
    _194.data[1] = _141;
    _194.data[2] = _154;
    if (f >= 0)
    goto _jump3351;
    fail_assertion("negative array index");
    _jump3351:;
    if (f < _194.d0)
    goto _jump3352;
    fail_assertion("index too large");
    _jump3352:;
    int64_t _195 = 0;
    _195 *= _194.d0;
    _195 += f;
    _a1_int64_t _196 = _194.data[_195];
    bool _197 = v.d0 != _196.d0;
    _a3_bool _198;
    if (!_197)
    goto _jump3353;
    _a3_bool _199;
    // Computing bound for F
    _199.d0 = l;
    if (l > 0) 
    goto _jump3354;
    fail_assertion("non-positive loop bound");
    _jump3354:;
    // Computing bound for G
    int64_t _200 = 37;
    _199.d1 = _200;
    if (_200 > 0) 
    goto _jump3355;
    fail_assertion("non-positive loop bound");
    _jump3355:;
    // Computing bound for H
    _199.d2 = v.d1;
    if (v.d1 > 0) 
    goto _jump3356;
    fail_assertion("non-positive loop bound");
    _jump3356:;
    // Computing total size of heap memory to allocate
    int64_t _201 = 1;
    _201 *= l;
    _201 *= _200;
    _201 *= v.d1;
    _201 *= sizeof(bool);
    _199.data = jpl_alloc(_201);
    int64_t _202 = 0; // H
    int64_t _203 = 0; // G
    int64_t _204 = 0; // F
    _jump3357:; // Begin body of loop
    int64_t _207 = 970;
    bool _208 = l > _207;
    bool _206 = _208;
    if (0 != _208)
    goto _jump3358;
    _206 = _109;
    _jump3358:;
    bool _205 = _206;
    if (0 != _206)
    goto _jump3359;
    bool _210 = !_109;
    bool _209 = _210;
    if (0 != _210)
    goto _jump3360;
    bool _211 = i > d;
    _209 = _211;
    _jump3360:;
    _205 = _209;
    _jump3359:;
    int64_t _212 = 0;
    _212 *= _199.d0;
    _212 += _204;
    _212 *= _199.d1;
    _212 += _203;
    _212 *= _199.d2;
    _212 += _202;
    _199.data[_212] = _205;
    _202++;
    if (_202 < v.d1)
    goto _jump3357;
    _202 = 0;
    _203++;
    if (_203 < _200)
    goto _jump3357;
    _203 = 0;
    _204++;
    if (_204 < l)
    goto _jump3357;
    // End body of loop
    _198 = _199;
    goto _jump3361;
    _jump3353:;
    _a3_bool _213;
    if (!_109)
    goto _jump3362;
    bool _214 = true;
    _a3_bool _215;
    if (!_214)
    goto _jump3363;
    _a1__a3_bool _216;
    // Computing bound for F
    _216.d0 = g;
    if (g > 0) 
    goto _jump3364;
    fail_assertion("non-positive loop bound");
    _jump3364:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= g;
    _217 *= sizeof(_a3_bool);
    _216.data = jpl_alloc(_217);
    int64_t _218 = 0; // F
    _jump3365:; // Begin body of loop
    int64_t _219 = 0;
    _219 *= _216.d0;
    _219 += _218;
    _216.data[_219] = k;
    _218++;
    if (_218 < g)
    goto _jump3365;
    // End body of loop
    if (m >= 0)
    goto _jump3366;
    fail_assertion("negative array index");
    _jump3366:;
    if (m < _216.d0)
    goto _jump3367;
    fail_assertion("index too large");
    _jump3367:;
    int64_t _220 = 0;
    _220 *= _216.d0;
    _220 += m;
    _a3_bool _221 = _216.data[_220];
    _215 = _221;
    goto _jump3368;
    _jump3363:;
    _215 = k;
    _jump3368:;
    _213 = _215;
    goto _jump3369;
    _jump3362:;
    _a3__a3_bool _222;
    // Computing bound for F
    _222.d0 = q;
    if (q > 0) 
    goto _jump3370;
    fail_assertion("non-positive loop bound");
    _jump3370:;
    // Computing bound for G
    _222.d1 = p;
    if (p > 0) 
    goto _jump3371;
    fail_assertion("non-positive loop bound");
    _jump3371:;
    // Computing bound for H
    int64_t _223 = n * v.d2;
    _222.d2 = _223;
    if (_223 > 0) 
    goto _jump3372;
    fail_assertion("non-positive loop bound");
    _jump3372:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= q;
    _224 *= p;
    _224 *= _223;
    _224 *= sizeof(_a3_bool);
    _222.data = jpl_alloc(_224);
    int64_t _225 = 0; // H
    int64_t _226 = 0; // G
    int64_t _227 = 0; // F
    _jump3373:; // Begin body of loop
    int64_t _228 = 0;
    _228 *= _222.d0;
    _228 += _227;
    _228 *= _222.d1;
    _228 += _226;
    _228 *= _222.d2;
    _228 += _225;
    _222.data[_228] = k;
    _225++;
    if (_225 < _223)
    goto _jump3373;
    _225 = 0;
    _226++;
    if (_226 < p)
    goto _jump3373;
    _226 = 0;
    _227++;
    if (_227 < q)
    goto _jump3373;
    // End body of loop
    int64_t _229 = 277;
    if (v.d1 >= 0)
    goto _jump3374;
    fail_assertion("negative array index");
    _jump3374:;
    if (v.d1 < _222.d0)
    goto _jump3375;
    fail_assertion("index too large");
    _jump3375:;
    if (q >= 0)
    goto _jump3376;
    fail_assertion("negative array index");
    _jump3376:;
    if (q < _222.d1)
    goto _jump3377;
    fail_assertion("index too large");
    _jump3377:;
    if (_229 >= 0)
    goto _jump3378;
    fail_assertion("negative array index");
    _jump3378:;
    if (_229 < _222.d2)
    goto _jump3379;
    fail_assertion("index too large");
    _jump3379:;
    int64_t _230 = 0;
    _230 *= _222.d0;
    _230 += v.d1;
    _230 *= _222.d1;
    _230 += q;
    _230 *= _222.d2;
    _230 += _229;
    _a3_bool _231 = _222.data[_230];
    _213 = _231;
    _jump3369:;
    _198 = _213;
    _jump3361:;
    _a3_bool _232;
    // Computing bound for F
    _232.d0 = f;
    if (f > 0) 
    goto _jump3380;
    fail_assertion("non-positive loop bound");
    _jump3380:;
    // Computing bound for G
    _232.d1 = l;
    if (l > 0) 
    goto _jump3381;
    fail_assertion("non-positive loop bound");
    _jump3381:;
    // Computing bound for H
    _a3_int64_t _233;
    // Computing bound for F
    _233.d0 = m;
    if (m > 0) 
    goto _jump3382;
    fail_assertion("non-positive loop bound");
    _jump3382:;
    // Computing bound for G
    _233.d1 = r;
    if (r > 0) 
    goto _jump3383;
    fail_assertion("non-positive loop bound");
    _jump3383:;
    // Computing bound for H
    _233.d2 = p;
    if (p > 0) 
    goto _jump3384;
    fail_assertion("non-positive loop bound");
    _jump3384:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= m;
    _234 *= r;
    _234 *= p;
    _234 *= sizeof(int64_t);
    _233.data = jpl_alloc(_234);
    int64_t _235 = 0; // H
    int64_t _236 = 0; // G
    int64_t _237 = 0; // F
    _jump3385:; // Begin body of loop
    int64_t _238 = 0;
    _238 *= _233.d0;
    _238 += _237;
    _238 *= _233.d1;
    _238 += _236;
    _238 *= _233.d2;
    _238 += _235;
    _233.data[_238] = l;
    _235++;
    if (_235 < p)
    goto _jump3385;
    _235 = 0;
    _236++;
    if (_236 < r)
    goto _jump3385;
    _236 = 0;
    _237++;
    if (_237 < m)
    goto _jump3385;
    // End body of loop
    bool _239 = !_109;
    int64_t _240;
    if (!_239)
    goto _jump3386;
    _240 = n;
    goto _jump3387;
    _jump3386:;
    _240 = m;
    _jump3387:;
    int64_t _241 = -_240;
    if (_241 >= 0)
    goto _jump3388;
    fail_assertion("negative array index");
    _jump3388:;
    if (_241 < _233.d0)
    goto _jump3389;
    fail_assertion("index too large");
    _jump3389:;
    if (v.d1 >= 0)
    goto _jump3390;
    fail_assertion("negative array index");
    _jump3390:;
    if (v.d1 < _233.d1)
    goto _jump3391;
    fail_assertion("index too large");
    _jump3391:;
    if (m >= 0)
    goto _jump3392;
    fail_assertion("negative array index");
    _jump3392:;
    if (m < _233.d2)
    goto _jump3393;
    fail_assertion("index too large");
    _jump3393:;
    int64_t _242 = 0;
    _242 *= _233.d0;
    _242 += _241;
    _242 *= _233.d1;
    _242 += v.d1;
    _242 *= _233.d2;
    _242 += m;
    int64_t _243 = _233.data[_242];
    _232.d2 = _243;
    if (_243 > 0) 
    goto _jump3394;
    fail_assertion("non-positive loop bound");
    _jump3394:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= f;
    _244 *= l;
    _244 *= _243;
    _244 *= sizeof(bool);
    _232.data = jpl_alloc(_244);
    int64_t _245 = 0; // H
    int64_t _246 = 0; // G
    int64_t _247 = 0; // F
    _jump3395:; // Begin body of loop
    bool _248 = false;
    bool _249;
    if (!_248)
    goto _jump3396;
    bool _250 = !_109;
    _249 = _250;
    goto _jump3397;
    _jump3396:;
    _a1_bool _251;
    // Computing bound for I
    _251.d0 = n;
    if (n > 0) 
    goto _jump3398;
    fail_assertion("non-positive loop bound");
    _jump3398:;
    // Computing total size of heap memory to allocate
    int64_t _252 = 1;
    _252 *= n;
    _252 *= sizeof(bool);
    _251.data = jpl_alloc(_252);
    int64_t _253 = 0; // I
    _jump3399:; // Begin body of loop
    int64_t _254 = 0;
    _254 *= _251.d0;
    _254 += _253;
    _251.data[_254] = _109;
    _253++;
    if (_253 < n)
    goto _jump3399;
    // End body of loop
    if (q >= 0)
    goto _jump3400;
    fail_assertion("negative array index");
    _jump3400:;
    if (q < _251.d0)
    goto _jump3401;
    fail_assertion("index too large");
    _jump3401:;
    int64_t _255 = 0;
    _255 *= _251.d0;
    _255 += q;
    bool _256 = _251.data[_255];
    _249 = _256;
    _jump3397:;
    int64_t _257 = 0;
    _257 *= _232.d0;
    _257 += _247;
    _257 *= _232.d1;
    _257 += _246;
    _257 *= _232.d2;
    _257 += _245;
    _232.data[_257] = _249;
    _245++;
    if (_245 < _243)
    goto _jump3395;
    _245 = 0;
    _246++;
    if (_246 < l)
    goto _jump3395;
    _246 = 0;
    _247++;
    if (_247 < f)
    goto _jump3395;
    // End body of loop
    _a1__a3_bool _258;
    _258.d0 = 2;
    _258.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _258.data[0] = _198;
    _258.data[1] = _232;
    if (m >= 0)
    goto _jump3402;
    fail_assertion("negative array index");
    _jump3402:;
    if (m < _258.d0)
    goto _jump3403;
    fail_assertion("index too large");
    _jump3403:;
    int64_t _259 = 0;
    _259 *= _258.d0;
    _259 += m;
    _a3_bool _260 = _258.data[_259];
    _a2__a3_double _261;
    // Computing bound for J
    int64_t _262 = 188;
    _261.d0 = _262;
    if (_262 > 0) 
    goto _jump3404;
    fail_assertion("non-positive loop bound");
    _jump3404:;
    // Computing bound for K
    _261.d1 = g;
    if (g > 0) 
    goto _jump3405;
    fail_assertion("non-positive loop bound");
    _jump3405:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _262;
    _263 *= g;
    _263 *= sizeof(_a3_double);
    _261.data = jpl_alloc(_263);
    int64_t _264 = 0; // K
    int64_t _265 = 0; // J
    _jump3406:; // Begin body of loop
    _a3_double _266;
    // Computing bound for L
    _266.d0 = v.d0;
    if (v.d0 > 0) 
    goto _jump3407;
    fail_assertion("non-positive loop bound");
    _jump3407:;
    // Computing bound for M
    _266.d1 = v.d0;
    if (v.d0 > 0) 
    goto _jump3408;
    fail_assertion("non-positive loop bound");
    _jump3408:;
    // Computing bound for N
    bool _267 = false;
    int64_t _268;
    if (!_267)
    goto _jump3409;
    _268 = r;
    goto _jump3410;
    _jump3409:;
    _268 = r;
    _jump3410:;
    _266.d2 = _268;
    if (_268 > 0) 
    goto _jump3411;
    fail_assertion("non-positive loop bound");
    _jump3411:;
    // Computing total size of heap memory to allocate
    int64_t _269 = 1;
    _269 *= v.d0;
    _269 *= v.d0;
    _269 *= _268;
    _269 *= sizeof(double);
    _266.data = jpl_alloc(_269);
    int64_t _270 = 0; // N
    int64_t _271 = 0; // M
    int64_t _272 = 0; // L
    _jump3412:; // Begin body of loop
    int64_t _273 = 0;
    _273 *= _266.d0;
    _273 += _272;
    _273 *= _266.d1;
    _273 += _271;
    _273 *= _266.d2;
    _273 += _270;
    _266.data[_273] = d;
    _270++;
    if (_270 < _268)
    goto _jump3412;
    _270 = 0;
    _271++;
    if (_271 < v.d0)
    goto _jump3412;
    _271 = 0;
    _272++;
    if (_272 < v.d0)
    goto _jump3412;
    // End body of loop
    int64_t _274 = 0;
    _274 *= _261.d0;
    _274 += _265;
    _274 *= _261.d1;
    _274 += _264;
    _261.data[_274] = _266;
    _264++;
    if (_264 < g)
    goto _jump3406;
    _264 = 0;
    _265++;
    if (_265 < _262)
    goto _jump3406;
    // End body of loop
    if (_196.d0 >= 0)
    goto _jump3413;
    fail_assertion("negative array index");
    _jump3413:;
    if (_196.d0 < _261.d0)
    goto _jump3414;
    fail_assertion("index too large");
    _jump3414:;
    if (v.d2 >= 0)
    goto _jump3415;
    fail_assertion("negative array index");
    _jump3415:;
    if (v.d2 < _261.d1)
    goto _jump3416;
    fail_assertion("index too large");
    _jump3416:;
    int64_t _275 = 0;
    _275 *= _261.d0;
    _275 += _196.d0;
    _275 *= _261.d1;
    _275 += v.d2;
    _a3_double _276 = _261.data[_275];
    void_t _277 = s(t, u, _276);
    return _277;
}

void jpl_main(struct args args) {
    _a1_double _0;
    // Computing bound for c
    bool _1 = true;
    double _2;
    if (!_1)
    goto _jump1177;
    double _3 = 85.0;
    _2 = _3;
    goto _jump1178;
    _jump1177:;
    double _4 = 31.0;
    _2 = _4;
    _jump1178:;
    double _5 = 86.0;
    double _6 = -_5;
    bool _7 = _2 == _6;
    int64_t _8;
    if (!_7)
    goto _jump1179;
    int64_t _9;
    // Computing bound for c
    int64_t _10 = 26;
    if (_10 > 0) 
    goto _jump1180;
    fail_assertion("non-positive loop bound");
    _jump1180:;
    _9 = 0;
    int64_t _11 = 0; // c
    _jump1181:; // Begin body of loop
    int64_t _12 = 704;
    int64_t _13 = 829;
    int64_t _14 = _12 / _13;
    _9 += _14;
    _11++;
    if (_11 < _10)
    goto _jump1181;
    // End body of loop
    _8 = _9;
    goto _jump1182;
    _jump1179:;
    int64_t _15 = 555;
    int64_t _16 = -_15;
    int64_t _17 = -_16;
    _8 = _17;
    _jump1182:;
    int64_t _18 = -_8;
    _0.d0 = _18;
    if (_18 > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= _18;
    _19 *= sizeof(double);
    _0.data = jpl_alloc(_19);
    int64_t _20 = 0; // c
    _jump1184:; // Begin body of loop
    double _21;
    // Computing bound for d
    int64_t _22 = -_20;
    if (_22 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing bound for e
    int64_t _23 = _20 - _20;
    int64_t _24 = -_23;
    if (_24 > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    // Computing bound for f
    int64_t _25;
    // Computing bound for d
    int64_t _26;
    // Computing bound for d
    if (_20 > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    _26 = 0;
    int64_t _27 = 0; // d
    _jump1188:; // Begin body of loop
    _26 += _20;
    _27++;
    if (_27 < _20)
    goto _jump1188;
    // End body of loop
    if (_26 > 0) 
    goto _jump1189;
    fail_assertion("non-positive loop bound");
    _jump1189:;
    _25 = 0;
    int64_t _28 = 0; // d
    _jump1190:; // Begin body of loop
    _25 += _20;
    _28++;
    if (_28 < _26)
    goto _jump1190;
    // End body of loop
    if (_25 > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    _21 = 0;
    int64_t _29 = 0; // f
    int64_t _30 = 0; // e
    int64_t _31 = 0; // d
    _jump1192:; // Begin body of loop
    double _32 = 56.0;
    double _33 = -_32;
    double _34 = -_33;
    _21 += _34;
    _29++;
    if (_29 < _25)
    goto _jump1192;
    _29 = 0;
    _30++;
    if (_30 < _24)
    goto _jump1192;
    _30 = 0;
    _31++;
    if (_31 < _22)
    goto _jump1192;
    // End body of loop
    int64_t _35 = 0;
    _35 *= _0.d0;
    _35 += _20;
    _0.data[_35] = _21;
    _20++;
    if (_20 < _18)
    goto _jump1184;
    // End body of loop
    _a1_int64_t _36;
    // Computing bound for c
    int64_t _37 = 643;
    int64_t _38 = -_37;
    int64_t _39 = 823;
    int64_t _40 = -_39;
    int64_t _41 = _38 % _40;
    int64_t _42 = 820;
    int64_t _43 = -_42;
    int64_t _44 = _41 - _43;
    _36.d0 = _44;
    if (_44 > 0) 
    goto _jump1193;
    fail_assertion("non-positive loop bound");
    _jump1193:;
    // Computing total size of heap memory to allocate
    int64_t _45 = 1;
    _45 *= _44;
    _45 *= sizeof(int64_t);
    _36.data = jpl_alloc(_45);
    int64_t _46 = 0; // c
    _jump1194:; // Begin body of loop
    int64_t _47;
    // Computing bound for d
    int64_t _48 = 190;
    if (_48 > 0) 
    goto _jump1195;
    fail_assertion("non-positive loop bound");
    _jump1195:;
    // Computing bound for e
    if (_46 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for f
    int64_t _49 = 759;
    int64_t _50 = -_49;
    int64_t _51 = -_50;
    if (_51 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    _47 = 0;
    int64_t _52 = 0; // f
    int64_t _53 = 0; // e
    int64_t _54 = 0; // d
    _jump1198:; // Begin body of loop
    bool _55 = false;
    bool _56 = !_55;
    int64_t _57;
    if (!_56)
    goto _jump1199;
    _57 = _54;
    goto _jump1200;
    _jump1199:;
    int64_t _58 = _53 * _52;
    _57 = _58;
    _jump1200:;
    _47 += _57;
    _52++;
    if (_52 < _51)
    goto _jump1198;
    _52 = 0;
    _53++;
    if (_53 < _46)
    goto _jump1198;
    _53 = 0;
    _54++;
    if (_54 < _48)
    goto _jump1198;
    // End body of loop
    int64_t _59 = 0;
    _59 *= _36.d0;
    _59 += _46;
    _36.data[_59] = _47;
    _46++;
    if (_46 < _44)
    goto _jump1194;
    // End body of loop
    bool _60 = true;
    bool _61 = !_60;
    _a2_int64_t _62;
    if (!_61)
    goto _jump1201;
    _a2_int64_t _63;
    // Computing bound for c
    int64_t _64 = 698;
    _63.d0 = _64;
    if (_64 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for d
    int64_t _65 = 560;
    int64_t _66 = -_65;
    _63.d1 = _66;
    if (_66 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= _64;
    _67 *= _66;
    _67 *= sizeof(int64_t);
    _63.data = jpl_alloc(_67);
    int64_t _68 = 0; // d
    int64_t _69 = 0; // c
    _jump1204:; // Begin body of loop
    int64_t _70 = 814;
    int64_t _71 = 0;
    _71 *= _63.d0;
    _71 += _69;
    _71 *= _63.d1;
    _71 += _68;
    _63.data[_71] = _70;
    _68++;
    if (_68 < _66)
    goto _jump1204;
    _68 = 0;
    _69++;
    if (_69 < _64)
    goto _jump1204;
    // End body of loop
    _62 = _63;
    goto _jump1205;
    _jump1201:;
    _a2_int64_t _72;
    // Computing bound for c
    int64_t _73 = 609;
    _72.d0 = _73;
    if (_73 > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    // Computing bound for d
    bool _74 = false;
    int64_t _75;
    if (!_74)
    goto _jump1207;
    int64_t _76 = 89;
    _75 = _76;
    goto _jump1208;
    _jump1207:;
    int64_t _77 = 337;
    _75 = _77;
    _jump1208:;
    _72.d1 = _75;
    if (_75 > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= _73;
    _78 *= _75;
    _78 *= sizeof(int64_t);
    _72.data = jpl_alloc(_78);
    int64_t _79 = 0; // d
    int64_t _80 = 0; // c
    _jump1210:; // Begin body of loop
    int64_t _81 = 465;
    int64_t _82 = 0;
    _82 *= _72.d0;
    _82 += _80;
    _82 *= _72.d1;
    _82 += _79;
    _72.data[_82] = _81;
    _79++;
    if (_79 < _75)
    goto _jump1210;
    _79 = 0;
    _80++;
    if (_80 < _73)
    goto _jump1210;
    // End body of loop
    _62 = _72;
    _jump1205:;
    int64_t _83;
    // Computing bound for c
    _a2_int64_t _84;
    // Computing bound for c
    int64_t _85 = 867;
    _84.d0 = _85;
    if (_85 > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing bound for d
    int64_t _86 = 472;
    _84.d1 = _86;
    if (_86 > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= _85;
    _87 *= _86;
    _87 *= sizeof(int64_t);
    _84.data = jpl_alloc(_87);
    int64_t _88 = 0; // d
    int64_t _89 = 0; // c
    _jump1213:; // Begin body of loop
    int64_t _90 = 906;
    int64_t _91 = 0;
    _91 *= _84.d0;
    _91 += _89;
    _91 *= _84.d1;
    _91 += _88;
    _84.data[_91] = _90;
    _88++;
    if (_88 < _86)
    goto _jump1213;
    _88 = 0;
    _89++;
    if (_89 < _85)
    goto _jump1213;
    // End body of loop
    int64_t _92 = 668;
    int64_t _93 = 929;
    int64_t _94 = -_93;
    if (_92 >= 0)
    goto _jump1214;
    fail_assertion("negative array index");
    _jump1214:;
    if (_92 < _84.d0)
    goto _jump1215;
    fail_assertion("index too large");
    _jump1215:;
    if (_94 >= 0)
    goto _jump1216;
    fail_assertion("negative array index");
    _jump1216:;
    if (_94 < _84.d1)
    goto _jump1217;
    fail_assertion("index too large");
    _jump1217:;
    int64_t _95 = 0;
    _95 *= _84.d0;
    _95 += _92;
    _95 *= _84.d1;
    _95 += _94;
    int64_t _96 = _84.data[_95];
    if (_96 > 0) 
    goto _jump1218;
    fail_assertion("non-positive loop bound");
    _jump1218:;
    _83 = 0;
    int64_t _97 = 0; // c
    _jump1219:; // Begin body of loop
    int64_t _98;
    // Computing bound for d
    int64_t _99 = 863;
    if (_99 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    _98 = 0;
    int64_t _100 = 0; // d
    _jump1221:; // Begin body of loop
    _98 += _100;
    _100++;
    if (_100 < _99)
    goto _jump1221;
    // End body of loop
    _83 += _98;
    _97++;
    if (_97 < _96)
    goto _jump1219;
    // End body of loop
    bool _101 = true;
    _a1_bool _102;
    _102.d0 = 1;
    _102.data = jpl_alloc(sizeof(bool) * 1);
    _102.data[0] = _101;
    int64_t _103 = 265;
    int64_t _104 = -_103;
    if (_104 >= 0)
    goto _jump1222;
    fail_assertion("negative array index");
    _jump1222:;
    if (_104 < _102.d0)
    goto _jump1223;
    fail_assertion("index too large");
    _jump1223:;
    int64_t _105 = 0;
    _105 *= _102.d0;
    _105 += _104;
    bool _106 = _102.data[_105];
    int64_t _107;
    if (!_106)
    goto _jump1224;
    int64_t _108 = 692;
    _107 = _108;
    goto _jump1225;
    _jump1224:;
    int64_t _109 = 760;
    int64_t _110 = 602;
    int64_t _111 = _109 - _110;
    int64_t _112 = -_111;
    _107 = _112;
    _jump1225:;
    if (_83 >= 0)
    goto _jump1226;
    fail_assertion("negative array index");
    _jump1226:;
    if (_83 < _62.d0)
    goto _jump1227;
    fail_assertion("index too large");
    _jump1227:;
    if (_107 >= 0)
    goto _jump1228;
    fail_assertion("negative array index");
    _jump1228:;
    if (_107 < _62.d1)
    goto _jump1229;
    fail_assertion("index too large");
    _jump1229:;
    int64_t _113 = 0;
    _113 *= _62.d0;
    _113 += _83;
    _113 *= _62.d1;
    _113 += _107;
    int64_t _114 = _62.data[_113];
    if (_114 >= 0)
    goto _jump1230;
    fail_assertion("negative array index");
    _jump1230:;
    if (_114 < _36.d0)
    goto _jump1231;
    fail_assertion("index too large");
    _jump1231:;
    int64_t _115 = 0;
    _115 *= _36.d0;
    _115 += _114;
    int64_t _116 = _36.data[_115];
    if (_116 >= 0)
    goto _jump1232;
    fail_assertion("negative array index");
    _jump1232:;
    if (_116 < _0.d0)
    goto _jump1233;
    fail_assertion("index too large");
    _jump1233:;
    int64_t _117 = 0;
    _117 *= _0.d0;
    _117 += _116;
    double _118 = _0.data[_117];
    double _119;
    // Computing bound for c
    int64_t _120 = 113;
    if (_120 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    _119 = 0;
    int64_t _121 = 0; // c
    _jump1235:; // Begin body of loop
    double _122 = 23.0;
    double _123 = 25.0;
    double _124 = -_123;
    double _125 = _122 / _124;
    _119 += _125;
    _121++;
    if (_121 < _120)
    goto _jump1235;
    // End body of loop
    double _126 = 30.0;
    _a2_double _127;
    // Computing bound for c
    int64_t _128;
    // Computing bound for c
    int64_t _129 = 348;
    if (_129 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    _128 = 0;
    int64_t _130 = 0; // c
    _jump1237:; // Begin body of loop
    int64_t _131 = 192;
    _128 += _131;
    _130++;
    if (_130 < _129)
    goto _jump1237;
    // End body of loop
    _127.d0 = _128;
    if (_128 > 0) 
    goto _jump1238;
    fail_assertion("non-positive loop bound");
    _jump1238:;
    // Computing bound for d
    int64_t _132 = 325;
    _127.d1 = _132;
    if (_132 > 0) 
    goto _jump1239;
    fail_assertion("non-positive loop bound");
    _jump1239:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _128;
    _133 *= _132;
    _133 *= sizeof(double);
    _127.data = jpl_alloc(_133);
    int64_t _134 = 0; // d
    int64_t _135 = 0; // c
    _jump1240:; // Begin body of loop
    double _136;
    // Computing bound for e
    int64_t _137;
    // Computing bound for e
    int64_t _138 = 75;
    if (_138 > 0) 
    goto _jump1241;
    fail_assertion("non-positive loop bound");
    _jump1241:;
    // Computing bound for f
    int64_t _139 = 988;
    if (_139 > 0) 
    goto _jump1242;
    fail_assertion("non-positive loop bound");
    _jump1242:;
    // Computing bound for g
    if (_135 > 0) 
    goto _jump1243;
    fail_assertion("non-positive loop bound");
    _jump1243:;
    _137 = 0;
    int64_t _140 = 0; // g
    int64_t _141 = 0; // f
    int64_t _142 = 0; // e
    _jump1244:; // Begin body of loop
    int64_t _143 = 8;
    _137 += _143;
    _140++;
    if (_140 < _135)
    goto _jump1244;
    _140 = 0;
    _141++;
    if (_141 < _139)
    goto _jump1244;
    _141 = 0;
    _142++;
    if (_142 < _138)
    goto _jump1244;
    // End body of loop
    if (_137 > 0) 
    goto _jump1245;
    fail_assertion("non-positive loop bound");
    _jump1245:;
    // Computing bound for f
    int64_t _144 = 229;
    if (_144 > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing bound for g
    int64_t _145 = 366;
    if (_145 > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    _136 = 0;
    int64_t _146 = 0; // g
    int64_t _147 = 0; // f
    int64_t _148 = 0; // e
    _jump1248:; // Begin body of loop
    double _149;
    // Computing bound for h
    if (_148 > 0) 
    goto _jump1249;
    fail_assertion("non-positive loop bound");
    _jump1249:;
    // Computing bound for i
    if (_147 > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing bound for j
    if (_147 > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    _149 = 0;
    int64_t _150 = 0; // j
    int64_t _151 = 0; // i
    int64_t _152 = 0; // h
    _jump1252:; // Begin body of loop
    double _153 = 29.0;
    _149 += _153;
    _150++;
    if (_150 < _147)
    goto _jump1252;
    _150 = 0;
    _151++;
    if (_151 < _147)
    goto _jump1252;
    _151 = 0;
    _152++;
    if (_152 < _148)
    goto _jump1252;
    // End body of loop
    _136 += _149;
    _146++;
    if (_146 < _145)
    goto _jump1248;
    _146 = 0;
    _147++;
    if (_147 < _144)
    goto _jump1248;
    _147 = 0;
    _148++;
    if (_148 < _137)
    goto _jump1248;
    // End body of loop
    int64_t _154 = 0;
    _154 *= _127.d0;
    _154 += _135;
    _154 *= _127.d1;
    _154 += _134;
    _127.data[_154] = _136;
    _134++;
    if (_134 < _132)
    goto _jump1240;
    _134 = 0;
    _135++;
    if (_135 < _128)
    goto _jump1240;
    // End body of loop
    int64_t _155 = 82;
    int64_t _156 = -_155;
    int64_t _157 = -_156;
    int64_t _158;
    // Computing bound for c
    int64_t _159 = 371;
    int64_t _160 = -_159;
    int64_t _161 = 942;
    int64_t _162 = _160 - _161;
    if (_162 > 0) 
    goto _jump1253;
    fail_assertion("non-positive loop bound");
    _jump1253:;
    // Computing bound for d
    int64_t _163 = 206;
    int64_t _164 = -_163;
    int64_t _165 = 789;
    int64_t _166 = _164 * _165;
    if (_166 > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    // Computing bound for e
    bool _167 = false;
    bool _168 = !_167;
    int64_t _169;
    if (!_168)
    goto _jump1255;
    int64_t _170 = 581;
    int64_t _171 = -_170;
    _169 = _171;
    goto _jump1256;
    _jump1255:;
    int64_t _172 = 185;
    _169 = _172;
    _jump1256:;
    if (_169 > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    _158 = 0;
    int64_t _173 = 0; // e
    int64_t _174 = 0; // d
    int64_t _175 = 0; // c
    _jump1258:; // Begin body of loop
    int64_t _176 = _174 / _173;
    int64_t _177 = -_176;
    _158 += _177;
    _173++;
    if (_173 < _169)
    goto _jump1258;
    _173 = 0;
    _174++;
    if (_174 < _166)
    goto _jump1258;
    _174 = 0;
    _175++;
    if (_175 < _162)
    goto _jump1258;
    // End body of loop
    if (_157 >= 0)
    goto _jump1259;
    fail_assertion("negative array index");
    _jump1259:;
    if (_157 < _127.d0)
    goto _jump1260;
    fail_assertion("index too large");
    _jump1260:;
    if (_158 >= 0)
    goto _jump1261;
    fail_assertion("negative array index");
    _jump1261:;
    if (_158 < _127.d1)
    goto _jump1262;
    fail_assertion("index too large");
    _jump1262:;
    int64_t _178 = 0;
    _178 *= _127.d0;
    _178 += _157;
    _178 *= _127.d1;
    _178 += _158;
    double _179 = _127.data[_178];
    double _180;
    // Computing bound for c
    int64_t _181 = 344;
    int64_t _182 = 143;
    _a1_int64_t _183;
    _183.d0 = 2;
    _183.data = jpl_alloc(sizeof(int64_t) * 2);
    _183.data[0] = _181;
    _183.data[1] = _182;
    int64_t _184 = 412;
    int64_t _185 = -_184;
    if (_185 >= 0)
    goto _jump1263;
    fail_assertion("negative array index");
    _jump1263:;
    if (_185 < _183.d0)
    goto _jump1264;
    fail_assertion("index too large");
    _jump1264:;
    int64_t _186 = 0;
    _186 *= _183.d0;
    _186 += _185;
    int64_t _187 = _183.data[_186];
    int64_t _188 = -_187;
    if (_188 > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    // Computing bound for d
    int64_t _189 = 7;
    if (_189 > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    // Computing bound for e
    bool _190 = true;
    int64_t _191;
    if (!_190)
    goto _jump1267;
    int64_t _192 = 919;
    _191 = _192;
    goto _jump1268;
    _jump1267:;
    int64_t _193 = 270;
    int64_t _194 = -_193;
    _191 = _194;
    _jump1268:;
    if (_191 > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    _180 = 0;
    int64_t _195 = 0; // e
    int64_t _196 = 0; // d
    int64_t _197 = 0; // c
    _jump1270:; // Begin body of loop
    bool _198 = true;
    bool _199;
    if (!_198)
    goto _jump1271;
    bool _200 = true;
    _199 = _200;
    goto _jump1272;
    _jump1271:;
    bool _201 = true;
    _199 = _201;
    _jump1272:;
    double _202;
    if (!_199)
    goto _jump1273;
    double _203 = 33.0;
    _202 = _203;
    goto _jump1274;
    _jump1273:;
    double _204 = 92.0;
    _202 = _204;
    _jump1274:;
    double _205 = -_202;
    _180 += _205;
    _195++;
    if (_195 < _191)
    goto _jump1270;
    _195 = 0;
    _196++;
    if (_196 < _189)
    goto _jump1270;
    _196 = 0;
    _197++;
    if (_197 < _188)
    goto _jump1270;
    // End body of loop
    rgba _206 = { _119, _126, _179, _180 };
    double _207 = a(_206);
    double _208 = _118 * _207;
    show("(FloatType)", &_208);
    print("c");
    _a2_rgba _209;
    // Computing bound for c
    bool _210 = false;
    bool _211;
    if (!_210)
    goto _jump1275;
    int64_t _213 = 161;
    int64_t _214 = 695;
    bool _215 = _213 < _214;
    bool _212 = _215;
    if (0 == _215)
    goto _jump1276;
    bool _216 = false;
    _212 = _216;
    _jump1276:;
    _211 = _212;
    goto _jump1277;
    _jump1275:;
    bool _218 = true;
    bool _219 = !_218;
    bool _217 = _219;
    if (0 != _219)
    goto _jump1278;
    bool _220 = true;
    bool _221;
    if (!_220)
    goto _jump1279;
    bool _222 = false;
    _221 = _222;
    goto _jump1280;
    _jump1279:;
    bool _223 = true;
    _221 = _223;
    _jump1280:;
    _217 = _221;
    _jump1278:;
    _211 = _217;
    _jump1277:;
    _a3__a2_int64_t _224;
    if (!_211)
    goto _jump1281;
    _a3__a2_int64_t _225;
    // Computing bound for c
    int64_t _226 = 393;
    _225.d0 = _226;
    if (_226 > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing bound for d
    int64_t _227 = 749;
    int64_t _228 = -_227;
    _225.d1 = _228;
    if (_228 > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for e
    int64_t _229 = 989;
    _225.d2 = _229;
    if (_229 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= _226;
    _230 *= _228;
    _230 *= _229;
    _230 *= sizeof(_a2_int64_t);
    _225.data = jpl_alloc(_230);
    int64_t _231 = 0; // e
    int64_t _232 = 0; // d
    int64_t _233 = 0; // c
    _jump1285:; // Begin body of loop
    _a2_int64_t _234;
    // Computing bound for f
    _234.d0 = _232;
    if (_232 > 0) 
    goto _jump1286;
    fail_assertion("non-positive loop bound");
    _jump1286:;
    // Computing bound for g
    _234.d1 = _232;
    if (_232 > 0) 
    goto _jump1287;
    fail_assertion("non-positive loop bound");
    _jump1287:;
    // Computing total size of heap memory to allocate
    int64_t _235 = 1;
    _235 *= _232;
    _235 *= _232;
    _235 *= sizeof(int64_t);
    _234.data = jpl_alloc(_235);
    int64_t _236 = 0; // g
    int64_t _237 = 0; // f
    _jump1288:; // Begin body of loop
    int64_t _238 = 0;
    _238 *= _234.d0;
    _238 += _237;
    _238 *= _234.d1;
    _238 += _236;
    _234.data[_238] = _237;
    _236++;
    if (_236 < _232)
    goto _jump1288;
    _236 = 0;
    _237++;
    if (_237 < _232)
    goto _jump1288;
    // End body of loop
    int64_t _239 = 0;
    _239 *= _225.d0;
    _239 += _233;
    _239 *= _225.d1;
    _239 += _232;
    _239 *= _225.d2;
    _239 += _231;
    _225.data[_239] = _234;
    _231++;
    if (_231 < _229)
    goto _jump1285;
    _231 = 0;
    _232++;
    if (_232 < _228)
    goto _jump1285;
    _232 = 0;
    _233++;
    if (_233 < _226)
    goto _jump1285;
    // End body of loop
    _224 = _225;
    goto _jump1289;
    _jump1281:;
    _a3__a2_int64_t _240;
    // Computing bound for c
    int64_t _241 = 536;
    int64_t _242 = -_241;
    int64_t _243 = 951;
    int64_t _244 = -_243;
    int64_t _245 = _242 + _244;
    _240.d0 = _245;
    if (_245 > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing bound for d
    int64_t _246 = 186;
    int64_t _247 = 736;
    int64_t _248 = _246 - _247;
    _240.d1 = _248;
    if (_248 > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    // Computing bound for e
    int64_t _249 = 333;
    _240.d2 = _249;
    if (_249 > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= _245;
    _250 *= _248;
    _250 *= _249;
    _250 *= sizeof(_a2_int64_t);
    _240.data = jpl_alloc(_250);
    int64_t _251 = 0; // e
    int64_t _252 = 0; // d
    int64_t _253 = 0; // c
    _jump1293:; // Begin body of loop
    _a2_int64_t _254;
    // Computing bound for f
    int64_t _255;
    // Computing bound for f
    if (_252 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    _255 = 0;
    int64_t _256 = 0; // f
    _jump1295:; // Begin body of loop
    int64_t _257 = 406;
    _255 += _257;
    _256++;
    if (_256 < _252)
    goto _jump1295;
    // End body of loop
    _254.d0 = _255;
    if (_255 > 0) 
    goto _jump1296;
    fail_assertion("non-positive loop bound");
    _jump1296:;
    // Computing bound for g
    _254.d1 = _251;
    if (_251 > 0) 
    goto _jump1297;
    fail_assertion("non-positive loop bound");
    _jump1297:;
    // Computing total size of heap memory to allocate
    int64_t _258 = 1;
    _258 *= _255;
    _258 *= _251;
    _258 *= sizeof(int64_t);
    _254.data = jpl_alloc(_258);
    int64_t _259 = 0; // g
    int64_t _260 = 0; // f
    _jump1298:; // Begin body of loop
    int64_t _261 = 0;
    _261 *= _254.d0;
    _261 += _260;
    _261 *= _254.d1;
    _261 += _259;
    _254.data[_261] = _259;
    _259++;
    if (_259 < _251)
    goto _jump1298;
    _259 = 0;
    _260++;
    if (_260 < _255)
    goto _jump1298;
    // End body of loop
    int64_t _262 = 0;
    _262 *= _240.d0;
    _262 += _253;
    _262 *= _240.d1;
    _262 += _252;
    _262 *= _240.d2;
    _262 += _251;
    _240.data[_262] = _254;
    _251++;
    if (_251 < _249)
    goto _jump1293;
    _251 = 0;
    _252++;
    if (_252 < _248)
    goto _jump1293;
    _252 = 0;
    _253++;
    if (_253 < _245)
    goto _jump1293;
    // End body of loop
    _224 = _240;
    _jump1289:;
    bool _264 = false;
    bool _265 = !_264;
    bool _266 = !_265;
    bool _263 = _266;
    if (0 != _266)
    goto _jump1299;
    bool _267 = true;
    bool _268 = !_267;
    _263 = _268;
    _jump1299:;
    int64_t _269;
    if (!_263)
    goto _jump1300;
    int64_t _270 = 275;
    int64_t _271 = -_270;
    int64_t _272 = 4;
    int64_t _273 = -_272;
    int64_t _274 = 198;
    _a1_int64_t _275;
    _275.d0 = 3;
    _275.data = jpl_alloc(sizeof(int64_t) * 3);
    _275.data[0] = _271;
    _275.data[1] = _273;
    _275.data[2] = _274;
    int64_t _276 = 783;
    int64_t _277 = -_276;
    if (_277 >= 0)
    goto _jump1301;
    fail_assertion("negative array index");
    _jump1301:;
    if (_277 < _275.d0)
    goto _jump1302;
    fail_assertion("index too large");
    _jump1302:;
    int64_t _278 = 0;
    _278 *= _275.d0;
    _278 += _277;
    int64_t _279 = _275.data[_278];
    _269 = _279;
    goto _jump1303;
    _jump1300:;
    int64_t _280 = 616;
    _269 = _280;
    _jump1303:;
    int64_t _281 = 743;
    int64_t _282;
    // Computing bound for c
    int64_t _283 = 146;
    if (_283 > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    // Computing bound for d
    int64_t _284 = 650;
    int64_t _285 = -_284;
    int64_t _286 = -_285;
    if (_286 > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    _282 = 0;
    int64_t _287 = 0; // d
    int64_t _288 = 0; // c
    _jump1306:; // Begin body of loop
    _282 += _288;
    _287++;
    if (_287 < _286)
    goto _jump1306;
    _287 = 0;
    _288++;
    if (_288 < _283)
    goto _jump1306;
    // End body of loop
    if (_269 >= 0)
    goto _jump1307;
    fail_assertion("negative array index");
    _jump1307:;
    if (_269 < _224.d0)
    goto _jump1308;
    fail_assertion("index too large");
    _jump1308:;
    if (_281 >= 0)
    goto _jump1309;
    fail_assertion("negative array index");
    _jump1309:;
    if (_281 < _224.d1)
    goto _jump1310;
    fail_assertion("index too large");
    _jump1310:;
    if (_282 >= 0)
    goto _jump1311;
    fail_assertion("negative array index");
    _jump1311:;
    if (_282 < _224.d2)
    goto _jump1312;
    fail_assertion("index too large");
    _jump1312:;
    int64_t _289 = 0;
    _289 *= _224.d0;
    _289 += _269;
    _289 *= _224.d1;
    _289 += _281;
    _289 *= _224.d2;
    _289 += _282;
    _a2_int64_t _290 = _224.data[_289];
    int64_t _291 = 952;
    int64_t _292 = -_291;
    _a1_int64_t _293;
    // Computing bound for c
    int64_t _294 = 231;
    int64_t _295 = -_294;
    _293.d0 = _295;
    if (_295 > 0) 
    goto _jump1313;
    fail_assertion("non-positive loop bound");
    _jump1313:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _295;
    _296 *= sizeof(int64_t);
    _293.data = jpl_alloc(_296);
    int64_t _297 = 0; // c
    _jump1314:; // Begin body of loop
    int64_t _298;
    // Computing bound for d
    int64_t _299 = 829;
    if (_299 > 0) 
    goto _jump1315;
    fail_assertion("non-positive loop bound");
    _jump1315:;
    // Computing bound for e
    int64_t _300 = -_297;
    if (_300 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    _298 = 0;
    int64_t _301 = 0; // e
    int64_t _302 = 0; // d
    _jump1317:; // Begin body of loop
    _298 += _297;
    _301++;
    if (_301 < _300)
    goto _jump1317;
    _301 = 0;
    _302++;
    if (_302 < _299)
    goto _jump1317;
    // End body of loop
    int64_t _303 = 0;
    _303 *= _293.d0;
    _303 += _297;
    _293.data[_303] = _298;
    _297++;
    if (_297 < _295)
    goto _jump1314;
    // End body of loop
    int64_t _304 = 679;
    if (_304 >= 0)
    goto _jump1318;
    fail_assertion("negative array index");
    _jump1318:;
    if (_304 < _293.d0)
    goto _jump1319;
    fail_assertion("index too large");
    _jump1319:;
    int64_t _305 = 0;
    _305 *= _293.d0;
    _305 += _304;
    int64_t _306 = _293.data[_305];
    int64_t _307 = 469;
    int64_t _308 = 250;
    int64_t _309 = _307 / _308;
    int64_t _310;
    // Computing bound for c
    bool _311 = false;
    int64_t _312;
    if (!_311)
    goto _jump1320;
    int64_t _313 = 988;
    _312 = _313;
    goto _jump1321;
    _jump1320:;
    int64_t _314 = 901;
    _312 = _314;
    _jump1321:;
    if (_312 > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    _310 = 0;
    int64_t _315 = 0; // c
    _jump1323:; // Begin body of loop
    int64_t _316 = 203;
    int64_t _317 = -_316;
    _310 += _317;
    _315++;
    if (_315 < _312)
    goto _jump1323;
    // End body of loop
    int64_t _318 = _309 + _310;
    int64_t _319 = _306 - _318;
    if (_292 >= 0)
    goto _jump1324;
    fail_assertion("negative array index");
    _jump1324:;
    if (_292 < _290.d0)
    goto _jump1325;
    fail_assertion("index too large");
    _jump1325:;
    if (_319 >= 0)
    goto _jump1326;
    fail_assertion("negative array index");
    _jump1326:;
    if (_319 < _290.d1)
    goto _jump1327;
    fail_assertion("index too large");
    _jump1327:;
    int64_t _320 = 0;
    _320 *= _290.d0;
    _320 += _292;
    _320 *= _290.d1;
    _320 += _319;
    int64_t _321 = _290.data[_320];
    _209.d0 = _321;
    if (_321 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    // Computing bound for d
    int64_t _323 = 3;
    int64_t _324 = 967;
    bool _325 = _323 <= _324;
    bool _322 = _325;
    if (0 != _325)
    goto _jump1329;
    bool _326 = true;
    _322 = _326;
    _jump1329:;
    _a1_int64_t _327;
    if (!_322)
    goto _jump1330;
    _a1_int64_t _328;
    // Computing bound for c
    int64_t _329 = 629;
    int64_t _330 = -_329;
    _328.d0 = _330;
    if (_330 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= _330;
    _331 *= sizeof(int64_t);
    _328.data = jpl_alloc(_331);
    int64_t _332 = 0; // c
    _jump1332:; // Begin body of loop
    int64_t _333 = 470;
    int64_t _334 = 66;
    int64_t _335 = _333 / _334;
    int64_t _336 = 0;
    _336 *= _328.d0;
    _336 += _332;
    _328.data[_336] = _335;
    _332++;
    if (_332 < _330)
    goto _jump1332;
    // End body of loop
    _327 = _328;
    goto _jump1333;
    _jump1330:;
    _a1_int64_t _337;
    // Computing bound for c
    int64_t _338 = 855;
    _337.d0 = _338;
    if (_338 > 0) 
    goto _jump1334;
    fail_assertion("non-positive loop bound");
    _jump1334:;
    // Computing total size of heap memory to allocate
    int64_t _339 = 1;
    _339 *= _338;
    _339 *= sizeof(int64_t);
    _337.data = jpl_alloc(_339);
    int64_t _340 = 0; // c
    _jump1335:; // Begin body of loop
    int64_t _341 = 0;
    _341 *= _337.d0;
    _341 += _340;
    _337.data[_341] = _340;
    _340++;
    if (_340 < _338)
    goto _jump1335;
    // End body of loop
    _327 = _337;
    _jump1333:;
    int64_t _342 = 707;
    int64_t _343 = 627;
    int64_t _344 = _342 / _343;
    if (_344 >= 0)
    goto _jump1336;
    fail_assertion("negative array index");
    _jump1336:;
    if (_344 < _327.d0)
    goto _jump1337;
    fail_assertion("index too large");
    _jump1337:;
    int64_t _345 = 0;
    _345 *= _327.d0;
    _345 += _344;
    int64_t _346 = _327.data[_345];
    _a3_int64_t _347;
    // Computing bound for c
    int64_t _348 = 297;
    int64_t _349 = -_348;
    _347.d0 = _349;
    if (_349 > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing bound for d
    int64_t _350;
    // Computing bound for c
    int64_t _351 = 875;
    if (_351 > 0) 
    goto _jump1339;
    fail_assertion("non-positive loop bound");
    _jump1339:;
    // Computing bound for d
    int64_t _352 = 649;
    int64_t _353 = 422;
    int64_t _354 = _352 - _353;
    if (_354 > 0) 
    goto _jump1340;
    fail_assertion("non-positive loop bound");
    _jump1340:;
    _350 = 0;
    int64_t _355 = 0; // d
    int64_t _356 = 0; // c
    _jump1341:; // Begin body of loop
    int64_t _357;
    // Computing bound for e
    if (_355 > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    _357 = 0;
    int64_t _358 = 0; // e
    _jump1343:; // Begin body of loop
    _357 += _355;
    _358++;
    if (_358 < _355)
    goto _jump1343;
    // End body of loop
    _350 += _357;
    _355++;
    if (_355 < _354)
    goto _jump1341;
    _355 = 0;
    _356++;
    if (_356 < _351)
    goto _jump1341;
    // End body of loop
    _347.d1 = _350;
    if (_350 > 0) 
    goto _jump1344;
    fail_assertion("non-positive loop bound");
    _jump1344:;
    // Computing bound for e
    int64_t _359 = 34;
    int64_t _360 = 646;
    int64_t _361 = 451;
    int64_t _362 = _360 / _361;
    int64_t _363 = _359 * _362;
    _347.d2 = _363;
    if (_363 > 0) 
    goto _jump1345;
    fail_assertion("non-positive loop bound");
    _jump1345:;
    // Computing total size of heap memory to allocate
    int64_t _364 = 1;
    _364 *= _349;
    _364 *= _350;
    _364 *= _363;
    _364 *= sizeof(int64_t);
    _347.data = jpl_alloc(_364);
    int64_t _365 = 0; // e
    int64_t _366 = 0; // d
    int64_t _367 = 0; // c
    _jump1346:; // Begin body of loop
    int64_t _368 = 0;
    _368 *= _347.d0;
    _368 += _367;
    _368 *= _347.d1;
    _368 += _366;
    _368 *= _347.d2;
    _368 += _365;
    _347.data[_368] = _367;
    _365++;
    if (_365 < _363)
    goto _jump1346;
    _365 = 0;
    _366++;
    if (_366 < _350)
    goto _jump1346;
    _366 = 0;
    _367++;
    if (_367 < _349)
    goto _jump1346;
    // End body of loop
    int64_t _369 = 6;
    bool _371 = true;
    bool _370 = _371;
    if (0 != _371)
    goto _jump1347;
    bool _372 = true;
    _370 = _372;
    _jump1347:;
    int64_t _373;
    if (!_370)
    goto _jump1348;
    int64_t _374 = 917;
    int64_t _375 = 263;
    int64_t _376 = _374 % _375;
    _373 = _376;
    goto _jump1349;
    _jump1348:;
    int64_t _377 = 966;
    _373 = _377;
    _jump1349:;
    int64_t _378 = 531;
    int64_t _379 = -_378;
    int64_t _380 = -_379;
    if (_369 >= 0)
    goto _jump1350;
    fail_assertion("negative array index");
    _jump1350:;
    if (_369 < _347.d0)
    goto _jump1351;
    fail_assertion("index too large");
    _jump1351:;
    if (_373 >= 0)
    goto _jump1352;
    fail_assertion("negative array index");
    _jump1352:;
    if (_373 < _347.d1)
    goto _jump1353;
    fail_assertion("index too large");
    _jump1353:;
    if (_380 >= 0)
    goto _jump1354;
    fail_assertion("negative array index");
    _jump1354:;
    if (_380 < _347.d2)
    goto _jump1355;
    fail_assertion("index too large");
    _jump1355:;
    int64_t _381 = 0;
    _381 *= _347.d0;
    _381 += _369;
    _381 *= _347.d1;
    _381 += _373;
    _381 *= _347.d2;
    _381 += _380;
    int64_t _382 = _347.data[_381];
    int64_t _383 = _346 / _382;
    int64_t _384 = -_383;
    _209.d1 = _384;
    if (_384 > 0) 
    goto _jump1356;
    fail_assertion("non-positive loop bound");
    _jump1356:;
    // Computing total size of heap memory to allocate
    int64_t _385 = 1;
    _385 *= _321;
    _385 *= _384;
    _385 *= sizeof(rgba);
    _209.data = jpl_alloc(_385);
    int64_t _386 = 0; // d
    int64_t _387 = 0; // c
    _jump1357:; // Begin body of loop
    _a1_rgba _388;
    // Computing bound for e
    _388.d0 = _386;
    if (_386 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _386;
    _389 *= sizeof(rgba);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // e
    _jump1359:; // Begin body of loop
    bool _391 = _386 <= _390;
    double _392;
    if (!_391)
    goto _jump1360;
    double _393 = 6.0;
    _392 = _393;
    goto _jump1361;
    _jump1360:;
    double _394 = 56.0;
    double _395 = -_394;
    _392 = _395;
    _jump1361:;
    double _396 = 49.0;
    double _397 = -_396;
    double _398 = 99.0;
    double _399 = 78.0;
    rgba _400 = { _392, _397, _398, _399 };
    int64_t _401 = 0;
    _401 *= _388.d0;
    _401 += _390;
    _388.data[_401] = _400;
    _390++;
    if (_390 < _386)
    goto _jump1359;
    // End body of loop
    int64_t _402 = 662;
    if (_402 >= 0)
    goto _jump1362;
    fail_assertion("negative array index");
    _jump1362:;
    if (_402 < _388.d0)
    goto _jump1363;
    fail_assertion("index too large");
    _jump1363:;
    int64_t _403 = 0;
    _403 *= _388.d0;
    _403 += _402;
    rgba _404 = _388.data[_403];
    int64_t _405 = 0;
    _405 *= _209.d0;
    _405 += _387;
    _405 *= _209.d1;
    _405 += _386;
    _209.data[_405] = _404;
    _386++;
    if (_386 < _384)
    goto _jump1357;
    _386 = 0;
    _387++;
    if (_387 < _321)
    goto _jump1357;
    // End body of loop
    write_image(_209, "c.png");
    bool _406 = true;
    bool _407 = false;
    bool _408 = _406 != _407;
    double _409;
    if (!_408)
    goto _jump1970;
    double _410 = 26.0;
    double _411 = -_410;
    double _412 = 10.0;
    double _413 = _411 * _412;
    _409 = _413;
    goto _jump1971;
    _jump1970:;
    double _414 = 45.0;
    double _415 = -_414;
    _409 = _415;
    _jump1971:;
    _a3_bool _416;
    // Computing bound for d
    int64_t _417 = 596;
    _416.d0 = _417;
    if (_417 > 0) 
    goto _jump1972;
    fail_assertion("non-positive loop bound");
    _jump1972:;
    // Computing bound for e
    int64_t _418 = 116;
    _416.d1 = _418;
    if (_418 > 0) 
    goto _jump1973;
    fail_assertion("non-positive loop bound");
    _jump1973:;
    // Computing bound for f
    int64_t _419 = 255;
    int64_t _420 = -_419;
    _416.d2 = _420;
    if (_420 > 0) 
    goto _jump1974;
    fail_assertion("non-positive loop bound");
    _jump1974:;
    // Computing total size of heap memory to allocate
    int64_t _421 = 1;
    _421 *= _417;
    _421 *= _418;
    _421 *= _420;
    _421 *= sizeof(bool);
    _416.data = jpl_alloc(_421);
    int64_t _422 = 0; // f
    int64_t _423 = 0; // e
    int64_t _424 = 0; // d
    _jump1975:; // Begin body of loop
    bool _425 = false;
    int64_t _426 = 0;
    _426 *= _416.d0;
    _426 += _424;
    _426 *= _416.d1;
    _426 += _423;
    _426 *= _416.d2;
    _426 += _422;
    _416.data[_426] = _425;
    _422++;
    if (_422 < _420)
    goto _jump1975;
    _422 = 0;
    _423++;
    if (_423 < _418)
    goto _jump1975;
    _423 = 0;
    _424++;
    if (_424 < _417)
    goto _jump1975;
    // End body of loop
    int64_t _427 = 185;
    int64_t _428 = -_427;
    bool _429 = true;
    int64_t _430;
    if (!_429)
    goto _jump1976;
    int64_t _431 = 904;
    _430 = _431;
    goto _jump1977;
    _jump1976:;
    int64_t _432 = 353;
    _430 = _432;
    _jump1977:;
    int64_t _433 = 860;
    if (_428 >= 0)
    goto _jump1978;
    fail_assertion("negative array index");
    _jump1978:;
    if (_428 < _416.d0)
    goto _jump1979;
    fail_assertion("index too large");
    _jump1979:;
    if (_430 >= 0)
    goto _jump1980;
    fail_assertion("negative array index");
    _jump1980:;
    if (_430 < _416.d1)
    goto _jump1981;
    fail_assertion("index too large");
    _jump1981:;
    if (_433 >= 0)
    goto _jump1982;
    fail_assertion("negative array index");
    _jump1982:;
    if (_433 < _416.d2)
    goto _jump1983;
    fail_assertion("index too large");
    _jump1983:;
    int64_t _434 = 0;
    _434 *= _416.d0;
    _434 += _428;
    _434 *= _416.d1;
    _434 += _430;
    _434 *= _416.d2;
    _434 += _433;
    bool _435 = _416.data[_434];
    double _436;
    if (!_435)
    goto _jump1984;
    double _437;
    // Computing bound for d
    int64_t _438;
    // Computing bound for d
    int64_t _439 = 853;
    int64_t _440 = -_439;
    if (_440 > 0) 
    goto _jump1985;
    fail_assertion("non-positive loop bound");
    _jump1985:;
    _438 = 0;
    int64_t _441 = 0; // d
    _jump1986:; // Begin body of loop
    int64_t _442 = 1;
    _438 += _442;
    _441++;
    if (_441 < _440)
    goto _jump1986;
    // End body of loop
    if (_438 > 0) 
    goto _jump1987;
    fail_assertion("non-positive loop bound");
    _jump1987:;
    // Computing bound for e
    int64_t _443 = 417;
    if (_443 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    _437 = 0;
    int64_t _444 = 0; // e
    int64_t _445 = 0; // d
    _jump1989:; // Begin body of loop
    bool _446 = false;
    bool _447 = false;
    bool _448 = _446 != _447;
    double _449;
    if (!_448)
    goto _jump1990;
    double _450 = 26.0;
    _449 = _450;
    goto _jump1991;
    _jump1990:;
    double _451 = 88.0;
    _449 = _451;
    _jump1991:;
    _437 += _449;
    _444++;
    if (_444 < _443)
    goto _jump1989;
    _444 = 0;
    _445++;
    if (_445 < _438)
    goto _jump1989;
    // End body of loop
    _436 = _437;
    goto _jump1992;
    _jump1984:;
    double _452;
    // Computing bound for d
    int64_t _453 = 78;
    int64_t _454 = -_453;
    int64_t _455 = -_454;
    if (_455 > 0) 
    goto _jump1993;
    fail_assertion("non-positive loop bound");
    _jump1993:;
    _452 = 0;
    int64_t _456 = 0; // d
    _jump1994:; // Begin body of loop
    double _457 = 65.0;
    _452 += _457;
    _456++;
    if (_456 < _455)
    goto _jump1994;
    // End body of loop
    _436 = _452;
    _jump1992:;
    double _458 = 48.0;
    double _459 = 14.0;
    double _460 = _458 - _459;
    double _461 = 19.0;
    double _462 = 15.0;
    double _463 = 12.0;
    double _464 = 28.0;
    rgba _465 = { _461, _462, _463, _464 };
    double _466 = _465.a;
    double _467 = 26.0;
    double _468;
    // Computing bound for d
    int64_t _469 = 0;
    if (_469 > 0) 
    goto _jump1995;
    fail_assertion("non-positive loop bound");
    _jump1995:;
    // Computing bound for e
    int64_t _470 = 55;
    if (_470 > 0) 
    goto _jump1996;
    fail_assertion("non-positive loop bound");
    _jump1996:;
    _468 = 0;
    int64_t _471 = 0; // e
    int64_t _472 = 0; // d
    _jump1997:; // Begin body of loop
    double _473 = 55.0;
    _468 += _473;
    _471++;
    if (_471 < _470)
    goto _jump1997;
    _471 = 0;
    _472++;
    if (_472 < _469)
    goto _jump1997;
    // End body of loop
    double _474 = -_468;
    bool _475 = true;
    double _476;
    if (!_475)
    goto _jump1998;
    double _477 = 77.0;
    _476 = _477;
    goto _jump1999;
    _jump1998:;
    double _478 = 61.0;
    _476 = _478;
    _jump1999:;
    rgba _479 = { _466, _467, _474, _476 };
    double _480 = a(_479);
    rgba _481 = { _409, _436, _460, _480 };
    double _482 = _481.a;
    double _483 = 75.0;
    double _484 = 54.0;
    double _485 = -_484;
    double _486 = _483 * _485;
    double _487 = _482 + _486;
    _a1__a2_rgba _488;
    // Computing bound for e
    int64_t _489 = 261;
    int64_t _490;
    // Computing bound for e
    int64_t _491 = 529;
    if (_491 > 0) 
    goto _jump2000;
    fail_assertion("non-positive loop bound");
    _jump2000:;
    _490 = 0;
    int64_t _492 = 0; // e
    _jump2001:; // Begin body of loop
    _490 += _492;
    _492++;
    if (_492 < _491)
    goto _jump2001;
    // End body of loop
    int64_t _493 = -_490;
    int64_t _494 = _489 / _493;
    int64_t _495 = -_494;
    int64_t _496;
    // Computing bound for e
    int64_t _497 = 378;
    int64_t _498 = -_497;
    if (_498 > 0) 
    goto _jump2002;
    fail_assertion("non-positive loop bound");
    _jump2002:;
    _496 = 0;
    int64_t _499 = 0; // e
    _jump2003:; // Begin body of loop
    _a2_int64_t _500;
    // Computing bound for f
    int64_t _501 = 500;
    _500.d0 = _501;
    if (_501 > 0) 
    goto _jump2004;
    fail_assertion("non-positive loop bound");
    _jump2004:;
    // Computing bound for g
    _500.d1 = _499;
    if (_499 > 0) 
    goto _jump2005;
    fail_assertion("non-positive loop bound");
    _jump2005:;
    // Computing total size of heap memory to allocate
    int64_t _502 = 1;
    _502 *= _501;
    _502 *= _499;
    _502 *= sizeof(int64_t);
    _500.data = jpl_alloc(_502);
    int64_t _503 = 0; // g
    int64_t _504 = 0; // f
    _jump2006:; // Begin body of loop
    int64_t _505 = 153;
    int64_t _506 = 0;
    _506 *= _500.d0;
    _506 += _504;
    _506 *= _500.d1;
    _506 += _503;
    _500.data[_506] = _505;
    _503++;
    if (_503 < _499)
    goto _jump2006;
    _503 = 0;
    _504++;
    if (_504 < _501)
    goto _jump2006;
    // End body of loop
    int64_t _507 = 668;
    int64_t _508 = 200;
    if (_507 >= 0)
    goto _jump2007;
    fail_assertion("negative array index");
    _jump2007:;
    if (_507 < _500.d0)
    goto _jump2008;
    fail_assertion("index too large");
    _jump2008:;
    if (_508 >= 0)
    goto _jump2009;
    fail_assertion("negative array index");
    _jump2009:;
    if (_508 < _500.d1)
    goto _jump2010;
    fail_assertion("index too large");
    _jump2010:;
    int64_t _509 = 0;
    _509 *= _500.d0;
    _509 += _507;
    _509 *= _500.d1;
    _509 += _508;
    int64_t _510 = _500.data[_509];
    _496 += _510;
    _499++;
    if (_499 < _498)
    goto _jump2003;
    // End body of loop
    int64_t _511 = -_496;
    int64_t _512 = _495 - _511;
    _488.d0 = _512;
    if (_512 > 0) 
    goto _jump2011;
    fail_assertion("non-positive loop bound");
    _jump2011:;
    // Computing total size of heap memory to allocate
    int64_t _513 = 1;
    _513 *= _512;
    _513 *= sizeof(_a2_rgba);
    _488.data = jpl_alloc(_513);
    int64_t _514 = 0; // e
    _jump2012:; // Begin body of loop
    _a2_rgba _515;
    // Computing bound for f
    int64_t _516;
    // Computing bound for f
    if (_514 > 0) 
    goto _jump2013;
    fail_assertion("non-positive loop bound");
    _jump2013:;
    // Computing bound for g
    int64_t _517;
    // Computing bound for f
    if (_514 > 0) 
    goto _jump2014;
    fail_assertion("non-positive loop bound");
    _jump2014:;
    _517 = 0;
    int64_t _518 = 0; // f
    _jump2015:; // Begin body of loop
    int64_t _519 = _514 - _514;
    _517 += _519;
    _518++;
    if (_518 < _514)
    goto _jump2015;
    // End body of loop
    int64_t _520 = 359;
    int64_t _521 = _517 / _520;
    if (_521 > 0) 
    goto _jump2016;
    fail_assertion("non-positive loop bound");
    _jump2016:;
    // Computing bound for h
    if (_514 > 0) 
    goto _jump2017;
    fail_assertion("non-positive loop bound");
    _jump2017:;
    _516 = 0;
    int64_t _522 = 0; // h
    int64_t _523 = 0; // g
    int64_t _524 = 0; // f
    _jump2018:; // Begin body of loop
    _516 += _523;
    _522++;
    if (_522 < _514)
    goto _jump2018;
    _522 = 0;
    _523++;
    if (_523 < _521)
    goto _jump2018;
    _523 = 0;
    _524++;
    if (_524 < _514)
    goto _jump2018;
    // End body of loop
    _515.d0 = _516;
    if (_516 > 0) 
    goto _jump2019;
    fail_assertion("non-positive loop bound");
    _jump2019:;
    // Computing bound for g
    _515.d1 = _514;
    if (_514 > 0) 
    goto _jump2020;
    fail_assertion("non-positive loop bound");
    _jump2020:;
    // Computing total size of heap memory to allocate
    int64_t _525 = 1;
    _525 *= _516;
    _525 *= _514;
    _525 *= sizeof(rgba);
    _515.data = jpl_alloc(_525);
    int64_t _526 = 0; // g
    int64_t _527 = 0; // f
    _jump2021:; // Begin body of loop
    double _528 = -_487;
    double _529 = -_487;
    double _530 = 18.0;
    double _531 = -_530;
    double _532 = fmod(_529, _531);
    double _533 = _528 / _532;
    double _534;
    // Computing bound for h
    int64_t _535 = -_526;
    if (_535 > 0) 
    goto _jump2022;
    fail_assertion("non-positive loop bound");
    _jump2022:;
    // Computing bound for i
    int64_t _536;
    // Computing bound for h
    if (_527 > 0) 
    goto _jump2023;
    fail_assertion("non-positive loop bound");
    _jump2023:;
    // Computing bound for i
    if (_514 > 0) 
    goto _jump2024;
    fail_assertion("non-positive loop bound");
    _jump2024:;
    _536 = 0;
    int64_t _537 = 0; // i
    int64_t _538 = 0; // h
    _jump2025:; // Begin body of loop
    _536 += _537;
    _537++;
    if (_537 < _514)
    goto _jump2025;
    _537 = 0;
    _538++;
    if (_538 < _527)
    goto _jump2025;
    // End body of loop
    int64_t _539 = -_536;
    if (_539 > 0) 
    goto _jump2026;
    fail_assertion("non-positive loop bound");
    _jump2026:;
    _534 = 0;
    int64_t _540 = 0; // i
    int64_t _541 = 0; // h
    _jump2027:; // Begin body of loop
    bool _542 = false;
    bool _543 = !_542;
    double _544;
    if (!_543)
    goto _jump2028;
    double _545 = 49.0;
    _544 = _545;
    goto _jump2029;
    _jump2028:;
    double _546 = -_487;
    _544 = _546;
    _jump2029:;
    _534 += _544;
    _540++;
    if (_540 < _539)
    goto _jump2027;
    _540 = 0;
    _541++;
    if (_541 < _535)
    goto _jump2027;
    // End body of loop
    rgba _547 = { _487, _533, _487, _534 };
    int64_t _548 = 0;
    _548 *= _515.d0;
    _548 += _527;
    _548 *= _515.d1;
    _548 += _526;
    _515.data[_548] = _547;
    _526++;
    if (_526 < _514)
    goto _jump2021;
    _526 = 0;
    _527++;
    if (_527 < _516)
    goto _jump2021;
    // End body of loop
    int64_t _549 = 0;
    _549 *= _488.d0;
    _549 += _514;
    _488.data[_549] = _515;
    _514++;
    if (_514 < _512)
    goto _jump2012;
    // End body of loop
    _a2__a2_int64_t _550;
    // Computing bound for e
    int64_t _551;
    // Computing bound for e
    int64_t _552 = 285;
    if (_552 > 0) 
    goto _jump2030;
    fail_assertion("non-positive loop bound");
    _jump2030:;
    _551 = 0;
    int64_t _553 = 0; // e
    _jump2031:; // Begin body of loop
    int64_t _554 = _553 * _553;
    _551 += _554;
    _553++;
    if (_553 < _552)
    goto _jump2031;
    // End body of loop
    _550.d0 = _551;
    if (_551 > 0) 
    goto _jump2032;
    fail_assertion("non-positive loop bound");
    _jump2032:;
    // Computing bound for f
    int64_t _555;
    // Computing bound for e
    int64_t _556 = 751;
    if (_556 > 0) 
    goto _jump2033;
    fail_assertion("non-positive loop bound");
    _jump2033:;
    // Computing bound for f
    int64_t _557 = 390;
    int64_t _558 = -_557;
    if (_558 > 0) 
    goto _jump2034;
    fail_assertion("non-positive loop bound");
    _jump2034:;
    _555 = 0;
    int64_t _559 = 0; // f
    int64_t _560 = 0; // e
    _jump2035:; // Begin body of loop
    _a1_int64_t _561;
    _561.d0 = 2;
    _561.data = jpl_alloc(sizeof(int64_t) * 2);
    _561.data[0] = _560;
    _561.data[1] = _560;
    int64_t _562 = 971;
    if (_562 >= 0)
    goto _jump2036;
    fail_assertion("negative array index");
    _jump2036:;
    if (_562 < _561.d0)
    goto _jump2037;
    fail_assertion("index too large");
    _jump2037:;
    int64_t _563 = 0;
    _563 *= _561.d0;
    _563 += _562;
    int64_t _564 = _561.data[_563];
    _555 += _564;
    _559++;
    if (_559 < _558)
    goto _jump2035;
    _559 = 0;
    _560++;
    if (_560 < _556)
    goto _jump2035;
    // End body of loop
    _550.d1 = _555;
    if (_555 > 0) 
    goto _jump2038;
    fail_assertion("non-positive loop bound");
    _jump2038:;
    // Computing total size of heap memory to allocate
    int64_t _565 = 1;
    _565 *= _551;
    _565 *= _555;
    _565 *= sizeof(_a2_int64_t);
    _550.data = jpl_alloc(_565);
    int64_t _566 = 0; // f
    int64_t _567 = 0; // e
    _jump2039:; // Begin body of loop
    _a2_int64_t _568;
    // Computing bound for g
    int64_t _569 = -_566;
    _568.d0 = _569;
    if (_569 > 0) 
    goto _jump2040;
    fail_assertion("non-positive loop bound");
    _jump2040:;
    // Computing bound for h
    int64_t _570 = -_567;
    _568.d1 = _570;
    if (_570 > 0) 
    goto _jump2041;
    fail_assertion("non-positive loop bound");
    _jump2041:;
    // Computing total size of heap memory to allocate
    int64_t _571 = 1;
    _571 *= _569;
    _571 *= _570;
    _571 *= sizeof(int64_t);
    _568.data = jpl_alloc(_571);
    int64_t _572 = 0; // h
    int64_t _573 = 0; // g
    _jump2042:; // Begin body of loop
    int64_t _574;
    // Computing bound for i
    int64_t _575;
    // Computing bound for i
    if (_573 > 0) 
    goto _jump2043;
    fail_assertion("non-positive loop bound");
    _jump2043:;
    // Computing bound for j
    if (_567 > 0) 
    goto _jump2044;
    fail_assertion("non-positive loop bound");
    _jump2044:;
    // Computing bound for k
    if (_573 > 0) 
    goto _jump2045;
    fail_assertion("non-positive loop bound");
    _jump2045:;
    _575 = 0;
    int64_t _576 = 0; // k
    int64_t _577 = 0; // j
    int64_t _578 = 0; // i
    _jump2046:; // Begin body of loop
    _575 += _577;
    _576++;
    if (_576 < _573)
    goto _jump2046;
    _576 = 0;
    _577++;
    if (_577 < _567)
    goto _jump2046;
    _577 = 0;
    _578++;
    if (_578 < _573)
    goto _jump2046;
    // End body of loop
    if (_575 > 0) 
    goto _jump2047;
    fail_assertion("non-positive loop bound");
    _jump2047:;
    // Computing bound for j
    int64_t _579 = 46;
    int64_t _580 = _579 * _573;
    if (_580 > 0) 
    goto _jump2048;
    fail_assertion("non-positive loop bound");
    _jump2048:;
    // Computing bound for k
    int64_t _581 = 586;
    if (_581 > 0) 
    goto _jump2049;
    fail_assertion("non-positive loop bound");
    _jump2049:;
    _574 = 0;
    int64_t _582 = 0; // k
    int64_t _583 = 0; // j
    int64_t _584 = 0; // i
    _jump2050:; // Begin body of loop
    _574 += _566;
    _582++;
    if (_582 < _581)
    goto _jump2050;
    _582 = 0;
    _583++;
    if (_583 < _580)
    goto _jump2050;
    _583 = 0;
    _584++;
    if (_584 < _575)
    goto _jump2050;
    // End body of loop
    int64_t _585 = 0;
    _585 *= _568.d0;
    _585 += _573;
    _585 *= _568.d1;
    _585 += _572;
    _568.data[_585] = _574;
    _572++;
    if (_572 < _570)
    goto _jump2042;
    _572 = 0;
    _573++;
    if (_573 < _569)
    goto _jump2042;
    // End body of loop
    int64_t _586 = 0;
    _586 *= _550.d0;
    _586 += _567;
    _586 *= _550.d1;
    _586 += _566;
    _550.data[_586] = _568;
    _566++;
    if (_566 < _555)
    goto _jump2039;
    _566 = 0;
    _567++;
    if (_567 < _551)
    goto _jump2039;
    // End body of loop
    _a1_int64_t _587;
    // Computing bound for e
    bool _588 = true;
    int64_t _589;
    if (!_588)
    goto _jump2051;
    int64_t _590 = 484;
    _589 = _590;
    goto _jump2052;
    _jump2051:;
    int64_t _591 = 112;
    _589 = _591;
    _jump2052:;
    int64_t _592;
    // Computing bound for e
    int64_t _593 = 870;
    if (_593 > 0) 
    goto _jump2053;
    fail_assertion("non-positive loop bound");
    _jump2053:;
    // Computing bound for f
    int64_t _594 = 399;
    if (_594 > 0) 
    goto _jump2054;
    fail_assertion("non-positive loop bound");
    _jump2054:;
    _592 = 0;
    int64_t _595 = 0; // f
    int64_t _596 = 0; // e
    _jump2055:; // Begin body of loop
    _592 += _596;
    _595++;
    if (_595 < _594)
    goto _jump2055;
    _595 = 0;
    _596++;
    if (_596 < _593)
    goto _jump2055;
    // End body of loop
    int64_t _597 = _589 / _592;
    _587.d0 = _597;
    if (_597 > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing total size of heap memory to allocate
    int64_t _598 = 1;
    _598 *= _597;
    _598 *= sizeof(int64_t);
    _587.data = jpl_alloc(_598);
    int64_t _599 = 0; // e
    _jump2057:; // Begin body of loop
    int64_t _600 = 577;
    int64_t _601 = -_600;
    int64_t _602 = _601 + _599;
    int64_t _603 = 0;
    _603 *= _587.d0;
    _603 += _599;
    _587.data[_603] = _602;
    _599++;
    if (_599 < _597)
    goto _jump2057;
    // End body of loop
    int64_t _604;
    // Computing bound for e
    bool _605 = true;
    int64_t _606;
    if (!_605)
    goto _jump2058;
    int64_t _607 = 161;
    int64_t _608 = -_607;
    _606 = _608;
    goto _jump2059;
    _jump2058:;
    int64_t _609 = 669;
    _606 = _609;
    _jump2059:;
    if (_606 > 0) 
    goto _jump2060;
    fail_assertion("non-positive loop bound");
    _jump2060:;
    _604 = 0;
    int64_t _610 = 0; // e
    _jump2061:; // Begin body of loop
    _604 += _610;
    _610++;
    if (_610 < _606)
    goto _jump2061;
    // End body of loop
    if (_604 >= 0)
    goto _jump2062;
    fail_assertion("negative array index");
    _jump2062:;
    if (_604 < _587.d0)
    goto _jump2063;
    fail_assertion("index too large");
    _jump2063:;
    int64_t _611 = 0;
    _611 *= _587.d0;
    _611 += _604;
    int64_t _612 = _587.data[_611];
    bool _613 = false;
    bool _614 = !_613;
    bool _615;
    if (!_614)
    goto _jump2064;
    bool _616 = true;
    bool _617 = !_616;
    _615 = _617;
    goto _jump2065;
    _jump2064:;
    bool _618 = false;
    _615 = _618;
    _jump2065:;
    int64_t _619;
    if (!_615)
    goto _jump2066;
    int64_t _620 = 496;
    int64_t _621 = 168;
    int64_t _622 = _620 + _621;
    int64_t _623 = 166;
    int64_t _624 = _622 / _623;
    int64_t _625 = 334;
    int64_t _626 = -_625;
    int64_t _627 = _624 / _626;
    _619 = _627;
    goto _jump2067;
    _jump2066:;
    int64_t _628 = 454;
    int64_t _629 = 388;
    int64_t _630 = _628 / _629;
    int64_t _631 = 231;
    bool _632 = _630 < _631;
    int64_t _633;
    if (!_632)
    goto _jump2068;
    int64_t _634 = 934;
    int64_t _635 = 431;
    int64_t _636 = _634 / _635;
    int64_t _637 = -_636;
    _633 = _637;
    goto _jump2069;
    _jump2068:;
    int64_t _638 = 214;
    _633 = _638;
    _jump2069:;
    _619 = _633;
    _jump2067:;
    if (_612 >= 0)
    goto _jump2070;
    fail_assertion("negative array index");
    _jump2070:;
    if (_612 < _550.d0)
    goto _jump2071;
    fail_assertion("index too large");
    _jump2071:;
    if (_619 >= 0)
    goto _jump2072;
    fail_assertion("negative array index");
    _jump2072:;
    if (_619 < _550.d1)
    goto _jump2073;
    fail_assertion("index too large");
    _jump2073:;
    int64_t _639 = 0;
    _639 *= _550.d0;
    _639 += _612;
    _639 *= _550.d1;
    _639 += _619;
    _a2_int64_t _640 = _550.data[_639];
    bool _641 = false;
    int64_t _642;
    if (!_641)
    goto _jump2074;
    int64_t _643;
    // Computing bound for e
    _a2_int64_t _644;
    // Computing bound for e
    int64_t _645 = 878;
    int64_t _646 = 774;
    int64_t _647 = _645 % _646;
    _644.d0 = _647;
    if (_647 > 0) 
    goto _jump2075;
    fail_assertion("non-positive loop bound");
    _jump2075:;
    // Computing bound for f
    int64_t _648 = 760;
    _644.d1 = _648;
    if (_648 > 0) 
    goto _jump2076;
    fail_assertion("non-positive loop bound");
    _jump2076:;
    // Computing total size of heap memory to allocate
    int64_t _649 = 1;
    _649 *= _647;
    _649 *= _648;
    _649 *= sizeof(int64_t);
    _644.data = jpl_alloc(_649);
    int64_t _650 = 0; // f
    int64_t _651 = 0; // e
    _jump2077:; // Begin body of loop
    int64_t _652 = 185;
    int64_t _653 = _652 / _650;
    int64_t _654 = 0;
    _654 *= _644.d0;
    _654 += _651;
    _654 *= _644.d1;
    _654 += _650;
    _644.data[_654] = _653;
    _650++;
    if (_650 < _648)
    goto _jump2077;
    _650 = 0;
    _651++;
    if (_651 < _647)
    goto _jump2077;
    // End body of loop
    int64_t _655 = 384;
    int64_t _656 = 304;
    if (_655 >= 0)
    goto _jump2078;
    fail_assertion("negative array index");
    _jump2078:;
    if (_655 < _644.d0)
    goto _jump2079;
    fail_assertion("index too large");
    _jump2079:;
    if (_656 >= 0)
    goto _jump2080;
    fail_assertion("negative array index");
    _jump2080:;
    if (_656 < _644.d1)
    goto _jump2081;
    fail_assertion("index too large");
    _jump2081:;
    int64_t _657 = 0;
    _657 *= _644.d0;
    _657 += _655;
    _657 *= _644.d1;
    _657 += _656;
    int64_t _658 = _644.data[_657];
    if (_658 > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing bound for f
    int64_t _659 = 34;
    if (_659 > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing bound for g
    int64_t _660 = 900;
    int64_t _661 = -_660;
    if (_661 > 0) 
    goto _jump2084;
    fail_assertion("non-positive loop bound");
    _jump2084:;
    _643 = 0;
    int64_t _662 = 0; // g
    int64_t _663 = 0; // f
    int64_t _664 = 0; // e
    _jump2085:; // Begin body of loop
    bool _665 = _487 != _487;
    int64_t _666;
    if (!_665)
    goto _jump2086;
    int64_t _667 = -_664;
    int64_t _668 = _667 * _663;
    _666 = _668;
    goto _jump2087;
    _jump2086:;
    int64_t _669 = 757;
    int64_t _670;
    // Computing bound for h
    if (_663 > 0) 
    goto _jump2088;
    fail_assertion("non-positive loop bound");
    _jump2088:;
    // Computing bound for i
    if (_663 > 0) 
    goto _jump2089;
    fail_assertion("non-positive loop bound");
    _jump2089:;
    _670 = 0;
    int64_t _671 = 0; // i
    int64_t _672 = 0; // h
    _jump2090:; // Begin body of loop
    _670 += _671;
    _671++;
    if (_671 < _663)
    goto _jump2090;
    _671 = 0;
    _672++;
    if (_672 < _663)
    goto _jump2090;
    // End body of loop
    int64_t _673 = _669 - _670;
    _666 = _673;
    _jump2087:;
    _643 += _666;
    _662++;
    if (_662 < _661)
    goto _jump2085;
    _662 = 0;
    _663++;
    if (_663 < _659)
    goto _jump2085;
    _663 = 0;
    _664++;
    if (_664 < _658)
    goto _jump2085;
    // End body of loop
    _642 = _643;
    goto _jump2091;
    _jump2074:;
    _a1_int64_t _674;
    // Computing bound for e
    int64_t _675 = 332;
    int64_t _676 = -_675;
    _674.d0 = _676;
    if (_676 > 0) 
    goto _jump2092;
    fail_assertion("non-positive loop bound");
    _jump2092:;
    // Computing total size of heap memory to allocate
    int64_t _677 = 1;
    _677 *= _676;
    _677 *= sizeof(int64_t);
    _674.data = jpl_alloc(_677);
    int64_t _678 = 0; // e
    _jump2093:; // Begin body of loop
    int64_t _679 = 0;
    _679 *= _674.d0;
    _679 += _678;
    _674.data[_679] = _678;
    _678++;
    if (_678 < _676)
    goto _jump2093;
    // End body of loop
    bool _680 = false;
    int64_t _681;
    if (!_680)
    goto _jump2094;
    int64_t _682 = 671;
    _681 = _682;
    goto _jump2095;
    _jump2094:;
    int64_t _683 = 732;
    _681 = _683;
    _jump2095:;
    int64_t _684 = -_681;
    if (_684 >= 0)
    goto _jump2096;
    fail_assertion("negative array index");
    _jump2096:;
    if (_684 < _674.d0)
    goto _jump2097;
    fail_assertion("index too large");
    _jump2097:;
    int64_t _685 = 0;
    _685 *= _674.d0;
    _685 += _684;
    int64_t _686 = _674.data[_685];
    int64_t _687 = -_686;
    _642 = _687;
    _jump2091:;
    int64_t _688 = 821;
    if (_642 >= 0)
    goto _jump2098;
    fail_assertion("negative array index");
    _jump2098:;
    if (_642 < _640.d0)
    goto _jump2099;
    fail_assertion("index too large");
    _jump2099:;
    if (_688 >= 0)
    goto _jump2100;
    fail_assertion("negative array index");
    _jump2100:;
    if (_688 < _640.d1)
    goto _jump2101;
    fail_assertion("index too large");
    _jump2101:;
    int64_t _689 = 0;
    _689 *= _640.d0;
    _689 += _642;
    _689 *= _640.d1;
    _689 += _688;
    int64_t _690 = _640.data[_689];
    if (_690 >= 0)
    goto _jump2102;
    fail_assertion("negative array index");
    _jump2102:;
    if (_690 < _488.d0)
    goto _jump2103;
    fail_assertion("index too large");
    _jump2103:;
    int64_t _691 = 0;
    _691 *= _488.d0;
    _691 += _690;
    _a2_rgba _692 = _488.data[_691];
    print("h");
    double _693 = 3.0;
    _a1_bool _694;
    // Computing bound for j
    int64_t _695;
    // Computing bound for j
    _a2_int64_t _696;
    // Computing bound for j
    int64_t _697 = 916;
    int64_t _698 = _697 % _692.d1;
    _696.d0 = _698;
    if (_698 > 0) 
    goto _jump2387;
    fail_assertion("non-positive loop bound");
    _jump2387:;
    // Computing bound for k
    int64_t _699 = 594;
    _696.d1 = _699;
    if (_699 > 0) 
    goto _jump2388;
    fail_assertion("non-positive loop bound");
    _jump2388:;
    // Computing total size of heap memory to allocate
    int64_t _700 = 1;
    _700 *= _698;
    _700 *= _699;
    _700 *= sizeof(int64_t);
    _696.data = jpl_alloc(_700);
    int64_t _701 = 0; // k
    int64_t _702 = 0; // j
    _jump2389:; // Begin body of loop
    int64_t _703 = 0;
    _703 *= _696.d0;
    _703 += _702;
    _703 *= _696.d1;
    _703 += _701;
    _696.data[_703] = _692.d1;
    _701++;
    if (_701 < _699)
    goto _jump2389;
    _701 = 0;
    _702++;
    if (_702 < _698)
    goto _jump2389;
    // End body of loop
    int64_t _704 = 740;
    int64_t _705 = _692.d1 + _692.d1;
    if (_704 >= 0)
    goto _jump2390;
    fail_assertion("negative array index");
    _jump2390:;
    if (_704 < _696.d0)
    goto _jump2391;
    fail_assertion("index too large");
    _jump2391:;
    if (_705 >= 0)
    goto _jump2392;
    fail_assertion("negative array index");
    _jump2392:;
    if (_705 < _696.d1)
    goto _jump2393;
    fail_assertion("index too large");
    _jump2393:;
    int64_t _706 = 0;
    _706 *= _696.d0;
    _706 += _704;
    _706 *= _696.d1;
    _706 += _705;
    int64_t _707 = _696.data[_706];
    if (_707 > 0) 
    goto _jump2394;
    fail_assertion("non-positive loop bound");
    _jump2394:;
    // Computing bound for k
    int64_t _708 = _692.d1 * _692.d1;
    bool _709 = _692.d1 <= _708;
    int64_t _710;
    if (!_709)
    goto _jump2395;
    bool _711 = true;
    bool _712 = !_711;
    int64_t _713;
    if (!_712)
    goto _jump2396;
    _713 = _692.d1;
    goto _jump2397;
    _jump2396:;
    int64_t _714 = _692.d1 + _692.d1;
    _713 = _714;
    _jump2397:;
    _710 = _713;
    goto _jump2398;
    _jump2395:;
    int64_t _715;
    // Computing bound for j
    if (_692.d1 > 0) 
    goto _jump2399;
    fail_assertion("non-positive loop bound");
    _jump2399:;
    // Computing bound for k
    int64_t _716 = 820;
    if (_716 > 0) 
    goto _jump2400;
    fail_assertion("non-positive loop bound");
    _jump2400:;
    // Computing bound for l
    int64_t _717 = 894;
    if (_717 > 0) 
    goto _jump2401;
    fail_assertion("non-positive loop bound");
    _jump2401:;
    _715 = 0;
    int64_t _718 = 0; // l
    int64_t _719 = 0; // k
    int64_t _720 = 0; // j
    _jump2402:; // Begin body of loop
    _715 += _718;
    _718++;
    if (_718 < _717)
    goto _jump2402;
    _718 = 0;
    _719++;
    if (_719 < _716)
    goto _jump2402;
    _719 = 0;
    _720++;
    if (_720 < _692.d1)
    goto _jump2402;
    // End body of loop
    _710 = _715;
    _jump2398:;
    int64_t _721 = _692.d1 - _710;
    if (_721 > 0) 
    goto _jump2403;
    fail_assertion("non-positive loop bound");
    _jump2403:;
    _695 = 0;
    int64_t _722 = 0; // k
    int64_t _723 = 0; // j
    _jump2404:; // Begin body of loop
    int64_t _724;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump2405;
    fail_assertion("non-positive loop bound");
    _jump2405:;
    // Computing bound for m
    int64_t _725 = -_692.d1;
    int64_t _726 = -_725;
    if (_726 > 0) 
    goto _jump2406;
    fail_assertion("non-positive loop bound");
    _jump2406:;
    // Computing bound for n
    if (_722 > 0) 
    goto _jump2407;
    fail_assertion("non-positive loop bound");
    _jump2407:;
    _724 = 0;
    int64_t _727 = 0; // n
    int64_t _728 = 0; // m
    int64_t _729 = 0; // l
    _jump2408:; // Begin body of loop
    _724 += _722;
    _727++;
    if (_727 < _722)
    goto _jump2408;
    _727 = 0;
    _728++;
    if (_728 < _726)
    goto _jump2408;
    _728 = 0;
    _729++;
    if (_729 < _692.d0)
    goto _jump2408;
    // End body of loop
    int64_t _730 = _724 * _692.d0;
    _695 += _730;
    _722++;
    if (_722 < _721)
    goto _jump2404;
    _722 = 0;
    _723++;
    if (_723 < _707)
    goto _jump2404;
    // End body of loop
    _694.d0 = _695;
    if (_695 > 0) 
    goto _jump2409;
    fail_assertion("non-positive loop bound");
    _jump2409:;
    // Computing total size of heap memory to allocate
    int64_t _731 = 1;
    _731 *= _695;
    _731 *= sizeof(bool);
    _694.data = jpl_alloc(_731);
    int64_t _732 = 0; // j
    _jump2410:; // Begin body of loop
    int64_t _734 = 442;
    bool _735 = _734 < _692.d1;
    int64_t _736 = 457;
    bool _737 = _736 >= _732;
    bool _738 = _735 == _737;
    bool _733 = _738;
    if (0 == _738)
    goto _jump2411;
    double _739 = 15.0;
    bool _740 = _487 < _739;
    int64_t _741;
    if (!_740)
    goto _jump2412;
    int64_t _742 = 653;
    _741 = _742;
    goto _jump2413;
    _jump2412:;
    int64_t _743;
    // Computing bound for k
    if (_732 > 0) 
    goto _jump2414;
    fail_assertion("non-positive loop bound");
    _jump2414:;
    _743 = 0;
    int64_t _744 = 0; // k
    _jump2415:; // Begin body of loop
    _743 += _732;
    _744++;
    if (_744 < _732)
    goto _jump2415;
    // End body of loop
    _741 = _743;
    _jump2413:;
    int64_t _745 = 652;
    int64_t _746 = _741 - _745;
    bool _747 = _692.d0 <= _692.d1;
    bool _748;
    if (!_747)
    goto _jump2416;
    bool _749 = _693 != _487;
    _748 = _749;
    goto _jump2417;
    _jump2416:;
    bool _750 = false;
    _748 = _750;
    _jump2417:;
    int64_t _751;
    if (!_748)
    goto _jump2418;
    int64_t _752;
    // Computing bound for k
    int64_t _753 = _692.d0 - _732;
    if (_753 > 0) 
    goto _jump2419;
    fail_assertion("non-positive loop bound");
    _jump2419:;
    _752 = 0;
    int64_t _754 = 0; // k
    _jump2420:; // Begin body of loop
    int64_t _755 = 144;
    int64_t _756 = -_755;
    _752 += _756;
    _754++;
    if (_754 < _753)
    goto _jump2420;
    // End body of loop
    _751 = _752;
    goto _jump2421;
    _jump2418:;
    _751 = _692.d0;
    _jump2421:;
    bool _757 = _746 != _751;
    _733 = _757;
    _jump2411:;
    int64_t _758 = 0;
    _758 *= _694.d0;
    _758 += _732;
    _694.data[_758] = _733;
    _732++;
    if (_732 < _695)
    goto _jump2410;
    // End body of loop
    bool _760 = true;
    bool _759 = _760;
    if (0 == _760)
    goto _jump2422;
    bool _761 = false;
    _759 = _761;
    _jump2422:;
    bool _762 = !_759;
    bool _763 = !_762;
    bool _764 = !_763;
    int64_t _765;
    if (!_764)
    goto _jump2423;
    int64_t _766;
    // Computing bound for j
    bool _767 = false;
    _a1_int64_t _768;
    if (!_767)
    goto _jump2424;
    _a1_int64_t _769;
    // Computing bound for j
    int64_t _770 = 629;
    _769.d0 = _770;
    if (_770 > 0) 
    goto _jump2425;
    fail_assertion("non-positive loop bound");
    _jump2425:;
    // Computing total size of heap memory to allocate
    int64_t _771 = 1;
    _771 *= _770;
    _771 *= sizeof(int64_t);
    _769.data = jpl_alloc(_771);
    int64_t _772 = 0; // j
    _jump2426:; // Begin body of loop
    int64_t _773 = 0;
    _773 *= _769.d0;
    _773 += _772;
    _769.data[_773] = _772;
    _772++;
    if (_772 < _770)
    goto _jump2426;
    // End body of loop
    _768 = _769;
    goto _jump2427;
    _jump2424:;
    int64_t _774 = 289;
    _a1_int64_t _775;
    _775.d0 = 1;
    _775.data = jpl_alloc(sizeof(int64_t) * 1);
    _775.data[0] = _774;
    _768 = _775;
    _jump2427:;
    if (_692.d0 >= 0)
    goto _jump2428;
    fail_assertion("negative array index");
    _jump2428:;
    if (_692.d0 < _768.d0)
    goto _jump2429;
    fail_assertion("index too large");
    _jump2429:;
    int64_t _776 = 0;
    _776 *= _768.d0;
    _776 += _692.d0;
    int64_t _777 = _768.data[_776];
    if (_777 > 0) 
    goto _jump2430;
    fail_assertion("non-positive loop bound");
    _jump2430:;
    // Computing bound for k
    if (_692.d1 > 0) 
    goto _jump2431;
    fail_assertion("non-positive loop bound");
    _jump2431:;
    // Computing bound for l
    _a1_int64_t _778;
    // Computing bound for j
    int64_t _779;
    // Computing bound for j
    if (_692.d0 > 0) 
    goto _jump2432;
    fail_assertion("non-positive loop bound");
    _jump2432:;
    // Computing bound for k
    if (_692.d0 > 0) 
    goto _jump2433;
    fail_assertion("non-positive loop bound");
    _jump2433:;
    _779 = 0;
    int64_t _780 = 0; // k
    int64_t _781 = 0; // j
    _jump2434:; // Begin body of loop
    int64_t _782 = -_692.d1;
    _779 += _782;
    _780++;
    if (_780 < _692.d0)
    goto _jump2434;
    _780 = 0;
    _781++;
    if (_781 < _692.d0)
    goto _jump2434;
    // End body of loop
    _778.d0 = _779;
    if (_779 > 0) 
    goto _jump2435;
    fail_assertion("non-positive loop bound");
    _jump2435:;
    // Computing total size of heap memory to allocate
    int64_t _783 = 1;
    _783 *= _779;
    _783 *= sizeof(int64_t);
    _778.data = jpl_alloc(_783);
    int64_t _784 = 0; // j
    _jump2436:; // Begin body of loop
    int64_t _785 = 0;
    _785 *= _778.d0;
    _785 += _784;
    _778.data[_785] = _692.d1;
    _784++;
    if (_784 < _779)
    goto _jump2436;
    // End body of loop
    if (_692.d1 >= 0)
    goto _jump2437;
    fail_assertion("negative array index");
    _jump2437:;
    if (_692.d1 < _778.d0)
    goto _jump2438;
    fail_assertion("index too large");
    _jump2438:;
    int64_t _786 = 0;
    _786 *= _778.d0;
    _786 += _692.d1;
    int64_t _787 = _778.data[_786];
    if (_787 > 0) 
    goto _jump2439;
    fail_assertion("non-positive loop bound");
    _jump2439:;
    _766 = 0;
    int64_t _788 = 0; // l
    int64_t _789 = 0; // k
    int64_t _790 = 0; // j
    _jump2440:; // Begin body of loop
    int64_t _791;
    // Computing bound for m
    bool _792 = true;
    int64_t _793;
    if (!_792)
    goto _jump2441;
    int64_t _794 = _789 % _692.d1;
    _793 = _794;
    goto _jump2442;
    _jump2441:;
    _793 = _788;
    _jump2442:;
    if (_793 > 0) 
    goto _jump2443;
    fail_assertion("non-positive loop bound");
    _jump2443:;
    _791 = 0;
    int64_t _795 = 0; // m
    _jump2444:; // Begin body of loop
    _791 += _790;
    _795++;
    if (_795 < _793)
    goto _jump2444;
    // End body of loop
    _766 += _791;
    _788++;
    if (_788 < _787)
    goto _jump2440;
    _788 = 0;
    _789++;
    if (_789 < _692.d1)
    goto _jump2440;
    _789 = 0;
    _790++;
    if (_790 < _777)
    goto _jump2440;
    // End body of loop
    _765 = _766;
    goto _jump2445;
    _jump2423:;
    _765 = _692.d1;
    _jump2445:;
    if (_765 >= 0)
    goto _jump2446;
    fail_assertion("negative array index");
    _jump2446:;
    if (_765 < _694.d0)
    goto _jump2447;
    fail_assertion("index too large");
    _jump2447:;
    int64_t _796 = 0;
    _796 *= _694.d0;
    _796 += _765;
    bool _797 = _694.data[_796];
    if (0 != _797)
    goto _jump2448;
    fail_assertion("j");
    _jump2448:;
    _a2_bool _798;
    // Computing bound for k
    _798.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2735;
    fail_assertion("non-positive loop bound");
    _jump2735:;
    // Computing bound for l
    _798.d1 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2736;
    fail_assertion("non-positive loop bound");
    _jump2736:;
    // Computing total size of heap memory to allocate
    int64_t _799 = 1;
    _799 *= _692.d1;
    _799 *= _692.d1;
    _799 *= sizeof(bool);
    _798.data = jpl_alloc(_799);
    int64_t _800 = 0; // l
    int64_t _801 = 0; // k
    _jump2737:; // Begin body of loop
    bool _802 = _692.d1 == _801;
    int64_t _803 = 0;
    _803 *= _798.d0;
    _803 += _801;
    _803 *= _798.d1;
    _803 += _800;
    _798.data[_803] = _802;
    _800++;
    if (_800 < _692.d1)
    goto _jump2737;
    _800 = 0;
    _801++;
    if (_801 < _692.d1)
    goto _jump2737;
    // End body of loop
    _a2_bool _804;
    // Computing bound for k
    _804.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2738;
    fail_assertion("non-positive loop bound");
    _jump2738:;
    // Computing bound for l
    int64_t _805 = 793;
    int64_t _806 = _805 * _692.d1;
    _804.d1 = _806;
    if (_806 > 0) 
    goto _jump2739;
    fail_assertion("non-positive loop bound");
    _jump2739:;
    // Computing total size of heap memory to allocate
    int64_t _807 = 1;
    _807 *= _692.d1;
    _807 *= _806;
    _807 *= sizeof(bool);
    _804.data = jpl_alloc(_807);
    int64_t _808 = 0; // l
    int64_t _809 = 0; // k
    _jump2740:; // Begin body of loop
    bool _810 = true;
    bool _811 = !_810;
    int64_t _812 = 0;
    _812 *= _804.d0;
    _812 += _809;
    _812 *= _804.d1;
    _812 += _808;
    _804.data[_812] = _811;
    _808++;
    if (_808 < _806)
    goto _jump2740;
    _808 = 0;
    _809++;
    if (_809 < _692.d1)
    goto _jump2740;
    // End body of loop
    _a2_bool _813;
    // Computing bound for k
    _813.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2741;
    fail_assertion("non-positive loop bound");
    _jump2741:;
    // Computing bound for l
    int64_t _814 = _692.d1 * _692.d1;
    _813.d1 = _814;
    if (_814 > 0) 
    goto _jump2742;
    fail_assertion("non-positive loop bound");
    _jump2742:;
    // Computing total size of heap memory to allocate
    int64_t _815 = 1;
    _815 *= _692.d0;
    _815 *= _814;
    _815 *= sizeof(bool);
    _813.data = jpl_alloc(_815);
    int64_t _816 = 0; // l
    int64_t _817 = 0; // k
    _jump2743:; // Begin body of loop
    int64_t _818 = 641;
    bool _819 = _817 > _818;
    int64_t _820 = 0;
    _820 *= _813.d0;
    _820 += _817;
    _820 *= _813.d1;
    _820 += _816;
    _813.data[_820] = _819;
    _816++;
    if (_816 < _814)
    goto _jump2743;
    _816 = 0;
    _817++;
    if (_817 < _692.d0)
    goto _jump2743;
    // End body of loop
    _a1__a2_bool _821;
    _821.d0 = 3;
    _821.data = jpl_alloc(sizeof(_a2_bool) * 3);
    _821.data[0] = _798;
    _821.data[1] = _804;
    _821.data[2] = _813;
    int64_t _822 = 554;
    int64_t _823 = _822 / _692.d0;
    if (_823 >= 0)
    goto _jump2744;
    fail_assertion("negative array index");
    _jump2744:;
    if (_823 < _821.d0)
    goto _jump2745;
    fail_assertion("index too large");
    _jump2745:;
    int64_t _824 = 0;
    _824 *= _821.d0;
    _824 += _823;
    _a2_bool _825 = _821.data[_824];
    int64_t _826 = 456;
    int64_t _827 = 618;
    int64_t _828 = _826 / _827;
    if (_692.d1 >= 0)
    goto _jump2746;
    fail_assertion("negative array index");
    _jump2746:;
    if (_692.d1 < _825.d0)
    goto _jump2747;
    fail_assertion("index too large");
    _jump2747:;
    if (_828 >= 0)
    goto _jump2748;
    fail_assertion("negative array index");
    _jump2748:;
    if (_828 < _825.d1)
    goto _jump2749;
    fail_assertion("index too large");
    _jump2749:;
    int64_t _829 = 0;
    _829 *= _825.d0;
    _829 += _692.d1;
    _829 *= _825.d1;
    _829 += _828;
    bool _830 = _825.data[_829];
    double _831;
    if (!_830)
    goto _jump2750;
    _831 = _487;
    goto _jump2751;
    _jump2750:;
    rgba _832 = j();
    double _833 = _832.b;
    double _834 = 59.0;
    double _835 = fmod(_833, _834);
    _831 = _835;
    _jump2751:;
    bool _837 = true;
    bool _836 = _837;
    if (0 != _837)
    goto _jump2752;
    int64_t _838 = 122;
    int64_t _839 = -_838;
    int64_t _840 = 883;
    int64_t _841 = -_840;
    bool _842 = _839 >= _841;
    bool _843 = !_842;
    bool _844;
    if (!_843)
    goto _jump2753;
    double _845 = -_693;
    bool _846 = _487 > _845;
    _844 = _846;
    goto _jump2754;
    _jump2753:;
    rgba _847 = j();
    double _848 = a(_847);
    bool _849 = _487 == _848;
    _844 = _849;
    _jump2754:;
    _836 = _844;
    _jump2752:;
    double _850;
    if (!_836)
    goto _jump2755;
    rgba _851 = j();
    double _852 = _851.b;
    double _853 = -_693;
    bool _854 = _852 >= _853;
    _a1_double _855;
    if (!_854)
    goto _jump2756;
    bool _856 = false;
    _a1_double _857;
    if (!_856)
    goto _jump2757;
    double _858 = 18.0;
    _a1_double _859;
    _859.d0 = 2;
    _859.data = jpl_alloc(sizeof(double) * 2);
    _859.data[0] = _693;
    _859.data[1] = _858;
    _857 = _859;
    goto _jump2758;
    _jump2757:;
    _a1_double _860;
    // Computing bound for k
    _860.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2759;
    fail_assertion("non-positive loop bound");
    _jump2759:;
    // Computing total size of heap memory to allocate
    int64_t _861 = 1;
    _861 *= _692.d1;
    _861 *= sizeof(double);
    _860.data = jpl_alloc(_861);
    int64_t _862 = 0; // k
    _jump2760:; // Begin body of loop
    double _863 = 56.0;
    int64_t _864 = 0;
    _864 *= _860.d0;
    _864 += _862;
    _860.data[_864] = _863;
    _862++;
    if (_862 < _692.d1)
    goto _jump2760;
    // End body of loop
    _857 = _860;
    _jump2758:;
    _855 = _857;
    goto _jump2761;
    _jump2756:;
    _a1_double _865;
    // Computing bound for k
    _865.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2762;
    fail_assertion("non-positive loop bound");
    _jump2762:;
    // Computing total size of heap memory to allocate
    int64_t _866 = 1;
    _866 *= _692.d0;
    _866 *= sizeof(double);
    _865.data = jpl_alloc(_866);
    int64_t _867 = 0; // k
    _jump2763:; // Begin body of loop
    double _868 = 80.0;
    int64_t _869 = 0;
    _869 *= _865.d0;
    _869 += _867;
    _865.data[_869] = _868;
    _867++;
    if (_867 < _692.d0)
    goto _jump2763;
    // End body of loop
    _855 = _865;
    _jump2761:;
    int64_t _870;
    // Computing bound for k
    if (_692.d0 > 0) 
    goto _jump2764;
    fail_assertion("non-positive loop bound");
    _jump2764:;
    // Computing bound for l
    if (_692.d1 > 0) 
    goto _jump2765;
    fail_assertion("non-positive loop bound");
    _jump2765:;
    // Computing bound for m
    int64_t _871;
    // Computing bound for k
    int64_t _872 = 282;
    int64_t _873 = _872 * _692.d0;
    if (_873 > 0) 
    goto _jump2766;
    fail_assertion("non-positive loop bound");
    _jump2766:;
    _871 = 0;
    int64_t _874 = 0; // k
    _jump2767:; // Begin body of loop
    _871 += _692.d0;
    _874++;
    if (_874 < _873)
    goto _jump2767;
    // End body of loop
    if (_871 > 0) 
    goto _jump2768;
    fail_assertion("non-positive loop bound");
    _jump2768:;
    _870 = 0;
    int64_t _875 = 0; // m
    int64_t _876 = 0; // l
    int64_t _877 = 0; // k
    _jump2769:; // Begin body of loop
    int64_t _878 = _692.d0 % _692.d1;
    _870 += _878;
    _875++;
    if (_875 < _871)
    goto _jump2769;
    _875 = 0;
    _876++;
    if (_876 < _692.d1)
    goto _jump2769;
    _876 = 0;
    _877++;
    if (_877 < _692.d0)
    goto _jump2769;
    // End body of loop
    if (_870 >= 0)
    goto _jump2770;
    fail_assertion("negative array index");
    _jump2770:;
    if (_870 < _855.d0)
    goto _jump2771;
    fail_assertion("index too large");
    _jump2771:;
    int64_t _879 = 0;
    _879 *= _855.d0;
    _879 += _870;
    double _880 = _855.data[_879];
    double _881 = _487 + _880;
    _850 = _881;
    goto _jump2772;
    _jump2755:;
    _850 = _487;
    _jump2772:;
    bool _882 = _831 != _850;
    if (0 != _882)
    goto _jump2773;
    fail_assertion("k");
    _jump2773:;
    bool _883 = false;
    bool _884;
    if (!_883)
    goto _jump2774;
    bool _885 = true;
    bool _886 = !_885;
    bool _887;
    if (!_886)
    goto _jump2775;
    rgba _888 = j();
    double _889 = a(_888);
    bool _890 = _889 >= _487;
    _887 = _890;
    goto _jump2776;
    _jump2775:;
    bool _891 = false;
    bool _892 = false;
    bool _893 = _891 == _892;
    bool _894 = _692.d0 >= _692.d0;
    bool _895 = _893 != _894;
    _887 = _895;
    _jump2776:;
    bool _896 = false;
    bool _897 = _887 == _896;
    _884 = _897;
    goto _jump2777;
    _jump2774:;
    _a3_bool _898;
    // Computing bound for k
    _898.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2778;
    fail_assertion("non-positive loop bound");
    _jump2778:;
    // Computing bound for l
    _898.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2779;
    fail_assertion("non-positive loop bound");
    _jump2779:;
    // Computing bound for m
    int64_t _899;
    // Computing bound for k
    int64_t _900 = 89;
    if (_900 > 0) 
    goto _jump2780;
    fail_assertion("non-positive loop bound");
    _jump2780:;
    _899 = 0;
    int64_t _901 = 0; // k
    _jump2781:; // Begin body of loop
    _899 += _692.d1;
    _901++;
    if (_901 < _900)
    goto _jump2781;
    // End body of loop
    _898.d2 = _899;
    if (_899 > 0) 
    goto _jump2782;
    fail_assertion("non-positive loop bound");
    _jump2782:;
    // Computing total size of heap memory to allocate
    int64_t _902 = 1;
    _902 *= _692.d0;
    _902 *= _692.d0;
    _902 *= _899;
    _902 *= sizeof(bool);
    _898.data = jpl_alloc(_902);
    int64_t _903 = 0; // m
    int64_t _904 = 0; // l
    int64_t _905 = 0; // k
    _jump2783:; // Begin body of loop
    bool _906 = true;
    int64_t _907 = 0;
    _907 *= _898.d0;
    _907 += _905;
    _907 *= _898.d1;
    _907 += _904;
    _907 *= _898.d2;
    _907 += _903;
    _898.data[_907] = _906;
    _903++;
    if (_903 < _899)
    goto _jump2783;
    _903 = 0;
    _904++;
    if (_904 < _692.d0)
    goto _jump2783;
    _904 = 0;
    _905++;
    if (_905 < _692.d0)
    goto _jump2783;
    // End body of loop
    int64_t _908 = 20;
    int64_t _909 = 645;
    int64_t _910 = _909 - _692.d1;
    bool _911 = _692.d1 == _910;
    int64_t _912;
    if (!_911)
    goto _jump2784;
    int64_t _913 = 192;
    int64_t _914 = 695;
    bool _915 = _913 < _914;
    int64_t _916;
    if (!_915)
    goto _jump2785;
    int64_t _917 = 665;
    _916 = _917;
    goto _jump2786;
    _jump2785:;
    int64_t _918 = 566;
    int64_t _919 = _918 + _692.d0;
    _916 = _919;
    _jump2786:;
    _912 = _916;
    goto _jump2787;
    _jump2784:;
    _a2_int64_t _920;
    // Computing bound for k
    _920.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2788;
    fail_assertion("non-positive loop bound");
    _jump2788:;
    // Computing bound for l
    _920.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2789;
    fail_assertion("non-positive loop bound");
    _jump2789:;
    // Computing total size of heap memory to allocate
    int64_t _921 = 1;
    _921 *= _692.d0;
    _921 *= _692.d0;
    _921 *= sizeof(int64_t);
    _920.data = jpl_alloc(_921);
    int64_t _922 = 0; // l
    int64_t _923 = 0; // k
    _jump2790:; // Begin body of loop
    int64_t _924 = 0;
    _924 *= _920.d0;
    _924 += _923;
    _924 *= _920.d1;
    _924 += _922;
    _920.data[_924] = _923;
    _922++;
    if (_922 < _692.d0)
    goto _jump2790;
    _922 = 0;
    _923++;
    if (_923 < _692.d0)
    goto _jump2790;
    // End body of loop
    int64_t _925 = 742;
    bool _926 = true;
    int64_t _927;
    if (!_926)
    goto _jump2791;
    _927 = _692.d0;
    goto _jump2792;
    _jump2791:;
    _927 = _692.d1;
    _jump2792:;
    if (_925 >= 0)
    goto _jump2793;
    fail_assertion("negative array index");
    _jump2793:;
    if (_925 < _920.d0)
    goto _jump2794;
    fail_assertion("index too large");
    _jump2794:;
    if (_927 >= 0)
    goto _jump2795;
    fail_assertion("negative array index");
    _jump2795:;
    if (_927 < _920.d1)
    goto _jump2796;
    fail_assertion("index too large");
    _jump2796:;
    int64_t _928 = 0;
    _928 *= _920.d0;
    _928 += _925;
    _928 *= _920.d1;
    _928 += _927;
    int64_t _929 = _920.data[_928];
    _912 = _929;
    _jump2787:;
    int64_t _930 = _692.d1 / _692.d0;
    int64_t _931 = 92;
    int64_t _932 = _930 * _931;
    if (_908 >= 0)
    goto _jump2797;
    fail_assertion("negative array index");
    _jump2797:;
    if (_908 < _898.d0)
    goto _jump2798;
    fail_assertion("index too large");
    _jump2798:;
    if (_912 >= 0)
    goto _jump2799;
    fail_assertion("negative array index");
    _jump2799:;
    if (_912 < _898.d1)
    goto _jump2800;
    fail_assertion("index too large");
    _jump2800:;
    if (_932 >= 0)
    goto _jump2801;
    fail_assertion("negative array index");
    _jump2801:;
    if (_932 < _898.d2)
    goto _jump2802;
    fail_assertion("index too large");
    _jump2802:;
    int64_t _933 = 0;
    _933 *= _898.d0;
    _933 += _908;
    _933 *= _898.d1;
    _933 += _912;
    _933 *= _898.d2;
    _933 += _932;
    bool _934 = _898.data[_933];
    _884 = _934;
    _jump2777:;
    bool _935 = false;
    bool _936;
    if (!_935)
    goto _jump2803;
    bool _937 = true;
    bool _938 = !_937;
    _936 = _938;
    goto _jump2804;
    _jump2803:;
    bool _939 = false;
    _936 = _939;
    _jump2804:;
    bool _940 = !_936;
    _a3_bool _941;
    if (!_940)
    goto _jump2805;
    _a3__a3_bool _942;
    // Computing bound for k
    int64_t _943;
    // Computing bound for k
    int64_t _944 = 355;
    if (_944 > 0) 
    goto _jump2806;
    fail_assertion("non-positive loop bound");
    _jump2806:;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump2807;
    fail_assertion("non-positive loop bound");
    _jump2807:;
    _943 = 0;
    int64_t _945 = 0; // l
    int64_t _946 = 0; // k
    _jump2808:; // Begin body of loop
    int64_t _947 = 769;
    _943 += _947;
    _945++;
    if (_945 < _692.d0)
    goto _jump2808;
    _945 = 0;
    _946++;
    if (_946 < _944)
    goto _jump2808;
    // End body of loop
    _942.d0 = _943;
    if (_943 > 0) 
    goto _jump2809;
    fail_assertion("non-positive loop bound");
    _jump2809:;
    // Computing bound for l
    _942.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2810;
    fail_assertion("non-positive loop bound");
    _jump2810:;
    // Computing bound for m
    int64_t _948 = 958;
    _942.d2 = _948;
    if (_948 > 0) 
    goto _jump2811;
    fail_assertion("non-positive loop bound");
    _jump2811:;
    // Computing total size of heap memory to allocate
    int64_t _949 = 1;
    _949 *= _943;
    _949 *= _692.d0;
    _949 *= _948;
    _949 *= sizeof(_a3_bool);
    _942.data = jpl_alloc(_949);
    int64_t _950 = 0; // m
    int64_t _951 = 0; // l
    int64_t _952 = 0; // k
    _jump2812:; // Begin body of loop
    _a3_bool _953;
    // Computing bound for n
    int64_t _954 = 63;
    _953.d0 = _954;
    if (_954 > 0) 
    goto _jump2813;
    fail_assertion("non-positive loop bound");
    _jump2813:;
    // Computing bound for o
    _953.d1 = _952;
    if (_952 > 0) 
    goto _jump2814;
    fail_assertion("non-positive loop bound");
    _jump2814:;
    // Computing bound for p
    _953.d2 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2815;
    fail_assertion("non-positive loop bound");
    _jump2815:;
    // Computing total size of heap memory to allocate
    int64_t _955 = 1;
    _955 *= _954;
    _955 *= _952;
    _955 *= _692.d1;
    _955 *= sizeof(bool);
    _953.data = jpl_alloc(_955);
    int64_t _956 = 0; // p
    int64_t _957 = 0; // o
    int64_t _958 = 0; // n
    _jump2816:; // Begin body of loop
    bool _959 = true;
    int64_t _960 = 0;
    _960 *= _953.d0;
    _960 += _958;
    _960 *= _953.d1;
    _960 += _957;
    _960 *= _953.d2;
    _960 += _956;
    _953.data[_960] = _959;
    _956++;
    if (_956 < _692.d1)
    goto _jump2816;
    _956 = 0;
    _957++;
    if (_957 < _952)
    goto _jump2816;
    _957 = 0;
    _958++;
    if (_958 < _954)
    goto _jump2816;
    // End body of loop
    int64_t _961 = 0;
    _961 *= _942.d0;
    _961 += _952;
    _961 *= _942.d1;
    _961 += _951;
    _961 *= _942.d2;
    _961 += _950;
    _942.data[_961] = _953;
    _950++;
    if (_950 < _948)
    goto _jump2812;
    _950 = 0;
    _951++;
    if (_951 < _692.d0)
    goto _jump2812;
    _951 = 0;
    _952++;
    if (_952 < _943)
    goto _jump2812;
    // End body of loop
    int64_t _962 = -_692.d1;
    int64_t _963 = _692.d1 - _962;
    int64_t _964 = 760;
    int64_t _965 = -_964;
    int64_t _966 = 450;
    if (_963 >= 0)
    goto _jump2817;
    fail_assertion("negative array index");
    _jump2817:;
    if (_963 < _942.d0)
    goto _jump2818;
    fail_assertion("index too large");
    _jump2818:;
    if (_965 >= 0)
    goto _jump2819;
    fail_assertion("negative array index");
    _jump2819:;
    if (_965 < _942.d1)
    goto _jump2820;
    fail_assertion("index too large");
    _jump2820:;
    if (_966 >= 0)
    goto _jump2821;
    fail_assertion("negative array index");
    _jump2821:;
    if (_966 < _942.d2)
    goto _jump2822;
    fail_assertion("index too large");
    _jump2822:;
    int64_t _967 = 0;
    _967 *= _942.d0;
    _967 += _963;
    _967 *= _942.d1;
    _967 += _965;
    _967 *= _942.d2;
    _967 += _966;
    _a3_bool _968 = _942.data[_967];
    _941 = _968;
    goto _jump2823;
    _jump2805:;
    _a3_bool _969;
    // Computing bound for k
    int64_t _970 = -_692.d0;
    _969.d0 = _970;
    if (_970 > 0) 
    goto _jump2824;
    fail_assertion("non-positive loop bound");
    _jump2824:;
    // Computing bound for l
    _a1_int64_t _971;
    // Computing bound for k
    _971.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2825;
    fail_assertion("non-positive loop bound");
    _jump2825:;
    // Computing total size of heap memory to allocate
    int64_t _972 = 1;
    _972 *= _692.d0;
    _972 *= sizeof(int64_t);
    _971.data = jpl_alloc(_972);
    int64_t _973 = 0; // k
    _jump2826:; // Begin body of loop
    int64_t _974 = 795;
    int64_t _975 = 0;
    _975 *= _971.d0;
    _975 += _973;
    _971.data[_975] = _974;
    _973++;
    if (_973 < _692.d0)
    goto _jump2826;
    // End body of loop
    int64_t _976 = _692.d0 - _692.d0;
    if (_976 >= 0)
    goto _jump2827;
    fail_assertion("negative array index");
    _jump2827:;
    if (_976 < _971.d0)
    goto _jump2828;
    fail_assertion("index too large");
    _jump2828:;
    int64_t _977 = 0;
    _977 *= _971.d0;
    _977 += _976;
    int64_t _978 = _971.data[_977];
    _969.d1 = _978;
    if (_978 > 0) 
    goto _jump2829;
    fail_assertion("non-positive loop bound");
    _jump2829:;
    // Computing bound for m
    int64_t _979;
    // Computing bound for k
    if (_692.d0 > 0) 
    goto _jump2830;
    fail_assertion("non-positive loop bound");
    _jump2830:;
    _979 = 0;
    int64_t _980 = 0; // k
    _jump2831:; // Begin body of loop
    int64_t _981 = _980 * _692.d1;
    _979 += _981;
    _980++;
    if (_980 < _692.d0)
    goto _jump2831;
    // End body of loop
    _969.d2 = _979;
    if (_979 > 0) 
    goto _jump2832;
    fail_assertion("non-positive loop bound");
    _jump2832:;
    // Computing total size of heap memory to allocate
    int64_t _982 = 1;
    _982 *= _970;
    _982 *= _978;
    _982 *= _979;
    _982 *= sizeof(bool);
    _969.data = jpl_alloc(_982);
    int64_t _983 = 0; // m
    int64_t _984 = 0; // l
    int64_t _985 = 0; // k
    _jump2833:; // Begin body of loop
    bool _986 = false;
    int64_t _987 = 0;
    _987 *= _969.d0;
    _987 += _985;
    _987 *= _969.d1;
    _987 += _984;
    _987 *= _969.d2;
    _987 += _983;
    _969.data[_987] = _986;
    _983++;
    if (_983 < _979)
    goto _jump2833;
    _983 = 0;
    _984++;
    if (_984 < _978)
    goto _jump2833;
    _984 = 0;
    _985++;
    if (_985 < _970)
    goto _jump2833;
    // End body of loop
    _941 = _969;
    _jump2823:;
    int64_t _988;
    // Computing bound for k
    _a2_int64_t _989;
    // Computing bound for k
    int64_t _990 = 420;
    _989.d0 = _990;
    if (_990 > 0) 
    goto _jump2834;
    fail_assertion("non-positive loop bound");
    _jump2834:;
    // Computing bound for l
    _989.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2835;
    fail_assertion("non-positive loop bound");
    _jump2835:;
    // Computing total size of heap memory to allocate
    int64_t _991 = 1;
    _991 *= _990;
    _991 *= _692.d0;
    _991 *= sizeof(int64_t);
    _989.data = jpl_alloc(_991);
    int64_t _992 = 0; // l
    int64_t _993 = 0; // k
    _jump2836:; // Begin body of loop
    int64_t _994 = 0;
    _994 *= _989.d0;
    _994 += _993;
    _994 *= _989.d1;
    _994 += _992;
    _989.data[_994] = _692.d0;
    _992++;
    if (_992 < _692.d0)
    goto _jump2836;
    _992 = 0;
    _993++;
    if (_993 < _990)
    goto _jump2836;
    // End body of loop
    bool _995 = false;
    int64_t _996;
    if (!_995)
    goto _jump2837;
    _996 = _692.d1;
    goto _jump2838;
    _jump2837:;
    _996 = _692.d0;
    _jump2838:;
    int64_t _997 = 24;
    int64_t _998 = -_997;
    if (_996 >= 0)
    goto _jump2839;
    fail_assertion("negative array index");
    _jump2839:;
    if (_996 < _989.d0)
    goto _jump2840;
    fail_assertion("index too large");
    _jump2840:;
    if (_998 >= 0)
    goto _jump2841;
    fail_assertion("negative array index");
    _jump2841:;
    if (_998 < _989.d1)
    goto _jump2842;
    fail_assertion("index too large");
    _jump2842:;
    int64_t _999 = 0;
    _999 *= _989.d0;
    _999 += _996;
    _999 *= _989.d1;
    _999 += _998;
    int64_t _1000 = _989.data[_999];
    int64_t _1001;
    // Computing bound for k
    int64_t _1002 = 681;
    if (_1002 > 0) 
    goto _jump2843;
    fail_assertion("non-positive loop bound");
    _jump2843:;
    // Computing bound for l
    if (_692.d1 > 0) 
    goto _jump2844;
    fail_assertion("non-positive loop bound");
    _jump2844:;
    // Computing bound for m
    int64_t _1003 = 394;
    if (_1003 > 0) 
    goto _jump2845;
    fail_assertion("non-positive loop bound");
    _jump2845:;
    _1001 = 0;
    int64_t _1004 = 0; // m
    int64_t _1005 = 0; // l
    int64_t _1006 = 0; // k
    _jump2846:; // Begin body of loop
    _1001 += _1004;
    _1004++;
    if (_1004 < _1003)
    goto _jump2846;
    _1004 = 0;
    _1005++;
    if (_1005 < _692.d1)
    goto _jump2846;
    _1005 = 0;
    _1006++;
    if (_1006 < _1002)
    goto _jump2846;
    // End body of loop
    int64_t _1007 = -_1001;
    int64_t _1008 = _1000 / _1007;
    if (_1008 > 0) 
    goto _jump2847;
    fail_assertion("non-positive loop bound");
    _jump2847:;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump2848;
    fail_assertion("non-positive loop bound");
    _jump2848:;
    _988 = 0;
    int64_t _1009 = 0; // l
    int64_t _1010 = 0; // k
    _jump2849:; // Begin body of loop
    _988 += _692.d0;
    _1009++;
    if (_1009 < _692.d0)
    goto _jump2849;
    _1009 = 0;
    _1010++;
    if (_1010 < _1008)
    goto _jump2849;
    // End body of loop
    rgba _1012 = j();
    double _1013 = _1012.g;
    bool _1014 = _487 == _1013;
    bool _1011 = _1014;
    if (0 != _1014)
    goto _jump2850;
    int64_t _1015 = 251;
    int64_t _1016;
    // Computing bound for k
    int64_t _1017 = 329;
    if (_1017 > 0) 
    goto _jump2851;
    fail_assertion("non-positive loop bound");
    _jump2851:;
    _1016 = 0;
    int64_t _1018 = 0; // k
    _jump2852:; // Begin body of loop
    _1016 += _692.d0;
    _1018++;
    if (_1018 < _1017)
    goto _jump2852;
    // End body of loop
    bool _1019 = _1015 <= _1016;
    _1011 = _1019;
    _jump2850:;
    int64_t _1020;
    if (!_1011)
    goto _jump2853;
    int64_t _1021 = 611;
    int64_t _1022;
    // Computing bound for k
    int64_t _1023 = 381;
    if (_1023 > 0) 
    goto _jump2854;
    fail_assertion("non-positive loop bound");
    _jump2854:;
    _1022 = 0;
    int64_t _1024 = 0; // k
    _jump2855:; // Begin body of loop
    int64_t _1025 = 958;
    int64_t _1026 = _1025 + _692.d1;
    _1022 += _1026;
    _1024++;
    if (_1024 < _1023)
    goto _jump2855;
    // End body of loop
    int64_t _1027 = _1021 / _1022;
    _1020 = _1027;
    goto _jump2856;
    _jump2853:;
    _1020 = _692.d1;
    _jump2856:;
    double _1028 = 64.0;
    double _1029 = 61.0;
    bool _1030 = _1028 <= _1029;
    _a2_int64_t _1031;
    if (!_1030)
    goto _jump2857;
    _a2_int64_t _1032;
    // Computing bound for k
    int64_t _1033 = _692.d1 + _692.d1;
    _1032.d0 = _1033;
    if (_1033 > 0) 
    goto _jump2858;
    fail_assertion("non-positive loop bound");
    _jump2858:;
    // Computing bound for l
    int64_t _1034 = 345;
    _1032.d1 = _1034;
    if (_1034 > 0) 
    goto _jump2859;
    fail_assertion("non-positive loop bound");
    _jump2859:;
    // Computing total size of heap memory to allocate
    int64_t _1035 = 1;
    _1035 *= _1033;
    _1035 *= _1034;
    _1035 *= sizeof(int64_t);
    _1032.data = jpl_alloc(_1035);
    int64_t _1036 = 0; // l
    int64_t _1037 = 0; // k
    _jump2860:; // Begin body of loop
    int64_t _1038 = 0;
    _1038 *= _1032.d0;
    _1038 += _1037;
    _1038 *= _1032.d1;
    _1038 += _1036;
    _1032.data[_1038] = _1036;
    _1036++;
    if (_1036 < _1034)
    goto _jump2860;
    _1036 = 0;
    _1037++;
    if (_1037 < _1033)
    goto _jump2860;
    // End body of loop
    _1031 = _1032;
    goto _jump2861;
    _jump2857:;
    _a2_int64_t _1039;
    // Computing bound for k
    int64_t _1040 = 268;
    int64_t _1041 = -_1040;
    _1039.d0 = _1041;
    if (_1041 > 0) 
    goto _jump2862;
    fail_assertion("non-positive loop bound");
    _jump2862:;
    // Computing bound for l
    _1039.d1 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2863;
    fail_assertion("non-positive loop bound");
    _jump2863:;
    // Computing total size of heap memory to allocate
    int64_t _1042 = 1;
    _1042 *= _1041;
    _1042 *= _692.d1;
    _1042 *= sizeof(int64_t);
    _1039.data = jpl_alloc(_1042);
    int64_t _1043 = 0; // l
    int64_t _1044 = 0; // k
    _jump2864:; // Begin body of loop
    int64_t _1045 = 565;
    int64_t _1046 = 0;
    _1046 *= _1039.d0;
    _1046 += _1044;
    _1046 *= _1039.d1;
    _1046 += _1043;
    _1039.data[_1046] = _1045;
    _1043++;
    if (_1043 < _692.d1)
    goto _jump2864;
    _1043 = 0;
    _1044++;
    if (_1044 < _1041)
    goto _jump2864;
    // End body of loop
    _1031 = _1039;
    _jump2861:;
    int64_t _1047 = 11;
    int64_t _1048 = -_1047;
    int64_t _1049 = 834;
    if (_1048 >= 0)
    goto _jump2865;
    fail_assertion("negative array index");
    _jump2865:;
    if (_1048 < _1031.d0)
    goto _jump2866;
    fail_assertion("index too large");
    _jump2866:;
    if (_1049 >= 0)
    goto _jump2867;
    fail_assertion("negative array index");
    _jump2867:;
    if (_1049 < _1031.d1)
    goto _jump2868;
    fail_assertion("index too large");
    _jump2868:;
    int64_t _1050 = 0;
    _1050 *= _1031.d0;
    _1050 += _1048;
    _1050 *= _1031.d1;
    _1050 += _1049;
    int64_t _1051 = _1031.data[_1050];
    if (_988 >= 0)
    goto _jump2869;
    fail_assertion("negative array index");
    _jump2869:;
    if (_988 < _941.d0)
    goto _jump2870;
    fail_assertion("index too large");
    _jump2870:;
    if (_1020 >= 0)
    goto _jump2871;
    fail_assertion("negative array index");
    _jump2871:;
    if (_1020 < _941.d1)
    goto _jump2872;
    fail_assertion("index too large");
    _jump2872:;
    if (_1051 >= 0)
    goto _jump2873;
    fail_assertion("negative array index");
    _jump2873:;
    if (_1051 < _941.d2)
    goto _jump2874;
    fail_assertion("index too large");
    _jump2874:;
    int64_t _1052 = 0;
    _1052 *= _941.d0;
    _1052 += _988;
    _1052 *= _941.d1;
    _1052 += _1020;
    _1052 *= _941.d2;
    _1052 += _1051;
    bool _1053 = _941.data[_1052];
    bool _1054 = _884 == _1053;
    _a2_rgba _1055;
    if (!_1054)
    goto _jump2875;
    int64_t _1056;
    // Computing bound for k
    if (_692.d1 > 0) 
    goto _jump2876;
    fail_assertion("non-positive loop bound");
    _jump2876:;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump2877;
    fail_assertion("non-positive loop bound");
    _jump2877:;
    _1056 = 0;
    int64_t _1057 = 0; // l
    int64_t _1058 = 0; // k
    _jump2878:; // Begin body of loop
    _1056 += _692.d0;
    _1057++;
    if (_1057 < _692.d0)
    goto _jump2878;
    _1057 = 0;
    _1058++;
    if (_1058 < _692.d1)
    goto _jump2878;
    // End body of loop
    int64_t _1059 = -_692.d1;
    bool _1060 = _1056 > _1059;
    double _1061;
    if (!_1060)
    goto _jump2879;
    rgba _1062 = j();
    double _1063 = _1062.a;
    _1061 = _1063;
    goto _jump2880;
    _jump2879:;
    rgba _1064 = j();
    double _1065 = _1064.a;
    _1061 = _1065;
    _jump2880:;
    double _1066 = fmod(_693, _1061);
    bool _1067 = _1066 <= _487;
    _a2_rgba _1068;
    if (!_1067)
    goto _jump2881;
    _a3_int64_t _1070;
    // Computing bound for k
    _1070.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2882;
    fail_assertion("non-positive loop bound");
    _jump2882:;
    // Computing bound for l
    int64_t _1071 = 425;
    _1070.d1 = _1071;
    if (_1071 > 0) 
    goto _jump2883;
    fail_assertion("non-positive loop bound");
    _jump2883:;
    // Computing bound for m
    _1070.d2 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2884;
    fail_assertion("non-positive loop bound");
    _jump2884:;
    // Computing total size of heap memory to allocate
    int64_t _1072 = 1;
    _1072 *= _692.d1;
    _1072 *= _1071;
    _1072 *= _692.d1;
    _1072 *= sizeof(int64_t);
    _1070.data = jpl_alloc(_1072);
    int64_t _1073 = 0; // m
    int64_t _1074 = 0; // l
    int64_t _1075 = 0; // k
    _jump2885:; // Begin body of loop
    int64_t _1076 = 0;
    _1076 *= _1070.d0;
    _1076 += _1075;
    _1076 *= _1070.d1;
    _1076 += _1074;
    _1076 *= _1070.d2;
    _1076 += _1073;
    _1070.data[_1076] = _692.d0;
    _1073++;
    if (_1073 < _692.d1)
    goto _jump2885;
    _1073 = 0;
    _1074++;
    if (_1074 < _1071)
    goto _jump2885;
    _1074 = 0;
    _1075++;
    if (_1075 < _692.d1)
    goto _jump2885;
    // End body of loop
    int64_t _1077 = 820;
    int64_t _1078 = _692.d1 / _1077;
    int64_t _1079 = 758;
    int64_t _1080 = -_1079;
    if (_1078 >= 0)
    goto _jump2886;
    fail_assertion("negative array index");
    _jump2886:;
    if (_1078 < _1070.d0)
    goto _jump2887;
    fail_assertion("index too large");
    _jump2887:;
    if (_692.d0 >= 0)
    goto _jump2888;
    fail_assertion("negative array index");
    _jump2888:;
    if (_692.d0 < _1070.d1)
    goto _jump2889;
    fail_assertion("index too large");
    _jump2889:;
    if (_1080 >= 0)
    goto _jump2890;
    fail_assertion("negative array index");
    _jump2890:;
    if (_1080 < _1070.d2)
    goto _jump2891;
    fail_assertion("index too large");
    _jump2891:;
    int64_t _1081 = 0;
    _1081 *= _1070.d0;
    _1081 += _1078;
    _1081 *= _1070.d1;
    _1081 += _692.d0;
    _1081 *= _1070.d2;
    _1081 += _1080;
    int64_t _1082 = _1070.data[_1081];
    int64_t _1083;
    // Computing bound for k
    if (_692.d1 > 0) 
    goto _jump2892;
    fail_assertion("non-positive loop bound");
    _jump2892:;
    // Computing bound for l
    int64_t _1084 = 934;
    int64_t _1085 = -_1084;
    if (_1085 > 0) 
    goto _jump2893;
    fail_assertion("non-positive loop bound");
    _jump2893:;
    _1083 = 0;
    int64_t _1086 = 0; // l
    int64_t _1087 = 0; // k
    _jump2894:; // Begin body of loop
    _1083 += _692.d1;
    _1086++;
    if (_1086 < _1085)
    goto _jump2894;
    _1086 = 0;
    _1087++;
    if (_1087 < _692.d1)
    goto _jump2894;
    // End body of loop
    bool _1088 = _1082 != _1083;
    bool _1069 = _1088;
    if (0 == _1088)
    goto _jump2895;
    bool _1089 = _487 != _693;
    bool _1090 = !_1089;
    _1069 = _1090;
    _jump2895:;
    _a2_rgba _1091;
    if (!_1069)
    goto _jump2896;
    bool _1093 = true;
    bool _1092 = _1093;
    if (0 == _1093)
    goto _jump2897;
    bool _1094 = _692.d1 >= _692.d1;
    _1092 = _1094;
    _jump2897:;
    bool _1095 = !_1092;
    _a2_rgba _1096;
    if (!_1095)
    goto _jump2898;
    _a2_rgba _1097;
    // Computing bound for k
    int64_t _1098;
    // Computing bound for k
    int64_t _1099 = 842;
    if (_1099 > 0) 
    goto _jump2899;
    fail_assertion("non-positive loop bound");
    _jump2899:;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump2900;
    fail_assertion("non-positive loop bound");
    _jump2900:;
    // Computing bound for m
    bool _1100 = false;
    int64_t _1101;
    if (!_1100)
    goto _jump2901;
    int64_t _1102 = 527;
    _1101 = _1102;
    goto _jump2902;
    _jump2901:;
    int64_t _1103 = 721;
    _1101 = _1103;
    _jump2902:;
    if (_1101 > 0) 
    goto _jump2903;
    fail_assertion("non-positive loop bound");
    _jump2903:;
    _1098 = 0;
    int64_t _1104 = 0; // m
    int64_t _1105 = 0; // l
    int64_t _1106 = 0; // k
    _jump2904:; // Begin body of loop
    int64_t _1107;
    // Computing bound for n
    if (_1106 > 0) 
    goto _jump2905;
    fail_assertion("non-positive loop bound");
    _jump2905:;
    // Computing bound for o
    if (_692.d0 > 0) 
    goto _jump2906;
    fail_assertion("non-positive loop bound");
    _jump2906:;
    // Computing bound for p
    if (_692.d1 > 0) 
    goto _jump2907;
    fail_assertion("non-positive loop bound");
    _jump2907:;
    _1107 = 0;
    int64_t _1108 = 0; // p
    int64_t _1109 = 0; // o
    int64_t _1110 = 0; // n
    _jump2908:; // Begin body of loop
    _1107 += _1106;
    _1108++;
    if (_1108 < _692.d1)
    goto _jump2908;
    _1108 = 0;
    _1109++;
    if (_1109 < _692.d0)
    goto _jump2908;
    _1109 = 0;
    _1110++;
    if (_1110 < _1106)
    goto _jump2908;
    // End body of loop
    _1098 += _1107;
    _1104++;
    if (_1104 < _1101)
    goto _jump2904;
    _1104 = 0;
    _1105++;
    if (_1105 < _692.d0)
    goto _jump2904;
    _1105 = 0;
    _1106++;
    if (_1106 < _1099)
    goto _jump2904;
    // End body of loop
    _1097.d0 = _1098;
    if (_1098 > 0) 
    goto _jump2909;
    fail_assertion("non-positive loop bound");
    _jump2909:;
    // Computing bound for l
    _1097.d1 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump2910;
    fail_assertion("non-positive loop bound");
    _jump2910:;
    // Computing total size of heap memory to allocate
    int64_t _1111 = 1;
    _1111 *= _1098;
    _1111 *= _692.d1;
    _1111 *= sizeof(rgba);
    _1097.data = jpl_alloc(_1111);
    int64_t _1112 = 0; // l
    int64_t _1113 = 0; // k
    _jump2911:; // Begin body of loop
    rgba _1114 = j();
    int64_t _1115 = 0;
    _1115 *= _1097.d0;
    _1115 += _1113;
    _1115 *= _1097.d1;
    _1115 += _1112;
    _1097.data[_1115] = _1114;
    _1112++;
    if (_1112 < _692.d1)
    goto _jump2911;
    _1112 = 0;
    _1113++;
    if (_1113 < _1098)
    goto _jump2911;
    // End body of loop
    _1096 = _1097;
    goto _jump2912;
    _jump2898:;
    _a2_rgba _1116;
    // Computing bound for k
    int64_t _1117 = _692.d0 - _692.d0;
    int64_t _1118 = -_1117;
    _1116.d0 = _1118;
    if (_1118 > 0) 
    goto _jump2913;
    fail_assertion("non-positive loop bound");
    _jump2913:;
    // Computing bound for l
    _1116.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2914;
    fail_assertion("non-positive loop bound");
    _jump2914:;
    // Computing total size of heap memory to allocate
    int64_t _1119 = 1;
    _1119 *= _1118;
    _1119 *= _692.d0;
    _1119 *= sizeof(rgba);
    _1116.data = jpl_alloc(_1119);
    int64_t _1120 = 0; // l
    int64_t _1121 = 0; // k
    _jump2915:; // Begin body of loop
    bool _1122 = _692.d1 >= _692.d1;
    rgba _1123;
    if (!_1122)
    goto _jump2916;
    rgba _1124 = j();
    _1123 = _1124;
    goto _jump2917;
    _jump2916:;
    rgba _1125 = j();
    _1123 = _1125;
    _jump2917:;
    int64_t _1126 = 0;
    _1126 *= _1116.d0;
    _1126 += _1121;
    _1126 *= _1116.d1;
    _1126 += _1120;
    _1116.data[_1126] = _1123;
    _1120++;
    if (_1120 < _692.d0)
    goto _jump2915;
    _1120 = 0;
    _1121++;
    if (_1121 < _1118)
    goto _jump2915;
    // End body of loop
    _1096 = _1116;
    _jump2912:;
    _1091 = _1096;
    goto _jump2918;
    _jump2896:;
    _1091 = _692;
    _jump2918:;
    _1068 = _1091;
    goto _jump2919;
    _jump2881:;
    _a2_rgba _1127;
    // Computing bound for k
    bool _1129 = true;
    bool _1128 = _1129;
    if (0 == _1129)
    goto _jump2920;
    int64_t _1130 = 227;
    bool _1131 = _1130 != _692.d1;
    _1128 = _1131;
    _jump2920:;
    bool _1132 = !_1128;
    int64_t _1133;
    if (!_1132)
    goto _jump2921;
    double _1134;
    // Computing bound for k
    int64_t _1135 = 992;
    if (_1135 > 0) 
    goto _jump2922;
    fail_assertion("non-positive loop bound");
    _jump2922:;
    _1134 = 0;
    int64_t _1136 = 0; // k
    _jump2923:; // Begin body of loop
    _1134 += _693;
    _1136++;
    if (_1136 < _1135)
    goto _jump2923;
    // End body of loop
    bool _1137 = _487 == _1134;
    int64_t _1138;
    if (!_1137)
    goto _jump2924;
    int64_t _1139;
    // Computing bound for k
    if (_692.d1 > 0) 
    goto _jump2925;
    fail_assertion("non-positive loop bound");
    _jump2925:;
    // Computing bound for l
    int64_t _1140 = 728;
    if (_1140 > 0) 
    goto _jump2926;
    fail_assertion("non-positive loop bound");
    _jump2926:;
    // Computing bound for m
    if (_692.d1 > 0) 
    goto _jump2927;
    fail_assertion("non-positive loop bound");
    _jump2927:;
    _1139 = 0;
    int64_t _1141 = 0; // m
    int64_t _1142 = 0; // l
    int64_t _1143 = 0; // k
    _jump2928:; // Begin body of loop
    int64_t _1144 = 376;
    _1139 += _1144;
    _1141++;
    if (_1141 < _692.d1)
    goto _jump2928;
    _1141 = 0;
    _1142++;
    if (_1142 < _1140)
    goto _jump2928;
    _1142 = 0;
    _1143++;
    if (_1143 < _692.d1)
    goto _jump2928;
    // End body of loop
    int64_t _1145 = -_692.d1;
    int64_t _1146 = _1139 * _1145;
    _1138 = _1146;
    goto _jump2929;
    _jump2924:;
    int64_t _1147 = 725;
    _1138 = _1147;
    _jump2929:;
    _1133 = _1138;
    goto _jump2930;
    _jump2921:;
    _1133 = _692.d1;
    _jump2930:;
    _1127.d0 = _1133;
    if (_1133 > 0) 
    goto _jump2931;
    fail_assertion("non-positive loop bound");
    _jump2931:;
    // Computing bound for l
    int64_t _1148;
    // Computing bound for k
    int64_t _1149 = 780;
    if (_1149 > 0) 
    goto _jump2932;
    fail_assertion("non-positive loop bound");
    _jump2932:;
    // Computing bound for l
    int64_t _1150;
    // Computing bound for k
    int64_t _1151 = _692.d0 * _692.d0;
    if (_1151 > 0) 
    goto _jump2933;
    fail_assertion("non-positive loop bound");
    _jump2933:;
    _1150 = 0;
    int64_t _1152 = 0; // k
    _jump2934:; // Begin body of loop
    bool _1153 = true;
    int64_t _1154;
    if (!_1153)
    goto _jump2935;
    _1154 = _692.d1;
    goto _jump2936;
    _jump2935:;
    _1154 = _1152;
    _jump2936:;
    _1150 += _1154;
    _1152++;
    if (_1152 < _1151)
    goto _jump2934;
    // End body of loop
    int64_t _1155 = -_1150;
    if (_1155 > 0) 
    goto _jump2937;
    fail_assertion("non-positive loop bound");
    _jump2937:;
    // Computing bound for m
    int64_t _1156 = 878;
    int64_t _1157 = -_1156;
    int64_t _1158 = -_1157;
    if (_1158 > 0) 
    goto _jump2938;
    fail_assertion("non-positive loop bound");
    _jump2938:;
    _1148 = 0;
    int64_t _1159 = 0; // m
    int64_t _1160 = 0; // l
    int64_t _1161 = 0; // k
    _jump2939:; // Begin body of loop
    int64_t _1162 = -_692.d0;
    _1148 += _1162;
    _1159++;
    if (_1159 < _1158)
    goto _jump2939;
    _1159 = 0;
    _1160++;
    if (_1160 < _1155)
    goto _jump2939;
    _1160 = 0;
    _1161++;
    if (_1161 < _1149)
    goto _jump2939;
    // End body of loop
    _1127.d1 = _1148;
    if (_1148 > 0) 
    goto _jump2940;
    fail_assertion("non-positive loop bound");
    _jump2940:;
    // Computing total size of heap memory to allocate
    int64_t _1163 = 1;
    _1163 *= _1133;
    _1163 *= _1148;
    _1163 *= sizeof(rgba);
    _1127.data = jpl_alloc(_1163);
    int64_t _1164 = 0; // l
    int64_t _1165 = 0; // k
    _jump2941:; // Begin body of loop
    rgba _1166 = j();
    int64_t _1167 = 0;
    _1167 *= _1127.d0;
    _1167 += _1165;
    _1167 *= _1127.d1;
    _1167 += _1164;
    _1127.data[_1167] = _1166;
    _1164++;
    if (_1164 < _1148)
    goto _jump2941;
    _1164 = 0;
    _1165++;
    if (_1165 < _1133)
    goto _jump2941;
    // End body of loop
    _1068 = _1127;
    _jump2919:;
    _1055 = _1068;
    goto _jump2942;
    _jump2875:;
    _a2_rgba _1168;
    // Computing bound for k
    int64_t _1169;
    // Computing bound for k
    if (_692.d1 > 0) 
    goto _jump2943;
    fail_assertion("non-positive loop bound");
    _jump2943:;
    // Computing bound for l
    int64_t _1170;
    // Computing bound for k
    bool _1171 = true;
    int64_t _1172;
    if (!_1171)
    goto _jump2944;
    bool _1174 = false;
    bool _1173 = _1174;
    if (0 != _1174)
    goto _jump2945;
    bool _1175 = true;
    _1173 = _1175;
    _jump2945:;
    int64_t _1176;
    if (!_1173)
    goto _jump2946;
    _1176 = _692.d0;
    goto _jump2947;
    _jump2946:;
    _1176 = _692.d1;
    _jump2947:;
    _1172 = _1176;
    goto _jump2948;
    _jump2944:;
    int64_t _1177 = 742;
    _1172 = _1177;
    _jump2948:;
    if (_1172 > 0) 
    goto _jump2949;
    fail_assertion("non-positive loop bound");
    _jump2949:;
    _1170 = 0;
    int64_t _1178 = 0; // k
    _jump2950:; // Begin body of loop
    _1170 += _1178;
    _1178++;
    if (_1178 < _1172)
    goto _jump2950;
    // End body of loop
    if (_1170 > 0) 
    goto _jump2951;
    fail_assertion("non-positive loop bound");
    _jump2951:;
    // Computing bound for m
    bool _1180 = true;
    bool _1179 = _1180;
    if (0 != _1180)
    goto _jump2952;
    bool _1181 = true;
    _1179 = _1181;
    _jump2952:;
    int64_t _1182;
    if (!_1179)
    goto _jump2953;
    _1182 = _692.d1;
    goto _jump2954;
    _jump2953:;
    int64_t _1183;
    // Computing bound for k
    if (_692.d0 > 0) 
    goto _jump2955;
    fail_assertion("non-positive loop bound");
    _jump2955:;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump2956;
    fail_assertion("non-positive loop bound");
    _jump2956:;
    // Computing bound for m
    if (_692.d1 > 0) 
    goto _jump2957;
    fail_assertion("non-positive loop bound");
    _jump2957:;
    _1183 = 0;
    int64_t _1184 = 0; // m
    int64_t _1185 = 0; // l
    int64_t _1186 = 0; // k
    _jump2958:; // Begin body of loop
    _1183 += _1184;
    _1184++;
    if (_1184 < _692.d1)
    goto _jump2958;
    _1184 = 0;
    _1185++;
    if (_1185 < _692.d0)
    goto _jump2958;
    _1185 = 0;
    _1186++;
    if (_1186 < _692.d0)
    goto _jump2958;
    // End body of loop
    _1182 = _1183;
    _jump2954:;
    _a1_int64_t _1187;
    _1187.d0 = 2;
    _1187.data = jpl_alloc(sizeof(int64_t) * 2);
    _1187.data[0] = _692.d1;
    _1187.data[1] = _1182;
    int64_t _1188 = 553;
    bool _1189 = false;
    int64_t _1190;
    if (!_1189)
    goto _jump2959;
    _1190 = _692.d1;
    goto _jump2960;
    _jump2959:;
    _1190 = _692.d1;
    _jump2960:;
    int64_t _1191 = _692.d0 / _1190;
    int64_t _1192 = _1188 - _1191;
    if (_1192 >= 0)
    goto _jump2961;
    fail_assertion("negative array index");
    _jump2961:;
    if (_1192 < _1187.d0)
    goto _jump2962;
    fail_assertion("index too large");
    _jump2962:;
    int64_t _1193 = 0;
    _1193 *= _1187.d0;
    _1193 += _1192;
    int64_t _1194 = _1187.data[_1193];
    if (_1194 > 0) 
    goto _jump2963;
    fail_assertion("non-positive loop bound");
    _jump2963:;
    _1169 = 0;
    int64_t _1195 = 0; // m
    int64_t _1196 = 0; // l
    int64_t _1197 = 0; // k
    _jump2964:; // Begin body of loop
    _1169 += _692.d0;
    _1195++;
    if (_1195 < _1194)
    goto _jump2964;
    _1195 = 0;
    _1196++;
    if (_1196 < _1170)
    goto _jump2964;
    _1196 = 0;
    _1197++;
    if (_1197 < _692.d1)
    goto _jump2964;
    // End body of loop
    _1168.d0 = _1169;
    if (_1169 > 0) 
    goto _jump2965;
    fail_assertion("non-positive loop bound");
    _jump2965:;
    // Computing bound for l
    _1168.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2966;
    fail_assertion("non-positive loop bound");
    _jump2966:;
    // Computing total size of heap memory to allocate
    int64_t _1198 = 1;
    _1198 *= _1169;
    _1198 *= _692.d0;
    _1198 *= sizeof(rgba);
    _1168.data = jpl_alloc(_1198);
    int64_t _1199 = 0; // l
    int64_t _1200 = 0; // k
    _jump2967:; // Begin body of loop
    _a1_double _1201;
    _1201.d0 = 1;
    _1201.data = jpl_alloc(sizeof(double) * 1);
    _1201.data[0] = _487;
    int64_t _1202 = -_1200;
    if (_1202 >= 0)
    goto _jump2968;
    fail_assertion("negative array index");
    _jump2968:;
    if (_1202 < _1201.d0)
    goto _jump2969;
    fail_assertion("index too large");
    _jump2969:;
    int64_t _1203 = 0;
    _1203 *= _1201.d0;
    _1203 += _1202;
    double _1204 = _1201.data[_1203];
    bool _1205 = _487 != _1204;
    _a2_rgba _1206;
    if (!_1205)
    goto _jump2970;
    bool _1207 = _1200 <= _1199;
    bool _1208;
    if (!_1207)
    goto _jump2971;
    double _1209 = 8.0;
    double _1210 = 7.0;
    bool _1211 = _1209 <= _1210;
    _1208 = _1211;
    goto _jump2972;
    _jump2971:;
    bool _1212 = _692.d1 != _1199;
    _1208 = _1212;
    _jump2972:;
    _a2_rgba _1213;
    if (!_1208)
    goto _jump2973;
    _1213 = _692;
    goto _jump2974;
    _jump2973:;
    int64_t _1214 = 769;
    bool _1215 = _1214 == _692.d0;
    _a2_rgba _1216;
    if (!_1215)
    goto _jump2975;
    _1216 = _692;
    goto _jump2976;
    _jump2975:;
    _a2_rgba _1217;
    // Computing bound for m
    _1217.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2977;
    fail_assertion("non-positive loop bound");
    _jump2977:;
    // Computing bound for n
    _1217.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2978;
    fail_assertion("non-positive loop bound");
    _jump2978:;
    // Computing total size of heap memory to allocate
    int64_t _1218 = 1;
    _1218 *= _692.d0;
    _1218 *= _692.d0;
    _1218 *= sizeof(rgba);
    _1217.data = jpl_alloc(_1218);
    int64_t _1219 = 0; // n
    int64_t _1220 = 0; // m
    _jump2979:; // Begin body of loop
    rgba _1221 = j();
    int64_t _1222 = 0;
    _1222 *= _1217.d0;
    _1222 += _1220;
    _1222 *= _1217.d1;
    _1222 += _1219;
    _1217.data[_1222] = _1221;
    _1219++;
    if (_1219 < _692.d0)
    goto _jump2979;
    _1219 = 0;
    _1220++;
    if (_1220 < _692.d0)
    goto _jump2979;
    // End body of loop
    _1216 = _1217;
    _jump2976:;
    _1213 = _1216;
    _jump2974:;
    _1206 = _1213;
    goto _jump2980;
    _jump2970:;
    _a2_rgba _1223;
    // Computing bound for m
    _1223.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2981;
    fail_assertion("non-positive loop bound");
    _jump2981:;
    // Computing bound for n
    _1223.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump2982;
    fail_assertion("non-positive loop bound");
    _jump2982:;
    // Computing total size of heap memory to allocate
    int64_t _1224 = 1;
    _1224 *= _692.d0;
    _1224 *= _692.d0;
    _1224 *= sizeof(rgba);
    _1223.data = jpl_alloc(_1224);
    int64_t _1225 = 0; // n
    int64_t _1226 = 0; // m
    _jump2983:; // Begin body of loop
    rgba _1227 = j();
    int64_t _1228 = 0;
    _1228 *= _1223.d0;
    _1228 += _1226;
    _1228 *= _1223.d1;
    _1228 += _1225;
    _1223.data[_1228] = _1227;
    _1225++;
    if (_1225 < _692.d0)
    goto _jump2983;
    _1225 = 0;
    _1226++;
    if (_1226 < _692.d0)
    goto _jump2983;
    // End body of loop
    _1206 = _1223;
    _jump2980:;
    if (_692.d0 >= 0)
    goto _jump2984;
    fail_assertion("negative array index");
    _jump2984:;
    if (_692.d0 < _1206.d0)
    goto _jump2985;
    fail_assertion("index too large");
    _jump2985:;
    if (_1200 >= 0)
    goto _jump2986;
    fail_assertion("negative array index");
    _jump2986:;
    if (_1200 < _1206.d1)
    goto _jump2987;
    fail_assertion("index too large");
    _jump2987:;
    int64_t _1229 = 0;
    _1229 *= _1206.d0;
    _1229 += _692.d0;
    _1229 *= _1206.d1;
    _1229 += _1200;
    rgba _1230 = _1206.data[_1229];
    int64_t _1231 = 0;
    _1231 *= _1168.d0;
    _1231 += _1200;
    _1231 *= _1168.d1;
    _1231 += _1199;
    _1168.data[_1231] = _1230;
    _1199++;
    if (_1199 < _692.d0)
    goto _jump2967;
    _1199 = 0;
    _1200++;
    if (_1200 < _1169)
    goto _jump2967;
    // End body of loop
    _1055 = _1168;
    _jump2942:;
    write_image(_1055, "k.png");
    bool _1234 = true;
    bool _1233 = _1234;
    if (0 == _1234)
    goto _jump2988;
    double _1235 = 95.0;
    double _1236 = 71.0;
    rgba _1237 = { _1235, _487, _1236, _693 };
    double _1238 = _1237.b;
    rgba _1239 = j();
    double _1240 = _1239.g;
    double _1241 = -_1240;
    bool _1242 = _1238 != _1241;
    _1233 = _1242;
    _jump2988:;
    bool _1243;
    if (!_1233)
    goto _jump2989;
    bool _1244 = true;
    _1243 = _1244;
    goto _jump2990;
    _jump2989:;
    double _1245 = 47.0;
    double _1246 = -_1245;
    double _1247 = 71.0;
    double _1248 = fmod(_693, _1247);
    bool _1249 = _1246 <= _1248;
    bool _1250;
    if (!_1249)
    goto _jump2991;
    int64_t _1251 = _692.d1 - _692.d0;
    bool _1252 = _1251 > _692.d0;
    _1250 = _1252;
    goto _jump2992;
    _jump2991:;
    double _1253 = 35.0;
    bool _1254 = _487 < _1253;
    _1250 = _1254;
    _jump2992:;
    bool _1255;
    if (!_1250)
    goto _jump2993;
    bool _1256 = true;
    bool _1257 = !_1256;
    bool _1258;
    if (!_1257)
    goto _jump2994;
    bool _1259 = _693 != _693;
    _1258 = _1259;
    goto _jump2995;
    _jump2994:;
    bool _1260 = true;
    _1258 = _1260;
    _jump2995:;
    bool _1261;
    if (!_1258)
    goto _jump2996;
    bool _1262 = true;
    _1261 = _1262;
    goto _jump2997;
    _jump2996:;
    bool _1263 = true;
    _1261 = _1263;
    _jump2997:;
    _1255 = _1261;
    goto _jump2998;
    _jump2993:;
    int64_t _1264;
    // Computing bound for k
    int64_t _1265 = 99;
    if (_1265 > 0) 
    goto _jump2999;
    fail_assertion("non-positive loop bound");
    _jump2999:;
    // Computing bound for l
    if (_692.d0 > 0) 
    goto _jump3000;
    fail_assertion("non-positive loop bound");
    _jump3000:;
    _1264 = 0;
    int64_t _1266 = 0; // l
    int64_t _1267 = 0; // k
    _jump3001:; // Begin body of loop
    _1264 += _1266;
    _1266++;
    if (_1266 < _692.d0)
    goto _jump3001;
    _1266 = 0;
    _1267++;
    if (_1267 < _1265)
    goto _jump3001;
    // End body of loop
    int64_t _1268 = _692.d0 * _1264;
    bool _1269 = _1268 == _692.d1;
    _1255 = _1269;
    _jump2998:;
    _1243 = _1255;
    _jump2990:;
    bool _1232 = _1243;
    if (0 == _1243)
    goto _jump3002;
    bool _1270 = _693 == _693;
    _1232 = _1270;
    _jump3002:;
    _a2_rgba _1271;
    if (!_1232)
    goto _jump3003;
    _a3__a2_rgba _1272;
    // Computing bound for k
    _a2__a1_int64_t _1273;
    // Computing bound for k
    int64_t _1274 = -_692.d0;
    _1273.d0 = _1274;
    if (_1274 > 0) 
    goto _jump3004;
    fail_assertion("non-positive loop bound");
    _jump3004:;
    // Computing bound for l
    _1273.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3005;
    fail_assertion("non-positive loop bound");
    _jump3005:;
    // Computing total size of heap memory to allocate
    int64_t _1275 = 1;
    _1275 *= _1274;
    _1275 *= _692.d0;
    _1275 *= sizeof(_a1_int64_t);
    _1273.data = jpl_alloc(_1275);
    int64_t _1276 = 0; // l
    int64_t _1277 = 0; // k
    _jump3006:; // Begin body of loop
    _a1_int64_t _1278;
    _1278.d0 = 3;
    _1278.data = jpl_alloc(sizeof(int64_t) * 3);
    _1278.data[0] = _1276;
    _1278.data[1] = _1276;
    _1278.data[2] = _692.d0;
    int64_t _1279 = 0;
    _1279 *= _1273.d0;
    _1279 += _1277;
    _1279 *= _1273.d1;
    _1279 += _1276;
    _1273.data[_1279] = _1278;
    _1276++;
    if (_1276 < _692.d0)
    goto _jump3006;
    _1276 = 0;
    _1277++;
    if (_1277 < _1274)
    goto _jump3006;
    // End body of loop
    bool _1280 = _487 > _693;
    int64_t _1281;
    if (!_1280)
    goto _jump3007;
    int64_t _1282 = 957;
    _1281 = _1282;
    goto _jump3008;
    _jump3007:;
    _1281 = _692.d0;
    _jump3008:;
    int64_t _1283 = -_692.d0;
    if (_1281 >= 0)
    goto _jump3009;
    fail_assertion("negative array index");
    _jump3009:;
    if (_1281 < _1273.d0)
    goto _jump3010;
    fail_assertion("index too large");
    _jump3010:;
    if (_1283 >= 0)
    goto _jump3011;
    fail_assertion("negative array index");
    _jump3011:;
    if (_1283 < _1273.d1)
    goto _jump3012;
    fail_assertion("index too large");
    _jump3012:;
    int64_t _1284 = 0;
    _1284 *= _1273.d0;
    _1284 += _1281;
    _1284 *= _1273.d1;
    _1284 += _1283;
    _a1_int64_t _1285 = _1273.data[_1284];
    if (_692.d1 >= 0)
    goto _jump3013;
    fail_assertion("negative array index");
    _jump3013:;
    if (_692.d1 < _1285.d0)
    goto _jump3014;
    fail_assertion("index too large");
    _jump3014:;
    int64_t _1286 = 0;
    _1286 *= _1285.d0;
    _1286 += _692.d1;
    int64_t _1287 = _1285.data[_1286];
    _1272.d0 = _1287;
    if (_1287 > 0) 
    goto _jump3015;
    fail_assertion("non-positive loop bound");
    _jump3015:;
    // Computing bound for l
    int64_t _1288;
    // Computing bound for k
    int64_t _1289 = 949;
    if (_1289 > 0) 
    goto _jump3016;
    fail_assertion("non-positive loop bound");
    _jump3016:;
    // Computing bound for l
    if (_692.d1 > 0) 
    goto _jump3017;
    fail_assertion("non-positive loop bound");
    _jump3017:;
    // Computing bound for m
    if (_692.d0 > 0) 
    goto _jump3018;
    fail_assertion("non-positive loop bound");
    _jump3018:;
    _1288 = 0;
    int64_t _1290 = 0; // m
    int64_t _1291 = 0; // l
    int64_t _1292 = 0; // k
    _jump3019:; // Begin body of loop
    int64_t _1293;
    // Computing bound for n
    if (_1291 > 0) 
    goto _jump3020;
    fail_assertion("non-positive loop bound");
    _jump3020:;
    // Computing bound for o
    int64_t _1294 = 231;
    if (_1294 > 0) 
    goto _jump3021;
    fail_assertion("non-positive loop bound");
    _jump3021:;
    // Computing bound for p
    if (_1290 > 0) 
    goto _jump3022;
    fail_assertion("non-positive loop bound");
    _jump3022:;
    _1293 = 0;
    int64_t _1295 = 0; // p
    int64_t _1296 = 0; // o
    int64_t _1297 = 0; // n
    _jump3023:; // Begin body of loop
    _1293 += _1297;
    _1295++;
    if (_1295 < _1290)
    goto _jump3023;
    _1295 = 0;
    _1296++;
    if (_1296 < _1294)
    goto _jump3023;
    _1296 = 0;
    _1297++;
    if (_1297 < _1291)
    goto _jump3023;
    // End body of loop
    _1288 += _1293;
    _1290++;
    if (_1290 < _692.d0)
    goto _jump3019;
    _1290 = 0;
    _1291++;
    if (_1291 < _692.d1)
    goto _jump3019;
    _1291 = 0;
    _1292++;
    if (_1292 < _1289)
    goto _jump3019;
    // End body of loop
    int64_t _1298 = -_1288;
    _1272.d1 = _1298;
    if (_1298 > 0) 
    goto _jump3024;
    fail_assertion("non-positive loop bound");
    _jump3024:;
    // Computing bound for m
    bool _1300 = false;
    bool _1299 = _1300;
    if (0 == _1300)
    goto _jump3025;
    bool _1301 = false;
    bool _1302 = !_1301;
    _1299 = _1302;
    _jump3025:;
    bool _1303 = !_1299;
    int64_t _1304;
    if (!_1303)
    goto _jump3026;
    int64_t _1305 = 243;
    int64_t _1306 = -_1305;
    _1304 = _1306;
    goto _jump3027;
    _jump3026:;
    double _1307 = -_487;
    rgba _1308 = j();
    double _1309 = a(_1308);
    bool _1310 = _1307 == _1309;
    int64_t _1311;
    if (!_1310)
    goto _jump3028;
    int64_t _1312 = -_692.d1;
    int64_t _1313 = -_1312;
    _1311 = _1313;
    goto _jump3029;
    _jump3028:;
    int64_t _1314 = 813;
    _1311 = _1314;
    _jump3029:;
    _1304 = _1311;
    _jump3027:;
    _1272.d2 = _1304;
    if (_1304 > 0) 
    goto _jump3030;
    fail_assertion("non-positive loop bound");
    _jump3030:;
    // Computing total size of heap memory to allocate
    int64_t _1315 = 1;
    _1315 *= _1287;
    _1315 *= _1298;
    _1315 *= _1304;
    _1315 *= sizeof(_a2_rgba);
    _1272.data = jpl_alloc(_1315);
    int64_t _1316 = 0; // m
    int64_t _1317 = 0; // l
    int64_t _1318 = 0; // k
    _jump3031:; // Begin body of loop
    _a2__a3__a2_rgba _1319;
    // Computing bound for n
    _1319.d0 = _1317;
    if (_1317 > 0) 
    goto _jump3032;
    fail_assertion("non-positive loop bound");
    _jump3032:;
    // Computing bound for o
    _1319.d1 = _1316;
    if (_1316 > 0) 
    goto _jump3033;
    fail_assertion("non-positive loop bound");
    _jump3033:;
    // Computing total size of heap memory to allocate
    int64_t _1320 = 1;
    _1320 *= _1317;
    _1320 *= _1316;
    _1320 *= sizeof(_a3__a2_rgba);
    _1319.data = jpl_alloc(_1320);
    int64_t _1321 = 0; // o
    int64_t _1322 = 0; // n
    _jump3034:; // Begin body of loop
    _a3__a2_rgba _1323;
    // Computing bound for p
    _1323.d0 = _1316;
    if (_1316 > 0) 
    goto _jump3035;
    fail_assertion("non-positive loop bound");
    _jump3035:;
    // Computing bound for q
    _1323.d1 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3036;
    fail_assertion("non-positive loop bound");
    _jump3036:;
    // Computing bound for r
    _1323.d2 = _1317;
    if (_1317 > 0) 
    goto _jump3037;
    fail_assertion("non-positive loop bound");
    _jump3037:;
    // Computing total size of heap memory to allocate
    int64_t _1324 = 1;
    _1324 *= _1316;
    _1324 *= _692.d1;
    _1324 *= _1317;
    _1324 *= sizeof(_a2_rgba);
    _1323.data = jpl_alloc(_1324);
    int64_t _1325 = 0; // r
    int64_t _1326 = 0; // q
    int64_t _1327 = 0; // p
    _jump3038:; // Begin body of loop
    int64_t _1328 = 0;
    _1328 *= _1323.d0;
    _1328 += _1327;
    _1328 *= _1323.d1;
    _1328 += _1326;
    _1328 *= _1323.d2;
    _1328 += _1325;
    _1323.data[_1328] = _692;
    _1325++;
    if (_1325 < _1317)
    goto _jump3038;
    _1325 = 0;
    _1326++;
    if (_1326 < _692.d1)
    goto _jump3038;
    _1326 = 0;
    _1327++;
    if (_1327 < _1316)
    goto _jump3038;
    // End body of loop
    int64_t _1329 = 0;
    _1329 *= _1319.d0;
    _1329 += _1322;
    _1329 *= _1319.d1;
    _1329 += _1321;
    _1319.data[_1329] = _1323;
    _1321++;
    if (_1321 < _1316)
    goto _jump3034;
    _1321 = 0;
    _1322++;
    if (_1322 < _1317)
    goto _jump3034;
    // End body of loop
    _a2_int64_t _1330;
    // Computing bound for n
    _1330.d0 = _1318;
    if (_1318 > 0) 
    goto _jump3039;
    fail_assertion("non-positive loop bound");
    _jump3039:;
    // Computing bound for o
    _1330.d1 = _1317;
    if (_1317 > 0) 
    goto _jump3040;
    fail_assertion("non-positive loop bound");
    _jump3040:;
    // Computing total size of heap memory to allocate
    int64_t _1331 = 1;
    _1331 *= _1318;
    _1331 *= _1317;
    _1331 *= sizeof(int64_t);
    _1330.data = jpl_alloc(_1331);
    int64_t _1332 = 0; // o
    int64_t _1333 = 0; // n
    _jump3041:; // Begin body of loop
    int64_t _1334 = 0;
    _1334 *= _1330.d0;
    _1334 += _1333;
    _1334 *= _1330.d1;
    _1334 += _1332;
    _1330.data[_1334] = _1317;
    _1332++;
    if (_1332 < _1317)
    goto _jump3041;
    _1332 = 0;
    _1333++;
    if (_1333 < _1318)
    goto _jump3041;
    // End body of loop
    int64_t _1335;
    // Computing bound for n
    int64_t _1336 = 705;
    if (_1336 > 0) 
    goto _jump3042;
    fail_assertion("non-positive loop bound");
    _jump3042:;
    _1335 = 0;
    int64_t _1337 = 0; // n
    _jump3043:; // Begin body of loop
    _1335 += _1316;
    _1337++;
    if (_1337 < _1336)
    goto _jump3043;
    // End body of loop
    if (_1335 >= 0)
    goto _jump3044;
    fail_assertion("negative array index");
    _jump3044:;
    if (_1335 < _1330.d0)
    goto _jump3045;
    fail_assertion("index too large");
    _jump3045:;
    if (_1316 >= 0)
    goto _jump3046;
    fail_assertion("negative array index");
    _jump3046:;
    if (_1316 < _1330.d1)
    goto _jump3047;
    fail_assertion("index too large");
    _jump3047:;
    int64_t _1338 = 0;
    _1338 *= _1330.d0;
    _1338 += _1335;
    _1338 *= _1330.d1;
    _1338 += _1316;
    int64_t _1339 = _1330.data[_1338];
    if (_1317 >= 0)
    goto _jump3048;
    fail_assertion("negative array index");
    _jump3048:;
    if (_1317 < _1319.d0)
    goto _jump3049;
    fail_assertion("index too large");
    _jump3049:;
    if (_1339 >= 0)
    goto _jump3050;
    fail_assertion("negative array index");
    _jump3050:;
    if (_1339 < _1319.d1)
    goto _jump3051;
    fail_assertion("index too large");
    _jump3051:;
    int64_t _1340 = 0;
    _1340 *= _1319.d0;
    _1340 += _1317;
    _1340 *= _1319.d1;
    _1340 += _1339;
    _a3__a2_rgba _1341 = _1319.data[_1340];
    int64_t _1342 = 91;
    _a1_int64_t _1343;
    _1343.d0 = 2;
    _1343.data = jpl_alloc(sizeof(int64_t) * 2);
    _1343.data[0] = _1317;
    _1343.data[1] = _692.d0;
    if (_1317 >= 0)
    goto _jump3052;
    fail_assertion("negative array index");
    _jump3052:;
    if (_1317 < _1343.d0)
    goto _jump3053;
    fail_assertion("index too large");
    _jump3053:;
    int64_t _1344 = 0;
    _1344 *= _1343.d0;
    _1344 += _1317;
    int64_t _1345 = _1343.data[_1344];
    int64_t _1346 = -_1318;
    if (_1342 >= 0)
    goto _jump3054;
    fail_assertion("negative array index");
    _jump3054:;
    if (_1342 < _1341.d0)
    goto _jump3055;
    fail_assertion("index too large");
    _jump3055:;
    if (_1345 >= 0)
    goto _jump3056;
    fail_assertion("negative array index");
    _jump3056:;
    if (_1345 < _1341.d1)
    goto _jump3057;
    fail_assertion("index too large");
    _jump3057:;
    if (_1346 >= 0)
    goto _jump3058;
    fail_assertion("negative array index");
    _jump3058:;
    if (_1346 < _1341.d2)
    goto _jump3059;
    fail_assertion("index too large");
    _jump3059:;
    int64_t _1347 = 0;
    _1347 *= _1341.d0;
    _1347 += _1342;
    _1347 *= _1341.d1;
    _1347 += _1345;
    _1347 *= _1341.d2;
    _1347 += _1346;
    _a2_rgba _1348 = _1341.data[_1347];
    int64_t _1349 = 0;
    _1349 *= _1272.d0;
    _1349 += _1318;
    _1349 *= _1272.d1;
    _1349 += _1317;
    _1349 *= _1272.d2;
    _1349 += _1316;
    _1272.data[_1349] = _1348;
    _1316++;
    if (_1316 < _1304)
    goto _jump3031;
    _1316 = 0;
    _1317++;
    if (_1317 < _1298)
    goto _jump3031;
    _1317 = 0;
    _1318++;
    if (_1318 < _1287)
    goto _jump3031;
    // End body of loop
    _a2_bool _1350;
    // Computing bound for k
    _1350.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3060;
    fail_assertion("non-positive loop bound");
    _jump3060:;
    // Computing bound for l
    int64_t _1351 = 955;
    _a1_int64_t _1352;
    _1352.d0 = 2;
    _1352.data = jpl_alloc(sizeof(int64_t) * 2);
    _1352.data[0] = _1351;
    _1352.data[1] = _692.d0;
    int64_t _1353;
    // Computing bound for k
    if (_692.d0 > 0) 
    goto _jump3061;
    fail_assertion("non-positive loop bound");
    _jump3061:;
    // Computing bound for l
    int64_t _1354 = 396;
    if (_1354 > 0) 
    goto _jump3062;
    fail_assertion("non-positive loop bound");
    _jump3062:;
    // Computing bound for m
    if (_692.d0 > 0) 
    goto _jump3063;
    fail_assertion("non-positive loop bound");
    _jump3063:;
    _1353 = 0;
    int64_t _1355 = 0; // m
    int64_t _1356 = 0; // l
    int64_t _1357 = 0; // k
    _jump3064:; // Begin body of loop
    _1353 += _1356;
    _1355++;
    if (_1355 < _692.d0)
    goto _jump3064;
    _1355 = 0;
    _1356++;
    if (_1356 < _1354)
    goto _jump3064;
    _1356 = 0;
    _1357++;
    if (_1357 < _692.d0)
    goto _jump3064;
    // End body of loop
    if (_1353 >= 0)
    goto _jump3065;
    fail_assertion("negative array index");
    _jump3065:;
    if (_1353 < _1352.d0)
    goto _jump3066;
    fail_assertion("index too large");
    _jump3066:;
    int64_t _1358 = 0;
    _1358 *= _1352.d0;
    _1358 += _1353;
    int64_t _1359 = _1352.data[_1358];
    _1350.d1 = _1359;
    if (_1359 > 0) 
    goto _jump3067;
    fail_assertion("non-positive loop bound");
    _jump3067:;
    // Computing total size of heap memory to allocate
    int64_t _1360 = 1;
    _1360 *= _692.d1;
    _1360 *= _1359;
    _1360 *= sizeof(bool);
    _1350.data = jpl_alloc(_1360);
    int64_t _1361 = 0; // l
    int64_t _1362 = 0; // k
    _jump3068:; // Begin body of loop
    double _1363 = 85.0;
    double _1364 = _1363 * _487;
    bool _1365 = _487 < _1364;
    int64_t _1366 = 0;
    _1366 *= _1350.d0;
    _1366 += _1362;
    _1366 *= _1350.d1;
    _1366 += _1361;
    _1350.data[_1366] = _1365;
    _1361++;
    if (_1361 < _1359)
    goto _jump3068;
    _1361 = 0;
    _1362++;
    if (_1362 < _692.d1)
    goto _jump3068;
    // End body of loop
    int64_t _1367 = 798;
    int64_t _1368 = _692.d0 % _1367;
    int64_t _1369;
    // Computing bound for k
    int64_t _1370 = 945;
    if (_1370 > 0) 
    goto _jump3069;
    fail_assertion("non-positive loop bound");
    _jump3069:;
    _1369 = 0;
    int64_t _1371 = 0; // k
    _jump3070:; // Begin body of loop
    int64_t _1372 = 887;
    _1369 += _1372;
    _1371++;
    if (_1371 < _1370)
    goto _jump3070;
    // End body of loop
    int64_t _1373 = _1368 - _1369;
    int64_t _1374 = _1373 % _692.d1;
    int64_t _1375 = 805;
    if (_1374 >= 0)
    goto _jump3071;
    fail_assertion("negative array index");
    _jump3071:;
    if (_1374 < _1350.d0)
    goto _jump3072;
    fail_assertion("index too large");
    _jump3072:;
    if (_1375 >= 0)
    goto _jump3073;
    fail_assertion("negative array index");
    _jump3073:;
    if (_1375 < _1350.d1)
    goto _jump3074;
    fail_assertion("index too large");
    _jump3074:;
    int64_t _1376 = 0;
    _1376 *= _1350.d0;
    _1376 += _1374;
    _1376 *= _1350.d1;
    _1376 += _1375;
    bool _1377 = _1350.data[_1376];
    int64_t _1378;
    if (!_1377)
    goto _jump3075;
    int64_t _1379 = -_692.d1;
    int64_t _1380 = -_1379;
    int64_t _1381 = -_1380;
    _1378 = _1381;
    goto _jump3076;
    _jump3075:;
    int64_t _1382 = 949;
    int64_t _1383 = -_1382;
    int64_t _1384 = -_1383;
    int64_t _1385 = -_1384;
    int64_t _1386 = -_1385;
    _1378 = _1386;
    _jump3076:;
    int64_t _1387;
    // Computing bound for k
    int64_t _1388 = 196;
    if (_1388 > 0) 
    goto _jump3077;
    fail_assertion("non-positive loop bound");
    _jump3077:;
    // Computing bound for l
    int64_t _1389 = 741;
    int64_t _1390 = _1389 % _692.d0;
    if (_1390 > 0) 
    goto _jump3078;
    fail_assertion("non-positive loop bound");
    _jump3078:;
    _1387 = 0;
    int64_t _1391 = 0; // l
    int64_t _1392 = 0; // k
    _jump3079:; // Begin body of loop
    _a2__a1_int64_t _1393;
    // Computing bound for m
    _1393.d0 = _1392;
    if (_1392 > 0) 
    goto _jump3080;
    fail_assertion("non-positive loop bound");
    _jump3080:;
    // Computing bound for n
    int64_t _1394 = _1391 * _1391;
    _1393.d1 = _1394;
    if (_1394 > 0) 
    goto _jump3081;
    fail_assertion("non-positive loop bound");
    _jump3081:;
    // Computing total size of heap memory to allocate
    int64_t _1395 = 1;
    _1395 *= _1392;
    _1395 *= _1394;
    _1395 *= sizeof(_a1_int64_t);
    _1393.data = jpl_alloc(_1395);
    int64_t _1396 = 0; // n
    int64_t _1397 = 0; // m
    _jump3082:; // Begin body of loop
    _a1_int64_t _1398;
    // Computing bound for o
    _1398.d0 = _1392;
    if (_1392 > 0) 
    goto _jump3083;
    fail_assertion("non-positive loop bound");
    _jump3083:;
    // Computing total size of heap memory to allocate
    int64_t _1399 = 1;
    _1399 *= _1392;
    _1399 *= sizeof(int64_t);
    _1398.data = jpl_alloc(_1399);
    int64_t _1400 = 0; // o
    _jump3084:; // Begin body of loop
    int64_t _1401 = 0;
    _1401 *= _1398.d0;
    _1401 += _1400;
    _1398.data[_1401] = _692.d1;
    _1400++;
    if (_1400 < _1392)
    goto _jump3084;
    // End body of loop
    int64_t _1402 = 0;
    _1402 *= _1393.d0;
    _1402 += _1397;
    _1402 *= _1393.d1;
    _1402 += _1396;
    _1393.data[_1402] = _1398;
    _1396++;
    if (_1396 < _1394)
    goto _jump3082;
    _1396 = 0;
    _1397++;
    if (_1397 < _1392)
    goto _jump3082;
    // End body of loop
    _a1_rgba _1403;
    // Computing bound for m
    _1403.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3085;
    fail_assertion("non-positive loop bound");
    _jump3085:;
    // Computing total size of heap memory to allocate
    int64_t _1404 = 1;
    _1404 *= _692.d0;
    _1404 *= sizeof(rgba);
    _1403.data = jpl_alloc(_1404);
    int64_t _1405 = 0; // m
    _jump3086:; // Begin body of loop
    rgba _1406 = j();
    int64_t _1407 = 0;
    _1407 *= _1403.d0;
    _1407 += _1405;
    _1403.data[_1407] = _1406;
    _1405++;
    if (_1405 < _692.d0)
    goto _jump3086;
    // End body of loop
    _a1_int64_t _1408;
    _1408.d0 = 2;
    _1408.data = jpl_alloc(sizeof(int64_t) * 2);
    _1408.data[0] = _692.d0;
    _1408.data[1] = _692.d0;
    void_t _1409 = b(_1403, _1408);
    _a1_int64_t _1410 = c(_1393, _1409);
    if (_692.d0 >= 0)
    goto _jump3087;
    fail_assertion("negative array index");
    _jump3087:;
    if (_692.d0 < _1410.d0)
    goto _jump3088;
    fail_assertion("index too large");
    _jump3088:;
    int64_t _1411 = 0;
    _1411 *= _1410.d0;
    _1411 += _692.d0;
    int64_t _1412 = _1410.data[_1411];
    _1387 += _1412;
    _1391++;
    if (_1391 < _1390)
    goto _jump3079;
    _1391 = 0;
    _1392++;
    if (_1392 < _1388)
    goto _jump3079;
    // End body of loop
    if (_1378 >= 0)
    goto _jump3089;
    fail_assertion("negative array index");
    _jump3089:;
    if (_1378 < _1272.d0)
    goto _jump3090;
    fail_assertion("index too large");
    _jump3090:;
    if (_1387 >= 0)
    goto _jump3091;
    fail_assertion("negative array index");
    _jump3091:;
    if (_1387 < _1272.d1)
    goto _jump3092;
    fail_assertion("index too large");
    _jump3092:;
    if (_692.d1 >= 0)
    goto _jump3093;
    fail_assertion("negative array index");
    _jump3093:;
    if (_692.d1 < _1272.d2)
    goto _jump3094;
    fail_assertion("index too large");
    _jump3094:;
    int64_t _1413 = 0;
    _1413 *= _1272.d0;
    _1413 += _1378;
    _1413 *= _1272.d1;
    _1413 += _1387;
    _1413 *= _1272.d2;
    _1413 += _692.d1;
    _a2_rgba _1414 = _1272.data[_1413];
    _1271 = _1414;
    goto _jump3095;
    _jump3003:;
    _a2_rgba _1415;
    // Computing bound for k
    _1415.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3096;
    fail_assertion("non-positive loop bound");
    _jump3096:;
    // Computing bound for l
    double _1416;
    // Computing bound for k
    int64_t _1417 = 481;
    int64_t _1418 = _1417 % _692.d1;
    if (_1418 > 0) 
    goto _jump3097;
    fail_assertion("non-positive loop bound");
    _jump3097:;
    // Computing bound for l
    int64_t _1419 = 32;
    int64_t _1420 = -_1419;
    if (_1420 > 0) 
    goto _jump3098;
    fail_assertion("non-positive loop bound");
    _jump3098:;
    _1416 = 0;
    int64_t _1421 = 0; // l
    int64_t _1422 = 0; // k
    _jump3099:; // Begin body of loop
    double _1423 = 7.0;
    _1416 += _1423;
    _1421++;
    if (_1421 < _1420)
    goto _jump3099;
    _1421 = 0;
    _1422++;
    if (_1422 < _1418)
    goto _jump3099;
    // End body of loop
    bool _1424 = _1416 > _693;
    _a1_bool _1425;
    // Computing bound for k
    int64_t _1426 = -_692.d0;
    _1425.d0 = _1426;
    if (_1426 > 0) 
    goto _jump3100;
    fail_assertion("non-positive loop bound");
    _jump3100:;
    // Computing total size of heap memory to allocate
    int64_t _1427 = 1;
    _1427 *= _1426;
    _1427 *= sizeof(bool);
    _1425.data = jpl_alloc(_1427);
    int64_t _1428 = 0; // k
    _jump3101:; // Begin body of loop
    bool _1429 = true;
    int64_t _1430 = 0;
    _1430 *= _1425.d0;
    _1430 += _1428;
    _1425.data[_1430] = _1429;
    _1428++;
    if (_1428 < _1426)
    goto _jump3101;
    // End body of loop
    int64_t _1431 = -_692.d1;
    int64_t _1432 = _692.d0 / _1431;
    if (_1432 >= 0)
    goto _jump3102;
    fail_assertion("negative array index");
    _jump3102:;
    if (_1432 < _1425.d0)
    goto _jump3103;
    fail_assertion("index too large");
    _jump3103:;
    int64_t _1433 = 0;
    _1433 *= _1425.d0;
    _1433 += _1432;
    bool _1434 = _1425.data[_1433];
    bool _1435 = _1424 == _1434;
    int64_t _1436;
    if (!_1435)
    goto _jump3104;
    int64_t _1437;
    // Computing bound for k
    int64_t _1438 = -_692.d1;
    if (_1438 > 0) 
    goto _jump3105;
    fail_assertion("non-positive loop bound");
    _jump3105:;
    // Computing bound for l
    int64_t _1439;
    // Computing bound for k
    if (_692.d0 > 0) 
    goto _jump3106;
    fail_assertion("non-positive loop bound");
    _jump3106:;
    _1439 = 0;
    int64_t _1440 = 0; // k
    _jump3107:; // Begin body of loop
    _1439 += _692.d0;
    _1440++;
    if (_1440 < _692.d0)
    goto _jump3107;
    // End body of loop
    int64_t _1441 = _1439 - _692.d1;
    if (_1441 > 0) 
    goto _jump3108;
    fail_assertion("non-positive loop bound");
    _jump3108:;
    // Computing bound for m
    bool _1442 = false;
    int64_t _1443;
    if (!_1442)
    goto _jump3109;
    _1443 = _692.d1;
    goto _jump3110;
    _jump3109:;
    bool _1444 = false;
    bool _1445 = !_1444;
    int64_t _1446;
    if (!_1445)
    goto _jump3111;
    int64_t _1447;
    // Computing bound for k
    int64_t _1448 = 489;
    if (_1448 > 0) 
    goto _jump3112;
    fail_assertion("non-positive loop bound");
    _jump3112:;
    // Computing bound for l
    int64_t _1449 = 399;
    if (_1449 > 0) 
    goto _jump3113;
    fail_assertion("non-positive loop bound");
    _jump3113:;
    _1447 = 0;
    int64_t _1450 = 0; // l
    int64_t _1451 = 0; // k
    _jump3114:; // Begin body of loop
    _1447 += _1450;
    _1450++;
    if (_1450 < _1449)
    goto _jump3114;
    _1450 = 0;
    _1451++;
    if (_1451 < _1448)
    goto _jump3114;
    // End body of loop
    _1446 = _1447;
    goto _jump3115;
    _jump3111:;
    int64_t _1452 = 210;
    _1446 = _1452;
    _jump3115:;
    _1443 = _1446;
    _jump3110:;
    if (_1443 > 0) 
    goto _jump3116;
    fail_assertion("non-positive loop bound");
    _jump3116:;
    _1437 = 0;
    int64_t _1453 = 0; // m
    int64_t _1454 = 0; // l
    int64_t _1455 = 0; // k
    _jump3117:; // Begin body of loop
    int64_t _1456 = 806;
    int64_t _1457 = -_692.d1;
    int64_t _1458 = _1456 % _1457;
    _1437 += _1458;
    _1453++;
    if (_1453 < _1443)
    goto _jump3117;
    _1453 = 0;
    _1454++;
    if (_1454 < _1441)
    goto _jump3117;
    _1454 = 0;
    _1455++;
    if (_1455 < _1438)
    goto _jump3117;
    // End body of loop
    _1436 = _1437;
    goto _jump3118;
    _jump3104:;
    _1436 = _692.d1;
    _jump3118:;
    _1415.d1 = _1436;
    if (_1436 > 0) 
    goto _jump3119;
    fail_assertion("non-positive loop bound");
    _jump3119:;
    // Computing total size of heap memory to allocate
    int64_t _1459 = 1;
    _1459 *= _692.d0;
    _1459 *= _1436;
    _1459 *= sizeof(rgba);
    _1415.data = jpl_alloc(_1459);
    int64_t _1460 = 0; // l
    int64_t _1461 = 0; // k
    _jump3120:; // Begin body of loop
    bool _1464 = _692.d0 == _692.d1;
    bool _1463 = _1464;
    if (0 != _1464)
    goto _jump3121;
    bool _1465 = false;
    _1463 = _1465;
    _jump3121:;
    bool _1462 = _1463;
    if (0 != _1463)
    goto _jump3122;
    bool _1466 = true;
    _1462 = _1466;
    _jump3122:;
    _a2_rgba _1467;
    if (!_1462)
    goto _jump3123;
    _a2_rgba _1468;
    // Computing bound for m
    bool _1469 = false;
    int64_t _1470;
    if (!_1469)
    goto _jump3124;
    _1470 = _1461;
    goto _jump3125;
    _jump3124:;
    _1470 = _692.d1;
    _jump3125:;
    int64_t _1471 = -_1470;
    _1468.d0 = _1471;
    if (_1471 > 0) 
    goto _jump3126;
    fail_assertion("non-positive loop bound");
    _jump3126:;
    // Computing bound for n
    int64_t _1472 = -_1460;
    _1468.d1 = _1472;
    if (_1472 > 0) 
    goto _jump3127;
    fail_assertion("non-positive loop bound");
    _jump3127:;
    // Computing total size of heap memory to allocate
    int64_t _1473 = 1;
    _1473 *= _1471;
    _1473 *= _1472;
    _1473 *= sizeof(rgba);
    _1468.data = jpl_alloc(_1473);
    int64_t _1474 = 0; // n
    int64_t _1475 = 0; // m
    _jump3128:; // Begin body of loop
    rgba _1476 = j();
    int64_t _1477 = 0;
    _1477 *= _1468.d0;
    _1477 += _1475;
    _1477 *= _1468.d1;
    _1477 += _1474;
    _1468.data[_1477] = _1476;
    _1474++;
    if (_1474 < _1472)
    goto _jump3128;
    _1474 = 0;
    _1475++;
    if (_1475 < _1471)
    goto _jump3128;
    // End body of loop
    _1467 = _1468;
    goto _jump3129;
    _jump3123:;
    _a2_rgba _1478;
    // Computing bound for m
    _1478.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3130;
    fail_assertion("non-positive loop bound");
    _jump3130:;
    // Computing bound for n
    _1478.d1 = _1460;
    if (_1460 > 0) 
    goto _jump3131;
    fail_assertion("non-positive loop bound");
    _jump3131:;
    // Computing total size of heap memory to allocate
    int64_t _1479 = 1;
    _1479 *= _692.d1;
    _1479 *= _1460;
    _1479 *= sizeof(rgba);
    _1478.data = jpl_alloc(_1479);
    int64_t _1480 = 0; // n
    int64_t _1481 = 0; // m
    _jump3132:; // Begin body of loop
    bool _1482 = _692.d1 >= _692.d0;
    rgba _1483;
    if (!_1482)
    goto _jump3133;
    bool _1484 = true;
    rgba _1485;
    if (!_1484)
    goto _jump3134;
    rgba _1486 = j();
    _1485 = _1486;
    goto _jump3135;
    _jump3134:;
    rgba _1487 = j();
    _1485 = _1487;
    _jump3135:;
    _1483 = _1485;
    goto _jump3136;
    _jump3133:;
    rgba _1488 = j();
    _1483 = _1488;
    _jump3136:;
    int64_t _1489 = 0;
    _1489 *= _1478.d0;
    _1489 += _1481;
    _1489 *= _1478.d1;
    _1489 += _1480;
    _1478.data[_1489] = _1483;
    _1480++;
    if (_1480 < _1460)
    goto _jump3132;
    _1480 = 0;
    _1481++;
    if (_1481 < _692.d1)
    goto _jump3132;
    // End body of loop
    _1467 = _1478;
    _jump3129:;
    int64_t _1490 = 959;
    int64_t _1491 = 510;
    if (_1490 >= 0)
    goto _jump3137;
    fail_assertion("negative array index");
    _jump3137:;
    if (_1490 < _1467.d0)
    goto _jump3138;
    fail_assertion("index too large");
    _jump3138:;
    if (_1491 >= 0)
    goto _jump3139;
    fail_assertion("negative array index");
    _jump3139:;
    if (_1491 < _1467.d1)
    goto _jump3140;
    fail_assertion("index too large");
    _jump3140:;
    int64_t _1492 = 0;
    _1492 *= _1467.d0;
    _1492 += _1490;
    _1492 *= _1467.d1;
    _1492 += _1491;
    rgba _1493 = _1467.data[_1492];
    int64_t _1494 = 0;
    _1494 *= _1415.d0;
    _1494 += _1461;
    _1494 *= _1415.d1;
    _1494 += _1460;
    _1415.data[_1494] = _1493;
    _1460++;
    if (_1460 < _1436)
    goto _jump3120;
    _1460 = 0;
    _1461++;
    if (_1461 < _692.d0)
    goto _jump3120;
    // End body of loop
    _1271 = _1415;
    _jump3095:;
    write_image(_1271, "k.png");
    _a1__a3_bool _1495;
    // Computing bound for k
    int64_t _1496 = 880;
    _1495.d0 = _1496;
    if (_1496 > 0) 
    goto _jump3141;
    fail_assertion("non-positive loop bound");
    _jump3141:;
    // Computing total size of heap memory to allocate
    int64_t _1497 = 1;
    _1497 *= _1496;
    _1497 *= sizeof(_a3_bool);
    _1495.data = jpl_alloc(_1497);
    int64_t _1498 = 0; // k
    _jump3142:; // Begin body of loop
    int64_t _1499 = -_692.d0;
    int64_t _1500 = -_1499;
    bool _1501 = _692.d0 < _692.d0;
    int64_t _1502;
    if (!_1501)
    goto _jump3143;
    _1502 = _1498;
    goto _jump3144;
    _jump3143:;
    _1502 = _1498;
    _jump3144:;
    int64_t _1503 = _1502 % _1498;
    bool _1504 = _1500 >= _1503;
    _a3_bool _1505;
    if (!_1504)
    goto _jump3145;
    bool _1506 = false;
    _a3_bool _1507;
    if (!_1506)
    goto _jump3146;
    bool _1508 = true;
    bool _1509 = !_1508;
    _a3_bool _1510;
    if (!_1509)
    goto _jump3147;
    _a3_bool _1511;
    // Computing bound for l
    bool _1512 = true;
    int64_t _1513;
    if (!_1512)
    goto _jump3148;
    _1513 = _692.d1;
    goto _jump3149;
    _jump3148:;
    int64_t _1514 = 502;
    _1513 = _1514;
    _jump3149:;
    _1511.d0 = _1513;
    if (_1513 > 0) 
    goto _jump3150;
    fail_assertion("non-positive loop bound");
    _jump3150:;
    // Computing bound for m
    int64_t _1515 = -_692.d0;
    _1511.d1 = _1515;
    if (_1515 > 0) 
    goto _jump3151;
    fail_assertion("non-positive loop bound");
    _jump3151:;
    // Computing bound for n
    _1511.d2 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3152;
    fail_assertion("non-positive loop bound");
    _jump3152:;
    // Computing total size of heap memory to allocate
    int64_t _1516 = 1;
    _1516 *= _1513;
    _1516 *= _1515;
    _1516 *= _692.d0;
    _1516 *= sizeof(bool);
    _1511.data = jpl_alloc(_1516);
    int64_t _1517 = 0; // n
    int64_t _1518 = 0; // m
    int64_t _1519 = 0; // l
    _jump3153:; // Begin body of loop
    bool _1520 = false;
    int64_t _1521 = 0;
    _1521 *= _1511.d0;
    _1521 += _1519;
    _1521 *= _1511.d1;
    _1521 += _1518;
    _1521 *= _1511.d2;
    _1521 += _1517;
    _1511.data[_1521] = _1520;
    _1517++;
    if (_1517 < _692.d0)
    goto _jump3153;
    _1517 = 0;
    _1518++;
    if (_1518 < _1515)
    goto _jump3153;
    _1518 = 0;
    _1519++;
    if (_1519 < _1513)
    goto _jump3153;
    // End body of loop
    _1510 = _1511;
    goto _jump3154;
    _jump3147:;
    _a3_bool _1522;
    // Computing bound for l
    int64_t _1523 = -_1498;
    _1522.d0 = _1523;
    if (_1523 > 0) 
    goto _jump3155;
    fail_assertion("non-positive loop bound");
    _jump3155:;
    // Computing bound for m
    _1522.d1 = _1498;
    if (_1498 > 0) 
    goto _jump3156;
    fail_assertion("non-positive loop bound");
    _jump3156:;
    // Computing bound for n
    _1522.d2 = _1498;
    if (_1498 > 0) 
    goto _jump3157;
    fail_assertion("non-positive loop bound");
    _jump3157:;
    // Computing total size of heap memory to allocate
    int64_t _1524 = 1;
    _1524 *= _1523;
    _1524 *= _1498;
    _1524 *= _1498;
    _1524 *= sizeof(bool);
    _1522.data = jpl_alloc(_1524);
    int64_t _1525 = 0; // n
    int64_t _1526 = 0; // m
    int64_t _1527 = 0; // l
    _jump3158:; // Begin body of loop
    bool _1529 = false;
    bool _1528 = _1529;
    if (0 == _1529)
    goto _jump3159;
    bool _1530 = true;
    _1528 = _1530;
    _jump3159:;
    int64_t _1531 = 0;
    _1531 *= _1522.d0;
    _1531 += _1527;
    _1531 *= _1522.d1;
    _1531 += _1526;
    _1531 *= _1522.d2;
    _1531 += _1525;
    _1522.data[_1531] = _1528;
    _1525++;
    if (_1525 < _1498)
    goto _jump3158;
    _1525 = 0;
    _1526++;
    if (_1526 < _1498)
    goto _jump3158;
    _1526 = 0;
    _1527++;
    if (_1527 < _1523)
    goto _jump3158;
    // End body of loop
    _1510 = _1522;
    _jump3154:;
    _1507 = _1510;
    goto _jump3160;
    _jump3146:;
    _a3_bool _1532;
    // Computing bound for l
    bool _1533 = true;
    int64_t _1534;
    if (!_1533)
    goto _jump3161;
    int64_t _1535 = 733;
    _1534 = _1535;
    goto _jump3162;
    _jump3161:;
    _1534 = _1498;
    _jump3162:;
    _1532.d0 = _1534;
    if (_1534 > 0) 
    goto _jump3163;
    fail_assertion("non-positive loop bound");
    _jump3163:;
    // Computing bound for m
    int64_t _1536 = 666;
    int64_t _1537;
    // Computing bound for l
    int64_t _1538 = 156;
    if (_1538 > 0) 
    goto _jump3164;
    fail_assertion("non-positive loop bound");
    _jump3164:;
    // Computing bound for m
    if (_692.d1 > 0) 
    goto _jump3165;
    fail_assertion("non-positive loop bound");
    _jump3165:;
    // Computing bound for n
    if (_692.d1 > 0) 
    goto _jump3166;
    fail_assertion("non-positive loop bound");
    _jump3166:;
    _1537 = 0;
    int64_t _1539 = 0; // n
    int64_t _1540 = 0; // m
    int64_t _1541 = 0; // l
    _jump3167:; // Begin body of loop
    _1537 += _1541;
    _1539++;
    if (_1539 < _692.d1)
    goto _jump3167;
    _1539 = 0;
    _1540++;
    if (_1540 < _692.d1)
    goto _jump3167;
    _1540 = 0;
    _1541++;
    if (_1541 < _1538)
    goto _jump3167;
    // End body of loop
    int64_t _1542 = _1536 % _1537;
    _1532.d1 = _1542;
    if (_1542 > 0) 
    goto _jump3168;
    fail_assertion("non-positive loop bound");
    _jump3168:;
    // Computing bound for n
    int64_t _1543 = -_692.d0;
    _1532.d2 = _1543;
    if (_1543 > 0) 
    goto _jump3169;
    fail_assertion("non-positive loop bound");
    _jump3169:;
    // Computing total size of heap memory to allocate
    int64_t _1544 = 1;
    _1544 *= _1534;
    _1544 *= _1542;
    _1544 *= _1543;
    _1544 *= sizeof(bool);
    _1532.data = jpl_alloc(_1544);
    int64_t _1545 = 0; // n
    int64_t _1546 = 0; // m
    int64_t _1547 = 0; // l
    _jump3170:; // Begin body of loop
    bool _1548 = false;
    int64_t _1549 = 0;
    _1549 *= _1532.d0;
    _1549 += _1547;
    _1549 *= _1532.d1;
    _1549 += _1546;
    _1549 *= _1532.d2;
    _1549 += _1545;
    _1532.data[_1549] = _1548;
    _1545++;
    if (_1545 < _1543)
    goto _jump3170;
    _1545 = 0;
    _1546++;
    if (_1546 < _1542)
    goto _jump3170;
    _1546 = 0;
    _1547++;
    if (_1547 < _1534)
    goto _jump3170;
    // End body of loop
    _1507 = _1532;
    _jump3160:;
    _1505 = _1507;
    goto _jump3171;
    _jump3145:;
    _a3_bool _1550;
    // Computing bound for l
    _1550.d0 = _1498;
    if (_1498 > 0) 
    goto _jump3172;
    fail_assertion("non-positive loop bound");
    _jump3172:;
    // Computing bound for m
    _1550.d1 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3173;
    fail_assertion("non-positive loop bound");
    _jump3173:;
    // Computing bound for n
    int64_t _1551 = -_692.d1;
    _1550.d2 = _1551;
    if (_1551 > 0) 
    goto _jump3174;
    fail_assertion("non-positive loop bound");
    _jump3174:;
    // Computing total size of heap memory to allocate
    int64_t _1552 = 1;
    _1552 *= _1498;
    _1552 *= _692.d1;
    _1552 *= _1551;
    _1552 *= sizeof(bool);
    _1550.data = jpl_alloc(_1552);
    int64_t _1553 = 0; // n
    int64_t _1554 = 0; // m
    int64_t _1555 = 0; // l
    _jump3175:; // Begin body of loop
    bool _1556 = false;
    bool _1557;
    if (!_1556)
    goto _jump3176;
    bool _1558 = false;
    _1557 = _1558;
    goto _jump3177;
    _jump3176:;
    bool _1559 = true;
    _1557 = _1559;
    _jump3177:;
    bool _1560;
    if (!_1557)
    goto _jump3178;
    int64_t _1561 = 365;
    int64_t _1562 = -_1561;
    bool _1563 = _1553 != _1562;
    _1560 = _1563;
    goto _jump3179;
    _jump3178:;
    int64_t _1564 = 493;
    int64_t _1565 = _1564 - _692.d1;
    bool _1566 = _1565 >= _692.d1;
    _1560 = _1566;
    _jump3179:;
    int64_t _1567 = 0;
    _1567 *= _1550.d0;
    _1567 += _1555;
    _1567 *= _1550.d1;
    _1567 += _1554;
    _1567 *= _1550.d2;
    _1567 += _1553;
    _1550.data[_1567] = _1560;
    _1553++;
    if (_1553 < _1551)
    goto _jump3175;
    _1553 = 0;
    _1554++;
    if (_1554 < _692.d1)
    goto _jump3175;
    _1554 = 0;
    _1555++;
    if (_1555 < _1498)
    goto _jump3175;
    // End body of loop
    _1505 = _1550;
    _jump3171:;
    int64_t _1568 = 0;
    _1568 *= _1495.d0;
    _1568 += _1498;
    _1495.data[_1568] = _1505;
    _1498++;
    if (_1498 < _1496)
    goto _jump3142;
    // End body of loop
    if (_692.d0 >= 0)
    goto _jump3180;
    fail_assertion("negative array index");
    _jump3180:;
    if (_692.d0 < _1495.d0)
    goto _jump3181;
    fail_assertion("index too large");
    _jump3181:;
    int64_t _1569 = 0;
    _1569 *= _1495.d0;
    _1569 += _692.d0;
    _a3_bool _1570 = _1495.data[_1569];
    _a3_rgba _1571;
    // Computing bound for o
    int64_t _1572 = 367;
    int64_t _1573 = -_1572;
    _1571.d0 = _1573;
    if (_1573 > 0) 
    goto _jump3182;
    fail_assertion("non-positive loop bound");
    _jump3182:;
    // Computing bound for p
    int64_t _1574 = 430;
    int64_t _1575 = -_1574;
    _1571.d1 = _1575;
    if (_1575 > 0) 
    goto _jump3183;
    fail_assertion("non-positive loop bound");
    _jump3183:;
    // Computing bound for q
    _1571.d2 = _1570.d2;
    if (_1570.d2 > 0) 
    goto _jump3184;
    fail_assertion("non-positive loop bound");
    _jump3184:;
    // Computing total size of heap memory to allocate
    int64_t _1576 = 1;
    _1576 *= _1573;
    _1576 *= _1575;
    _1576 *= _1570.d2;
    _1576 *= sizeof(rgba);
    _1571.data = jpl_alloc(_1576);
    int64_t _1577 = 0; // q
    int64_t _1578 = 0; // p
    int64_t _1579 = 0; // o
    _jump3185:; // Begin body of loop
    bool _1580 = true;
    bool _1581;
    if (!_1580)
    goto _jump3186;
    bool _1582 = false;
    bool _1583 = !_1582;
    _1581 = _1583;
    goto _jump3187;
    _jump3186:;
    bool _1584 = false;
    bool _1585;
    if (!_1584)
    goto _jump3188;
    bool _1586 = false;
    _1585 = _1586;
    goto _jump3189;
    _jump3188:;
    bool _1587 = true;
    _1585 = _1587;
    _jump3189:;
    _1581 = _1585;
    _jump3187:;
    _a2__a2__a2_rgba _1588;
    if (!_1581)
    goto _jump3190;
    _a2__a2__a2_rgba _1589;
    // Computing bound for r
    _1589.d0 = _1577;
    if (_1577 > 0) 
    goto _jump3191;
    fail_assertion("non-positive loop bound");
    _jump3191:;
    // Computing bound for s
    _1589.d1 = _1570.d2;
    if (_1570.d2 > 0) 
    goto _jump3192;
    fail_assertion("non-positive loop bound");
    _jump3192:;
    // Computing total size of heap memory to allocate
    int64_t _1590 = 1;
    _1590 *= _1577;
    _1590 *= _1570.d2;
    _1590 *= sizeof(_a2__a2_rgba);
    _1589.data = jpl_alloc(_1590);
    int64_t _1591 = 0; // s
    int64_t _1592 = 0; // r
    _jump3193:; // Begin body of loop
    _a2__a2_rgba _1593;
    // Computing bound for t
    _1593.d0 = _1570.d1;
    if (_1570.d1 > 0) 
    goto _jump3194;
    fail_assertion("non-positive loop bound");
    _jump3194:;
    // Computing bound for u
    _1593.d1 = _1592;
    if (_1592 > 0) 
    goto _jump3195;
    fail_assertion("non-positive loop bound");
    _jump3195:;
    // Computing total size of heap memory to allocate
    int64_t _1594 = 1;
    _1594 *= _1570.d1;
    _1594 *= _1592;
    _1594 *= sizeof(_a2_rgba);
    _1593.data = jpl_alloc(_1594);
    int64_t _1595 = 0; // u
    int64_t _1596 = 0; // t
    _jump3196:; // Begin body of loop
    int64_t _1597 = 0;
    _1597 *= _1593.d0;
    _1597 += _1596;
    _1597 *= _1593.d1;
    _1597 += _1595;
    _1593.data[_1597] = _692;
    _1595++;
    if (_1595 < _1592)
    goto _jump3196;
    _1595 = 0;
    _1596++;
    if (_1596 < _1570.d1)
    goto _jump3196;
    // End body of loop
    int64_t _1598 = 0;
    _1598 *= _1589.d0;
    _1598 += _1592;
    _1598 *= _1589.d1;
    _1598 += _1591;
    _1589.data[_1598] = _1593;
    _1591++;
    if (_1591 < _1570.d2)
    goto _jump3193;
    _1591 = 0;
    _1592++;
    if (_1592 < _1577)
    goto _jump3193;
    // End body of loop
    _1588 = _1589;
    goto _jump3197;
    _jump3190:;
    _a2__a2__a2_rgba _1599;
    // Computing bound for r
    int64_t _1600;
    // Computing bound for r
    int64_t _1601 = 215;
    if (_1601 > 0) 
    goto _jump3198;
    fail_assertion("non-positive loop bound");
    _jump3198:;
    _1600 = 0;
    int64_t _1602 = 0; // r
    _jump3199:; // Begin body of loop
    _1600 += _1570.d2;
    _1602++;
    if (_1602 < _1601)
    goto _jump3199;
    // End body of loop
    _1599.d0 = _1600;
    if (_1600 > 0) 
    goto _jump3200;
    fail_assertion("non-positive loop bound");
    _jump3200:;
    // Computing bound for s
    _1599.d1 = _1577;
    if (_1577 > 0) 
    goto _jump3201;
    fail_assertion("non-positive loop bound");
    _jump3201:;
    // Computing total size of heap memory to allocate
    int64_t _1603 = 1;
    _1603 *= _1600;
    _1603 *= _1577;
    _1603 *= sizeof(_a2__a2_rgba);
    _1599.data = jpl_alloc(_1603);
    int64_t _1604 = 0; // s
    int64_t _1605 = 0; // r
    _jump3202:; // Begin body of loop
    _a2__a2_rgba _1606;
    // Computing bound for t
    _1606.d0 = _1570.d0;
    if (_1570.d0 > 0) 
    goto _jump3203;
    fail_assertion("non-positive loop bound");
    _jump3203:;
    // Computing bound for u
    int64_t _1607 = 257;
    _1606.d1 = _1607;
    if (_1607 > 0) 
    goto _jump3204;
    fail_assertion("non-positive loop bound");
    _jump3204:;
    // Computing total size of heap memory to allocate
    int64_t _1608 = 1;
    _1608 *= _1570.d0;
    _1608 *= _1607;
    _1608 *= sizeof(_a2_rgba);
    _1606.data = jpl_alloc(_1608);
    int64_t _1609 = 0; // u
    int64_t _1610 = 0; // t
    _jump3205:; // Begin body of loop
    int64_t _1611 = 0;
    _1611 *= _1606.d0;
    _1611 += _1610;
    _1611 *= _1606.d1;
    _1611 += _1609;
    _1606.data[_1611] = _692;
    _1609++;
    if (_1609 < _1607)
    goto _jump3205;
    _1609 = 0;
    _1610++;
    if (_1610 < _1570.d0)
    goto _jump3205;
    // End body of loop
    int64_t _1612 = 0;
    _1612 *= _1599.d0;
    _1612 += _1605;
    _1612 *= _1599.d1;
    _1612 += _1604;
    _1599.data[_1612] = _1606;
    _1604++;
    if (_1604 < _1577)
    goto _jump3202;
    _1604 = 0;
    _1605++;
    if (_1605 < _1600)
    goto _jump3202;
    // End body of loop
    _1588 = _1599;
    _jump3197:;
    int64_t _1613 = -_1570.d0;
    int64_t _1614;
    // Computing bound for r
    int64_t _1615 = 847;
    if (_1615 > 0) 
    goto _jump3206;
    fail_assertion("non-positive loop bound");
    _jump3206:;
    // Computing bound for s
    if (_1570.d1 > 0) 
    goto _jump3207;
    fail_assertion("non-positive loop bound");
    _jump3207:;
    _1614 = 0;
    int64_t _1616 = 0; // s
    int64_t _1617 = 0; // r
    _jump3208:; // Begin body of loop
    _1614 += _1578;
    _1616++;
    if (_1616 < _1570.d1)
    goto _jump3208;
    _1616 = 0;
    _1617++;
    if (_1617 < _1615)
    goto _jump3208;
    // End body of loop
    if (_1613 >= 0)
    goto _jump3209;
    fail_assertion("negative array index");
    _jump3209:;
    if (_1613 < _1588.d0)
    goto _jump3210;
    fail_assertion("index too large");
    _jump3210:;
    if (_1614 >= 0)
    goto _jump3211;
    fail_assertion("negative array index");
    _jump3211:;
    if (_1614 < _1588.d1)
    goto _jump3212;
    fail_assertion("index too large");
    _jump3212:;
    int64_t _1618 = 0;
    _1618 *= _1588.d0;
    _1618 += _1613;
    _1618 *= _1588.d1;
    _1618 += _1614;
    _a2__a2_rgba _1619 = _1588.data[_1618];
    int64_t _1620;
    // Computing bound for r
    if (_1570.d0 > 0) 
    goto _jump3213;
    fail_assertion("non-positive loop bound");
    _jump3213:;
    _1620 = 0;
    int64_t _1621 = 0; // r
    _jump3214:; // Begin body of loop
    _1620 += _1570.d0;
    _1621++;
    if (_1621 < _1570.d0)
    goto _jump3214;
    // End body of loop
    if (_1570.d2 >= 0)
    goto _jump3215;
    fail_assertion("negative array index");
    _jump3215:;
    if (_1570.d2 < _1619.d0)
    goto _jump3216;
    fail_assertion("index too large");
    _jump3216:;
    if (_1620 >= 0)
    goto _jump3217;
    fail_assertion("negative array index");
    _jump3217:;
    if (_1620 < _1619.d1)
    goto _jump3218;
    fail_assertion("index too large");
    _jump3218:;
    int64_t _1622 = 0;
    _1622 *= _1619.d0;
    _1622 += _1570.d2;
    _1622 *= _1619.d1;
    _1622 += _1620;
    _a2_rgba _1623 = _1619.data[_1622];
    if (_1577 >= 0)
    goto _jump3219;
    fail_assertion("negative array index");
    _jump3219:;
    if (_1577 < _1623.d0)
    goto _jump3220;
    fail_assertion("index too large");
    _jump3220:;
    if (_692.d0 >= 0)
    goto _jump3221;
    fail_assertion("negative array index");
    _jump3221:;
    if (_692.d0 < _1623.d1)
    goto _jump3222;
    fail_assertion("index too large");
    _jump3222:;
    int64_t _1624 = 0;
    _1624 *= _1623.d0;
    _1624 += _1577;
    _1624 *= _1623.d1;
    _1624 += _692.d0;
    rgba _1625 = _1623.data[_1624];
    int64_t _1626 = 0;
    _1626 *= _1571.d0;
    _1626 += _1579;
    _1626 *= _1571.d1;
    _1626 += _1578;
    _1626 *= _1571.d2;
    _1626 += _1577;
    _1571.data[_1626] = _1625;
    _1577++;
    if (_1577 < _1570.d2)
    goto _jump3185;
    _1577 = 0;
    _1578++;
    if (_1578 < _1575)
    goto _jump3185;
    _1578 = 0;
    _1579++;
    if (_1579 < _1573)
    goto _jump3185;
    // End body of loop
    print("w");
    bool _1627 = true;
    if (0 != _1627)
    goto _jump3417;
    fail_assertion("w");
    _jump3417:;
    print("w");
    _a2__a2__a1_int64_t _1628;
    // Computing bound for w
    _1628.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3418;
    fail_assertion("non-positive loop bound");
    _jump3418:;
    // Computing bound for x
    _1628.d1 = _1570.d1;
    if (_1570.d1 > 0) 
    goto _jump3419;
    fail_assertion("non-positive loop bound");
    _jump3419:;
    // Computing total size of heap memory to allocate
    int64_t _1629 = 1;
    _1629 *= _692.d0;
    _1629 *= _1570.d1;
    _1629 *= sizeof(_a2__a1_int64_t);
    _1628.data = jpl_alloc(_1629);
    int64_t _1630 = 0; // x
    int64_t _1631 = 0; // w
    _jump3420:; // Begin body of loop
    int64_t _1632 = 756;
    bool _1633 = _1570.d1 >= _1632;
    bool _1634;
    if (!_1633)
    goto _jump3421;
    bool _1636 = _692.d1 == _1570.d0;
    bool _1635 = _1636;
    if (0 != _1636)
    goto _jump3422;
    bool _1638 = false;
    bool _1637 = _1638;
    if (0 == _1638)
    goto _jump3423;
    bool _1639 = false;
    _1637 = _1639;
    _jump3423:;
    _1635 = _1637;
    _jump3422:;
    _1634 = _1635;
    goto _jump3424;
    _jump3421:;
    bool _1640 = _692.d0 < _1571.d1;
    _1634 = _1640;
    _jump3424:;
    _a2__a1_int64_t _1641;
    if (!_1634)
    goto _jump3425;
    double _1642 = 31.0;
    double _1643 = 73.0;
    bool _1644 = _1642 >= _1643;
    bool _1645 = !_1644;
    _a2__a1_int64_t _1646;
    if (!_1645)
    goto _jump3426;
    _a2__a1_int64_t _1647;
    // Computing bound for y
    _1647.d0 = _1630;
    if (_1630 > 0) 
    goto _jump3427;
    fail_assertion("non-positive loop bound");
    _jump3427:;
    // Computing bound for z
    _1647.d1 = _1630;
    if (_1630 > 0) 
    goto _jump3428;
    fail_assertion("non-positive loop bound");
    _jump3428:;
    // Computing total size of heap memory to allocate
    int64_t _1648 = 1;
    _1648 *= _1630;
    _1648 *= _1630;
    _1648 *= sizeof(_a1_int64_t);
    _1647.data = jpl_alloc(_1648);
    int64_t _1649 = 0; // z
    int64_t _1650 = 0; // y
    _jump3429:; // Begin body of loop
    _a1_int64_t _1651;
    // Computing bound for A
    _1651.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3430;
    fail_assertion("non-positive loop bound");
    _jump3430:;
    // Computing total size of heap memory to allocate
    int64_t _1652 = 1;
    _1652 *= _692.d1;
    _1652 *= sizeof(int64_t);
    _1651.data = jpl_alloc(_1652);
    int64_t _1653 = 0; // A
    _jump3431:; // Begin body of loop
    int64_t _1654 = 0;
    _1654 *= _1651.d0;
    _1654 += _1653;
    _1651.data[_1654] = _1650;
    _1653++;
    if (_1653 < _692.d1)
    goto _jump3431;
    // End body of loop
    int64_t _1655 = 0;
    _1655 *= _1647.d0;
    _1655 += _1650;
    _1655 *= _1647.d1;
    _1655 += _1649;
    _1647.data[_1655] = _1651;
    _1649++;
    if (_1649 < _1630)
    goto _jump3429;
    _1649 = 0;
    _1650++;
    if (_1650 < _1630)
    goto _jump3429;
    // End body of loop
    _1646 = _1647;
    goto _jump3432;
    _jump3426:;
    _a2__a1_int64_t _1656;
    // Computing bound for y
    _1656.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3433;
    fail_assertion("non-positive loop bound");
    _jump3433:;
    // Computing bound for z
    _1656.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3434;
    fail_assertion("non-positive loop bound");
    _jump3434:;
    // Computing total size of heap memory to allocate
    int64_t _1657 = 1;
    _1657 *= _692.d1;
    _1657 *= _692.d0;
    _1657 *= sizeof(_a1_int64_t);
    _1656.data = jpl_alloc(_1657);
    int64_t _1658 = 0; // z
    int64_t _1659 = 0; // y
    _jump3435:; // Begin body of loop
    _a1_int64_t _1660;
    // Computing bound for A
    _1660.d0 = _1631;
    if (_1631 > 0) 
    goto _jump3436;
    fail_assertion("non-positive loop bound");
    _jump3436:;
    // Computing total size of heap memory to allocate
    int64_t _1661 = 1;
    _1661 *= _1631;
    _1661 *= sizeof(int64_t);
    _1660.data = jpl_alloc(_1661);
    int64_t _1662 = 0; // A
    _jump3437:; // Begin body of loop
    int64_t _1663 = 0;
    _1663 *= _1660.d0;
    _1663 += _1662;
    _1660.data[_1663] = _1570.d0;
    _1662++;
    if (_1662 < _1631)
    goto _jump3437;
    // End body of loop
    int64_t _1664 = 0;
    _1664 *= _1656.d0;
    _1664 += _1659;
    _1664 *= _1656.d1;
    _1664 += _1658;
    _1656.data[_1664] = _1660;
    _1658++;
    if (_1658 < _692.d0)
    goto _jump3435;
    _1658 = 0;
    _1659++;
    if (_1659 < _692.d1)
    goto _jump3435;
    // End body of loop
    _1646 = _1656;
    _jump3432:;
    _1641 = _1646;
    goto _jump3438;
    _jump3425:;
    _a2__a1_int64_t _1665;
    // Computing bound for y
    int64_t _1666;
    // Computing bound for y
    if (_692.d0 > 0) 
    goto _jump3439;
    fail_assertion("non-positive loop bound");
    _jump3439:;
    // Computing bound for z
    if (_692.d0 > 0) 
    goto _jump3440;
    fail_assertion("non-positive loop bound");
    _jump3440:;
    // Computing bound for A
    if (_1571.d1 > 0) 
    goto _jump3441;
    fail_assertion("non-positive loop bound");
    _jump3441:;
    _1666 = 0;
    int64_t _1667 = 0; // A
    int64_t _1668 = 0; // z
    int64_t _1669 = 0; // y
    _jump3442:; // Begin body of loop
    _1666 += _1631;
    _1667++;
    if (_1667 < _1571.d1)
    goto _jump3442;
    _1667 = 0;
    _1668++;
    if (_1668 < _692.d0)
    goto _jump3442;
    _1668 = 0;
    _1669++;
    if (_1669 < _692.d0)
    goto _jump3442;
    // End body of loop
    _1665.d0 = _1666;
    if (_1666 > 0) 
    goto _jump3443;
    fail_assertion("non-positive loop bound");
    _jump3443:;
    // Computing bound for z
    _1665.d1 = _1571.d2;
    if (_1571.d2 > 0) 
    goto _jump3444;
    fail_assertion("non-positive loop bound");
    _jump3444:;
    // Computing total size of heap memory to allocate
    int64_t _1670 = 1;
    _1670 *= _1666;
    _1670 *= _1571.d2;
    _1670 *= sizeof(_a1_int64_t);
    _1665.data = jpl_alloc(_1670);
    int64_t _1671 = 0; // z
    int64_t _1672 = 0; // y
    _jump3445:; // Begin body of loop
    _a1_int64_t _1673;
    _1673.d0 = 2;
    _1673.data = jpl_alloc(sizeof(int64_t) * 2);
    _1673.data[0] = _1571.d2;
    _1673.data[1] = _1571.d2;
    int64_t _1674 = 0;
    _1674 *= _1665.d0;
    _1674 += _1672;
    _1674 *= _1665.d1;
    _1674 += _1671;
    _1665.data[_1674] = _1673;
    _1671++;
    if (_1671 < _1571.d2)
    goto _jump3445;
    _1671 = 0;
    _1672++;
    if (_1672 < _1666)
    goto _jump3445;
    // End body of loop
    _1641 = _1665;
    _jump3438:;
    int64_t _1675 = 0;
    _1675 *= _1628.d0;
    _1675 += _1631;
    _1675 *= _1628.d1;
    _1675 += _1630;
    _1628.data[_1675] = _1641;
    _1630++;
    if (_1630 < _1570.d1)
    goto _jump3420;
    _1630 = 0;
    _1631++;
    if (_1631 < _692.d0)
    goto _jump3420;
    // End body of loop
    bool _1676 = false;
    rgba _1677;
    if (!_1676)
    goto _jump3446;
    rgba _1678 = j();
    _1677 = _1678;
    goto _jump3447;
    _jump3446:;
    bool _1679 = false;
    rgba _1680;
    if (!_1679)
    goto _jump3448;
    rgba _1681 = j();
    _1680 = _1681;
    goto _jump3449;
    _jump3448:;
    rgba _1682 = j();
    _1680 = _1682;
    _jump3449:;
    _1677 = _1680;
    _jump3447:;
    double _1683 = a(_1677);
    int64_t _1684 = _692.d0 - _692.d0;
    if (_1571.d2 >= 0)
    goto _jump3450;
    fail_assertion("negative array index");
    _jump3450:;
    if (_1571.d2 < _692.d0)
    goto _jump3451;
    fail_assertion("index too large");
    _jump3451:;
    if (_1684 >= 0)
    goto _jump3452;
    fail_assertion("negative array index");
    _jump3452:;
    if (_1684 < _692.d1)
    goto _jump3453;
    fail_assertion("index too large");
    _jump3453:;
    int64_t _1685 = 0;
    _1685 *= _692.d0;
    _1685 += _1571.d2;
    _1685 *= _692.d1;
    _1685 += _1684;
    rgba _1686 = _692.data[_1685];
    double _1687 = _1686.g;
    bool _1688 = _1683 >= _1687;
    int64_t _1689;
    if (!_1688)
    goto _jump3454;
    double _1692 = 47.0;
    bool _1693 = _1692 == _487;
    bool _1691 = _1693;
    if (0 == _1693)
    goto _jump3455;
    bool _1694 = true;
    _1691 = _1694;
    _jump3455:;
    bool _1690 = _1691;
    if (0 == _1691)
    goto _jump3456;
    bool _1695 = _692.d0 <= _1571.d1;
    _1690 = _1695;
    _jump3456:;
    int64_t _1696;
    if (!_1690)
    goto _jump3457;
    _1696 = _1571.d1;
    goto _jump3458;
    _jump3457:;
    _1696 = _1570.d1;
    _jump3458:;
    _1689 = _1696;
    goto _jump3459;
    _jump3454:;
    _1689 = _692.d0;
    _jump3459:;
    int64_t _1697 = -_692.d0;
    _a3_int64_t _1698;
    // Computing bound for w
    _1698.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3460;
    fail_assertion("non-positive loop bound");
    _jump3460:;
    // Computing bound for x
    int64_t _1699 = -_1571.d0;
    _1698.d1 = _1699;
    if (_1699 > 0) 
    goto _jump3461;
    fail_assertion("non-positive loop bound");
    _jump3461:;
    // Computing bound for y
    _1698.d2 = _1570.d2;
    if (_1570.d2 > 0) 
    goto _jump3462;
    fail_assertion("non-positive loop bound");
    _jump3462:;
    // Computing total size of heap memory to allocate
    int64_t _1700 = 1;
    _1700 *= _692.d0;
    _1700 *= _1699;
    _1700 *= _1570.d2;
    _1700 *= sizeof(int64_t);
    _1698.data = jpl_alloc(_1700);
    int64_t _1701 = 0; // y
    int64_t _1702 = 0; // x
    int64_t _1703 = 0; // w
    _jump3463:; // Begin body of loop
    int64_t _1704 = 0;
    _1704 *= _1698.d0;
    _1704 += _1703;
    _1704 *= _1698.d1;
    _1704 += _1702;
    _1704 *= _1698.d2;
    _1704 += _1701;
    _1698.data[_1704] = _1571.d0;
    _1701++;
    if (_1701 < _1570.d2)
    goto _jump3463;
    _1701 = 0;
    _1702++;
    if (_1702 < _1699)
    goto _jump3463;
    _1702 = 0;
    _1703++;
    if (_1703 < _692.d0)
    goto _jump3463;
    // End body of loop
    int64_t _1705 = _1570.d0 % _1570.d0;
    int64_t _1706;
    // Computing bound for w
    if (_692.d1 > 0) 
    goto _jump3464;
    fail_assertion("non-positive loop bound");
    _jump3464:;
    _1706 = 0;
    int64_t _1707 = 0; // w
    _jump3465:; // Begin body of loop
    _1706 += _1570.d2;
    _1707++;
    if (_1707 < _692.d1)
    goto _jump3465;
    // End body of loop
    int64_t _1708 = _1571.d0 * _1570.d2;
    if (_1705 >= 0)
    goto _jump3466;
    fail_assertion("negative array index");
    _jump3466:;
    if (_1705 < _1698.d0)
    goto _jump3467;
    fail_assertion("index too large");
    _jump3467:;
    if (_1706 >= 0)
    goto _jump3468;
    fail_assertion("negative array index");
    _jump3468:;
    if (_1706 < _1698.d1)
    goto _jump3469;
    fail_assertion("index too large");
    _jump3469:;
    if (_1708 >= 0)
    goto _jump3470;
    fail_assertion("negative array index");
    _jump3470:;
    if (_1708 < _1698.d2)
    goto _jump3471;
    fail_assertion("index too large");
    _jump3471:;
    int64_t _1709 = 0;
    _1709 *= _1698.d0;
    _1709 += _1705;
    _1709 *= _1698.d1;
    _1709 += _1706;
    _1709 *= _1698.d2;
    _1709 += _1708;
    int64_t _1710 = _1698.data[_1709];
    int64_t _1711 = _1697 * _1710;
    int64_t _1712 = _1711 * _1570.d2;
    if (_1689 >= 0)
    goto _jump3472;
    fail_assertion("negative array index");
    _jump3472:;
    if (_1689 < _1628.d0)
    goto _jump3473;
    fail_assertion("index too large");
    _jump3473:;
    if (_1712 >= 0)
    goto _jump3474;
    fail_assertion("negative array index");
    _jump3474:;
    if (_1712 < _1628.d1)
    goto _jump3475;
    fail_assertion("index too large");
    _jump3475:;
    int64_t _1713 = 0;
    _1713 *= _1628.d0;
    _1713 += _1689;
    _1713 *= _1628.d1;
    _1713 += _1712;
    _a2__a1_int64_t _1714 = _1628.data[_1713];
    bool _1715 = _692.d1 < _692.d1;
    bool _1716 = true;
    bool _1717 = _1715 == _1716;
    void_t _1718;
    if (!_1717)
    goto _jump3476;
    bool _1719 = _1571.d1 <= _692.d1;
    rgba _1720;
    if (!_1719)
    goto _jump3477;
    double _1721;
    // Computing bound for w
    bool _1722 = false;
    int64_t _1723;
    if (!_1722)
    goto _jump3478;
    _1723 = _1570.d2;
    goto _jump3479;
    _jump3478:;
    int64_t _1724 = 614;
    _1723 = _1724;
    _jump3479:;
    if (_1723 > 0) 
    goto _jump3480;
    fail_assertion("non-positive loop bound");
    _jump3480:;
    _1721 = 0;
    int64_t _1725 = 0; // w
    _jump3481:; // Begin body of loop
    _1721 += _487;
    _1725++;
    if (_1725 < _1723)
    goto _jump3481;
    // End body of loop
    double _1726 = 55.0;
    double _1727 = 55.0;
    double _1728 = _1726 / _1727;
    double _1729 = 88.0;
    double _1730 = -_1729;
    double _1731 = -_1730;
    bool _1732 = _1571.d2 < _692.d1;
    double _1733;
    if (!_1732)
    goto _jump3482;
    _1733 = _487;
    goto _jump3483;
    _jump3482:;
    double _1734;
    // Computing bound for w
    if (_1570.d0 > 0) 
    goto _jump3484;
    fail_assertion("non-positive loop bound");
    _jump3484:;
    // Computing bound for x
    if (_1570.d1 > 0) 
    goto _jump3485;
    fail_assertion("non-positive loop bound");
    _jump3485:;
    // Computing bound for y
    if (_692.d0 > 0) 
    goto _jump3486;
    fail_assertion("non-positive loop bound");
    _jump3486:;
    _1734 = 0;
    int64_t _1735 = 0; // y
    int64_t _1736 = 0; // x
    int64_t _1737 = 0; // w
    _jump3487:; // Begin body of loop
    double _1738 = 64.0;
    _1734 += _1738;
    _1735++;
    if (_1735 < _692.d0)
    goto _jump3487;
    _1735 = 0;
    _1736++;
    if (_1736 < _1570.d1)
    goto _jump3487;
    _1736 = 0;
    _1737++;
    if (_1737 < _1570.d0)
    goto _jump3487;
    // End body of loop
    _1733 = _1734;
    _jump3483:;
    rgba _1739 = { _1721, _1728, _1731, _1733 };
    _1720 = _1739;
    goto _jump3488;
    _jump3477:;
    rgba _1740 = j();
    _1720 = _1740;
    _jump3488:;
    bool _1741 = true;
    bool _1742 = !_1741;
    _a3_rgba _1743;
    if (!_1742)
    goto _jump3489;
    _1743 = _1571;
    goto _jump3490;
    _jump3489:;
    _a3_rgba _1744;
    // Computing bound for w
    _1744.d0 = _1570.d0;
    if (_1570.d0 > 0) 
    goto _jump3491;
    fail_assertion("non-positive loop bound");
    _jump3491:;
    // Computing bound for x
    int64_t _1745 = 119;
    _1744.d1 = _1745;
    if (_1745 > 0) 
    goto _jump3492;
    fail_assertion("non-positive loop bound");
    _jump3492:;
    // Computing bound for y
    _1744.d2 = _1570.d2;
    if (_1570.d2 > 0) 
    goto _jump3493;
    fail_assertion("non-positive loop bound");
    _jump3493:;
    // Computing total size of heap memory to allocate
    int64_t _1746 = 1;
    _1746 *= _1570.d0;
    _1746 *= _1745;
    _1746 *= _1570.d2;
    _1746 *= sizeof(rgba);
    _1744.data = jpl_alloc(_1746);
    int64_t _1747 = 0; // y
    int64_t _1748 = 0; // x
    int64_t _1749 = 0; // w
    _jump3494:; // Begin body of loop
    rgba _1750 = j();
    int64_t _1751 = 0;
    _1751 *= _1744.d0;
    _1751 += _1749;
    _1751 *= _1744.d1;
    _1751 += _1748;
    _1751 *= _1744.d2;
    _1751 += _1747;
    _1744.data[_1751] = _1750;
    _1747++;
    if (_1747 < _1570.d2)
    goto _jump3494;
    _1747 = 0;
    _1748++;
    if (_1748 < _1745)
    goto _jump3494;
    _1748 = 0;
    _1749++;
    if (_1749 < _1570.d0)
    goto _jump3494;
    // End body of loop
    _1743 = _1744;
    _jump3490:;
    int64_t _1752;
    // Computing bound for w
    if (_1570.d1 > 0) 
    goto _jump3495;
    fail_assertion("non-positive loop bound");
    _jump3495:;
    // Computing bound for x
    if (_1571.d0 > 0) 
    goto _jump3496;
    fail_assertion("non-positive loop bound");
    _jump3496:;
    // Computing bound for y
    if (_692.d0 > 0) 
    goto _jump3497;
    fail_assertion("non-positive loop bound");
    _jump3497:;
    _1752 = 0;
    int64_t _1753 = 0; // y
    int64_t _1754 = 0; // x
    int64_t _1755 = 0; // w
    _jump3498:; // Begin body of loop
    _1752 += _1571.d2;
    _1753++;
    if (_1753 < _692.d0)
    goto _jump3498;
    _1753 = 0;
    _1754++;
    if (_1754 < _1571.d0)
    goto _jump3498;
    _1754 = 0;
    _1755++;
    if (_1755 < _1570.d1)
    goto _jump3498;
    // End body of loop
    if (_1570.d0 >= 0)
    goto _jump3499;
    fail_assertion("negative array index");
    _jump3499:;
    if (_1570.d0 < _1743.d0)
    goto _jump3500;
    fail_assertion("index too large");
    _jump3500:;
    if (_1752 >= 0)
    goto _jump3501;
    fail_assertion("negative array index");
    _jump3501:;
    if (_1752 < _1743.d1)
    goto _jump3502;
    fail_assertion("index too large");
    _jump3502:;
    if (_1570.d1 >= 0)
    goto _jump3503;
    fail_assertion("negative array index");
    _jump3503:;
    if (_1570.d1 < _1743.d2)
    goto _jump3504;
    fail_assertion("index too large");
    _jump3504:;
    int64_t _1756 = 0;
    _1756 *= _1743.d0;
    _1756 += _1570.d0;
    _1756 *= _1743.d1;
    _1756 += _1752;
    _1756 *= _1743.d2;
    _1756 += _1570.d1;
    rgba _1757 = _1743.data[_1756];
    double _1758 = _1757.a;
    _a3_double _1759;
    // Computing bound for w
    _1759.d0 = _1570.d1;
    if (_1570.d1 > 0) 
    goto _jump3505;
    fail_assertion("non-positive loop bound");
    _jump3505:;
    // Computing bound for x
    _1759.d1 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3506;
    fail_assertion("non-positive loop bound");
    _jump3506:;
    // Computing bound for y
    _1759.d2 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3507;
    fail_assertion("non-positive loop bound");
    _jump3507:;
    // Computing total size of heap memory to allocate
    int64_t _1760 = 1;
    _1760 *= _1570.d1;
    _1760 *= _692.d0;
    _1760 *= _692.d1;
    _1760 *= sizeof(double);
    _1759.data = jpl_alloc(_1760);
    int64_t _1761 = 0; // y
    int64_t _1762 = 0; // x
    int64_t _1763 = 0; // w
    _jump3508:; // Begin body of loop
    int64_t _1764 = 0;
    _1764 *= _1759.d0;
    _1764 += _1763;
    _1764 *= _1759.d1;
    _1764 += _1762;
    _1764 *= _1759.d2;
    _1764 += _1761;
    _1759.data[_1764] = _487;
    _1761++;
    if (_1761 < _692.d1)
    goto _jump3508;
    _1761 = 0;
    _1762++;
    if (_1762 < _692.d0)
    goto _jump3508;
    _1762 = 0;
    _1763++;
    if (_1763 < _1570.d1)
    goto _jump3508;
    // End body of loop
    void_t _1765 = s(_1720, _1758, _1759);
    _1718 = _1765;
    goto _jump3509;
    _jump3476:;
    bool _1766 = false;
    _a1_rgba _1767;
    if (!_1766)
    goto _jump3510;
    _a1_rgba _1768;
    // Computing bound for w
    int64_t _1769 = -_692.d1;
    _1768.d0 = _1769;
    if (_1769 > 0) 
    goto _jump3511;
    fail_assertion("non-positive loop bound");
    _jump3511:;
    // Computing total size of heap memory to allocate
    int64_t _1770 = 1;
    _1770 *= _1769;
    _1770 *= sizeof(rgba);
    _1768.data = jpl_alloc(_1770);
    int64_t _1771 = 0; // w
    _jump3512:; // Begin body of loop
    rgba _1772 = j();
    int64_t _1773 = 0;
    _1773 *= _1768.d0;
    _1773 += _1771;
    _1768.data[_1773] = _1772;
    _1771++;
    if (_1771 < _1769)
    goto _jump3512;
    // End body of loop
    _1767 = _1768;
    goto _jump3513;
    _jump3510:;
    _a1_rgba _1774;
    // Computing bound for w
    _1774.d0 = _692.d0;
    if (_692.d0 > 0) 
    goto _jump3514;
    fail_assertion("non-positive loop bound");
    _jump3514:;
    // Computing total size of heap memory to allocate
    int64_t _1775 = 1;
    _1775 *= _692.d0;
    _1775 *= sizeof(rgba);
    _1774.data = jpl_alloc(_1775);
    int64_t _1776 = 0; // w
    _jump3515:; // Begin body of loop
    if (_1570.d1 >= 0)
    goto _jump3516;
    fail_assertion("negative array index");
    _jump3516:;
    if (_1570.d1 < _692.d0)
    goto _jump3517;
    fail_assertion("index too large");
    _jump3517:;
    if (_1776 >= 0)
    goto _jump3518;
    fail_assertion("negative array index");
    _jump3518:;
    if (_1776 < _692.d1)
    goto _jump3519;
    fail_assertion("index too large");
    _jump3519:;
    int64_t _1777 = 0;
    _1777 *= _692.d0;
    _1777 += _1570.d1;
    _1777 *= _692.d1;
    _1777 += _1776;
    rgba _1778 = _692.data[_1777];
    int64_t _1779 = 0;
    _1779 *= _1774.d0;
    _1779 += _1776;
    _1774.data[_1779] = _1778;
    _1776++;
    if (_1776 < _692.d0)
    goto _jump3515;
    // End body of loop
    _1767 = _1774;
    _jump3513:;
    _a2__a1_int64_t _1780;
    // Computing bound for w
    _1780.d0 = _1571.d0;
    if (_1571.d0 > 0) 
    goto _jump3520;
    fail_assertion("non-positive loop bound");
    _jump3520:;
    // Computing bound for x
    _a1_int64_t _1781;
    _1781.d0 = 1;
    _1781.data = jpl_alloc(sizeof(int64_t) * 1);
    _1781.data[0] = _692.d0;
    if (_1571.d0 >= 0)
    goto _jump3521;
    fail_assertion("negative array index");
    _jump3521:;
    if (_1571.d0 < _1781.d0)
    goto _jump3522;
    fail_assertion("index too large");
    _jump3522:;
    int64_t _1782 = 0;
    _1782 *= _1781.d0;
    _1782 += _1571.d0;
    int64_t _1783 = _1781.data[_1782];
    _1780.d1 = _1783;
    if (_1783 > 0) 
    goto _jump3523;
    fail_assertion("non-positive loop bound");
    _jump3523:;
    // Computing total size of heap memory to allocate
    int64_t _1784 = 1;
    _1784 *= _1571.d0;
    _1784 *= _1783;
    _1784 *= sizeof(_a1_int64_t);
    _1780.data = jpl_alloc(_1784);
    int64_t _1785 = 0; // x
    int64_t _1786 = 0; // w
    _jump3524:; // Begin body of loop
    _a1_int64_t _1787;
    // Computing bound for y
    _1787.d0 = _1571.d2;
    if (_1571.d2 > 0) 
    goto _jump3525;
    fail_assertion("non-positive loop bound");
    _jump3525:;
    // Computing total size of heap memory to allocate
    int64_t _1788 = 1;
    _1788 *= _1571.d2;
    _1788 *= sizeof(int64_t);
    _1787.data = jpl_alloc(_1788);
    int64_t _1789 = 0; // y
    _jump3526:; // Begin body of loop
    int64_t _1790 = 0;
    _1790 *= _1787.d0;
    _1790 += _1789;
    _1787.data[_1790] = _692.d0;
    _1789++;
    if (_1789 < _1571.d2)
    goto _jump3526;
    // End body of loop
    int64_t _1791 = 0;
    _1791 *= _1780.d0;
    _1791 += _1786;
    _1791 *= _1780.d1;
    _1791 += _1785;
    _1780.data[_1791] = _1787;
    _1785++;
    if (_1785 < _1783)
    goto _jump3524;
    _1785 = 0;
    _1786++;
    if (_1786 < _1571.d0)
    goto _jump3524;
    // End body of loop
    rgba _1792 = j();
    double _1793 = a(_1792);
    double _1794 = 73.0;
    double _1795 = 93.0;
    double _1796 = _1795 - _487;
    double _1797 = _487 + _487;
    rgba _1798 = { _1793, _1794, _1796, _1797 };
    double _1799 = 12.0;
    double _1800 = 7.0;
    double _1801 = _487 / _1800;
    double _1802 = _1799 + _1801;
    _a3_double _1803;
    // Computing bound for w
    _1803.d0 = _692.d1;
    if (_692.d1 > 0) 
    goto _jump3527;
    fail_assertion("non-positive loop bound");
    _jump3527:;
    // Computing bound for x
    int64_t _1804 = 591;
    _1803.d1 = _1804;
    if (_1804 > 0) 
    goto _jump3528;
    fail_assertion("non-positive loop bound");
    _jump3528:;
    // Computing bound for y
    _1803.d2 = _1571.d2;
    if (_1571.d2 > 0) 
    goto _jump3529;
    fail_assertion("non-positive loop bound");
    _jump3529:;
    // Computing total size of heap memory to allocate
    int64_t _1805 = 1;
    _1805 *= _692.d1;
    _1805 *= _1804;
    _1805 *= _1571.d2;
    _1805 *= sizeof(double);
    _1803.data = jpl_alloc(_1805);
    int64_t _1806 = 0; // y
    int64_t _1807 = 0; // x
    int64_t _1808 = 0; // w
    _jump3530:; // Begin body of loop
    double _1809 = 97.0;
    int64_t _1810 = 0;
    _1810 *= _1803.d0;
    _1810 += _1808;
    _1810 *= _1803.d1;
    _1810 += _1807;
    _1810 *= _1803.d2;
    _1810 += _1806;
    _1803.data[_1810] = _1809;
    _1806++;
    if (_1806 < _1571.d2)
    goto _jump3530;
    _1806 = 0;
    _1807++;
    if (_1807 < _1804)
    goto _jump3530;
    _1807 = 0;
    _1808++;
    if (_1808 < _692.d1)
    goto _jump3530;
    // End body of loop
    void_t _1811 = s(_1798, _1802, _1803);
    _a1_int64_t _1812 = c(_1780, _1811);
    void_t _1813 = b(_1767, _1812);
    _1718 = _1813;
    _jump3509:;
    _a1_int64_t _1814 = c(_1714, _1718);
}

