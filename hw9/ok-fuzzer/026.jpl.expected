
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
    double a;
    void_t b;
    _a3_int64_t c;
} a;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_double *data;
} _a2__a1_double;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_double *data;
} _a2__a2__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  _a1_double *data;
} _a1__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1_double *data;
} _a3__a1__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
    double a;
    double b;
    double c;
} y;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
    y a;
    void_t b;
} C;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  C *data;
} _a3_C;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

bool d() {
    bool _0 = false;
    bool _1 = false;
    bool _2;
    if (!_1)
    goto _jump239;
    bool _3 = d();
    bool _4 = true;
    bool _5 = !_0;
    bool _6 = _4 == _5;
    bool _7 = !_6;
    bool _8 = _3 != _7;
    _2 = _8;
    goto _jump240;
    _jump239:;
    bool _9 = d();
    _2 = _9;
    _jump240:;
    bool _10 = true;
    bool _11;
    if (!_10)
    goto _jump241;
    int64_t _12 = -c;
    int64_t _13 = c / _12;
    int64_t _14 = -_13;
    bool _15 = c == _14;
    bool _16;
    if (!_15)
    goto _jump242;
    bool _18 = true;
    bool _17 = _18;
    if (0 == _18)
    goto _jump243;
    _a1_int64_t _19;
    // Computing bound for f
    int64_t _20 = 601;
    _19.d0 = _20;
    if (_20 > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= _20;
    _21 *= sizeof(int64_t);
    _19.data = jpl_alloc(_21);
    int64_t _22 = 0; // f
    _jump245:; // Begin body of loop
    int64_t _23 = 938;
    int64_t _24 = 0;
    _24 *= _19.d0;
    _24 += _22;
    _19.data[_24] = _23;
    _22++;
    if (_22 < _20)
    goto _jump245;
    // End body of loop
    bool _25 = d();
    int64_t _26;
    if (!_25)
    goto _jump246;
    _26 = c;
    goto _jump247;
    _jump246:;
    _26 = c;
    _jump247:;
    if (_26 >= 0)
    goto _jump248;
    fail_assertion("negative array index");
    _jump248:;
    if (_26 < _19.d0)
    goto _jump249;
    fail_assertion("index too large");
    _jump249:;
    int64_t _27 = 0;
    _27 *= _19.d0;
    _27 += _26;
    int64_t _28 = _19.data[_27];
    bool _29 = c == _28;
    _17 = _29;
    _jump243:;
    _16 = _17;
    goto _jump250;
    _jump242:;
    bool _30 = false;
    bool _31 = !_30;
    _16 = _31;
    _jump250:;
    _11 = _16;
    goto _jump251;
    _jump241:;
    double _32 = 61.0;
    double _33 = -_32;
    double _34;
    // Computing bound for f
    _a1_int64_t _35;
    // Computing bound for f
    _35.d0 = c;
    if (c > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= c;
    _36 *= sizeof(int64_t);
    _35.data = jpl_alloc(_36);
    int64_t _37 = 0; // f
    _jump253:; // Begin body of loop
    int64_t _38 = 0;
    _38 *= _35.d0;
    _38 += _37;
    _35.data[_38] = _37;
    _37++;
    if (_37 < c)
    goto _jump253;
    // End body of loop
    int64_t _39 = 467;
    int64_t _40 = c + _39;
    if (_40 >= 0)
    goto _jump254;
    fail_assertion("negative array index");
    _jump254:;
    if (_40 < _35.d0)
    goto _jump255;
    fail_assertion("index too large");
    _jump255:;
    int64_t _41 = 0;
    _41 *= _35.d0;
    _41 += _40;
    int64_t _42 = _35.data[_41];
    if (_42 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing bound for g
    bool _43 = d();
    int64_t _44;
    if (!_43)
    goto _jump257;
    _44 = c;
    goto _jump258;
    _jump257:;
    int64_t _45;
    // Computing bound for f
    int64_t _46 = 944;
    if (_46 > 0) 
    goto _jump259;
    fail_assertion("non-positive loop bound");
    _jump259:;
    _45 = 0;
    int64_t _47 = 0; // f
    _jump260:; // Begin body of loop
    int64_t _48 = 373;
    _45 += _48;
    _47++;
    if (_47 < _46)
    goto _jump260;
    // End body of loop
    _44 = _45;
    _jump258:;
    if (_44 > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    _34 = 0;
    int64_t _49 = 0; // g
    int64_t _50 = 0; // f
    _jump262:; // Begin body of loop
    _a2_double _51;
    // Computing bound for h
    _51.d0 = _50;
    if (_50 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing bound for i
    _51.d1 = _50;
    if (_50 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= _50;
    _52 *= _50;
    _52 *= sizeof(double);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // i
    int64_t _54 = 0; // h
    _jump265:; // Begin body of loop
    double _55 = 34.0;
    int64_t _56 = 0;
    _56 *= _51.d0;
    _56 += _54;
    _56 *= _51.d1;
    _56 += _53;
    _51.data[_56] = _55;
    _53++;
    if (_53 < _50)
    goto _jump265;
    _53 = 0;
    _54++;
    if (_54 < _50)
    goto _jump265;
    // End body of loop
    if (c >= 0)
    goto _jump266;
    fail_assertion("negative array index");
    _jump266:;
    if (c < _51.d0)
    goto _jump267;
    fail_assertion("index too large");
    _jump267:;
    if (c >= 0)
    goto _jump268;
    fail_assertion("negative array index");
    _jump268:;
    if (c < _51.d1)
    goto _jump269;
    fail_assertion("index too large");
    _jump269:;
    int64_t _57 = 0;
    _57 *= _51.d0;
    _57 += c;
    _57 *= _51.d1;
    _57 += c;
    double _58 = _51.data[_57];
    _34 += _58;
    _49++;
    if (_49 < _44)
    goto _jump262;
    _49 = 0;
    _50++;
    if (_50 < _42)
    goto _jump262;
    // End body of loop
    double _59 = -_34;
    bool _60 = _33 <= _59;
    _11 = _60;
    _jump251:;
    double _61;
    // Computing bound for f
    int64_t _62;
    // Computing bound for f
    int64_t _63;
    if (!_0)
    goto _jump270;
    int64_t _64 = 720;
    _63 = _64;
    goto _jump271;
    _jump270:;
    int64_t _65 = 715;
    _63 = _65;
    _jump271:;
    if (_63 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    _62 = 0;
    int64_t _66 = 0; // f
    _jump273:; // Begin body of loop
    bool _67 = false;
    int64_t _68;
    if (!_67)
    goto _jump274;
    int64_t _69 = 864;
    _68 = _69;
    goto _jump275;
    _jump274:;
    int64_t _70 = 850;
    _68 = _70;
    _jump275:;
    _62 += _68;
    _66++;
    if (_66 < _63)
    goto _jump273;
    // End body of loop
    if (_62 > 0) 
    goto _jump276;
    fail_assertion("non-positive loop bound");
    _jump276:;
    _61 = 0;
    int64_t _71 = 0; // f
    _jump277:; // Begin body of loop
    double _72 = 71.0;
    _61 += _72;
    _71++;
    if (_71 < _62)
    goto _jump277;
    // End body of loop
    double _73 = 41.0;
    double _74 = -_73;
    double _75 = -_74;
    double _76 = -_75;
    double _77 = _61 + _76;
    double _78 = 69.0;
    bool _79 = _77 > _78;
    bool _80 = !_79;
    _a1_bool _81;
    _81.d0 = 3;
    _81.data = jpl_alloc(sizeof(bool) * 3);
    _81.data[0] = _2;
    _81.data[1] = _11;
    _81.data[2] = _80;
    bool _82 = d();
    bool _83;
    if (!_0)
    goto _jump278;
    _83 = _82;
    goto _jump279;
    _jump278:;
    int64_t _84 = 624;
    int64_t _85 = 766;
    int64_t _86 = _84 * _85;
    int64_t _87;
    // Computing bound for i
    bool _88 = _0 == _0;
    int64_t _89;
    if (!_88)
    goto _jump280;
    _89 = _81.d0;
    goto _jump281;
    _jump280:;
    int64_t _90 = 813;
    _89 = _90;
    _jump281:;
    if (_89 > 0) 
    goto _jump282;
    fail_assertion("non-positive loop bound");
    _jump282:;
    // Computing bound for j
    int64_t _91;
    if (!_82)
    goto _jump283;
    bool _92 = d();
    int64_t _93;
    if (!_92)
    goto _jump284;
    _93 = c;
    goto _jump285;
    _jump284:;
    int64_t _94 = 830;
    _93 = _94;
    _jump285:;
    _91 = _93;
    goto _jump286;
    _jump283:;
    int64_t _95 = _81.d0 - _81.d0;
    _91 = _95;
    _jump286:;
    if (_91 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    // Computing bound for k
    int64_t _96 = 557;
    int64_t _97 = _96 / c;
    if (_97 > 0) 
    goto _jump288;
    fail_assertion("non-positive loop bound");
    _jump288:;
    _87 = 0;
    int64_t _98 = 0; // k
    int64_t _99 = 0; // j
    int64_t _100 = 0; // i
    _jump289:; // Begin body of loop
    _87 += _99;
    _98++;
    if (_98 < _97)
    goto _jump289;
    _98 = 0;
    _99++;
    if (_99 < _91)
    goto _jump289;
    _99 = 0;
    _100++;
    if (_100 < _89)
    goto _jump289;
    // End body of loop
    bool _101 = _86 >= _87;
    _83 = _101;
    _jump279:;
    bool _102 = !_83;
    bool _103;
    if (!_102)
    goto _jump290;
    bool _104;
    if (!_82)
    goto _jump291;
    _a2__a3_bool _105;
    // Computing bound for i
    _105.d0 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing bound for j
    int64_t _106 = -_81.d0;
    _105.d1 = _106;
    if (_106 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= _81.d0;
    _107 *= _106;
    _107 *= sizeof(_a3_bool);
    _105.data = jpl_alloc(_107);
    int64_t _108 = 0; // j
    int64_t _109 = 0; // i
    _jump294:; // Begin body of loop
    _a3_bool _110;
    // Computing bound for k
    _110.d0 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing bound for l
    int64_t _111 = _109 * _109;
    _110.d1 = _111;
    if (_111 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing bound for m
    _110.d2 = _108;
    if (_108 > 0) 
    goto _jump297;
    fail_assertion("non-positive loop bound");
    _jump297:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _81.d0;
    _112 *= _111;
    _112 *= _108;
    _112 *= sizeof(bool);
    _110.data = jpl_alloc(_112);
    int64_t _113 = 0; // m
    int64_t _114 = 0; // l
    int64_t _115 = 0; // k
    _jump298:; // Begin body of loop
    bool _116 = true;
    int64_t _117 = 0;
    _117 *= _110.d0;
    _117 += _115;
    _117 *= _110.d1;
    _117 += _114;
    _117 *= _110.d2;
    _117 += _113;
    _110.data[_117] = _116;
    _113++;
    if (_113 < _108)
    goto _jump298;
    _113 = 0;
    _114++;
    if (_114 < _111)
    goto _jump298;
    _114 = 0;
    _115++;
    if (_115 < _81.d0)
    goto _jump298;
    // End body of loop
    int64_t _118 = 0;
    _118 *= _105.d0;
    _118 += _109;
    _118 *= _105.d1;
    _118 += _108;
    _105.data[_118] = _110;
    _108++;
    if (_108 < _106)
    goto _jump294;
    _108 = 0;
    _109++;
    if (_109 < _81.d0)
    goto _jump294;
    // End body of loop
    int64_t _119 = 812;
    int64_t _120 = 105;
    _a1_int64_t _121;
    _121.d0 = 2;
    _121.data = jpl_alloc(sizeof(int64_t) * 2);
    _121.data[0] = _119;
    _121.data[1] = _120;
    if (c >= 0)
    goto _jump299;
    fail_assertion("negative array index");
    _jump299:;
    if (c < _121.d0)
    goto _jump300;
    fail_assertion("index too large");
    _jump300:;
    int64_t _122 = 0;
    _122 *= _121.d0;
    _122 += c;
    int64_t _123 = _121.data[_122];
    int64_t _124 = _81.d0 / _123;
    _a3_int64_t _125;
    // Computing bound for i
    _125.d0 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing bound for j
    bool _126 = d();
    int64_t _127;
    if (!_126)
    goto _jump302;
    _127 = _81.d0;
    goto _jump303;
    _jump302:;
    int64_t _128 = 69;
    _127 = _128;
    _jump303:;
    _125.d1 = _127;
    if (_127 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for k
    int64_t _129 = 920;
    _125.d2 = _129;
    if (_129 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing total size of heap memory to allocate
    int64_t _130 = 1;
    _130 *= _81.d0;
    _130 *= _127;
    _130 *= _129;
    _130 *= sizeof(int64_t);
    _125.data = jpl_alloc(_130);
    int64_t _131 = 0; // k
    int64_t _132 = 0; // j
    int64_t _133 = 0; // i
    _jump306:; // Begin body of loop
    int64_t _134 = 0;
    _134 *= _125.d0;
    _134 += _133;
    _134 *= _125.d1;
    _134 += _132;
    _134 *= _125.d2;
    _134 += _131;
    _125.data[_134] = _81.d0;
    _131++;
    if (_131 < _129)
    goto _jump306;
    _131 = 0;
    _132++;
    if (_132 < _127)
    goto _jump306;
    _132 = 0;
    _133++;
    if (_133 < _81.d0)
    goto _jump306;
    // End body of loop
    int64_t _135 = 675;
    int64_t _136 = _135 / c;
    int64_t _137 = -_136;
    int64_t _138 = 548;
    bool _139 = d();
    bool _140 = !_139;
    int64_t _141;
    if (!_140)
    goto _jump307;
    int64_t _142 = -c;
    _141 = _142;
    goto _jump308;
    _jump307:;
    _141 = c;
    _jump308:;
    if (_137 >= 0)
    goto _jump309;
    fail_assertion("negative array index");
    _jump309:;
    if (_137 < _125.d0)
    goto _jump310;
    fail_assertion("index too large");
    _jump310:;
    if (_138 >= 0)
    goto _jump311;
    fail_assertion("negative array index");
    _jump311:;
    if (_138 < _125.d1)
    goto _jump312;
    fail_assertion("index too large");
    _jump312:;
    if (_141 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (_141 < _125.d2)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    int64_t _143 = 0;
    _143 *= _125.d0;
    _143 += _137;
    _143 *= _125.d1;
    _143 += _138;
    _143 *= _125.d2;
    _143 += _141;
    int64_t _144 = _125.data[_143];
    if (_124 >= 0)
    goto _jump315;
    fail_assertion("negative array index");
    _jump315:;
    if (_124 < _105.d0)
    goto _jump316;
    fail_assertion("index too large");
    _jump316:;
    if (_144 >= 0)
    goto _jump317;
    fail_assertion("negative array index");
    _jump317:;
    if (_144 < _105.d1)
    goto _jump318;
    fail_assertion("index too large");
    _jump318:;
    int64_t _145 = 0;
    _145 *= _105.d0;
    _145 += _124;
    _145 *= _105.d1;
    _145 += _144;
    _a3_bool _146 = _105.data[_145];
    bool _147 = false;
    int64_t _148;
    if (!_147)
    goto _jump319;
    int64_t _149 = 947;
    int64_t _150 = _149 + _81.d0;
    int64_t _151 = -_150;
    _148 = _151;
    goto _jump320;
    _jump319:;
    int64_t _152;
    // Computing bound for i
    if (_81.d0 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing bound for j
    if (_81.d0 > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    // Computing bound for k
    int64_t _153 = 573;
    if (_153 > 0) 
    goto _jump323;
    fail_assertion("non-positive loop bound");
    _jump323:;
    _152 = 0;
    int64_t _154 = 0; // k
    int64_t _155 = 0; // j
    int64_t _156 = 0; // i
    _jump324:; // Begin body of loop
    int64_t _157 = 472;
    int64_t _158 = _154 / _157;
    _152 += _158;
    _154++;
    if (_154 < _153)
    goto _jump324;
    _154 = 0;
    _155++;
    if (_155 < _81.d0)
    goto _jump324;
    _155 = 0;
    _156++;
    if (_156 < _81.d0)
    goto _jump324;
    // End body of loop
    _148 = _152;
    _jump320:;
    int64_t _159 = -_148;
    int64_t _160 = 448;
    _a3_bool _161;
    // Computing bound for i
    _161.d0 = c;
    if (c > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    // Computing bound for j
    int64_t _162 = 904;
    int64_t _163 = _162 % _81.d0;
    _161.d1 = _163;
    if (_163 > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing bound for k
    int64_t _164 = 451;
    _161.d2 = _164;
    if (_164 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= c;
    _165 *= _163;
    _165 *= _164;
    _165 *= sizeof(bool);
    _161.data = jpl_alloc(_165);
    int64_t _166 = 0; // k
    int64_t _167 = 0; // j
    int64_t _168 = 0; // i
    _jump328:; // Begin body of loop
    bool _169 = false;
    int64_t _170 = 0;
    _170 *= _161.d0;
    _170 += _168;
    _170 *= _161.d1;
    _170 += _167;
    _170 *= _161.d2;
    _170 += _166;
    _161.data[_170] = _169;
    _166++;
    if (_166 < _164)
    goto _jump328;
    _166 = 0;
    _167++;
    if (_167 < _163)
    goto _jump328;
    _167 = 0;
    _168++;
    if (_168 < c)
    goto _jump328;
    // End body of loop
    int64_t _171;
    if (!_0)
    goto _jump329;
    _171 = _81.d0;
    goto _jump330;
    _jump329:;
    _171 = _81.d0;
    _jump330:;
    int64_t _172;
    if (!_82)
    goto _jump331;
    _172 = c;
    goto _jump332;
    _jump331:;
    _172 = c;
    _jump332:;
    int64_t _173 = _171 * _172;
    if (_173 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (_173 < _161.d0)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    if (_81.d0 >= 0)
    goto _jump335;
    fail_assertion("negative array index");
    _jump335:;
    if (_81.d0 < _161.d1)
    goto _jump336;
    fail_assertion("index too large");
    _jump336:;
    if (c >= 0)
    goto _jump337;
    fail_assertion("negative array index");
    _jump337:;
    if (c < _161.d2)
    goto _jump338;
    fail_assertion("index too large");
    _jump338:;
    int64_t _174 = 0;
    _174 *= _161.d0;
    _174 += _173;
    _174 *= _161.d1;
    _174 += _81.d0;
    _174 *= _161.d2;
    _174 += c;
    bool _175 = _161.data[_174];
    int64_t _176;
    if (!_175)
    goto _jump339;
    int64_t _177 = 935;
    _176 = _177;
    goto _jump340;
    _jump339:;
    int64_t _178 = 80;
    _176 = _178;
    _jump340:;
    if (_159 >= 0)
    goto _jump341;
    fail_assertion("negative array index");
    _jump341:;
    if (_159 < _146.d0)
    goto _jump342;
    fail_assertion("index too large");
    _jump342:;
    if (_160 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (_160 < _146.d1)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (_176 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (_176 < _146.d2)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _179 = 0;
    _179 *= _146.d0;
    _179 += _159;
    _179 *= _146.d1;
    _179 += _160;
    _179 *= _146.d2;
    _179 += _176;
    bool _180 = _146.data[_179];
    _104 = _180;
    goto _jump347;
    _jump291:;
    _104 = _82;
    _jump347:;
    _103 = _104;
    goto _jump348;
    _jump290:;
    _a2_bool _181;
    // Computing bound for i
    int64_t _182;
    // Computing bound for i
    int64_t _183 = c + c;
    if (_183 > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing bound for j
    int64_t _184;
    // Computing bound for i
    if (_81.d0 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    _184 = 0;
    int64_t _185 = 0; // i
    _jump351:; // Begin body of loop
    int64_t _186 = 881;
    _184 += _186;
    _185++;
    if (_185 < _81.d0)
    goto _jump351;
    // End body of loop
    if (_184 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    // Computing bound for k
    if (_81.d0 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    _182 = 0;
    int64_t _187 = 0; // k
    int64_t _188 = 0; // j
    int64_t _189 = 0; // i
    _jump354:; // Begin body of loop
    _182 += _188;
    _187++;
    if (_187 < _81.d0)
    goto _jump354;
    _187 = 0;
    _188++;
    if (_188 < _184)
    goto _jump354;
    _188 = 0;
    _189++;
    if (_189 < _183)
    goto _jump354;
    // End body of loop
    _181.d0 = _182;
    if (_182 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing bound for j
    int64_t _190;
    if (!_82)
    goto _jump356;
    _190 = _81.d0;
    goto _jump357;
    _jump356:;
    bool _191 = d();
    int64_t _192;
    if (!_191)
    goto _jump358;
    _192 = c;
    goto _jump359;
    _jump358:;
    int64_t _193 = 68;
    _192 = _193;
    _jump359:;
    _190 = _192;
    _jump357:;
    _181.d1 = _190;
    if (_190 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= _182;
    _194 *= _190;
    _194 *= sizeof(bool);
    _181.data = jpl_alloc(_194);
    int64_t _195 = 0; // j
    int64_t _196 = 0; // i
    _jump361:; // Begin body of loop
    _a3_bool _197;
    // Computing bound for k
    int64_t _198 = 298;
    _197.d0 = _198;
    if (_198 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing bound for l
    _197.d1 = c;
    if (c > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for m
    _197.d2 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= _198;
    _199 *= c;
    _199 *= _81.d0;
    _199 *= sizeof(bool);
    _197.data = jpl_alloc(_199);
    int64_t _200 = 0; // m
    int64_t _201 = 0; // l
    int64_t _202 = 0; // k
    _jump365:; // Begin body of loop
    int64_t _203 = 0;
    _203 *= _197.d0;
    _203 += _202;
    _203 *= _197.d1;
    _203 += _201;
    _203 *= _197.d2;
    _203 += _200;
    _197.data[_203] = _0;
    _200++;
    if (_200 < _81.d0)
    goto _jump365;
    _200 = 0;
    _201++;
    if (_201 < c)
    goto _jump365;
    _201 = 0;
    _202++;
    if (_202 < _198)
    goto _jump365;
    // End body of loop
    int64_t _204 = 695;
    int64_t _205 = 124;
    if (_204 >= 0)
    goto _jump366;
    fail_assertion("negative array index");
    _jump366:;
    if (_204 < _197.d0)
    goto _jump367;
    fail_assertion("index too large");
    _jump367:;
    if (_195 >= 0)
    goto _jump368;
    fail_assertion("negative array index");
    _jump368:;
    if (_195 < _197.d1)
    goto _jump369;
    fail_assertion("index too large");
    _jump369:;
    if (_205 >= 0)
    goto _jump370;
    fail_assertion("negative array index");
    _jump370:;
    if (_205 < _197.d2)
    goto _jump371;
    fail_assertion("index too large");
    _jump371:;
    int64_t _206 = 0;
    _206 *= _197.d0;
    _206 += _204;
    _206 *= _197.d1;
    _206 += _195;
    _206 *= _197.d2;
    _206 += _205;
    bool _207 = _197.data[_206];
    int64_t _208 = 0;
    _208 *= _181.d0;
    _208 += _196;
    _208 *= _181.d1;
    _208 += _195;
    _181.data[_208] = _207;
    _195++;
    if (_195 < _190)
    goto _jump361;
    _195 = 0;
    _196++;
    if (_196 < _182)
    goto _jump361;
    // End body of loop
    int64_t _209 = -_81.d0;
    bool _210 = d();
    bool _211;
    if (!_210)
    goto _jump372;
    bool _212 = d();
    _211 = _212;
    goto _jump373;
    _jump372:;
    bool _213 = false;
    _211 = _213;
    _jump373:;
    int64_t _214;
    if (!_211)
    goto _jump374;
    int64_t _215 = 413;
    int64_t _216 = c - _215;
    _214 = _216;
    goto _jump375;
    _jump374:;
    bool _217 = d();
    int64_t _218;
    if (!_217)
    goto _jump376;
    _218 = _81.d0;
    goto _jump377;
    _jump376:;
    _218 = c;
    _jump377:;
    _214 = _218;
    _jump375:;
    int64_t _219 = _81.d0 - _214;
    if (_209 >= 0)
    goto _jump378;
    fail_assertion("negative array index");
    _jump378:;
    if (_209 < _181.d0)
    goto _jump379;
    fail_assertion("index too large");
    _jump379:;
    if (_219 >= 0)
    goto _jump380;
    fail_assertion("negative array index");
    _jump380:;
    if (_219 < _181.d1)
    goto _jump381;
    fail_assertion("index too large");
    _jump381:;
    int64_t _220 = 0;
    _220 *= _181.d0;
    _220 += _209;
    _220 *= _181.d1;
    _220 += _219;
    bool _221 = _181.data[_220];
    double _222;
    if (!_221)
    goto _jump382;
    double _223;
    // Computing bound for i
    int64_t _224 = 519;
    int64_t _225 = -_224;
    int64_t _226 = -_225;
    int64_t _227 = -_226;
    if (_227 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing bound for j
    int64_t _228 = 414;
    bool _229 = _228 <= _81.d0;
    int64_t _230;
    if (!_229)
    goto _jump384;
    _230 = _81.d0;
    goto _jump385;
    _jump384:;
    _230 = c;
    _jump385:;
    int64_t _231 = c / _230;
    if (_231 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing bound for k
    int64_t _232 = 502;
    int64_t _233 = c % _232;
    if (_233 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    _223 = 0;
    int64_t _234 = 0; // k
    int64_t _235 = 0; // j
    int64_t _236 = 0; // i
    _jump388:; // Begin body of loop
    double _237;
    // Computing bound for l
    if (_236 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing bound for m
    _a2_int64_t _238;
    // Computing bound for l
    _238.d0 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for m
    _238.d1 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing total size of heap memory to allocate
    int64_t _239 = 1;
    _239 *= _81.d0;
    _239 *= _81.d0;
    _239 *= sizeof(int64_t);
    _238.data = jpl_alloc(_239);
    int64_t _240 = 0; // m
    int64_t _241 = 0; // l
    _jump392:; // Begin body of loop
    int64_t _242 = 0;
    _242 *= _238.d0;
    _242 += _241;
    _242 *= _238.d1;
    _242 += _240;
    _238.data[_242] = _81.d0;
    _240++;
    if (_240 < _81.d0)
    goto _jump392;
    _240 = 0;
    _241++;
    if (_241 < _81.d0)
    goto _jump392;
    // End body of loop
    int64_t _243 = -_234;
    int64_t _244 = 584;
    if (_243 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_243 < _238.d0)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    if (_244 >= 0)
    goto _jump395;
    fail_assertion("negative array index");
    _jump395:;
    if (_244 < _238.d1)
    goto _jump396;
    fail_assertion("index too large");
    _jump396:;
    int64_t _245 = 0;
    _245 *= _238.d0;
    _245 += _243;
    _245 *= _238.d1;
    _245 += _244;
    int64_t _246 = _238.data[_245];
    if (_246 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing bound for n
    if (_236 > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    _237 = 0;
    int64_t _247 = 0; // n
    int64_t _248 = 0; // m
    int64_t _249 = 0; // l
    _jump399:; // Begin body of loop
    double _250;
    // Computing bound for o
    if (_235 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for p
    int64_t _251 = 758;
    if (_251 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for q
    int64_t _252;
    // Computing bound for o
    if (_234 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    _252 = 0;
    int64_t _253 = 0; // o
    _jump403:; // Begin body of loop
    _252 += _234;
    _253++;
    if (_253 < _234)
    goto _jump403;
    // End body of loop
    if (_252 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    _250 = 0;
    int64_t _254 = 0; // q
    int64_t _255 = 0; // p
    int64_t _256 = 0; // o
    _jump405:; // Begin body of loop
    double _257 = 39.0;
    double _258 = -_257;
    _250 += _258;
    _254++;
    if (_254 < _252)
    goto _jump405;
    _254 = 0;
    _255++;
    if (_255 < _251)
    goto _jump405;
    _255 = 0;
    _256++;
    if (_256 < _235)
    goto _jump405;
    // End body of loop
    _237 += _250;
    _247++;
    if (_247 < _236)
    goto _jump399;
    _247 = 0;
    _248++;
    if (_248 < _246)
    goto _jump399;
    _248 = 0;
    _249++;
    if (_249 < _236)
    goto _jump399;
    // End body of loop
    _223 += _237;
    _234++;
    if (_234 < _233)
    goto _jump388;
    _234 = 0;
    _235++;
    if (_235 < _231)
    goto _jump388;
    _235 = 0;
    _236++;
    if (_236 < _227)
    goto _jump388;
    // End body of loop
    _222 = _223;
    goto _jump406;
    _jump382:;
    double _259 = 94.0;
    double _260 = -_259;
    _222 = _260;
    _jump406:;
    bool _261 = d();
    double _262;
    if (!_261)
    goto _jump407;
    if (c >= 0)
    goto _jump408;
    fail_assertion("negative array index");
    _jump408:;
    if (c < b.d0)
    goto _jump409;
    fail_assertion("index too large");
    _jump409:;
    int64_t _263 = 0;
    _263 *= b.d0;
    _263 += c;
    double _264 = b.data[_263];
    double _265 = 44.0;
    double _266 = _264 * _265;
    _262 = _266;
    goto _jump410;
    _jump407:;
    double _267 = 75.0;
    _262 = _267;
    _jump410:;
    bool _268 = _222 == _262;
    _103 = _268;
    _jump348:;
    return _103;
    _a1__a1_bool _269;
    _269.d0 = 3;
    _269.data = jpl_alloc(sizeof(_a1_bool) * 3);
    _269.data[0] = _81;
    _269.data[1] = _81;
    _269.data[2] = _81;
    int64_t _270 = 467;
    int64_t _271 = 952;
    bool _272 = _270 < _271;
    bool _273 = !_272;
    int64_t _274;
    if (!_273)
    goto _jump411;
    int64_t _275 = 481;
    _274 = _275;
    goto _jump412;
    _jump411:;
    int64_t _276;
    // Computing bound for i
    int64_t _277 = c - _81.d0;
    if (_277 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing bound for j
    int64_t _278;
    // Computing bound for i
    bool _279 = !_0;
    int64_t _280;
    if (!_279)
    goto _jump414;
    _280 = _81.d0;
    goto _jump415;
    _jump414:;
    int64_t _281 = 333;
    int64_t _282 = -_281;
    _280 = _282;
    _jump415:;
    if (_280 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for j
    if (c > 0) 
    goto _jump417;
    fail_assertion("non-positive loop bound");
    _jump417:;
    // Computing bound for k
    bool _283 = d();
    int64_t _284;
    if (!_283)
    goto _jump418;
    int64_t _285;
    // Computing bound for i
    int64_t _286 = 286;
    if (_286 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    // Computing bound for j
    int64_t _287 = 484;
    if (_287 > 0) 
    goto _jump420;
    fail_assertion("non-positive loop bound");
    _jump420:;
    _285 = 0;
    int64_t _288 = 0; // j
    int64_t _289 = 0; // i
    _jump421:; // Begin body of loop
    int64_t _290 = 487;
    _285 += _290;
    _288++;
    if (_288 < _287)
    goto _jump421;
    _288 = 0;
    _289++;
    if (_289 < _286)
    goto _jump421;
    // End body of loop
    _284 = _285;
    goto _jump422;
    _jump418:;
    int64_t _291;
    // Computing bound for i
    bool _292 = d();
    int64_t _293;
    if (!_292)
    goto _jump423;
    int64_t _294 = 773;
    _293 = _294;
    goto _jump424;
    _jump423:;
    _293 = c;
    _jump424:;
    if (_293 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    _291 = 0;
    int64_t _295 = 0; // i
    _jump426:; // Begin body of loop
    _291 += c;
    _295++;
    if (_295 < _293)
    goto _jump426;
    // End body of loop
    _284 = _291;
    _jump422:;
    if (_284 > 0) 
    goto _jump427;
    fail_assertion("non-positive loop bound");
    _jump427:;
    _278 = 0;
    int64_t _296 = 0; // k
    int64_t _297 = 0; // j
    int64_t _298 = 0; // i
    _jump428:; // Begin body of loop
    int64_t _299 = 429;
    _278 += _299;
    _296++;
    if (_296 < _284)
    goto _jump428;
    _296 = 0;
    _297++;
    if (_297 < c)
    goto _jump428;
    _297 = 0;
    _298++;
    if (_298 < _280)
    goto _jump428;
    // End body of loop
    if (_278 > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    // Computing bound for k
    _a2_bool _300;
    // Computing bound for i
    _300.d0 = c;
    if (c > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing bound for j
    _300.d1 = _81.d0;
    if (_81.d0 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= c;
    _301 *= _81.d0;
    _301 *= sizeof(bool);
    _300.data = jpl_alloc(_301);
    int64_t _302 = 0; // j
    int64_t _303 = 0; // i
    _jump432:; // Begin body of loop
    int64_t _304 = 0;
    _304 *= _300.d0;
    _304 += _303;
    _304 *= _300.d1;
    _304 += _302;
    _300.data[_304] = _0;
    _302++;
    if (_302 < _81.d0)
    goto _jump432;
    _302 = 0;
    _303++;
    if (_303 < c)
    goto _jump432;
    // End body of loop
    int64_t _305 = -c;
    if (c >= 0)
    goto _jump433;
    fail_assertion("negative array index");
    _jump433:;
    if (c < _300.d0)
    goto _jump434;
    fail_assertion("index too large");
    _jump434:;
    if (_305 >= 0)
    goto _jump435;
    fail_assertion("negative array index");
    _jump435:;
    if (_305 < _300.d1)
    goto _jump436;
    fail_assertion("index too large");
    _jump436:;
    int64_t _306 = 0;
    _306 *= _300.d0;
    _306 += c;
    _306 *= _300.d1;
    _306 += _305;
    bool _307 = _300.data[_306];
    int64_t _308;
    if (!_307)
    goto _jump437;
    _308 = c;
    goto _jump438;
    _jump437:;
    int64_t _309;
    if (!_0)
    goto _jump439;
    _309 = _81.d0;
    goto _jump440;
    _jump439:;
    _309 = _81.d0;
    _jump440:;
    _308 = _309;
    _jump438:;
    int64_t _310 = -_308;
    if (_310 > 0) 
    goto _jump441;
    fail_assertion("non-positive loop bound");
    _jump441:;
    _276 = 0;
    int64_t _311 = 0; // k
    int64_t _312 = 0; // j
    int64_t _313 = 0; // i
    _jump442:; // Begin body of loop
    _276 += _311;
    _311++;
    if (_311 < _310)
    goto _jump442;
    _311 = 0;
    _312++;
    if (_312 < _278)
    goto _jump442;
    _312 = 0;
    _313++;
    if (_313 < _277)
    goto _jump442;
    // End body of loop
    _274 = _276;
    _jump412:;
    if (_274 >= 0)
    goto _jump443;
    fail_assertion("negative array index");
    _jump443:;
    if (_274 < _269.d0)
    goto _jump444;
    fail_assertion("index too large");
    _jump444:;
    int64_t _314 = 0;
    _314 *= _269.d0;
    _314 += _274;
    _a1_bool _315 = _269.data[_314];
    _a2_bool _316;
    // Computing bound for k
    int64_t _317 = 488;
    _316.d0 = _317;
    if (_317 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    // Computing bound for l
    int64_t _318 = -c;
    _316.d1 = _318;
    if (_318 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= _317;
    _319 *= _318;
    _319 *= sizeof(bool);
    _316.data = jpl_alloc(_319);
    int64_t _320 = 0; // l
    int64_t _321 = 0; // k
    _jump447:; // Begin body of loop
    double _322 = 99.0;
    double _323 = -_322;
    double _324;
    if (!_0)
    goto _jump448;
    double _325 = 80.0;
    _324 = _325;
    goto _jump449;
    _jump448:;
    bool _327 = d();
    bool _326 = _327;
    if (0 != _327)
    goto _jump450;
    _326 = _0;
    _jump450:;
    double _328;
    if (!_326)
    goto _jump451;
    int64_t _329 = 454;
    if (_329 >= 0)
    goto _jump452;
    fail_assertion("negative array index");
    _jump452:;
    if (_329 < b.d0)
    goto _jump453;
    fail_assertion("index too large");
    _jump453:;
    int64_t _330 = 0;
    _330 *= b.d0;
    _330 += _329;
    double _331 = b.data[_330];
    _328 = _331;
    goto _jump454;
    _jump451:;
    double _332 = 26.0;
    _328 = _332;
    _jump454:;
    double _333 = -_328;
    double _334 = -_333;
    _324 = _334;
    _jump449:;
    bool _335 = _323 == _324;
    int64_t _336 = 0;
    _336 *= _316.d0;
    _336 += _321;
    _336 *= _316.d1;
    _336 += _320;
    _316.data[_336] = _335;
    _320++;
    if (_320 < _318)
    goto _jump447;
    _320 = 0;
    _321++;
    if (_321 < _317)
    goto _jump447;
    // End body of loop
    bool _337 = false;
    return _337;
}

void_t w(a x) {
    bool _0 = true;
    if (0 != _0)
    goto _jump817;
    fail_assertion("y");
    _jump817:;
    double _1 = 81.0;
    double _2 = x.a;
    double _3 = fmod(_1, _2);
    double _4 = -_3;
    bool _5 = d();
    double _6;
    if (!_5)
    goto _jump818;
    double _7 = 8.0;
    _6 = _7;
    goto _jump819;
    _jump818:;
    double _8 = 99.0;
    _6 = _8;
    _jump819:;
    if (g >= 0)
    goto _jump820;
    fail_assertion("negative array index");
    _jump820:;
    if (g < q.d0)
    goto _jump821;
    fail_assertion("index too large");
    _jump821:;
    int64_t _9 = 0;
    _9 *= q.d0;
    _9 += g;
    double _10 = q.data[_9];
    double _11 = x.a;
    double _12;
    // Computing bound for y
    if (i > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    // Computing bound for z
    if (c > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    _12 = 0;
    int64_t _13 = 0; // z
    int64_t _14 = 0; // y
    _jump824:; // Begin body of loop
    double _15 = 3.0;
    _12 += _15;
    _13++;
    if (_13 < c)
    goto _jump824;
    _13 = 0;
    _14++;
    if (_14 < i)
    goto _jump824;
    // End body of loop
    double _16 = -_12;
    rgba _17 = { _6, _10, _11, _16 };
    double _18 = _17.r;
    double _19 = _4 + _18;
    double _20 = 7.0;
    bool _21 = _19 < _20;
    _a1_bool _22;
    _22.d0 = 3;
    _22.data = jpl_alloc(sizeof(bool) * 3);
    _22.data[0] = m;
    _22.data[1] = _21;
    _22.data[2] = k;
    double _23;
    // Computing bound for A
    if (_22.d0 > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    // Computing bound for B
    if (p > 0) 
    goto _jump826;
    fail_assertion("non-positive loop bound");
    _jump826:;
    // Computing bound for C
    if (r > 0) 
    goto _jump827;
    fail_assertion("non-positive loop bound");
    _jump827:;
    _23 = 0;
    int64_t _24 = 0; // C
    int64_t _25 = 0; // B
    int64_t _26 = 0; // A
    _jump828:; // Begin body of loop
    double _27;
    // Computing bound for D
    if (g > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    // Computing bound for E
    int64_t _28;
    // Computing bound for D
    bool _29 = d();
    int64_t _30;
    if (!_29)
    goto _jump830;
    _30 = i;
    goto _jump831;
    _jump830:;
    int64_t _31 = 186;
    _30 = _31;
    _jump831:;
    if (_30 > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    // Computing bound for E
    if (_24 > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for F
    if (p > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    _28 = 0;
    int64_t _32 = 0; // F
    int64_t _33 = 0; // E
    int64_t _34 = 0; // D
    _jump835:; // Begin body of loop
    int64_t _35 = 347;
    int64_t _36 = _35 / u;
    _28 += _36;
    _32++;
    if (_32 < p)
    goto _jump835;
    _32 = 0;
    _33++;
    if (_33 < _24)
    goto _jump835;
    _33 = 0;
    _34++;
    if (_34 < _30)
    goto _jump835;
    // End body of loop
    if (_28 > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    _27 = 0;
    int64_t _37 = 0; // E
    int64_t _38 = 0; // D
    _jump837:; // Begin body of loop
    double _39;
    if (!m)
    goto _jump838;
    double _40 = 91.0;
    _39 = _40;
    goto _jump839;
    _jump838:;
    double _41 = 25.0;
    double _42 = -_41;
    double _43 = -_42;
    double _44 = -_43;
    _39 = _44;
    _jump839:;
    _27 += _39;
    _37++;
    if (_37 < _28)
    goto _jump837;
    _37 = 0;
    _38++;
    if (_38 < g)
    goto _jump837;
    // End body of loop
    _23 += _27;
    _24++;
    if (_24 < r)
    goto _jump828;
    _24 = 0;
    _25++;
    if (_25 < p)
    goto _jump828;
    _25 = 0;
    _26++;
    if (_26 < _22.d0)
    goto _jump828;
    // End body of loop
    _a2__a3_void_t _45;
    // Computing bound for A
    bool _46 = !m;
    int64_t _47;
    if (!_46)
    goto _jump840;
    int64_t _48 = g * p;
    int64_t _49 = f / _48;
    _47 = _49;
    goto _jump841;
    _jump840:;
    _47 = g;
    _jump841:;
    _45.d0 = _47;
    if (_47 > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing bound for B
    _a3_int64_t _50 = x.c;
    if (o >= 0)
    goto _jump843;
    fail_assertion("negative array index");
    _jump843:;
    if (o < _50.d0)
    goto _jump844;
    fail_assertion("index too large");
    _jump844:;
    if (t >= 0)
    goto _jump845;
    fail_assertion("negative array index");
    _jump845:;
    if (t < _50.d1)
    goto _jump846;
    fail_assertion("index too large");
    _jump846:;
    if (g >= 0)
    goto _jump847;
    fail_assertion("negative array index");
    _jump847:;
    if (g < _50.d2)
    goto _jump848;
    fail_assertion("index too large");
    _jump848:;
    int64_t _51 = 0;
    _51 *= _50.d0;
    _51 += o;
    _51 *= _50.d1;
    _51 += t;
    _51 *= _50.d2;
    _51 += g;
    int64_t _52 = _50.data[_51];
    _45.d1 = _52;
    if (_52 > 0) 
    goto _jump849;
    fail_assertion("non-positive loop bound");
    _jump849:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= _47;
    _53 *= _52;
    _53 *= sizeof(_a3_void_t);
    _45.data = jpl_alloc(_53);
    int64_t _54 = 0; // B
    int64_t _55 = 0; // A
    _jump850:; // Begin body of loop
    _a3_void_t _56;
    // Computing bound for C
    _56.d0 = r;
    if (r > 0) 
    goto _jump851;
    fail_assertion("non-positive loop bound");
    _jump851:;
    // Computing bound for D
    _56.d1 = j;
    if (j > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for E
    _56.d2 = i;
    if (i > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= r;
    _57 *= j;
    _57 *= i;
    _57 *= sizeof(void_t);
    _56.data = jpl_alloc(_57);
    int64_t _58 = 0; // E
    int64_t _59 = 0; // D
    int64_t _60 = 0; // C
    _jump854:; // Begin body of loop
    void_t _61;
    if (!k)
    goto _jump855;
    void_t _62 = x.b;
    _61 = _62;
    goto _jump856;
    _jump855:;
    void_t _63 = x.b;
    _61 = _63;
    _jump856:;
    int64_t _64 = 0;
    _64 *= _56.d0;
    _64 += _60;
    _64 *= _56.d1;
    _64 += _59;
    _64 *= _56.d2;
    _64 += _58;
    _56.data[_64] = _61;
    _58++;
    if (_58 < i)
    goto _jump854;
    _58 = 0;
    _59++;
    if (_59 < j)
    goto _jump854;
    _59 = 0;
    _60++;
    if (_60 < r)
    goto _jump854;
    // End body of loop
    int64_t _65 = 0;
    _65 *= _45.d0;
    _65 += _55;
    _65 *= _45.d1;
    _65 += _54;
    _45.data[_65] = _56;
    _54++;
    if (_54 < _52)
    goto _jump850;
    _54 = 0;
    _55++;
    if (_55 < _47)
    goto _jump850;
    // End body of loop
    bool _66 = d();
    _a2_bool _67;
    if (!_66)
    goto _jump857;
    _67 = h;
    goto _jump858;
    _jump857:;
    _67 = n;
    _jump858:;
    int64_t _68 = -o;
    int64_t _69 = 495;
    if (_68 >= 0)
    goto _jump859;
    fail_assertion("negative array index");
    _jump859:;
    if (_68 < _67.d0)
    goto _jump860;
    fail_assertion("index too large");
    _jump860:;
    if (_69 >= 0)
    goto _jump861;
    fail_assertion("negative array index");
    _jump861:;
    if (_69 < _67.d1)
    goto _jump862;
    fail_assertion("index too large");
    _jump862:;
    int64_t _70 = 0;
    _70 *= _67.d0;
    _70 += _68;
    _70 *= _67.d1;
    _70 += _69;
    bool _71 = _67.data[_70];
    _a1_int64_t _72;
    if (!_71)
    goto _jump863;
    _a1_int64_t _73;
    // Computing bound for A
    _73.d0 = p;
    if (p > 0) 
    goto _jump864;
    fail_assertion("non-positive loop bound");
    _jump864:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= p;
    _74 *= sizeof(int64_t);
    _73.data = jpl_alloc(_74);
    int64_t _75 = 0; // A
    _jump865:; // Begin body of loop
    int64_t _76 = 0;
    _76 *= _73.d0;
    _76 += _75;
    _73.data[_76] = _22.d0;
    _75++;
    if (_75 < p)
    goto _jump865;
    // End body of loop
    _72 = _73;
    goto _jump866;
    _jump863:;
    _a1_int64_t _77;
    if (!k)
    goto _jump867;
    _a1_int64_t _78;
    // Computing bound for A
    _78.d0 = i;
    if (i > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= i;
    _79 *= sizeof(int64_t);
    _78.data = jpl_alloc(_79);
    int64_t _80 = 0; // A
    _jump869:; // Begin body of loop
    int64_t _81 = 0;
    _81 *= _78.d0;
    _81 += _80;
    _78.data[_81] = o;
    _80++;
    if (_80 < i)
    goto _jump869;
    // End body of loop
    _77 = _78;
    goto _jump870;
    _jump867:;
    _a1_int64_t _82;
    // Computing bound for A
    _82.d0 = u;
    if (u > 0) 
    goto _jump871;
    fail_assertion("non-positive loop bound");
    _jump871:;
    // Computing total size of heap memory to allocate
    int64_t _83 = 1;
    _83 *= u;
    _83 *= sizeof(int64_t);
    _82.data = jpl_alloc(_83);
    int64_t _84 = 0; // A
    _jump872:; // Begin body of loop
    int64_t _85 = 0;
    _85 *= _82.d0;
    _85 += _84;
    _82.data[_85] = o;
    _84++;
    if (_84 < u)
    goto _jump872;
    // End body of loop
    _77 = _82;
    _jump870:;
    _72 = _77;
    _jump866:;
    if (g >= 0)
    goto _jump873;
    fail_assertion("negative array index");
    _jump873:;
    if (g < _72.d0)
    goto _jump874;
    fail_assertion("index too large");
    _jump874:;
    int64_t _86 = 0;
    _86 *= _72.d0;
    _86 += g;
    int64_t _87 = _72.data[_86];
    if (_87 >= 0)
    goto _jump875;
    fail_assertion("negative array index");
    _jump875:;
    if (_87 < _45.d0)
    goto _jump876;
    fail_assertion("index too large");
    _jump876:;
    if (i >= 0)
    goto _jump877;
    fail_assertion("negative array index");
    _jump877:;
    if (i < _45.d1)
    goto _jump878;
    fail_assertion("index too large");
    _jump878:;
    int64_t _88 = 0;
    _88 *= _45.d0;
    _88 += _87;
    _88 *= _45.d1;
    _88 += i;
    _a3_void_t _89 = _45.data[_88];
    if (i >= 0)
    goto _jump879;
    fail_assertion("negative array index");
    _jump879:;
    if (i < _89.d0)
    goto _jump880;
    fail_assertion("index too large");
    _jump880:;
    if (t >= 0)
    goto _jump881;
    fail_assertion("negative array index");
    _jump881:;
    if (t < _89.d1)
    goto _jump882;
    fail_assertion("index too large");
    _jump882:;
    if (f >= 0)
    goto _jump883;
    fail_assertion("negative array index");
    _jump883:;
    if (f < _89.d2)
    goto _jump884;
    fail_assertion("index too large");
    _jump884:;
    int64_t _90 = 0;
    _90 *= _89.d0;
    _90 += i;
    _90 *= _89.d1;
    _90 += t;
    _90 *= _89.d2;
    _90 += f;
    void_t _91 = _89.data[_90];
    _a3_int64_t _92 = x.c;
    a _93 = { _23, _91, _92 };
    _a3_int64_t _94;
    // Computing bound for B
    _a2_int64_t _95;
    // Computing bound for B
    int64_t _96 = -f;
    _95.d0 = _96;
    if (_96 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing bound for C
    _95.d1 = t;
    if (t > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= _96;
    _97 *= t;
    _97 *= sizeof(int64_t);
    _95.data = jpl_alloc(_97);
    int64_t _98 = 0; // C
    int64_t _99 = 0; // B
    _jump887:; // Begin body of loop
    bool _100 = d();
    int64_t _101;
    if (!_100)
    goto _jump888;
    _101 = p;
    goto _jump889;
    _jump888:;
    _101 = _22.d0;
    _jump889:;
    int64_t _102 = 0;
    _102 *= _95.d0;
    _102 += _99;
    _102 *= _95.d1;
    _102 += _98;
    _95.data[_102] = _101;
    _98++;
    if (_98 < t)
    goto _jump887;
    _98 = 0;
    _99++;
    if (_99 < _96)
    goto _jump887;
    // End body of loop
    if (i >= 0)
    goto _jump890;
    fail_assertion("negative array index");
    _jump890:;
    if (i < _95.d0)
    goto _jump891;
    fail_assertion("index too large");
    _jump891:;
    if (p >= 0)
    goto _jump892;
    fail_assertion("negative array index");
    _jump892:;
    if (p < _95.d1)
    goto _jump893;
    fail_assertion("index too large");
    _jump893:;
    int64_t _103 = 0;
    _103 *= _95.d0;
    _103 += i;
    _103 *= _95.d1;
    _103 += p;
    int64_t _104 = _95.data[_103];
    _94.d0 = _104;
    if (_104 > 0) 
    goto _jump894;
    fail_assertion("non-positive loop bound");
    _jump894:;
    // Computing bound for C
    _94.d1 = g;
    if (g > 0) 
    goto _jump895;
    fail_assertion("non-positive loop bound");
    _jump895:;
    // Computing bound for D
    int64_t _105;
    // Computing bound for B
    if (u > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    // Computing bound for C
    int64_t _106;
    if (!k)
    goto _jump897;
    _106 = _22.d0;
    goto _jump898;
    _jump897:;
    _106 = i;
    _jump898:;
    if (_106 > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    // Computing bound for D
    if (u > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    _105 = 0;
    int64_t _107 = 0; // D
    int64_t _108 = 0; // C
    int64_t _109 = 0; // B
    _jump901:; // Begin body of loop
    _105 += g;
    _107++;
    if (_107 < u)
    goto _jump901;
    _107 = 0;
    _108++;
    if (_108 < _106)
    goto _jump901;
    _108 = 0;
    _109++;
    if (_109 < u)
    goto _jump901;
    // End body of loop
    int64_t _110 = -_105;
    _94.d2 = _110;
    if (_110 > 0) 
    goto _jump902;
    fail_assertion("non-positive loop bound");
    _jump902:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= _104;
    _111 *= g;
    _111 *= _110;
    _111 *= sizeof(int64_t);
    _94.data = jpl_alloc(_111);
    int64_t _112 = 0; // D
    int64_t _113 = 0; // C
    int64_t _114 = 0; // B
    _jump903:; // Begin body of loop
    int64_t _115 = 0;
    _115 *= _94.d0;
    _115 += _114;
    _115 *= _94.d1;
    _115 += _113;
    _115 *= _94.d2;
    _115 += _112;
    _94.data[_115] = _22.d0;
    _112++;
    if (_112 < _110)
    goto _jump903;
    _112 = 0;
    _113++;
    if (_113 < g)
    goto _jump903;
    _113 = 0;
    _114++;
    if (_114 < _104)
    goto _jump903;
    // End body of loop
    _a3__a1__a1_double _116;
    // Computing bound for F
    _116.d0 = _22.d0;
    if (_22.d0 > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for G
    _116.d1 = u;
    if (u > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for H
    _116.d2 = i;
    if (i > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= _22.d0;
    _117 *= u;
    _117 *= i;
    _117 *= sizeof(_a1__a1_double);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // H
    int64_t _119 = 0; // G
    int64_t _120 = 0; // F
    _jump907:; // Begin body of loop
    _a1_double _121;
    // Computing bound for I
    _121.d0 = _119;
    if (_119 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _119;
    _122 *= sizeof(double);
    _121.data = jpl_alloc(_122);
    int64_t _123 = 0; // I
    _jump909:; // Begin body of loop
    double _124;
    // Computing bound for J
    if (r > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for K
    if (_120 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing bound for L
    if (c > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    _124 = 0;
    int64_t _125 = 0; // L
    int64_t _126 = 0; // K
    int64_t _127 = 0; // J
    _jump913:; // Begin body of loop
    double _128 = 52.0;
    _124 += _128;
    _125++;
    if (_125 < c)
    goto _jump913;
    _125 = 0;
    _126++;
    if (_126 < _120)
    goto _jump913;
    _126 = 0;
    _127++;
    if (_127 < r)
    goto _jump913;
    // End body of loop
    int64_t _129 = 0;
    _129 *= _121.d0;
    _129 += _123;
    _121.data[_129] = _124;
    _123++;
    if (_123 < _119)
    goto _jump909;
    // End body of loop
    _a1__a1_double _130;
    _130.d0 = 3;
    _130.data = jpl_alloc(sizeof(_a1_double) * 3);
    _130.data[0] = b;
    _130.data[1] = _121;
    _130.data[2] = b;
    int64_t _131 = 0;
    _131 *= _116.d0;
    _131 += _120;
    _131 *= _116.d1;
    _131 += _119;
    _131 *= _116.d2;
    _131 += _118;
    _116.data[_131] = _130;
    _118++;
    if (_118 < i)
    goto _jump907;
    _118 = 0;
    _119++;
    if (_119 < u)
    goto _jump907;
    _119 = 0;
    _120++;
    if (_120 < _22.d0)
    goto _jump907;
    // End body of loop
    if (c >= 0)
    goto _jump914;
    fail_assertion("negative array index");
    _jump914:;
    if (c < _116.d0)
    goto _jump915;
    fail_assertion("index too large");
    _jump915:;
    if (j >= 0)
    goto _jump916;
    fail_assertion("negative array index");
    _jump916:;
    if (j < _116.d1)
    goto _jump917;
    fail_assertion("index too large");
    _jump917:;
    if (_94.d2 >= 0)
    goto _jump918;
    fail_assertion("negative array index");
    _jump918:;
    if (_94.d2 < _116.d2)
    goto _jump919;
    fail_assertion("index too large");
    _jump919:;
    int64_t _132 = 0;
    _132 *= _116.d0;
    _132 += c;
    _132 *= _116.d1;
    _132 += j;
    _132 *= _116.d2;
    _132 += _94.d2;
    _a1__a1_double _133 = _116.data[_132];
    _a1_bool _134;
    // Computing bound for H
    _a2__a1_int64_t _135;
    // Computing bound for H
    _135.d0 = c;
    if (c > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for I
    _135.d1 = _94.d2;
    if (_94.d2 > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= c;
    _136 *= _94.d2;
    _136 *= sizeof(_a1_int64_t);
    _135.data = jpl_alloc(_136);
    int64_t _137 = 0; // I
    int64_t _138 = 0; // H
    _jump922:; // Begin body of loop
    int64_t _139 = -t;
    int64_t _140 = -f;
    _a1_int64_t _141;
    _141.d0 = 3;
    _141.data = jpl_alloc(sizeof(int64_t) * 3);
    _141.data[0] = _139;
    _141.data[1] = _140;
    _141.data[2] = _137;
    int64_t _142 = 0;
    _142 *= _135.d0;
    _142 += _138;
    _142 *= _135.d1;
    _142 += _137;
    _135.data[_142] = _141;
    _137++;
    if (_137 < _94.d2)
    goto _jump922;
    _137 = 0;
    _138++;
    if (_138 < c)
    goto _jump922;
    // End body of loop
    int64_t _143 = 601;
    if (_143 >= 0)
    goto _jump923;
    fail_assertion("negative array index");
    _jump923:;
    if (_143 < _135.d0)
    goto _jump924;
    fail_assertion("index too large");
    _jump924:;
    if (j >= 0)
    goto _jump925;
    fail_assertion("negative array index");
    _jump925:;
    if (j < _135.d1)
    goto _jump926;
    fail_assertion("index too large");
    _jump926:;
    int64_t _144 = 0;
    _144 *= _135.d0;
    _144 += _143;
    _144 *= _135.d1;
    _144 += j;
    _a1_int64_t _145 = _135.data[_144];
    if (j >= 0)
    goto _jump927;
    fail_assertion("negative array index");
    _jump927:;
    if (j < _145.d0)
    goto _jump928;
    fail_assertion("index too large");
    _jump928:;
    int64_t _146 = 0;
    _146 *= _145.d0;
    _146 += j;
    int64_t _147 = _145.data[_146];
    _134.d0 = _147;
    if (_147 > 0) 
    goto _jump929;
    fail_assertion("non-positive loop bound");
    _jump929:;
    // Computing total size of heap memory to allocate
    int64_t _148 = 1;
    _148 *= _147;
    _148 *= sizeof(bool);
    _134.data = jpl_alloc(_148);
    int64_t _149 = 0; // H
    _jump930:; // Begin body of loop
    int64_t _150;
    // Computing bound for I
    if (_149 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for J
    _a1_int64_t _151;
    // Computing bound for I
    bool _152 = d();
    bool _153 = k == _152;
    int64_t _154;
    if (!_153)
    goto _jump932;
    _154 = f;
    goto _jump933;
    _jump932:;
    _154 = _94.d1;
    _jump933:;
    _151.d0 = _154;
    if (_154 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= _154;
    _155 *= sizeof(int64_t);
    _151.data = jpl_alloc(_155);
    int64_t _156 = 0; // I
    _jump935:; // Begin body of loop
    int64_t _157 = 0;
    _157 *= _151.d0;
    _157 += _156;
    _151.data[_157] = u;
    _156++;
    if (_156 < _154)
    goto _jump935;
    // End body of loop
    int64_t _158;
    // Computing bound for I
    bool _159 = !m;
    int64_t _160;
    if (!_159)
    goto _jump936;
    _160 = i;
    goto _jump937;
    _jump936:;
    _160 = _94.d1;
    _jump937:;
    if (_160 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    _158 = 0;
    int64_t _161 = 0; // I
    _jump939:; // Begin body of loop
    _158 += c;
    _161++;
    if (_161 < _160)
    goto _jump939;
    // End body of loop
    if (_158 >= 0)
    goto _jump940;
    fail_assertion("negative array index");
    _jump940:;
    if (_158 < _151.d0)
    goto _jump941;
    fail_assertion("index too large");
    _jump941:;
    int64_t _162 = 0;
    _162 *= _151.d0;
    _162 += _158;
    int64_t _163 = _151.data[_162];
    if (_163 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    _150 = 0;
    int64_t _164 = 0; // J
    int64_t _165 = 0; // I
    _jump943:; // Begin body of loop
    bool _166 = false;
    _a2_int64_t _167;
    if (!_166)
    goto _jump944;
    _a2_int64_t _168;
    // Computing bound for K
    _168.d0 = f;
    if (f > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    // Computing bound for L
    _168.d1 = r;
    if (r > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= f;
    _169 *= r;
    _169 *= sizeof(int64_t);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // L
    int64_t _171 = 0; // K
    _jump947:; // Begin body of loop
    int64_t _172 = 0;
    _172 *= _168.d0;
    _172 += _171;
    _172 *= _168.d1;
    _172 += _170;
    _168.data[_172] = _171;
    _170++;
    if (_170 < r)
    goto _jump947;
    _170 = 0;
    _171++;
    if (_171 < f)
    goto _jump947;
    // End body of loop
    _167 = _168;
    goto _jump948;
    _jump944:;
    _a2_int64_t _173;
    // Computing bound for K
    _173.d0 = f;
    if (f > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    // Computing bound for L
    _173.d1 = _149;
    if (_149 > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing total size of heap memory to allocate
    int64_t _174 = 1;
    _174 *= f;
    _174 *= _149;
    _174 *= sizeof(int64_t);
    _173.data = jpl_alloc(_174);
    int64_t _175 = 0; // L
    int64_t _176 = 0; // K
    _jump951:; // Begin body of loop
    int64_t _177 = 0;
    _177 *= _173.d0;
    _177 += _176;
    _177 *= _173.d1;
    _177 += _175;
    _173.data[_177] = t;
    _175++;
    if (_175 < _149)
    goto _jump951;
    _175 = 0;
    _176++;
    if (_176 < f)
    goto _jump951;
    // End body of loop
    _167 = _173;
    _jump948:;
    if (g >= 0)
    goto _jump952;
    fail_assertion("negative array index");
    _jump952:;
    if (g < _167.d0)
    goto _jump953;
    fail_assertion("index too large");
    _jump953:;
    if (j >= 0)
    goto _jump954;
    fail_assertion("negative array index");
    _jump954:;
    if (j < _167.d1)
    goto _jump955;
    fail_assertion("index too large");
    _jump955:;
    int64_t _178 = 0;
    _178 *= _167.d0;
    _178 += g;
    _178 *= _167.d1;
    _178 += j;
    int64_t _179 = _167.data[_178];
    _150 += _179;
    _164++;
    if (_164 < _163)
    goto _jump943;
    _164 = 0;
    _165++;
    if (_165 < _149)
    goto _jump943;
    // End body of loop
    bool _180 = p > _150;
    int64_t _181 = 0;
    _181 *= _134.d0;
    _181 += _149;
    _134.data[_181] = _180;
    _149++;
    if (_149 < _147)
    goto _jump930;
    // End body of loop
    void_t _182 = {};
    return _182;
}

void_t I() {
    _a3_C _0;
    // Computing bound for J
    bool _1 = false;
    _a1_int64_t _2;
    if (!_1)
    goto _jump984;
    int64_t _3;
    if (!k)
    goto _jump985;
    _3 = j;
    goto _jump986;
    _jump985:;
    _3 = t;
    _jump986:;
    int64_t _4;
    // Computing bound for J
    if (B > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    _4 = 0;
    int64_t _5 = 0; // J
    _jump988:; // Begin body of loop
    _4 += p;
    _5++;
    if (_5 < B)
    goto _jump988;
    // End body of loop
    _a1_int64_t _6;
    _6.d0 = 2;
    _6.data = jpl_alloc(sizeof(int64_t) * 2);
    _6.data[0] = _3;
    _6.data[1] = _4;
    _2 = _6;
    goto _jump989;
    _jump984:;
    int64_t _7;
    // Computing bound for J
    if (F > 0) 
    goto _jump990;
    fail_assertion("non-positive loop bound");
    _jump990:;
    // Computing bound for K
    if (t > 0) 
    goto _jump991;
    fail_assertion("non-positive loop bound");
    _jump991:;
    _7 = 0;
    int64_t _8 = 0; // K
    int64_t _9 = 0; // J
    _jump992:; // Begin body of loop
    _7 += H;
    _8++;
    if (_8 < t)
    goto _jump992;
    _8 = 0;
    _9++;
    if (_9 < F)
    goto _jump992;
    // End body of loop
    _a1_int64_t _10;
    _10.d0 = 1;
    _10.data = jpl_alloc(sizeof(int64_t) * 1);
    _10.data[0] = _7;
    _2 = _10;
    _jump989:;
    if (g >= 0)
    goto _jump993;
    fail_assertion("negative array index");
    _jump993:;
    if (g < _2.d0)
    goto _jump994;
    fail_assertion("index too large");
    _jump994:;
    int64_t _11 = 0;
    _11 *= _2.d0;
    _11 += g;
    int64_t _12 = _2.data[_11];
    _0.d0 = _12;
    if (_12 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for K
    int64_t _13 = c + A;
    _0.d1 = _13;
    if (_13 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing bound for L
    _0.d2 = o;
    if (o > 0) 
    goto _jump997;
    fail_assertion("non-positive loop bound");
    _jump997:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _12;
    _14 *= _13;
    _14 *= o;
    _14 *= sizeof(C);
    _0.data = jpl_alloc(_14);
    int64_t _15 = 0; // L
    int64_t _16 = 0; // K
    int64_t _17 = 0; // J
    _jump998:; // Begin body of loop
    if (t >= 0)
    goto _jump999;
    fail_assertion("negative array index");
    _jump999:;
    if (t < b.d0)
    goto _jump1000;
    fail_assertion("index too large");
    _jump1000:;
    int64_t _18 = 0;
    _18 *= b.d0;
    _18 += t;
    double _19 = b.data[_18];
    double _20 = 37.0;
    int64_t _21 = 892;
    if (_21 >= 0)
    goto _jump1001;
    fail_assertion("negative array index");
    _jump1001:;
    if (_21 < q.d0)
    goto _jump1002;
    fail_assertion("index too large");
    _jump1002:;
    int64_t _22 = 0;
    _22 *= q.d0;
    _22 += _21;
    double _23 = q.data[_22];
    double _24 = _20 + _23;
    double _25;
    // Computing bound for M
    int64_t _26;
    // Computing bound for M
    if (H > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    _26 = 0;
    int64_t _27 = 0; // M
    _jump1004:; // Begin body of loop
    _26 += B;
    _27++;
    if (_27 < H)
    goto _jump1004;
    // End body of loop
    if (_26 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing bound for N
    int64_t _28 = 871;
    if (_28 > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    // Computing bound for O
    int64_t _29;
    // Computing bound for M
    int64_t _30 = 945;
    if (_30 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for N
    if (_17 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for O
    if (_15 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    _29 = 0;
    int64_t _31 = 0; // O
    int64_t _32 = 0; // N
    int64_t _33 = 0; // M
    _jump1010:; // Begin body of loop
    _29 += _31;
    _31++;
    if (_31 < _15)
    goto _jump1010;
    _31 = 0;
    _32++;
    if (_32 < _17)
    goto _jump1010;
    _32 = 0;
    _33++;
    if (_33 < _30)
    goto _jump1010;
    // End body of loop
    if (_29 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    _25 = 0;
    int64_t _34 = 0; // O
    int64_t _35 = 0; // N
    int64_t _36 = 0; // M
    _jump1012:; // Begin body of loop
    double _37 = 62.0;
    _25 += _37;
    _34++;
    if (_34 < _29)
    goto _jump1012;
    _34 = 0;
    _35++;
    if (_35 < _28)
    goto _jump1012;
    _35 = 0;
    _36++;
    if (_36 < _26)
    goto _jump1012;
    // End body of loop
    y _38 = { _19, _24, _25 };
    void_t _39 = I();
    C _40 = { _38, _39 };
    int64_t _41 = 0;
    _41 *= _0.d0;
    _41 += _17;
    _41 *= _0.d1;
    _41 += _16;
    _41 *= _0.d2;
    _41 += _15;
    _0.data[_41] = _40;
    _15++;
    if (_15 < o)
    goto _jump998;
    _15 = 0;
    _16++;
    if (_16 < _13)
    goto _jump998;
    _16 = 0;
    _17++;
    if (_17 < _12)
    goto _jump998;
    // End body of loop
    int64_t _42 = p - g;
    if (_42 >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (_42 < _0.d0)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    if (B >= 0)
    goto _jump1015;
    fail_assertion("negative array index");
    _jump1015:;
    if (B < _0.d1)
    goto _jump1016;
    fail_assertion("index too large");
    _jump1016:;
    if (u >= 0)
    goto _jump1017;
    fail_assertion("negative array index");
    _jump1017:;
    if (u < _0.d2)
    goto _jump1018;
    fail_assertion("index too large");
    _jump1018:;
    int64_t _43 = 0;
    _43 *= _0.d0;
    _43 += _42;
    _43 *= _0.d1;
    _43 += B;
    _43 *= _0.d2;
    _43 += u;
    C _44 = _0.data[_43];
    void_t _45 = _44.b;
    return _45;
    double _46;
    // Computing bound for P
    if (E > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing bound for Q
    if (n.d1 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    _46 = 0;
    int64_t _47 = 0; // Q
    int64_t _48 = 0; // P
    _jump1021:; // Begin body of loop
    double _49 = 60.0;
    _46 += _49;
    _47++;
    if (_47 < n.d1)
    goto _jump1021;
    _47 = 0;
    _48++;
    if (_48 < E)
    goto _jump1021;
    // End body of loop
    double _50 = 55.0;
    double _51 = 5.0;
    double _52;
    if (!m)
    goto _jump1022;
    if (j >= 0)
    goto _jump1023;
    fail_assertion("negative array index");
    _jump1023:;
    if (j < q.d0)
    goto _jump1024;
    fail_assertion("index too large");
    _jump1024:;
    int64_t _53 = 0;
    _53 *= q.d0;
    _53 += j;
    double _54 = q.data[_53];
    _52 = _54;
    goto _jump1025;
    _jump1022:;
    double _55 = 31.0;
    double _56 = -_55;
    _52 = _56;
    _jump1025:;
    double _57;
    // Computing bound for P
    int64_t _58 = 677;
    if (_58 > 0) 
    goto _jump1026;
    fail_assertion("non-positive loop bound");
    _jump1026:;
    // Computing bound for Q
    if (A > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    _57 = 0;
    int64_t _59 = 0; // Q
    int64_t _60 = 0; // P
    _jump1028:; // Begin body of loop
    double _61 = 4.0;
    _57 += _61;
    _59++;
    if (_59 < A)
    goto _jump1028;
    _59 = 0;
    _60++;
    if (_60 < _58)
    goto _jump1028;
    // End body of loop
    double _62 = 7.0;
    y _63 = { _52, _57, _62 };
    double _64 = _63.a;
    double _65 = _51 / _64;
    double _66 = 36.0;
    double _67 = 18.0;
    double _68 = _66 + _67;
    double _69 = -_68;
    double _70 = _65 - _69;
    y _71 = { _46, _50, _70 };
    _a1_bool _72;
    // Computing bound for Q
    _72.d0 = o;
    if (o > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    // Computing total size of heap memory to allocate
    int64_t _73 = 1;
    _73 *= o;
    _73 *= sizeof(bool);
    _72.data = jpl_alloc(_73);
    int64_t _74 = 0; // Q
    _jump1030:; // Begin body of loop
    int64_t _75 = 0;
    _75 *= _72.d0;
    _75 += _74;
    _72.data[_75] = m;
    _74++;
    if (_74 < o)
    goto _jump1030;
    // End body of loop
    if (E >= 0)
    goto _jump1031;
    fail_assertion("negative array index");
    _jump1031:;
    if (E < _72.d0)
    goto _jump1032;
    fail_assertion("index too large");
    _jump1032:;
    int64_t _76 = 0;
    _76 *= _72.d0;
    _76 += E;
    bool _77 = _72.data[_76];
    _a2_void_t _78;
    if (!_77)
    goto _jump1033;
    bool _80 = d();
    bool _79 = _80;
    if (0 == _80)
    goto _jump1034;
    bool _81 = F <= E;
    _79 = _81;
    _jump1034:;
    _a2_void_t _82;
    if (!_79)
    goto _jump1035;
    bool _83 = false;
    _a1_bool _84;
    if (!_83)
    goto _jump1036;
    bool _85 = d();
    _a1_bool _86;
    _86.d0 = 2;
    _86.data = jpl_alloc(sizeof(bool) * 2);
    _86.data[0] = _85;
    _86.data[1] = k;
    _84 = _86;
    goto _jump1037;
    _jump1036:;
    _a1_bool _87;
    // Computing bound for Q
    _87.d0 = t;
    if (t > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= t;
    _88 *= sizeof(bool);
    _87.data = jpl_alloc(_88);
    int64_t _89 = 0; // Q
    _jump1039:; // Begin body of loop
    int64_t _90 = 0;
    _90 *= _87.d0;
    _90 += _89;
    _87.data[_90] = k;
    _89++;
    if (_89 < t)
    goto _jump1039;
    // End body of loop
    _84 = _87;
    _jump1037:;
    if (j >= 0)
    goto _jump1040;
    fail_assertion("negative array index");
    _jump1040:;
    if (j < _84.d0)
    goto _jump1041;
    fail_assertion("index too large");
    _jump1041:;
    int64_t _91 = 0;
    _91 *= _84.d0;
    _91 += j;
    bool _92 = _84.data[_91];
    _a2_void_t _93;
    if (!_92)
    goto _jump1042;
    _a2_void_t _94;
    if (!m)
    goto _jump1043;
    _a2_void_t _95;
    // Computing bound for Q
    _95.d0 = t;
    if (t > 0) 
    goto _jump1044;
    fail_assertion("non-positive loop bound");
    _jump1044:;
    // Computing bound for R
    int64_t _96 = -n.d1;
    _95.d1 = _96;
    if (_96 > 0) 
    goto _jump1045;
    fail_assertion("non-positive loop bound");
    _jump1045:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= t;
    _97 *= _96;
    _97 *= sizeof(void_t);
    _95.data = jpl_alloc(_97);
    int64_t _98 = 0; // R
    int64_t _99 = 0; // Q
    _jump1046:; // Begin body of loop
    void_t _100 = I();
    int64_t _101 = 0;
    _101 *= _95.d0;
    _101 += _99;
    _101 *= _95.d1;
    _101 += _98;
    _95.data[_101] = _100;
    _98++;
    if (_98 < _96)
    goto _jump1046;
    _98 = 0;
    _99++;
    if (_99 < t)
    goto _jump1046;
    // End body of loop
    _94 = _95;
    goto _jump1047;
    _jump1043:;
    _a2_void_t _102;
    // Computing bound for Q
    _102.d0 = r;
    if (r > 0) 
    goto _jump1048;
    fail_assertion("non-positive loop bound");
    _jump1048:;
    // Computing bound for R
    _102.d1 = n.d1;
    if (n.d1 > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= r;
    _103 *= n.d1;
    _103 *= sizeof(void_t);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // R
    int64_t _105 = 0; // Q
    _jump1050:; // Begin body of loop
    void_t _106 = I();
    int64_t _107 = 0;
    _107 *= _102.d0;
    _107 += _105;
    _107 *= _102.d1;
    _107 += _104;
    _102.data[_107] = _106;
    _104++;
    if (_104 < n.d1)
    goto _jump1050;
    _104 = 0;
    _105++;
    if (_105 < r)
    goto _jump1050;
    // End body of loop
    _94 = _102;
    _jump1047:;
    _93 = _94;
    goto _jump1051;
    _jump1042:;
    _a2_void_t _108;
    // Computing bound for Q
    _108.d0 = g;
    if (g > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing bound for R
    _108.d1 = F;
    if (F > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= g;
    _109 *= F;
    _109 *= sizeof(void_t);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // R
    int64_t _111 = 0; // Q
    _jump1054:; // Begin body of loop
    void_t _112;
    if (!k)
    goto _jump1055;
    void_t _113 = I();
    _112 = _113;
    goto _jump1056;
    _jump1055:;
    void_t _114 = I();
    _112 = _114;
    _jump1056:;
    int64_t _115 = 0;
    _115 *= _108.d0;
    _115 += _111;
    _115 *= _108.d1;
    _115 += _110;
    _108.data[_115] = _112;
    _110++;
    if (_110 < F)
    goto _jump1054;
    _110 = 0;
    _111++;
    if (_111 < g)
    goto _jump1054;
    // End body of loop
    _93 = _108;
    _jump1051:;
    _82 = _93;
    goto _jump1057;
    _jump1035:;
    _a2_void_t _116;
    // Computing bound for Q
    _116.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1058;
    fail_assertion("non-positive loop bound");
    _jump1058:;
    // Computing bound for R
    _116.d1 = H;
    if (H > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= n.d0;
    _117 *= H;
    _117 *= sizeof(void_t);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // R
    int64_t _119 = 0; // Q
    _jump1060:; // Begin body of loop
    void_t _120 = I();
    int64_t _121 = 0;
    _121 *= _116.d0;
    _121 += _119;
    _121 *= _116.d1;
    _121 += _118;
    _116.data[_121] = _120;
    _118++;
    if (_118 < H)
    goto _jump1060;
    _118 = 0;
    _119++;
    if (_119 < n.d0)
    goto _jump1060;
    // End body of loop
    _82 = _116;
    _jump1057:;
    _78 = _82;
    goto _jump1061;
    _jump1033:;
    _a2_void_t _122;
    // Computing bound for Q
    _122.d0 = j;
    if (j > 0) 
    goto _jump1062;
    fail_assertion("non-positive loop bound");
    _jump1062:;
    // Computing bound for R
    _122.d1 = c;
    if (c > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= j;
    _123 *= c;
    _123 *= sizeof(void_t);
    _122.data = jpl_alloc(_123);
    int64_t _124 = 0; // R
    int64_t _125 = 0; // Q
    _jump1064:; // Begin body of loop
    void_t _126 = I();
    int64_t _127 = 0;
    _127 *= _122.d0;
    _127 += _125;
    _127 *= _122.d1;
    _127 += _124;
    _122.data[_127] = _126;
    _124++;
    if (_124 < c)
    goto _jump1064;
    _124 = 0;
    _125++;
    if (_125 < j)
    goto _jump1064;
    // End body of loop
    _78 = _122;
    _jump1061:;
    bool _128 = true;
    _a2_int64_t _129;
    if (!_128)
    goto _jump1065;
    _a1__a2_int64_t _130;
    // Computing bound for Q
    _130.d0 = u;
    if (u > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= u;
    _131 *= sizeof(_a2_int64_t);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // Q
    _jump1067:; // Begin body of loop
    _a2_int64_t _133;
    // Computing bound for R
    _133.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing bound for S
    int64_t _134 = 676;
    _133.d1 = _134;
    if (_134 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= n.d0;
    _135 *= _134;
    _135 *= sizeof(int64_t);
    _133.data = jpl_alloc(_135);
    int64_t _136 = 0; // S
    int64_t _137 = 0; // R
    _jump1070:; // Begin body of loop
    int64_t _138 = 0;
    _138 *= _133.d0;
    _138 += _137;
    _138 *= _133.d1;
    _138 += _136;
    _133.data[_138] = f;
    _136++;
    if (_136 < _134)
    goto _jump1070;
    _136 = 0;
    _137++;
    if (_137 < n.d0)
    goto _jump1070;
    // End body of loop
    int64_t _139 = 0;
    _139 *= _130.d0;
    _139 += _132;
    _130.data[_139] = _133;
    _132++;
    if (_132 < u)
    goto _jump1067;
    // End body of loop
    if (E >= 0)
    goto _jump1071;
    fail_assertion("negative array index");
    _jump1071:;
    if (E < _130.d0)
    goto _jump1072;
    fail_assertion("index too large");
    _jump1072:;
    int64_t _140 = 0;
    _140 *= _130.d0;
    _140 += E;
    _a2_int64_t _141 = _130.data[_140];
    _129 = _141;
    goto _jump1073;
    _jump1065:;
    bool _142 = u > H;
    _a2_int64_t _143;
    if (!_142)
    goto _jump1074;
    _a2_int64_t _144;
    // Computing bound for Q
    _144.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1075;
    fail_assertion("non-positive loop bound");
    _jump1075:;
    // Computing bound for R
    _144.d1 = B;
    if (B > 0) 
    goto _jump1076;
    fail_assertion("non-positive loop bound");
    _jump1076:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= n.d0;
    _145 *= B;
    _145 *= sizeof(int64_t);
    _144.data = jpl_alloc(_145);
    int64_t _146 = 0; // R
    int64_t _147 = 0; // Q
    _jump1077:; // Begin body of loop
    int64_t _148 = 0;
    _148 *= _144.d0;
    _148 += _147;
    _148 *= _144.d1;
    _148 += _146;
    _144.data[_148] = n.d0;
    _146++;
    if (_146 < B)
    goto _jump1077;
    _146 = 0;
    _147++;
    if (_147 < n.d0)
    goto _jump1077;
    // End body of loop
    _143 = _144;
    goto _jump1078;
    _jump1074:;
    _a2_int64_t _149;
    // Computing bound for Q
    _149.d0 = r;
    if (r > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing bound for R
    _149.d1 = H;
    if (H > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= r;
    _150 *= H;
    _150 *= sizeof(int64_t);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // R
    int64_t _152 = 0; // Q
    _jump1081:; // Begin body of loop
    int64_t _153;
    // Computing bound for S
    if (c > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    _153 = 0;
    int64_t _154 = 0; // S
    _jump1083:; // Begin body of loop
    _153 += B;
    _154++;
    if (_154 < c)
    goto _jump1083;
    // End body of loop
    int64_t _155 = 0;
    _155 *= _149.d0;
    _155 += _152;
    _155 *= _149.d1;
    _155 += _151;
    _149.data[_155] = _153;
    _151++;
    if (_151 < H)
    goto _jump1081;
    _151 = 0;
    _152++;
    if (_152 < r)
    goto _jump1081;
    // End body of loop
    _143 = _149;
    _jump1078:;
    _129 = _143;
    _jump1073:;
    if (u >= 0)
    goto _jump1084;
    fail_assertion("negative array index");
    _jump1084:;
    if (u < _129.d0)
    goto _jump1085;
    fail_assertion("index too large");
    _jump1085:;
    if (j >= 0)
    goto _jump1086;
    fail_assertion("negative array index");
    _jump1086:;
    if (j < _129.d1)
    goto _jump1087;
    fail_assertion("index too large");
    _jump1087:;
    int64_t _156 = 0;
    _156 *= _129.d0;
    _156 += u;
    _156 *= _129.d1;
    _156 += j;
    int64_t _157 = _129.data[_156];
    int64_t _158 = _157 % c;
    if (_158 >= 0)
    goto _jump1088;
    fail_assertion("negative array index");
    _jump1088:;
    if (_158 < _78.d0)
    goto _jump1089;
    fail_assertion("index too large");
    _jump1089:;
    if (H >= 0)
    goto _jump1090;
    fail_assertion("negative array index");
    _jump1090:;
    if (H < _78.d1)
    goto _jump1091;
    fail_assertion("index too large");
    _jump1091:;
    int64_t _159 = 0;
    _159 *= _78.d0;
    _159 += _158;
    _159 *= _78.d1;
    _159 += H;
    void_t _160 = _78.data[_159];
    return _160;
    if (p >= 0)
    goto _jump1092;
    fail_assertion("negative array index");
    _jump1092:;
    if (p < n.d0)
    goto _jump1093;
    fail_assertion("index too large");
    _jump1093:;
    if (H >= 0)
    goto _jump1094;
    fail_assertion("negative array index");
    _jump1094:;
    if (H < n.d1)
    goto _jump1095;
    fail_assertion("index too large");
    _jump1095:;
    int64_t _162 = 0;
    _162 *= n.d0;
    _162 += p;
    _162 *= n.d1;
    _162 += H;
    bool _163 = n.data[_162];
    bool _161 = _163;
    if (0 != _163)
    goto _jump1096;
    bool _164 = d();
    _161 = _164;
    _jump1096:;
    rgba _165;
    if (!_161)
    goto _jump1097;
    double _166 = 94.0;
    double _167 = 33.0;
    double _168 = _166 * _167;
    double _169;
    // Computing bound for Q
    if (E > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    // Computing bound for R
    if (n.d1 > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    _169 = 0;
    int64_t _170 = 0; // R
    int64_t _171 = 0; // Q
    _jump1100:; // Begin body of loop
    _a3_double _172;
    // Computing bound for S
    _172.d0 = B;
    if (B > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing bound for T
    _172.d1 = B;
    if (B > 0) 
    goto _jump1102;
    fail_assertion("non-positive loop bound");
    _jump1102:;
    // Computing bound for U
    _172.d2 = E;
    if (E > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= B;
    _173 *= B;
    _173 *= E;
    _173 *= sizeof(double);
    _172.data = jpl_alloc(_173);
    int64_t _174 = 0; // U
    int64_t _175 = 0; // T
    int64_t _176 = 0; // S
    _jump1104:; // Begin body of loop
    double _177 = 74.0;
    int64_t _178 = 0;
    _178 *= _172.d0;
    _178 += _176;
    _178 *= _172.d1;
    _178 += _175;
    _178 *= _172.d2;
    _178 += _174;
    _172.data[_178] = _177;
    _174++;
    if (_174 < E)
    goto _jump1104;
    _174 = 0;
    _175++;
    if (_175 < B)
    goto _jump1104;
    _175 = 0;
    _176++;
    if (_176 < B)
    goto _jump1104;
    // End body of loop
    if (p >= 0)
    goto _jump1105;
    fail_assertion("negative array index");
    _jump1105:;
    if (p < n.d0)
    goto _jump1106;
    fail_assertion("index too large");
    _jump1106:;
    if (r >= 0)
    goto _jump1107;
    fail_assertion("negative array index");
    _jump1107:;
    if (r < n.d1)
    goto _jump1108;
    fail_assertion("index too large");
    _jump1108:;
    int64_t _179 = 0;
    _179 *= n.d0;
    _179 += p;
    _179 *= n.d1;
    _179 += r;
    bool _180 = n.data[_179];
    int64_t _181;
    if (!_180)
    goto _jump1109;
    _181 = f;
    goto _jump1110;
    _jump1109:;
    _181 = _170;
    _jump1110:;
    if (g >= 0)
    goto _jump1111;
    fail_assertion("negative array index");
    _jump1111:;
    if (g < _172.d0)
    goto _jump1112;
    fail_assertion("index too large");
    _jump1112:;
    if (c >= 0)
    goto _jump1113;
    fail_assertion("negative array index");
    _jump1113:;
    if (c < _172.d1)
    goto _jump1114;
    fail_assertion("index too large");
    _jump1114:;
    if (_181 >= 0)
    goto _jump1115;
    fail_assertion("negative array index");
    _jump1115:;
    if (_181 < _172.d2)
    goto _jump1116;
    fail_assertion("index too large");
    _jump1116:;
    int64_t _182 = 0;
    _182 *= _172.d0;
    _182 += g;
    _182 *= _172.d1;
    _182 += c;
    _182 *= _172.d2;
    _182 += _181;
    double _183 = _172.data[_182];
    _169 += _183;
    _170++;
    if (_170 < n.d1)
    goto _jump1100;
    _170 = 0;
    _171++;
    if (_171 < E)
    goto _jump1100;
    // End body of loop
    double _184 = 45.0;
    double _185;
    // Computing bound for Q
    int64_t _186 = B / n.d1;
    if (_186 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for R
    int64_t _187 = -n.d0;
    if (_187 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    _185 = 0;
    int64_t _188 = 0; // R
    int64_t _189 = 0; // Q
    _jump1119:; // Begin body of loop
    bool _190;
    if (!k)
    goto _jump1120;
    bool _191 = true;
    _190 = _191;
    goto _jump1121;
    _jump1120:;
    bool _192 = true;
    _190 = _192;
    _jump1121:;
    double _193;
    if (!_190)
    goto _jump1122;
    double _194 = 7.0;
    double _195 = 99.0;
    double _196 = _194 + _195;
    _193 = _196;
    goto _jump1123;
    _jump1122:;
    double _197 = 4.0;
    _193 = _197;
    _jump1123:;
    _185 += _193;
    _188++;
    if (_188 < _187)
    goto _jump1119;
    _188 = 0;
    _189++;
    if (_189 < _186)
    goto _jump1119;
    // End body of loop
    double _198 = _184 - _185;
    bool _200 = d();
    bool _199 = _200;
    if (0 == _200)
    goto _jump1124;
    _199 = m;
    _jump1124:;
    bool _201;
    if (!_199)
    goto _jump1125;
    bool _202;
    if (!k)
    goto _jump1126;
    _202 = k;
    goto _jump1127;
    _jump1126:;
    _202 = k;
    _jump1127:;
    bool _203 = !_202;
    _201 = _203;
    goto _jump1128;
    _jump1125:;
    double _204 = 17.0;
    double _205 = 59.0;
    bool _206 = _204 <= _205;
    _201 = _206;
    _jump1128:;
    double _207;
    if (!_201)
    goto _jump1129;
    double _208 = 34.0;
    _207 = _208;
    goto _jump1130;
    _jump1129:;
    double _209 = 42.0;
    _207 = _209;
    _jump1130:;
    rgba _210 = { _168, _169, _198, _207 };
    _165 = _210;
    goto _jump1131;
    _jump1097:;
    _a2_double _211;
    // Computing bound for Q
    _211.d0 = A;
    if (A > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing bound for R
    int64_t _212;
    // Computing bound for Q
    if (p > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    // Computing bound for R
    if (u > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    // Computing bound for S
    if (t > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    _212 = 0;
    int64_t _213 = 0; // S
    int64_t _214 = 0; // R
    int64_t _215 = 0; // Q
    _jump1136:; // Begin body of loop
    _212 += t;
    _213++;
    if (_213 < t)
    goto _jump1136;
    _213 = 0;
    _214++;
    if (_214 < u)
    goto _jump1136;
    _214 = 0;
    _215++;
    if (_215 < p)
    goto _jump1136;
    // End body of loop
    _211.d1 = _212;
    if (_212 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= A;
    _216 *= _212;
    _216 *= sizeof(double);
    _211.data = jpl_alloc(_216);
    int64_t _217 = 0; // R
    int64_t _218 = 0; // Q
    _jump1138:; // Begin body of loop
    double _219 = _71.a;
    if (j >= 0)
    goto _jump1139;
    fail_assertion("negative array index");
    _jump1139:;
    if (j < q.d0)
    goto _jump1140;
    fail_assertion("index too large");
    _jump1140:;
    int64_t _220 = 0;
    _220 *= q.d0;
    _220 += j;
    double _221 = q.data[_220];
    double _222 = _219 / _221;
    int64_t _223 = 0;
    _223 *= _211.d0;
    _223 += _218;
    _223 *= _211.d1;
    _223 += _217;
    _211.data[_223] = _222;
    _217++;
    if (_217 < _212)
    goto _jump1138;
    _217 = 0;
    _218++;
    if (_218 < A)
    goto _jump1138;
    // End body of loop
    if (c >= 0)
    goto _jump1141;
    fail_assertion("negative array index");
    _jump1141:;
    if (c < _211.d0)
    goto _jump1142;
    fail_assertion("index too large");
    _jump1142:;
    if (n.d1 >= 0)
    goto _jump1143;
    fail_assertion("negative array index");
    _jump1143:;
    if (n.d1 < _211.d1)
    goto _jump1144;
    fail_assertion("index too large");
    _jump1144:;
    int64_t _224 = 0;
    _224 *= _211.d0;
    _224 += c;
    _224 *= _211.d1;
    _224 += n.d1;
    double _225 = _211.data[_224];
    if (g >= 0)
    goto _jump1145;
    fail_assertion("negative array index");
    _jump1145:;
    if (g < s.d0)
    goto _jump1146;
    fail_assertion("index too large");
    _jump1146:;
    if (n.d1 >= 0)
    goto _jump1147;
    fail_assertion("negative array index");
    _jump1147:;
    if (n.d1 < s.d1)
    goto _jump1148;
    fail_assertion("index too large");
    _jump1148:;
    int64_t _226 = 0;
    _226 *= s.d0;
    _226 += g;
    _226 *= s.d1;
    _226 += n.d1;
    rgba _227 = s.data[_226];
    double _228 = _227.a;
    int64_t _229 = 671;
    if (_229 >= 0)
    goto _jump1149;
    fail_assertion("negative array index");
    _jump1149:;
    if (_229 < z.d0)
    goto _jump1150;
    fail_assertion("index too large");
    _jump1150:;
    if (p >= 0)
    goto _jump1151;
    fail_assertion("negative array index");
    _jump1151:;
    if (p < z.d1)
    goto _jump1152;
    fail_assertion("index too large");
    _jump1152:;
    int64_t _230 = 0;
    _230 *= z.d0;
    _230 += _229;
    _230 *= z.d1;
    _230 += p;
    rgba _231 = z.data[_230];
    double _232 = _231.g;
    double _233 = 66.0;
    double _234 = 25.0;
    double _235 = -_234;
    rgba _236 = { _228, _232, _233, _235 };
    double _237 = _236.b;
    double _238;
    if (!k)
    goto _jump1153;
    if (c >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (c < b.d0)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    int64_t _239 = 0;
    _239 *= b.d0;
    _239 += c;
    double _240 = b.data[_239];
    _238 = _240;
    goto _jump1156;
    _jump1153:;
    double _241;
    // Computing bound for Q
    if (i > 0) 
    goto _jump1157;
    fail_assertion("non-positive loop bound");
    _jump1157:;
    // Computing bound for R
    int64_t _242 = 805;
    if (_242 > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    _241 = 0;
    int64_t _243 = 0; // R
    int64_t _244 = 0; // Q
    _jump1159:; // Begin body of loop
    double _245;
    // Computing bound for S
    if (n.d0 > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing bound for T
    if (H > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    _245 = 0;
    int64_t _246 = 0; // T
    int64_t _247 = 0; // S
    _jump1162:; // Begin body of loop
    double _248 = 44.0;
    _245 += _248;
    _246++;
    if (_246 < H)
    goto _jump1162;
    _246 = 0;
    _247++;
    if (_247 < n.d0)
    goto _jump1162;
    // End body of loop
    _241 += _245;
    _243++;
    if (_243 < _242)
    goto _jump1159;
    _243 = 0;
    _244++;
    if (_244 < i)
    goto _jump1159;
    // End body of loop
    double _249 = -_241;
    _238 = _249;
    _jump1156:;
    _a1_double _250;
    // Computing bound for Q
    _250.d0 = i;
    if (i > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing total size of heap memory to allocate
    int64_t _251 = 1;
    _251 *= i;
    _251 *= sizeof(double);
    _250.data = jpl_alloc(_251);
    int64_t _252 = 0; // Q
    _jump1164:; // Begin body of loop
    double _253 = 19.0;
    double _254;
    // Computing bound for R
    int64_t _255 = 228;
    if (_255 > 0) 
    goto _jump1165;
    fail_assertion("non-positive loop bound");
    _jump1165:;
    // Computing bound for S
    if (H > 0) 
    goto _jump1166;
    fail_assertion("non-positive loop bound");
    _jump1166:;
    _254 = 0;
    int64_t _256 = 0; // S
    int64_t _257 = 0; // R
    _jump1167:; // Begin body of loop
    double _258 = 60.0;
    _254 += _258;
    _256++;
    if (_256 < H)
    goto _jump1167;
    _256 = 0;
    _257++;
    if (_257 < _255)
    goto _jump1167;
    // End body of loop
    double _259 = _253 * _254;
    int64_t _260 = 0;
    _260 *= _250.d0;
    _260 += _252;
    _250.data[_260] = _259;
    _252++;
    if (_252 < i)
    goto _jump1164;
    // End body of loop
    int64_t _261 = 957;
    if (_261 >= 0)
    goto _jump1168;
    fail_assertion("negative array index");
    _jump1168:;
    if (_261 < _250.d0)
    goto _jump1169;
    fail_assertion("index too large");
    _jump1169:;
    int64_t _262 = 0;
    _262 *= _250.d0;
    _262 += _261;
    double _263 = _250.data[_262];
    rgba _264 = { _225, _237, _238, _263 };
    _165 = _264;
    _jump1131:;
    double _265 = _165.a;
    _a2_void_t _266;
    // Computing bound for R
    _a1_int64_t _267;
    _267.d0 = 2;
    _267.data = jpl_alloc(sizeof(int64_t) * 2);
    _267.data[0] = n.d0;
    _267.data[1] = B;
    _a1_int64_t _268;
    // Computing bound for R
    _268.d0 = f;
    if (f > 0) 
    goto _jump1170;
    fail_assertion("non-positive loop bound");
    _jump1170:;
    // Computing total size of heap memory to allocate
    int64_t _269 = 1;
    _269 *= f;
    _269 *= sizeof(int64_t);
    _268.data = jpl_alloc(_269);
    int64_t _270 = 0; // R
    _jump1171:; // Begin body of loop
    int64_t _271 = 0;
    _271 *= _268.d0;
    _271 += _270;
    _268.data[_271] = n.d1;
    _270++;
    if (_270 < f)
    goto _jump1171;
    // End body of loop
    if (p >= 0)
    goto _jump1172;
    fail_assertion("negative array index");
    _jump1172:;
    if (p < _268.d0)
    goto _jump1173;
    fail_assertion("index too large");
    _jump1173:;
    int64_t _272 = 0;
    _272 *= _268.d0;
    _272 += p;
    int64_t _273 = _268.data[_272];
    if (_273 >= 0)
    goto _jump1174;
    fail_assertion("negative array index");
    _jump1174:;
    if (_273 < _267.d0)
    goto _jump1175;
    fail_assertion("index too large");
    _jump1175:;
    int64_t _274 = 0;
    _274 *= _267.d0;
    _274 += _273;
    int64_t _275 = _267.data[_274];
    _266.d0 = _275;
    if (_275 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing bound for S
    _266.d1 = i;
    if (i > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing total size of heap memory to allocate
    int64_t _276 = 1;
    _276 *= _275;
    _276 *= i;
    _276 *= sizeof(void_t);
    _266.data = jpl_alloc(_276);
    int64_t _277 = 0; // S
    int64_t _278 = 0; // R
    _jump1178:; // Begin body of loop
    void_t _279 = I();
    int64_t _280 = 0;
    _280 *= _266.d0;
    _280 += _278;
    _280 *= _266.d1;
    _280 += _277;
    _266.data[_280] = _279;
    _277++;
    if (_277 < i)
    goto _jump1178;
    _277 = 0;
    _278++;
    if (_278 < _275)
    goto _jump1178;
    // End body of loop
    if (r >= 0)
    goto _jump1179;
    fail_assertion("negative array index");
    _jump1179:;
    if (r < _266.d0)
    goto _jump1180;
    fail_assertion("index too large");
    _jump1180:;
    if (g >= 0)
    goto _jump1181;
    fail_assertion("negative array index");
    _jump1181:;
    if (g < _266.d1)
    goto _jump1182;
    fail_assertion("index too large");
    _jump1182:;
    int64_t _281 = 0;
    _281 *= _266.d0;
    _281 += r;
    _281 *= _266.d1;
    _281 += g;
    void_t _282 = _266.data[_281];
    C _283 = { _71, _282 };
    void_t _284 = _283.b;
    return _284;
}

void jpl_main(struct args args) {
    bool _0 = false;
    bool _1;
    if (!_0)
    goto _jump1;
    _a1_bool _3;
    // Computing bound for b
    int64_t _4 = 22;
    int64_t _5 = -_4;
    int64_t _6 = -_5;
    int64_t _7 = -_6;
    _3.d0 = _7;
    if (_7 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= _7;
    _8 *= sizeof(bool);
    _3.data = jpl_alloc(_8);
    int64_t _9 = 0; // b
    _jump3:; // Begin body of loop
    bool _10 = true;
    bool _11 = !_10;
    bool _12 = !_11;
    bool _13;
    if (!_12)
    goto _jump4;
    bool _14 = false;
    bool _15 = !_14;
    _13 = _15;
    goto _jump5;
    _jump4:;
    bool _16 = true;
    _13 = _16;
    _jump5:;
    int64_t _17 = 0;
    _17 *= _3.d0;
    _17 += _9;
    _3.data[_17] = _13;
    _9++;
    if (_9 < _7)
    goto _jump3;
    // End body of loop
    int64_t _18 = 920;
    if (_18 >= 0)
    goto _jump6;
    fail_assertion("negative array index");
    _jump6:;
    if (_18 < _3.d0)
    goto _jump7;
    fail_assertion("index too large");
    _jump7:;
    int64_t _19 = 0;
    _19 *= _3.d0;
    _19 += _18;
    bool _20 = _3.data[_19];
    bool _2 = _20;
    if (0 != _20)
    goto _jump8;
    int64_t _21;
    // Computing bound for b
    int64_t _22 = 577;
    if (_22 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    // Computing bound for c
    int64_t _23;
    // Computing bound for b
    bool _24 = true;
    int64_t _25;
    if (!_24)
    goto _jump10;
    int64_t _26 = 931;
    _25 = _26;
    goto _jump11;
    _jump10:;
    int64_t _27 = 214;
    _25 = _27;
    _jump11:;
    if (_25 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    // Computing bound for c
    int64_t _28 = 88;
    int64_t _29 = 402;
    int64_t _30 = _28 + _29;
    if (_30 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    // Computing bound for d
    int64_t _31 = 714;
    if (_31 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    _23 = 0;
    int64_t _32 = 0; // d
    int64_t _33 = 0; // c
    int64_t _34 = 0; // b
    _jump15:; // Begin body of loop
    _23 += _33;
    _32++;
    if (_32 < _31)
    goto _jump15;
    _32 = 0;
    _33++;
    if (_33 < _30)
    goto _jump15;
    _33 = 0;
    _34++;
    if (_34 < _25)
    goto _jump15;
    // End body of loop
    if (_23 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    _21 = 0;
    int64_t _35 = 0; // c
    int64_t _36 = 0; // b
    _jump17:; // Begin body of loop
    int64_t _37 = 671;
    _21 += _37;
    _35++;
    if (_35 < _23)
    goto _jump17;
    _35 = 0;
    _36++;
    if (_36 < _22)
    goto _jump17;
    // End body of loop
    int64_t _38 = 62;
    bool _39 = _21 <= _38;
    bool _40;
    if (!_39)
    goto _jump18;
    bool _41 = true;
    int64_t _42;
    if (!_41)
    goto _jump19;
    int64_t _43 = 115;
    int64_t _44 = -_43;
    _42 = _44;
    goto _jump20;
    _jump19:;
    int64_t _45;
    // Computing bound for b
    int64_t _46 = 401;
    if (_46 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing bound for c
    int64_t _47 = 356;
    if (_47 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    _45 = 0;
    int64_t _48 = 0; // c
    int64_t _49 = 0; // b
    _jump23:; // Begin body of loop
    _45 += _49;
    _48++;
    if (_48 < _47)
    goto _jump23;
    _48 = 0;
    _49++;
    if (_49 < _46)
    goto _jump23;
    // End body of loop
    int64_t _50 = -_45;
    _42 = _50;
    _jump20:;
    bool _52 = true;
    bool _51 = _52;
    if (0 != _52)
    goto _jump24;
    bool _53 = false;
    _51 = _53;
    _jump24:;
    int64_t _54;
    if (!_51)
    goto _jump25;
    _a2_int64_t _55;
    // Computing bound for b
    int64_t _56 = 604;
    _55.d0 = _56;
    if (_56 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for c
    int64_t _57 = 466;
    _55.d1 = _57;
    if (_57 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= _56;
    _58 *= _57;
    _58 *= sizeof(int64_t);
    _55.data = jpl_alloc(_58);
    int64_t _59 = 0; // c
    int64_t _60 = 0; // b
    _jump28:; // Begin body of loop
    int64_t _61 = 0;
    _61 *= _55.d0;
    _61 += _60;
    _61 *= _55.d1;
    _61 += _59;
    _55.data[_61] = _60;
    _59++;
    if (_59 < _57)
    goto _jump28;
    _59 = 0;
    _60++;
    if (_60 < _56)
    goto _jump28;
    // End body of loop
    int64_t _62 = 811;
    int64_t _63 = 316;
    int64_t _64 = 860;
    int64_t _65 = _63 % _64;
    if (_62 >= 0)
    goto _jump29;
    fail_assertion("negative array index");
    _jump29:;
    if (_62 < _55.d0)
    goto _jump30;
    fail_assertion("index too large");
    _jump30:;
    if (_65 >= 0)
    goto _jump31;
    fail_assertion("negative array index");
    _jump31:;
    if (_65 < _55.d1)
    goto _jump32;
    fail_assertion("index too large");
    _jump32:;
    int64_t _66 = 0;
    _66 *= _55.d0;
    _66 += _62;
    _66 *= _55.d1;
    _66 += _65;
    int64_t _67 = _55.data[_66];
    _54 = _67;
    goto _jump33;
    _jump25:;
    int64_t _68 = 659;
    _54 = _68;
    _jump33:;
    bool _69 = _42 < _54;
    _40 = _69;
    goto _jump34;
    _jump18:;
    bool _70 = false;
    int64_t _71;
    if (!_70)
    goto _jump35;
    int64_t _72 = 370;
    int64_t _73 = -_72;
    _71 = _73;
    goto _jump36;
    _jump35:;
    int64_t _74 = 648;
    int64_t _75 = -_74;
    int64_t _76 = 54;
    int64_t _77 = _75 - _76;
    _71 = _77;
    _jump36:;
    int64_t _78 = 973;
    bool _79 = _71 < _78;
    _40 = _79;
    _jump34:;
    _2 = _40;
    _jump8:;
    _1 = _2;
    goto _jump37;
    _jump1:;
    double _83 = 69.0;
    bool _84 = false;
    double _85;
    if (!_84)
    goto _jump38;
    double _86 = 89.0;
    double _87 = -_86;
    _85 = _87;
    goto _jump39;
    _jump38:;
    double _88 = 27.0;
    double _89 = -_88;
    _85 = _89;
    _jump39:;
    bool _90 = _83 < _85;
    bool _82 = _90;
    if (0 != _90)
    goto _jump40;
    bool _91 = false;
    _82 = _91;
    _jump40:;
    bool _81 = _82;
    if (0 != _82)
    goto _jump41;
    bool _92 = true;
    _81 = _92;
    _jump41:;
    bool _80 = _81;
    if (0 != _81)
    goto _jump42;
    double _93;
    // Computing bound for b
    int64_t _94;
    // Computing bound for b
    int64_t _95 = 440;
    if (_95 > 0) 
    goto _jump43;
    fail_assertion("non-positive loop bound");
    _jump43:;
    // Computing bound for c
    int64_t _96 = 416;
    if (_96 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    _94 = 0;
    int64_t _97 = 0; // c
    int64_t _98 = 0; // b
    _jump45:; // Begin body of loop
    _94 += _97;
    _97++;
    if (_97 < _96)
    goto _jump45;
    _97 = 0;
    _98++;
    if (_98 < _95)
    goto _jump45;
    // End body of loop
    if (_94 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    _93 = 0;
    int64_t _99 = 0; // b
    _jump47:; // Begin body of loop
    double _100 = 7.0;
    double _101 = 78.0;
    double _102 = _100 + _101;
    _93 += _102;
    _99++;
    if (_99 < _94)
    goto _jump47;
    // End body of loop
    double _103 = -_93;
    double _104 = 52.0;
    bool _105 = _103 > _104;
    _80 = _105;
    _jump42:;
    _1 = _80;
    _jump37:;
    if (0 != _1)
    goto _jump48;
    fail_assertion("b");
    _jump48:;
    bool _107 = true;
    _a1_bool _108;
    if (!_107)
    goto _jump49;
    _a1_bool _109;
    // Computing bound for b
    int64_t _110 = 534;
    int64_t _111 = -_110;
    _109.d0 = _111;
    if (_111 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _111;
    _112 *= sizeof(bool);
    _109.data = jpl_alloc(_112);
    int64_t _113 = 0; // b
    _jump51:; // Begin body of loop
    int64_t _114 = 503;
    bool _115 = _114 != _113;
    int64_t _116 = 0;
    _116 *= _109.d0;
    _116 += _113;
    _109.data[_116] = _115;
    _113++;
    if (_113 < _111)
    goto _jump51;
    // End body of loop
    _108 = _109;
    goto _jump52;
    _jump49:;
    _a1_bool _117;
    // Computing bound for b
    int64_t _118 = 630;
    _117.d0 = _118;
    if (_118 > 0) 
    goto _jump53;
    fail_assertion("non-positive loop bound");
    _jump53:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= _118;
    _119 *= sizeof(bool);
    _117.data = jpl_alloc(_119);
    int64_t _120 = 0; // b
    _jump54:; // Begin body of loop
    bool _121 = true;
    bool _122 = !_121;
    int64_t _123 = 0;
    _123 *= _117.d0;
    _123 += _120;
    _117.data[_123] = _122;
    _120++;
    if (_120 < _118)
    goto _jump54;
    // End body of loop
    _108 = _117;
    _jump52:;
    int64_t _124 = 979;
    int64_t _125 = 285;
    int64_t _126 = _124 / _125;
    int64_t _127 = 660;
    int64_t _128 = _126 - _127;
    if (_128 >= 0)
    goto _jump55;
    fail_assertion("negative array index");
    _jump55:;
    if (_128 < _108.d0)
    goto _jump56;
    fail_assertion("index too large");
    _jump56:;
    int64_t _129 = 0;
    _129 *= _108.d0;
    _129 += _128;
    bool _130 = _108.data[_129];
    bool _106 = _130;
    if (0 != _130)
    goto _jump57;
    int64_t _132 = 607;
    int64_t _133;
    // Computing bound for b
    int64_t _134 = 778;
    if (_134 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    _133 = 0;
    int64_t _135 = 0; // b
    _jump59:; // Begin body of loop
    int64_t _136 = 465;
    _133 += _136;
    _135++;
    if (_135 < _134)
    goto _jump59;
    // End body of loop
    bool _137 = _132 < _133;
    bool _131 = _137;
    if (0 != _137)
    goto _jump60;
    bool _138 = false;
    _131 = _138;
    _jump60:;
    bool _139;
    if (!_131)
    goto _jump61;
    bool _140 = false;
    bool _141;
    if (!_140)
    goto _jump62;
    int64_t _142 = 98;
    int64_t _143 = 286;
    bool _144 = _142 != _143;
    _141 = _144;
    goto _jump63;
    _jump62:;
    _a1_bool _145;
    // Computing bound for b
    int64_t _146 = 206;
    _145.d0 = _146;
    if (_146 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= _146;
    _147 *= sizeof(bool);
    _145.data = jpl_alloc(_147);
    int64_t _148 = 0; // b
    _jump65:; // Begin body of loop
    bool _149 = true;
    int64_t _150 = 0;
    _150 *= _145.d0;
    _150 += _148;
    _145.data[_150] = _149;
    _148++;
    if (_148 < _146)
    goto _jump65;
    // End body of loop
    int64_t _151 = 593;
    if (_151 >= 0)
    goto _jump66;
    fail_assertion("negative array index");
    _jump66:;
    if (_151 < _145.d0)
    goto _jump67;
    fail_assertion("index too large");
    _jump67:;
    int64_t _152 = 0;
    _152 *= _145.d0;
    _152 += _151;
    bool _153 = _145.data[_152];
    _141 = _153;
    _jump63:;
    _139 = _141;
    goto _jump68;
    _jump61:;
    double _154 = 26.0;
    double _155 = 31.0;
    bool _156 = _154 != _155;
    bool _157 = !_156;
    bool _158 = false;
    bool _159 = _157 == _158;
    _139 = _159;
    _jump68:;
    _106 = _139;
    _jump57:;
    _a3__a1_double _160;
    if (!_106)
    goto _jump69;
    _a3__a1_double _161;
    // Computing bound for b
    int64_t _162 = 729;
    int64_t _163 = -_162;
    int64_t _164 = -_163;
    bool _165 = false;
    int64_t _166;
    if (!_165)
    goto _jump70;
    int64_t _167 = 248;
    int64_t _168 = -_167;
    _166 = _168;
    goto _jump71;
    _jump70:;
    int64_t _169 = 955;
    _166 = _169;
    _jump71:;
    int64_t _170 = _164 % _166;
    int64_t _171 = -_170;
    _161.d0 = _171;
    if (_171 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing bound for c
    int64_t _172;
    // Computing bound for b
    int64_t _173 = 638;
    if (_173 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    _172 = 0;
    int64_t _174 = 0; // b
    _jump74:; // Begin body of loop
    int64_t _175 = 682;
    _172 += _175;
    _174++;
    if (_174 < _173)
    goto _jump74;
    // End body of loop
    _a2_int64_t _176;
    // Computing bound for b
    int64_t _177 = 756;
    _176.d0 = _177;
    if (_177 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for c
    int64_t _178 = 770;
    _176.d1 = _178;
    if (_178 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= _177;
    _179 *= _178;
    _179 *= sizeof(int64_t);
    _176.data = jpl_alloc(_179);
    int64_t _180 = 0; // c
    int64_t _181 = 0; // b
    _jump77:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _176.d0;
    _182 += _181;
    _182 *= _176.d1;
    _182 += _180;
    _176.data[_182] = _181;
    _180++;
    if (_180 < _178)
    goto _jump77;
    _180 = 0;
    _181++;
    if (_181 < _177)
    goto _jump77;
    // End body of loop
    int64_t _183;
    // Computing bound for b
    int64_t _184 = 902;
    if (_184 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    _183 = 0;
    int64_t _185 = 0; // b
    _jump79:; // Begin body of loop
    _183 += _185;
    _185++;
    if (_185 < _184)
    goto _jump79;
    // End body of loop
    int64_t _186;
    // Computing bound for b
    int64_t _187 = 450;
    if (_187 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    _186 = 0;
    int64_t _188 = 0; // b
    _jump81:; // Begin body of loop
    _186 += _188;
    _188++;
    if (_188 < _187)
    goto _jump81;
    // End body of loop
    if (_183 >= 0)
    goto _jump82;
    fail_assertion("negative array index");
    _jump82:;
    if (_183 < _176.d0)
    goto _jump83;
    fail_assertion("index too large");
    _jump83:;
    if (_186 >= 0)
    goto _jump84;
    fail_assertion("negative array index");
    _jump84:;
    if (_186 < _176.d1)
    goto _jump85;
    fail_assertion("index too large");
    _jump85:;
    int64_t _189 = 0;
    _189 *= _176.d0;
    _189 += _183;
    _189 *= _176.d1;
    _189 += _186;
    int64_t _190 = _176.data[_189];
    int64_t _191 = _172 + _190;
    bool _193 = false;
    bool _194 = !_193;
    bool _192 = _194;
    if (0 == _194)
    goto _jump86;
    bool _195 = false;
    bool _196 = !_195;
    _192 = _196;
    _jump86:;
    int64_t _197;
    if (!_192)
    goto _jump87;
    int64_t _198 = 217;
    _197 = _198;
    goto _jump88;
    _jump87:;
    int64_t _199 = 274;
    _197 = _199;
    _jump88:;
    int64_t _200 = _191 * _197;
    _161.d1 = _200;
    if (_200 > 0) 
    goto _jump89;
    fail_assertion("non-positive loop bound");
    _jump89:;
    // Computing bound for d
    int64_t _201 = 916;
    int64_t _202 = -_201;
    _161.d2 = _202;
    if (_202 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _171;
    _203 *= _200;
    _203 *= _202;
    _203 *= sizeof(_a1_double);
    _161.data = jpl_alloc(_203);
    int64_t _204 = 0; // d
    int64_t _205 = 0; // c
    int64_t _206 = 0; // b
    _jump91:; // Begin body of loop
    bool _207 = false;
    _a2__a1_double _208;
    if (!_207)
    goto _jump92;
    _a2__a1_double _209;
    // Computing bound for e
    int64_t _210 = 576;
    _209.d0 = _210;
    if (_210 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing bound for f
    int64_t _211;
    // Computing bound for e
    if (_206 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    _211 = 0;
    int64_t _212 = 0; // e
    _jump95:; // Begin body of loop
    _211 += _206;
    _212++;
    if (_212 < _206)
    goto _jump95;
    // End body of loop
    _209.d1 = _211;
    if (_211 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= _210;
    _213 *= _211;
    _213 *= sizeof(_a1_double);
    _209.data = jpl_alloc(_213);
    int64_t _214 = 0; // f
    int64_t _215 = 0; // e
    _jump97:; // Begin body of loop
    double _216 = 67.0;
    double _217 = 25.0;
    _a1_double _218;
    _218.d0 = 2;
    _218.data = jpl_alloc(sizeof(double) * 2);
    _218.data[0] = _216;
    _218.data[1] = _217;
    int64_t _219 = 0;
    _219 *= _209.d0;
    _219 += _215;
    _219 *= _209.d1;
    _219 += _214;
    _209.data[_219] = _218;
    _214++;
    if (_214 < _211)
    goto _jump97;
    _214 = 0;
    _215++;
    if (_215 < _210)
    goto _jump97;
    // End body of loop
    _208 = _209;
    goto _jump98;
    _jump92:;
    _a2__a1_double _220;
    // Computing bound for e
    int64_t _221;
    // Computing bound for e
    if (_206 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    _221 = 0;
    int64_t _222 = 0; // e
    _jump100:; // Begin body of loop
    int64_t _223 = 83;
    _221 += _223;
    _222++;
    if (_222 < _206)
    goto _jump100;
    // End body of loop
    _220.d0 = _221;
    if (_221 > 0) 
    goto _jump101;
    fail_assertion("non-positive loop bound");
    _jump101:;
    // Computing bound for f
    _220.d1 = _204;
    if (_204 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= _221;
    _224 *= _204;
    _224 *= sizeof(_a1_double);
    _220.data = jpl_alloc(_224);
    int64_t _225 = 0; // f
    int64_t _226 = 0; // e
    _jump103:; // Begin body of loop
    _a1_double _227;
    // Computing bound for g
    _227.d0 = _204;
    if (_204 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= _204;
    _228 *= sizeof(double);
    _227.data = jpl_alloc(_228);
    int64_t _229 = 0; // g
    _jump105:; // Begin body of loop
    double _230 = 59.0;
    int64_t _231 = 0;
    _231 *= _227.d0;
    _231 += _229;
    _227.data[_231] = _230;
    _229++;
    if (_229 < _204)
    goto _jump105;
    // End body of loop
    int64_t _232 = 0;
    _232 *= _220.d0;
    _232 += _226;
    _232 *= _220.d1;
    _232 += _225;
    _220.data[_232] = _227;
    _225++;
    if (_225 < _204)
    goto _jump103;
    _225 = 0;
    _226++;
    if (_226 < _221)
    goto _jump103;
    // End body of loop
    _208 = _220;
    _jump98:;
    bool _233 = true;
    int64_t _234;
    if (!_233)
    goto _jump106;
    _a2_int64_t _235;
    // Computing bound for e
    _235.d0 = _204;
    if (_204 > 0) 
    goto _jump107;
    fail_assertion("non-positive loop bound");
    _jump107:;
    // Computing bound for f
    int64_t _236 = 954;
    _235.d1 = _236;
    if (_236 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    // Computing total size of heap memory to allocate
    int64_t _237 = 1;
    _237 *= _204;
    _237 *= _236;
    _237 *= sizeof(int64_t);
    _235.data = jpl_alloc(_237);
    int64_t _238 = 0; // f
    int64_t _239 = 0; // e
    _jump109:; // Begin body of loop
    int64_t _240 = 0;
    _240 *= _235.d0;
    _240 += _239;
    _240 *= _235.d1;
    _240 += _238;
    _235.data[_240] = _204;
    _238++;
    if (_238 < _236)
    goto _jump109;
    _238 = 0;
    _239++;
    if (_239 < _204)
    goto _jump109;
    // End body of loop
    int64_t _241 = -_204;
    if (_241 >= 0)
    goto _jump110;
    fail_assertion("negative array index");
    _jump110:;
    if (_241 < _235.d0)
    goto _jump111;
    fail_assertion("index too large");
    _jump111:;
    if (_204 >= 0)
    goto _jump112;
    fail_assertion("negative array index");
    _jump112:;
    if (_204 < _235.d1)
    goto _jump113;
    fail_assertion("index too large");
    _jump113:;
    int64_t _242 = 0;
    _242 *= _235.d0;
    _242 += _241;
    _242 *= _235.d1;
    _242 += _204;
    int64_t _243 = _235.data[_242];
    _234 = _243;
    goto _jump114;
    _jump106:;
    bool _244 = false;
    bool _245 = !_244;
    int64_t _246;
    if (!_245)
    goto _jump115;
    int64_t _247 = _205 % _205;
    _246 = _247;
    goto _jump116;
    _jump115:;
    int64_t _248 = 180;
    _246 = _248;
    _jump116:;
    _234 = _246;
    _jump114:;
    if (_234 >= 0)
    goto _jump117;
    fail_assertion("negative array index");
    _jump117:;
    if (_234 < _208.d0)
    goto _jump118;
    fail_assertion("index too large");
    _jump118:;
    if (_204 >= 0)
    goto _jump119;
    fail_assertion("negative array index");
    _jump119:;
    if (_204 < _208.d1)
    goto _jump120;
    fail_assertion("index too large");
    _jump120:;
    int64_t _249 = 0;
    _249 *= _208.d0;
    _249 += _234;
    _249 *= _208.d1;
    _249 += _204;
    _a1_double _250 = _208.data[_249];
    int64_t _251 = 0;
    _251 *= _161.d0;
    _251 += _206;
    _251 *= _161.d1;
    _251 += _205;
    _251 *= _161.d2;
    _251 += _204;
    _161.data[_251] = _250;
    _204++;
    if (_204 < _202)
    goto _jump91;
    _204 = 0;
    _205++;
    if (_205 < _200)
    goto _jump91;
    _205 = 0;
    _206++;
    if (_206 < _171)
    goto _jump91;
    // End body of loop
    _160 = _161;
    goto _jump121;
    _jump69:;
    _a3__a1_double _252;
    // Computing bound for b
    bool _253 = true;
    int64_t _254;
    if (!_253)
    goto _jump122;
    int64_t _255 = 847;
    int64_t _256 = -_255;
    _254 = _256;
    goto _jump123;
    _jump122:;
    _a1_int64_t _257;
    // Computing bound for b
    int64_t _258 = 321;
    _257.d0 = _258;
    if (_258 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= _258;
    _259 *= sizeof(int64_t);
    _257.data = jpl_alloc(_259);
    int64_t _260 = 0; // b
    _jump125:; // Begin body of loop
    int64_t _261 = 0;
    _261 *= _257.d0;
    _261 += _260;
    _257.data[_261] = _260;
    _260++;
    if (_260 < _258)
    goto _jump125;
    // End body of loop
    int64_t _262 = 494;
    int64_t _263 = -_262;
    int64_t _264 = 634;
    int64_t _265 = _263 / _264;
    if (_265 >= 0)
    goto _jump126;
    fail_assertion("negative array index");
    _jump126:;
    if (_265 < _257.d0)
    goto _jump127;
    fail_assertion("index too large");
    _jump127:;
    int64_t _266 = 0;
    _266 *= _257.d0;
    _266 += _265;
    int64_t _267 = _257.data[_266];
    _254 = _267;
    _jump123:;
    _252.d0 = _254;
    if (_254 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    // Computing bound for c
    int64_t _268 = 378;
    int64_t _269 = -_268;
    int64_t _270 = 314;
    int64_t _271 = -_270;
    int64_t _272 = _269 * _271;
    int64_t _273 = -_272;
    int64_t _274 = -_273;
    _252.d1 = _274;
    if (_274 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    // Computing bound for d
    bool _275 = false;
    bool _276 = !_275;
    int64_t _277;
    if (!_276)
    goto _jump130;
    int64_t _278;
    // Computing bound for b
    int64_t _279 = 279;
    int64_t _280 = -_279;
    if (_280 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing bound for c
    int64_t _281 = 17;
    if (_281 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    _278 = 0;
    int64_t _282 = 0; // c
    int64_t _283 = 0; // b
    _jump133:; // Begin body of loop
    _278 += _283;
    _282++;
    if (_282 < _281)
    goto _jump133;
    _282 = 0;
    _283++;
    if (_283 < _280)
    goto _jump133;
    // End body of loop
    int64_t _284 = -_278;
    _277 = _284;
    goto _jump134;
    _jump130:;
    int64_t _285 = 535;
    _277 = _285;
    _jump134:;
    _252.d2 = _277;
    if (_277 > 0) 
    goto _jump135;
    fail_assertion("non-positive loop bound");
    _jump135:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= _254;
    _286 *= _274;
    _286 *= _277;
    _286 *= sizeof(_a1_double);
    _252.data = jpl_alloc(_286);
    int64_t _287 = 0; // d
    int64_t _288 = 0; // c
    int64_t _289 = 0; // b
    _jump136:; // Begin body of loop
    bool _290 = false;
    _a1_double _291;
    if (!_290)
    goto _jump137;
    _a3__a1_double _292;
    // Computing bound for e
    int64_t _293;
    // Computing bound for e
    if (_288 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    // Computing bound for f
    if (_287 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing bound for g
    if (_287 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    _293 = 0;
    int64_t _294 = 0; // g
    int64_t _295 = 0; // f
    int64_t _296 = 0; // e
    _jump141:; // Begin body of loop
    _293 += _295;
    _294++;
    if (_294 < _287)
    goto _jump141;
    _294 = 0;
    _295++;
    if (_295 < _287)
    goto _jump141;
    _295 = 0;
    _296++;
    if (_296 < _288)
    goto _jump141;
    // End body of loop
    _292.d0 = _293;
    if (_293 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    // Computing bound for f
    _292.d1 = _288;
    if (_288 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing bound for g
    _292.d2 = _289;
    if (_289 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    // Computing total size of heap memory to allocate
    int64_t _297 = 1;
    _297 *= _293;
    _297 *= _288;
    _297 *= _289;
    _297 *= sizeof(_a1_double);
    _292.data = jpl_alloc(_297);
    int64_t _298 = 0; // g
    int64_t _299 = 0; // f
    int64_t _300 = 0; // e
    _jump145:; // Begin body of loop
    double _301 = 41.0;
    _a1_double _302;
    _302.d0 = 1;
    _302.data = jpl_alloc(sizeof(double) * 1);
    _302.data[0] = _301;
    int64_t _303 = 0;
    _303 *= _292.d0;
    _303 += _300;
    _303 *= _292.d1;
    _303 += _299;
    _303 *= _292.d2;
    _303 += _298;
    _292.data[_303] = _302;
    _298++;
    if (_298 < _289)
    goto _jump145;
    _298 = 0;
    _299++;
    if (_299 < _288)
    goto _jump145;
    _299 = 0;
    _300++;
    if (_300 < _293)
    goto _jump145;
    // End body of loop
    int64_t _304 = -_288;
    bool _305 = true;
    int64_t _306;
    if (!_305)
    goto _jump146;
    int64_t _307 = -_289;
    _306 = _307;
    goto _jump147;
    _jump146:;
    _306 = _289;
    _jump147:;
    int64_t _308;
    // Computing bound for e
    if (_289 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    _308 = 0;
    int64_t _309 = 0; // e
    _jump149:; // Begin body of loop
    _308 += _309;
    _309++;
    if (_309 < _289)
    goto _jump149;
    // End body of loop
    if (_304 >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (_304 < _292.d0)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    if (_306 >= 0)
    goto _jump152;
    fail_assertion("negative array index");
    _jump152:;
    if (_306 < _292.d1)
    goto _jump153;
    fail_assertion("index too large");
    _jump153:;
    if (_308 >= 0)
    goto _jump154;
    fail_assertion("negative array index");
    _jump154:;
    if (_308 < _292.d2)
    goto _jump155;
    fail_assertion("index too large");
    _jump155:;
    int64_t _310 = 0;
    _310 *= _292.d0;
    _310 += _304;
    _310 *= _292.d1;
    _310 += _306;
    _310 *= _292.d2;
    _310 += _308;
    _a1_double _311 = _292.data[_310];
    _291 = _311;
    goto _jump156;
    _jump137:;
    _a1_double _312;
    // Computing bound for e
    int64_t _313 = -_287;
    _312.d0 = _313;
    if (_313 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing total size of heap memory to allocate
    int64_t _314 = 1;
    _314 *= _313;
    _314 *= sizeof(double);
    _312.data = jpl_alloc(_314);
    int64_t _315 = 0; // e
    _jump158:; // Begin body of loop
    double _316 = 0.0;
    int64_t _317 = 0;
    _317 *= _312.d0;
    _317 += _315;
    _312.data[_317] = _316;
    _315++;
    if (_315 < _313)
    goto _jump158;
    // End body of loop
    _291 = _312;
    _jump156:;
    int64_t _318 = 0;
    _318 *= _252.d0;
    _318 += _289;
    _318 *= _252.d1;
    _318 += _288;
    _318 *= _252.d2;
    _318 += _287;
    _252.data[_318] = _291;
    _287++;
    if (_287 < _277)
    goto _jump136;
    _287 = 0;
    _288++;
    if (_288 < _274)
    goto _jump136;
    _288 = 0;
    _289++;
    if (_289 < _254)
    goto _jump136;
    // End body of loop
    _160 = _252;
    _jump121:;
    int64_t _319;
    // Computing bound for b
    int64_t _320;
    // Computing bound for b
    int64_t _321 = 352;
    if (_321 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing bound for c
    int64_t _322 = 643;
    int64_t _323 = 164;
    int64_t _324 = _322 % _323;
    int64_t _325 = -_324;
    if (_325 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    _320 = 0;
    int64_t _326 = 0; // c
    int64_t _327 = 0; // b
    _jump161:; // Begin body of loop
    _320 += _326;
    _326++;
    if (_326 < _325)
    goto _jump161;
    _326 = 0;
    _327++;
    if (_327 < _321)
    goto _jump161;
    // End body of loop
    int64_t _328 = 52;
    int64_t _329 = 534;
    int64_t _330 = _328 % _329;
    int64_t _331 = -_330;
    int64_t _332 = 802;
    int64_t _333 = -_332;
    _a1_int64_t _334;
    _334.d0 = 3;
    _334.data = jpl_alloc(sizeof(int64_t) * 3);
    _334.data[0] = _320;
    _334.data[1] = _331;
    _334.data[2] = _333;
    int64_t _335;
    // Computing bound for b
    int64_t _336 = 118;
    int64_t _337 = 626;
    int64_t _338 = _336 % _337;
    if (_338 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    // Computing bound for c
    int64_t _339 = 273;
    int64_t _340 = -_339;
    int64_t _341 = -_340;
    if (_341 > 0) 
    goto _jump163;
    fail_assertion("non-positive loop bound");
    _jump163:;
    _335 = 0;
    int64_t _342 = 0; // c
    int64_t _343 = 0; // b
    _jump164:; // Begin body of loop
    _a1_int64_t _344;
    // Computing bound for d
    _344.d0 = _342;
    if (_342 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    // Computing total size of heap memory to allocate
    int64_t _345 = 1;
    _345 *= _342;
    _345 *= sizeof(int64_t);
    _344.data = jpl_alloc(_345);
    int64_t _346 = 0; // d
    _jump166:; // Begin body of loop
    int64_t _347 = 515;
    int64_t _348 = 0;
    _348 *= _344.d0;
    _348 += _346;
    _344.data[_348] = _347;
    _346++;
    if (_346 < _342)
    goto _jump166;
    // End body of loop
    int64_t _349;
    // Computing bound for d
    if (_343 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing bound for e
    if (_343 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    _349 = 0;
    int64_t _350 = 0; // e
    int64_t _351 = 0; // d
    _jump169:; // Begin body of loop
    _349 += _343;
    _350++;
    if (_350 < _343)
    goto _jump169;
    _350 = 0;
    _351++;
    if (_351 < _343)
    goto _jump169;
    // End body of loop
    if (_349 >= 0)
    goto _jump170;
    fail_assertion("negative array index");
    _jump170:;
    if (_349 < _344.d0)
    goto _jump171;
    fail_assertion("index too large");
    _jump171:;
    int64_t _352 = 0;
    _352 *= _344.d0;
    _352 += _349;
    int64_t _353 = _344.data[_352];
    _335 += _353;
    _342++;
    if (_342 < _341)
    goto _jump164;
    _342 = 0;
    _343++;
    if (_343 < _338)
    goto _jump164;
    // End body of loop
    int64_t _354;
    // Computing bound for b
    int64_t _355 = 816;
    if (_355 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    _354 = 0;
    int64_t _356 = 0; // b
    _jump173:; // Begin body of loop
    int64_t _357 = -_356;
    int64_t _358 = -_357;
    _354 += _358;
    _356++;
    if (_356 < _355)
    goto _jump173;
    // End body of loop
    int64_t _359 = _335 % _354;
    if (_359 >= 0)
    goto _jump174;
    fail_assertion("negative array index");
    _jump174:;
    if (_359 < _334.d0)
    goto _jump175;
    fail_assertion("index too large");
    _jump175:;
    int64_t _360 = 0;
    _360 *= _334.d0;
    _360 += _359;
    int64_t _361 = _334.data[_360];
    if (_361 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    // Computing bound for c
    bool _363 = false;
    bool _362 = _363;
    if (0 == _363)
    goto _jump177;
    int64_t _364 = 464;
    int64_t _365 = 87;
    bool _366 = _364 >= _365;
    bool _367 = !_366;
    _362 = _367;
    _jump177:;
    int64_t _368;
    if (!_362)
    goto _jump178;
    double _369 = 7.0;
    double _370 = 92.0;
    bool _371 = _369 != _370;
    int64_t _372;
    if (!_371)
    goto _jump179;
    int64_t _373 = 716;
    int64_t _374 = 824;
    int64_t _375 = _373 / _374;
    _372 = _375;
    goto _jump180;
    _jump179:;
    int64_t _376 = 723;
    _372 = _376;
    _jump180:;
    int64_t _377 = 165;
    int64_t _378 = 730;
    int64_t _379 = _377 * _378;
    int64_t _380 = -_379;
    int64_t _381 = _372 % _380;
    _368 = _381;
    goto _jump181;
    _jump178:;
    int64_t _382 = 809;
    int64_t _383 = -_382;
    _368 = _383;
    _jump181:;
    int64_t _384 = -_368;
    if (_384 > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing bound for d
    _a3_int64_t _385;
    // Computing bound for b
    int64_t _386 = 454;
    int64_t _387 = -_386;
    _385.d0 = _387;
    if (_387 > 0) 
    goto _jump183;
    fail_assertion("non-positive loop bound");
    _jump183:;
    // Computing bound for c
    int64_t _388 = 336;
    _385.d1 = _388;
    if (_388 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing bound for d
    bool _389 = false;
    int64_t _390;
    if (!_389)
    goto _jump185;
    int64_t _391 = 87;
    _390 = _391;
    goto _jump186;
    _jump185:;
    int64_t _392 = 96;
    _390 = _392;
    _jump186:;
    _385.d2 = _390;
    if (_390 > 0) 
    goto _jump187;
    fail_assertion("non-positive loop bound");
    _jump187:;
    // Computing total size of heap memory to allocate
    int64_t _393 = 1;
    _393 *= _387;
    _393 *= _388;
    _393 *= _390;
    _393 *= sizeof(int64_t);
    _385.data = jpl_alloc(_393);
    int64_t _394 = 0; // d
    int64_t _395 = 0; // c
    int64_t _396 = 0; // b
    _jump188:; // Begin body of loop
    int64_t _397 = 0;
    _397 *= _385.d0;
    _397 += _396;
    _397 *= _385.d1;
    _397 += _395;
    _397 *= _385.d2;
    _397 += _394;
    _385.data[_397] = _396;
    _394++;
    if (_394 < _390)
    goto _jump188;
    _394 = 0;
    _395++;
    if (_395 < _388)
    goto _jump188;
    _395 = 0;
    _396++;
    if (_396 < _387)
    goto _jump188;
    // End body of loop
    int64_t _398 = 836;
    int64_t _399 = 692;
    int64_t _400 = 917;
    int64_t _401 = 347;
    int64_t _402 = _400 % _401;
    int64_t _403 = -_402;
    int64_t _404 = 362;
    int64_t _405 = _403 + _404;
    if (_398 >= 0)
    goto _jump189;
    fail_assertion("negative array index");
    _jump189:;
    if (_398 < _385.d0)
    goto _jump190;
    fail_assertion("index too large");
    _jump190:;
    if (_399 >= 0)
    goto _jump191;
    fail_assertion("negative array index");
    _jump191:;
    if (_399 < _385.d1)
    goto _jump192;
    fail_assertion("index too large");
    _jump192:;
    if (_405 >= 0)
    goto _jump193;
    fail_assertion("negative array index");
    _jump193:;
    if (_405 < _385.d2)
    goto _jump194;
    fail_assertion("index too large");
    _jump194:;
    int64_t _406 = 0;
    _406 *= _385.d0;
    _406 += _398;
    _406 *= _385.d1;
    _406 += _399;
    _406 *= _385.d2;
    _406 += _405;
    int64_t _407 = _385.data[_406];
    if (_407 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    _319 = 0;
    int64_t _408 = 0; // d
    int64_t _409 = 0; // c
    int64_t _410 = 0; // b
    _jump196:; // Begin body of loop
    int64_t _411 = 296;
    int64_t _412 = 874;
    int64_t _413 = _411 / _412;
    _319 += _413;
    _408++;
    if (_408 < _407)
    goto _jump196;
    _408 = 0;
    _409++;
    if (_409 < _384)
    goto _jump196;
    _409 = 0;
    _410++;
    if (_410 < _361)
    goto _jump196;
    // End body of loop
    int64_t _414 = 253;
    bool _415 = false;
    int64_t _416;
    if (!_415)
    goto _jump197;
    int64_t _417 = 92;
    _416 = _417;
    goto _jump198;
    _jump197:;
    int64_t _418 = 309;
    int64_t _419 = 536;
    int64_t _420 = 664;
    bool _421 = _419 == _420;
    int64_t _422;
    if (!_421)
    goto _jump199;
    int64_t _423 = 909;
    int64_t _424 = -_423;
    int64_t _425 = -_424;
    _422 = _425;
    goto _jump200;
    _jump199:;
    _a1_int64_t _426;
    // Computing bound for b
    int64_t _427 = 881;
    _426.d0 = _427;
    if (_427 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= _427;
    _428 *= sizeof(int64_t);
    _426.data = jpl_alloc(_428);
    int64_t _429 = 0; // b
    _jump202:; // Begin body of loop
    int64_t _430 = 341;
    int64_t _431 = 0;
    _431 *= _426.d0;
    _431 += _429;
    _426.data[_431] = _430;
    _429++;
    if (_429 < _427)
    goto _jump202;
    // End body of loop
    int64_t _432 = 755;
    if (_432 >= 0)
    goto _jump203;
    fail_assertion("negative array index");
    _jump203:;
    if (_432 < _426.d0)
    goto _jump204;
    fail_assertion("index too large");
    _jump204:;
    int64_t _433 = 0;
    _433 *= _426.d0;
    _433 += _432;
    int64_t _434 = _426.data[_433];
    _422 = _434;
    _jump200:;
    int64_t _435 = _418 - _422;
    _416 = _435;
    _jump198:;
    _a3_bool _436;
    // Computing bound for b
    int64_t _437 = 708;
    _436.d0 = _437;
    if (_437 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing bound for c
    int64_t _438 = 374;
    int64_t _439 = -_438;
    _436.d1 = _439;
    if (_439 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    // Computing bound for d
    int64_t _440 = 635;
    _436.d2 = _440;
    if (_440 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing total size of heap memory to allocate
    int64_t _441 = 1;
    _441 *= _437;
    _441 *= _439;
    _441 *= _440;
    _441 *= sizeof(bool);
    _436.data = jpl_alloc(_441);
    int64_t _442 = 0; // d
    int64_t _443 = 0; // c
    int64_t _444 = 0; // b
    _jump208:; // Begin body of loop
    bool _445 = true;
    bool _446 = !_445;
    int64_t _447 = 0;
    _447 *= _436.d0;
    _447 += _444;
    _447 *= _436.d1;
    _447 += _443;
    _447 *= _436.d2;
    _447 += _442;
    _436.data[_447] = _446;
    _442++;
    if (_442 < _440)
    goto _jump208;
    _442 = 0;
    _443++;
    if (_443 < _439)
    goto _jump208;
    _443 = 0;
    _444++;
    if (_444 < _437)
    goto _jump208;
    // End body of loop
    bool _448 = false;
    bool _449 = !_448;
    int64_t _450;
    if (!_449)
    goto _jump209;
    int64_t _451 = 818;
    _450 = _451;
    goto _jump210;
    _jump209:;
    int64_t _452 = 741;
    int64_t _453 = -_452;
    _450 = _453;
    _jump210:;
    int64_t _454;
    // Computing bound for b
    int64_t _455 = 9;
    int64_t _456 = -_455;
    if (_456 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for c
    int64_t _457 = 771;
    if (_457 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    _454 = 0;
    int64_t _458 = 0; // c
    int64_t _459 = 0; // b
    _jump213:; // Begin body of loop
    int64_t _460 = -_458;
    _454 += _460;
    _458++;
    if (_458 < _457)
    goto _jump213;
    _458 = 0;
    _459++;
    if (_459 < _456)
    goto _jump213;
    // End body of loop
    int64_t _461;
    // Computing bound for b
    int64_t _462 = 194;
    if (_462 > 0) 
    goto _jump214;
    fail_assertion("non-positive loop bound");
    _jump214:;
    // Computing bound for c
    int64_t _463 = 422;
    int64_t _464 = -_463;
    if (_464 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing bound for d
    int64_t _465 = 614;
    int64_t _466 = -_465;
    if (_466 > 0) 
    goto _jump216;
    fail_assertion("non-positive loop bound");
    _jump216:;
    _461 = 0;
    int64_t _467 = 0; // d
    int64_t _468 = 0; // c
    int64_t _469 = 0; // b
    _jump217:; // Begin body of loop
    _461 += _468;
    _467++;
    if (_467 < _466)
    goto _jump217;
    _467 = 0;
    _468++;
    if (_468 < _464)
    goto _jump217;
    _468 = 0;
    _469++;
    if (_469 < _462)
    goto _jump217;
    // End body of loop
    if (_450 >= 0)
    goto _jump218;
    fail_assertion("negative array index");
    _jump218:;
    if (_450 < _436.d0)
    goto _jump219;
    fail_assertion("index too large");
    _jump219:;
    if (_454 >= 0)
    goto _jump220;
    fail_assertion("negative array index");
    _jump220:;
    if (_454 < _436.d1)
    goto _jump221;
    fail_assertion("index too large");
    _jump221:;
    if (_461 >= 0)
    goto _jump222;
    fail_assertion("negative array index");
    _jump222:;
    if (_461 < _436.d2)
    goto _jump223;
    fail_assertion("index too large");
    _jump223:;
    int64_t _470 = 0;
    _470 *= _436.d0;
    _470 += _450;
    _470 *= _436.d1;
    _470 += _454;
    _470 *= _436.d2;
    _470 += _461;
    bool _471 = _436.data[_470];
    int64_t _472;
    if (!_471)
    goto _jump224;
    int64_t _473;
    // Computing bound for b
    int64_t _474 = 782;
    if (_474 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for c
    int64_t _475 = 952;
    if (_475 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    _473 = 0;
    int64_t _476 = 0; // c
    int64_t _477 = 0; // b
    _jump227:; // Begin body of loop
    int64_t _478 = 792;
    _473 += _478;
    _476++;
    if (_476 < _475)
    goto _jump227;
    _476 = 0;
    _477++;
    if (_477 < _474)
    goto _jump227;
    // End body of loop
    int64_t _479 = 458;
    int64_t _480 = 312;
    int64_t _481 = _479 / _480;
    int64_t _482 = _473 + _481;
    int64_t _483 = -_482;
    _472 = _483;
    goto _jump228;
    _jump224:;
    int64_t _484 = 605;
    int64_t _485 = 26;
    int64_t _486 = -_485;
    int64_t _487 = 266;
    int64_t _488 = 949;
    int64_t _489 = _487 - _488;
    _a1_int64_t _490;
    _490.d0 = 3;
    _490.data = jpl_alloc(sizeof(int64_t) * 3);
    _490.data[0] = _484;
    _490.data[1] = _486;
    _490.data[2] = _489;
    bool _491 = true;
    int64_t _492;
    if (!_491)
    goto _jump229;
    int64_t _493 = 642;
    _492 = _493;
    goto _jump230;
    _jump229:;
    int64_t _494 = 343;
    _492 = _494;
    _jump230:;
    int64_t _495 = -_492;
    if (_495 >= 0)
    goto _jump231;
    fail_assertion("negative array index");
    _jump231:;
    if (_495 < _490.d0)
    goto _jump232;
    fail_assertion("index too large");
    _jump232:;
    int64_t _496 = 0;
    _496 *= _490.d0;
    _496 += _495;
    int64_t _497 = _490.data[_496];
    _472 = _497;
    _jump228:;
    int64_t _498 = 479;
    int64_t _499 = _472 + _498;
    int64_t _500 = _416 % _499;
    if (_319 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (_319 < _160.d0)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    if (_414 >= 0)
    goto _jump235;
    fail_assertion("negative array index");
    _jump235:;
    if (_414 < _160.d1)
    goto _jump236;
    fail_assertion("index too large");
    _jump236:;
    if (_500 >= 0)
    goto _jump237;
    fail_assertion("negative array index");
    _jump237:;
    if (_500 < _160.d2)
    goto _jump238;
    fail_assertion("index too large");
    _jump238:;
    int64_t _501 = 0;
    _501 *= _160.d0;
    _501 += _319;
    _501 *= _160.d1;
    _501 += _414;
    _501 *= _160.d2;
    _501 += _500;
    _a1_double _502 = _160.data[_501];
    print("e");
    _a3_double _503;
    // Computing bound for e
    _a3_int64_t _504;
    // Computing bound for e
    int64_t _505 = -_502.d0;
    int64_t _506 = _505 * _502.d0;
    _504.d0 = _506;
    if (_506 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for f
    int64_t _507 = -_502.d0;
    int64_t _508 = 832;
    int64_t _509 = _508 % _502.d0;
    int64_t _510 = _507 + _509;
    _504.d1 = _510;
    if (_510 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing bound for g
    int64_t _511;
    // Computing bound for e
    int64_t _512;
    // Computing bound for e
    if (_502.d0 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    // Computing bound for f
    if (_502.d0 > 0) 
    goto _jump458;
    fail_assertion("non-positive loop bound");
    _jump458:;
    // Computing bound for g
    if (_502.d0 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    _512 = 0;
    int64_t _513 = 0; // g
    int64_t _514 = 0; // f
    int64_t _515 = 0; // e
    _jump460:; // Begin body of loop
    _512 += _515;
    _513++;
    if (_513 < _502.d0)
    goto _jump460;
    _513 = 0;
    _514++;
    if (_514 < _502.d0)
    goto _jump460;
    _514 = 0;
    _515++;
    if (_515 < _502.d0)
    goto _jump460;
    // End body of loop
    if (_512 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for f
    if (_502.d0 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    _511 = 0;
    int64_t _516 = 0; // f
    int64_t _517 = 0; // e
    _jump463:; // Begin body of loop
    int64_t _518 = -_517;
    _511 += _518;
    _516++;
    if (_516 < _502.d0)
    goto _jump463;
    _516 = 0;
    _517++;
    if (_517 < _512)
    goto _jump463;
    // End body of loop
    _504.d2 = _511;
    if (_511 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing total size of heap memory to allocate
    int64_t _519 = 1;
    _519 *= _506;
    _519 *= _510;
    _519 *= _511;
    _519 *= sizeof(int64_t);
    _504.data = jpl_alloc(_519);
    int64_t _520 = 0; // g
    int64_t _521 = 0; // f
    int64_t _522 = 0; // e
    _jump465:; // Begin body of loop
    int64_t _523 = 0;
    _523 *= _504.d0;
    _523 += _522;
    _523 *= _504.d1;
    _523 += _521;
    _523 *= _504.d2;
    _523 += _520;
    _504.data[_523] = _520;
    _520++;
    if (_520 < _511)
    goto _jump465;
    _520 = 0;
    _521++;
    if (_521 < _510)
    goto _jump465;
    _521 = 0;
    _522++;
    if (_522 < _506)
    goto _jump465;
    // End body of loop
    int64_t _524 = -_502.d0;
    int64_t _525 = -_502.d0;
    int64_t _526 = _524 - _525;
    int64_t _527 = -_526;
    _a1_int64_t _528;
    _528.d0 = 1;
    _528.data = jpl_alloc(sizeof(int64_t) * 1);
    _528.data[0] = _502.d0;
    int64_t _529;
    // Computing bound for e
    int64_t _530 = 291;
    if (_530 > 0) 
    goto _jump466;
    fail_assertion("non-positive loop bound");
    _jump466:;
    // Computing bound for f
    int64_t _531 = 222;
    if (_531 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    _529 = 0;
    int64_t _532 = 0; // f
    int64_t _533 = 0; // e
    _jump468:; // Begin body of loop
    _529 += _502.d0;
    _532++;
    if (_532 < _531)
    goto _jump468;
    _532 = 0;
    _533++;
    if (_533 < _530)
    goto _jump468;
    // End body of loop
    int64_t _534 = -_529;
    if (_534 >= 0)
    goto _jump469;
    fail_assertion("negative array index");
    _jump469:;
    if (_534 < _528.d0)
    goto _jump470;
    fail_assertion("index too large");
    _jump470:;
    int64_t _535 = 0;
    _535 *= _528.d0;
    _535 += _534;
    int64_t _536 = _528.data[_535];
    int64_t _537 = 555;
    if (_527 >= 0)
    goto _jump471;
    fail_assertion("negative array index");
    _jump471:;
    if (_527 < _504.d0)
    goto _jump472;
    fail_assertion("index too large");
    _jump472:;
    if (_536 >= 0)
    goto _jump473;
    fail_assertion("negative array index");
    _jump473:;
    if (_536 < _504.d1)
    goto _jump474;
    fail_assertion("index too large");
    _jump474:;
    if (_537 >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (_537 < _504.d2)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    int64_t _538 = 0;
    _538 *= _504.d0;
    _538 += _527;
    _538 *= _504.d1;
    _538 += _536;
    _538 *= _504.d2;
    _538 += _537;
    int64_t _539 = _504.data[_538];
    _503.d0 = _539;
    if (_539 > 0) 
    goto _jump477;
    fail_assertion("non-positive loop bound");
    _jump477:;
    // Computing bound for f
    _503.d1 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    // Computing bound for g
    bool _540 = true;
    bool _541 = !_540;
    bool _542;
    if (!_541)
    goto _jump479;
    int64_t _543 = 913;
    int64_t _544 = 613;
    bool _545 = _543 < _544;
    _542 = _545;
    goto _jump480;
    _jump479:;
    bool _546 = d();
    bool _547 = !_546;
    _542 = _547;
    _jump480:;
    _a3_int64_t _548;
    if (!_542)
    goto _jump481;
    bool _549 = true;
    _a3_int64_t _550;
    if (!_549)
    goto _jump482;
    _a3_int64_t _551;
    // Computing bound for e
    int64_t _552 = 765;
    _551.d0 = _552;
    if (_552 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    // Computing bound for f
    _551.d1 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing bound for g
    int64_t _553 = 104;
    _551.d2 = _553;
    if (_553 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing total size of heap memory to allocate
    int64_t _554 = 1;
    _554 *= _552;
    _554 *= _502.d0;
    _554 *= _553;
    _554 *= sizeof(int64_t);
    _551.data = jpl_alloc(_554);
    int64_t _555 = 0; // g
    int64_t _556 = 0; // f
    int64_t _557 = 0; // e
    _jump486:; // Begin body of loop
    int64_t _558 = 0;
    _558 *= _551.d0;
    _558 += _557;
    _558 *= _551.d1;
    _558 += _556;
    _558 *= _551.d2;
    _558 += _555;
    _551.data[_558] = _502.d0;
    _555++;
    if (_555 < _553)
    goto _jump486;
    _555 = 0;
    _556++;
    if (_556 < _502.d0)
    goto _jump486;
    _556 = 0;
    _557++;
    if (_557 < _552)
    goto _jump486;
    // End body of loop
    _550 = _551;
    goto _jump487;
    _jump482:;
    _a3_int64_t _559;
    // Computing bound for e
    int64_t _560 = 363;
    _559.d0 = _560;
    if (_560 > 0) 
    goto _jump488;
    fail_assertion("non-positive loop bound");
    _jump488:;
    // Computing bound for f
    int64_t _561 = 489;
    _559.d1 = _561;
    if (_561 > 0) 
    goto _jump489;
    fail_assertion("non-positive loop bound");
    _jump489:;
    // Computing bound for g
    int64_t _562 = 516;
    _559.d2 = _562;
    if (_562 > 0) 
    goto _jump490;
    fail_assertion("non-positive loop bound");
    _jump490:;
    // Computing total size of heap memory to allocate
    int64_t _563 = 1;
    _563 *= _560;
    _563 *= _561;
    _563 *= _562;
    _563 *= sizeof(int64_t);
    _559.data = jpl_alloc(_563);
    int64_t _564 = 0; // g
    int64_t _565 = 0; // f
    int64_t _566 = 0; // e
    _jump491:; // Begin body of loop
    int64_t _567 = 0;
    _567 *= _559.d0;
    _567 += _566;
    _567 *= _559.d1;
    _567 += _565;
    _567 *= _559.d2;
    _567 += _564;
    _559.data[_567] = _502.d0;
    _564++;
    if (_564 < _562)
    goto _jump491;
    _564 = 0;
    _565++;
    if (_565 < _561)
    goto _jump491;
    _565 = 0;
    _566++;
    if (_566 < _560)
    goto _jump491;
    // End body of loop
    _550 = _559;
    _jump487:;
    _548 = _550;
    goto _jump492;
    _jump481:;
    _a3_int64_t _568;
    // Computing bound for e
    int64_t _569 = 401;
    int64_t _570 = _569 * _502.d0;
    _568.d0 = _570;
    if (_570 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for f
    int64_t _571 = 666;
    _568.d1 = _571;
    if (_571 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing bound for g
    int64_t _572 = 716;
    int64_t _573 = _502.d0 / _572;
    _568.d2 = _573;
    if (_573 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing total size of heap memory to allocate
    int64_t _574 = 1;
    _574 *= _570;
    _574 *= _571;
    _574 *= _573;
    _574 *= sizeof(int64_t);
    _568.data = jpl_alloc(_574);
    int64_t _575 = 0; // g
    int64_t _576 = 0; // f
    int64_t _577 = 0; // e
    _jump496:; // Begin body of loop
    int64_t _578 = 0;
    _578 *= _568.d0;
    _578 += _577;
    _578 *= _568.d1;
    _578 += _576;
    _578 *= _568.d2;
    _578 += _575;
    _568.data[_578] = _576;
    _575++;
    if (_575 < _573)
    goto _jump496;
    _575 = 0;
    _576++;
    if (_576 < _571)
    goto _jump496;
    _576 = 0;
    _577++;
    if (_577 < _570)
    goto _jump496;
    // End body of loop
    _548 = _568;
    _jump492:;
    int64_t _579 = -_502.d0;
    int64_t _580 = 785;
    int64_t _581 = 411;
    int64_t _582 = 950;
    _a1_int64_t _583;
    _583.d0 = 3;
    _583.data = jpl_alloc(sizeof(int64_t) * 3);
    _583.data[0] = _581;
    _583.data[1] = _582;
    _583.data[2] = _502.d0;
    int64_t _584 = _502.d0 * _502.d0;
    if (_584 >= 0)
    goto _jump497;
    fail_assertion("negative array index");
    _jump497:;
    if (_584 < _583.d0)
    goto _jump498;
    fail_assertion("index too large");
    _jump498:;
    int64_t _585 = 0;
    _585 *= _583.d0;
    _585 += _584;
    int64_t _586 = _583.data[_585];
    if (_579 >= 0)
    goto _jump499;
    fail_assertion("negative array index");
    _jump499:;
    if (_579 < _548.d0)
    goto _jump500;
    fail_assertion("index too large");
    _jump500:;
    if (_580 >= 0)
    goto _jump501;
    fail_assertion("negative array index");
    _jump501:;
    if (_580 < _548.d1)
    goto _jump502;
    fail_assertion("index too large");
    _jump502:;
    if (_586 >= 0)
    goto _jump503;
    fail_assertion("negative array index");
    _jump503:;
    if (_586 < _548.d2)
    goto _jump504;
    fail_assertion("index too large");
    _jump504:;
    int64_t _587 = 0;
    _587 *= _548.d0;
    _587 += _579;
    _587 *= _548.d1;
    _587 += _580;
    _587 *= _548.d2;
    _587 += _586;
    int64_t _588 = _548.data[_587];
    _503.d2 = _588;
    if (_588 > 0) 
    goto _jump505;
    fail_assertion("non-positive loop bound");
    _jump505:;
    // Computing total size of heap memory to allocate
    int64_t _589 = 1;
    _589 *= _539;
    _589 *= _502.d0;
    _589 *= _588;
    _589 *= sizeof(double);
    _503.data = jpl_alloc(_589);
    int64_t _590 = 0; // g
    int64_t _591 = 0; // f
    int64_t _592 = 0; // e
    _jump506:; // Begin body of loop
    double _593 = 74.0;
    double _594;
    // Computing bound for h
    int64_t _595;
    // Computing bound for h
    int64_t _596 = 823;
    if (_596 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing bound for i
    if (_592 > 0) 
    goto _jump508;
    fail_assertion("non-positive loop bound");
    _jump508:;
    // Computing bound for j
    if (_591 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    _595 = 0;
    int64_t _597 = 0; // j
    int64_t _598 = 0; // i
    int64_t _599 = 0; // h
    _jump510:; // Begin body of loop
    _595 += _592;
    _597++;
    if (_597 < _591)
    goto _jump510;
    _597 = 0;
    _598++;
    if (_598 < _592)
    goto _jump510;
    _598 = 0;
    _599++;
    if (_599 < _596)
    goto _jump510;
    // End body of loop
    if (_595 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    // Computing bound for i
    int64_t _600 = _590 - _590;
    if (_600 > 0) 
    goto _jump512;
    fail_assertion("non-positive loop bound");
    _jump512:;
    // Computing bound for j
    if (_592 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    _594 = 0;
    int64_t _601 = 0; // j
    int64_t _602 = 0; // i
    int64_t _603 = 0; // h
    _jump514:; // Begin body of loop
    if (_592 >= 0)
    goto _jump515;
    fail_assertion("negative array index");
    _jump515:;
    if (_592 < _502.d0)
    goto _jump516;
    fail_assertion("index too large");
    _jump516:;
    int64_t _604 = 0;
    _604 *= _502.d0;
    _604 += _592;
    double _605 = _502.data[_604];
    _594 += _605;
    _601++;
    if (_601 < _592)
    goto _jump514;
    _601 = 0;
    _602++;
    if (_602 < _600)
    goto _jump514;
    _602 = 0;
    _603++;
    if (_603 < _595)
    goto _jump514;
    // End body of loop
    double _606 = 17.0;
    double _607 = -_606;
    double _608 = _594 * _607;
    double _609 = _593 / _608;
    int64_t _610 = 0;
    _610 *= _503.d0;
    _610 += _592;
    _610 *= _503.d1;
    _610 += _591;
    _610 *= _503.d2;
    _610 += _590;
    _503.data[_610] = _609;
    _590++;
    if (_590 < _588)
    goto _jump506;
    _590 = 0;
    _591++;
    if (_591 < _502.d0)
    goto _jump506;
    _591 = 0;
    _592++;
    if (_592 < _539)
    goto _jump506;
    // End body of loop
    int64_t _611 = -_502.d0;
    int64_t _612 = 729;
    int64_t _613 = -_612;
    int64_t _614 = -_613;
    int64_t _615 = 630;
    int64_t _616 = _614 * _615;
    _a1_int64_t _617;
    // Computing bound for e
    int64_t _618 = 419;
    _617.d0 = _618;
    if (_618 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing total size of heap memory to allocate
    int64_t _619 = 1;
    _619 *= _618;
    _619 *= sizeof(int64_t);
    _617.data = jpl_alloc(_619);
    int64_t _620 = 0; // e
    _jump518:; // Begin body of loop
    _a2_int64_t _621;
    // Computing bound for f
    _621.d0 = _620;
    if (_620 > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    // Computing bound for g
    _621.d1 = _620;
    if (_620 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing total size of heap memory to allocate
    int64_t _622 = 1;
    _622 *= _620;
    _622 *= _620;
    _622 *= sizeof(int64_t);
    _621.data = jpl_alloc(_622);
    int64_t _623 = 0; // g
    int64_t _624 = 0; // f
    _jump521:; // Begin body of loop
    bool _625 = d();
    int64_t _626;
    if (!_625)
    goto _jump522;
    int64_t _627 = 806;
    _626 = _627;
    goto _jump523;
    _jump522:;
    _626 = _620;
    _jump523:;
    int64_t _628 = 0;
    _628 *= _621.d0;
    _628 += _624;
    _628 *= _621.d1;
    _628 += _623;
    _621.data[_628] = _626;
    _623++;
    if (_623 < _620)
    goto _jump521;
    _623 = 0;
    _624++;
    if (_624 < _620)
    goto _jump521;
    // End body of loop
    int64_t _629;
    // Computing bound for f
    if (_502.d0 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    _629 = 0;
    int64_t _630 = 0; // f
    _jump525:; // Begin body of loop
    int64_t _631 = 412;
    _629 += _631;
    _630++;
    if (_630 < _502.d0)
    goto _jump525;
    // End body of loop
    int64_t _632 = -_629;
    bool _633 = true;
    bool _634;
    if (!_633)
    goto _jump526;
    bool _635 = d();
    _634 = _635;
    goto _jump527;
    _jump526:;
    bool _636 = true;
    _634 = _636;
    _jump527:;
    int64_t _637;
    if (!_634)
    goto _jump528;
    int64_t _638 = -_502.d0;
    _637 = _638;
    goto _jump529;
    _jump528:;
    bool _639 = true;
    int64_t _640;
    if (!_639)
    goto _jump530;
    _640 = _502.d0;
    goto _jump531;
    _jump530:;
    int64_t _641 = 570;
    _640 = _641;
    _jump531:;
    _637 = _640;
    _jump529:;
    if (_632 >= 0)
    goto _jump532;
    fail_assertion("negative array index");
    _jump532:;
    if (_632 < _621.d0)
    goto _jump533;
    fail_assertion("index too large");
    _jump533:;
    if (_637 >= 0)
    goto _jump534;
    fail_assertion("negative array index");
    _jump534:;
    if (_637 < _621.d1)
    goto _jump535;
    fail_assertion("index too large");
    _jump535:;
    int64_t _642 = 0;
    _642 *= _621.d0;
    _642 += _632;
    _642 *= _621.d1;
    _642 += _637;
    int64_t _643 = _621.data[_642];
    int64_t _644 = 0;
    _644 *= _617.d0;
    _644 += _620;
    _617.data[_644] = _643;
    _620++;
    if (_620 < _618)
    goto _jump518;
    // End body of loop
    int64_t _645 = -_502.d0;
    if (_645 >= 0)
    goto _jump536;
    fail_assertion("negative array index");
    _jump536:;
    if (_645 < _617.d0)
    goto _jump537;
    fail_assertion("index too large");
    _jump537:;
    int64_t _646 = 0;
    _646 *= _617.d0;
    _646 += _645;
    int64_t _647 = _617.data[_646];
    if (_611 >= 0)
    goto _jump538;
    fail_assertion("negative array index");
    _jump538:;
    if (_611 < _503.d0)
    goto _jump539;
    fail_assertion("index too large");
    _jump539:;
    if (_616 >= 0)
    goto _jump540;
    fail_assertion("negative array index");
    _jump540:;
    if (_616 < _503.d1)
    goto _jump541;
    fail_assertion("index too large");
    _jump541:;
    if (_647 >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (_647 < _503.d2)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    int64_t _648 = 0;
    _648 *= _503.d0;
    _648 += _611;
    _648 *= _503.d1;
    _648 += _616;
    _648 *= _503.d2;
    _648 += _647;
    double _649 = _503.data[_648];
    _a1_double _650;
    _650.d0 = 1;
    _650.data = jpl_alloc(sizeof(double) * 1);
    _650.data[0] = _649;
    show("(ArrayType (FloatType) 1)", &_650);
    double _651 = get_time();
    double _652 = get_time();
    _a2_bool _653;
    // Computing bound for e
    int64_t _654 = 338;
    int64_t _655 = -_654;
    int64_t _656 = -_655;
    _653.d0 = _656;
    if (_656 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for f
    int64_t _657;
    // Computing bound for e
    bool _658 = false;
    bool _659 = !_658;
    int64_t _660;
    if (!_659)
    goto _jump545;
    _660 = _502.d0;
    goto _jump546;
    _jump545:;
    _660 = _502.d0;
    _jump546:;
    int64_t _661 = 857;
    int64_t _662 = _660 * _661;
    if (_662 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    _657 = 0;
    int64_t _663 = 0; // e
    _jump548:; // Begin body of loop
    int64_t _664 = 459;
    _657 += _664;
    _663++;
    if (_663 < _662)
    goto _jump548;
    // End body of loop
    _653.d1 = _657;
    if (_657 > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    // Computing total size of heap memory to allocate
    int64_t _665 = 1;
    _665 *= _656;
    _665 *= _657;
    _665 *= sizeof(bool);
    _653.data = jpl_alloc(_665);
    int64_t _666 = 0; // f
    int64_t _667 = 0; // e
    _jump550:; // Begin body of loop
    bool _668 = false;
    int64_t _669 = 0;
    _669 *= _653.d0;
    _669 += _667;
    _669 *= _653.d1;
    _669 += _666;
    _653.data[_669] = _668;
    _666++;
    if (_666 < _657)
    goto _jump550;
    _666 = 0;
    _667++;
    if (_667 < _656)
    goto _jump550;
    // End body of loop
    double _670 = get_time();
    print_time(_670 - _652);
    double _671 = get_time();
    print_time(_671 - _651);
    bool _673 = true;
    bool _672 = _673;
    if (0 == _673)
    goto _jump551;
    double _674;
    // Computing bound for h
    int64_t _675;
    // Computing bound for h
    if (_653.d0 > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    _675 = 0;
    int64_t _676 = 0; // h
    _jump553:; // Begin body of loop
    _675 += _653.d0;
    _676++;
    if (_676 < _653.d0)
    goto _jump553;
    // End body of loop
    int64_t _677 = -_675;
    if (_677 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for i
    int64_t _678;
    // Computing bound for h
    bool _679 = false;
    int64_t _680;
    if (!_679)
    goto _jump555;
    int64_t _681 = 485;
    _680 = _681;
    goto _jump556;
    _jump555:;
    int64_t _682;
    // Computing bound for h
    if (_502.d0 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for i
    if (_653.d1 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    _682 = 0;
    int64_t _683 = 0; // i
    int64_t _684 = 0; // h
    _jump559:; // Begin body of loop
    _682 += _653.d0;
    _683++;
    if (_683 < _653.d1)
    goto _jump559;
    _683 = 0;
    _684++;
    if (_684 < _502.d0)
    goto _jump559;
    // End body of loop
    _680 = _682;
    _jump556:;
    if (_680 > 0) 
    goto _jump560;
    fail_assertion("non-positive loop bound");
    _jump560:;
    // Computing bound for i
    int64_t _685;
    // Computing bound for h
    if (_653.d1 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for i
    if (_653.d0 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    // Computing bound for j
    if (_653.d0 > 0) 
    goto _jump563;
    fail_assertion("non-positive loop bound");
    _jump563:;
    _685 = 0;
    int64_t _686 = 0; // j
    int64_t _687 = 0; // i
    int64_t _688 = 0; // h
    _jump564:; // Begin body of loop
    _685 += _653.d1;
    _686++;
    if (_686 < _653.d0)
    goto _jump564;
    _686 = 0;
    _687++;
    if (_687 < _653.d0)
    goto _jump564;
    _687 = 0;
    _688++;
    if (_688 < _653.d1)
    goto _jump564;
    // End body of loop
    int64_t _689 = -_685;
    if (_689 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    _678 = 0;
    int64_t _690 = 0; // i
    int64_t _691 = 0; // h
    _jump566:; // Begin body of loop
    int64_t _692 = 378;
    int64_t _693 = _692 % _690;
    _678 += _693;
    _690++;
    if (_690 < _689)
    goto _jump566;
    _690 = 0;
    _691++;
    if (_691 < _680)
    goto _jump566;
    // End body of loop
    if (_678 > 0) 
    goto _jump567;
    fail_assertion("non-positive loop bound");
    _jump567:;
    // Computing bound for j
    _a1_int64_t _694;
    _694.d0 = 2;
    _694.data = jpl_alloc(sizeof(int64_t) * 2);
    _694.data[0] = _653.d1;
    _694.data[1] = _502.d0;
    if (_653.d1 >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (_653.d1 < _694.d0)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    int64_t _695 = 0;
    _695 *= _694.d0;
    _695 += _653.d1;
    int64_t _696 = _694.data[_695];
    if (_696 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    _674 = 0;
    int64_t _697 = 0; // j
    int64_t _698 = 0; // i
    int64_t _699 = 0; // h
    _jump571:; // Begin body of loop
    double _700 = 37.0;
    _674 += _700;
    _697++;
    if (_697 < _696)
    goto _jump571;
    _697 = 0;
    _698++;
    if (_698 < _678)
    goto _jump571;
    _698 = 0;
    _699++;
    if (_699 < _677)
    goto _jump571;
    // End body of loop
    double _701 = 69.0;
    double _702 = -_701;
    double _703 = 49.0;
    double _704 = -_703;
    double _705 = -_704;
    bool _706 = _702 < _705;
    double _707;
    if (!_706)
    goto _jump572;
    _a2_double _708;
    // Computing bound for h
    _708.d0 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    // Computing bound for i
    _708.d1 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing total size of heap memory to allocate
    int64_t _709 = 1;
    _709 *= _502.d0;
    _709 *= _653.d0;
    _709 *= sizeof(double);
    _708.data = jpl_alloc(_709);
    int64_t _710 = 0; // i
    int64_t _711 = 0; // h
    _jump575:; // Begin body of loop
    double _712;
    // Computing bound for j
    if (_653.d1 > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing bound for k
    int64_t _713 = 834;
    if (_713 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing bound for l
    if (_502.d0 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    _712 = 0;
    int64_t _714 = 0; // l
    int64_t _715 = 0; // k
    int64_t _716 = 0; // j
    _jump579:; // Begin body of loop
    double _717 = 8.0;
    _712 += _717;
    _714++;
    if (_714 < _502.d0)
    goto _jump579;
    _714 = 0;
    _715++;
    if (_715 < _713)
    goto _jump579;
    _715 = 0;
    _716++;
    if (_716 < _653.d1)
    goto _jump579;
    // End body of loop
    int64_t _718 = 0;
    _718 *= _708.d0;
    _718 += _711;
    _718 *= _708.d1;
    _718 += _710;
    _708.data[_718] = _712;
    _710++;
    if (_710 < _653.d0)
    goto _jump575;
    _710 = 0;
    _711++;
    if (_711 < _502.d0)
    goto _jump575;
    // End body of loop
    if (_502.d0 >= 0)
    goto _jump580;
    fail_assertion("negative array index");
    _jump580:;
    if (_502.d0 < _708.d0)
    goto _jump581;
    fail_assertion("index too large");
    _jump581:;
    if (_653.d1 >= 0)
    goto _jump582;
    fail_assertion("negative array index");
    _jump582:;
    if (_653.d1 < _708.d1)
    goto _jump583;
    fail_assertion("index too large");
    _jump583:;
    int64_t _719 = 0;
    _719 *= _708.d0;
    _719 += _502.d0;
    _719 *= _708.d1;
    _719 += _653.d1;
    double _720 = _708.data[_719];
    _707 = _720;
    goto _jump584;
    _jump572:;
    bool _722 = false;
    bool _721 = _722;
    if (0 == _722)
    goto _jump585;
    bool _723 = true;
    _721 = _723;
    _jump585:;
    bool _724;
    if (!_721)
    goto _jump586;
    bool _725 = true;
    _724 = _725;
    goto _jump587;
    _jump586:;
    bool _726 = d();
    _724 = _726;
    _jump587:;
    double _727;
    if (!_724)
    goto _jump588;
    double _728 = 0.0;
    double _729 = 89.0;
    double _730 = _728 * _729;
    double _731 = 53.0;
    double _732 = -_731;
    double _733 = fmod(_730, _732);
    _727 = _733;
    goto _jump589;
    _jump588:;
    double _734 = 90.0;
    double _735 = 28.0;
    double _736 = -_735;
    double _737 = _734 * _736;
    _727 = _737;
    _jump589:;
    _707 = _727;
    _jump584:;
    bool _738 = _674 != _707;
    _672 = _738;
    _jump551:;
    _a2_bool _739;
    if (!_672)
    goto _jump590;
    _a2__a2_double _740;
    // Computing bound for h
    _740.d0 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for i
    int64_t _741 = 541;
    int64_t _742 = -_741;
    _740.d1 = _742;
    if (_742 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    // Computing total size of heap memory to allocate
    int64_t _743 = 1;
    _743 *= _653.d1;
    _743 *= _742;
    _743 *= sizeof(_a2_double);
    _740.data = jpl_alloc(_743);
    int64_t _744 = 0; // i
    int64_t _745 = 0; // h
    _jump593:; // Begin body of loop
    _a2_double _746;
    // Computing bound for j
    _746.d0 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for k
    _746.d1 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing total size of heap memory to allocate
    int64_t _747 = 1;
    _747 *= _653.d0;
    _747 *= _653.d0;
    _747 *= sizeof(double);
    _746.data = jpl_alloc(_747);
    int64_t _748 = 0; // k
    int64_t _749 = 0; // j
    _jump596:; // Begin body of loop
    double _750 = 36.0;
    int64_t _751 = 0;
    _751 *= _746.d0;
    _751 += _749;
    _751 *= _746.d1;
    _751 += _748;
    _746.data[_751] = _750;
    _748++;
    if (_748 < _653.d0)
    goto _jump596;
    _748 = 0;
    _749++;
    if (_749 < _653.d0)
    goto _jump596;
    // End body of loop
    int64_t _752 = 0;
    _752 *= _740.d0;
    _752 += _745;
    _752 *= _740.d1;
    _752 += _744;
    _740.data[_752] = _746;
    _744++;
    if (_744 < _742)
    goto _jump593;
    _744 = 0;
    _745++;
    if (_745 < _653.d1)
    goto _jump593;
    // End body of loop
    if (_653.d1 >= 0)
    goto _jump597;
    fail_assertion("negative array index");
    _jump597:;
    if (_653.d1 < _740.d0)
    goto _jump598;
    fail_assertion("index too large");
    _jump598:;
    if (_653.d1 >= 0)
    goto _jump599;
    fail_assertion("negative array index");
    _jump599:;
    if (_653.d1 < _740.d1)
    goto _jump600;
    fail_assertion("index too large");
    _jump600:;
    int64_t _753 = 0;
    _753 *= _740.d0;
    _753 += _653.d1;
    _753 *= _740.d1;
    _753 += _653.d1;
    _a2_double _754 = _740.data[_753];
    int64_t _755 = _653.d1 - _502.d0;
    int64_t _756 = -_755;
    int64_t _757 = 140;
    if (_756 >= 0)
    goto _jump601;
    fail_assertion("negative array index");
    _jump601:;
    if (_756 < _754.d0)
    goto _jump602;
    fail_assertion("index too large");
    _jump602:;
    if (_757 >= 0)
    goto _jump603;
    fail_assertion("negative array index");
    _jump603:;
    if (_757 < _754.d1)
    goto _jump604;
    fail_assertion("index too large");
    _jump604:;
    int64_t _758 = 0;
    _758 *= _754.d0;
    _758 += _756;
    _758 *= _754.d1;
    _758 += _757;
    double _759 = _754.data[_758];
    bool _760 = d();
    bool _761;
    if (!_760)
    goto _jump605;
    bool _762 = d();
    bool _763 = !_762;
    bool _764;
    if (!_763)
    goto _jump606;
    bool _765 = _653.d1 == _502.d0;
    _764 = _765;
    goto _jump607;
    _jump606:;
    bool _766 = d();
    _764 = _766;
    _jump607:;
    _761 = _764;
    goto _jump608;
    _jump605:;
    bool _767 = false;
    bool _768 = !_767;
    _761 = _768;
    _jump608:;
    double _769;
    if (!_761)
    goto _jump609;
    double _770 = 22.0;
    _769 = _770;
    goto _jump610;
    _jump609:;
    double _771 = 82.0;
    _769 = _771;
    _jump610:;
    bool _772 = _759 == _769;
    _a2_bool _773;
    if (!_772)
    goto _jump611;
    _a3__a2_bool _774;
    // Computing bound for h
    int64_t _775 = 407;
    int64_t _776 = -_775;
    _774.d0 = _776;
    if (_776 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing bound for i
    int64_t _777 = 199;
    int64_t _778 = _653.d1 * _777;
    _774.d1 = _778;
    if (_778 > 0) 
    goto _jump613;
    fail_assertion("non-positive loop bound");
    _jump613:;
    // Computing bound for j
    _774.d2 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump614;
    fail_assertion("non-positive loop bound");
    _jump614:;
    // Computing total size of heap memory to allocate
    int64_t _779 = 1;
    _779 *= _776;
    _779 *= _778;
    _779 *= _653.d1;
    _779 *= sizeof(_a2_bool);
    _774.data = jpl_alloc(_779);
    int64_t _780 = 0; // j
    int64_t _781 = 0; // i
    int64_t _782 = 0; // h
    _jump615:; // Begin body of loop
    int64_t _783 = 0;
    _783 *= _774.d0;
    _783 += _782;
    _783 *= _774.d1;
    _783 += _781;
    _783 *= _774.d2;
    _783 += _780;
    _774.data[_783] = _653;
    _780++;
    if (_780 < _653.d1)
    goto _jump615;
    _780 = 0;
    _781++;
    if (_781 < _778)
    goto _jump615;
    _781 = 0;
    _782++;
    if (_782 < _776)
    goto _jump615;
    // End body of loop
    int64_t _784 = 492;
    if (_502.d0 >= 0)
    goto _jump616;
    fail_assertion("negative array index");
    _jump616:;
    if (_502.d0 < _774.d0)
    goto _jump617;
    fail_assertion("index too large");
    _jump617:;
    if (_653.d0 >= 0)
    goto _jump618;
    fail_assertion("negative array index");
    _jump618:;
    if (_653.d0 < _774.d1)
    goto _jump619;
    fail_assertion("index too large");
    _jump619:;
    if (_784 >= 0)
    goto _jump620;
    fail_assertion("negative array index");
    _jump620:;
    if (_784 < _774.d2)
    goto _jump621;
    fail_assertion("index too large");
    _jump621:;
    int64_t _785 = 0;
    _785 *= _774.d0;
    _785 += _502.d0;
    _785 *= _774.d1;
    _785 += _653.d0;
    _785 *= _774.d2;
    _785 += _784;
    _a2_bool _786 = _774.data[_785];
    _a1__a2_bool _787;
    _787.d0 = 2;
    _787.data = jpl_alloc(sizeof(_a2_bool) * 2);
    _787.data[0] = _653;
    _787.data[1] = _786;
    _a2_int64_t _788;
    // Computing bound for h
    _788.d0 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    // Computing bound for i
    int64_t _789 = 490;
    int64_t _790 = _789 / _653.d1;
    int64_t _791 = 76;
    int64_t _792 = _790 + _791;
    _788.d1 = _792;
    if (_792 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    // Computing total size of heap memory to allocate
    int64_t _793 = 1;
    _793 *= _653.d1;
    _793 *= _792;
    _793 *= sizeof(int64_t);
    _788.data = jpl_alloc(_793);
    int64_t _794 = 0; // i
    int64_t _795 = 0; // h
    _jump624:; // Begin body of loop
    int64_t _796 = -_653.d1;
    int64_t _797 = _796 - _794;
    int64_t _798 = 0;
    _798 *= _788.d0;
    _798 += _795;
    _798 *= _788.d1;
    _798 += _794;
    _788.data[_798] = _797;
    _794++;
    if (_794 < _792)
    goto _jump624;
    _794 = 0;
    _795++;
    if (_795 < _653.d1)
    goto _jump624;
    // End body of loop
    int64_t _799 = 400;
    if (_502.d0 >= 0)
    goto _jump625;
    fail_assertion("negative array index");
    _jump625:;
    if (_502.d0 < _788.d0)
    goto _jump626;
    fail_assertion("index too large");
    _jump626:;
    if (_799 >= 0)
    goto _jump627;
    fail_assertion("negative array index");
    _jump627:;
    if (_799 < _788.d1)
    goto _jump628;
    fail_assertion("index too large");
    _jump628:;
    int64_t _800 = 0;
    _800 *= _788.d0;
    _800 += _502.d0;
    _800 *= _788.d1;
    _800 += _799;
    int64_t _801 = _788.data[_800];
    if (_801 >= 0)
    goto _jump629;
    fail_assertion("negative array index");
    _jump629:;
    if (_801 < _787.d0)
    goto _jump630;
    fail_assertion("index too large");
    _jump630:;
    int64_t _802 = 0;
    _802 *= _787.d0;
    _802 += _801;
    _a2_bool _803 = _787.data[_802];
    _773 = _803;
    goto _jump631;
    _jump611:;
    _a2_bool _804;
    // Computing bound for h
    int64_t _805 = 898;
    int64_t _806 = -_805;
    _804.d0 = _806;
    if (_806 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for i
    int64_t _807;
    // Computing bound for h
    int64_t _808 = -_653.d1;
    if (_808 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    _807 = 0;
    int64_t _809 = 0; // h
    _jump634:; // Begin body of loop
    int64_t _810 = 610;
    _807 += _810;
    _809++;
    if (_809 < _808)
    goto _jump634;
    // End body of loop
    int64_t _811;
    // Computing bound for h
    if (_502.d0 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    _811 = 0;
    int64_t _812 = 0; // h
    _jump636:; // Begin body of loop
    int64_t _813 = 129;
    _811 += _813;
    _812++;
    if (_812 < _502.d0)
    goto _jump636;
    // End body of loop
    int64_t _814 = 658;
    bool _815 = _811 >= _814;
    int64_t _816;
    if (!_815)
    goto _jump637;
    int64_t _817 = _653.d1 / _653.d1;
    _816 = _817;
    goto _jump638;
    _jump637:;
    _a2_int64_t _818;
    // Computing bound for h
    _818.d0 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump639;
    fail_assertion("non-positive loop bound");
    _jump639:;
    // Computing bound for i
    _818.d1 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing total size of heap memory to allocate
    int64_t _819 = 1;
    _819 *= _502.d0;
    _819 *= _653.d0;
    _819 *= sizeof(int64_t);
    _818.data = jpl_alloc(_819);
    int64_t _820 = 0; // i
    int64_t _821 = 0; // h
    _jump641:; // Begin body of loop
    int64_t _822 = 0;
    _822 *= _818.d0;
    _822 += _821;
    _822 *= _818.d1;
    _822 += _820;
    _818.data[_822] = _502.d0;
    _820++;
    if (_820 < _653.d0)
    goto _jump641;
    _820 = 0;
    _821++;
    if (_821 < _502.d0)
    goto _jump641;
    // End body of loop
    if (_502.d0 >= 0)
    goto _jump642;
    fail_assertion("negative array index");
    _jump642:;
    if (_502.d0 < _818.d0)
    goto _jump643;
    fail_assertion("index too large");
    _jump643:;
    if (_502.d0 >= 0)
    goto _jump644;
    fail_assertion("negative array index");
    _jump644:;
    if (_502.d0 < _818.d1)
    goto _jump645;
    fail_assertion("index too large");
    _jump645:;
    int64_t _823 = 0;
    _823 *= _818.d0;
    _823 += _502.d0;
    _823 *= _818.d1;
    _823 += _502.d0;
    int64_t _824 = _818.data[_823];
    _816 = _824;
    _jump638:;
    int64_t _825 = _807 / _816;
    _804.d1 = _825;
    if (_825 > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing total size of heap memory to allocate
    int64_t _826 = 1;
    _826 *= _806;
    _826 *= _825;
    _826 *= sizeof(bool);
    _804.data = jpl_alloc(_826);
    int64_t _827 = 0; // i
    int64_t _828 = 0; // h
    _jump647:; // Begin body of loop
    _a2_bool _829;
    // Computing bound for j
    if (_653.d0 >= 0)
    goto _jump648;
    fail_assertion("negative array index");
    _jump648:;
    if (_653.d0 < _653.d0)
    goto _jump649;
    fail_assertion("index too large");
    _jump649:;
    if (_827 >= 0)
    goto _jump650;
    fail_assertion("negative array index");
    _jump650:;
    if (_827 < _653.d1)
    goto _jump651;
    fail_assertion("index too large");
    _jump651:;
    int64_t _830 = 0;
    _830 *= _653.d0;
    _830 += _653.d0;
    _830 *= _653.d1;
    _830 += _827;
    bool _831 = _653.data[_830];
    int64_t _832;
    if (!_831)
    goto _jump652;
    int64_t _833 = _827 % _653.d1;
    _832 = _833;
    goto _jump653;
    _jump652:;
    int64_t _834;
    // Computing bound for j
    if (_653.d1 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    _834 = 0;
    int64_t _835 = 0; // j
    _jump655:; // Begin body of loop
    _834 += _828;
    _835++;
    if (_835 < _653.d1)
    goto _jump655;
    // End body of loop
    _832 = _834;
    _jump653:;
    _829.d0 = _832;
    if (_832 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing bound for k
    _829.d1 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump657;
    fail_assertion("non-positive loop bound");
    _jump657:;
    // Computing total size of heap memory to allocate
    int64_t _836 = 1;
    _836 *= _832;
    _836 *= _653.d0;
    _836 *= sizeof(bool);
    _829.data = jpl_alloc(_836);
    int64_t _837 = 0; // k
    int64_t _838 = 0; // j
    _jump658:; // Begin body of loop
    bool _839 = false;
    int64_t _840 = 0;
    _840 *= _829.d0;
    _840 += _838;
    _840 *= _829.d1;
    _840 += _837;
    _829.data[_840] = _839;
    _837++;
    if (_837 < _653.d0)
    goto _jump658;
    _837 = 0;
    _838++;
    if (_838 < _832)
    goto _jump658;
    // End body of loop
    int64_t _841 = 717;
    if (_841 >= 0)
    goto _jump659;
    fail_assertion("negative array index");
    _jump659:;
    if (_841 < _829.d0)
    goto _jump660;
    fail_assertion("index too large");
    _jump660:;
    if (_653.d1 >= 0)
    goto _jump661;
    fail_assertion("negative array index");
    _jump661:;
    if (_653.d1 < _829.d1)
    goto _jump662;
    fail_assertion("index too large");
    _jump662:;
    int64_t _842 = 0;
    _842 *= _829.d0;
    _842 += _841;
    _842 *= _829.d1;
    _842 += _653.d1;
    bool _843 = _829.data[_842];
    int64_t _844 = 0;
    _844 *= _804.d0;
    _844 += _828;
    _844 *= _804.d1;
    _844 += _827;
    _804.data[_844] = _843;
    _827++;
    if (_827 < _825)
    goto _jump647;
    _827 = 0;
    _828++;
    if (_828 < _806)
    goto _jump647;
    // End body of loop
    _773 = _804;
    _jump631:;
    _739 = _773;
    goto _jump663;
    _jump590:;
    double _847 = 52.0;
    double _848 = 1.0;
    bool _849 = _847 >= _848;
    bool _846 = _849;
    if (0 != _849)
    goto _jump664;
    int64_t _850 = 818;
    int64_t _851 = -_850;
    bool _852 = _502.d0 >= _851;
    _846 = _852;
    _jump664:;
    bool _845 = _846;
    if (0 != _846)
    goto _jump665;
    bool _853 = d();
    _845 = _853;
    _jump665:;
    _a2_bool _854;
    if (!_845)
    goto _jump666;
    _854 = _653;
    goto _jump667;
    _jump666:;
    bool _855 = d();
    _a1__a2_bool _856;
    if (!_855)
    goto _jump668;
    _a1__a2_bool _857;
    // Computing bound for h
    bool _858 = d();
    int64_t _859;
    if (!_858)
    goto _jump669;
    bool _860 = true;
    int64_t _861;
    if (!_860)
    goto _jump670;
    _861 = _502.d0;
    goto _jump671;
    _jump670:;
    _861 = _502.d0;
    _jump671:;
    _859 = _861;
    goto _jump672;
    _jump669:;
    int64_t _862 = -_502.d0;
    _859 = _862;
    _jump672:;
    _857.d0 = _859;
    if (_859 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    // Computing total size of heap memory to allocate
    int64_t _863 = 1;
    _863 *= _859;
    _863 *= sizeof(_a2_bool);
    _857.data = jpl_alloc(_863);
    int64_t _864 = 0; // h
    _jump674:; // Begin body of loop
    _a2__a2_bool _865;
    // Computing bound for i
    _865.d0 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    // Computing bound for j
    _865.d1 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump676;
    fail_assertion("non-positive loop bound");
    _jump676:;
    // Computing total size of heap memory to allocate
    int64_t _866 = 1;
    _866 *= _502.d0;
    _866 *= _653.d0;
    _866 *= sizeof(_a2_bool);
    _865.data = jpl_alloc(_866);
    int64_t _867 = 0; // j
    int64_t _868 = 0; // i
    _jump677:; // Begin body of loop
    int64_t _869 = 0;
    _869 *= _865.d0;
    _869 += _868;
    _869 *= _865.d1;
    _869 += _867;
    _865.data[_869] = _653;
    _867++;
    if (_867 < _653.d0)
    goto _jump677;
    _867 = 0;
    _868++;
    if (_868 < _502.d0)
    goto _jump677;
    // End body of loop
    int64_t _870 = 797;
    if (_870 >= 0)
    goto _jump678;
    fail_assertion("negative array index");
    _jump678:;
    if (_870 < _865.d0)
    goto _jump679;
    fail_assertion("index too large");
    _jump679:;
    if (_653.d0 >= 0)
    goto _jump680;
    fail_assertion("negative array index");
    _jump680:;
    if (_653.d0 < _865.d1)
    goto _jump681;
    fail_assertion("index too large");
    _jump681:;
    int64_t _871 = 0;
    _871 *= _865.d0;
    _871 += _870;
    _871 *= _865.d1;
    _871 += _653.d0;
    _a2_bool _872 = _865.data[_871];
    int64_t _873 = 0;
    _873 *= _857.d0;
    _873 += _864;
    _857.data[_873] = _872;
    _864++;
    if (_864 < _859)
    goto _jump674;
    // End body of loop
    _856 = _857;
    goto _jump682;
    _jump668:;
    bool _874 = true;
    _a2_bool _875;
    if (!_874)
    goto _jump683;
    bool _876 = false;
    _a2_bool _877;
    if (!_876)
    goto _jump684;
    _877 = _653;
    goto _jump685;
    _jump684:;
    _877 = _653;
    _jump685:;
    _875 = _877;
    goto _jump686;
    _jump683:;
    _875 = _653;
    _jump686:;
    bool _878 = false;
    _a2_bool _879;
    if (!_878)
    goto _jump687;
    _a2_bool _880;
    // Computing bound for h
    _880.d0 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for i
    _880.d1 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing total size of heap memory to allocate
    int64_t _881 = 1;
    _881 *= _502.d0;
    _881 *= _653.d1;
    _881 *= sizeof(bool);
    _880.data = jpl_alloc(_881);
    int64_t _882 = 0; // i
    int64_t _883 = 0; // h
    _jump690:; // Begin body of loop
    bool _884 = false;
    int64_t _885 = 0;
    _885 *= _880.d0;
    _885 += _883;
    _885 *= _880.d1;
    _885 += _882;
    _880.data[_885] = _884;
    _882++;
    if (_882 < _653.d1)
    goto _jump690;
    _882 = 0;
    _883++;
    if (_883 < _502.d0)
    goto _jump690;
    // End body of loop
    _879 = _880;
    goto _jump691;
    _jump687:;
    _879 = _653;
    _jump691:;
    _a1__a2_bool _886;
    _886.d0 = 3;
    _886.data = jpl_alloc(sizeof(_a2_bool) * 3);
    _886.data[0] = _653;
    _886.data[1] = _875;
    _886.data[2] = _879;
    _856 = _886;
    _jump682:;
    if (_653.d0 >= 0)
    goto _jump692;
    fail_assertion("negative array index");
    _jump692:;
    if (_653.d0 < _856.d0)
    goto _jump693;
    fail_assertion("index too large");
    _jump693:;
    int64_t _887 = 0;
    _887 *= _856.d0;
    _887 += _653.d0;
    _a2_bool _888 = _856.data[_887];
    _854 = _888;
    _jump667:;
    _739 = _854;
    _jump663:;
    _a1_bool _889;
    // Computing bound for k
    _889.d0 = _739.d1;
    if (_739.d1 > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    // Computing total size of heap memory to allocate
    int64_t _890 = 1;
    _890 *= _739.d1;
    _890 *= sizeof(bool);
    _889.data = jpl_alloc(_890);
    int64_t _891 = 0; // k
    _jump695:; // Begin body of loop
    _a3_bool _892;
    // Computing bound for l
    _892.d0 = _502.d0;
    if (_502.d0 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for m
    int64_t _893 = 305;
    _892.d1 = _893;
    if (_893 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    // Computing bound for n
    _892.d2 = _891;
    if (_891 > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    // Computing total size of heap memory to allocate
    int64_t _894 = 1;
    _894 *= _502.d0;
    _894 *= _893;
    _894 *= _891;
    _894 *= sizeof(bool);
    _892.data = jpl_alloc(_894);
    int64_t _895 = 0; // n
    int64_t _896 = 0; // m
    int64_t _897 = 0; // l
    _jump699:; // Begin body of loop
    bool _899 = false;
    bool _898 = _899;
    if (0 != _899)
    goto _jump700;
    _a1_bool _900;
    // Computing bound for o
    _900.d0 = _895;
    if (_895 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing total size of heap memory to allocate
    int64_t _901 = 1;
    _901 *= _895;
    _901 *= sizeof(bool);
    _900.data = jpl_alloc(_901);
    int64_t _902 = 0; // o
    _jump702:; // Begin body of loop
    bool _903 = false;
    int64_t _904 = 0;
    _904 *= _900.d0;
    _904 += _902;
    _900.data[_904] = _903;
    _902++;
    if (_902 < _895)
    goto _jump702;
    // End body of loop
    int64_t _905;
    // Computing bound for o
    if (_653.d1 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    _905 = 0;
    int64_t _906 = 0; // o
    _jump704:; // Begin body of loop
    _905 += _897;
    _906++;
    if (_906 < _653.d1)
    goto _jump704;
    // End body of loop
    if (_905 >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (_905 < _900.d0)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    int64_t _907 = 0;
    _907 *= _900.d0;
    _907 += _905;
    bool _908 = _900.data[_907];
    _898 = _908;
    _jump700:;
    int64_t _909 = 0;
    _909 *= _892.d0;
    _909 += _897;
    _909 *= _892.d1;
    _909 += _896;
    _909 *= _892.d2;
    _909 += _895;
    _892.data[_909] = _898;
    _895++;
    if (_895 < _891)
    goto _jump699;
    _895 = 0;
    _896++;
    if (_896 < _893)
    goto _jump699;
    _896 = 0;
    _897++;
    if (_897 < _502.d0)
    goto _jump699;
    // End body of loop
    if (_502.d0 >= 0)
    goto _jump707;
    fail_assertion("negative array index");
    _jump707:;
    if (_502.d0 < _892.d0)
    goto _jump708;
    fail_assertion("index too large");
    _jump708:;
    if (_502.d0 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (_502.d0 < _892.d1)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    if (_739.d1 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (_739.d1 < _892.d2)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    int64_t _910 = 0;
    _910 *= _892.d0;
    _910 += _502.d0;
    _910 *= _892.d1;
    _910 += _502.d0;
    _910 *= _892.d2;
    _910 += _739.d1;
    bool _911 = _892.data[_910];
    int64_t _912 = 0;
    _912 *= _889.d0;
    _912 += _891;
    _889.data[_912] = _911;
    _891++;
    if (_891 < _739.d1)
    goto _jump695;
    // End body of loop
    if (_653.d0 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_653.d0 < _889.d0)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    int64_t _913 = 0;
    _913 *= _889.d0;
    _913 += _653.d0;
    bool _914 = _889.data[_913];
    if (0 != _914)
    goto _jump715;
    fail_assertion("k");
    _jump715:;
    bool _915 = false;
    bool _916 = !_915;
    double _917 = get_time();
    _a2_rgba _918 = read_image("l.png");
    double _919 = get_time();
    print_time(_919 - _917);
    double _920;
    if (!_916)
    goto _jump716;
    double _921 = 83.0;
    _920 = _921;
    goto _jump717;
    _jump716:;
    double _922 = 49.0;
    double _923 = 28.0;
    double _924 = _922 + _923;
    double _925 = -_924;
    _920 = _925;
    _jump717:;
    double _926;
    // Computing bound for q
    int64_t _927;
    // Computing bound for q
    if (_653.d0 > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for r
    int64_t _928;
    // Computing bound for q
    if (_739.d1 > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing bound for r
    if (_502.d0 > 0) 
    goto _jump720;
    fail_assertion("non-positive loop bound");
    _jump720:;
    // Computing bound for s
    if (_502.d0 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    _928 = 0;
    int64_t _929 = 0; // s
    int64_t _930 = 0; // r
    int64_t _931 = 0; // q
    _jump722:; // Begin body of loop
    _928 += _930;
    _929++;
    if (_929 < _502.d0)
    goto _jump722;
    _929 = 0;
    _930++;
    if (_930 < _502.d0)
    goto _jump722;
    _930 = 0;
    _931++;
    if (_931 < _739.d1)
    goto _jump722;
    // End body of loop
    if (_928 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    _927 = 0;
    int64_t _932 = 0; // r
    int64_t _933 = 0; // q
    _jump724:; // Begin body of loop
    _927 += _502.d0;
    _932++;
    if (_932 < _928)
    goto _jump724;
    _932 = 0;
    _933++;
    if (_933 < _653.d0)
    goto _jump724;
    // End body of loop
    if (_927 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing bound for r
    if (_739.d0 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    // Computing bound for s
    if (_653.d0 > 0) 
    goto _jump727;
    fail_assertion("non-positive loop bound");
    _jump727:;
    _926 = 0;
    int64_t _934 = 0; // s
    int64_t _935 = 0; // r
    int64_t _936 = 0; // q
    _jump728:; // Begin body of loop
    _a1_double _937;
    if (!_916)
    goto _jump729;
    _937 = _502;
    goto _jump730;
    _jump729:;
    _937 = _502;
    _jump730:;
    if (_739.d0 >= 0)
    goto _jump731;
    fail_assertion("negative array index");
    _jump731:;
    if (_739.d0 < _937.d0)
    goto _jump732;
    fail_assertion("index too large");
    _jump732:;
    int64_t _938 = 0;
    _938 *= _937.d0;
    _938 += _739.d0;
    double _939 = _937.data[_938];
    _926 += _939;
    _934++;
    if (_934 < _653.d0)
    goto _jump728;
    _934 = 0;
    _935++;
    if (_935 < _739.d0)
    goto _jump728;
    _935 = 0;
    _936++;
    if (_936 < _927)
    goto _jump728;
    // End body of loop
    bool _940 = _920 >= _926;
    _a3_bool _941;
    if (!_940)
    goto _jump733;
    _a3_bool _942;
    // Computing bound for q
    _a1_int64_t _943;
    // Computing bound for q
    bool _944 = d();
    int64_t _945;
    if (!_944)
    goto _jump734;
    _945 = _739.d0;
    goto _jump735;
    _jump734:;
    _945 = _653.d0;
    _jump735:;
    _943.d0 = _945;
    if (_945 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing total size of heap memory to allocate
    int64_t _946 = 1;
    _946 *= _945;
    _946 *= sizeof(int64_t);
    _943.data = jpl_alloc(_946);
    int64_t _947 = 0; // q
    _jump737:; // Begin body of loop
    int64_t _948 = 0;
    _948 *= _943.d0;
    _948 += _947;
    _943.data[_948] = _653.d1;
    _947++;
    if (_947 < _945)
    goto _jump737;
    // End body of loop
    if (_653.d1 >= 0)
    goto _jump738;
    fail_assertion("negative array index");
    _jump738:;
    if (_653.d1 < _943.d0)
    goto _jump739;
    fail_assertion("index too large");
    _jump739:;
    int64_t _949 = 0;
    _949 *= _943.d0;
    _949 += _653.d1;
    int64_t _950 = _943.data[_949];
    _942.d0 = _950;
    if (_950 > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    // Computing bound for r
    _942.d1 = _739.d1;
    if (_739.d1 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for s
    int64_t _951 = 739;
    _942.d2 = _951;
    if (_951 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing total size of heap memory to allocate
    int64_t _952 = 1;
    _952 *= _950;
    _952 *= _739.d1;
    _952 *= _951;
    _952 *= sizeof(bool);
    _942.data = jpl_alloc(_952);
    int64_t _953 = 0; // s
    int64_t _954 = 0; // r
    int64_t _955 = 0; // q
    _jump743:; // Begin body of loop
    bool _956 = true;
    int64_t _957 = 0;
    _957 *= _942.d0;
    _957 += _955;
    _957 *= _942.d1;
    _957 += _954;
    _957 *= _942.d2;
    _957 += _953;
    _942.data[_957] = _956;
    _953++;
    if (_953 < _951)
    goto _jump743;
    _953 = 0;
    _954++;
    if (_954 < _739.d1)
    goto _jump743;
    _954 = 0;
    _955++;
    if (_955 < _950)
    goto _jump743;
    // End body of loop
    _941 = _942;
    goto _jump744;
    _jump733:;
    _a3__a3_bool _958;
    // Computing bound for q
    _958.d0 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing bound for r
    _958.d1 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing bound for s
    int64_t _959;
    if (!_916)
    goto _jump747;
    _959 = _739.d0;
    goto _jump748;
    _jump747:;
    _959 = _653.d1;
    _jump748:;
    int64_t _960 = -_959;
    _958.d2 = _960;
    if (_960 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing total size of heap memory to allocate
    int64_t _961 = 1;
    _961 *= _653.d1;
    _961 *= _653.d1;
    _961 *= _960;
    _961 *= sizeof(_a3_bool);
    _958.data = jpl_alloc(_961);
    int64_t _962 = 0; // s
    int64_t _963 = 0; // r
    int64_t _964 = 0; // q
    _jump750:; // Begin body of loop
    bool _965 = d();
    _a3_bool _966;
    if (!_965)
    goto _jump751;
    _a3_bool _967;
    // Computing bound for t
    _967.d0 = _963;
    if (_963 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for u
    _967.d1 = _739.d1;
    if (_739.d1 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing bound for v
    int64_t _968 = 855;
    _967.d2 = _968;
    if (_968 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    // Computing total size of heap memory to allocate
    int64_t _969 = 1;
    _969 *= _963;
    _969 *= _739.d1;
    _969 *= _968;
    _969 *= sizeof(bool);
    _967.data = jpl_alloc(_969);
    int64_t _970 = 0; // v
    int64_t _971 = 0; // u
    int64_t _972 = 0; // t
    _jump755:; // Begin body of loop
    int64_t _973 = 0;
    _973 *= _967.d0;
    _973 += _972;
    _973 *= _967.d1;
    _973 += _971;
    _973 *= _967.d2;
    _973 += _970;
    _967.data[_973] = _916;
    _970++;
    if (_970 < _968)
    goto _jump755;
    _970 = 0;
    _971++;
    if (_971 < _739.d1)
    goto _jump755;
    _971 = 0;
    _972++;
    if (_972 < _963)
    goto _jump755;
    // End body of loop
    _966 = _967;
    goto _jump756;
    _jump751:;
    _a3_bool _974;
    // Computing bound for t
    _974.d0 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump757;
    fail_assertion("non-positive loop bound");
    _jump757:;
    // Computing bound for u
    _974.d1 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing bound for v
    int64_t _975 = 784;
    _974.d2 = _975;
    if (_975 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing total size of heap memory to allocate
    int64_t _976 = 1;
    _976 *= _653.d1;
    _976 *= _653.d1;
    _976 *= _975;
    _976 *= sizeof(bool);
    _974.data = jpl_alloc(_976);
    int64_t _977 = 0; // v
    int64_t _978 = 0; // u
    int64_t _979 = 0; // t
    _jump760:; // Begin body of loop
    int64_t _980 = 0;
    _980 *= _974.d0;
    _980 += _979;
    _980 *= _974.d1;
    _980 += _978;
    _980 *= _974.d2;
    _980 += _977;
    _974.data[_980] = _916;
    _977++;
    if (_977 < _975)
    goto _jump760;
    _977 = 0;
    _978++;
    if (_978 < _653.d1)
    goto _jump760;
    _978 = 0;
    _979++;
    if (_979 < _653.d1)
    goto _jump760;
    // End body of loop
    _966 = _974;
    _jump756:;
    int64_t _981 = 0;
    _981 *= _958.d0;
    _981 += _964;
    _981 *= _958.d1;
    _981 += _963;
    _981 *= _958.d2;
    _981 += _962;
    _958.data[_981] = _966;
    _962++;
    if (_962 < _960)
    goto _jump750;
    _962 = 0;
    _963++;
    if (_963 < _653.d1)
    goto _jump750;
    _963 = 0;
    _964++;
    if (_964 < _653.d1)
    goto _jump750;
    // End body of loop
    int64_t _982 = 120;
    int64_t _983;
    // Computing bound for q
    if (_653.d0 > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    // Computing bound for r
    if (_653.d0 > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    _983 = 0;
    int64_t _984 = 0; // r
    int64_t _985 = 0; // q
    _jump763:; // Begin body of loop
    _a2_int64_t _986;
    // Computing bound for s
    _986.d0 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    // Computing bound for t
    _986.d1 = _985;
    if (_985 > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    // Computing total size of heap memory to allocate
    int64_t _987 = 1;
    _987 *= _653.d1;
    _987 *= _985;
    _987 *= sizeof(int64_t);
    _986.data = jpl_alloc(_987);
    int64_t _988 = 0; // t
    int64_t _989 = 0; // s
    _jump766:; // Begin body of loop
    int64_t _990 = 948;
    int64_t _991 = 0;
    _991 *= _986.d0;
    _991 += _989;
    _991 *= _986.d1;
    _991 += _988;
    _986.data[_991] = _990;
    _988++;
    if (_988 < _985)
    goto _jump766;
    _988 = 0;
    _989++;
    if (_989 < _653.d1)
    goto _jump766;
    // End body of loop
    int64_t _992;
    // Computing bound for s
    if (_739.d0 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for t
    if (_739.d0 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    // Computing bound for u
    if (_985 > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    _992 = 0;
    int64_t _993 = 0; // u
    int64_t _994 = 0; // t
    int64_t _995 = 0; // s
    _jump770:; // Begin body of loop
    _992 += _502.d0;
    _993++;
    if (_993 < _985)
    goto _jump770;
    _993 = 0;
    _994++;
    if (_994 < _739.d0)
    goto _jump770;
    _994 = 0;
    _995++;
    if (_995 < _739.d0)
    goto _jump770;
    // End body of loop
    int64_t _996 = -_653.d1;
    if (_992 >= 0)
    goto _jump771;
    fail_assertion("negative array index");
    _jump771:;
    if (_992 < _986.d0)
    goto _jump772;
    fail_assertion("index too large");
    _jump772:;
    if (_996 >= 0)
    goto _jump773;
    fail_assertion("negative array index");
    _jump773:;
    if (_996 < _986.d1)
    goto _jump774;
    fail_assertion("index too large");
    _jump774:;
    int64_t _997 = 0;
    _997 *= _986.d0;
    _997 += _992;
    _997 *= _986.d1;
    _997 += _996;
    int64_t _998 = _986.data[_997];
    _983 += _998;
    _984++;
    if (_984 < _653.d0)
    goto _jump763;
    _984 = 0;
    _985++;
    if (_985 < _653.d0)
    goto _jump763;
    // End body of loop
    if (_982 >= 0)
    goto _jump775;
    fail_assertion("negative array index");
    _jump775:;
    if (_982 < _958.d0)
    goto _jump776;
    fail_assertion("index too large");
    _jump776:;
    if (_983 >= 0)
    goto _jump777;
    fail_assertion("negative array index");
    _jump777:;
    if (_983 < _958.d1)
    goto _jump778;
    fail_assertion("index too large");
    _jump778:;
    if (_653.d0 >= 0)
    goto _jump779;
    fail_assertion("negative array index");
    _jump779:;
    if (_653.d0 < _958.d2)
    goto _jump780;
    fail_assertion("index too large");
    _jump780:;
    int64_t _999 = 0;
    _999 *= _958.d0;
    _999 += _982;
    _999 *= _958.d1;
    _999 += _983;
    _999 *= _958.d2;
    _999 += _653.d0;
    _a3_bool _1000 = _958.data[_999];
    _941 = _1000;
    _jump744:;
    int64_t _1001 = _653.d1 % _502.d0;
    if (_653.d0 >= 0)
    goto _jump781;
    fail_assertion("negative array index");
    _jump781:;
    if (_653.d0 < _941.d0)
    goto _jump782;
    fail_assertion("index too large");
    _jump782:;
    if (_653.d0 >= 0)
    goto _jump783;
    fail_assertion("negative array index");
    _jump783:;
    if (_653.d0 < _941.d1)
    goto _jump784;
    fail_assertion("index too large");
    _jump784:;
    if (_1001 >= 0)
    goto _jump785;
    fail_assertion("negative array index");
    _jump785:;
    if (_1001 < _941.d2)
    goto _jump786;
    fail_assertion("index too large");
    _jump786:;
    int64_t _1002 = 0;
    _1002 *= _941.d0;
    _1002 += _653.d0;
    _1002 *= _941.d1;
    _1002 += _653.d0;
    _1002 *= _941.d2;
    _1002 += _1001;
    bool _1003 = _941.data[_1002];
    _a1_double _1004;
    if (!_1003)
    goto _jump787;
    _1004 = _502;
    goto _jump788;
    _jump787:;
    _a2__a2__a1_double _1005;
    // Computing bound for q
    int64_t _1006;
    // Computing bound for q
    if (_653.d1 > 0) 
    goto _jump789;
    fail_assertion("non-positive loop bound");
    _jump789:;
    // Computing bound for r
    if (_739.d0 > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    _1006 = 0;
    int64_t _1007 = 0; // r
    int64_t _1008 = 0; // q
    _jump791:; // Begin body of loop
    _1006 += _1008;
    _1007++;
    if (_1007 < _739.d0)
    goto _jump791;
    _1007 = 0;
    _1008++;
    if (_1008 < _653.d1)
    goto _jump791;
    // End body of loop
    _1005.d0 = _1006;
    if (_1006 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing bound for r
    _1005.d1 = _739.d0;
    if (_739.d0 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    // Computing total size of heap memory to allocate
    int64_t _1009 = 1;
    _1009 *= _1006;
    _1009 *= _739.d0;
    _1009 *= sizeof(_a2__a1_double);
    _1005.data = jpl_alloc(_1009);
    int64_t _1010 = 0; // r
    int64_t _1011 = 0; // q
    _jump794:; // Begin body of loop
    _a2__a1_double _1012;
    // Computing bound for s
    int64_t _1013;
    if (!_916)
    goto _jump795;
    _1013 = _739.d0;
    goto _jump796;
    _jump795:;
    _1013 = _653.d1;
    _jump796:;
    int64_t _1014 = -_1013;
    _1012.d0 = _1014;
    if (_1014 > 0) 
    goto _jump797;
    fail_assertion("non-positive loop bound");
    _jump797:;
    // Computing bound for t
    _1012.d1 = _1010;
    if (_1010 > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing total size of heap memory to allocate
    int64_t _1015 = 1;
    _1015 *= _1014;
    _1015 *= _1010;
    _1015 *= sizeof(_a1_double);
    _1012.data = jpl_alloc(_1015);
    int64_t _1016 = 0; // t
    int64_t _1017 = 0; // s
    _jump799:; // Begin body of loop
    int64_t _1018 = 0;
    _1018 *= _1012.d0;
    _1018 += _1017;
    _1018 *= _1012.d1;
    _1018 += _1016;
    _1012.data[_1018] = _502;
    _1016++;
    if (_1016 < _1010)
    goto _jump799;
    _1016 = 0;
    _1017++;
    if (_1017 < _1014)
    goto _jump799;
    // End body of loop
    int64_t _1019 = 0;
    _1019 *= _1005.d0;
    _1019 += _1011;
    _1019 *= _1005.d1;
    _1019 += _1010;
    _1005.data[_1019] = _1012;
    _1010++;
    if (_1010 < _739.d0)
    goto _jump794;
    _1010 = 0;
    _1011++;
    if (_1011 < _1006)
    goto _jump794;
    // End body of loop
    int64_t _1020;
    // Computing bound for q
    int64_t _1021;
    // Computing bound for q
    if (_653.d1 > 0) 
    goto _jump800;
    fail_assertion("non-positive loop bound");
    _jump800:;
    // Computing bound for r
    if (_739.d1 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing bound for s
    int64_t _1022 = 10;
    if (_1022 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    _1021 = 0;
    int64_t _1023 = 0; // s
    int64_t _1024 = 0; // r
    int64_t _1025 = 0; // q
    _jump803:; // Begin body of loop
    _1021 += _502.d0;
    _1023++;
    if (_1023 < _1022)
    goto _jump803;
    _1023 = 0;
    _1024++;
    if (_1024 < _739.d1)
    goto _jump803;
    _1024 = 0;
    _1025++;
    if (_1025 < _653.d1)
    goto _jump803;
    // End body of loop
    if (_1021 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    _1020 = 0;
    int64_t _1026 = 0; // q
    _jump805:; // Begin body of loop
    _1020 += _739.d0;
    _1026++;
    if (_1026 < _1021)
    goto _jump805;
    // End body of loop
    int64_t _1027 = _1020 - _739.d1;
    int64_t _1028 = _502.d0 % _1027;
    if (_502.d0 >= 0)
    goto _jump806;
    fail_assertion("negative array index");
    _jump806:;
    if (_502.d0 < _1005.d0)
    goto _jump807;
    fail_assertion("index too large");
    _jump807:;
    if (_1028 >= 0)
    goto _jump808;
    fail_assertion("negative array index");
    _jump808:;
    if (_1028 < _1005.d1)
    goto _jump809;
    fail_assertion("index too large");
    _jump809:;
    int64_t _1029 = 0;
    _1029 *= _1005.d0;
    _1029 += _502.d0;
    _1029 *= _1005.d1;
    _1029 += _1028;
    _a2__a1_double _1030 = _1005.data[_1029];
    int64_t _1031;
    // Computing bound for q
    if (_653.d0 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    // Computing bound for r
    if (_502.d0 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    _1031 = 0;
    int64_t _1032 = 0; // r
    int64_t _1033 = 0; // q
    _jump812:; // Begin body of loop
    _1031 += _502.d0;
    _1032++;
    if (_1032 < _502.d0)
    goto _jump812;
    _1032 = 0;
    _1033++;
    if (_1033 < _653.d0)
    goto _jump812;
    // End body of loop
    if (_653.d0 >= 0)
    goto _jump813;
    fail_assertion("negative array index");
    _jump813:;
    if (_653.d0 < _1030.d0)
    goto _jump814;
    fail_assertion("index too large");
    _jump814:;
    if (_1031 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (_1031 < _1030.d1)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    int64_t _1034 = 0;
    _1034 *= _1030.d0;
    _1034 += _653.d0;
    _1034 *= _1030.d1;
    _1034 += _1031;
    _a1_double _1035 = _1030.data[_1034];
    _1004 = _1035;
    _jump788:;
    _a2_rgba _1036 = read_image("s.png");
    int64_t t = _1036.d0;
    int64_t u = _1036.d1;
    _a2_rgba _1037 = read_image("v.png");
    _a2_rgba _1038 = read_image("x.png");
    _a3__a2_rgba _1039;
    // Computing bound for z
    _1039.d0 = _653.d0;
    if (_653.d0 > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for A
    _1039.d1 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    // Computing bound for B
    int64_t _1040;
    // Computing bound for z
    if (_653.d1 > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing bound for A
    _a3__a1_int64_t _1041;
    // Computing bound for z
    _1041.d0 = _1036.d0;
    if (_1036.d0 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing bound for A
    _1041.d1 = _1036.d0;
    if (_1036.d0 > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for B
    _1041.d2 = _1004.d0;
    if (_1004.d0 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing total size of heap memory to allocate
    int64_t _1042 = 1;
    _1042 *= _1036.d0;
    _1042 *= _1036.d0;
    _1042 *= _1004.d0;
    _1042 *= sizeof(_a1_int64_t);
    _1041.data = jpl_alloc(_1042);
    int64_t _1043 = 0; // B
    int64_t _1044 = 0; // A
    int64_t _1045 = 0; // z
    _jump962:; // Begin body of loop
    _a1_int64_t _1046;
    // Computing bound for C
    _1046.d0 = _653.d1;
    if (_653.d1 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    // Computing total size of heap memory to allocate
    int64_t _1047 = 1;
    _1047 *= _653.d1;
    _1047 *= sizeof(int64_t);
    _1046.data = jpl_alloc(_1047);
    int64_t _1048 = 0; // C
    _jump964:; // Begin body of loop
    int64_t _1049 = 0;
    _1049 *= _1046.d0;
    _1049 += _1048;
    _1046.data[_1049] = _1036.d0;
    _1048++;
    if (_1048 < _653.d1)
    goto _jump964;
    // End body of loop
    int64_t _1050 = 0;
    _1050 *= _1041.d0;
    _1050 += _1045;
    _1050 *= _1041.d1;
    _1050 += _1044;
    _1050 *= _1041.d2;
    _1050 += _1043;
    _1041.data[_1050] = _1046;
    _1043++;
    if (_1043 < _1004.d0)
    goto _jump962;
    _1043 = 0;
    _1044++;
    if (_1044 < _1036.d0)
    goto _jump962;
    _1044 = 0;
    _1045++;
    if (_1045 < _1036.d0)
    goto _jump962;
    // End body of loop
    if (_1036.d1 >= 0)
    goto _jump965;
    fail_assertion("negative array index");
    _jump965:;
    if (_1036.d1 < _1041.d0)
    goto _jump966;
    fail_assertion("index too large");
    _jump966:;
    if (_1036.d0 >= 0)
    goto _jump967;
    fail_assertion("negative array index");
    _jump967:;
    if (_1036.d0 < _1041.d1)
    goto _jump968;
    fail_assertion("index too large");
    _jump968:;
    if (_1036.d0 >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (_1036.d0 < _1041.d2)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    int64_t _1051 = 0;
    _1051 *= _1041.d0;
    _1051 += _1036.d1;
    _1051 *= _1041.d1;
    _1051 += _1036.d0;
    _1051 *= _1041.d2;
    _1051 += _1036.d0;
    _a1_int64_t _1052 = _1041.data[_1051];
    if (_653.d1 >= 0)
    goto _jump971;
    fail_assertion("negative array index");
    _jump971:;
    if (_653.d1 < _1052.d0)
    goto _jump972;
    fail_assertion("index too large");
    _jump972:;
    int64_t _1053 = 0;
    _1053 *= _1052.d0;
    _1053 += _653.d1;
    int64_t _1054 = _1052.data[_1053];
    if (_1054 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for B
    int64_t _1055 = _739.d1 * _653.d0;
    if (_1055 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    _1040 = 0;
    int64_t _1056 = 0; // B
    int64_t _1057 = 0; // A
    int64_t _1058 = 0; // z
    _jump975:; // Begin body of loop
    _1040 += _739.d1;
    _1056++;
    if (_1056 < _1055)
    goto _jump975;
    _1056 = 0;
    _1057++;
    if (_1057 < _1054)
    goto _jump975;
    _1057 = 0;
    _1058++;
    if (_1058 < _653.d1)
    goto _jump975;
    // End body of loop
    _1039.d2 = _1040;
    if (_1040 > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    // Computing total size of heap memory to allocate
    int64_t _1059 = 1;
    _1059 *= _653.d0;
    _1059 *= _653.d1;
    _1059 *= _1040;
    _1059 *= sizeof(_a2_rgba);
    _1039.data = jpl_alloc(_1059);
    int64_t _1060 = 0; // B
    int64_t _1061 = 0; // A
    int64_t _1062 = 0; // z
    _jump977:; // Begin body of loop
    int64_t _1063 = 0;
    _1063 *= _1039.d0;
    _1063 += _1062;
    _1063 *= _1039.d1;
    _1063 += _1061;
    _1063 *= _1039.d2;
    _1063 += _1060;
    _1039.data[_1063] = _1038;
    _1060++;
    if (_1060 < _1040)
    goto _jump977;
    _1060 = 0;
    _1061++;
    if (_1061 < _653.d1)
    goto _jump977;
    _1061 = 0;
    _1062++;
    if (_1062 < _653.d0)
    goto _jump977;
    // End body of loop
    if (_653.d0 >= 0)
    goto _jump978;
    fail_assertion("negative array index");
    _jump978:;
    if (_653.d0 < _1039.d0)
    goto _jump979;
    fail_assertion("index too large");
    _jump979:;
    if (_653.d1 >= 0)
    goto _jump980;
    fail_assertion("negative array index");
    _jump980:;
    if (_653.d1 < _1039.d1)
    goto _jump981;
    fail_assertion("index too large");
    _jump981:;
    if (_1004.d0 >= 0)
    goto _jump982;
    fail_assertion("negative array index");
    _jump982:;
    if (_1004.d0 < _1039.d2)
    goto _jump983;
    fail_assertion("index too large");
    _jump983:;
    int64_t _1064 = 0;
    _1064 *= _1039.d0;
    _1064 += _653.d0;
    _1064 *= _1039.d1;
    _1064 += _653.d1;
    _1064 *= _1039.d2;
    _1064 += _1004.d0;
    _a2_rgba _1065 = _1039.data[_1064];
    _a1_bool _1066;
    _1066.d0 = 1;
    _1066.data = jpl_alloc(sizeof(bool) * 1);
    _1066.data[0] = _916;
}

