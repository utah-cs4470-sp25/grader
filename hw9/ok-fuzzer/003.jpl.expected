
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
    bool a;
    void_t b;
    bool c;
} a;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  _a2_void_t *data;
} _a1__a2_void_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  _a1_rgba *data;
} _a1__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a1_int64_t *data;
} _a2__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  _a3__a1_int64_t *data;
} _a1__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1_rgba *data;
} _a2__a1__a1_rgba;

typedef struct {
    rgba a;
} q;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
    rgba a;
    a b;
} y;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
    q a;
    a b;
    _a1_void_t c;
} F;

void_t n(double o, _a1_bool p, rgba r) {
    _a2_int64_t _0;
    // Computing bound for s
    _0.d0 = f;
    if (f > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for t
    _0.d1 = k;
    if (k > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= f;
    _1 *= k;
    _1 *= sizeof(int64_t);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // t
    int64_t _3 = 0; // s
    _jump539:; // Begin body of loop
    int64_t _4 = 0;
    _4 *= _0.d0;
    _4 += _3;
    _4 *= _0.d1;
    _4 += _2;
    _0.data[_4] = k;
    _2++;
    if (_2 < k)
    goto _jump539;
    _2 = 0;
    _3++;
    if (_3 < f)
    goto _jump539;
    // End body of loop
    double _5;
    // Computing bound for v
    if (k > 0) 
    goto _jump540;
    fail_assertion("non-positive loop bound");
    _jump540:;
    _5 = 0;
    int64_t _6 = 0; // v
    _jump541:; // Begin body of loop
    double _7 = r.g;
    _5 += _7;
    _6++;
    if (_6 < k)
    goto _jump541;
    // End body of loop
    _a1_double _8;
    _8.d0 = 2;
    _8.data = jpl_alloc(sizeof(double) * 2);
    _8.data[0] = o;
    _8.data[1] = _5;
    if (h >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (h < _8.d0)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    int64_t _9 = 0;
    _9 *= _8.d0;
    _9 += h;
    double _10 = _8.data[_9];
    double _11;
    // Computing bound for v
    int64_t _12 = -l;
    if (_12 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for w
    int64_t _13 = g * m;
    int64_t _14 = _0.d0 - _13;
    if (_14 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing bound for x
    if (g > 0) 
    goto _jump546;
    fail_assertion("non-positive loop bound");
    _jump546:;
    _11 = 0;
    int64_t _15 = 0; // x
    int64_t _16 = 0; // w
    int64_t _17 = 0; // v
    _jump547:; // Begin body of loop
    double _18 = 33.0;
    rgba _19 = { i, o, _18, d };
    double _20 = _19.a;
    _11 += _20;
    _15++;
    if (_15 < g)
    goto _jump547;
    _15 = 0;
    _16++;
    if (_16 < _14)
    goto _jump547;
    _16 = 0;
    _17++;
    if (_17 < _12)
    goto _jump547;
    // End body of loop
    bool _21 = i == _11;
    _a2_rgba _22;
    if (!_21)
    goto _jump548;
    bool _23 = true;
    _a2_rgba _24;
    if (!_23)
    goto _jump549;
    bool _25 = true;
    _a2_rgba _26;
    if (!_25)
    goto _jump550;
    _a2_rgba _27;
    // Computing bound for v
    int64_t _28 = -_0.d0;
    _27.d0 = _28;
    if (_28 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing bound for w
    _27.d1 = l;
    if (l > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _28;
    _29 *= l;
    _29 *= sizeof(rgba);
    _27.data = jpl_alloc(_29);
    int64_t _30 = 0; // w
    int64_t _31 = 0; // v
    _jump553:; // Begin body of loop
    int64_t _32 = 0;
    _32 *= _27.d0;
    _32 += _31;
    _32 *= _27.d1;
    _32 += _30;
    _27.data[_32] = r;
    _30++;
    if (_30 < l)
    goto _jump553;
    _30 = 0;
    _31++;
    if (_31 < _28)
    goto _jump553;
    // End body of loop
    _26 = _27;
    goto _jump554;
    _jump550:;
    bool _33 = false;
    _a2_rgba _34;
    if (!_33)
    goto _jump555;
    _a2_rgba _35;
    // Computing bound for v
    _35.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing bound for w
    _35.d1 = l;
    if (l > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _0.d0;
    _36 *= l;
    _36 *= sizeof(rgba);
    _35.data = jpl_alloc(_36);
    int64_t _37 = 0; // w
    int64_t _38 = 0; // v
    _jump558:; // Begin body of loop
    int64_t _39 = 0;
    _39 *= _35.d0;
    _39 += _38;
    _39 *= _35.d1;
    _39 += _37;
    _35.data[_39] = r;
    _37++;
    if (_37 < l)
    goto _jump558;
    _37 = 0;
    _38++;
    if (_38 < _0.d0)
    goto _jump558;
    // End body of loop
    _34 = _35;
    goto _jump559;
    _jump555:;
    _a2_rgba _40;
    // Computing bound for v
    _40.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump560;
    fail_assertion("non-positive loop bound");
    _jump560:;
    // Computing bound for w
    _40.d1 = c;
    if (c > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= _0.d1;
    _41 *= c;
    _41 *= sizeof(rgba);
    _40.data = jpl_alloc(_41);
    int64_t _42 = 0; // w
    int64_t _43 = 0; // v
    _jump562:; // Begin body of loop
    int64_t _44 = 0;
    _44 *= _40.d0;
    _44 += _43;
    _44 *= _40.d1;
    _44 += _42;
    _40.data[_44] = r;
    _42++;
    if (_42 < c)
    goto _jump562;
    _42 = 0;
    _43++;
    if (_43 < _0.d1)
    goto _jump562;
    // End body of loop
    _34 = _40;
    _jump559:;
    _26 = _34;
    _jump554:;
    _24 = _26;
    goto _jump563;
    _jump549:;
    _a2_rgba _45;
    // Computing bound for v
    _45.d0 = k;
    if (k > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing bound for w
    _45.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= k;
    _46 *= _0.d1;
    _46 *= sizeof(rgba);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // w
    int64_t _48 = 0; // v
    _jump566:; // Begin body of loop
    bool _49 = h == f;
    rgba _50;
    if (!_49)
    goto _jump567;
    _50 = r;
    goto _jump568;
    _jump567:;
    _50 = r;
    _jump568:;
    int64_t _51 = 0;
    _51 *= _45.d0;
    _51 += _48;
    _51 *= _45.d1;
    _51 += _47;
    _45.data[_51] = _50;
    _47++;
    if (_47 < _0.d1)
    goto _jump566;
    _47 = 0;
    _48++;
    if (_48 < k)
    goto _jump566;
    // End body of loop
    _24 = _45;
    _jump563:;
    _22 = _24;
    goto _jump569;
    _jump548:;
    _a2_rgba _52;
    // Computing bound for v
    int64_t _53 = _0.d1 / g;
    _52.d0 = _53;
    if (_53 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for w
    _52.d1 = l;
    if (l > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= _53;
    _54 *= l;
    _54 *= sizeof(rgba);
    _52.data = jpl_alloc(_54);
    int64_t _55 = 0; // w
    int64_t _56 = 0; // v
    _jump572:; // Begin body of loop
    double _57 = 14.0;
    bool _58 = _57 == i;
    _a3_rgba _59;
    if (!_58)
    goto _jump573;
    _a3_rgba _60;
    // Computing bound for x
    _60.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing bound for y
    _60.d1 = c;
    if (c > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    // Computing bound for z
    _60.d2 = k;
    if (k > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= _0.d1;
    _61 *= c;
    _61 *= k;
    _61 *= sizeof(rgba);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // z
    int64_t _63 = 0; // y
    int64_t _64 = 0; // x
    _jump577:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _60.d0;
    _65 += _64;
    _65 *= _60.d1;
    _65 += _63;
    _65 *= _60.d2;
    _65 += _62;
    _60.data[_65] = r;
    _62++;
    if (_62 < k)
    goto _jump577;
    _62 = 0;
    _63++;
    if (_63 < c)
    goto _jump577;
    _63 = 0;
    _64++;
    if (_64 < _0.d1)
    goto _jump577;
    // End body of loop
    _59 = _60;
    goto _jump578;
    _jump573:;
    _a3_rgba _66;
    // Computing bound for x
    _66.d0 = h;
    if (h > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for y
    _66.d1 = k;
    if (k > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    // Computing bound for z
    _66.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= h;
    _67 *= k;
    _67 *= _0.d0;
    _67 *= sizeof(rgba);
    _66.data = jpl_alloc(_67);
    int64_t _68 = 0; // z
    int64_t _69 = 0; // y
    int64_t _70 = 0; // x
    _jump582:; // Begin body of loop
    int64_t _71 = 0;
    _71 *= _66.d0;
    _71 += _70;
    _71 *= _66.d1;
    _71 += _69;
    _71 *= _66.d2;
    _71 += _68;
    _66.data[_71] = r;
    _68++;
    if (_68 < _0.d0)
    goto _jump582;
    _68 = 0;
    _69++;
    if (_69 < k)
    goto _jump582;
    _69 = 0;
    _70++;
    if (_70 < h)
    goto _jump582;
    // End body of loop
    _59 = _66;
    _jump578:;
    if (f >= 0)
    goto _jump583;
    fail_assertion("negative array index");
    _jump583:;
    if (f < _59.d0)
    goto _jump584;
    fail_assertion("index too large");
    _jump584:;
    if (p.d0 >= 0)
    goto _jump585;
    fail_assertion("negative array index");
    _jump585:;
    if (p.d0 < _59.d1)
    goto _jump586;
    fail_assertion("index too large");
    _jump586:;
    if (_55 >= 0)
    goto _jump587;
    fail_assertion("negative array index");
    _jump587:;
    if (_55 < _59.d2)
    goto _jump588;
    fail_assertion("index too large");
    _jump588:;
    int64_t _72 = 0;
    _72 *= _59.d0;
    _72 += f;
    _72 *= _59.d1;
    _72 += p.d0;
    _72 *= _59.d2;
    _72 += _55;
    rgba _73 = _59.data[_72];
    int64_t _74 = 0;
    _74 *= _52.d0;
    _74 += _56;
    _74 *= _52.d1;
    _74 += _55;
    _52.data[_74] = _73;
    _55++;
    if (_55 < l)
    goto _jump572;
    _55 = 0;
    _56++;
    if (_56 < _53)
    goto _jump572;
    // End body of loop
    _22 = _52;
    _jump569:;
    int64_t _75 = l % f;
    if (m >= 0)
    goto _jump589;
    fail_assertion("negative array index");
    _jump589:;
    if (m < _22.d0)
    goto _jump590;
    fail_assertion("index too large");
    _jump590:;
    if (_75 >= 0)
    goto _jump591;
    fail_assertion("negative array index");
    _jump591:;
    if (_75 < _22.d1)
    goto _jump592;
    fail_assertion("index too large");
    _jump592:;
    int64_t _76 = 0;
    _76 *= _22.d0;
    _76 += m;
    _76 *= _22.d1;
    _76 += _75;
    rgba _77 = _22.data[_76];
    void_t _78 = n(_10, p, _77);
    return _78;
    bool _79 = l >= h;
    if (0 != _79)
    goto _jump593;
    fail_assertion("v");
    _jump593:;
    int64_t _80 = 189;
    bool _81 = false;
    int64_t _82;
    if (!_81)
    goto _jump594;
    int64_t _83 = h + p.d0;
    _82 = _83;
    goto _jump595;
    _jump594:;
    _82 = k;
    _jump595:;
    bool _84 = _82 < l;
    if (0 != _84)
    goto _jump596;
    fail_assertion("w");
    _jump596:;
    _a2__a3_int64_t _85;
    // Computing bound for w
    _85.d0 = k;
    if (k > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    // Computing bound for x
    int64_t _86 = l % l;
    _85.d1 = _86;
    if (_86 > 0) 
    goto _jump598;
    fail_assertion("non-positive loop bound");
    _jump598:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= k;
    _87 *= _86;
    _87 *= sizeof(_a3_int64_t);
    _85.data = jpl_alloc(_87);
    int64_t _88 = 0; // x
    int64_t _89 = 0; // w
    _jump599:; // Begin body of loop
    bool _90 = true;
    _a3_int64_t _91;
    if (!_90)
    goto _jump600;
    _a3_int64_t _92;
    // Computing bound for y
    bool _93 = h == g;
    int64_t _94;
    if (!_93)
    goto _jump601;
    int64_t _95;
    // Computing bound for y
    if (h > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing bound for z
    if (f > 0) 
    goto _jump603;
    fail_assertion("non-positive loop bound");
    _jump603:;
    _95 = 0;
    int64_t _96 = 0; // z
    int64_t _97 = 0; // y
    _jump604:; // Begin body of loop
    _95 += _80;
    _96++;
    if (_96 < f)
    goto _jump604;
    _96 = 0;
    _97++;
    if (_97 < h)
    goto _jump604;
    // End body of loop
    _94 = _95;
    goto _jump605;
    _jump601:;
    _94 = _80;
    _jump605:;
    int64_t _98 = c + _94;
    _92.d0 = _98;
    if (_98 > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    // Computing bound for z
    _92.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    // Computing bound for A
    int64_t _99 = 239;
    _92.d2 = _99;
    if (_99 > 0) 
    goto _jump608;
    fail_assertion("non-positive loop bound");
    _jump608:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= _98;
    _100 *= _0.d0;
    _100 *= _99;
    _100 *= sizeof(int64_t);
    _92.data = jpl_alloc(_100);
    int64_t _101 = 0; // A
    int64_t _102 = 0; // z
    int64_t _103 = 0; // y
    _jump609:; // Begin body of loop
    int64_t _104 = 0;
    _104 *= _92.d0;
    _104 += _103;
    _104 *= _92.d1;
    _104 += _102;
    _104 *= _92.d2;
    _104 += _101;
    _92.data[_104] = p.d0;
    _101++;
    if (_101 < _99)
    goto _jump609;
    _101 = 0;
    _102++;
    if (_102 < _0.d0)
    goto _jump609;
    _102 = 0;
    _103++;
    if (_103 < _98)
    goto _jump609;
    // End body of loop
    _91 = _92;
    goto _jump610;
    _jump600:;
    _a3__a3_int64_t _105;
    // Computing bound for y
    _105.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for z
    bool _106 = false;
    int64_t _107;
    if (!_106)
    goto _jump612;
    _107 = _0.d1;
    goto _jump613;
    _jump612:;
    _107 = l;
    _jump613:;
    _105.d1 = _107;
    if (_107 > 0) 
    goto _jump614;
    fail_assertion("non-positive loop bound");
    _jump614:;
    // Computing bound for A
    _105.d2 = h;
    if (h > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= p.d0;
    _108 *= _107;
    _108 *= h;
    _108 *= sizeof(_a3_int64_t);
    _105.data = jpl_alloc(_108);
    int64_t _109 = 0; // A
    int64_t _110 = 0; // z
    int64_t _111 = 0; // y
    _jump616:; // Begin body of loop
    _a3_int64_t _112;
    // Computing bound for B
    _112.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    // Computing bound for C
    _112.d1 = _111;
    if (_111 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    // Computing bound for D
    if (_0.d0 >= 0)
    goto _jump619;
    fail_assertion("negative array index");
    _jump619:;
    if (_0.d0 < _0.d0)
    goto _jump620;
    fail_assertion("index too large");
    _jump620:;
    if (_88 >= 0)
    goto _jump621;
    fail_assertion("negative array index");
    _jump621:;
    if (_88 < _0.d1)
    goto _jump622;
    fail_assertion("index too large");
    _jump622:;
    int64_t _113 = 0;
    _113 *= _0.d0;
    _113 += _0.d0;
    _113 *= _0.d1;
    _113 += _88;
    int64_t _114 = _0.data[_113];
    _112.d2 = _114;
    if (_114 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= p.d0;
    _115 *= _111;
    _115 *= _114;
    _115 *= sizeof(int64_t);
    _112.data = jpl_alloc(_115);
    int64_t _116 = 0; // D
    int64_t _117 = 0; // C
    int64_t _118 = 0; // B
    _jump624:; // Begin body of loop
    int64_t _119 = 0;
    _119 *= _112.d0;
    _119 += _118;
    _119 *= _112.d1;
    _119 += _117;
    _119 *= _112.d2;
    _119 += _116;
    _112.data[_119] = _109;
    _116++;
    if (_116 < _114)
    goto _jump624;
    _116 = 0;
    _117++;
    if (_117 < _111)
    goto _jump624;
    _117 = 0;
    _118++;
    if (_118 < p.d0)
    goto _jump624;
    // End body of loop
    int64_t _120 = 0;
    _120 *= _105.d0;
    _120 += _111;
    _120 *= _105.d1;
    _120 += _110;
    _120 *= _105.d2;
    _120 += _109;
    _105.data[_120] = _112;
    _109++;
    if (_109 < h)
    goto _jump616;
    _109 = 0;
    _110++;
    if (_110 < _107)
    goto _jump616;
    _110 = 0;
    _111++;
    if (_111 < p.d0)
    goto _jump616;
    // End body of loop
    if (_88 >= 0)
    goto _jump625;
    fail_assertion("negative array index");
    _jump625:;
    if (_88 < _105.d0)
    goto _jump626;
    fail_assertion("index too large");
    _jump626:;
    if (h >= 0)
    goto _jump627;
    fail_assertion("negative array index");
    _jump627:;
    if (h < _105.d1)
    goto _jump628;
    fail_assertion("index too large");
    _jump628:;
    if (_88 >= 0)
    goto _jump629;
    fail_assertion("negative array index");
    _jump629:;
    if (_88 < _105.d2)
    goto _jump630;
    fail_assertion("index too large");
    _jump630:;
    int64_t _121 = 0;
    _121 *= _105.d0;
    _121 += _88;
    _121 *= _105.d1;
    _121 += h;
    _121 *= _105.d2;
    _121 += _88;
    _a3_int64_t _122 = _105.data[_121];
    _91 = _122;
    _jump610:;
    int64_t _123 = 0;
    _123 *= _85.d0;
    _123 += _89;
    _123 *= _85.d1;
    _123 += _88;
    _85.data[_123] = _91;
    _88++;
    if (_88 < _86)
    goto _jump599;
    _88 = 0;
    _89++;
    if (_89 < k)
    goto _jump599;
    // End body of loop
    if (p.d0 >= 0)
    goto _jump631;
    fail_assertion("negative array index");
    _jump631:;
    if (p.d0 < _85.d0)
    goto _jump632;
    fail_assertion("index too large");
    _jump632:;
    if (_0.d0 >= 0)
    goto _jump633;
    fail_assertion("negative array index");
    _jump633:;
    if (_0.d0 < _85.d1)
    goto _jump634;
    fail_assertion("index too large");
    _jump634:;
    int64_t _124 = 0;
    _124 *= _85.d0;
    _124 += p.d0;
    _124 *= _85.d1;
    _124 += _0.d0;
    _a3_int64_t _125 = _85.data[_124];
    double _126 = r.g;
    double _127 = r.a;
    bool _128 = _126 == _127;
    double _129 = r.r;
    void_t _130 = n(_129, p, r);
    bool _132 = p.d0 < g;
    bool _131 = _132;
    if (0 == _132)
    goto _jump635;
    bool _133 = h == c;
    _131 = _133;
    _jump635:;
    a _134 = { _128, _130, _131 };
    bool _135 = _134.a;
    bool _136 = !_135;
    bool _137;
    if (!_136)
    goto _jump636;
    _a2_bool _139;
    // Computing bound for A
    _139.d0 = _125.d2;
    if (_125.d2 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for B
    _a1_int64_t _140;
    // Computing bound for A
    _140.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= p.d0;
    _141 *= sizeof(int64_t);
    _140.data = jpl_alloc(_141);
    int64_t _142 = 0; // A
    _jump639:; // Begin body of loop
    int64_t _143 = 0;
    _143 *= _140.d0;
    _143 += _142;
    _140.data[_143] = _125.d1;
    _142++;
    if (_142 < p.d0)
    goto _jump639;
    // End body of loop
    if (_80 >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (_80 < _140.d0)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    int64_t _144 = 0;
    _144 *= _140.d0;
    _144 += _80;
    int64_t _145 = _140.data[_144];
    _139.d1 = _145;
    if (_145 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _125.d2;
    _146 *= _145;
    _146 *= sizeof(bool);
    _139.data = jpl_alloc(_146);
    int64_t _147 = 0; // B
    int64_t _148 = 0; // A
    _jump643:; // Begin body of loop
    bool _150 = _125.d1 <= _147;
    bool _149 = _150;
    if (0 == _150)
    goto _jump644;
    if (c >= 0)
    goto _jump645;
    fail_assertion("negative array index");
    _jump645:;
    if (c < p.d0)
    goto _jump646;
    fail_assertion("index too large");
    _jump646:;
    int64_t _151 = 0;
    _151 *= p.d0;
    _151 += c;
    bool _152 = p.data[_151];
    _149 = _152;
    _jump644:;
    int64_t _153 = 0;
    _153 *= _139.d0;
    _153 += _148;
    _153 *= _139.d1;
    _153 += _147;
    _139.data[_153] = _149;
    _147++;
    if (_147 < _145)
    goto _jump643;
    _147 = 0;
    _148++;
    if (_148 < _125.d2)
    goto _jump643;
    // End body of loop
    if (_125.d2 >= 0)
    goto _jump647;
    fail_assertion("negative array index");
    _jump647:;
    if (_125.d2 < _139.d0)
    goto _jump648;
    fail_assertion("index too large");
    _jump648:;
    if (_125.d2 >= 0)
    goto _jump649;
    fail_assertion("negative array index");
    _jump649:;
    if (_125.d2 < _139.d1)
    goto _jump650;
    fail_assertion("index too large");
    _jump650:;
    int64_t _154 = 0;
    _154 *= _139.d0;
    _154 += _125.d2;
    _154 *= _139.d1;
    _154 += _125.d2;
    bool _155 = _139.data[_154];
    bool _138 = _155;
    if (0 != _155)
    goto _jump651;
    bool _158 = false;
    bool _157 = _158;
    if (0 != _158)
    goto _jump652;
    bool _159 = true;
    _157 = _159;
    _jump652:;
    bool _156 = _157;
    if (0 == _157)
    goto _jump653;
    _a3_bool _160;
    // Computing bound for A
    int64_t _161 = h + _0.d0;
    _160.d0 = _161;
    if (_161 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing bound for B
    _160.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for C
    int64_t _162 = 272;
    int64_t _163 = _162 * p.d0;
    _160.d2 = _163;
    if (_163 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= _161;
    _164 *= _0.d1;
    _164 *= _163;
    _164 *= sizeof(bool);
    _160.data = jpl_alloc(_164);
    int64_t _165 = 0; // C
    int64_t _166 = 0; // B
    int64_t _167 = 0; // A
    _jump657:; // Begin body of loop
    bool _168 = false;
    int64_t _169 = 0;
    _169 *= _160.d0;
    _169 += _167;
    _169 *= _160.d1;
    _169 += _166;
    _169 *= _160.d2;
    _169 += _165;
    _160.data[_169] = _168;
    _165++;
    if (_165 < _163)
    goto _jump657;
    _165 = 0;
    _166++;
    if (_166 < _0.d1)
    goto _jump657;
    _166 = 0;
    _167++;
    if (_167 < _161)
    goto _jump657;
    // End body of loop
    if (f >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (f < _160.d0)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    if (_80 >= 0)
    goto _jump660;
    fail_assertion("negative array index");
    _jump660:;
    if (_80 < _160.d1)
    goto _jump661;
    fail_assertion("index too large");
    _jump661:;
    if (_125.d2 >= 0)
    goto _jump662;
    fail_assertion("negative array index");
    _jump662:;
    if (_125.d2 < _160.d2)
    goto _jump663;
    fail_assertion("index too large");
    _jump663:;
    int64_t _170 = 0;
    _170 *= _160.d0;
    _170 += f;
    _170 *= _160.d1;
    _170 += _80;
    _170 *= _160.d2;
    _170 += _125.d2;
    bool _171 = _160.data[_170];
    _156 = _171;
    _jump653:;
    _138 = _156;
    _jump651:;
    _137 = _138;
    goto _jump664;
    _jump636:;
    bool _172 = l != g;
    if (f >= 0)
    goto _jump665;
    fail_assertion("negative array index");
    _jump665:;
    if (f < p.d0)
    goto _jump666;
    fail_assertion("index too large");
    _jump666:;
    int64_t _173 = 0;
    _173 *= p.d0;
    _173 += f;
    bool _174 = p.data[_173];
    bool _175;
    if (!_174)
    goto _jump667;
    _a3_bool _176;
    // Computing bound for A
    _176.d0 = _80;
    if (_80 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    // Computing bound for B
    _176.d1 = h;
    if (h > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for C
    _176.d2 = p.d0;
    if (p.d0 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _80;
    _177 *= h;
    _177 *= p.d0;
    _177 *= sizeof(bool);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // C
    int64_t _179 = 0; // B
    int64_t _180 = 0; // A
    _jump671:; // Begin body of loop
    bool _181 = false;
    int64_t _182 = 0;
    _182 *= _176.d0;
    _182 += _180;
    _182 *= _176.d1;
    _182 += _179;
    _182 *= _176.d2;
    _182 += _178;
    _176.data[_182] = _181;
    _178++;
    if (_178 < p.d0)
    goto _jump671;
    _178 = 0;
    _179++;
    if (_179 < h)
    goto _jump671;
    _179 = 0;
    _180++;
    if (_180 < _80)
    goto _jump671;
    // End body of loop
    if (m >= 0)
    goto _jump672;
    fail_assertion("negative array index");
    _jump672:;
    if (m < _176.d0)
    goto _jump673;
    fail_assertion("index too large");
    _jump673:;
    if (l >= 0)
    goto _jump674;
    fail_assertion("negative array index");
    _jump674:;
    if (l < _176.d1)
    goto _jump675;
    fail_assertion("index too large");
    _jump675:;
    if (_0.d1 >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (_0.d1 < _176.d2)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    int64_t _183 = 0;
    _183 *= _176.d0;
    _183 += m;
    _183 *= _176.d1;
    _183 += l;
    _183 *= _176.d2;
    _183 += _0.d1;
    bool _184 = _176.data[_183];
    _175 = _184;
    goto _jump678;
    _jump667:;
    _a2_bool _185;
    // Computing bound for A
    _185.d0 = g;
    if (g > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing bound for B
    _185.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= g;
    _186 *= _0.d1;
    _186 *= sizeof(bool);
    _185.data = jpl_alloc(_186);
    int64_t _187 = 0; // B
    int64_t _188 = 0; // A
    _jump681:; // Begin body of loop
    bool _189 = false;
    int64_t _190 = 0;
    _190 *= _185.d0;
    _190 += _188;
    _190 *= _185.d1;
    _190 += _187;
    _185.data[_190] = _189;
    _187++;
    if (_187 < _0.d1)
    goto _jump681;
    _187 = 0;
    _188++;
    if (_188 < g)
    goto _jump681;
    // End body of loop
    if (h >= 0)
    goto _jump682;
    fail_assertion("negative array index");
    _jump682:;
    if (h < _185.d0)
    goto _jump683;
    fail_assertion("index too large");
    _jump683:;
    if (c >= 0)
    goto _jump684;
    fail_assertion("negative array index");
    _jump684:;
    if (c < _185.d1)
    goto _jump685;
    fail_assertion("index too large");
    _jump685:;
    int64_t _191 = 0;
    _191 *= _185.d0;
    _191 += h;
    _191 *= _185.d1;
    _191 += c;
    bool _192 = _185.data[_191];
    _175 = _192;
    _jump678:;
    bool _193 = _172 != _175;
    _137 = _193;
    _jump664:;
    void_t _194;
    if (!_137)
    goto _jump686;
    double _196;
    // Computing bound for A
    if (h > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing bound for B
    if (k > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for C
    if (m > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    _196 = 0;
    int64_t _197 = 0; // C
    int64_t _198 = 0; // B
    int64_t _199 = 0; // A
    _jump690:; // Begin body of loop
    _196 += d;
    _197++;
    if (_197 < m)
    goto _jump690;
    _197 = 0;
    _198++;
    if (_198 < k)
    goto _jump690;
    _198 = 0;
    _199++;
    if (_199 < h)
    goto _jump690;
    // End body of loop
    bool _200 = true;
    double _201;
    if (!_200)
    goto _jump691;
    _201 = i;
    goto _jump692;
    _jump691:;
    _201 = d;
    _jump692:;
    bool _202 = _196 < _201;
    bool _203;
    if (!_202)
    goto _jump693;
    bool _204 = false;
    _203 = _204;
    goto _jump694;
    _jump693:;
    bool _205 = true;
    _203 = _205;
    _jump694:;
    bool _195 = _203;
    if (0 == _203)
    goto _jump695;
    bool _207 = true;
    bool _206 = _207;
    if (0 != _207)
    goto _jump696;
    bool _208 = false;
    _206 = _208;
    _jump696:;
    _195 = _206;
    _jump695:;
    _a2_void_t _209;
    if (!_195)
    goto _jump697;
    _a3__a2_void_t _210;
    // Computing bound for A
    int64_t _211 = -_125.d0;
    _210.d0 = _211;
    if (_211 > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    // Computing bound for B
    _210.d1 = _125.d0;
    if (_125.d0 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    // Computing bound for C
    _210.d2 = p.d0;
    if (p.d0 > 0) 
    goto _jump700;
    fail_assertion("non-positive loop bound");
    _jump700:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= _211;
    _212 *= _125.d0;
    _212 *= p.d0;
    _212 *= sizeof(_a2_void_t);
    _210.data = jpl_alloc(_212);
    int64_t _213 = 0; // C
    int64_t _214 = 0; // B
    int64_t _215 = 0; // A
    _jump701:; // Begin body of loop
    _a2_void_t _216;
    // Computing bound for D
    int64_t _217;
    // Computing bound for D
    int64_t _218 = 944;
    if (_218 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    _217 = 0;
    int64_t _219 = 0; // D
    _jump703:; // Begin body of loop
    _217 += _219;
    _219++;
    if (_219 < _218)
    goto _jump703;
    // End body of loop
    _216.d0 = _217;
    if (_217 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for E
    _216.d1 = c;
    if (c > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing total size of heap memory to allocate
    int64_t _220 = 1;
    _220 *= _217;
    _220 *= c;
    _220 *= sizeof(void_t);
    _216.data = jpl_alloc(_220);
    int64_t _221 = 0; // E
    int64_t _222 = 0; // D
    _jump706:; // Begin body of loop
    double _223 = 19.0;
    void_t _224 = n(_223, p, r);
    int64_t _225 = 0;
    _225 *= _216.d0;
    _225 += _222;
    _225 *= _216.d1;
    _225 += _221;
    _216.data[_225] = _224;
    _221++;
    if (_221 < c)
    goto _jump706;
    _221 = 0;
    _222++;
    if (_222 < _217)
    goto _jump706;
    // End body of loop
    int64_t _226 = 0;
    _226 *= _210.d0;
    _226 += _215;
    _226 *= _210.d1;
    _226 += _214;
    _226 *= _210.d2;
    _226 += _213;
    _210.data[_226] = _216;
    _213++;
    if (_213 < p.d0)
    goto _jump701;
    _213 = 0;
    _214++;
    if (_214 < _125.d0)
    goto _jump701;
    _214 = 0;
    _215++;
    if (_215 < _211)
    goto _jump701;
    // End body of loop
    if (f >= 0)
    goto _jump707;
    fail_assertion("negative array index");
    _jump707:;
    if (f < _210.d0)
    goto _jump708;
    fail_assertion("index too large");
    _jump708:;
    if (_125.d0 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (_125.d0 < _210.d1)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    if (_0.d1 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (_0.d1 < _210.d2)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    int64_t _227 = 0;
    _227 *= _210.d0;
    _227 += f;
    _227 *= _210.d1;
    _227 += _125.d0;
    _227 *= _210.d2;
    _227 += _0.d1;
    _a2_void_t _228 = _210.data[_227];
    _209 = _228;
    goto _jump713;
    _jump697:;
    _a3__a2_void_t _229;
    // Computing bound for A
    _229.d0 = m;
    if (m > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for B
    _229.d1 = f;
    if (f > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    // Computing bound for C
    _229.d2 = f;
    if (f > 0) 
    goto _jump716;
    fail_assertion("non-positive loop bound");
    _jump716:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= m;
    _230 *= f;
    _230 *= f;
    _230 *= sizeof(_a2_void_t);
    _229.data = jpl_alloc(_230);
    int64_t _231 = 0; // C
    int64_t _232 = 0; // B
    int64_t _233 = 0; // A
    _jump717:; // Begin body of loop
    _a2_void_t _234;
    // Computing bound for D
    _234.d0 = _125.d2;
    if (_125.d2 > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for E
    _234.d1 = _80;
    if (_80 > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing total size of heap memory to allocate
    int64_t _235 = 1;
    _235 *= _125.d2;
    _235 *= _80;
    _235 *= sizeof(void_t);
    _234.data = jpl_alloc(_235);
    int64_t _236 = 0; // E
    int64_t _237 = 0; // D
    _jump720:; // Begin body of loop
    void_t _238 = n(i, p, r);
    int64_t _239 = 0;
    _239 *= _234.d0;
    _239 += _237;
    _239 *= _234.d1;
    _239 += _236;
    _234.data[_239] = _238;
    _236++;
    if (_236 < _80)
    goto _jump720;
    _236 = 0;
    _237++;
    if (_237 < _125.d2)
    goto _jump720;
    // End body of loop
    int64_t _240 = 0;
    _240 *= _229.d0;
    _240 += _233;
    _240 *= _229.d1;
    _240 += _232;
    _240 *= _229.d2;
    _240 += _231;
    _229.data[_240] = _234;
    _231++;
    if (_231 < f)
    goto _jump717;
    _231 = 0;
    _232++;
    if (_232 < f)
    goto _jump717;
    _232 = 0;
    _233++;
    if (_233 < m)
    goto _jump717;
    // End body of loop
    int64_t _241;
    // Computing bound for A
    _a3_int64_t _242;
    // Computing bound for A
    _242.d0 = k;
    if (k > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for B
    _242.d1 = m;
    if (m > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing bound for C
    _242.d2 = p.d0;
    if (p.d0 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= k;
    _243 *= m;
    _243 *= p.d0;
    _243 *= sizeof(int64_t);
    _242.data = jpl_alloc(_243);
    int64_t _244 = 0; // C
    int64_t _245 = 0; // B
    int64_t _246 = 0; // A
    _jump724:; // Begin body of loop
    int64_t _247 = 580;
    int64_t _248 = 0;
    _248 *= _242.d0;
    _248 += _246;
    _248 *= _242.d1;
    _248 += _245;
    _248 *= _242.d2;
    _248 += _244;
    _242.data[_248] = _247;
    _244++;
    if (_244 < p.d0)
    goto _jump724;
    _244 = 0;
    _245++;
    if (_245 < m)
    goto _jump724;
    _245 = 0;
    _246++;
    if (_246 < k)
    goto _jump724;
    // End body of loop
    int64_t _249 = 854;
    if (_249 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_249 < _242.d0)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    if (m >= 0)
    goto _jump727;
    fail_assertion("negative array index");
    _jump727:;
    if (m < _242.d1)
    goto _jump728;
    fail_assertion("index too large");
    _jump728:;
    if (_125.d2 >= 0)
    goto _jump729;
    fail_assertion("negative array index");
    _jump729:;
    if (_125.d2 < _242.d2)
    goto _jump730;
    fail_assertion("index too large");
    _jump730:;
    int64_t _250 = 0;
    _250 *= _242.d0;
    _250 += _249;
    _250 *= _242.d1;
    _250 += m;
    _250 *= _242.d2;
    _250 += _125.d2;
    int64_t _251 = _242.data[_250];
    if (_251 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing bound for B
    int64_t _252 = -_125.d1;
    int64_t _253 = -_252;
    if (_253 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    // Computing bound for C
    if (f > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    _241 = 0;
    int64_t _254 = 0; // C
    int64_t _255 = 0; // B
    int64_t _256 = 0; // A
    _jump734:; // Begin body of loop
    if (k >= 0)
    goto _jump735;
    fail_assertion("negative array index");
    _jump735:;
    if (k < p.d0)
    goto _jump736;
    fail_assertion("index too large");
    _jump736:;
    int64_t _257 = 0;
    _257 *= p.d0;
    _257 += k;
    bool _258 = p.data[_257];
    int64_t _259;
    if (!_258)
    goto _jump737;
    _259 = p.d0;
    goto _jump738;
    _jump737:;
    _259 = _0.d1;
    _jump738:;
    _241 += _259;
    _254++;
    if (_254 < f)
    goto _jump734;
    _254 = 0;
    _255++;
    if (_255 < _253)
    goto _jump734;
    _255 = 0;
    _256++;
    if (_256 < _251)
    goto _jump734;
    // End body of loop
    if (_241 >= 0)
    goto _jump739;
    fail_assertion("negative array index");
    _jump739:;
    if (_241 < _229.d0)
    goto _jump740;
    fail_assertion("index too large");
    _jump740:;
    if (_125.d1 >= 0)
    goto _jump741;
    fail_assertion("negative array index");
    _jump741:;
    if (_125.d1 < _229.d1)
    goto _jump742;
    fail_assertion("index too large");
    _jump742:;
    if (_125.d1 >= 0)
    goto _jump743;
    fail_assertion("negative array index");
    _jump743:;
    if (_125.d1 < _229.d2)
    goto _jump744;
    fail_assertion("index too large");
    _jump744:;
    int64_t _260 = 0;
    _260 *= _229.d0;
    _260 += _241;
    _260 *= _229.d1;
    _260 += _125.d1;
    _260 *= _229.d2;
    _260 += _125.d1;
    _a2_void_t _261 = _229.data[_260];
    _209 = _261;
    _jump713:;
    int64_t _262;
    // Computing bound for A
    if (_0.d1 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    _262 = 0;
    int64_t _263 = 0; // A
    _jump746:; // Begin body of loop
    _262 += _125.d1;
    _263++;
    if (_263 < _0.d1)
    goto _jump746;
    // End body of loop
    if (_80 >= 0)
    goto _jump747;
    fail_assertion("negative array index");
    _jump747:;
    if (_80 < _209.d0)
    goto _jump748;
    fail_assertion("index too large");
    _jump748:;
    if (_262 >= 0)
    goto _jump749;
    fail_assertion("negative array index");
    _jump749:;
    if (_262 < _209.d1)
    goto _jump750;
    fail_assertion("index too large");
    _jump750:;
    int64_t _264 = 0;
    _264 *= _209.d0;
    _264 += _80;
    _264 *= _209.d1;
    _264 += _262;
    void_t _265 = _209.data[_264];
    _194 = _265;
    goto _jump751;
    _jump686:;
    bool _266 = true;
    _a2_void_t _267;
    if (!_266)
    goto _jump752;
    _a2_void_t _268;
    // Computing bound for A
    _268.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing bound for B
    _268.d1 = _125.d1;
    if (_125.d1 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    // Computing total size of heap memory to allocate
    int64_t _269 = 1;
    _269 *= _0.d1;
    _269 *= _125.d1;
    _269 *= sizeof(void_t);
    _268.data = jpl_alloc(_269);
    int64_t _270 = 0; // B
    int64_t _271 = 0; // A
    _jump755:; // Begin body of loop
    bool _272 = i == i;
    bool _273 = true;
    if (m >= 0)
    goto _jump756;
    fail_assertion("negative array index");
    _jump756:;
    if (m < p.d0)
    goto _jump757;
    fail_assertion("index too large");
    _jump757:;
    int64_t _274 = 0;
    _274 *= p.d0;
    _274 += m;
    bool _275 = p.data[_274];
    _a1_bool _276;
    _276.d0 = 3;
    _276.data = jpl_alloc(sizeof(bool) * 3);
    _276.data[0] = _272;
    _276.data[1] = _273;
    _276.data[2] = _275;
    double _277;
    // Computing bound for C
    if (h > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing bound for D
    if (_0.d0 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing bound for E
    if (p.d0 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    _277 = 0;
    int64_t _278 = 0; // E
    int64_t _279 = 0; // D
    int64_t _280 = 0; // C
    _jump761:; // Begin body of loop
    _277 += o;
    _278++;
    if (_278 < p.d0)
    goto _jump761;
    _278 = 0;
    _279++;
    if (_279 < _0.d0)
    goto _jump761;
    _279 = 0;
    _280++;
    if (_280 < h)
    goto _jump761;
    // End body of loop
    double _281;
    // Computing bound for C
    if (_0.d0 > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing bound for D
    if (l > 0) 
    goto _jump763;
    fail_assertion("non-positive loop bound");
    _jump763:;
    // Computing bound for E
    if (m > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    _281 = 0;
    int64_t _282 = 0; // E
    int64_t _283 = 0; // D
    int64_t _284 = 0; // C
    _jump765:; // Begin body of loop
    _281 += i;
    _282++;
    if (_282 < m)
    goto _jump765;
    _282 = 0;
    _283++;
    if (_283 < l)
    goto _jump765;
    _283 = 0;
    _284++;
    if (_284 < _0.d0)
    goto _jump765;
    // End body of loop
    double _285 = o + d;
    rgba _286 = { d, _277, _281, _285 };
    void_t _287 = n(o, _276, _286);
    int64_t _288 = 0;
    _288 *= _268.d0;
    _288 += _271;
    _288 *= _268.d1;
    _288 += _270;
    _268.data[_288] = _287;
    _270++;
    if (_270 < _125.d1)
    goto _jump755;
    _270 = 0;
    _271++;
    if (_271 < _0.d1)
    goto _jump755;
    // End body of loop
    _267 = _268;
    goto _jump766;
    _jump752:;
    _a1__a2_void_t _289;
    // Computing bound for A
    bool _290 = true;
    bool _291;
    if (!_290)
    goto _jump767;
    bool _292 = true;
    _291 = _292;
    goto _jump768;
    _jump767:;
    bool _293 = true;
    _291 = _293;
    _jump768:;
    int64_t _294;
    if (!_291)
    goto _jump769;
    _294 = m;
    goto _jump770;
    _jump769:;
    int64_t _295;
    // Computing bound for A
    if (h > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    // Computing bound for B
    if (k > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    _295 = 0;
    int64_t _296 = 0; // B
    int64_t _297 = 0; // A
    _jump773:; // Begin body of loop
    _295 += h;
    _296++;
    if (_296 < k)
    goto _jump773;
    _296 = 0;
    _297++;
    if (_297 < h)
    goto _jump773;
    // End body of loop
    _294 = _295;
    _jump770:;
    _289.d0 = _294;
    if (_294 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    // Computing total size of heap memory to allocate
    int64_t _298 = 1;
    _298 *= _294;
    _298 *= sizeof(_a2_void_t);
    _289.data = jpl_alloc(_298);
    int64_t _299 = 0; // A
    _jump775:; // Begin body of loop
    _a2_void_t _300;
    // Computing bound for B
    _300.d0 = k;
    if (k > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    // Computing bound for C
    _300.d1 = _299;
    if (_299 > 0) 
    goto _jump777;
    fail_assertion("non-positive loop bound");
    _jump777:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= k;
    _301 *= _299;
    _301 *= sizeof(void_t);
    _300.data = jpl_alloc(_301);
    int64_t _302 = 0; // C
    int64_t _303 = 0; // B
    _jump778:; // Begin body of loop
    void_t _304 = n(i, p, r);
    int64_t _305 = 0;
    _305 *= _300.d0;
    _305 += _303;
    _305 *= _300.d1;
    _305 += _302;
    _300.data[_305] = _304;
    _302++;
    if (_302 < _299)
    goto _jump778;
    _302 = 0;
    _303++;
    if (_303 < k)
    goto _jump778;
    // End body of loop
    int64_t _306 = 0;
    _306 *= _289.d0;
    _306 += _299;
    _289.data[_306] = _300;
    _299++;
    if (_299 < _294)
    goto _jump775;
    // End body of loop
    int64_t _307 = _125.d2 / _80;
    if (_307 >= 0)
    goto _jump779;
    fail_assertion("negative array index");
    _jump779:;
    if (_307 < _289.d0)
    goto _jump780;
    fail_assertion("index too large");
    _jump780:;
    int64_t _308 = 0;
    _308 *= _289.d0;
    _308 += _307;
    _a2_void_t _309 = _289.data[_308];
    _267 = _309;
    _jump766:;
    if (_125.d1 >= 0)
    goto _jump781;
    fail_assertion("negative array index");
    _jump781:;
    if (_125.d1 < j.d0)
    goto _jump782;
    fail_assertion("index too large");
    _jump782:;
    if (k >= 0)
    goto _jump783;
    fail_assertion("negative array index");
    _jump783:;
    if (k < j.d1)
    goto _jump784;
    fail_assertion("index too large");
    _jump784:;
    if (f >= 0)
    goto _jump785;
    fail_assertion("negative array index");
    _jump785:;
    if (f < j.d2)
    goto _jump786;
    fail_assertion("index too large");
    _jump786:;
    int64_t _310 = 0;
    _310 *= j.d0;
    _310 += _125.d1;
    _310 *= j.d1;
    _310 += k;
    _310 *= j.d2;
    _310 += f;
    double _311 = j.data[_310];
    double _312 = -_311;
    double _313 = 95.0;
    bool _314 = _312 == _313;
    int64_t _315;
    if (!_314)
    goto _jump787;
    _315 = _0.d1;
    goto _jump788;
    _jump787:;
    _315 = _0.d0;
    _jump788:;
    int64_t _316 = -_315;
    if (_316 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_316 < _267.d0)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    if (_0.d0 >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (_0.d0 < _267.d1)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    int64_t _317 = 0;
    _317 *= _267.d0;
    _317 += _316;
    _317 *= _267.d1;
    _317 += _0.d0;
    void_t _318 = _267.data[_317];
    _194 = _318;
    _jump751:;
    return _194;
}

_a1__a1_rgba p(_a1_rgba q) {
    _a3_bool _0;
    // Computing bound for s
    int64_t _1;
    // Computing bound for s
    if (q.d0 > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    // Computing bound for t
    double _2 = i + o;
    bool _3 = _2 != o;
    _a1_int64_t _4;
    if (!_3)
    goto _jump795;
    bool _5 = f == l;
    _a1_int64_t _6;
    if (!_5)
    goto _jump796;
    _a1_int64_t _7;
    // Computing bound for s
    _7.d0 = q.d0;
    if (q.d0 > 0) 
    goto _jump797;
    fail_assertion("non-positive loop bound");
    _jump797:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= q.d0;
    _8 *= sizeof(int64_t);
    _7.data = jpl_alloc(_8);
    int64_t _9 = 0; // s
    _jump798:; // Begin body of loop
    int64_t _10 = 141;
    int64_t _11 = 0;
    _11 *= _7.d0;
    _11 += _9;
    _7.data[_11] = _10;
    _9++;
    if (_9 < q.d0)
    goto _jump798;
    // End body of loop
    _6 = _7;
    goto _jump799;
    _jump796:;
    _a1_int64_t _12;
    _12.d0 = 1;
    _12.data = jpl_alloc(sizeof(int64_t) * 1);
    _12.data[0] = c;
    _6 = _12;
    _jump799:;
    _4 = _6;
    goto _jump800;
    _jump795:;
    int64_t _13 = m + c;
    _a1_int64_t _14;
    _14.d0 = 2;
    _14.data = jpl_alloc(sizeof(int64_t) * 2);
    _14.data[0] = _13;
    _14.data[1] = h;
    _4 = _14;
    _jump800:;
    if (g >= 0)
    goto _jump801;
    fail_assertion("negative array index");
    _jump801:;
    if (g < _4.d0)
    goto _jump802;
    fail_assertion("index too large");
    _jump802:;
    int64_t _15 = 0;
    _15 *= _4.d0;
    _15 += g;
    int64_t _16 = _4.data[_15];
    double _17 = 93.0;
    bool _18 = _17 >= i;
    bool _19 = !_18;
    _a1_int64_t _20;
    if (!_19)
    goto _jump803;
    _a1_int64_t _21;
    // Computing bound for s
    _21.d0 = c;
    if (c > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= c;
    _22 *= sizeof(int64_t);
    _21.data = jpl_alloc(_22);
    int64_t _23 = 0; // s
    _jump805:; // Begin body of loop
    int64_t _24;
    // Computing bound for t
    if (m > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    // Computing bound for u
    if (h > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    _24 = 0;
    int64_t _25 = 0; // u
    int64_t _26 = 0; // t
    _jump808:; // Begin body of loop
    _24 += g;
    _25++;
    if (_25 < h)
    goto _jump808;
    _25 = 0;
    _26++;
    if (_26 < m)
    goto _jump808;
    // End body of loop
    int64_t _27 = 0;
    _27 *= _21.d0;
    _27 += _23;
    _21.data[_27] = _24;
    _23++;
    if (_23 < c)
    goto _jump805;
    // End body of loop
    _20 = _21;
    goto _jump809;
    _jump803:;
    int64_t _28 = -h;
    _a1_int64_t _29;
    _29.d0 = 3;
    _29.data = jpl_alloc(sizeof(int64_t) * 3);
    _29.data[0] = _28;
    _29.data[1] = g;
    _29.data[2] = k;
    _20 = _29;
    _jump809:;
    int64_t _30 = -l;
    if (_30 >= 0)
    goto _jump810;
    fail_assertion("negative array index");
    _jump810:;
    if (_30 < _20.d0)
    goto _jump811;
    fail_assertion("index too large");
    _jump811:;
    int64_t _31 = 0;
    _31 *= _20.d0;
    _31 += _30;
    int64_t _32 = _20.data[_31];
    int64_t _33 = _16 - _32;
    if (_33 > 0) 
    goto _jump812;
    fail_assertion("non-positive loop bound");
    _jump812:;
    // Computing bound for u
    if (h > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    _1 = 0;
    int64_t _34 = 0; // u
    int64_t _35 = 0; // t
    int64_t _36 = 0; // s
    _jump814:; // Begin body of loop
    _1 += g;
    _34++;
    if (_34 < h)
    goto _jump814;
    _34 = 0;
    _35++;
    if (_35 < _33)
    goto _jump814;
    _35 = 0;
    _36++;
    if (_36 < q.d0)
    goto _jump814;
    // End body of loop
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump815;
    fail_assertion("non-positive loop bound");
    _jump815:;
    // Computing bound for t
    _0.d1 = l;
    if (l > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    // Computing bound for u
    _0.d2 = h;
    if (h > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _1;
    _37 *= l;
    _37 *= h;
    _37 *= sizeof(bool);
    _0.data = jpl_alloc(_37);
    int64_t _38 = 0; // u
    int64_t _39 = 0; // t
    int64_t _40 = 0; // s
    _jump818:; // Begin body of loop
    _a3_bool _42;
    // Computing bound for v
    _42.d0 = _40;
    if (_40 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    // Computing bound for w
    _42.d1 = l;
    if (l > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    // Computing bound for x
    _42.d2 = g;
    if (g > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= _40;
    _43 *= l;
    _43 *= g;
    _43 *= sizeof(bool);
    _42.data = jpl_alloc(_43);
    int64_t _44 = 0; // x
    int64_t _45 = 0; // w
    int64_t _46 = 0; // v
    _jump822:; // Begin body of loop
    bool _47 = true;
    int64_t _48 = 0;
    _48 *= _42.d0;
    _48 += _46;
    _48 *= _42.d1;
    _48 += _45;
    _48 *= _42.d2;
    _48 += _44;
    _42.data[_48] = _47;
    _44++;
    if (_44 < g)
    goto _jump822;
    _44 = 0;
    _45++;
    if (_45 < l)
    goto _jump822;
    _45 = 0;
    _46++;
    if (_46 < _40)
    goto _jump822;
    // End body of loop
    if (c >= 0)
    goto _jump823;
    fail_assertion("negative array index");
    _jump823:;
    if (c < _42.d0)
    goto _jump824;
    fail_assertion("index too large");
    _jump824:;
    if (q.d0 >= 0)
    goto _jump825;
    fail_assertion("negative array index");
    _jump825:;
    if (q.d0 < _42.d1)
    goto _jump826;
    fail_assertion("index too large");
    _jump826:;
    if (_38 >= 0)
    goto _jump827;
    fail_assertion("negative array index");
    _jump827:;
    if (_38 < _42.d2)
    goto _jump828;
    fail_assertion("index too large");
    _jump828:;
    int64_t _49 = 0;
    _49 *= _42.d0;
    _49 += c;
    _49 *= _42.d1;
    _49 += q.d0;
    _49 *= _42.d2;
    _49 += _38;
    bool _50 = _42.data[_49];
    bool _51;
    if (!_50)
    goto _jump829;
    double _52 = 84.0;
    bool _53 = i <= _52;
    _51 = _53;
    goto _jump830;
    _jump829:;
    bool _54 = true;
    _51 = _54;
    _jump830:;
    bool _55 = !_51;
    bool _41 = _55;
    if (0 == _55)
    goto _jump831;
    _a3_bool _56;
    // Computing bound for v
    _56.d0 = f;
    if (f > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    // Computing bound for w
    _56.d1 = m;
    if (m > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for x
    _56.d2 = q.d0;
    if (q.d0 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= f;
    _57 *= m;
    _57 *= q.d0;
    _57 *= sizeof(bool);
    _56.data = jpl_alloc(_57);
    int64_t _58 = 0; // x
    int64_t _59 = 0; // w
    int64_t _60 = 0; // v
    _jump835:; // Begin body of loop
    bool _61 = o >= d;
    int64_t _62 = 0;
    _62 *= _56.d0;
    _62 += _60;
    _62 *= _56.d1;
    _62 += _59;
    _62 *= _56.d2;
    _62 += _58;
    _56.data[_62] = _61;
    _58++;
    if (_58 < q.d0)
    goto _jump835;
    _58 = 0;
    _59++;
    if (_59 < m)
    goto _jump835;
    _59 = 0;
    _60++;
    if (_60 < f)
    goto _jump835;
    // End body of loop
    int64_t _63;
    // Computing bound for v
    int64_t _64 = m - _39;
    if (_64 > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for w
    if (_39 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    _63 = 0;
    int64_t _65 = 0; // w
    int64_t _66 = 0; // v
    _jump838:; // Begin body of loop
    int64_t _67 = -h;
    _63 += _67;
    _65++;
    if (_65 < _39)
    goto _jump838;
    _65 = 0;
    _66++;
    if (_66 < _64)
    goto _jump838;
    // End body of loop
    _a1_int64_t _68;
    // Computing bound for v
    _68.d0 = k;
    if (k > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= k;
    _69 *= sizeof(int64_t);
    _68.data = jpl_alloc(_69);
    int64_t _70 = 0; // v
    _jump840:; // Begin body of loop
    int64_t _71 = 0;
    _71 *= _68.d0;
    _71 += _70;
    _68.data[_71] = q.d0;
    _70++;
    if (_70 < k)
    goto _jump840;
    // End body of loop
    if (_38 >= 0)
    goto _jump841;
    fail_assertion("negative array index");
    _jump841:;
    if (_38 < _68.d0)
    goto _jump842;
    fail_assertion("index too large");
    _jump842:;
    int64_t _72 = 0;
    _72 *= _68.d0;
    _72 += _38;
    int64_t _73 = _68.data[_72];
    if (_63 >= 0)
    goto _jump843;
    fail_assertion("negative array index");
    _jump843:;
    if (_63 < _56.d0)
    goto _jump844;
    fail_assertion("index too large");
    _jump844:;
    if (h >= 0)
    goto _jump845;
    fail_assertion("negative array index");
    _jump845:;
    if (h < _56.d1)
    goto _jump846;
    fail_assertion("index too large");
    _jump846:;
    if (_73 >= 0)
    goto _jump847;
    fail_assertion("negative array index");
    _jump847:;
    if (_73 < _56.d2)
    goto _jump848;
    fail_assertion("index too large");
    _jump848:;
    int64_t _74 = 0;
    _74 *= _56.d0;
    _74 += _63;
    _74 *= _56.d1;
    _74 += h;
    _74 *= _56.d2;
    _74 += _73;
    bool _75 = _56.data[_74];
    bool _76;
    if (!_75)
    goto _jump849;
    _a1_double _77;
    // Computing bound for v
    _77.d0 = f;
    if (f > 0) 
    goto _jump850;
    fail_assertion("non-positive loop bound");
    _jump850:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= f;
    _78 *= sizeof(double);
    _77.data = jpl_alloc(_78);
    int64_t _79 = 0; // v
    _jump851:; // Begin body of loop
    double _80 = 94.0;
    int64_t _81 = 0;
    _81 *= _77.d0;
    _81 += _79;
    _77.data[_81] = _80;
    _79++;
    if (_79 < f)
    goto _jump851;
    // End body of loop
    if (q.d0 >= 0)
    goto _jump852;
    fail_assertion("negative array index");
    _jump852:;
    if (q.d0 < _77.d0)
    goto _jump853;
    fail_assertion("index too large");
    _jump853:;
    int64_t _82 = 0;
    _82 *= _77.d0;
    _82 += q.d0;
    double _83 = _77.data[_82];
    int64_t _84 = -g;
    int64_t _85 = -h;
    if (_84 >= 0)
    goto _jump854;
    fail_assertion("negative array index");
    _jump854:;
    if (_84 < j.d0)
    goto _jump855;
    fail_assertion("index too large");
    _jump855:;
    if (_85 >= 0)
    goto _jump856;
    fail_assertion("negative array index");
    _jump856:;
    if (_85 < j.d1)
    goto _jump857;
    fail_assertion("index too large");
    _jump857:;
    if (h >= 0)
    goto _jump858;
    fail_assertion("negative array index");
    _jump858:;
    if (h < j.d2)
    goto _jump859;
    fail_assertion("index too large");
    _jump859:;
    int64_t _86 = 0;
    _86 *= j.d0;
    _86 += _84;
    _86 *= j.d1;
    _86 += _85;
    _86 *= j.d2;
    _86 += h;
    double _87 = j.data[_86];
    bool _88 = _83 != _87;
    _76 = _88;
    goto _jump860;
    _jump849:;
    bool _90 = f < m;
    bool _89 = _90;
    if (0 == _90)
    goto _jump861;
    bool _91 = true;
    _89 = _91;
    _jump861:;
    _76 = _89;
    _jump860:;
    _41 = _76;
    _jump831:;
    bool _92;
    if (!_41)
    goto _jump862;
    bool _93 = i == o;
    _92 = _93;
    goto _jump863;
    _jump862:;
    bool _94 = true;
    bool _95;
    if (!_94)
    goto _jump864;
    bool _96 = _38 == q.d0;
    bool _97;
    if (!_96)
    goto _jump865;
    bool _98 = false;
    bool _99 = !_98;
    _97 = _99;
    goto _jump866;
    _jump865:;
    bool _100 = false;
    bool _101 = !_100;
    _97 = _101;
    _jump866:;
    bool _102 = !_97;
    _95 = _102;
    goto _jump867;
    _jump864:;
    double _103;
    // Computing bound for v
    if (k > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    _103 = 0;
    int64_t _104 = 0; // v
    _jump869:; // Begin body of loop
    _103 += i;
    _104++;
    if (_104 < k)
    goto _jump869;
    // End body of loop
    double _105 = 35.0;
    double _106 = -_105;
    bool _107 = _103 >= _106;
    bool _108;
    if (!_107)
    goto _jump870;
    double _109 = 19.0;
    double _110 = fmod(_109, i);
    bool _111 = o != _110;
    _108 = _111;
    goto _jump871;
    _jump870:;
    bool _112 = false;
    _108 = _112;
    _jump871:;
    _95 = _108;
    _jump867:;
    bool _113;
    if (!_95)
    goto _jump872;
    bool _116 = _40 == _39;
    bool _115 = _116;
    if (0 != _116)
    goto _jump873;
    bool _117 = q.d0 > _39;
    _115 = _117;
    _jump873:;
    bool _114 = _115;
    if (0 == _115)
    goto _jump874;
    bool _118 = false;
    bool _119 = false;
    _a1_bool _120;
    _120.d0 = 2;
    _120.data = jpl_alloc(sizeof(bool) * 2);
    _120.data[0] = _118;
    _120.data[1] = _119;
    int64_t _121;
    // Computing bound for v
    if (_39 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for w
    if (f > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing bound for x
    if (c > 0) 
    goto _jump877;
    fail_assertion("non-positive loop bound");
    _jump877:;
    _121 = 0;
    int64_t _122 = 0; // x
    int64_t _123 = 0; // w
    int64_t _124 = 0; // v
    _jump878:; // Begin body of loop
    _121 += _40;
    _122++;
    if (_122 < c)
    goto _jump878;
    _122 = 0;
    _123++;
    if (_123 < f)
    goto _jump878;
    _123 = 0;
    _124++;
    if (_124 < _39)
    goto _jump878;
    // End body of loop
    if (_121 >= 0)
    goto _jump879;
    fail_assertion("negative array index");
    _jump879:;
    if (_121 < _120.d0)
    goto _jump880;
    fail_assertion("index too large");
    _jump880:;
    int64_t _125 = 0;
    _125 *= _120.d0;
    _125 += _121;
    bool _126 = _120.data[_125];
    _114 = _126;
    _jump874:;
    bool _127;
    if (!_114)
    goto _jump881;
    bool _129 = true;
    bool _128 = _129;
    if (0 != _129)
    goto _jump882;
    bool _130 = false;
    bool _131 = !_130;
    _128 = _131;
    _jump882:;
    _127 = _128;
    goto _jump883;
    _jump881:;
    bool _133 = true;
    bool _134 = !_133;
    bool _132 = _134;
    if (0 != _134)
    goto _jump884;
    bool _135 = false;
    _132 = _135;
    _jump884:;
    _127 = _132;
    _jump883:;
    _113 = _127;
    goto _jump885;
    _jump872:;
    bool _136 = true;
    _113 = _136;
    _jump885:;
    _92 = _113;
    _jump863:;
    int64_t _137 = 0;
    _137 *= _0.d0;
    _137 += _40;
    _137 *= _0.d1;
    _137 += _39;
    _137 *= _0.d2;
    _137 += _38;
    _0.data[_137] = _92;
    _38++;
    if (_38 < h)
    goto _jump818;
    _38 = 0;
    _39++;
    if (_39 < l)
    goto _jump818;
    _39 = 0;
    _40++;
    if (_40 < _1)
    goto _jump818;
    // End body of loop
    int64_t _138;
    // Computing bound for w
    if (c > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing bound for x
    bool _139 = true;
    _a1_bool _140;
    if (!_139)
    goto _jump887;
    _a1_bool _141;
    // Computing bound for w
    _141.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _0.d0;
    _142 *= sizeof(bool);
    _141.data = jpl_alloc(_142);
    int64_t _143 = 0; // w
    _jump889:; // Begin body of loop
    bool _144 = false;
    int64_t _145 = 0;
    _145 *= _141.d0;
    _145 += _143;
    _141.data[_145] = _144;
    _143++;
    if (_143 < _0.d0)
    goto _jump889;
    // End body of loop
    _140 = _141;
    goto _jump890;
    _jump887:;
    _a1_bool _146;
    // Computing bound for w
    _146.d0 = f;
    if (f > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= f;
    _147 *= sizeof(bool);
    _146.data = jpl_alloc(_147);
    int64_t _148 = 0; // w
    _jump892:; // Begin body of loop
    bool _149 = true;
    int64_t _150 = 0;
    _150 *= _146.d0;
    _150 += _148;
    _146.data[_150] = _149;
    _148++;
    if (_148 < f)
    goto _jump892;
    // End body of loop
    _140 = _146;
    _jump890:;
    bool _151 = m < g;
    int64_t _152;
    if (!_151)
    goto _jump893;
    _152 = q.d0;
    goto _jump894;
    _jump893:;
    int64_t _153 = h + k;
    _152 = _153;
    _jump894:;
    if (_152 >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (_152 < _140.d0)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    int64_t _154 = 0;
    _154 *= _140.d0;
    _154 += _152;
    bool _155 = _140.data[_154];
    int64_t _156;
    if (!_155)
    goto _jump897;
    _156 = m;
    goto _jump898;
    _jump897:;
    _156 = m;
    _jump898:;
    if (_156 > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    _138 = 0;
    int64_t _157 = 0; // x
    int64_t _158 = 0; // w
    _jump900:; // Begin body of loop
    _138 += g;
    _157++;
    if (_157 < _156)
    goto _jump900;
    _157 = 0;
    _158++;
    if (_158 < c)
    goto _jump900;
    // End body of loop
    if (_138 >= 0)
    goto _jump901;
    fail_assertion("negative array index");
    _jump901:;
    if (_138 < _0.d0)
    goto _jump902;
    fail_assertion("index too large");
    _jump902:;
    if (_0.d1 >= 0)
    goto _jump903;
    fail_assertion("negative array index");
    _jump903:;
    if (_0.d1 < _0.d1)
    goto _jump904;
    fail_assertion("index too large");
    _jump904:;
    if (q.d0 >= 0)
    goto _jump905;
    fail_assertion("negative array index");
    _jump905:;
    if (q.d0 < _0.d2)
    goto _jump906;
    fail_assertion("index too large");
    _jump906:;
    int64_t _159 = 0;
    _159 *= _0.d0;
    _159 += _138;
    _159 *= _0.d1;
    _159 += _0.d1;
    _159 *= _0.d2;
    _159 += q.d0;
    bool _160 = _0.data[_159];
    _a1_int64_t _161;
    if (!_160)
    goto _jump907;
    _a1_int64_t _162;
    // Computing bound for w
    _162.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= _0.d2;
    _163 *= sizeof(int64_t);
    _162.data = jpl_alloc(_163);
    int64_t _164 = 0; // w
    _jump909:; // Begin body of loop
    int64_t _165 = 0;
    _165 *= _162.d0;
    _165 += _164;
    _162.data[_165] = l;
    _164++;
    if (_164 < _0.d2)
    goto _jump909;
    // End body of loop
    _161 = _162;
    goto _jump910;
    _jump907:;
    _a2__a3__a1_int64_t _166;
    // Computing bound for w
    _166.d0 = g;
    if (g > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing bound for x
    int64_t _167;
    // Computing bound for w
    int64_t _168;
    // Computing bound for w
    if (h > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    // Computing bound for x
    if (c > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    _168 = 0;
    int64_t _169 = 0; // x
    int64_t _170 = 0; // w
    _jump914:; // Begin body of loop
    _168 += l;
    _169++;
    if (_169 < c)
    goto _jump914;
    _169 = 0;
    _170++;
    if (_170 < h)
    goto _jump914;
    // End body of loop
    if (_168 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing bound for x
    int64_t _171 = 613;
    if (_171 > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    _167 = 0;
    int64_t _172 = 0; // x
    int64_t _173 = 0; // w
    _jump917:; // Begin body of loop
    int64_t _174 = _0.d2 + _172;
    _167 += _174;
    _172++;
    if (_172 < _171)
    goto _jump917;
    _172 = 0;
    _173++;
    if (_173 < _168)
    goto _jump917;
    // End body of loop
    _166.d1 = _167;
    if (_167 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing total size of heap memory to allocate
    int64_t _175 = 1;
    _175 *= g;
    _175 *= _167;
    _175 *= sizeof(_a3__a1_int64_t);
    _166.data = jpl_alloc(_175);
    int64_t _176 = 0; // x
    int64_t _177 = 0; // w
    _jump919:; // Begin body of loop
    _a3__a1_int64_t _178;
    // Computing bound for y
    _178.d0 = q.d0;
    if (q.d0 > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for z
    _178.d1 = f;
    if (f > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing bound for A
    _178.d2 = _177;
    if (_177 > 0) 
    goto _jump922;
    fail_assertion("non-positive loop bound");
    _jump922:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= q.d0;
    _179 *= f;
    _179 *= _177;
    _179 *= sizeof(_a1_int64_t);
    _178.data = jpl_alloc(_179);
    int64_t _180 = 0; // A
    int64_t _181 = 0; // z
    int64_t _182 = 0; // y
    _jump923:; // Begin body of loop
    int64_t _183;
    // Computing bound for B
    if (_180 > 0) 
    goto _jump924;
    fail_assertion("non-positive loop bound");
    _jump924:;
    _183 = 0;
    int64_t _184 = 0; // B
    _jump925:; // Begin body of loop
    _183 += _180;
    _184++;
    if (_184 < _180)
    goto _jump925;
    // End body of loop
    _a1_int64_t _185;
    _185.d0 = 3;
    _185.data = jpl_alloc(sizeof(int64_t) * 3);
    _185.data[0] = f;
    _185.data[1] = g;
    _185.data[2] = _183;
    int64_t _186 = 0;
    _186 *= _178.d0;
    _186 += _182;
    _186 *= _178.d1;
    _186 += _181;
    _186 *= _178.d2;
    _186 += _180;
    _178.data[_186] = _185;
    _180++;
    if (_180 < _177)
    goto _jump923;
    _180 = 0;
    _181++;
    if (_181 < f)
    goto _jump923;
    _181 = 0;
    _182++;
    if (_182 < q.d0)
    goto _jump923;
    // End body of loop
    int64_t _187 = 0;
    _187 *= _166.d0;
    _187 += _177;
    _187 *= _166.d1;
    _187 += _176;
    _166.data[_187] = _178;
    _176++;
    if (_176 < _167)
    goto _jump919;
    _176 = 0;
    _177++;
    if (_177 < g)
    goto _jump919;
    // End body of loop
    bool _188 = false;
    bool _189 = !_188;
    int64_t _190;
    if (!_189)
    goto _jump926;
    int64_t _191;
    // Computing bound for w
    if (m > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    _191 = 0;
    int64_t _192 = 0; // w
    _jump928:; // Begin body of loop
    _191 += c;
    _192++;
    if (_192 < m)
    goto _jump928;
    // End body of loop
    bool _193 = _191 == f;
    int64_t _194;
    if (!_193)
    goto _jump929;
    _194 = _0.d1;
    goto _jump930;
    _jump929:;
    int64_t _195;
    // Computing bound for w
    if (_0.d1 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for x
    if (h > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    _195 = 0;
    int64_t _196 = 0; // x
    int64_t _197 = 0; // w
    _jump933:; // Begin body of loop
    _195 += _0.d0;
    _196++;
    if (_196 < h)
    goto _jump933;
    _196 = 0;
    _197++;
    if (_197 < _0.d1)
    goto _jump933;
    // End body of loop
    _194 = _195;
    _jump930:;
    _190 = _194;
    goto _jump934;
    _jump926:;
    _190 = h;
    _jump934:;
    if (l >= 0)
    goto _jump935;
    fail_assertion("negative array index");
    _jump935:;
    if (l < _166.d0)
    goto _jump936;
    fail_assertion("index too large");
    _jump936:;
    if (_190 >= 0)
    goto _jump937;
    fail_assertion("negative array index");
    _jump937:;
    if (_190 < _166.d1)
    goto _jump938;
    fail_assertion("index too large");
    _jump938:;
    int64_t _198 = 0;
    _198 *= _166.d0;
    _198 += l;
    _198 *= _166.d1;
    _198 += _190;
    _a3__a1_int64_t _199 = _166.data[_198];
    if (f >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (f < _199.d0)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    if (l >= 0)
    goto _jump941;
    fail_assertion("negative array index");
    _jump941:;
    if (l < _199.d1)
    goto _jump942;
    fail_assertion("index too large");
    _jump942:;
    if (k >= 0)
    goto _jump943;
    fail_assertion("negative array index");
    _jump943:;
    if (k < _199.d2)
    goto _jump944;
    fail_assertion("index too large");
    _jump944:;
    int64_t _200 = 0;
    _200 *= _199.d0;
    _200 += f;
    _200 *= _199.d1;
    _200 += l;
    _200 *= _199.d2;
    _200 += k;
    _a1_int64_t _201 = _199.data[_200];
    _161 = _201;
    _jump910:;
    bool _203 = false;
    bool _202 = _203;
    if (0 != _203)
    goto _jump945;
    bool _204 = false;
    if (_0.d2 >= 0)
    goto _jump946;
    fail_assertion("negative array index");
    _jump946:;
    if (_0.d2 < j.d0)
    goto _jump947;
    fail_assertion("index too large");
    _jump947:;
    if (_0.d2 >= 0)
    goto _jump948;
    fail_assertion("negative array index");
    _jump948:;
    if (_0.d2 < j.d1)
    goto _jump949;
    fail_assertion("index too large");
    _jump949:;
    if (q.d0 >= 0)
    goto _jump950;
    fail_assertion("negative array index");
    _jump950:;
    if (q.d0 < j.d2)
    goto _jump951;
    fail_assertion("index too large");
    _jump951:;
    int64_t _205 = 0;
    _205 *= j.d0;
    _205 += _0.d2;
    _205 *= j.d1;
    _205 += _0.d2;
    _205 *= j.d2;
    _205 += q.d0;
    double _206 = j.data[_205];
    double _207 = -_206;
    bool _208 = _207 == d;
    bool _209 = !_208;
    bool _210;
    if (!_209)
    goto _jump952;
    bool _211 = true;
    _210 = _211;
    goto _jump953;
    _jump952:;
    double _212;
    // Computing bound for y
    if (_0.d2 > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    _212 = 0;
    int64_t _213 = 0; // y
    _jump955:; // Begin body of loop
    double _214;
    // Computing bound for z
    if (h > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for A
    if (q.d0 > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    _214 = 0;
    int64_t _215 = 0; // A
    int64_t _216 = 0; // z
    _jump958:; // Begin body of loop
    double _217 = 86.0;
    _214 += _217;
    _215++;
    if (_215 < q.d0)
    goto _jump958;
    _215 = 0;
    _216++;
    if (_216 < h)
    goto _jump958;
    // End body of loop
    _212 += _214;
    _213++;
    if (_213 < _0.d2)
    goto _jump955;
    // End body of loop
    double _218 = 16.0;
    double _219 = _212 * _218;
    bool _220 = i <= _219;
    _210 = _220;
    _jump953:;
    bool _221 = _204 != _210;
    _202 = _221;
    _jump945:;
    if (0 != _202)
    goto _jump959;
    fail_assertion("y");
    _jump959:;
    double _222 = -i;
    double _223;
    // Computing bound for y
    int64_t _224 = 290;
    bool _225 = true;
    int64_t _226;
    if (!_225)
    goto _jump960;
    _226 = _161.d0;
    goto _jump961;
    _jump960:;
    _226 = _0.d0;
    _jump961:;
    if (_224 >= 0)
    goto _jump962;
    fail_assertion("negative array index");
    _jump962:;
    if (_224 < b.d0)
    goto _jump963;
    fail_assertion("index too large");
    _jump963:;
    if (_226 >= 0)
    goto _jump964;
    fail_assertion("negative array index");
    _jump964:;
    if (_226 < b.d1)
    goto _jump965;
    fail_assertion("index too large");
    _jump965:;
    int64_t _227 = 0;
    _227 *= b.d0;
    _227 += _224;
    _227 *= b.d1;
    _227 += _226;
    int64_t _228 = b.data[_227];
    if (_228 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing bound for z
    if (_0.d1 > 0) 
    goto _jump967;
    fail_assertion("non-positive loop bound");
    _jump967:;
    _223 = 0;
    int64_t _229 = 0; // z
    int64_t _230 = 0; // y
    _jump968:; // Begin body of loop
    double _231;
    // Computing bound for A
    if (m > 0) 
    goto _jump969;
    fail_assertion("non-positive loop bound");
    _jump969:;
    _231 = 0;
    int64_t _232 = 0; // A
    _jump970:; // Begin body of loop
    bool _233 = false;
    double _234;
    if (!_233)
    goto _jump971;
    _234 = o;
    goto _jump972;
    _jump971:;
    _234 = i;
    _jump972:;
    _231 += _234;
    _232++;
    if (_232 < m)
    goto _jump970;
    // End body of loop
    _223 += _231;
    _229++;
    if (_229 < _0.d1)
    goto _jump968;
    _229 = 0;
    _230++;
    if (_230 < _228)
    goto _jump968;
    // End body of loop
    bool _235 = _222 < _223;
    bool _236;
    if (!_235)
    goto _jump973;
    _a2_bool _237;
    // Computing bound for y
    int64_t _238 = g * _0.d0;
    _237.d0 = _238;
    if (_238 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for z
    _237.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing total size of heap memory to allocate
    int64_t _239 = 1;
    _239 *= _238;
    _239 *= _0.d1;
    _239 *= sizeof(bool);
    _237.data = jpl_alloc(_239);
    int64_t _240 = 0; // z
    int64_t _241 = 0; // y
    _jump976:; // Begin body of loop
    double _242 = 52.0;
    bool _243 = d == _242;
    bool _244 = true;
    bool _245 = _243 == _244;
    int64_t _246 = 0;
    _246 *= _237.d0;
    _246 += _241;
    _246 *= _237.d1;
    _246 += _240;
    _237.data[_246] = _245;
    _240++;
    if (_240 < _0.d1)
    goto _jump976;
    _240 = 0;
    _241++;
    if (_241 < _238)
    goto _jump976;
    // End body of loop
    int64_t _247;
    // Computing bound for y
    int64_t _248;
    // Computing bound for y
    if (_0.d1 > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing bound for z
    if (q.d0 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for A
    if (l > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    _248 = 0;
    int64_t _249 = 0; // A
    int64_t _250 = 0; // z
    int64_t _251 = 0; // y
    _jump980:; // Begin body of loop
    _248 += l;
    _249++;
    if (_249 < l)
    goto _jump980;
    _249 = 0;
    _250++;
    if (_250 < q.d0)
    goto _jump980;
    _250 = 0;
    _251++;
    if (_251 < _0.d1)
    goto _jump980;
    // End body of loop
    if (_248 > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    _247 = 0;
    int64_t _252 = 0; // y
    _jump982:; // Begin body of loop
    _247 += m;
    _252++;
    if (_252 < _248)
    goto _jump982;
    // End body of loop
    if (_247 >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (_247 < _237.d0)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    if (f >= 0)
    goto _jump985;
    fail_assertion("negative array index");
    _jump985:;
    if (f < _237.d1)
    goto _jump986;
    fail_assertion("index too large");
    _jump986:;
    int64_t _253 = 0;
    _253 *= _237.d0;
    _253 += _247;
    _253 *= _237.d1;
    _253 += f;
    bool _254 = _237.data[_253];
    _236 = _254;
    goto _jump987;
    _jump973:;
    bool _255 = false;
    _a2_double _256;
    if (!_255)
    goto _jump988;
    _a2_double _257;
    // Computing bound for y
    _257.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing bound for z
    _257.d1 = g;
    if (g > 0) 
    goto _jump990;
    fail_assertion("non-positive loop bound");
    _jump990:;
    // Computing total size of heap memory to allocate
    int64_t _258 = 1;
    _258 *= _161.d0;
    _258 *= g;
    _258 *= sizeof(double);
    _257.data = jpl_alloc(_258);
    int64_t _259 = 0; // z
    int64_t _260 = 0; // y
    _jump991:; // Begin body of loop
    int64_t _261 = 0;
    _261 *= _257.d0;
    _261 += _260;
    _261 *= _257.d1;
    _261 += _259;
    _257.data[_261] = d;
    _259++;
    if (_259 < g)
    goto _jump991;
    _259 = 0;
    _260++;
    if (_260 < _161.d0)
    goto _jump991;
    // End body of loop
    _256 = _257;
    goto _jump992;
    _jump988:;
    _a2_double _262;
    // Computing bound for y
    _262.d0 = h;
    if (h > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing bound for z
    _262.d1 = m;
    if (m > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= h;
    _263 *= m;
    _263 *= sizeof(double);
    _262.data = jpl_alloc(_263);
    int64_t _264 = 0; // z
    int64_t _265 = 0; // y
    _jump995:; // Begin body of loop
    int64_t _266 = 0;
    _266 *= _262.d0;
    _266 += _265;
    _266 *= _262.d1;
    _266 += _264;
    _262.data[_266] = o;
    _264++;
    if (_264 < m)
    goto _jump995;
    _264 = 0;
    _265++;
    if (_265 < h)
    goto _jump995;
    // End body of loop
    _256 = _262;
    _jump992:;
    _a2_int64_t _267;
    // Computing bound for y
    _267.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing bound for z
    _267.d1 = g;
    if (g > 0) 
    goto _jump997;
    fail_assertion("non-positive loop bound");
    _jump997:;
    // Computing total size of heap memory to allocate
    int64_t _268 = 1;
    _268 *= _0.d0;
    _268 *= g;
    _268 *= sizeof(int64_t);
    _267.data = jpl_alloc(_268);
    int64_t _269 = 0; // z
    int64_t _270 = 0; // y
    _jump998:; // Begin body of loop
    int64_t _271 = 0;
    _271 *= _267.d0;
    _271 += _270;
    _271 *= _267.d1;
    _271 += _269;
    _267.data[_271] = _0.d0;
    _269++;
    if (_269 < g)
    goto _jump998;
    _269 = 0;
    _270++;
    if (_270 < _0.d0)
    goto _jump998;
    // End body of loop
    if (m >= 0)
    goto _jump999;
    fail_assertion("negative array index");
    _jump999:;
    if (m < _267.d0)
    goto _jump1000;
    fail_assertion("index too large");
    _jump1000:;
    if (_0.d0 >= 0)
    goto _jump1001;
    fail_assertion("negative array index");
    _jump1001:;
    if (_0.d0 < _267.d1)
    goto _jump1002;
    fail_assertion("index too large");
    _jump1002:;
    int64_t _272 = 0;
    _272 *= _267.d0;
    _272 += m;
    _272 *= _267.d1;
    _272 += _0.d0;
    int64_t _273 = _267.data[_272];
    if (_273 >= 0)
    goto _jump1003;
    fail_assertion("negative array index");
    _jump1003:;
    if (_273 < _256.d0)
    goto _jump1004;
    fail_assertion("index too large");
    _jump1004:;
    if (_161.d0 >= 0)
    goto _jump1005;
    fail_assertion("negative array index");
    _jump1005:;
    if (_161.d0 < _256.d1)
    goto _jump1006;
    fail_assertion("index too large");
    _jump1006:;
    int64_t _274 = 0;
    _274 *= _256.d0;
    _274 += _273;
    _274 *= _256.d1;
    _274 += _161.d0;
    double _275 = _256.data[_274];
    double _276 = -o;
    bool _277 = _275 > _276;
    _236 = _277;
    _jump987:;
    _a3__a1_int64_t _278;
    if (!_236)
    goto _jump1007;
    _a3__a1_int64_t _279;
    // Computing bound for y
    int64_t _280 = 740;
    _279.d0 = _280;
    if (_280 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for z
    _279.d1 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing bound for A
    _279.d2 = q.d0;
    if (q.d0 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing total size of heap memory to allocate
    int64_t _281 = 1;
    _281 *= _280;
    _281 *= _161.d0;
    _281 *= q.d0;
    _281 *= sizeof(_a1_int64_t);
    _279.data = jpl_alloc(_281);
    int64_t _282 = 0; // A
    int64_t _283 = 0; // z
    int64_t _284 = 0; // y
    _jump1011:; // Begin body of loop
    _a3_int64_t _285;
    // Computing bound for B
    _285.d0 = _282;
    if (_282 > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    // Computing bound for C
    int64_t _286 = -_282;
    _285.d1 = _286;
    if (_286 > 0) 
    goto _jump1013;
    fail_assertion("non-positive loop bound");
    _jump1013:;
    // Computing bound for D
    int64_t _287 = 939;
    _285.d2 = _287;
    if (_287 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing total size of heap memory to allocate
    int64_t _288 = 1;
    _288 *= _282;
    _288 *= _286;
    _288 *= _287;
    _288 *= sizeof(int64_t);
    _285.data = jpl_alloc(_288);
    int64_t _289 = 0; // D
    int64_t _290 = 0; // C
    int64_t _291 = 0; // B
    _jump1015:; // Begin body of loop
    int64_t _292 = 0;
    _292 *= _285.d0;
    _292 += _291;
    _292 *= _285.d1;
    _292 += _290;
    _292 *= _285.d2;
    _292 += _289;
    _285.data[_292] = g;
    _289++;
    if (_289 < _287)
    goto _jump1015;
    _289 = 0;
    _290++;
    if (_290 < _286)
    goto _jump1015;
    _290 = 0;
    _291++;
    if (_291 < _282)
    goto _jump1015;
    // End body of loop
    double _293 = 0.0;
    double _294 = 61.0;
    bool _295 = _293 != _294;
    int64_t _296;
    if (!_295)
    goto _jump1016;
    _296 = _0.d2;
    goto _jump1017;
    _jump1016:;
    _296 = q.d0;
    _jump1017:;
    if (_296 >= 0)
    goto _jump1018;
    fail_assertion("negative array index");
    _jump1018:;
    if (_296 < _285.d0)
    goto _jump1019;
    fail_assertion("index too large");
    _jump1019:;
    if (_0.d0 >= 0)
    goto _jump1020;
    fail_assertion("negative array index");
    _jump1020:;
    if (_0.d0 < _285.d1)
    goto _jump1021;
    fail_assertion("index too large");
    _jump1021:;
    if (_282 >= 0)
    goto _jump1022;
    fail_assertion("negative array index");
    _jump1022:;
    if (_282 < _285.d2)
    goto _jump1023;
    fail_assertion("index too large");
    _jump1023:;
    int64_t _297 = 0;
    _297 *= _285.d0;
    _297 += _296;
    _297 *= _285.d1;
    _297 += _0.d0;
    _297 *= _285.d2;
    _297 += _282;
    int64_t _298 = _285.data[_297];
    _a1_int64_t _299;
    _299.d0 = 3;
    _299.data = jpl_alloc(sizeof(int64_t) * 3);
    _299.data[0] = q.d0;
    _299.data[1] = _298;
    _299.data[2] = _284;
    int64_t _300 = 0;
    _300 *= _279.d0;
    _300 += _284;
    _300 *= _279.d1;
    _300 += _283;
    _300 *= _279.d2;
    _300 += _282;
    _279.data[_300] = _299;
    _282++;
    if (_282 < q.d0)
    goto _jump1011;
    _282 = 0;
    _283++;
    if (_283 < _161.d0)
    goto _jump1011;
    _283 = 0;
    _284++;
    if (_284 < _280)
    goto _jump1011;
    // End body of loop
    _278 = _279;
    goto _jump1024;
    _jump1007:;
    _278 = e;
    _jump1024:;
    _a1__a3__a1_int64_t _301;
    _301.d0 = 2;
    _301.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 2);
    _301.data[0] = e;
    _301.data[1] = _278;
    double _303;
    // Computing bound for A
    if (k > 0) 
    goto _jump1025;
    fail_assertion("non-positive loop bound");
    _jump1025:;
    _303 = 0;
    int64_t _304 = 0; // A
    _jump1026:; // Begin body of loop
    _303 += i;
    _304++;
    if (_304 < k)
    goto _jump1026;
    // End body of loop
    bool _305 = d >= _303;
    bool _306 = !_305;
    double _307;
    if (!_306)
    goto _jump1027;
    double _308;
    // Computing bound for A
    if (_301.d0 > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing bound for B
    int64_t _309 = 982;
    bool _310 = c == _309;
    int64_t _311;
    if (!_310)
    goto _jump1029;
    int64_t _312 = 437;
    _311 = _312;
    goto _jump1030;
    _jump1029:;
    _311 = _0.d2;
    _jump1030:;
    if (_311 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    _308 = 0;
    int64_t _313 = 0; // B
    int64_t _314 = 0; // A
    _jump1032:; // Begin body of loop
    _308 += d;
    _313++;
    if (_313 < _311)
    goto _jump1032;
    _313 = 0;
    _314++;
    if (_314 < _301.d0)
    goto _jump1032;
    // End body of loop
    _307 = _308;
    goto _jump1033;
    _jump1027:;
    _a1_double _315;
    // Computing bound for A
    _315.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= _0.d1;
    _316 *= sizeof(double);
    _315.data = jpl_alloc(_316);
    int64_t _317 = 0; // A
    _jump1035:; // Begin body of loop
    int64_t _318 = 0;
    _318 *= _315.d0;
    _318 += _317;
    _315.data[_318] = o;
    _317++;
    if (_317 < _0.d1)
    goto _jump1035;
    // End body of loop
    if (q.d0 >= 0)
    goto _jump1036;
    fail_assertion("negative array index");
    _jump1036:;
    if (q.d0 < _315.d0)
    goto _jump1037;
    fail_assertion("index too large");
    _jump1037:;
    int64_t _319 = 0;
    _319 *= _315.d0;
    _319 += q.d0;
    double _320 = _315.data[_319];
    double _321 = 88.0;
    double _322 = _320 * _321;
    _307 = _322;
    _jump1033:;
    bool _323 = _307 < o;
    bool _302 = _323;
    if (0 == _323)
    goto _jump1038;
    int64_t _324 = 246;
    if (_324 >= 0)
    goto _jump1039;
    fail_assertion("negative array index");
    _jump1039:;
    if (_324 < _0.d0)
    goto _jump1040;
    fail_assertion("index too large");
    _jump1040:;
    if (_161.d0 >= 0)
    goto _jump1041;
    fail_assertion("negative array index");
    _jump1041:;
    if (_161.d0 < _0.d1)
    goto _jump1042;
    fail_assertion("index too large");
    _jump1042:;
    if (q.d0 >= 0)
    goto _jump1043;
    fail_assertion("negative array index");
    _jump1043:;
    if (q.d0 < _0.d2)
    goto _jump1044;
    fail_assertion("index too large");
    _jump1044:;
    int64_t _325 = 0;
    _325 *= _0.d0;
    _325 += _324;
    _325 *= _0.d1;
    _325 += _161.d0;
    _325 *= _0.d2;
    _325 += q.d0;
    bool _326 = _0.data[_325];
    _a1_bool _327;
    _327.d0 = 1;
    _327.data = jpl_alloc(sizeof(bool) * 1);
    _327.data[0] = _326;
    _a1__a1_bool _328;
    _328.d0 = 1;
    _328.data = jpl_alloc(sizeof(_a1_bool) * 1);
    _328.data[0] = _327;
    if (f >= 0)
    goto _jump1045;
    fail_assertion("negative array index");
    _jump1045:;
    if (f < _328.d0)
    goto _jump1046;
    fail_assertion("index too large");
    _jump1046:;
    int64_t _329 = 0;
    _329 *= _328.d0;
    _329 += f;
    _a1_bool _330 = _328.data[_329];
    if (g >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (g < _330.d0)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    int64_t _331 = 0;
    _331 *= _330.d0;
    _331 += g;
    bool _332 = _330.data[_331];
    _302 = _332;
    _jump1038:;
    _a2_int64_t _333;
    if (!_302)
    goto _jump1049;
    _a2_int64_t _334;
    // Computing bound for A
    _334.d0 = g;
    if (g > 0) 
    goto _jump1050;
    fail_assertion("non-positive loop bound");
    _jump1050:;
    // Computing bound for B
    _a2__a3_int64_t _335;
    // Computing bound for A
    int64_t _336 = 894;
    _335.d0 = _336;
    if (_336 > 0) 
    goto _jump1051;
    fail_assertion("non-positive loop bound");
    _jump1051:;
    // Computing bound for B
    _335.d1 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= _336;
    _337 *= _0.d2;
    _337 *= sizeof(_a3_int64_t);
    _335.data = jpl_alloc(_337);
    int64_t _338 = 0; // B
    int64_t _339 = 0; // A
    _jump1053:; // Begin body of loop
    bool _340 = _338 > _339;
    _a3_int64_t _341;
    if (!_340)
    goto _jump1054;
    _a3_int64_t _342;
    // Computing bound for C
    _342.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    // Computing bound for D
    _342.d1 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    // Computing bound for E
    _342.d2 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing total size of heap memory to allocate
    int64_t _343 = 1;
    _343 *= _0.d2;
    _343 *= _161.d0;
    _343 *= _161.d0;
    _343 *= sizeof(int64_t);
    _342.data = jpl_alloc(_343);
    int64_t _344 = 0; // E
    int64_t _345 = 0; // D
    int64_t _346 = 0; // C
    _jump1058:; // Begin body of loop
    int64_t _347 = 0;
    _347 *= _342.d0;
    _347 += _346;
    _347 *= _342.d1;
    _347 += _345;
    _347 *= _342.d2;
    _347 += _344;
    _342.data[_347] = _0.d0;
    _344++;
    if (_344 < _161.d0)
    goto _jump1058;
    _344 = 0;
    _345++;
    if (_345 < _161.d0)
    goto _jump1058;
    _345 = 0;
    _346++;
    if (_346 < _0.d2)
    goto _jump1058;
    // End body of loop
    _341 = _342;
    goto _jump1059;
    _jump1054:;
    _a3_int64_t _348;
    // Computing bound for C
    _348.d0 = _339;
    if (_339 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing bound for D
    _348.d1 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump1061;
    fail_assertion("non-positive loop bound");
    _jump1061:;
    // Computing bound for E
    _348.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1062;
    fail_assertion("non-positive loop bound");
    _jump1062:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= _339;
    _349 *= _0.d2;
    _349 *= _0.d1;
    _349 *= sizeof(int64_t);
    _348.data = jpl_alloc(_349);
    int64_t _350 = 0; // E
    int64_t _351 = 0; // D
    int64_t _352 = 0; // C
    _jump1063:; // Begin body of loop
    int64_t _353 = 0;
    _353 *= _348.d0;
    _353 += _352;
    _353 *= _348.d1;
    _353 += _351;
    _353 *= _348.d2;
    _353 += _350;
    _348.data[_353] = f;
    _350++;
    if (_350 < _0.d1)
    goto _jump1063;
    _350 = 0;
    _351++;
    if (_351 < _0.d2)
    goto _jump1063;
    _351 = 0;
    _352++;
    if (_352 < _339)
    goto _jump1063;
    // End body of loop
    _341 = _348;
    _jump1059:;
    int64_t _354 = 0;
    _354 *= _335.d0;
    _354 += _339;
    _354 *= _335.d1;
    _354 += _338;
    _335.data[_354] = _341;
    _338++;
    if (_338 < _0.d2)
    goto _jump1053;
    _338 = 0;
    _339++;
    if (_339 < _336)
    goto _jump1053;
    // End body of loop
    _a1_int64_t _355;
    _355.d0 = 1;
    _355.data = jpl_alloc(sizeof(int64_t) * 1);
    _355.data[0] = _0.d1;
    if (_0.d0 >= 0)
    goto _jump1064;
    fail_assertion("negative array index");
    _jump1064:;
    if (_0.d0 < _355.d0)
    goto _jump1065;
    fail_assertion("index too large");
    _jump1065:;
    int64_t _356 = 0;
    _356 *= _355.d0;
    _356 += _0.d0;
    int64_t _357 = _355.data[_356];
    if (m >= 0)
    goto _jump1066;
    fail_assertion("negative array index");
    _jump1066:;
    if (m < _335.d0)
    goto _jump1067;
    fail_assertion("index too large");
    _jump1067:;
    if (_357 >= 0)
    goto _jump1068;
    fail_assertion("negative array index");
    _jump1068:;
    if (_357 < _335.d1)
    goto _jump1069;
    fail_assertion("index too large");
    _jump1069:;
    int64_t _358 = 0;
    _358 *= _335.d0;
    _358 += m;
    _358 *= _335.d1;
    _358 += _357;
    _a3_int64_t _359 = _335.data[_358];
    int64_t _360;
    // Computing bound for A
    if (c > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing bound for B
    if (_0.d2 > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    _360 = 0;
    int64_t _361 = 0; // B
    int64_t _362 = 0; // A
    _jump1072:; // Begin body of loop
    _360 += _0.d0;
    _361++;
    if (_361 < _0.d2)
    goto _jump1072;
    _361 = 0;
    _362++;
    if (_362 < c)
    goto _jump1072;
    // End body of loop
    if (_0.d2 >= 0)
    goto _jump1073;
    fail_assertion("negative array index");
    _jump1073:;
    if (_0.d2 < _359.d0)
    goto _jump1074;
    fail_assertion("index too large");
    _jump1074:;
    if (_161.d0 >= 0)
    goto _jump1075;
    fail_assertion("negative array index");
    _jump1075:;
    if (_161.d0 < _359.d1)
    goto _jump1076;
    fail_assertion("index too large");
    _jump1076:;
    if (_360 >= 0)
    goto _jump1077;
    fail_assertion("negative array index");
    _jump1077:;
    if (_360 < _359.d2)
    goto _jump1078;
    fail_assertion("index too large");
    _jump1078:;
    int64_t _363 = 0;
    _363 *= _359.d0;
    _363 += _0.d2;
    _363 *= _359.d1;
    _363 += _161.d0;
    _363 *= _359.d2;
    _363 += _360;
    int64_t _364 = _359.data[_363];
    _334.d1 = _364;
    if (_364 > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing total size of heap memory to allocate
    int64_t _365 = 1;
    _365 *= g;
    _365 *= _364;
    _365 *= sizeof(int64_t);
    _334.data = jpl_alloc(_365);
    int64_t _366 = 0; // B
    int64_t _367 = 0; // A
    _jump1080:; // Begin body of loop
    int64_t _368 = l + l;
    int64_t _369 = 0;
    _369 *= _334.d0;
    _369 += _367;
    _369 *= _334.d1;
    _369 += _366;
    _334.data[_369] = _368;
    _366++;
    if (_366 < _364)
    goto _jump1080;
    _366 = 0;
    _367++;
    if (_367 < g)
    goto _jump1080;
    // End body of loop
    _333 = _334;
    goto _jump1081;
    _jump1049:;
    _333 = b;
    _jump1081:;
    _a2__a1__a1_rgba _370;
    // Computing bound for E
    _370.d0 = g;
    if (g > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    // Computing bound for F
    _370.d1 = _333.d1;
    if (_333.d1 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing total size of heap memory to allocate
    int64_t _371 = 1;
    _371 *= g;
    _371 *= _333.d1;
    _371 *= sizeof(_a1__a1_rgba);
    _370.data = jpl_alloc(_371);
    int64_t _372 = 0; // F
    int64_t _373 = 0; // E
    _jump1084:; // Begin body of loop
    _a1__a1_rgba _374 = p(q);
    int64_t _375 = 0;
    _375 *= _370.d0;
    _375 += _373;
    _375 *= _370.d1;
    _375 += _372;
    _370.data[_375] = _374;
    _372++;
    if (_372 < _333.d1)
    goto _jump1084;
    _372 = 0;
    _373++;
    if (_373 < g)
    goto _jump1084;
    // End body of loop
    if (g >= 0)
    goto _jump1085;
    fail_assertion("negative array index");
    _jump1085:;
    if (g < _370.d0)
    goto _jump1086;
    fail_assertion("index too large");
    _jump1086:;
    if (l >= 0)
    goto _jump1087;
    fail_assertion("negative array index");
    _jump1087:;
    if (l < _370.d1)
    goto _jump1088;
    fail_assertion("index too large");
    _jump1088:;
    int64_t _376 = 0;
    _376 *= _370.d0;
    _376 += g;
    _376 *= _370.d1;
    _376 += l;
    _a1__a1_rgba _377 = _370.data[_376];
    return _377;
}

int64_t D(rgba E) {
    return C;
    double _0;
    // Computing bound for F
    int64_t _1 = s / w;
    if (_1 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    _0 = 0;
    int64_t _2 = 0; // F
    _jump1176:; // Begin body of loop
    _0 += d;
    _2++;
    if (_2 < _1)
    goto _jump1176;
    // End body of loop
    _a2_double _3;
    // Computing bound for F
    _3.d0 = f;
    if (f > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing bound for G
    _3.d1 = C;
    if (C > 0) 
    goto _jump1178;
    fail_assertion("non-positive loop bound");
    _jump1178:;
    // Computing total size of heap memory to allocate
    int64_t _4 = 1;
    _4 *= f;
    _4 *= C;
    _4 *= sizeof(double);
    _3.data = jpl_alloc(_4);
    int64_t _5 = 0; // G
    int64_t _6 = 0; // F
    _jump1179:; // Begin body of loop
    int64_t _7 = 0;
    _7 *= _3.d0;
    _7 += _6;
    _7 *= _3.d1;
    _7 += _5;
    _3.data[_7] = d;
    _5++;
    if (_5 < C)
    goto _jump1179;
    _5 = 0;
    _6++;
    if (_6 < f)
    goto _jump1179;
    // End body of loop
    if (k >= 0)
    goto _jump1180;
    fail_assertion("negative array index");
    _jump1180:;
    if (k < _3.d0)
    goto _jump1181;
    fail_assertion("index too large");
    _jump1181:;
    if (w >= 0)
    goto _jump1182;
    fail_assertion("negative array index");
    _jump1182:;
    if (w < _3.d1)
    goto _jump1183;
    fail_assertion("index too large");
    _jump1183:;
    int64_t _8 = 0;
    _8 *= _3.d0;
    _8 += k;
    _8 *= _3.d1;
    _8 += w;
    double _9 = _3.data[_8];
    _a2_double _10;
    // Computing bound for F
    _10.d0 = C;
    if (C > 0) 
    goto _jump1184;
    fail_assertion("non-positive loop bound");
    _jump1184:;
    // Computing bound for G
    int64_t _11 = -v;
    _10.d1 = _11;
    if (_11 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= C;
    _12 *= _11;
    _12 *= sizeof(double);
    _10.data = jpl_alloc(_12);
    int64_t _13 = 0; // G
    int64_t _14 = 0; // F
    _jump1186:; // Begin body of loop
    int64_t _15 = 0;
    _15 *= _10.d0;
    _15 += _14;
    _15 *= _10.d1;
    _15 += _13;
    _10.data[_15] = d;
    _13++;
    if (_13 < _11)
    goto _jump1186;
    _13 = 0;
    _14++;
    if (_14 < C)
    goto _jump1186;
    // End body of loop
    if (v >= 0)
    goto _jump1187;
    fail_assertion("negative array index");
    _jump1187:;
    if (v < _10.d0)
    goto _jump1188;
    fail_assertion("index too large");
    _jump1188:;
    if (g >= 0)
    goto _jump1189;
    fail_assertion("negative array index");
    _jump1189:;
    if (g < _10.d1)
    goto _jump1190;
    fail_assertion("index too large");
    _jump1190:;
    int64_t _16 = 0;
    _16 *= _10.d0;
    _16 += v;
    _16 *= _10.d1;
    _16 += g;
    double _17 = _10.data[_16];
    _a3_double _18;
    // Computing bound for F
    double _19 = 77.0;
    double _20 = 91.0;
    double _21 = 18.0;
    rgba _22 = { d, _19, _20, _21 };
    int64_t _23 = D(_22);
    _18.d0 = _23;
    if (_23 > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing bound for G
    int64_t _24 = B + f;
    int64_t _25 = -_24;
    _18.d1 = _25;
    if (_25 > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    // Computing bound for H
    _18.d2 = C;
    if (C > 0) 
    goto _jump1193;
    fail_assertion("non-positive loop bound");
    _jump1193:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= _23;
    _26 *= _25;
    _26 *= C;
    _26 *= sizeof(double);
    _18.data = jpl_alloc(_26);
    int64_t _27 = 0; // H
    int64_t _28 = 0; // G
    int64_t _29 = 0; // F
    _jump1194:; // Begin body of loop
    double _30;
    // Computing bound for I
    if (C > 0) 
    goto _jump1195;
    fail_assertion("non-positive loop bound");
    _jump1195:;
    // Computing bound for J
    if (_29 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for K
    if (h > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    _30 = 0;
    int64_t _31 = 0; // K
    int64_t _32 = 0; // J
    int64_t _33 = 0; // I
    _jump1198:; // Begin body of loop
    _30 += i;
    _31++;
    if (_31 < h)
    goto _jump1198;
    _31 = 0;
    _32++;
    if (_32 < _29)
    goto _jump1198;
    _32 = 0;
    _33++;
    if (_33 < C)
    goto _jump1198;
    // End body of loop
    int64_t _34 = 0;
    _34 *= _18.d0;
    _34 += _29;
    _34 *= _18.d1;
    _34 += _28;
    _34 *= _18.d2;
    _34 += _27;
    _18.data[_34] = _30;
    _27++;
    if (_27 < C)
    goto _jump1194;
    _27 = 0;
    _28++;
    if (_28 < _25)
    goto _jump1194;
    _28 = 0;
    _29++;
    if (_29 < _23)
    goto _jump1194;
    // End body of loop
    bool _35 = true;
    _a1_int64_t _36;
    if (!_35)
    goto _jump1199;
    _36 = r;
    goto _jump1200;
    _jump1199:;
    _36 = r;
    _jump1200:;
    if (B >= 0)
    goto _jump1201;
    fail_assertion("negative array index");
    _jump1201:;
    if (B < _36.d0)
    goto _jump1202;
    fail_assertion("index too large");
    _jump1202:;
    int64_t _37 = 0;
    _37 *= _36.d0;
    _37 += B;
    int64_t _38 = _36.data[_37];
    if (B >= 0)
    goto _jump1203;
    fail_assertion("negative array index");
    _jump1203:;
    if (B < _18.d0)
    goto _jump1204;
    fail_assertion("index too large");
    _jump1204:;
    if (_38 >= 0)
    goto _jump1205;
    fail_assertion("negative array index");
    _jump1205:;
    if (_38 < _18.d1)
    goto _jump1206;
    fail_assertion("index too large");
    _jump1206:;
    if (C >= 0)
    goto _jump1207;
    fail_assertion("negative array index");
    _jump1207:;
    if (C < _18.d2)
    goto _jump1208;
    fail_assertion("index too large");
    _jump1208:;
    int64_t _39 = 0;
    _39 *= _18.d0;
    _39 += B;
    _39 *= _18.d1;
    _39 += _38;
    _39 *= _18.d2;
    _39 += C;
    double _40 = _18.data[_39];
    double _41 = -_40;
    rgba _42 = { _0, _9, _17, _41 };
    q _43 = { _42 };
    bool _44 = t;
    if (0 != t)
    goto _jump1209;
    bool _45 = !t;
    bool _46 = !_45;
    _44 = _46;
    _jump1209:;
    double _47;
    if (!_44)
    goto _jump1210;
    _a2_double _48;
    // Computing bound for H
    _48.d0 = h;
    if (h > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing bound for I
    _48.d1 = v;
    if (v > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= h;
    _49 *= v;
    _49 *= sizeof(double);
    _48.data = jpl_alloc(_49);
    int64_t _50 = 0; // I
    int64_t _51 = 0; // H
    _jump1213:; // Begin body of loop
    int64_t _52 = 0;
    _52 *= _48.d0;
    _52 += _51;
    _52 *= _48.d1;
    _52 += _50;
    _48.data[_52] = d;
    _50++;
    if (_50 < v)
    goto _jump1213;
    _50 = 0;
    _51++;
    if (_51 < h)
    goto _jump1213;
    // End body of loop
    int64_t _53;
    // Computing bound for H
    int64_t _54 = 555;
    if (_54 > 0) 
    goto _jump1214;
    fail_assertion("non-positive loop bound");
    _jump1214:;
    _53 = 0;
    int64_t _55 = 0; // H
    _jump1215:; // Begin body of loop
    _53 += f;
    _55++;
    if (_55 < _54)
    goto _jump1215;
    // End body of loop
    if (w >= 0)
    goto _jump1216;
    fail_assertion("negative array index");
    _jump1216:;
    if (w < _48.d0)
    goto _jump1217;
    fail_assertion("index too large");
    _jump1217:;
    if (_53 >= 0)
    goto _jump1218;
    fail_assertion("negative array index");
    _jump1218:;
    if (_53 < _48.d1)
    goto _jump1219;
    fail_assertion("index too large");
    _jump1219:;
    int64_t _56 = 0;
    _56 *= _48.d0;
    _56 += w;
    _56 *= _48.d1;
    _56 += _53;
    double _57 = _48.data[_56];
    double _58 = -_57;
    _a1_double _59;
    _59.d0 = 2;
    _59.data = jpl_alloc(sizeof(double) * 2);
    _59.data[0] = _58;
    _59.data[1] = d;
    int64_t _60;
    // Computing bound for H
    int64_t _61;
    // Computing bound for H
    int64_t _62 = 665;
    if (_62 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    _61 = 0;
    int64_t _63 = 0; // H
    _jump1221:; // Begin body of loop
    _61 += c;
    _63++;
    if (_63 < _62)
    goto _jump1221;
    // End body of loop
    if (_61 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for I
    if (w > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing bound for J
    if (w > 0) 
    goto _jump1224;
    fail_assertion("non-positive loop bound");
    _jump1224:;
    _60 = 0;
    int64_t _64 = 0; // J
    int64_t _65 = 0; // I
    int64_t _66 = 0; // H
    _jump1225:; // Begin body of loop
    _60 += g;
    _64++;
    if (_64 < w)
    goto _jump1225;
    _64 = 0;
    _65++;
    if (_65 < w)
    goto _jump1225;
    _65 = 0;
    _66++;
    if (_66 < _61)
    goto _jump1225;
    // End body of loop
    if (k >= 0)
    goto _jump1226;
    fail_assertion("negative array index");
    _jump1226:;
    if (k < x.d0)
    goto _jump1227;
    fail_assertion("index too large");
    _jump1227:;
    if (_60 >= 0)
    goto _jump1228;
    fail_assertion("negative array index");
    _jump1228:;
    if (_60 < x.d1)
    goto _jump1229;
    fail_assertion("index too large");
    _jump1229:;
    int64_t _67 = 0;
    _67 *= x.d0;
    _67 += k;
    _67 *= x.d1;
    _67 += _60;
    rgba _68 = x.data[_67];
    int64_t _69 = D(_68);
    if (_69 >= 0)
    goto _jump1230;
    fail_assertion("negative array index");
    _jump1230:;
    if (_69 < _59.d0)
    goto _jump1231;
    fail_assertion("index too large");
    _jump1231:;
    int64_t _70 = 0;
    _70 *= _59.d0;
    _70 += _69;
    double _71 = _59.data[_70];
    _47 = _71;
    goto _jump1232;
    _jump1210:;
    rgba _72;
    if (!t)
    goto _jump1233;
    _a2_rgba _73;
    // Computing bound for H
    int64_t _74 = w % w;
    _73.d0 = _74;
    if (_74 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing bound for I
    _73.d1 = A;
    if (A > 0) 
    goto _jump1235;
    fail_assertion("non-positive loop bound");
    _jump1235:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= _74;
    _75 *= A;
    _75 *= sizeof(rgba);
    _73.data = jpl_alloc(_75);
    int64_t _76 = 0; // I
    int64_t _77 = 0; // H
    _jump1236:; // Begin body of loop
    rgba _78 = _43.a;
    int64_t _79 = 0;
    _79 *= _73.d0;
    _79 += _77;
    _79 *= _73.d1;
    _79 += _76;
    _73.data[_79] = _78;
    _76++;
    if (_76 < A)
    goto _jump1236;
    _76 = 0;
    _77++;
    if (_77 < _74)
    goto _jump1236;
    // End body of loop
    int64_t _80;
    // Computing bound for H
    if (c > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    // Computing bound for I
    if (w > 0) 
    goto _jump1238;
    fail_assertion("non-positive loop bound");
    _jump1238:;
    // Computing bound for J
    int64_t _81 = B - C;
    if (_81 > 0) 
    goto _jump1239;
    fail_assertion("non-positive loop bound");
    _jump1239:;
    _80 = 0;
    int64_t _82 = 0; // J
    int64_t _83 = 0; // I
    int64_t _84 = 0; // H
    _jump1240:; // Begin body of loop
    _80 += h;
    _82++;
    if (_82 < _81)
    goto _jump1240;
    _82 = 0;
    _83++;
    if (_83 < w)
    goto _jump1240;
    _83 = 0;
    _84++;
    if (_84 < c)
    goto _jump1240;
    // End body of loop
    if (C >= 0)
    goto _jump1241;
    fail_assertion("negative array index");
    _jump1241:;
    if (C < _73.d0)
    goto _jump1242;
    fail_assertion("index too large");
    _jump1242:;
    if (_80 >= 0)
    goto _jump1243;
    fail_assertion("negative array index");
    _jump1243:;
    if (_80 < _73.d1)
    goto _jump1244;
    fail_assertion("index too large");
    _jump1244:;
    int64_t _85 = 0;
    _85 *= _73.d0;
    _85 += C;
    _85 *= _73.d1;
    _85 += _80;
    rgba _86 = _73.data[_85];
    _72 = _86;
    goto _jump1245;
    _jump1233:;
    rgba _87 = _43.a;
    _72 = _87;
    _jump1245:;
    double _88 = _72.g;
    _47 = _88;
    _jump1232:;
    bool _89;
    if (!t)
    goto _jump1246;
    _89 = t;
    goto _jump1247;
    _jump1246:;
    _a3_bool _90;
    // Computing bound for H
    _90.d0 = f;
    if (f > 0) 
    goto _jump1248;
    fail_assertion("non-positive loop bound");
    _jump1248:;
    // Computing bound for I
    _90.d1 = g;
    if (g > 0) 
    goto _jump1249;
    fail_assertion("non-positive loop bound");
    _jump1249:;
    // Computing bound for J
    _90.d2 = w;
    if (w > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= f;
    _91 *= g;
    _91 *= w;
    _91 *= sizeof(bool);
    _90.data = jpl_alloc(_91);
    int64_t _92 = 0; // J
    int64_t _93 = 0; // I
    int64_t _94 = 0; // H
    _jump1251:; // Begin body of loop
    int64_t _95 = 0;
    _95 *= _90.d0;
    _95 += _94;
    _95 *= _90.d1;
    _95 += _93;
    _95 *= _90.d2;
    _95 += _92;
    _90.data[_95] = t;
    _92++;
    if (_92 < w)
    goto _jump1251;
    _92 = 0;
    _93++;
    if (_93 < g)
    goto _jump1251;
    _93 = 0;
    _94++;
    if (_94 < f)
    goto _jump1251;
    // End body of loop
    if (v >= 0)
    goto _jump1252;
    fail_assertion("negative array index");
    _jump1252:;
    if (v < b.d0)
    goto _jump1253;
    fail_assertion("index too large");
    _jump1253:;
    if (m >= 0)
    goto _jump1254;
    fail_assertion("negative array index");
    _jump1254:;
    if (m < b.d1)
    goto _jump1255;
    fail_assertion("index too large");
    _jump1255:;
    int64_t _96 = 0;
    _96 *= b.d0;
    _96 += v;
    _96 *= b.d1;
    _96 += m;
    int64_t _97 = b.data[_96];
    if (m >= 0)
    goto _jump1256;
    fail_assertion("negative array index");
    _jump1256:;
    if (m < _90.d0)
    goto _jump1257;
    fail_assertion("index too large");
    _jump1257:;
    if (v >= 0)
    goto _jump1258;
    fail_assertion("negative array index");
    _jump1258:;
    if (v < _90.d1)
    goto _jump1259;
    fail_assertion("index too large");
    _jump1259:;
    if (_97 >= 0)
    goto _jump1260;
    fail_assertion("negative array index");
    _jump1260:;
    if (_97 < _90.d2)
    goto _jump1261;
    fail_assertion("index too large");
    _jump1261:;
    int64_t _98 = 0;
    _98 *= _90.d0;
    _98 += m;
    _98 *= _90.d1;
    _98 += v;
    _98 *= _90.d2;
    _98 += _97;
    bool _99 = _90.data[_98];
    bool _100 = !_99;
    _89 = _100;
    _jump1247:;
    bool _101 = !_89;
    _a1_bool _102;
    if (!_101)
    goto _jump1262;
    bool _103 = k > k;
    bool _104 = true;
    double _105;
    if (!_104)
    goto _jump1263;
    _105 = i;
    goto _jump1264;
    _jump1263:;
    _105 = i;
    _jump1264:;
    bool _106 = _105 <= o;
    bool _107;
    if (!_106)
    goto _jump1265;
    double _108 = 15.0;
    bool _109 = o > _108;
    _107 = _109;
    goto _jump1266;
    _jump1265:;
    _107 = t;
    _jump1266:;
    bool _110;
    if (!_107)
    goto _jump1267;
    bool _112 = false;
    bool _111 = _112;
    if (0 != _112)
    goto _jump1268;
    _111 = t;
    _jump1268:;
    bool _113;
    if (!_111)
    goto _jump1269;
    double _114 = E.r;
    double _115 = 82.0;
    double _116 = _115 * o;
    bool _117 = _114 != _116;
    _113 = _117;
    goto _jump1270;
    _jump1269:;
    double _118 = -o;
    bool _119 = _118 >= d;
    _113 = _119;
    _jump1270:;
    _110 = _113;
    goto _jump1271;
    _jump1267:;
    _a3_int64_t _120;
    // Computing bound for H
    _120.d0 = f;
    if (f > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for I
    _120.d1 = w;
    if (w > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing bound for J
    _120.d2 = v;
    if (v > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= f;
    _121 *= w;
    _121 *= v;
    _121 *= sizeof(int64_t);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // J
    int64_t _123 = 0; // I
    int64_t _124 = 0; // H
    _jump1275:; // Begin body of loop
    int64_t _125 = 0;
    _125 *= _120.d0;
    _125 += _124;
    _125 *= _120.d1;
    _125 += _123;
    _125 *= _120.d2;
    _125 += _122;
    _120.data[_125] = _123;
    _122++;
    if (_122 < v)
    goto _jump1275;
    _122 = 0;
    _123++;
    if (_123 < w)
    goto _jump1275;
    _123 = 0;
    _124++;
    if (_124 < f)
    goto _jump1275;
    // End body of loop
    if (h >= 0)
    goto _jump1276;
    fail_assertion("negative array index");
    _jump1276:;
    if (h < _120.d0)
    goto _jump1277;
    fail_assertion("index too large");
    _jump1277:;
    if (v >= 0)
    goto _jump1278;
    fail_assertion("negative array index");
    _jump1278:;
    if (v < _120.d1)
    goto _jump1279;
    fail_assertion("index too large");
    _jump1279:;
    if (c >= 0)
    goto _jump1280;
    fail_assertion("negative array index");
    _jump1280:;
    if (c < _120.d2)
    goto _jump1281;
    fail_assertion("index too large");
    _jump1281:;
    int64_t _126 = 0;
    _126 *= _120.d0;
    _126 += h;
    _126 *= _120.d1;
    _126 += v;
    _126 *= _120.d2;
    _126 += c;
    int64_t _127 = _120.data[_126];
    bool _128 = w != _127;
    _110 = _128;
    _jump1271:;
    _a1_double _129;
    // Computing bound for H
    _129.d0 = B;
    if (B > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing total size of heap memory to allocate
    int64_t _130 = 1;
    _130 *= B;
    _130 *= sizeof(double);
    _129.data = jpl_alloc(_130);
    int64_t _131 = 0; // H
    _jump1283:; // Begin body of loop
    double _132 = o + d;
    int64_t _133 = 0;
    _133 *= _129.d0;
    _133 += _131;
    _129.data[_133] = _132;
    _131++;
    if (_131 < B)
    goto _jump1283;
    // End body of loop
    if (l >= 0)
    goto _jump1284;
    fail_assertion("negative array index");
    _jump1284:;
    if (l < _129.d0)
    goto _jump1285;
    fail_assertion("index too large");
    _jump1285:;
    int64_t _134 = 0;
    _134 *= _129.d0;
    _134 += l;
    double _135 = _129.data[_134];
    bool _136 = i == _135;
    _a1_bool _137;
    _137.d0 = 3;
    _137.data = jpl_alloc(sizeof(bool) * 3);
    _137.data[0] = _103;
    _137.data[1] = _110;
    _137.data[2] = _136;
    _102 = _137;
    goto _jump1286;
    _jump1262:;
    _a3__a1_bool _138;
    // Computing bound for H
    _138.d0 = s;
    if (s > 0) 
    goto _jump1287;
    fail_assertion("non-positive loop bound");
    _jump1287:;
    // Computing bound for I
    _138.d1 = k;
    if (k > 0) 
    goto _jump1288;
    fail_assertion("non-positive loop bound");
    _jump1288:;
    // Computing bound for J
    int64_t _139;
    // Computing bound for H
    if (w > 0) 
    goto _jump1289;
    fail_assertion("non-positive loop bound");
    _jump1289:;
    // Computing bound for I
    if (f > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing bound for J
    if (s > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    _139 = 0;
    int64_t _140 = 0; // J
    int64_t _141 = 0; // I
    int64_t _142 = 0; // H
    _jump1292:; // Begin body of loop
    _139 += m;
    _140++;
    if (_140 < s)
    goto _jump1292;
    _140 = 0;
    _141++;
    if (_141 < f)
    goto _jump1292;
    _141 = 0;
    _142++;
    if (_142 < w)
    goto _jump1292;
    // End body of loop
    _138.d2 = _139;
    if (_139 > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= s;
    _143 *= k;
    _143 *= _139;
    _143 *= sizeof(_a1_bool);
    _138.data = jpl_alloc(_143);
    int64_t _144 = 0; // J
    int64_t _145 = 0; // I
    int64_t _146 = 0; // H
    _jump1294:; // Begin body of loop
    _a1_bool _147;
    // Computing bound for K
    _147.d0 = C;
    if (C > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing total size of heap memory to allocate
    int64_t _148 = 1;
    _148 *= C;
    _148 *= sizeof(bool);
    _147.data = jpl_alloc(_148);
    int64_t _149 = 0; // K
    _jump1296:; // Begin body of loop
    bool _150 = false;
    int64_t _151 = 0;
    _151 *= _147.d0;
    _151 += _149;
    _147.data[_151] = _150;
    _149++;
    if (_149 < C)
    goto _jump1296;
    // End body of loop
    int64_t _152 = 0;
    _152 *= _138.d0;
    _152 += _146;
    _152 *= _138.d1;
    _152 += _145;
    _152 *= _138.d2;
    _152 += _144;
    _138.data[_152] = _147;
    _144++;
    if (_144 < _139)
    goto _jump1294;
    _144 = 0;
    _145++;
    if (_145 < k)
    goto _jump1294;
    _145 = 0;
    _146++;
    if (_146 < s)
    goto _jump1294;
    // End body of loop
    int64_t _153 = 315;
    int64_t _154 = -_153;
    int64_t _155 = -_154;
    bool _156 = i >= d;
    int64_t _157;
    if (!_156)
    goto _jump1297;
    _157 = f;
    goto _jump1298;
    _jump1297:;
    _157 = C;
    _jump1298:;
    int64_t _158 = _157 / v;
    int64_t _159 = -_158;
    if (_155 >= 0)
    goto _jump1299;
    fail_assertion("negative array index");
    _jump1299:;
    if (_155 < _138.d0)
    goto _jump1300;
    fail_assertion("index too large");
    _jump1300:;
    if (f >= 0)
    goto _jump1301;
    fail_assertion("negative array index");
    _jump1301:;
    if (f < _138.d1)
    goto _jump1302;
    fail_assertion("index too large");
    _jump1302:;
    if (_159 >= 0)
    goto _jump1303;
    fail_assertion("negative array index");
    _jump1303:;
    if (_159 < _138.d2)
    goto _jump1304;
    fail_assertion("index too large");
    _jump1304:;
    int64_t _160 = 0;
    _160 *= _138.d0;
    _160 += _155;
    _160 *= _138.d1;
    _160 += f;
    _160 *= _138.d2;
    _160 += _159;
    _a1_bool _161 = _138.data[_160];
    _102 = _161;
    _jump1286:;
    double _162 = i + i;
    _a2_double _163;
    // Computing bound for H
    _163.d0 = h;
    if (h > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing bound for I
    _163.d1 = B;
    if (B > 0) 
    goto _jump1306;
    fail_assertion("non-positive loop bound");
    _jump1306:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= h;
    _164 *= B;
    _164 *= sizeof(double);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // I
    int64_t _166 = 0; // H
    _jump1307:; // Begin body of loop
    double _167 = 46.0;
    double _168 = fmod(_167, o);
    int64_t _169 = 0;
    _169 *= _163.d0;
    _169 += _166;
    _169 *= _163.d1;
    _169 += _165;
    _163.data[_169] = _168;
    _165++;
    if (_165 < B)
    goto _jump1307;
    _165 = 0;
    _166++;
    if (_166 < h)
    goto _jump1307;
    // End body of loop
    if (C >= 0)
    goto _jump1308;
    fail_assertion("negative array index");
    _jump1308:;
    if (C < _163.d0)
    goto _jump1309;
    fail_assertion("index too large");
    _jump1309:;
    if (k >= 0)
    goto _jump1310;
    fail_assertion("negative array index");
    _jump1310:;
    if (k < _163.d1)
    goto _jump1311;
    fail_assertion("index too large");
    _jump1311:;
    int64_t _170 = 0;
    _170 *= _163.d0;
    _170 += C;
    _170 *= _163.d1;
    _170 += k;
    double _171 = _163.data[_170];
    double _172;
    if (!t)
    goto _jump1312;
    double _173;
    // Computing bound for H
    if (h > 0) 
    goto _jump1313;
    fail_assertion("non-positive loop bound");
    _jump1313:;
    // Computing bound for I
    int64_t _174 = D(E);
    if (_174 > 0) 
    goto _jump1314;
    fail_assertion("non-positive loop bound");
    _jump1314:;
    // Computing bound for J
    if (C > 0) 
    goto _jump1315;
    fail_assertion("non-positive loop bound");
    _jump1315:;
    _173 = 0;
    int64_t _175 = 0; // J
    int64_t _176 = 0; // I
    int64_t _177 = 0; // H
    _jump1316:; // Begin body of loop
    double _178 = E.a;
    _173 += _178;
    _175++;
    if (_175 < C)
    goto _jump1316;
    _175 = 0;
    _176++;
    if (_176 < _174)
    goto _jump1316;
    _176 = 0;
    _177++;
    if (_177 < h)
    goto _jump1316;
    // End body of loop
    _172 = _173;
    goto _jump1317;
    _jump1312:;
    double _179 = 16.0;
    _172 = _179;
    _jump1317:;
    rgba _180 = { d, _162, _171, _172 };
    bool _181 = true;
    _a1_bool _182;
    _182.d0 = 1;
    _182.data = jpl_alloc(sizeof(bool) * 1);
    _182.data[0] = _181;
    rgba _183 = _43.a;
    void_t _184 = n(o, _182, _183);
    int64_t _185;
    // Computing bound for H
    int64_t _186 = -h;
    if (_186 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for I
    int64_t _187;
    // Computing bound for H
    if (h > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    _187 = 0;
    int64_t _188 = 0; // H
    _jump1320:; // Begin body of loop
    _187 += w;
    _188++;
    if (_188 < h)
    goto _jump1320;
    // End body of loop
    if (_187 > 0) 
    goto _jump1321;
    fail_assertion("non-positive loop bound");
    _jump1321:;
    // Computing bound for J
    if (f >= 0)
    goto _jump1322;
    fail_assertion("negative array index");
    _jump1322:;
    if (f < b.d0)
    goto _jump1323;
    fail_assertion("index too large");
    _jump1323:;
    if (s >= 0)
    goto _jump1324;
    fail_assertion("negative array index");
    _jump1324:;
    if (s < b.d1)
    goto _jump1325;
    fail_assertion("index too large");
    _jump1325:;
    int64_t _189 = 0;
    _189 *= b.d0;
    _189 += f;
    _189 *= b.d1;
    _189 += s;
    int64_t _190 = b.data[_189];
    if (_190 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    _185 = 0;
    int64_t _191 = 0; // J
    int64_t _192 = 0; // I
    int64_t _193 = 0; // H
    _jump1327:; // Begin body of loop
    _185 += w;
    _191++;
    if (_191 < _190)
    goto _jump1327;
    _191 = 0;
    _192++;
    if (_192 < _187)
    goto _jump1327;
    _192 = 0;
    _193++;
    if (_193 < _186)
    goto _jump1327;
    // End body of loop
    bool _194 = _185 <= f;
    a _195 = { t, _184, _194 };
    y _196 = { _180, _195 };
    rgba _197 = _196.a;
    void_t _198 = n(_47, _102, _197);
    double _200 = 80.0;
    bool _201 = d == _200;
    bool _199 = _201;
    if (0 == _201)
    goto _jump1328;
    bool _202 = t;
    if (0 != t)
    goto _jump1329;
    int64_t _203;
    // Computing bound for I
    int64_t _204;
    // Computing bound for I
    if (f > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    _204 = 0;
    int64_t _205 = 0; // I
    _jump1331:; // Begin body of loop
    int64_t _206 = 938;
    int64_t _207 = h % _206;
    _204 += _207;
    _205++;
    if (_205 < f)
    goto _jump1331;
    // End body of loop
    if (_204 > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    _203 = 0;
    int64_t _208 = 0; // I
    _jump1333:; // Begin body of loop
    int64_t _209 = C + h;
    int64_t _210;
    if (!t)
    goto _jump1334;
    _210 = s;
    goto _jump1335;
    _jump1334:;
    _210 = c;
    _jump1335:;
    int64_t _211 = _209 / _210;
    _203 += _211;
    _208++;
    if (_208 < _204)
    goto _jump1333;
    // End body of loop
    bool _212 = v != _203;
    _202 = _212;
    _jump1329:;
    _199 = _202;
    _jump1328:;
    _a2_int64_t _213;
    if (!_199)
    goto _jump1336;
    _213 = b;
    goto _jump1337;
    _jump1336:;
    _a2_int64_t _214;
    // Computing bound for I
    _214.d0 = f;
    if (f > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing bound for J
    int64_t _215 = 533;
    _214.d1 = _215;
    if (_215 > 0) 
    goto _jump1339;
    fail_assertion("non-positive loop bound");
    _jump1339:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= f;
    _216 *= _215;
    _216 *= sizeof(int64_t);
    _214.data = jpl_alloc(_216);
    int64_t _217 = 0; // J
    int64_t _218 = 0; // I
    _jump1340:; // Begin body of loop
    int64_t _219 = 0;
    _219 *= _214.d0;
    _219 += _218;
    _219 *= _214.d1;
    _219 += _217;
    _214.data[_219] = s;
    _217++;
    if (_217 < _215)
    goto _jump1340;
    _217 = 0;
    _218++;
    if (_218 < f)
    goto _jump1340;
    // End body of loop
    _213 = _214;
    _jump1337:;
    _a1_int64_t _220;
    _220.d0 = 1;
    _220.data = jpl_alloc(sizeof(int64_t) * 1);
    _220.data[0] = k;
    return f;
}

void jpl_main(struct args args) {
    bool _0 = true;
    bool _2 = true;
    int64_t _3;
    if (!_2)
    goto _jump1;
    int64_t _4;
    // Computing bound for b
    int64_t _5 = 726;
    int64_t _6 = -_5;
    if (_6 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    _4 = 0;
    int64_t _7 = 0; // b
    _jump3:; // Begin body of loop
    int64_t _8 = 64;
    _4 += _8;
    _7++;
    if (_7 < _6)
    goto _jump3;
    // End body of loop
    _3 = _4;
    goto _jump4;
    _jump1:;
    int64_t _9 = 612;
    _3 = _9;
    _jump4:;
    int64_t _10;
    // Computing bound for b
    int64_t _11 = 446;
    if (_11 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing bound for c
    int64_t _12 = 256;
    if (_12 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    _10 = 0;
    int64_t _13 = 0; // c
    int64_t _14 = 0; // b
    _jump7:; // Begin body of loop
    int64_t _15 = 318;
    int64_t _16 = -_15;
    _10 += _16;
    _13++;
    if (_13 < _12)
    goto _jump7;
    _13 = 0;
    _14++;
    if (_14 < _11)
    goto _jump7;
    // End body of loop
    int64_t _17 = -_10;
    bool _18 = _3 > _17;
    bool _1 = _18;
    if (0 != _18)
    goto _jump8;
    _a2_bool _19;
    // Computing bound for b
    int64_t _20;
    // Computing bound for b
    int64_t _21 = 571;
    int64_t _22 = -_21;
    if (_22 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    _20 = 0;
    int64_t _23 = 0; // b
    _jump10:; // Begin body of loop
    int64_t _24 = 166;
    _20 += _24;
    _23++;
    if (_23 < _22)
    goto _jump10;
    // End body of loop
    _19.d0 = _20;
    if (_20 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for c
    int64_t _25 = 186;
    int64_t _26 = 242;
    int64_t _27 = _25 % _26;
    int64_t _28 = -_27;
    _19.d1 = _28;
    if (_28 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _20;
    _29 *= _28;
    _29 *= sizeof(bool);
    _19.data = jpl_alloc(_29);
    int64_t _30 = 0; // c
    int64_t _31 = 0; // b
    _jump13:; // Begin body of loop
    bool _32 = true;
    int64_t _33 = 0;
    _33 *= _19.d0;
    _33 += _31;
    _33 *= _19.d1;
    _33 += _30;
    _19.data[_33] = _32;
    _30++;
    if (_30 < _28)
    goto _jump13;
    _30 = 0;
    _31++;
    if (_31 < _20)
    goto _jump13;
    // End body of loop
    int64_t _34 = 693;
    int64_t _35 = 909;
    int64_t _36 = -_35;
    int64_t _37 = _34 - _36;
    _a3_int64_t _38;
    // Computing bound for b
    int64_t _39 = 686;
    _38.d0 = _39;
    if (_39 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing bound for c
    int64_t _40 = 884;
    _38.d1 = _40;
    if (_40 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    // Computing bound for d
    int64_t _41 = 665;
    int64_t _42 = -_41;
    _38.d2 = _42;
    if (_42 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= _39;
    _43 *= _40;
    _43 *= _42;
    _43 *= sizeof(int64_t);
    _38.data = jpl_alloc(_43);
    int64_t _44 = 0; // d
    int64_t _45 = 0; // c
    int64_t _46 = 0; // b
    _jump17:; // Begin body of loop
    int64_t _47 = 0;
    _47 *= _38.d0;
    _47 += _46;
    _47 *= _38.d1;
    _47 += _45;
    _47 *= _38.d2;
    _47 += _44;
    _38.data[_47] = _45;
    _44++;
    if (_44 < _42)
    goto _jump17;
    _44 = 0;
    _45++;
    if (_45 < _40)
    goto _jump17;
    _45 = 0;
    _46++;
    if (_46 < _39)
    goto _jump17;
    // End body of loop
    int64_t _48 = 174;
    int64_t _49 = -_48;
    int64_t _50 = 851;
    int64_t _51 = 303;
    int64_t _52 = -_51;
    int64_t _53 = 519;
    int64_t _54 = _52 % _53;
    if (_49 >= 0)
    goto _jump18;
    fail_assertion("negative array index");
    _jump18:;
    if (_49 < _38.d0)
    goto _jump19;
    fail_assertion("index too large");
    _jump19:;
    if (_50 >= 0)
    goto _jump20;
    fail_assertion("negative array index");
    _jump20:;
    if (_50 < _38.d1)
    goto _jump21;
    fail_assertion("index too large");
    _jump21:;
    if (_54 >= 0)
    goto _jump22;
    fail_assertion("negative array index");
    _jump22:;
    if (_54 < _38.d2)
    goto _jump23;
    fail_assertion("index too large");
    _jump23:;
    int64_t _55 = 0;
    _55 *= _38.d0;
    _55 += _49;
    _55 *= _38.d1;
    _55 += _50;
    _55 *= _38.d2;
    _55 += _54;
    int64_t _56 = _38.data[_55];
    if (_37 >= 0)
    goto _jump24;
    fail_assertion("negative array index");
    _jump24:;
    if (_37 < _19.d0)
    goto _jump25;
    fail_assertion("index too large");
    _jump25:;
    if (_56 >= 0)
    goto _jump26;
    fail_assertion("negative array index");
    _jump26:;
    if (_56 < _19.d1)
    goto _jump27;
    fail_assertion("index too large");
    _jump27:;
    int64_t _57 = 0;
    _57 *= _19.d0;
    _57 += _37;
    _57 *= _19.d1;
    _57 += _56;
    bool _58 = _19.data[_57];
    _1 = _58;
    _jump8:;
    bool _59 = _0 != _1;
    _a2_int64_t _60;
    if (!_59)
    goto _jump28;
    _a2_int64_t _61;
    // Computing bound for b
    int64_t _62;
    // Computing bound for b
    bool _63 = false;
    int64_t _64;
    if (!_63)
    goto _jump29;
    int64_t _65 = 255;
    int64_t _66 = -_65;
    _64 = _66;
    goto _jump30;
    _jump29:;
    int64_t _67 = 972;
    _64 = _67;
    _jump30:;
    if (_64 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    _62 = 0;
    int64_t _68 = 0; // b
    _jump32:; // Begin body of loop
    int64_t _69 = 720;
    _62 += _69;
    _68++;
    if (_68 < _64)
    goto _jump32;
    // End body of loop
    int64_t _70 = -_62;
    int64_t _71 = 696;
    int64_t _72 = -_71;
    int64_t _73 = -_72;
    int64_t _74 = -_73;
    int64_t _75 = _70 / _74;
    _61.d0 = _75;
    if (_75 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing bound for c
    int64_t _76 = 148;
    _61.d1 = _76;
    if (_76 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _75;
    _77 *= _76;
    _77 *= sizeof(int64_t);
    _61.data = jpl_alloc(_77);
    int64_t _78 = 0; // c
    int64_t _79 = 0; // b
    _jump35:; // Begin body of loop
    bool _80 = false;
    _a2_int64_t _81;
    if (!_80)
    goto _jump36;
    _a2_int64_t _82;
    // Computing bound for d
    int64_t _83 = 900;
    _82.d0 = _83;
    if (_83 > 0) 
    goto _jump37;
    fail_assertion("non-positive loop bound");
    _jump37:;
    // Computing bound for e
    int64_t _84 = 417;
    _a1_int64_t _85;
    _85.d0 = 1;
    _85.data = jpl_alloc(sizeof(int64_t) * 1);
    _85.data[0] = _84;
    int64_t _86;
    // Computing bound for d
    if (_79 > 0) 
    goto _jump38;
    fail_assertion("non-positive loop bound");
    _jump38:;
    _86 = 0;
    int64_t _87 = 0; // d
    _jump39:; // Begin body of loop
    int64_t _88 = 694;
    _86 += _88;
    _87++;
    if (_87 < _79)
    goto _jump39;
    // End body of loop
    if (_86 >= 0)
    goto _jump40;
    fail_assertion("negative array index");
    _jump40:;
    if (_86 < _85.d0)
    goto _jump41;
    fail_assertion("index too large");
    _jump41:;
    int64_t _89 = 0;
    _89 *= _85.d0;
    _89 += _86;
    int64_t _90 = _85.data[_89];
    _82.d1 = _90;
    if (_90 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= _83;
    _91 *= _90;
    _91 *= sizeof(int64_t);
    _82.data = jpl_alloc(_91);
    int64_t _92 = 0; // e
    int64_t _93 = 0; // d
    _jump43:; // Begin body of loop
    int64_t _94 = 0;
    _94 *= _82.d0;
    _94 += _93;
    _94 *= _82.d1;
    _94 += _92;
    _82.data[_94] = _92;
    _92++;
    if (_92 < _90)
    goto _jump43;
    _92 = 0;
    _93++;
    if (_93 < _83)
    goto _jump43;
    // End body of loop
    _81 = _82;
    goto _jump44;
    _jump36:;
    _a1__a2_int64_t _95;
    // Computing bound for d
    _95.d0 = _79;
    if (_79 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= _79;
    _96 *= sizeof(_a2_int64_t);
    _95.data = jpl_alloc(_96);
    int64_t _97 = 0; // d
    _jump46:; // Begin body of loop
    _a2_int64_t _98;
    // Computing bound for e
    _98.d0 = _78;
    if (_78 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    // Computing bound for f
    _98.d1 = _79;
    if (_79 > 0) 
    goto _jump48;
    fail_assertion("non-positive loop bound");
    _jump48:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= _78;
    _99 *= _79;
    _99 *= sizeof(int64_t);
    _98.data = jpl_alloc(_99);
    int64_t _100 = 0; // f
    int64_t _101 = 0; // e
    _jump49:; // Begin body of loop
    int64_t _102 = 0;
    _102 *= _98.d0;
    _102 += _101;
    _102 *= _98.d1;
    _102 += _100;
    _98.data[_102] = _97;
    _100++;
    if (_100 < _79)
    goto _jump49;
    _100 = 0;
    _101++;
    if (_101 < _78)
    goto _jump49;
    // End body of loop
    int64_t _103 = 0;
    _103 *= _95.d0;
    _103 += _97;
    _95.data[_103] = _98;
    _97++;
    if (_97 < _79)
    goto _jump46;
    // End body of loop
    int64_t _104 = -_78;
    int64_t _105 = -_104;
    if (_105 >= 0)
    goto _jump50;
    fail_assertion("negative array index");
    _jump50:;
    if (_105 < _95.d0)
    goto _jump51;
    fail_assertion("index too large");
    _jump51:;
    int64_t _106 = 0;
    _106 *= _95.d0;
    _106 += _105;
    _a2_int64_t _107 = _95.data[_106];
    _81 = _107;
    _jump44:;
    int64_t _108 = 336;
    int64_t _109 = -_108;
    if (_78 >= 0)
    goto _jump52;
    fail_assertion("negative array index");
    _jump52:;
    if (_78 < _81.d0)
    goto _jump53;
    fail_assertion("index too large");
    _jump53:;
    if (_109 >= 0)
    goto _jump54;
    fail_assertion("negative array index");
    _jump54:;
    if (_109 < _81.d1)
    goto _jump55;
    fail_assertion("index too large");
    _jump55:;
    int64_t _110 = 0;
    _110 *= _81.d0;
    _110 += _78;
    _110 *= _81.d1;
    _110 += _109;
    int64_t _111 = _81.data[_110];
    int64_t _112 = 0;
    _112 *= _61.d0;
    _112 += _79;
    _112 *= _61.d1;
    _112 += _78;
    _61.data[_112] = _111;
    _78++;
    if (_78 < _76)
    goto _jump35;
    _78 = 0;
    _79++;
    if (_79 < _75)
    goto _jump35;
    // End body of loop
    _60 = _61;
    goto _jump56;
    _jump28:;
    _a2_int64_t _113;
    // Computing bound for b
    bool _114 = true;
    int64_t _115;
    if (!_114)
    goto _jump57;
    _a2_int64_t _116;
    // Computing bound for b
    int64_t _117 = 307;
    int64_t _118 = -_117;
    int64_t _119 = 642;
    int64_t _120 = 618;
    int64_t _121 = _119 + _120;
    int64_t _122 = _118 - _121;
    _116.d0 = _122;
    if (_122 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    // Computing bound for c
    int64_t _123;
    // Computing bound for b
    int64_t _124 = 569;
    int64_t _125 = -_124;
    if (_125 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    _123 = 0;
    int64_t _126 = 0; // b
    _jump60:; // Begin body of loop
    int64_t _127 = 805;
    _123 += _127;
    _126++;
    if (_126 < _125)
    goto _jump60;
    // End body of loop
    _116.d1 = _123;
    if (_123 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _122;
    _128 *= _123;
    _128 *= sizeof(int64_t);
    _116.data = jpl_alloc(_128);
    int64_t _129 = 0; // c
    int64_t _130 = 0; // b
    _jump62:; // Begin body of loop
    int64_t _131 = 0;
    _131 *= _116.d0;
    _131 += _130;
    _131 *= _116.d1;
    _131 += _129;
    _116.data[_131] = _130;
    _129++;
    if (_129 < _123)
    goto _jump62;
    _129 = 0;
    _130++;
    if (_130 < _122)
    goto _jump62;
    // End body of loop
    int64_t _132;
    // Computing bound for b
    bool _134 = true;
    bool _133 = _134;
    if (0 != _134)
    goto _jump63;
    bool _135 = true;
    _133 = _135;
    _jump63:;
    int64_t _136;
    if (!_133)
    goto _jump64;
    int64_t _137 = 164;
    int64_t _138 = -_137;
    _136 = _138;
    goto _jump65;
    _jump64:;
    int64_t _139 = 711;
    _136 = _139;
    _jump65:;
    if (_136 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing bound for c
    int64_t _140 = 156;
    int64_t _141 = -_140;
    int64_t _142 = -_141;
    if (_142 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    // Computing bound for d
    int64_t _143 = 873;
    if (_143 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    _132 = 0;
    int64_t _144 = 0; // d
    int64_t _145 = 0; // c
    int64_t _146 = 0; // b
    _jump69:; // Begin body of loop
    bool _147 = _145 != _144;
    int64_t _148;
    if (!_147)
    goto _jump70;
    int64_t _149 = 323;
    int64_t _150 = 828;
    int64_t _151 = _149 / _150;
    _148 = _151;
    goto _jump71;
    _jump70:;
    int64_t _152;
    // Computing bound for e
    int64_t _153 = 173;
    if (_153 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    _152 = 0;
    int64_t _154 = 0; // e
    _jump73:; // Begin body of loop
    _152 += _145;
    _154++;
    if (_154 < _153)
    goto _jump73;
    // End body of loop
    _148 = _152;
    _jump71:;
    _132 += _148;
    _144++;
    if (_144 < _143)
    goto _jump69;
    _144 = 0;
    _145++;
    if (_145 < _142)
    goto _jump69;
    _145 = 0;
    _146++;
    if (_146 < _136)
    goto _jump69;
    // End body of loop
    int64_t _155;
    // Computing bound for b
    int64_t _156 = 344;
    int64_t _157 = 627;
    int64_t _158 = -_157;
    int64_t _159 = _156 / _158;
    if (_159 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    _155 = 0;
    int64_t _160 = 0; // b
    _jump75:; // Begin body of loop
    int64_t _161 = 714;
    _155 += _161;
    _160++;
    if (_160 < _159)
    goto _jump75;
    // End body of loop
    if (_132 >= 0)
    goto _jump76;
    fail_assertion("negative array index");
    _jump76:;
    if (_132 < _116.d0)
    goto _jump77;
    fail_assertion("index too large");
    _jump77:;
    if (_155 >= 0)
    goto _jump78;
    fail_assertion("negative array index");
    _jump78:;
    if (_155 < _116.d1)
    goto _jump79;
    fail_assertion("index too large");
    _jump79:;
    int64_t _162 = 0;
    _162 *= _116.d0;
    _162 += _132;
    _162 *= _116.d1;
    _162 += _155;
    int64_t _163 = _116.data[_162];
    _115 = _163;
    goto _jump80;
    _jump57:;
    int64_t _164 = 372;
    _115 = _164;
    _jump80:;
    _113.d0 = _115;
    if (_115 > 0) 
    goto _jump81;
    fail_assertion("non-positive loop bound");
    _jump81:;
    // Computing bound for c
    int64_t _165 = 497;
    _113.d1 = _165;
    if (_165 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= _115;
    _166 *= _165;
    _166 *= sizeof(int64_t);
    _113.data = jpl_alloc(_166);
    int64_t _167 = 0; // c
    int64_t _168 = 0; // b
    _jump83:; // Begin body of loop
    int64_t _169;
    // Computing bound for d
    int64_t _170;
    // Computing bound for d
    _a1_bool _171;
    // Computing bound for d
    _171.d0 = _168;
    if (_168 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= _168;
    _172 *= sizeof(bool);
    _171.data = jpl_alloc(_172);
    int64_t _173 = 0; // d
    _jump85:; // Begin body of loop
    bool _174 = true;
    int64_t _175 = 0;
    _175 *= _171.d0;
    _175 += _173;
    _171.data[_175] = _174;
    _173++;
    if (_173 < _168)
    goto _jump85;
    // End body of loop
    int64_t _176;
    // Computing bound for d
    if (_168 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    _176 = 0;
    int64_t _177 = 0; // d
    _jump87:; // Begin body of loop
    _176 += _177;
    _177++;
    if (_177 < _168)
    goto _jump87;
    // End body of loop
    if (_176 >= 0)
    goto _jump88;
    fail_assertion("negative array index");
    _jump88:;
    if (_176 < _171.d0)
    goto _jump89;
    fail_assertion("index too large");
    _jump89:;
    int64_t _178 = 0;
    _178 *= _171.d0;
    _178 += _176;
    bool _179 = _171.data[_178];
    int64_t _180;
    if (!_179)
    goto _jump90;
    bool _181 = true;
    bool _182 = true;
    bool _183 = _181 == _182;
    int64_t _184;
    if (!_183)
    goto _jump91;
    _184 = _168;
    goto _jump92;
    _jump91:;
    _184 = _168;
    _jump92:;
    _180 = _184;
    goto _jump93;
    _jump90:;
    bool _185 = true;
    int64_t _186;
    if (!_185)
    goto _jump94;
    _186 = _168;
    goto _jump95;
    _jump94:;
    int64_t _187;
    // Computing bound for d
    if (_168 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing bound for e
    if (_168 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    _187 = 0;
    int64_t _188 = 0; // e
    int64_t _189 = 0; // d
    _jump98:; // Begin body of loop
    _187 += _189;
    _188++;
    if (_188 < _168)
    goto _jump98;
    _188 = 0;
    _189++;
    if (_189 < _168)
    goto _jump98;
    // End body of loop
    _186 = _187;
    _jump95:;
    _180 = _186;
    _jump93:;
    if (_180 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing bound for e
    int64_t _190;
    // Computing bound for d
    int64_t _191 = 230;
    if (_191 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    // Computing bound for e
    int64_t _192 = 81;
    int64_t _193 = _168 - _192;
    if (_193 > 0) 
    goto _jump101;
    fail_assertion("non-positive loop bound");
    _jump101:;
    // Computing bound for f
    int64_t _194 = -_168;
    if (_194 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    _190 = 0;
    int64_t _195 = 0; // f
    int64_t _196 = 0; // e
    int64_t _197 = 0; // d
    _jump103:; // Begin body of loop
    _190 += _167;
    _195++;
    if (_195 < _194)
    goto _jump103;
    _195 = 0;
    _196++;
    if (_196 < _193)
    goto _jump103;
    _196 = 0;
    _197++;
    if (_197 < _191)
    goto _jump103;
    // End body of loop
    int64_t _198 = _190 - _167;
    if (_198 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    // Computing bound for f
    _a2_int64_t _199;
    // Computing bound for d
    _199.d0 = _168;
    if (_168 > 0) 
    goto _jump105;
    fail_assertion("non-positive loop bound");
    _jump105:;
    // Computing bound for e
    int64_t _200 = 907;
    _199.d1 = _200;
    if (_200 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing total size of heap memory to allocate
    int64_t _201 = 1;
    _201 *= _168;
    _201 *= _200;
    _201 *= sizeof(int64_t);
    _199.data = jpl_alloc(_201);
    int64_t _202 = 0; // e
    int64_t _203 = 0; // d
    _jump107:; // Begin body of loop
    int64_t _204 = 991;
    int64_t _205 = 0;
    _205 *= _199.d0;
    _205 += _203;
    _205 *= _199.d1;
    _205 += _202;
    _199.data[_205] = _204;
    _202++;
    if (_202 < _200)
    goto _jump107;
    _202 = 0;
    _203++;
    if (_203 < _168)
    goto _jump107;
    // End body of loop
    int64_t _206;
    // Computing bound for d
    int64_t _207 = 974;
    if (_207 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    _206 = 0;
    int64_t _208 = 0; // d
    _jump109:; // Begin body of loop
    int64_t _209 = 934;
    int64_t _210 = _167 + _209;
    _206 += _210;
    _208++;
    if (_208 < _207)
    goto _jump109;
    // End body of loop
    if (_206 >= 0)
    goto _jump110;
    fail_assertion("negative array index");
    _jump110:;
    if (_206 < _199.d0)
    goto _jump111;
    fail_assertion("index too large");
    _jump111:;
    if (_167 >= 0)
    goto _jump112;
    fail_assertion("negative array index");
    _jump112:;
    if (_167 < _199.d1)
    goto _jump113;
    fail_assertion("index too large");
    _jump113:;
    int64_t _211 = 0;
    _211 *= _199.d0;
    _211 += _206;
    _211 *= _199.d1;
    _211 += _167;
    int64_t _212 = _199.data[_211];
    if (_212 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    _170 = 0;
    int64_t _213 = 0; // f
    int64_t _214 = 0; // e
    int64_t _215 = 0; // d
    _jump115:; // Begin body of loop
    int64_t _216;
    // Computing bound for g
    if (_167 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _216 = 0;
    int64_t _217 = 0; // g
    _jump117:; // Begin body of loop
    _216 += _217;
    _217++;
    if (_217 < _167)
    goto _jump117;
    // End body of loop
    _170 += _216;
    _213++;
    if (_213 < _212)
    goto _jump115;
    _213 = 0;
    _214++;
    if (_214 < _198)
    goto _jump115;
    _214 = 0;
    _215++;
    if (_215 < _180)
    goto _jump115;
    // End body of loop
    if (_170 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    _169 = 0;
    int64_t _218 = 0; // d
    _jump119:; // Begin body of loop
    bool _219 = false;
    _a3_int64_t _220;
    if (!_219)
    goto _jump120;
    bool _221 = false;
    _a3_int64_t _222;
    if (!_221)
    goto _jump121;
    _a3_int64_t _223;
    // Computing bound for e
    _223.d0 = _168;
    if (_168 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing bound for f
    _223.d1 = _167;
    if (_167 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    // Computing bound for g
    _223.d2 = _167;
    if (_167 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= _168;
    _224 *= _167;
    _224 *= _167;
    _224 *= sizeof(int64_t);
    _223.data = jpl_alloc(_224);
    int64_t _225 = 0; // g
    int64_t _226 = 0; // f
    int64_t _227 = 0; // e
    _jump125:; // Begin body of loop
    int64_t _228 = 0;
    _228 *= _223.d0;
    _228 += _227;
    _228 *= _223.d1;
    _228 += _226;
    _228 *= _223.d2;
    _228 += _225;
    _223.data[_228] = _225;
    _225++;
    if (_225 < _167)
    goto _jump125;
    _225 = 0;
    _226++;
    if (_226 < _167)
    goto _jump125;
    _226 = 0;
    _227++;
    if (_227 < _168)
    goto _jump125;
    // End body of loop
    _222 = _223;
    goto _jump126;
    _jump121:;
    _a3_int64_t _229;
    // Computing bound for e
    _229.d0 = _168;
    if (_168 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for f
    _229.d1 = _218;
    if (_218 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    // Computing bound for g
    _229.d2 = _167;
    if (_167 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= _168;
    _230 *= _218;
    _230 *= _167;
    _230 *= sizeof(int64_t);
    _229.data = jpl_alloc(_230);
    int64_t _231 = 0; // g
    int64_t _232 = 0; // f
    int64_t _233 = 0; // e
    _jump130:; // Begin body of loop
    int64_t _234 = 0;
    _234 *= _229.d0;
    _234 += _233;
    _234 *= _229.d1;
    _234 += _232;
    _234 *= _229.d2;
    _234 += _231;
    _229.data[_234] = _218;
    _231++;
    if (_231 < _167)
    goto _jump130;
    _231 = 0;
    _232++;
    if (_232 < _218)
    goto _jump130;
    _232 = 0;
    _233++;
    if (_233 < _168)
    goto _jump130;
    // End body of loop
    _222 = _229;
    _jump126:;
    _220 = _222;
    goto _jump131;
    _jump120:;
    _a3_int64_t _235;
    // Computing bound for e
    int64_t _236 = 714;
    _235.d0 = _236;
    if (_236 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    // Computing bound for f
    int64_t _237 = 294;
    _235.d1 = _237;
    if (_237 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    // Computing bound for g
    int64_t _238;
    // Computing bound for e
    int64_t _239 = 4;
    if (_239 > 0) 
    goto _jump134;
    fail_assertion("non-positive loop bound");
    _jump134:;
    // Computing bound for f
    if (_168 > 0) 
    goto _jump135;
    fail_assertion("non-positive loop bound");
    _jump135:;
    _238 = 0;
    int64_t _240 = 0; // f
    int64_t _241 = 0; // e
    _jump136:; // Begin body of loop
    _238 += _168;
    _240++;
    if (_240 < _168)
    goto _jump136;
    _240 = 0;
    _241++;
    if (_241 < _239)
    goto _jump136;
    // End body of loop
    _235.d2 = _238;
    if (_238 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing total size of heap memory to allocate
    int64_t _242 = 1;
    _242 *= _236;
    _242 *= _237;
    _242 *= _238;
    _242 *= sizeof(int64_t);
    _235.data = jpl_alloc(_242);
    int64_t _243 = 0; // g
    int64_t _244 = 0; // f
    int64_t _245 = 0; // e
    _jump138:; // Begin body of loop
    int64_t _246;
    // Computing bound for h
    if (_167 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing bound for i
    if (_245 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    _246 = 0;
    int64_t _247 = 0; // i
    int64_t _248 = 0; // h
    _jump141:; // Begin body of loop
    _246 += _167;
    _247++;
    if (_247 < _245)
    goto _jump141;
    _247 = 0;
    _248++;
    if (_248 < _167)
    goto _jump141;
    // End body of loop
    int64_t _249 = 0;
    _249 *= _235.d0;
    _249 += _245;
    _249 *= _235.d1;
    _249 += _244;
    _249 *= _235.d2;
    _249 += _243;
    _235.data[_249] = _246;
    _243++;
    if (_243 < _238)
    goto _jump138;
    _243 = 0;
    _244++;
    if (_244 < _237)
    goto _jump138;
    _244 = 0;
    _245++;
    if (_245 < _236)
    goto _jump138;
    // End body of loop
    _220 = _235;
    _jump131:;
    int64_t _250;
    // Computing bound for e
    if (_218 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    _250 = 0;
    int64_t _251 = 0; // e
    _jump143:; // Begin body of loop
    int64_t _252 = 819;
    _250 += _252;
    _251++;
    if (_251 < _218)
    goto _jump143;
    // End body of loop
    int64_t _253 = 497;
    if (_250 >= 0)
    goto _jump144;
    fail_assertion("negative array index");
    _jump144:;
    if (_250 < _220.d0)
    goto _jump145;
    fail_assertion("index too large");
    _jump145:;
    if (_167 >= 0)
    goto _jump146;
    fail_assertion("negative array index");
    _jump146:;
    if (_167 < _220.d1)
    goto _jump147;
    fail_assertion("index too large");
    _jump147:;
    if (_253 >= 0)
    goto _jump148;
    fail_assertion("negative array index");
    _jump148:;
    if (_253 < _220.d2)
    goto _jump149;
    fail_assertion("index too large");
    _jump149:;
    int64_t _254 = 0;
    _254 *= _220.d0;
    _254 += _250;
    _254 *= _220.d1;
    _254 += _167;
    _254 *= _220.d2;
    _254 += _253;
    int64_t _255 = _220.data[_254];
    _169 += _255;
    _218++;
    if (_218 < _170)
    goto _jump119;
    // End body of loop
    int64_t _256 = 0;
    _256 *= _113.d0;
    _256 += _168;
    _256 *= _113.d1;
    _256 += _167;
    _113.data[_256] = _169;
    _167++;
    if (_167 < _165)
    goto _jump83;
    _167 = 0;
    _168++;
    if (_168 < _115)
    goto _jump83;
    // End body of loop
    _60 = _113;
    _jump56:;
    bool _259 = false;
    bool _260 = !_259;
    bool _261 = !_260;
    bool _262 = !_261;
    bool _263 = !_262;
    bool _258 = _263;
    if (0 != _263)
    goto _jump150;
    bool _264 = false;
    _258 = _264;
    _jump150:;
    bool _265 = !_258;
    bool _257 = _265;
    if (0 == _265)
    goto _jump151;
    int64_t _266;
    // Computing bound for c
    int64_t _267 = 960;
    if (_267 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing bound for d
    int64_t _268 = 307;
    if (_268 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing bound for e
    bool _269 = false;
    bool _270 = !_269;
    int64_t _271;
    if (!_270)
    goto _jump154;
    _a1_int64_t _272;
    // Computing bound for c
    int64_t _273 = 351;
    int64_t _274 = -_273;
    _272.d0 = _274;
    if (_274 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing total size of heap memory to allocate
    int64_t _275 = 1;
    _275 *= _274;
    _275 *= sizeof(int64_t);
    _272.data = jpl_alloc(_275);
    int64_t _276 = 0; // c
    _jump156:; // Begin body of loop
    int64_t _277 = 474;
    int64_t _278 = -_277;
    int64_t _279 = 0;
    _279 *= _272.d0;
    _279 += _276;
    _272.data[_279] = _278;
    _276++;
    if (_276 < _274)
    goto _jump156;
    // End body of loop
    bool _280 = false;
    int64_t _281;
    if (!_280)
    goto _jump157;
    int64_t _282 = 832;
    _281 = _282;
    goto _jump158;
    _jump157:;
    int64_t _283 = 453;
    int64_t _284 = 705;
    int64_t _285 = _283 / _284;
    _281 = _285;
    _jump158:;
    if (_281 >= 0)
    goto _jump159;
    fail_assertion("negative array index");
    _jump159:;
    if (_281 < _272.d0)
    goto _jump160;
    fail_assertion("index too large");
    _jump160:;
    int64_t _286 = 0;
    _286 *= _272.d0;
    _286 += _281;
    int64_t _287 = _272.data[_286];
    _271 = _287;
    goto _jump161;
    _jump154:;
    int64_t _288 = 106;
    int64_t _289 = -_288;
    _271 = _289;
    _jump161:;
    if (_271 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _266 = 0;
    int64_t _290 = 0; // e
    int64_t _291 = 0; // d
    int64_t _292 = 0; // c
    _jump163:; // Begin body of loop
    _a3_int64_t _293;
    // Computing bound for f
    _293.d0 = _290;
    if (_290 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing bound for g
    int64_t _294;
    // Computing bound for f
    int64_t _295 = 643;
    int64_t _296 = -_295;
    if (_296 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    _294 = 0;
    int64_t _297 = 0; // f
    _jump166:; // Begin body of loop
    _294 += _291;
    _297++;
    if (_297 < _296)
    goto _jump166;
    // End body of loop
    _293.d1 = _294;
    if (_294 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing bound for h
    int64_t _298 = 669;
    _293.d2 = _298;
    if (_298 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= _290;
    _299 *= _294;
    _299 *= _298;
    _299 *= sizeof(int64_t);
    _293.data = jpl_alloc(_299);
    int64_t _300 = 0; // h
    int64_t _301 = 0; // g
    int64_t _302 = 0; // f
    _jump169:; // Begin body of loop
    int64_t _303;
    // Computing bound for i
    bool _304 = true;
    int64_t _305;
    if (!_304)
    goto _jump170;
    _305 = _292;
    goto _jump171;
    _jump170:;
    _305 = _290;
    _jump171:;
    if (_305 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    // Computing bound for j
    if (_300 > 0) 
    goto _jump173;
    fail_assertion("non-positive loop bound");
    _jump173:;
    _303 = 0;
    int64_t _306 = 0; // j
    int64_t _307 = 0; // i
    _jump174:; // Begin body of loop
    _303 += _291;
    _306++;
    if (_306 < _300)
    goto _jump174;
    _306 = 0;
    _307++;
    if (_307 < _305)
    goto _jump174;
    // End body of loop
    int64_t _308 = 0;
    _308 *= _293.d0;
    _308 += _302;
    _308 *= _293.d1;
    _308 += _301;
    _308 *= _293.d2;
    _308 += _300;
    _293.data[_308] = _303;
    _300++;
    if (_300 < _298)
    goto _jump169;
    _300 = 0;
    _301++;
    if (_301 < _294)
    goto _jump169;
    _301 = 0;
    _302++;
    if (_302 < _290)
    goto _jump169;
    // End body of loop
    int64_t _309 = 171;
    int64_t _310;
    // Computing bound for f
    int64_t _311 = 956;
    if (_311 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    _310 = 0;
    int64_t _312 = 0; // f
    _jump176:; // Begin body of loop
    int64_t _313;
    // Computing bound for g
    int64_t _314 = 116;
    if (_314 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing bound for h
    int64_t _315;
    // Computing bound for g
    if (_291 > 0) 
    goto _jump178;
    fail_assertion("non-positive loop bound");
    _jump178:;
    // Computing bound for h
    int64_t _316 = 22;
    if (_316 > 0) 
    goto _jump179;
    fail_assertion("non-positive loop bound");
    _jump179:;
    _315 = 0;
    int64_t _317 = 0; // h
    int64_t _318 = 0; // g
    _jump180:; // Begin body of loop
    _315 += _318;
    _317++;
    if (_317 < _316)
    goto _jump180;
    _317 = 0;
    _318++;
    if (_318 < _291)
    goto _jump180;
    // End body of loop
    if (_315 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    _313 = 0;
    int64_t _319 = 0; // h
    int64_t _320 = 0; // g
    _jump182:; // Begin body of loop
    _313 += _312;
    _319++;
    if (_319 < _315)
    goto _jump182;
    _319 = 0;
    _320++;
    if (_320 < _314)
    goto _jump182;
    // End body of loop
    _310 += _313;
    _312++;
    if (_312 < _311)
    goto _jump176;
    // End body of loop
    if (_292 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (_292 < _293.d0)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    if (_309 >= 0)
    goto _jump185;
    fail_assertion("negative array index");
    _jump185:;
    if (_309 < _293.d1)
    goto _jump186;
    fail_assertion("index too large");
    _jump186:;
    if (_310 >= 0)
    goto _jump187;
    fail_assertion("negative array index");
    _jump187:;
    if (_310 < _293.d2)
    goto _jump188;
    fail_assertion("index too large");
    _jump188:;
    int64_t _321 = 0;
    _321 *= _293.d0;
    _321 += _292;
    _321 *= _293.d1;
    _321 += _309;
    _321 *= _293.d2;
    _321 += _310;
    int64_t _322 = _293.data[_321];
    _266 += _322;
    _290++;
    if (_290 < _271)
    goto _jump163;
    _290 = 0;
    _291++;
    if (_291 < _268)
    goto _jump163;
    _291 = 0;
    _292++;
    if (_292 < _267)
    goto _jump163;
    // End body of loop
    int64_t _323;
    // Computing bound for c
    int64_t _324;
    // Computing bound for c
    int64_t _325;
    // Computing bound for c
    int64_t _326 = 404;
    if (_326 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing bound for d
    int64_t _327 = 104;
    int64_t _328 = 949;
    int64_t _329 = _327 / _328;
    if (_329 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing bound for e
    int64_t _330 = 100;
    int64_t _331 = 397;
    int64_t _332 = _330 - _331;
    if (_332 > 0) 
    goto _jump191;
    fail_assertion("non-positive loop bound");
    _jump191:;
    _325 = 0;
    int64_t _333 = 0; // e
    int64_t _334 = 0; // d
    int64_t _335 = 0; // c
    _jump192:; // Begin body of loop
    _325 += _333;
    _333++;
    if (_333 < _332)
    goto _jump192;
    _333 = 0;
    _334++;
    if (_334 < _329)
    goto _jump192;
    _334 = 0;
    _335++;
    if (_335 < _326)
    goto _jump192;
    // End body of loop
    if (_325 > 0) 
    goto _jump193;
    fail_assertion("non-positive loop bound");
    _jump193:;
    // Computing bound for d
    int64_t _336;
    // Computing bound for c
    int64_t _337 = 887;
    if (_337 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for d
    int64_t _338 = 946;
    if (_338 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    _336 = 0;
    int64_t _339 = 0; // d
    int64_t _340 = 0; // c
    _jump196:; // Begin body of loop
    _336 += _340;
    _339++;
    if (_339 < _338)
    goto _jump196;
    _339 = 0;
    _340++;
    if (_340 < _337)
    goto _jump196;
    // End body of loop
    if (_336 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing bound for e
    int64_t _341 = 567;
    int64_t _342 = -_341;
    if (_342 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    _324 = 0;
    int64_t _343 = 0; // e
    int64_t _344 = 0; // d
    int64_t _345 = 0; // c
    _jump199:; // Begin body of loop
    int64_t _346;
    // Computing bound for f
    int64_t _347;
    // Computing bound for f
    if (_343 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing bound for g
    if (_344 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    _347 = 0;
    int64_t _348 = 0; // g
    int64_t _349 = 0; // f
    _jump202:; // Begin body of loop
    _347 += _348;
    _348++;
    if (_348 < _344)
    goto _jump202;
    _348 = 0;
    _349++;
    if (_349 < _343)
    goto _jump202;
    // End body of loop
    if (_347 > 0) 
    goto _jump203;
    fail_assertion("non-positive loop bound");
    _jump203:;
    _346 = 0;
    int64_t _350 = 0; // f
    _jump204:; // Begin body of loop
    _346 += _345;
    _350++;
    if (_350 < _347)
    goto _jump204;
    // End body of loop
    _324 += _346;
    _343++;
    if (_343 < _342)
    goto _jump199;
    _343 = 0;
    _344++;
    if (_344 < _336)
    goto _jump199;
    _344 = 0;
    _345++;
    if (_345 < _325)
    goto _jump199;
    // End body of loop
    if (_324 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    _323 = 0;
    int64_t _351 = 0; // c
    _jump206:; // Begin body of loop
    int64_t _352 = -_351;
    _323 += _352;
    _351++;
    if (_351 < _324)
    goto _jump206;
    // End body of loop
    bool _353 = true;
    int64_t _354;
    if (!_353)
    goto _jump207;
    int64_t _355 = 770;
    int64_t _356 = 704;
    int64_t _357 = 600;
    if (_356 >= 0)
    goto _jump208;
    fail_assertion("negative array index");
    _jump208:;
    if (_356 < _60.d0)
    goto _jump209;
    fail_assertion("index too large");
    _jump209:;
    if (_357 >= 0)
    goto _jump210;
    fail_assertion("negative array index");
    _jump210:;
    if (_357 < _60.d1)
    goto _jump211;
    fail_assertion("index too large");
    _jump211:;
    int64_t _358 = 0;
    _358 *= _60.d0;
    _358 += _356;
    _358 *= _60.d1;
    _358 += _357;
    int64_t _359 = _60.data[_358];
    int64_t _360 = _355 - _359;
    bool _361 = false;
    int64_t _362;
    if (!_361)
    goto _jump212;
    int64_t _363 = 135;
    int64_t _364 = -_363;
    _362 = _364;
    goto _jump213;
    _jump212:;
    int64_t _365 = 840;
    _362 = _365;
    _jump213:;
    int64_t _366 = _360 - _362;
    _354 = _366;
    goto _jump214;
    _jump207:;
    int64_t _367 = 350;
    _354 = _367;
    _jump214:;
    int64_t _368 = _323 % _354;
    bool _369 = _266 > _368;
    _257 = _369;
    _jump151:;
    if (0 != _257)
    goto _jump215;
    fail_assertion("c");
    _jump215:;
    bool _370 = true;
    bool _371 = !_370;
    if (0 != _371)
    goto _jump216;
    fail_assertion("c");
    _jump216:;
    int64_t _372 = 952;
    int64_t _373 = -_372;
    double _374 = 77.0;
    bool _375 = false;
    int64_t _376;
    if (!_375)
    goto _jump217;
    int64_t _377 = 610;
    _376 = _377;
    goto _jump218;
    _jump217:;
    _376 = _373;
    _jump218:;
    int64_t _378 = -_373;
    bool _379 = _376 == _378;
    double _380;
    if (!_379)
    goto _jump219;
    double _381 = 37.0;
    _380 = _381;
    goto _jump220;
    _jump219:;
    double _382;
    // Computing bound for d
    _a3_int64_t _383;
    // Computing bound for d
    int64_t _384 = 58;
    int64_t _385 = _384 + _373;
    _383.d0 = _385;
    if (_385 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing bound for e
    int64_t _386 = 828;
    _383.d1 = _386;
    if (_386 > 0) 
    goto _jump222;
    fail_assertion("non-positive loop bound");
    _jump222:;
    // Computing bound for f
    _383.d2 = _373;
    if (_373 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing total size of heap memory to allocate
    int64_t _387 = 1;
    _387 *= _385;
    _387 *= _386;
    _387 *= _373;
    _387 *= sizeof(int64_t);
    _383.data = jpl_alloc(_387);
    int64_t _388 = 0; // f
    int64_t _389 = 0; // e
    int64_t _390 = 0; // d
    _jump224:; // Begin body of loop
    int64_t _391;
    // Computing bound for g
    if (_389 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    _391 = 0;
    int64_t _392 = 0; // g
    _jump226:; // Begin body of loop
    int64_t _393 = 500;
    _391 += _393;
    _392++;
    if (_392 < _389)
    goto _jump226;
    // End body of loop
    int64_t _394 = 0;
    _394 *= _383.d0;
    _394 += _390;
    _394 *= _383.d1;
    _394 += _389;
    _394 *= _383.d2;
    _394 += _388;
    _383.data[_394] = _391;
    _388++;
    if (_388 < _373)
    goto _jump224;
    _388 = 0;
    _389++;
    if (_389 < _386)
    goto _jump224;
    _389 = 0;
    _390++;
    if (_390 < _385)
    goto _jump224;
    // End body of loop
    _a1_int64_t _395;
    // Computing bound for d
    int64_t _396 = 102;
    _395.d0 = _396;
    if (_396 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing total size of heap memory to allocate
    int64_t _397 = 1;
    _397 *= _396;
    _397 *= sizeof(int64_t);
    _395.data = jpl_alloc(_397);
    int64_t _398 = 0; // d
    _jump228:; // Begin body of loop
    int64_t _399 = 702;
    int64_t _400 = 0;
    _400 *= _395.d0;
    _400 += _398;
    _395.data[_400] = _399;
    _398++;
    if (_398 < _396)
    goto _jump228;
    // End body of loop
    if (_373 >= 0)
    goto _jump229;
    fail_assertion("negative array index");
    _jump229:;
    if (_373 < _395.d0)
    goto _jump230;
    fail_assertion("index too large");
    _jump230:;
    int64_t _401 = 0;
    _401 *= _395.d0;
    _401 += _373;
    int64_t _402 = _395.data[_401];
    int64_t _403 = 714;
    if (_373 >= 0)
    goto _jump231;
    fail_assertion("negative array index");
    _jump231:;
    if (_373 < _383.d0)
    goto _jump232;
    fail_assertion("index too large");
    _jump232:;
    if (_402 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (_402 < _383.d1)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    if (_403 >= 0)
    goto _jump235;
    fail_assertion("negative array index");
    _jump235:;
    if (_403 < _383.d2)
    goto _jump236;
    fail_assertion("index too large");
    _jump236:;
    int64_t _404 = 0;
    _404 *= _383.d0;
    _404 += _373;
    _404 *= _383.d1;
    _404 += _402;
    _404 *= _383.d2;
    _404 += _403;
    int64_t _405 = _383.data[_404];
    if (_405 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    _382 = 0;
    int64_t _406 = 0; // d
    _jump238:; // Begin body of loop
    double _407 = 99.0;
    double _408 = -_407;
    _382 += _408;
    _406++;
    if (_406 < _405)
    goto _jump238;
    // End body of loop
    _380 = _382;
    _jump220:;
    double _409 = _374 / _380;
    double _410 = -_409;
    bool _412 = false;
    _a2_bool _413;
    if (!_412)
    goto _jump239;
    _a1__a2_bool _414;
    // Computing bound for e
    _414.d0 = _373;
    if (_373 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    // Computing total size of heap memory to allocate
    int64_t _415 = 1;
    _415 *= _373;
    _415 *= sizeof(_a2_bool);
    _414.data = jpl_alloc(_415);
    int64_t _416 = 0; // e
    _jump241:; // Begin body of loop
    _a2_bool _417;
    // Computing bound for f
    _417.d0 = _373;
    if (_373 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for g
    _417.d1 = _416;
    if (_416 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    // Computing total size of heap memory to allocate
    int64_t _418 = 1;
    _418 *= _373;
    _418 *= _416;
    _418 *= sizeof(bool);
    _417.data = jpl_alloc(_418);
    int64_t _419 = 0; // g
    int64_t _420 = 0; // f
    _jump244:; // Begin body of loop
    bool _421 = true;
    int64_t _422 = 0;
    _422 *= _417.d0;
    _422 += _420;
    _422 *= _417.d1;
    _422 += _419;
    _417.data[_422] = _421;
    _419++;
    if (_419 < _416)
    goto _jump244;
    _419 = 0;
    _420++;
    if (_420 < _373)
    goto _jump244;
    // End body of loop
    int64_t _423 = 0;
    _423 *= _414.d0;
    _423 += _416;
    _414.data[_423] = _417;
    _416++;
    if (_416 < _373)
    goto _jump241;
    // End body of loop
    bool _424 = true;
    int64_t _425;
    if (!_424)
    goto _jump245;
    _425 = _373;
    goto _jump246;
    _jump245:;
    _425 = _373;
    _jump246:;
    if (_425 >= 0)
    goto _jump247;
    fail_assertion("negative array index");
    _jump247:;
    if (_425 < _414.d0)
    goto _jump248;
    fail_assertion("index too large");
    _jump248:;
    int64_t _426 = 0;
    _426 *= _414.d0;
    _426 += _425;
    _a2_bool _427 = _414.data[_426];
    _413 = _427;
    goto _jump249;
    _jump239:;
    _a2_bool _428;
    // Computing bound for e
    _428.d0 = _373;
    if (_373 > 0) 
    goto _jump250;
    fail_assertion("non-positive loop bound");
    _jump250:;
    // Computing bound for f
    int64_t _429 = 756;
    int64_t _430 = -_429;
    _428.d1 = _430;
    if (_430 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing total size of heap memory to allocate
    int64_t _431 = 1;
    _431 *= _373;
    _431 *= _430;
    _431 *= sizeof(bool);
    _428.data = jpl_alloc(_431);
    int64_t _432 = 0; // f
    int64_t _433 = 0; // e
    _jump252:; // Begin body of loop
    bool _434 = true;
    bool _435 = !_434;
    int64_t _436 = 0;
    _436 *= _428.d0;
    _436 += _433;
    _436 *= _428.d1;
    _436 += _432;
    _428.data[_436] = _435;
    _432++;
    if (_432 < _430)
    goto _jump252;
    _432 = 0;
    _433++;
    if (_433 < _373)
    goto _jump252;
    // End body of loop
    _413 = _428;
    _jump249:;
    int64_t _437;
    // Computing bound for e
    int64_t _438 = -_373;
    if (_438 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    // Computing bound for f
    int64_t _439 = 792;
    if (_439 > 0) 
    goto _jump254;
    fail_assertion("non-positive loop bound");
    _jump254:;
    _437 = 0;
    int64_t _440 = 0; // f
    int64_t _441 = 0; // e
    _jump255:; // Begin body of loop
    int64_t _442 = 863;
    _437 += _442;
    _440++;
    if (_440 < _439)
    goto _jump255;
    _440 = 0;
    _441++;
    if (_441 < _438)
    goto _jump255;
    // End body of loop
    int64_t _443 = 867;
    if (_437 >= 0)
    goto _jump256;
    fail_assertion("negative array index");
    _jump256:;
    if (_437 < _413.d0)
    goto _jump257;
    fail_assertion("index too large");
    _jump257:;
    if (_443 >= 0)
    goto _jump258;
    fail_assertion("negative array index");
    _jump258:;
    if (_443 < _413.d1)
    goto _jump259;
    fail_assertion("index too large");
    _jump259:;
    int64_t _444 = 0;
    _444 *= _413.d0;
    _444 += _437;
    _444 *= _413.d1;
    _444 += _443;
    bool _445 = _413.data[_444];
    bool _411 = _445;
    if (0 == _445)
    goto _jump260;
    bool _446 = false;
    bool _447 = !_446;
    int64_t _448;
    if (!_447)
    goto _jump261;
    _a1_int64_t _449;
    // Computing bound for e
    _449.d0 = _373;
    if (_373 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= _373;
    _450 *= sizeof(int64_t);
    _449.data = jpl_alloc(_450);
    int64_t _451 = 0; // e
    _jump263:; // Begin body of loop
    int64_t _452 = 903;
    int64_t _453 = 0;
    _453 *= _449.d0;
    _453 += _451;
    _449.data[_453] = _452;
    _451++;
    if (_451 < _373)
    goto _jump263;
    // End body of loop
    if (_373 >= 0)
    goto _jump264;
    fail_assertion("negative array index");
    _jump264:;
    if (_373 < _449.d0)
    goto _jump265;
    fail_assertion("index too large");
    _jump265:;
    int64_t _454 = 0;
    _454 *= _449.d0;
    _454 += _373;
    int64_t _455 = _449.data[_454];
    int64_t _456 = 316;
    if (_455 >= 0)
    goto _jump266;
    fail_assertion("negative array index");
    _jump266:;
    if (_455 < _60.d0)
    goto _jump267;
    fail_assertion("index too large");
    _jump267:;
    if (_456 >= 0)
    goto _jump268;
    fail_assertion("negative array index");
    _jump268:;
    if (_456 < _60.d1)
    goto _jump269;
    fail_assertion("index too large");
    _jump269:;
    int64_t _457 = 0;
    _457 *= _60.d0;
    _457 += _455;
    _457 *= _60.d1;
    _457 += _456;
    int64_t _458 = _60.data[_457];
    _448 = _458;
    goto _jump270;
    _jump261:;
    int64_t _459;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for f
    int64_t _460 = -_373;
    if (_460 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing bound for g
    int64_t _461 = 220;
    if (_461 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    _459 = 0;
    int64_t _462 = 0; // g
    int64_t _463 = 0; // f
    int64_t _464 = 0; // e
    _jump274:; // Begin body of loop
    _459 += _462;
    _462++;
    if (_462 < _461)
    goto _jump274;
    _462 = 0;
    _463++;
    if (_463 < _460)
    goto _jump274;
    _463 = 0;
    _464++;
    if (_464 < _373)
    goto _jump274;
    // End body of loop
    _448 = _459;
    _jump270:;
    bool _465 = _448 >= _373;
    _411 = _465;
    _jump260:;
    _a3__a1_int64_t _466;
    if (!_411)
    goto _jump275;
    int64_t _467 = 521;
    int64_t _468 = -_467;
    int64_t _469 = 69;
    int64_t _470 = 382;
    int64_t _471 = _469 % _470;
    bool _472 = true;
    int64_t _473;
    if (!_472)
    goto _jump276;
    int64_t _474 = 498;
    _473 = _474;
    goto _jump277;
    _jump276:;
    int64_t _475 = 836;
    _473 = _475;
    _jump277:;
    int64_t _476 = _471 - _473;
    int64_t _477 = _468 + _476;
    if (_373 >= 0)
    goto _jump278;
    fail_assertion("negative array index");
    _jump278:;
    if (_373 < _60.d0)
    goto _jump279;
    fail_assertion("index too large");
    _jump279:;
    if (_373 >= 0)
    goto _jump280;
    fail_assertion("negative array index");
    _jump280:;
    if (_373 < _60.d1)
    goto _jump281;
    fail_assertion("index too large");
    _jump281:;
    int64_t _478 = 0;
    _478 *= _60.d0;
    _478 += _373;
    _478 *= _60.d1;
    _478 += _373;
    int64_t _479 = _60.data[_478];
    int64_t _480 = _477 / _479;
    int64_t _481 = 456;
    bool _482 = _480 < _481;
    _a3__a1_int64_t _483;
    if (!_482)
    goto _jump282;
    bool _485 = true;
    bool _486 = false;
    bool _487 = _485 == _486;
    bool _484 = _487;
    if (0 != _487)
    goto _jump283;
    bool _488 = true;
    _484 = _488;
    _jump283:;
    _a3__a1_int64_t _489;
    if (!_484)
    goto _jump284;
    _a3__a1_int64_t _490;
    // Computing bound for e
    int64_t _491 = 279;
    int64_t _492 = 395;
    int64_t _493 = -_492;
    bool _494 = _491 <= _493;
    int64_t _495;
    if (!_494)
    goto _jump285;
    bool _496 = false;
    bool _497 = !_496;
    int64_t _498;
    if (!_497)
    goto _jump286;
    _498 = _373;
    goto _jump287;
    _jump286:;
    int64_t _499 = 807;
    _498 = _499;
    _jump287:;
    _495 = _498;
    goto _jump288;
    _jump285:;
    int64_t _500;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    // Computing bound for f
    int64_t _501 = 712;
    if (_501 > 0) 
    goto _jump290;
    fail_assertion("non-positive loop bound");
    _jump290:;
    // Computing bound for g
    int64_t _502 = 179;
    int64_t _503 = _502 * _373;
    if (_503 > 0) 
    goto _jump291;
    fail_assertion("non-positive loop bound");
    _jump291:;
    _500 = 0;
    int64_t _504 = 0; // g
    int64_t _505 = 0; // f
    int64_t _506 = 0; // e
    _jump292:; // Begin body of loop
    _500 += _505;
    _504++;
    if (_504 < _503)
    goto _jump292;
    _504 = 0;
    _505++;
    if (_505 < _501)
    goto _jump292;
    _505 = 0;
    _506++;
    if (_506 < _373)
    goto _jump292;
    // End body of loop
    _495 = _500;
    _jump288:;
    _490.d0 = _495;
    if (_495 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    // Computing bound for f
    int64_t _507 = 472;
    _490.d1 = _507;
    if (_507 > 0) 
    goto _jump294;
    fail_assertion("non-positive loop bound");
    _jump294:;
    // Computing bound for g
    bool _508 = true;
    bool _509 = !_508;
    _a2_int64_t _510;
    if (!_509)
    goto _jump295;
    _510 = _60;
    goto _jump296;
    _jump295:;
    _510 = _60;
    _jump296:;
    int64_t _511 = 815;
    if (_373 >= 0)
    goto _jump297;
    fail_assertion("negative array index");
    _jump297:;
    if (_373 < _510.d0)
    goto _jump298;
    fail_assertion("index too large");
    _jump298:;
    if (_511 >= 0)
    goto _jump299;
    fail_assertion("negative array index");
    _jump299:;
    if (_511 < _510.d1)
    goto _jump300;
    fail_assertion("index too large");
    _jump300:;
    int64_t _512 = 0;
    _512 *= _510.d0;
    _512 += _373;
    _512 *= _510.d1;
    _512 += _511;
    int64_t _513 = _510.data[_512];
    _490.d2 = _513;
    if (_513 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing total size of heap memory to allocate
    int64_t _514 = 1;
    _514 *= _495;
    _514 *= _507;
    _514 *= _513;
    _514 *= sizeof(_a1_int64_t);
    _490.data = jpl_alloc(_514);
    int64_t _515 = 0; // g
    int64_t _516 = 0; // f
    int64_t _517 = 0; // e
    _jump302:; // Begin body of loop
    int64_t _518 = 694;
    int64_t _519 = -_516;
    int64_t _520 = 572;
    _a1_int64_t _521;
    _521.d0 = 3;
    _521.data = jpl_alloc(sizeof(int64_t) * 3);
    _521.data[0] = _518;
    _521.data[1] = _519;
    _521.data[2] = _520;
    int64_t _522 = 0;
    _522 *= _490.d0;
    _522 += _517;
    _522 *= _490.d1;
    _522 += _516;
    _522 *= _490.d2;
    _522 += _515;
    _490.data[_522] = _521;
    _515++;
    if (_515 < _513)
    goto _jump302;
    _515 = 0;
    _516++;
    if (_516 < _507)
    goto _jump302;
    _516 = 0;
    _517++;
    if (_517 < _495)
    goto _jump302;
    // End body of loop
    _489 = _490;
    goto _jump303;
    _jump284:;
    _a3__a1_int64_t _523;
    // Computing bound for e
    int64_t _524;
    // Computing bound for e
    int64_t _525 = 18;
    if (_525 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for f
    int64_t _526;
    // Computing bound for e
    int64_t _527 = 505;
    if (_527 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    _526 = 0;
    int64_t _528 = 0; // e
    _jump306:; // Begin body of loop
    _526 += _373;
    _528++;
    if (_528 < _527)
    goto _jump306;
    // End body of loop
    if (_526 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    _524 = 0;
    int64_t _529 = 0; // f
    int64_t _530 = 0; // e
    _jump308:; // Begin body of loop
    int64_t _531;
    // Computing bound for g
    int64_t _532 = -_373;
    if (_532 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    _531 = 0;
    int64_t _533 = 0; // g
    _jump310:; // Begin body of loop
    _531 += _373;
    _533++;
    if (_533 < _532)
    goto _jump310;
    // End body of loop
    _524 += _531;
    _529++;
    if (_529 < _526)
    goto _jump308;
    _529 = 0;
    _530++;
    if (_530 < _525)
    goto _jump308;
    // End body of loop
    _523.d0 = _524;
    if (_524 > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing bound for f
    int64_t _534;
    // Computing bound for e
    int64_t _535 = 740;
    bool _536 = _535 >= _373;
    int64_t _537;
    if (!_536)
    goto _jump312;
    int64_t _538 = 89;
    _537 = _538;
    goto _jump313;
    _jump312:;
    int64_t _539 = 252;
    int64_t _540 = -_539;
    _537 = _540;
    _jump313:;
    if (_537 > 0) 
    goto _jump314;
    fail_assertion("non-positive loop bound");
    _jump314:;
    // Computing bound for f
    int64_t _541 = 140;
    if (_541 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    _534 = 0;
    int64_t _542 = 0; // f
    int64_t _543 = 0; // e
    _jump316:; // Begin body of loop
    int64_t _544 = -_543;
    _534 += _544;
    _542++;
    if (_542 < _541)
    goto _jump316;
    _542 = 0;
    _543++;
    if (_543 < _537)
    goto _jump316;
    // End body of loop
    _523.d1 = _534;
    if (_534 > 0) 
    goto _jump317;
    fail_assertion("non-positive loop bound");
    _jump317:;
    // Computing bound for g
    int64_t _545 = -_373;
    int64_t _546 = _545 / _373;
    _523.d2 = _546;
    if (_546 > 0) 
    goto _jump318;
    fail_assertion("non-positive loop bound");
    _jump318:;
    // Computing total size of heap memory to allocate
    int64_t _547 = 1;
    _547 *= _524;
    _547 *= _534;
    _547 *= _546;
    _547 *= sizeof(_a1_int64_t);
    _523.data = jpl_alloc(_547);
    int64_t _548 = 0; // g
    int64_t _549 = 0; // f
    int64_t _550 = 0; // e
    _jump319:; // Begin body of loop
    _a1__a1_int64_t _551;
    // Computing bound for h
    _551.d0 = _550;
    if (_550 > 0) 
    goto _jump320;
    fail_assertion("non-positive loop bound");
    _jump320:;
    // Computing total size of heap memory to allocate
    int64_t _552 = 1;
    _552 *= _550;
    _552 *= sizeof(_a1_int64_t);
    _551.data = jpl_alloc(_552);
    int64_t _553 = 0; // h
    _jump321:; // Begin body of loop
    _a1_int64_t _554;
    _554.d0 = 3;
    _554.data = jpl_alloc(sizeof(int64_t) * 3);
    _554.data[0] = _373;
    _554.data[1] = _373;
    _554.data[2] = _373;
    int64_t _555 = 0;
    _555 *= _551.d0;
    _555 += _553;
    _551.data[_555] = _554;
    _553++;
    if (_553 < _550)
    goto _jump321;
    // End body of loop
    if (_550 >= 0)
    goto _jump322;
    fail_assertion("negative array index");
    _jump322:;
    if (_550 < _551.d0)
    goto _jump323;
    fail_assertion("index too large");
    _jump323:;
    int64_t _556 = 0;
    _556 *= _551.d0;
    _556 += _550;
    _a1_int64_t _557 = _551.data[_556];
    int64_t _558 = 0;
    _558 *= _523.d0;
    _558 += _550;
    _558 *= _523.d1;
    _558 += _549;
    _558 *= _523.d2;
    _558 += _548;
    _523.data[_558] = _557;
    _548++;
    if (_548 < _546)
    goto _jump319;
    _548 = 0;
    _549++;
    if (_549 < _534)
    goto _jump319;
    _549 = 0;
    _550++;
    if (_550 < _524)
    goto _jump319;
    // End body of loop
    _489 = _523;
    _jump303:;
    _483 = _489;
    goto _jump324;
    _jump282:;
    _a3__a1_int64_t _559;
    // Computing bound for e
    int64_t _560;
    // Computing bound for e
    int64_t _561 = 448;
    if (_561 >= 0)
    goto _jump325;
    fail_assertion("negative array index");
    _jump325:;
    if (_561 < _60.d0)
    goto _jump326;
    fail_assertion("index too large");
    _jump326:;
    if (_373 >= 0)
    goto _jump327;
    fail_assertion("negative array index");
    _jump327:;
    if (_373 < _60.d1)
    goto _jump328;
    fail_assertion("index too large");
    _jump328:;
    int64_t _562 = 0;
    _562 *= _60.d0;
    _562 += _561;
    _562 *= _60.d1;
    _562 += _373;
    int64_t _563 = _60.data[_562];
    int64_t _564 = -_563;
    int64_t _565 = -_564;
    if (_565 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    _560 = 0;
    int64_t _566 = 0; // e
    _jump330:; // Begin body of loop
    _a3_int64_t _567;
    // Computing bound for f
    int64_t _568;
    // Computing bound for f
    if (_373 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    _568 = 0;
    int64_t _569 = 0; // f
    _jump332:; // Begin body of loop
    _568 += _373;
    _569++;
    if (_569 < _373)
    goto _jump332;
    // End body of loop
    _567.d0 = _568;
    if (_568 > 0) 
    goto _jump333;
    fail_assertion("non-positive loop bound");
    _jump333:;
    // Computing bound for g
    int64_t _570 = -_566;
    _567.d1 = _570;
    if (_570 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    // Computing bound for h
    int64_t _571;
    // Computing bound for f
    int64_t _572 = 754;
    if (_572 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    _571 = 0;
    int64_t _573 = 0; // f
    _jump336:; // Begin body of loop
    int64_t _574 = 639;
    _571 += _574;
    _573++;
    if (_573 < _572)
    goto _jump336;
    // End body of loop
    _567.d2 = _571;
    if (_571 > 0) 
    goto _jump337;
    fail_assertion("non-positive loop bound");
    _jump337:;
    // Computing total size of heap memory to allocate
    int64_t _575 = 1;
    _575 *= _568;
    _575 *= _570;
    _575 *= _571;
    _575 *= sizeof(int64_t);
    _567.data = jpl_alloc(_575);
    int64_t _576 = 0; // h
    int64_t _577 = 0; // g
    int64_t _578 = 0; // f
    _jump338:; // Begin body of loop
    int64_t _579 = 0;
    _579 *= _567.d0;
    _579 += _578;
    _579 *= _567.d1;
    _579 += _577;
    _579 *= _567.d2;
    _579 += _576;
    _567.data[_579] = _578;
    _576++;
    if (_576 < _571)
    goto _jump338;
    _576 = 0;
    _577++;
    if (_577 < _570)
    goto _jump338;
    _577 = 0;
    _578++;
    if (_578 < _568)
    goto _jump338;
    // End body of loop
    int64_t _580;
    // Computing bound for f
    int64_t _581 = 462;
    if (_581 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    _580 = 0;
    int64_t _582 = 0; // f
    _jump340:; // Begin body of loop
    _580 += _566;
    _582++;
    if (_582 < _581)
    goto _jump340;
    // End body of loop
    int64_t _583 = 347;
    if (_580 >= 0)
    goto _jump341;
    fail_assertion("negative array index");
    _jump341:;
    if (_580 < _567.d0)
    goto _jump342;
    fail_assertion("index too large");
    _jump342:;
    if (_583 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (_583 < _567.d1)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (_566 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (_566 < _567.d2)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _584 = 0;
    _584 *= _567.d0;
    _584 += _580;
    _584 *= _567.d1;
    _584 += _583;
    _584 *= _567.d2;
    _584 += _566;
    int64_t _585 = _567.data[_584];
    _560 += _585;
    _566++;
    if (_566 < _565)
    goto _jump330;
    // End body of loop
    _559.d0 = _560;
    if (_560 > 0) 
    goto _jump347;
    fail_assertion("non-positive loop bound");
    _jump347:;
    // Computing bound for f
    int64_t _586;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    _586 = 0;
    int64_t _587 = 0; // e
    _jump349:; // Begin body of loop
    _586 += _587;
    _587++;
    if (_587 < _373)
    goto _jump349;
    // End body of loop
    _559.d1 = _586;
    if (_586 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for g
    double _588 = 2.0;
    double _589 = -_410;
    bool _590 = _588 != _589;
    int64_t _591;
    if (!_590)
    goto _jump351;
    _591 = _373;
    goto _jump352;
    _jump351:;
    bool _592 = false;
    int64_t _593;
    if (!_592)
    goto _jump353;
    _593 = _373;
    goto _jump354;
    _jump353:;
    int64_t _594 = 719;
    int64_t _595 = -_594;
    _593 = _595;
    _jump354:;
    _591 = _593;
    _jump352:;
    _559.d2 = _591;
    if (_591 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing total size of heap memory to allocate
    int64_t _596 = 1;
    _596 *= _560;
    _596 *= _586;
    _596 *= _591;
    _596 *= sizeof(_a1_int64_t);
    _559.data = jpl_alloc(_596);
    int64_t _597 = 0; // g
    int64_t _598 = 0; // f
    int64_t _599 = 0; // e
    _jump356:; // Begin body of loop
    bool _600 = false;
    bool _601 = !_600;
    _a1_int64_t _602;
    if (!_601)
    goto _jump357;
    _a1_int64_t _603;
    // Computing bound for h
    int64_t _604;
    // Computing bound for h
    if (_373 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    // Computing bound for i
    int64_t _605;
    // Computing bound for h
    if (_373 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing bound for i
    if (_598 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing bound for j
    if (_597 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    _605 = 0;
    int64_t _606 = 0; // j
    int64_t _607 = 0; // i
    int64_t _608 = 0; // h
    _jump362:; // Begin body of loop
    int64_t _609 = 174;
    _605 += _609;
    _606++;
    if (_606 < _597)
    goto _jump362;
    _606 = 0;
    _607++;
    if (_607 < _598)
    goto _jump362;
    _607 = 0;
    _608++;
    if (_608 < _373)
    goto _jump362;
    // End body of loop
    if (_605 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for j
    int64_t _610 = -_373;
    if (_610 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    _604 = 0;
    int64_t _611 = 0; // j
    int64_t _612 = 0; // i
    int64_t _613 = 0; // h
    _jump365:; // Begin body of loop
    _604 += _612;
    _611++;
    if (_611 < _610)
    goto _jump365;
    _611 = 0;
    _612++;
    if (_612 < _605)
    goto _jump365;
    _612 = 0;
    _613++;
    if (_613 < _373)
    goto _jump365;
    // End body of loop
    _603.d0 = _604;
    if (_604 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing total size of heap memory to allocate
    int64_t _614 = 1;
    _614 *= _604;
    _614 *= sizeof(int64_t);
    _603.data = jpl_alloc(_614);
    int64_t _615 = 0; // h
    _jump367:; // Begin body of loop
    int64_t _616;
    // Computing bound for i
    int64_t _617 = -_615;
    if (_617 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    // Computing bound for j
    int64_t _618;
    // Computing bound for i
    int64_t _619 = 118;
    if (_619 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    // Computing bound for j
    if (_599 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    _618 = 0;
    int64_t _620 = 0; // j
    int64_t _621 = 0; // i
    _jump371:; // Begin body of loop
    _618 += _620;
    _620++;
    if (_620 < _599)
    goto _jump371;
    _620 = 0;
    _621++;
    if (_621 < _619)
    goto _jump371;
    // End body of loop
    if (_618 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    // Computing bound for k
    if (_599 >= 0)
    goto _jump373;
    fail_assertion("negative array index");
    _jump373:;
    if (_599 < _60.d0)
    goto _jump374;
    fail_assertion("index too large");
    _jump374:;
    if (_373 >= 0)
    goto _jump375;
    fail_assertion("negative array index");
    _jump375:;
    if (_373 < _60.d1)
    goto _jump376;
    fail_assertion("index too large");
    _jump376:;
    int64_t _622 = 0;
    _622 *= _60.d0;
    _622 += _599;
    _622 *= _60.d1;
    _622 += _373;
    int64_t _623 = _60.data[_622];
    if (_623 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    _616 = 0;
    int64_t _624 = 0; // k
    int64_t _625 = 0; // j
    int64_t _626 = 0; // i
    _jump378:; // Begin body of loop
    _616 += _599;
    _624++;
    if (_624 < _623)
    goto _jump378;
    _624 = 0;
    _625++;
    if (_625 < _618)
    goto _jump378;
    _625 = 0;
    _626++;
    if (_626 < _617)
    goto _jump378;
    // End body of loop
    int64_t _627 = 0;
    _627 *= _603.d0;
    _627 += _615;
    _603.data[_627] = _616;
    _615++;
    if (_615 < _604)
    goto _jump367;
    // End body of loop
    _602 = _603;
    goto _jump379;
    _jump357:;
    bool _628 = false;
    _a1_int64_t _629;
    if (!_628)
    goto _jump380;
    int64_t _630 = _599 + _373;
    _a1_int64_t _631;
    _631.d0 = 2;
    _631.data = jpl_alloc(sizeof(int64_t) * 2);
    _631.data[0] = _630;
    _631.data[1] = _597;
    _629 = _631;
    goto _jump381;
    _jump380:;
    bool _632 = _373 > _373;
    _a1_int64_t _633;
    if (!_632)
    goto _jump382;
    int64_t _634 = 995;
    _a1_int64_t _635;
    _635.d0 = 2;
    _635.data = jpl_alloc(sizeof(int64_t) * 2);
    _635.data[0] = _373;
    _635.data[1] = _634;
    _633 = _635;
    goto _jump383;
    _jump382:;
    _a1_int64_t _636;
    // Computing bound for h
    _636.d0 = _598;
    if (_598 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    // Computing total size of heap memory to allocate
    int64_t _637 = 1;
    _637 *= _598;
    _637 *= sizeof(int64_t);
    _636.data = jpl_alloc(_637);
    int64_t _638 = 0; // h
    _jump385:; // Begin body of loop
    int64_t _639 = 0;
    _639 *= _636.d0;
    _639 += _638;
    _636.data[_639] = _597;
    _638++;
    if (_638 < _598)
    goto _jump385;
    // End body of loop
    _633 = _636;
    _jump383:;
    _629 = _633;
    _jump381:;
    _602 = _629;
    _jump379:;
    int64_t _640 = 0;
    _640 *= _559.d0;
    _640 += _599;
    _640 *= _559.d1;
    _640 += _598;
    _640 *= _559.d2;
    _640 += _597;
    _559.data[_640] = _602;
    _597++;
    if (_597 < _591)
    goto _jump356;
    _597 = 0;
    _598++;
    if (_598 < _586)
    goto _jump356;
    _598 = 0;
    _599++;
    if (_599 < _560)
    goto _jump356;
    // End body of loop
    _483 = _559;
    _jump324:;
    _466 = _483;
    goto _jump386;
    _jump275:;
    int64_t _641 = 714;
    int64_t _642 = 689;
    bool _643 = _641 >= _642;
    bool _644 = !_643;
    bool _645 = !_644;
    bool _646 = !_645;
    bool _647;
    if (!_646)
    goto _jump387;
    bool _649 = true;
    bool _648 = _649;
    if (0 == _649)
    goto _jump388;
    double _650 = 47.0;
    double _651 = -_410;
    double _652 = -_651;
    bool _653 = _650 > _652;
    _648 = _653;
    _jump388:;
    _647 = _648;
    goto _jump389;
    _jump387:;
    double _654 = 68.0;
    double _655 = 54.0;
    bool _656 = _654 >= _655;
    _647 = _656;
    _jump389:;
    _a3__a1_int64_t _657;
    if (!_647)
    goto _jump390;
    _a3__a1_int64_t _658;
    // Computing bound for e
    int64_t _659;
    // Computing bound for e
    _a1__a2_int64_t _660;
    // Computing bound for e
    int64_t _661 = 994;
    _660.d0 = _661;
    if (_661 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing total size of heap memory to allocate
    int64_t _662 = 1;
    _662 *= _661;
    _662 *= sizeof(_a2_int64_t);
    _660.data = jpl_alloc(_662);
    int64_t _663 = 0; // e
    _jump392:; // Begin body of loop
    int64_t _664 = 0;
    _664 *= _660.d0;
    _664 += _663;
    _660.data[_664] = _60;
    _663++;
    if (_663 < _661)
    goto _jump392;
    // End body of loop
    if (_373 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_373 < _660.d0)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    int64_t _665 = 0;
    _665 *= _660.d0;
    _665 += _373;
    _a2_int64_t _666 = _660.data[_665];
    int64_t _667 = 724;
    int64_t _668;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    _668 = 0;
    int64_t _669 = 0; // e
    _jump396:; // Begin body of loop
    int64_t _670 = 20;
    _668 += _670;
    _669++;
    if (_669 < _373)
    goto _jump396;
    // End body of loop
    if (_667 >= 0)
    goto _jump397;
    fail_assertion("negative array index");
    _jump397:;
    if (_667 < _666.d0)
    goto _jump398;
    fail_assertion("index too large");
    _jump398:;
    if (_668 >= 0)
    goto _jump399;
    fail_assertion("negative array index");
    _jump399:;
    if (_668 < _666.d1)
    goto _jump400;
    fail_assertion("index too large");
    _jump400:;
    int64_t _671 = 0;
    _671 *= _666.d0;
    _671 += _667;
    _671 *= _666.d1;
    _671 += _668;
    int64_t _672 = _666.data[_671];
    if (_672 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for f
    _a2_int64_t _673;
    // Computing bound for e
    _673.d0 = _373;
    if (_373 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    // Computing bound for f
    int64_t _674 = 803;
    int64_t _675 = -_674;
    _673.d1 = _675;
    if (_675 > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    // Computing total size of heap memory to allocate
    int64_t _676 = 1;
    _676 *= _373;
    _676 *= _675;
    _676 *= sizeof(int64_t);
    _673.data = jpl_alloc(_676);
    int64_t _677 = 0; // f
    int64_t _678 = 0; // e
    _jump404:; // Begin body of loop
    int64_t _679 = 93;
    int64_t _680 = 0;
    _680 *= _673.d0;
    _680 += _678;
    _680 *= _673.d1;
    _680 += _677;
    _673.data[_680] = _679;
    _677++;
    if (_677 < _675)
    goto _jump404;
    _677 = 0;
    _678++;
    if (_678 < _373)
    goto _jump404;
    // End body of loop
    int64_t _681 = 858;
    int64_t _682 = -_681;
    int64_t _683 = -_373;
    int64_t _684 = _373 % _683;
    if (_682 >= 0)
    goto _jump405;
    fail_assertion("negative array index");
    _jump405:;
    if (_682 < _673.d0)
    goto _jump406;
    fail_assertion("index too large");
    _jump406:;
    if (_684 >= 0)
    goto _jump407;
    fail_assertion("negative array index");
    _jump407:;
    if (_684 < _673.d1)
    goto _jump408;
    fail_assertion("index too large");
    _jump408:;
    int64_t _685 = 0;
    _685 *= _673.d0;
    _685 += _682;
    _685 *= _673.d1;
    _685 += _684;
    int64_t _686 = _673.data[_685];
    if (_686 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    // Computing bound for g
    int64_t _687 = 217;
    if (_687 > 0) 
    goto _jump410;
    fail_assertion("non-positive loop bound");
    _jump410:;
    _659 = 0;
    int64_t _688 = 0; // g
    int64_t _689 = 0; // f
    int64_t _690 = 0; // e
    _jump411:; // Begin body of loop
    int64_t _691 = 136;
    int64_t _692 = _691 / _373;
    _659 += _692;
    _688++;
    if (_688 < _687)
    goto _jump411;
    _688 = 0;
    _689++;
    if (_689 < _686)
    goto _jump411;
    _689 = 0;
    _690++;
    if (_690 < _672)
    goto _jump411;
    // End body of loop
    _658.d0 = _659;
    if (_659 > 0) 
    goto _jump412;
    fail_assertion("non-positive loop bound");
    _jump412:;
    // Computing bound for f
    int64_t _693;
    // Computing bound for e
    int64_t _694 = -_373;
    if (_694 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing bound for f
    if (_373 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    _693 = 0;
    int64_t _695 = 0; // f
    int64_t _696 = 0; // e
    _jump415:; // Begin body of loop
    int64_t _697 = 76;
    _693 += _697;
    _695++;
    if (_695 < _373)
    goto _jump415;
    _695 = 0;
    _696++;
    if (_696 < _694)
    goto _jump415;
    // End body of loop
    int64_t _698 = _693 - _373;
    int64_t _699 = -_698;
    _658.d1 = _699;
    if (_699 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for g
    if (_373 >= 0)
    goto _jump417;
    fail_assertion("negative array index");
    _jump417:;
    if (_373 < _60.d0)
    goto _jump418;
    fail_assertion("index too large");
    _jump418:;
    if (_373 >= 0)
    goto _jump419;
    fail_assertion("negative array index");
    _jump419:;
    if (_373 < _60.d1)
    goto _jump420;
    fail_assertion("index too large");
    _jump420:;
    int64_t _700 = 0;
    _700 *= _60.d0;
    _700 += _373;
    _700 *= _60.d1;
    _700 += _373;
    int64_t _701 = _60.data[_700];
    int64_t _702 = 942;
    bool _703 = _701 == _702;
    int64_t _704;
    if (!_703)
    goto _jump421;
    int64_t _705 = -_373;
    _704 = _705;
    goto _jump422;
    _jump421:;
    _704 = _373;
    _jump422:;
    bool _706 = false;
    int64_t _707;
    if (!_706)
    goto _jump423;
    int64_t _708;
    // Computing bound for e
    int64_t _709 = 135;
    if (_709 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing bound for f
    if (_373 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing bound for g
    int64_t _710 = 844;
    if (_710 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    _708 = 0;
    int64_t _711 = 0; // g
    int64_t _712 = 0; // f
    int64_t _713 = 0; // e
    _jump427:; // Begin body of loop
    _708 += _712;
    _711++;
    if (_711 < _710)
    goto _jump427;
    _711 = 0;
    _712++;
    if (_712 < _373)
    goto _jump427;
    _712 = 0;
    _713++;
    if (_713 < _709)
    goto _jump427;
    // End body of loop
    _707 = _708;
    goto _jump428;
    _jump423:;
    int64_t _714;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    // Computing bound for f
    int64_t _715 = 750;
    if (_715 > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    _714 = 0;
    int64_t _716 = 0; // f
    int64_t _717 = 0; // e
    _jump431:; // Begin body of loop
    _714 += _716;
    _716++;
    if (_716 < _715)
    goto _jump431;
    _716 = 0;
    _717++;
    if (_717 < _373)
    goto _jump431;
    // End body of loop
    _707 = _714;
    _jump428:;
    int64_t _718;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump432;
    fail_assertion("non-positive loop bound");
    _jump432:;
    _718 = 0;
    int64_t _719 = 0; // e
    _jump433:; // Begin body of loop
    _718 += _719;
    _719++;
    if (_719 < _373)
    goto _jump433;
    // End body of loop
    int64_t _720 = 399;
    int64_t _721 = _718 / _720;
    int64_t _722 = _707 / _721;
    int64_t _723 = _704 * _722;
    _658.d2 = _723;
    if (_723 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing total size of heap memory to allocate
    int64_t _724 = 1;
    _724 *= _659;
    _724 *= _699;
    _724 *= _723;
    _724 *= sizeof(_a1_int64_t);
    _658.data = jpl_alloc(_724);
    int64_t _725 = 0; // g
    int64_t _726 = 0; // f
    int64_t _727 = 0; // e
    _jump435:; // Begin body of loop
    bool _728 = false;
    bool _729 = !_728;
    bool _730 = !_729;
    _a1_int64_t _731;
    if (!_730)
    goto _jump436;
    bool _732 = false;
    _a1_int64_t _733;
    if (!_732)
    goto _jump437;
    _a1_int64_t _734;
    // Computing bound for h
    int64_t _735 = -_725;
    _734.d0 = _735;
    if (_735 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    // Computing total size of heap memory to allocate
    int64_t _736 = 1;
    _736 *= _735;
    _736 *= sizeof(int64_t);
    _734.data = jpl_alloc(_736);
    int64_t _737 = 0; // h
    _jump439:; // Begin body of loop
    int64_t _738 = 0;
    _738 *= _734.d0;
    _738 += _737;
    _734.data[_738] = _726;
    _737++;
    if (_737 < _735)
    goto _jump439;
    // End body of loop
    _733 = _734;
    goto _jump440;
    _jump437:;
    int64_t _739 = 86;
    _a1_int64_t _740;
    _740.d0 = 3;
    _740.data = jpl_alloc(sizeof(int64_t) * 3);
    _740.data[0] = _726;
    _740.data[1] = _725;
    _740.data[2] = _739;
    _733 = _740;
    _jump440:;
    _731 = _733;
    goto _jump441;
    _jump436:;
    _a1__a1_int64_t _741;
    // Computing bound for h
    _741.d0 = _726;
    if (_726 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    // Computing total size of heap memory to allocate
    int64_t _742 = 1;
    _742 *= _726;
    _742 *= sizeof(_a1_int64_t);
    _741.data = jpl_alloc(_742);
    int64_t _743 = 0; // h
    _jump443:; // Begin body of loop
    _a1_int64_t _744;
    _744.d0 = 1;
    _744.data = jpl_alloc(sizeof(int64_t) * 1);
    _744.data[0] = _725;
    int64_t _745 = 0;
    _745 *= _741.d0;
    _745 += _743;
    _741.data[_745] = _744;
    _743++;
    if (_743 < _726)
    goto _jump443;
    // End body of loop
    int64_t _746 = 483;
    if (_746 >= 0)
    goto _jump444;
    fail_assertion("negative array index");
    _jump444:;
    if (_746 < _741.d0)
    goto _jump445;
    fail_assertion("index too large");
    _jump445:;
    int64_t _747 = 0;
    _747 *= _741.d0;
    _747 += _746;
    _a1_int64_t _748 = _741.data[_747];
    _731 = _748;
    _jump441:;
    int64_t _749 = 0;
    _749 *= _658.d0;
    _749 += _727;
    _749 *= _658.d1;
    _749 += _726;
    _749 *= _658.d2;
    _749 += _725;
    _658.data[_749] = _731;
    _725++;
    if (_725 < _723)
    goto _jump435;
    _725 = 0;
    _726++;
    if (_726 < _699)
    goto _jump435;
    _726 = 0;
    _727++;
    if (_727 < _659)
    goto _jump435;
    // End body of loop
    _657 = _658;
    goto _jump446;
    _jump390:;
    _a3__a1_int64_t _750;
    // Computing bound for e
    int64_t _751 = 275;
    _750.d0 = _751;
    if (_751 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    // Computing bound for f
    bool _752 = false;
    int64_t _753;
    if (!_752)
    goto _jump448;
    int64_t _754;
    // Computing bound for e
    if (_373 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for f
    if (_373 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    // Computing bound for g
    if (_373 > 0) 
    goto _jump451;
    fail_assertion("non-positive loop bound");
    _jump451:;
    _754 = 0;
    int64_t _755 = 0; // g
    int64_t _756 = 0; // f
    int64_t _757 = 0; // e
    _jump452:; // Begin body of loop
    _754 += _757;
    _755++;
    if (_755 < _373)
    goto _jump452;
    _755 = 0;
    _756++;
    if (_756 < _373)
    goto _jump452;
    _756 = 0;
    _757++;
    if (_757 < _373)
    goto _jump452;
    // End body of loop
    int64_t _758 = -_754;
    int64_t _759 = -_758;
    _753 = _759;
    goto _jump453;
    _jump448:;
    int64_t _760 = 658;
    _753 = _760;
    _jump453:;
    _750.d1 = _753;
    if (_753 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing bound for g
    int64_t _761 = 51;
    _a1_int64_t _762;
    _762.d0 = 2;
    _762.data = jpl_alloc(sizeof(int64_t) * 2);
    _762.data[0] = _761;
    _762.data[1] = _373;
    int64_t _763;
    // Computing bound for e
    bool _764 = false;
    int64_t _765;
    if (!_764)
    goto _jump455;
    _765 = _373;
    goto _jump456;
    _jump455:;
    int64_t _766 = 6;
    _765 = _766;
    _jump456:;
    if (_765 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    // Computing bound for f
    int64_t _767 = 662;
    int64_t _768 = -_767;
    if (_768 > 0) 
    goto _jump458;
    fail_assertion("non-positive loop bound");
    _jump458:;
    // Computing bound for g
    int64_t _769 = 16;
    if (_769 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    _763 = 0;
    int64_t _770 = 0; // g
    int64_t _771 = 0; // f
    int64_t _772 = 0; // e
    _jump460:; // Begin body of loop
    int64_t _773;
    // Computing bound for h
    if (_770 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for i
    int64_t _774 = 279;
    if (_774 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing bound for j
    if (_770 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    _773 = 0;
    int64_t _775 = 0; // j
    int64_t _776 = 0; // i
    int64_t _777 = 0; // h
    _jump464:; // Begin body of loop
    _773 += _775;
    _775++;
    if (_775 < _770)
    goto _jump464;
    _775 = 0;
    _776++;
    if (_776 < _774)
    goto _jump464;
    _776 = 0;
    _777++;
    if (_777 < _770)
    goto _jump464;
    // End body of loop
    _763 += _773;
    _770++;
    if (_770 < _769)
    goto _jump460;
    _770 = 0;
    _771++;
    if (_771 < _768)
    goto _jump460;
    _771 = 0;
    _772++;
    if (_772 < _765)
    goto _jump460;
    // End body of loop
    if (_763 >= 0)
    goto _jump465;
    fail_assertion("negative array index");
    _jump465:;
    if (_763 < _762.d0)
    goto _jump466;
    fail_assertion("index too large");
    _jump466:;
    int64_t _778 = 0;
    _778 *= _762.d0;
    _778 += _763;
    int64_t _779 = _762.data[_778];
    int64_t _780 = -_779;
    _750.d2 = _780;
    if (_780 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing total size of heap memory to allocate
    int64_t _781 = 1;
    _781 *= _751;
    _781 *= _753;
    _781 *= _780;
    _781 *= sizeof(_a1_int64_t);
    _750.data = jpl_alloc(_781);
    int64_t _782 = 0; // g
    int64_t _783 = 0; // f
    int64_t _784 = 0; // e
    _jump468:; // Begin body of loop
    _a1_int64_t _785;
    // Computing bound for h
    bool _787 = true;
    bool _788;
    if (!_787)
    goto _jump469;
    bool _789 = false;
    _788 = _789;
    goto _jump470;
    _jump469:;
    bool _790 = true;
    _788 = _790;
    _jump470:;
    bool _786 = _788;
    if (0 == _788)
    goto _jump471;
    double _791 = 7.0;
    bool _792 = _410 >= _791;
    _786 = _792;
    _jump471:;
    int64_t _793;
    if (!_786)
    goto _jump472;
    int64_t _794;
    // Computing bound for h
    if (_782 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    _794 = 0;
    int64_t _795 = 0; // h
    _jump474:; // Begin body of loop
    _794 += _795;
    _795++;
    if (_795 < _782)
    goto _jump474;
    // End body of loop
    _793 = _794;
    goto _jump475;
    _jump472:;
    int64_t _796 = -_782;
    _793 = _796;
    _jump475:;
    _785.d0 = _793;
    if (_793 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing total size of heap memory to allocate
    int64_t _797 = 1;
    _797 *= _793;
    _797 *= sizeof(int64_t);
    _785.data = jpl_alloc(_797);
    int64_t _798 = 0; // h
    _jump477:; // Begin body of loop
    int64_t _799;
    // Computing bound for i
    if (_783 >= 0)
    goto _jump478;
    fail_assertion("negative array index");
    _jump478:;
    if (_783 < _60.d0)
    goto _jump479;
    fail_assertion("index too large");
    _jump479:;
    if (_784 >= 0)
    goto _jump480;
    fail_assertion("negative array index");
    _jump480:;
    if (_784 < _60.d1)
    goto _jump481;
    fail_assertion("index too large");
    _jump481:;
    int64_t _800 = 0;
    _800 *= _60.d0;
    _800 += _783;
    _800 *= _60.d1;
    _800 += _784;
    int64_t _801 = _60.data[_800];
    if (_801 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing bound for j
    int64_t _802;
    // Computing bound for i
    int64_t _803 = _373 / _798;
    if (_803 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    // Computing bound for j
    if (_784 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    _802 = 0;
    int64_t _804 = 0; // j
    int64_t _805 = 0; // i
    _jump485:; // Begin body of loop
    int64_t _806 = 451;
    _802 += _806;
    _804++;
    if (_804 < _784)
    goto _jump485;
    _804 = 0;
    _805++;
    if (_805 < _803)
    goto _jump485;
    // End body of loop
    if (_802 > 0) 
    goto _jump486;
    fail_assertion("non-positive loop bound");
    _jump486:;
    _799 = 0;
    int64_t _807 = 0; // j
    int64_t _808 = 0; // i
    _jump487:; // Begin body of loop
    _799 += _784;
    _807++;
    if (_807 < _802)
    goto _jump487;
    _807 = 0;
    _808++;
    if (_808 < _801)
    goto _jump487;
    // End body of loop
    int64_t _809 = 0;
    _809 *= _785.d0;
    _809 += _798;
    _785.data[_809] = _799;
    _798++;
    if (_798 < _793)
    goto _jump477;
    // End body of loop
    int64_t _810 = 0;
    _810 *= _750.d0;
    _810 += _784;
    _810 *= _750.d1;
    _810 += _783;
    _810 *= _750.d2;
    _810 += _782;
    _750.data[_810] = _785;
    _782++;
    if (_782 < _780)
    goto _jump468;
    _782 = 0;
    _783++;
    if (_783 < _753)
    goto _jump468;
    _783 = 0;
    _784++;
    if (_784 < _751)
    goto _jump468;
    // End body of loop
    _657 = _750;
    _jump446:;
    _466 = _657;
    _jump386:;
    double _811 = 51.0;
    double _812 = fmod(_811, _410);
    bool _813 = _410 >= _812;
    bool _814 = !_813;
    _a2_bool _815;
    // Computing bound for i
    _a2_int64_t _816;
    // Computing bound for i
    int64_t _817 = 153;
    _816.d0 = _817;
    if (_817 > 0) 
    goto _jump488;
    fail_assertion("non-positive loop bound");
    _jump488:;
    // Computing bound for j
    _816.d1 = _373;
    if (_373 > 0) 
    goto _jump489;
    fail_assertion("non-positive loop bound");
    _jump489:;
    // Computing total size of heap memory to allocate
    int64_t _818 = 1;
    _818 *= _817;
    _818 *= _373;
    _818 *= sizeof(int64_t);
    _816.data = jpl_alloc(_818);
    int64_t _819 = 0; // j
    int64_t _820 = 0; // i
    _jump490:; // Begin body of loop
    int64_t _821 = 0;
    _821 *= _816.d0;
    _821 += _820;
    _821 *= _816.d1;
    _821 += _819;
    _816.data[_821] = _373;
    _819++;
    if (_819 < _373)
    goto _jump490;
    _819 = 0;
    _820++;
    if (_820 < _817)
    goto _jump490;
    // End body of loop
    int64_t _822 = 261;
    int64_t _823 = _822 * _373;
    if (_466.d1 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_466.d1 < _816.d0)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_823 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_823 < _816.d1)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    int64_t _824 = 0;
    _824 *= _816.d0;
    _824 += _466.d1;
    _824 *= _816.d1;
    _824 += _823;
    int64_t _825 = _816.data[_824];
    _815.d0 = _825;
    if (_825 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing bound for j
    int64_t _826;
    // Computing bound for i
    if (_466.d2 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    _826 = 0;
    int64_t _827 = 0; // i
    _jump497:; // Begin body of loop
    _826 += _827;
    _827++;
    if (_827 < _466.d2)
    goto _jump497;
    // End body of loop
    _815.d1 = _826;
    if (_826 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing total size of heap memory to allocate
    int64_t _828 = 1;
    _828 *= _825;
    _828 *= _826;
    _828 *= sizeof(bool);
    _815.data = jpl_alloc(_828);
    int64_t _829 = 0; // j
    int64_t _830 = 0; // i
    _jump499:; // Begin body of loop
    bool _831 = true;
    bool _832 = !_831;
    int64_t _833 = 0;
    _833 *= _815.d0;
    _833 += _830;
    _833 *= _815.d1;
    _833 += _829;
    _815.data[_833] = _832;
    _829++;
    if (_829 < _826)
    goto _jump499;
    _829 = 0;
    _830++;
    if (_830 < _825)
    goto _jump499;
    // End body of loop
    int64_t _834 = 424;
    bool _835 = _466.d1 != _834;
    bool _836;
    if (!_835)
    goto _jump500;
    bool _837 = true;
    _836 = _837;
    goto _jump501;
    _jump500:;
    bool _838 = false;
    _836 = _838;
    _jump501:;
    int64_t _839;
    if (!_836)
    goto _jump502;
    _a2_int64_t _840;
    // Computing bound for i
    _840.d0 = _466.d1;
    if (_466.d1 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing bound for j
    _840.d1 = _466.d2;
    if (_466.d2 > 0) 
    goto _jump504;
    fail_assertion("non-positive loop bound");
    _jump504:;
    // Computing total size of heap memory to allocate
    int64_t _841 = 1;
    _841 *= _466.d1;
    _841 *= _466.d2;
    _841 *= sizeof(int64_t);
    _840.data = jpl_alloc(_841);
    int64_t _842 = 0; // j
    int64_t _843 = 0; // i
    _jump505:; // Begin body of loop
    int64_t _844 = 0;
    _844 *= _840.d0;
    _844 += _843;
    _844 *= _840.d1;
    _844 += _842;
    _840.data[_844] = _466.d2;
    _842++;
    if (_842 < _466.d2)
    goto _jump505;
    _842 = 0;
    _843++;
    if (_843 < _466.d1)
    goto _jump505;
    // End body of loop
    if (_466.d0 >= 0)
    goto _jump506;
    fail_assertion("negative array index");
    _jump506:;
    if (_466.d0 < _840.d0)
    goto _jump507;
    fail_assertion("index too large");
    _jump507:;
    if (_466.d2 >= 0)
    goto _jump508;
    fail_assertion("negative array index");
    _jump508:;
    if (_466.d2 < _840.d1)
    goto _jump509;
    fail_assertion("index too large");
    _jump509:;
    int64_t _845 = 0;
    _845 *= _840.d0;
    _845 += _466.d0;
    _845 *= _840.d1;
    _845 += _466.d2;
    int64_t _846 = _840.data[_845];
    _839 = _846;
    goto _jump510;
    _jump502:;
    int64_t _847;
    // Computing bound for i
    int64_t _848 = 537;
    if (_848 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    // Computing bound for j
    if (_466.d0 > 0) 
    goto _jump512;
    fail_assertion("non-positive loop bound");
    _jump512:;
    _847 = 0;
    int64_t _849 = 0; // j
    int64_t _850 = 0; // i
    _jump513:; // Begin body of loop
    _847 += _849;
    _849++;
    if (_849 < _466.d0)
    goto _jump513;
    _849 = 0;
    _850++;
    if (_850 < _848)
    goto _jump513;
    // End body of loop
    int64_t _851 = -_847;
    _839 = _851;
    _jump510:;
    if (_839 >= 0)
    goto _jump514;
    fail_assertion("negative array index");
    _jump514:;
    if (_839 < _815.d0)
    goto _jump515;
    fail_assertion("index too large");
    _jump515:;
    if (_466.d2 >= 0)
    goto _jump516;
    fail_assertion("negative array index");
    _jump516:;
    if (_466.d2 < _815.d1)
    goto _jump517;
    fail_assertion("index too large");
    _jump517:;
    int64_t _852 = 0;
    _852 *= _815.d0;
    _852 += _839;
    _852 *= _815.d1;
    _852 += _466.d2;
    bool _853 = _815.data[_852];
    bool _854 = _814 == _853;
    double _855;
    if (!_854)
    goto _jump518;
    _a2_bool _856;
    // Computing bound for i
    int64_t _857 = 881;
    _856.d0 = _857;
    if (_857 > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    // Computing bound for j
    _856.d1 = _466.d0;
    if (_466.d0 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing total size of heap memory to allocate
    int64_t _858 = 1;
    _858 *= _857;
    _858 *= _466.d0;
    _858 *= sizeof(bool);
    _856.data = jpl_alloc(_858);
    int64_t _859 = 0; // j
    int64_t _860 = 0; // i
    _jump521:; // Begin body of loop
    bool _861 = true;
    int64_t _862 = 0;
    _862 *= _856.d0;
    _862 += _860;
    _862 *= _856.d1;
    _862 += _859;
    _856.data[_862] = _861;
    _859++;
    if (_859 < _466.d0)
    goto _jump521;
    _859 = 0;
    _860++;
    if (_860 < _857)
    goto _jump521;
    // End body of loop
    int64_t _863;
    // Computing bound for i
    if (_373 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for j
    if (_466.d0 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing bound for k
    if (_466.d0 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    _863 = 0;
    int64_t _864 = 0; // k
    int64_t _865 = 0; // j
    int64_t _866 = 0; // i
    _jump525:; // Begin body of loop
    _863 += _466.d2;
    _864++;
    if (_864 < _466.d0)
    goto _jump525;
    _864 = 0;
    _865++;
    if (_865 < _466.d0)
    goto _jump525;
    _865 = 0;
    _866++;
    if (_866 < _373)
    goto _jump525;
    // End body of loop
    if (_466.d0 >= 0)
    goto _jump526;
    fail_assertion("negative array index");
    _jump526:;
    if (_466.d0 < _856.d0)
    goto _jump527;
    fail_assertion("index too large");
    _jump527:;
    if (_863 >= 0)
    goto _jump528;
    fail_assertion("negative array index");
    _jump528:;
    if (_863 < _856.d1)
    goto _jump529;
    fail_assertion("index too large");
    _jump529:;
    int64_t _867 = 0;
    _867 *= _856.d0;
    _867 += _466.d0;
    _867 *= _856.d1;
    _867 += _863;
    bool _868 = _856.data[_867];
    bool _869 = !_868;
    double _870;
    if (!_869)
    goto _jump530;
    double _871 = 83.0;
    double _872 = -_871;
    _870 = _872;
    goto _jump531;
    _jump530:;
    double _873 = -_410;
    double _874 = -_410;
    double _875 = 78.0;
    double _876 = _410 * _875;
    rgba _877 = { _410, _873, _874, _876 };
    double _878 = _877.r;
    _870 = _878;
    _jump531:;
    double _879 = -_870;
    _855 = _879;
    goto _jump532;
    _jump518:;
    _855 = _410;
    _jump532:;
    double _880 = _410 - _855;
    _a3_double _881;
    // Computing bound for j
    int64_t _882 = 315;
    int64_t _883 = -_882;
    int64_t _884 = -_466.d0;
    int64_t _885 = _883 - _884;
    _881.d0 = _885;
    if (_885 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for k
    _881.d1 = _373;
    if (_373 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing bound for l
    _881.d2 = _466.d1;
    if (_466.d1 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    // Computing total size of heap memory to allocate
    int64_t _886 = 1;
    _886 *= _885;
    _886 *= _373;
    _886 *= _466.d1;
    _886 *= sizeof(double);
    _881.data = jpl_alloc(_886);
    int64_t _887 = 0; // l
    int64_t _888 = 0; // k
    int64_t _889 = 0; // j
    _jump536:; // Begin body of loop
    int64_t _890 = 0;
    _890 *= _881.d0;
    _890 += _889;
    _890 *= _881.d1;
    _890 += _888;
    _890 *= _881.d2;
    _890 += _887;
    _881.data[_890] = _410;
    _887++;
    if (_887 < _466.d1)
    goto _jump536;
    _887 = 0;
    _888++;
    if (_888 < _373)
    goto _jump536;
    _888 = 0;
    _889++;
    if (_889 < _885)
    goto _jump536;
    // End body of loop
    double _891 = get_time();
    int64_t _892 = _466.d2 / _881.d0;
    int64_t _893 = -_881.d0;
    int64_t _894 = _892 - _893;
    bool _895 = _894 < _466.d0;
    if (0 != _895)
    goto _jump793;
    fail_assertion("o");
    _jump793:;
    double _896 = get_time();
    print_time(_896 - _891);
    double _897 = 65.0;
    double _898 = get_time();
    bool _899 = true;
    double _900;
    if (!_899)
    goto _jump1089;
    double _901;
    // Computing bound for r
    if (_881.d2 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for s
    if (_373 > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    _901 = 0;
    int64_t _902 = 0; // s
    int64_t _903 = 0; // r
    _jump1092:; // Begin body of loop
    _901 += _410;
    _902++;
    if (_902 < _373)
    goto _jump1092;
    _902 = 0;
    _903++;
    if (_903 < _881.d2)
    goto _jump1092;
    // End body of loop
    _900 = _901;
    goto _jump1093;
    _jump1089:;
    _900 = _897;
    _jump1093:;
    double _904 = 96.0;
    bool _905 = _900 != _904;
    int64_t _906;
    if (!_905)
    goto _jump1094;
    _906 = _466.d2;
    goto _jump1095;
    _jump1094:;
    _906 = _466.d1;
    _jump1095:;
    _a1_int64_t _907;
    _907.d0 = 1;
    _907.data = jpl_alloc(sizeof(int64_t) * 1);
    _907.data[0] = _906;
    double _908 = get_time();
    print_time(_908 - _898);
    double _909 = 72.0;
    double _910 = -_897;
    rgba _911 = { _897, _909, _410, _910 };
    double _912 = _911.r;
    bool _913 = false;
    double _914;
    if (!_913)
    goto _jump1096;
    _914 = _410;
    goto _jump1097;
    _jump1096:;
    _914 = _410;
    _jump1097:;
    double _915 = 8.0;
    double _916 = _914 + _915;
    bool _917 = _912 < _916;
    double _919 = 90.0;
    bool _920 = _919 != _897;
    bool _918 = _920;
    if (0 == _920)
    goto _jump1098;
    bool _922 = false;
    bool _923 = !_922;
    bool _921 = _923;
    if (0 == _923)
    goto _jump1099;
    int64_t _924 = 22;
    bool _925 = _881.d2 >= _924;
    _921 = _925;
    _jump1099:;
    _918 = _921;
    _jump1098:;
    bool _926;
    if (!_918)
    goto _jump1100;
    bool _927 = true;
    _926 = _927;
    goto _jump1101;
    _jump1100:;
    bool _928 = _466.d1 < _881.d2;
    bool _929;
    if (!_928)
    goto _jump1102;
    bool _930 = _881.d2 >= _466.d1;
    bool _931 = !_930;
    _929 = _931;
    goto _jump1103;
    _jump1102:;
    _a1_bool _932;
    // Computing bound for t
    _932.d0 = _466.d1;
    if (_466.d1 > 0) 
    goto _jump1104;
    fail_assertion("non-positive loop bound");
    _jump1104:;
    // Computing total size of heap memory to allocate
    int64_t _933 = 1;
    _933 *= _466.d1;
    _933 *= sizeof(bool);
    _932.data = jpl_alloc(_933);
    int64_t _934 = 0; // t
    _jump1105:; // Begin body of loop
    bool _935 = true;
    int64_t _936 = 0;
    _936 *= _932.d0;
    _936 += _934;
    _932.data[_936] = _935;
    _934++;
    if (_934 < _466.d1)
    goto _jump1105;
    // End body of loop
    int64_t _937 = _466.d0 * _373;
    if (_937 >= 0)
    goto _jump1106;
    fail_assertion("negative array index");
    _jump1106:;
    if (_937 < _932.d0)
    goto _jump1107;
    fail_assertion("index too large");
    _jump1107:;
    int64_t _938 = 0;
    _938 *= _932.d0;
    _938 += _937;
    bool _939 = _932.data[_938];
    _929 = _939;
    _jump1103:;
    _926 = _929;
    _jump1101:;
    void_t _940;
    if (!_926)
    goto _jump1108;
    _a3_void_t _941;
    // Computing bound for t
    bool _942 = true;
    int64_t _943;
    if (!_942)
    goto _jump1109;
    _943 = _881.d2;
    goto _jump1110;
    _jump1109:;
    if (_466.d2 >= 0)
    goto _jump1111;
    fail_assertion("negative array index");
    _jump1111:;
    if (_466.d2 < _60.d0)
    goto _jump1112;
    fail_assertion("index too large");
    _jump1112:;
    if (_373 >= 0)
    goto _jump1113;
    fail_assertion("negative array index");
    _jump1113:;
    if (_373 < _60.d1)
    goto _jump1114;
    fail_assertion("index too large");
    _jump1114:;
    int64_t _944 = 0;
    _944 *= _60.d0;
    _944 += _466.d2;
    _944 *= _60.d1;
    _944 += _373;
    int64_t _945 = _60.data[_944];
    _943 = _945;
    _jump1110:;
    _941.d0 = _943;
    if (_943 > 0) 
    goto _jump1115;
    fail_assertion("non-positive loop bound");
    _jump1115:;
    // Computing bound for u
    _941.d1 = _466.d1;
    if (_466.d1 > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for v
    _941.d2 = _373;
    if (_373 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing total size of heap memory to allocate
    int64_t _946 = 1;
    _946 *= _943;
    _946 *= _466.d1;
    _946 *= _373;
    _946 *= sizeof(void_t);
    _941.data = jpl_alloc(_946);
    int64_t _947 = 0; // v
    int64_t _948 = 0; // u
    int64_t _949 = 0; // t
    _jump1118:; // Begin body of loop
    _a1_bool _950;
    // Computing bound for w
    int64_t _951 = 762;
    _950.d0 = _951;
    if (_951 > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing total size of heap memory to allocate
    int64_t _952 = 1;
    _952 *= _951;
    _952 *= sizeof(bool);
    _950.data = jpl_alloc(_952);
    int64_t _953 = 0; // w
    _jump1120:; // Begin body of loop
    bool _954 = false;
    int64_t _955 = 0;
    _955 *= _950.d0;
    _955 += _953;
    _950.data[_955] = _954;
    _953++;
    if (_953 < _951)
    goto _jump1120;
    // End body of loop
    double _956 = 33.0;
    double _957 = 14.0;
    rgba _958 = { _956, _410, _897, _957 };
    void_t _959 = n(_897, _950, _958);
    int64_t _960 = 0;
    _960 *= _941.d0;
    _960 += _949;
    _960 *= _941.d1;
    _960 += _948;
    _960 *= _941.d2;
    _960 += _947;
    _941.data[_960] = _959;
    _947++;
    if (_947 < _373)
    goto _jump1118;
    _947 = 0;
    _948++;
    if (_948 < _466.d1)
    goto _jump1118;
    _948 = 0;
    _949++;
    if (_949 < _943)
    goto _jump1118;
    // End body of loop
    if (_907.d0 >= 0)
    goto _jump1121;
    fail_assertion("negative array index");
    _jump1121:;
    if (_907.d0 < _941.d0)
    goto _jump1122;
    fail_assertion("index too large");
    _jump1122:;
    if (_881.d2 >= 0)
    goto _jump1123;
    fail_assertion("negative array index");
    _jump1123:;
    if (_881.d2 < _941.d1)
    goto _jump1124;
    fail_assertion("index too large");
    _jump1124:;
    if (_466.d0 >= 0)
    goto _jump1125;
    fail_assertion("negative array index");
    _jump1125:;
    if (_466.d0 < _941.d2)
    goto _jump1126;
    fail_assertion("index too large");
    _jump1126:;
    int64_t _961 = 0;
    _961 *= _941.d0;
    _961 += _907.d0;
    _961 *= _941.d1;
    _961 += _881.d2;
    _961 *= _941.d2;
    _961 += _466.d0;
    void_t _962 = _941.data[_961];
    _940 = _962;
    goto _jump1127;
    _jump1108:;
    bool _963 = true;
    bool _964;
    if (!_963)
    goto _jump1128;
    double _965;
    // Computing bound for t
    if (_881.d2 > 0) 
    goto _jump1129;
    fail_assertion("non-positive loop bound");
    _jump1129:;
    // Computing bound for u
    if (_881.d0 > 0) 
    goto _jump1130;
    fail_assertion("non-positive loop bound");
    _jump1130:;
    _965 = 0;
    int64_t _966 = 0; // u
    int64_t _967 = 0; // t
    _jump1131:; // Begin body of loop
    _965 += _897;
    _966++;
    if (_966 < _881.d0)
    goto _jump1131;
    _966 = 0;
    _967++;
    if (_967 < _881.d2)
    goto _jump1131;
    // End body of loop
    double _968 = 72.0;
    bool _969 = _965 > _968;
    _964 = _969;
    goto _jump1132;
    _jump1128:;
    bool _970 = false;
    bool _971 = _466.d1 >= _466.d1;
    bool _972 = _970 != _971;
    _964 = _972;
    _jump1132:;
    void_t _973;
    if (!_964)
    goto _jump1133;
    bool _974 = _466.d1 != _373;
    _a1_bool _975;
    _975.d0 = 1;
    _975.data = jpl_alloc(sizeof(bool) * 1);
    _975.data[0] = _974;
    double _976;
    // Computing bound for t
    if (_881.d2 > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    _976 = 0;
    int64_t _977 = 0; // t
    _jump1135:; // Begin body of loop
    double _978 = 34.0;
    _976 += _978;
    _977++;
    if (_977 < _881.d2)
    goto _jump1135;
    // End body of loop
    double _979 = -_410;
    double _980;
    // Computing bound for t
    if (_373 > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    _980 = 0;
    int64_t _981 = 0; // t
    _jump1137:; // Begin body of loop
    _980 += _410;
    _981++;
    if (_981 < _373)
    goto _jump1137;
    // End body of loop
    rgba _982 = { _976, _979, _980, _410 };
    void_t _983 = n(_410, _975, _982);
    _973 = _983;
    goto _jump1138;
    _jump1133:;
    double _984 = 49.0;
    double _985 = 1.0;
    bool _986 = _897 == _985;
    bool _987 = true;
    bool _988 = !_987;
    _a1_bool _989;
    _989.d0 = 2;
    _989.data = jpl_alloc(sizeof(bool) * 2);
    _989.data[0] = _986;
    _989.data[1] = _988;
    bool _990 = false;
    double _991;
    if (!_990)
    goto _jump1139;
    _991 = _880;
    goto _jump1140;
    _jump1139:;
    _991 = _897;
    _jump1140:;
    double _992 = 31.0;
    rgba _993 = { _991, _992, _897, _897 };
    void_t _994 = n(_984, _989, _993);
    _973 = _994;
    _jump1138:;
    _940 = _973;
    _jump1127:;
    _a2_bool _995;
    // Computing bound for t
    _995.d0 = _881.d1;
    if (_881.d1 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    // Computing bound for u
    int64_t _996;
    // Computing bound for t
    if (_881.d1 > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    _996 = 0;
    int64_t _997 = 0; // t
    _jump1143:; // Begin body of loop
    _996 += _881.d1;
    _997++;
    if (_997 < _881.d1)
    goto _jump1143;
    // End body of loop
    _995.d1 = _996;
    if (_996 > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    // Computing total size of heap memory to allocate
    int64_t _998 = 1;
    _998 *= _881.d1;
    _998 *= _996;
    _998 *= sizeof(bool);
    _995.data = jpl_alloc(_998);
    int64_t _999 = 0; // u
    int64_t _1000 = 0; // t
    _jump1145:; // Begin body of loop
    bool _1001 = _466.d2 <= _1000;
    bool _1002;
    if (!_1001)
    goto _jump1146;
    bool _1003 = _881.d1 == _881.d1;
    _1002 = _1003;
    goto _jump1147;
    _jump1146:;
    bool _1004 = false;
    _1002 = _1004;
    _jump1147:;
    if (_466.d1 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (_466.d1 < _60.d0)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    if (_907.d0 >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (_907.d0 < _60.d1)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _1005 = 0;
    _1005 *= _60.d0;
    _1005 += _466.d1;
    _1005 *= _60.d1;
    _1005 += _907.d0;
    int64_t _1006 = _60.data[_1005];
    int64_t _1007;
    // Computing bound for v
    int64_t _1008 = 673;
    if (_1008 > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    _1007 = 0;
    int64_t _1009 = 0; // v
    _jump1153:; // Begin body of loop
    _1007 += _907.d0;
    _1009++;
    if (_1009 < _1008)
    goto _jump1153;
    // End body of loop
    bool _1010 = _1006 == _1007;
    bool _1011 = _1002 == _1010;
    int64_t _1012 = 0;
    _1012 *= _995.d0;
    _1012 += _1000;
    _1012 *= _995.d1;
    _1012 += _999;
    _995.data[_1012] = _1011;
    _999++;
    if (_999 < _996)
    goto _jump1145;
    _999 = 0;
    _1000++;
    if (_1000 < _881.d1)
    goto _jump1145;
    // End body of loop
    if (_881.d0 >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (_881.d0 < _995.d0)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    if (_907.d0 >= 0)
    goto _jump1156;
    fail_assertion("negative array index");
    _jump1156:;
    if (_907.d0 < _995.d1)
    goto _jump1157;
    fail_assertion("index too large");
    _jump1157:;
    int64_t _1013 = 0;
    _1013 *= _995.d0;
    _1013 += _881.d0;
    _1013 *= _995.d1;
    _1013 += _907.d0;
    bool _1014 = _995.data[_1013];
    a _1015 = { _917, _940, _1014 };
    bool _1016 = _1015.a;
    _a2__a2_int64_t _1017;
    // Computing bound for u
    int64_t _1018 = _373 * _373;
    _1017.d0 = _1018;
    if (_1018 > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    // Computing bound for v
    int64_t _1019 = _881.d0 - _881.d0;
    _1017.d1 = _1019;
    if (_1019 > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    // Computing total size of heap memory to allocate
    int64_t _1020 = 1;
    _1020 *= _1018;
    _1020 *= _1019;
    _1020 *= sizeof(_a2_int64_t);
    _1017.data = jpl_alloc(_1020);
    int64_t _1021 = 0; // v
    int64_t _1022 = 0; // u
    _jump1160:; // Begin body of loop
    _a1__a2_int64_t _1023;
    if (!_1016)
    goto _jump1161;
    _a1__a2_int64_t _1024;
    _1024.d0 = 3;
    _1024.data = jpl_alloc(sizeof(_a2_int64_t) * 3);
    _1024.data[0] = _60;
    _1024.data[1] = _60;
    _1024.data[2] = _60;
    _1023 = _1024;
    goto _jump1162;
    _jump1161:;
    _a1__a2_int64_t _1025;
    _1025.d0 = 1;
    _1025.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _1025.data[0] = _60;
    _1023 = _1025;
    _jump1162:;
    bool _1026 = !_1016;
    int64_t _1027;
    if (!_1026)
    goto _jump1163;
    _1027 = _373;
    goto _jump1164;
    _jump1163:;
    _1027 = _1022;
    _jump1164:;
    if (_1027 >= 0)
    goto _jump1165;
    fail_assertion("negative array index");
    _jump1165:;
    if (_1027 < _1023.d0)
    goto _jump1166;
    fail_assertion("index too large");
    _jump1166:;
    int64_t _1028 = 0;
    _1028 *= _1023.d0;
    _1028 += _1027;
    _a2_int64_t _1029 = _1023.data[_1028];
    int64_t _1030 = 0;
    _1030 *= _1017.d0;
    _1030 += _1022;
    _1030 *= _1017.d1;
    _1030 += _1021;
    _1017.data[_1030] = _1029;
    _1021++;
    if (_1021 < _1019)
    goto _jump1160;
    _1021 = 0;
    _1022++;
    if (_1022 < _1018)
    goto _jump1160;
    // End body of loop
    if (_881.d1 >= 0)
    goto _jump1167;
    fail_assertion("negative array index");
    _jump1167:;
    if (_881.d1 < _1017.d0)
    goto _jump1168;
    fail_assertion("index too large");
    _jump1168:;
    if (_881.d0 >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (_881.d0 < _1017.d1)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    int64_t _1031 = 0;
    _1031 *= _1017.d0;
    _1031 += _881.d1;
    _1031 *= _1017.d1;
    _1031 += _881.d0;
    _a2_int64_t _1032 = _1017.data[_1031];
    _a1__a2_int64_t _1033;
    _1033.d0 = 2;
    _1033.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _1033.data[0] = _60;
    _1033.data[1] = _1032;
    int64_t _1034 = -_466.d2;
    _a1_int64_t _1035;
    _1035.d0 = 1;
    _1035.data = jpl_alloc(sizeof(int64_t) * 1);
    _1035.data[0] = _1034;
    int64_t _1036 = 792;
    if (_1036 >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (_1036 < _1035.d0)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    int64_t _1037 = 0;
    _1037 *= _1035.d0;
    _1037 += _1036;
    int64_t _1038 = _1035.data[_1037];
    int64_t _1039 = _1038 % _466.d2;
    int64_t _1040 = _1039 + _466.d2;
    if (_1040 >= 0)
    goto _jump1173;
    fail_assertion("negative array index");
    _jump1173:;
    if (_1040 < _1033.d0)
    goto _jump1174;
    fail_assertion("index too large");
    _jump1174:;
    int64_t _1041 = 0;
    _1041 *= _1033.d0;
    _1041 += _1040;
    _a2_int64_t _1042 = _1033.data[_1041];
    _a2_rgba _1043 = read_image("x.png");
    int64_t _1044 = -_373;
    bool _1045 = _466.d1 != _1044;
    bool _1046 = !_1045;
    double _1047;
    // Computing bound for G
    bool _1048 = false;
    int64_t _1049;
    if (!_1048)
    goto _jump1341;
    int64_t _1050 = -_1042.d0;
    _1049 = _1050;
    goto _jump1342;
    _jump1341:;
    _1049 = _907.d0;
    _jump1342:;
    if (_1049 > 0) 
    goto _jump1343;
    fail_assertion("non-positive loop bound");
    _jump1343:;
    // Computing bound for H
    if (_881.d0 > 0) 
    goto _jump1344;
    fail_assertion("non-positive loop bound");
    _jump1344:;
    // Computing bound for I
    int64_t _1051 = -_881.d2;
    if (_1051 > 0) 
    goto _jump1345;
    fail_assertion("non-positive loop bound");
    _jump1345:;
    _1047 = 0;
    int64_t _1052 = 0; // I
    int64_t _1053 = 0; // H
    int64_t _1054 = 0; // G
    _jump1346:; // Begin body of loop
    _1047 += _897;
    _1052++;
    if (_1052 < _1051)
    goto _jump1346;
    _1052 = 0;
    _1053++;
    if (_1053 < _881.d0)
    goto _jump1346;
    _1053 = 0;
    _1054++;
    if (_1054 < _1049)
    goto _jump1346;
    // End body of loop
    _a1_double _1055;
    _1055.d0 = 2;
    _1055.data = jpl_alloc(sizeof(double) * 2);
    _1055.data[0] = _897;
    _1055.data[1] = _1047;
    bool _1056 = _1016;
    if (0 == _1016)
    goto _jump1347;
    _1056 = _1016;
    _jump1347:;
    _a2_rgba _1057;
    if (!_1056)
    goto _jump1348;
    _1057 = _1043;
    goto _jump1349;
    _jump1348:;
    _1057 = _1043;
    _jump1349:;
    if (_466.d0 >= 0)
    goto _jump1350;
    fail_assertion("negative array index");
    _jump1350:;
    if (_466.d0 < _1057.d0)
    goto _jump1351;
    fail_assertion("index too large");
    _jump1351:;
    if (_881.d0 >= 0)
    goto _jump1352;
    fail_assertion("negative array index");
    _jump1352:;
    if (_881.d0 < _1057.d1)
    goto _jump1353;
    fail_assertion("index too large");
    _jump1353:;
    int64_t _1058 = 0;
    _1058 *= _1057.d0;
    _1058 += _466.d0;
    _1058 *= _1057.d1;
    _1058 += _881.d0;
    rgba _1059 = _1057.data[_1058];
    int64_t _1060 = D(_1059);
    if (_1060 >= 0)
    goto _jump1354;
    fail_assertion("negative array index");
    _jump1354:;
    if (_1060 < _1055.d0)
    goto _jump1355;
    fail_assertion("index too large");
    _jump1355:;
    int64_t _1061 = 0;
    _1061 *= _1055.d0;
    _1061 += _1060;
    double _1062 = _1055.data[_1061];
    bool _1063 = _897 != _1062;
    bool _1064 = _1046 == _1063;
    show("(BoolType)", &_1064);
}

