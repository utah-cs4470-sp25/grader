
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_void_t *data;
} _a3__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  _a1_double *data;
} _a1__a1_double;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
    bool a;
} t;

typedef struct {
  int64_t d0;
  t *data;
} _a1_t;

double b(_a1_void_t c, _a3_void_t e, bool i) {
    double _1 = 11.0;
    bool _2 = a < _1;
    bool _0 = _2;
    if (0 == _2)
    goto _jump171;
    _0 = i;
    _jump171:;
    bool _3;
    if (!_0)
    goto _jump172;
    bool _4 = e.d0 >= e.d0;
    bool _5 = !_4;
    _3 = _5;
    goto _jump173;
    _jump172:;
    double _6 = 98.0;
    bool _7 = _6 < a;
    bool _8;
    if (!_7)
    goto _jump174;
    bool _9 = c.d0 != e.d0;
    _8 = _9;
    goto _jump175;
    _jump174:;
    bool _10 = false;
    _8 = _10;
    _jump175:;
    _3 = _8;
    _jump173:;
    bool _11 = !_3;
    rgba _12;
    if (!_11)
    goto _jump176;
    double _13;
    // Computing bound for j
    if (e.d0 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing bound for k
    int64_t _14 = 159;
    if (_14 > 0) 
    goto _jump178;
    fail_assertion("non-positive loop bound");
    _jump178:;
    _13 = 0;
    int64_t _15 = 0; // k
    int64_t _16 = 0; // j
    _jump179:; // Begin body of loop
    double _17 = 16.0;
    _13 += _17;
    _15++;
    if (_15 < _14)
    goto _jump179;
    _15 = 0;
    _16++;
    if (_16 < e.d0)
    goto _jump179;
    // End body of loop
    double _18 = 42.0;
    double _19 = -_18;
    double _20 = -a;
    double _21 = 8.0;
    double _22 = 24.0;
    rgba _23 = { _19, _20, _21, _22 };
    double _24 = _23.r;
    _a2_double _25;
    // Computing bound for j
    int64_t _26 = 399;
    _25.d0 = _26;
    if (_26 > 0) 
    goto _jump180;
    fail_assertion("non-positive loop bound");
    _jump180:;
    // Computing bound for k
    _25.d1 = e.d2;
    if (e.d2 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= _26;
    _27 *= e.d2;
    _27 *= sizeof(double);
    _25.data = jpl_alloc(_27);
    int64_t _28 = 0; // k
    int64_t _29 = 0; // j
    _jump182:; // Begin body of loop
    bool _30 = false;
    double _31 = b(c, e, _30);
    int64_t _32 = 0;
    _32 *= _25.d0;
    _32 += _29;
    _32 *= _25.d1;
    _32 += _28;
    _25.data[_32] = _31;
    _28++;
    if (_28 < e.d2)
    goto _jump182;
    _28 = 0;
    _29++;
    if (_29 < _26)
    goto _jump182;
    // End body of loop
    if (e.d0 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (e.d0 < _25.d0)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    if (e.d0 >= 0)
    goto _jump185;
    fail_assertion("negative array index");
    _jump185:;
    if (e.d0 < _25.d1)
    goto _jump186;
    fail_assertion("index too large");
    _jump186:;
    int64_t _33 = 0;
    _33 *= _25.d0;
    _33 += e.d0;
    _33 *= _25.d1;
    _33 += e.d0;
    double _34 = _25.data[_33];
    _a2_double _35;
    if (!i)
    goto _jump187;
    _a2_double _36;
    // Computing bound for j
    int64_t _37 = 459;
    _36.d0 = _37;
    if (_37 > 0) 
    goto _jump188;
    fail_assertion("non-positive loop bound");
    _jump188:;
    // Computing bound for k
    int64_t _38 = 474;
    _36.d1 = _38;
    if (_38 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing total size of heap memory to allocate
    int64_t _39 = 1;
    _39 *= _37;
    _39 *= _38;
    _39 *= sizeof(double);
    _36.data = jpl_alloc(_39);
    int64_t _40 = 0; // k
    int64_t _41 = 0; // j
    _jump190:; // Begin body of loop
    double _42 = 30.0;
    int64_t _43 = 0;
    _43 *= _36.d0;
    _43 += _41;
    _43 *= _36.d1;
    _43 += _40;
    _36.data[_43] = _42;
    _40++;
    if (_40 < _38)
    goto _jump190;
    _40 = 0;
    _41++;
    if (_41 < _37)
    goto _jump190;
    // End body of loop
    _35 = _36;
    goto _jump191;
    _jump187:;
    _a2_double _44;
    // Computing bound for j
    _44.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump192;
    fail_assertion("non-positive loop bound");
    _jump192:;
    // Computing bound for k
    _44.d1 = e.d1;
    if (e.d1 > 0) 
    goto _jump193;
    fail_assertion("non-positive loop bound");
    _jump193:;
    // Computing total size of heap memory to allocate
    int64_t _45 = 1;
    _45 *= e.d1;
    _45 *= e.d1;
    _45 *= sizeof(double);
    _44.data = jpl_alloc(_45);
    int64_t _46 = 0; // k
    int64_t _47 = 0; // j
    _jump194:; // Begin body of loop
    int64_t _48 = 0;
    _48 *= _44.d0;
    _48 += _47;
    _48 *= _44.d1;
    _48 += _46;
    _44.data[_48] = a;
    _46++;
    if (_46 < e.d1)
    goto _jump194;
    _46 = 0;
    _47++;
    if (_47 < e.d1)
    goto _jump194;
    // End body of loop
    _35 = _44;
    _jump191:;
    bool _49 = false;
    int64_t _50;
    if (!_49)
    goto _jump195;
    _50 = e.d2;
    goto _jump196;
    _jump195:;
    int64_t _51;
    if (!i)
    goto _jump197;
    _51 = c.d0;
    goto _jump198;
    _jump197:;
    _51 = e.d1;
    _jump198:;
    _50 = _51;
    _jump196:;
    if (c.d0 >= 0)
    goto _jump199;
    fail_assertion("negative array index");
    _jump199:;
    if (c.d0 < _35.d0)
    goto _jump200;
    fail_assertion("index too large");
    _jump200:;
    if (_50 >= 0)
    goto _jump201;
    fail_assertion("negative array index");
    _jump201:;
    if (_50 < _35.d1)
    goto _jump202;
    fail_assertion("index too large");
    _jump202:;
    int64_t _52 = 0;
    _52 *= _35.d0;
    _52 += c.d0;
    _52 *= _35.d1;
    _52 += _50;
    double _53 = _35.data[_52];
    rgba _54 = { _13, _24, _34, _53 };
    _12 = _54;
    goto _jump203;
    _jump176:;
    int64_t _56 = 813;
    bool _57 = c.d0 <= _56;
    bool _55 = _57;
    if (0 == _57)
    goto _jump204;
    _55 = i;
    _jump204:;
    bool _58;
    if (!_55)
    goto _jump205;
    _58 = i;
    goto _jump206;
    _jump205:;
    int64_t _59;
    // Computing bound for j
    if (e.d1 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    _59 = 0;
    int64_t _60 = 0; // j
    _jump208:; // Begin body of loop
    _59 += e.d0;
    _60++;
    if (_60 < e.d1)
    goto _jump208;
    // End body of loop
    bool _61 = _59 == e.d0;
    _58 = _61;
    _jump206:;
    rgba _62;
    if (!_58)
    goto _jump209;
    double _63 = 23.0;
    double _64 = -_63;
    double _65 = -a;
    _a2_double _66;
    // Computing bound for j
    _66.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for k
    int64_t _67 = 128;
    _66.d1 = _67;
    if (_67 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= e.d2;
    _68 *= _67;
    _68 *= sizeof(double);
    _66.data = jpl_alloc(_68);
    int64_t _69 = 0; // k
    int64_t _70 = 0; // j
    _jump212:; // Begin body of loop
    int64_t _71 = 0;
    _71 *= _66.d0;
    _71 += _70;
    _71 *= _66.d1;
    _71 += _69;
    _66.data[_71] = a;
    _69++;
    if (_69 < _67)
    goto _jump212;
    _69 = 0;
    _70++;
    if (_70 < e.d2)
    goto _jump212;
    // End body of loop
    int64_t _72 = -e.d2;
    int64_t _73 = e.d0 - e.d1;
    if (_72 >= 0)
    goto _jump213;
    fail_assertion("negative array index");
    _jump213:;
    if (_72 < _66.d0)
    goto _jump214;
    fail_assertion("index too large");
    _jump214:;
    if (_73 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (_73 < _66.d1)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    int64_t _74 = 0;
    _74 *= _66.d0;
    _74 += _72;
    _74 *= _66.d1;
    _74 += _73;
    double _75 = _66.data[_74];
    rgba _76 = { _64, _65, _75, a };
    _62 = _76;
    goto _jump217;
    _jump209:;
    double _77 = 97.0;
    double _78;
    // Computing bound for j
    if (e.d2 > 0) 
    goto _jump218;
    fail_assertion("non-positive loop bound");
    _jump218:;
    _78 = 0;
    int64_t _79 = 0; // j
    _jump219:; // Begin body of loop
    double _80 = 44.0;
    _78 += _80;
    _79++;
    if (_79 < e.d2)
    goto _jump219;
    // End body of loop
    double _81 = b(c, e, i);
    double _82 = fmod(_78, _81);
    double _83 = 38.0;
    rgba _84 = { a, _77, _82, _83 };
    _62 = _84;
    _jump217:;
    _12 = _62;
    _jump203:;
    double _85 = _12.b;
    double _86;
    // Computing bound for j
    int64_t _87;
    // Computing bound for j
    int64_t _88 = e.d1 / e.d1;
    int64_t _89 = -_88;
    int64_t _90 = _89 * e.d2;
    if (_90 > 0) 
    goto _jump220;
    fail_assertion("non-positive loop bound");
    _jump220:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing bound for l
    int64_t _91 = 155;
    if (_91 > 0) 
    goto _jump222;
    fail_assertion("non-positive loop bound");
    _jump222:;
    _87 = 0;
    int64_t _92 = 0; // l
    int64_t _93 = 0; // k
    int64_t _94 = 0; // j
    _jump223:; // Begin body of loop
    _a3_int64_t _95;
    // Computing bound for m
    _95.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    // Computing bound for n
    int64_t _96 = 324;
    int64_t _97 = _96 % _93;
    _95.d1 = _97;
    if (_97 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for o
    _95.d2 = e.d0;
    if (e.d0 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing total size of heap memory to allocate
    int64_t _98 = 1;
    _98 *= e.d2;
    _98 *= _97;
    _98 *= e.d0;
    _98 *= sizeof(int64_t);
    _95.data = jpl_alloc(_98);
    int64_t _99 = 0; // o
    int64_t _100 = 0; // n
    int64_t _101 = 0; // m
    _jump227:; // Begin body of loop
    int64_t _102 = 0;
    _102 *= _95.d0;
    _102 += _101;
    _102 *= _95.d1;
    _102 += _100;
    _102 *= _95.d2;
    _102 += _99;
    _95.data[_102] = e.d0;
    _99++;
    if (_99 < e.d0)
    goto _jump227;
    _99 = 0;
    _100++;
    if (_100 < _97)
    goto _jump227;
    _100 = 0;
    _101++;
    if (_101 < e.d2)
    goto _jump227;
    // End body of loop
    _a2_int64_t _103;
    // Computing bound for m
    _103.d0 = _93;
    if (_93 > 0) 
    goto _jump228;
    fail_assertion("non-positive loop bound");
    _jump228:;
    // Computing bound for n
    int64_t _104 = 673;
    _103.d1 = _104;
    if (_104 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _93;
    _105 *= _104;
    _105 *= sizeof(int64_t);
    _103.data = jpl_alloc(_105);
    int64_t _106 = 0; // n
    int64_t _107 = 0; // m
    _jump230:; // Begin body of loop
    int64_t _108 = 0;
    _108 *= _103.d0;
    _108 += _107;
    _108 *= _103.d1;
    _108 += _106;
    _103.data[_108] = _107;
    _106++;
    if (_106 < _104)
    goto _jump230;
    _106 = 0;
    _107++;
    if (_107 < _93)
    goto _jump230;
    // End body of loop
    if (_93 >= 0)
    goto _jump231;
    fail_assertion("negative array index");
    _jump231:;
    if (_93 < _103.d0)
    goto _jump232;
    fail_assertion("index too large");
    _jump232:;
    if (c.d0 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (c.d0 < _103.d1)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    int64_t _109 = 0;
    _109 *= _103.d0;
    _109 += _93;
    _109 *= _103.d1;
    _109 += c.d0;
    int64_t _110 = _103.data[_109];
    int64_t _111 = 59;
    if (_94 >= 0)
    goto _jump235;
    fail_assertion("negative array index");
    _jump235:;
    if (_94 < _95.d0)
    goto _jump236;
    fail_assertion("index too large");
    _jump236:;
    if (_110 >= 0)
    goto _jump237;
    fail_assertion("negative array index");
    _jump237:;
    if (_110 < _95.d1)
    goto _jump238;
    fail_assertion("index too large");
    _jump238:;
    if (_111 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (_111 < _95.d2)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    int64_t _112 = 0;
    _112 *= _95.d0;
    _112 += _94;
    _112 *= _95.d1;
    _112 += _110;
    _112 *= _95.d2;
    _112 += _111;
    int64_t _113 = _95.data[_112];
    _87 += _113;
    _92++;
    if (_92 < _91)
    goto _jump223;
    _92 = 0;
    _93++;
    if (_93 < c.d0)
    goto _jump223;
    _93 = 0;
    _94++;
    if (_94 < _90)
    goto _jump223;
    // End body of loop
    if (_87 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for l
    int64_t _114 = 182;
    if (_114 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    _86 = 0;
    int64_t _115 = 0; // l
    int64_t _116 = 0; // k
    int64_t _117 = 0; // j
    _jump244:; // Begin body of loop
    double _118 = 11.0;
    bool _119 = a < _118;
    _a1__a3_void_t _120;
    if (!_119)
    goto _jump245;
    _a1__a3_void_t _121;
    _121.d0 = 2;
    _121.data = jpl_alloc(sizeof(_a3_void_t) * 2);
    _121.data[0] = e;
    _121.data[1] = e;
    _120 = _121;
    goto _jump246;
    _jump245:;
    _a1__a3_void_t _122;
    // Computing bound for m
    _122.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= e.d0;
    _123 *= sizeof(_a3_void_t);
    _122.data = jpl_alloc(_123);
    int64_t _124 = 0; // m
    _jump248:; // Begin body of loop
    int64_t _125 = 0;
    _125 *= _122.d0;
    _125 += _124;
    _122.data[_125] = e;
    _124++;
    if (_124 < e.d0)
    goto _jump248;
    // End body of loop
    _120 = _122;
    _jump246:;
    int64_t _126 = _117 * _116;
    if (_126 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (_126 < _120.d0)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    int64_t _127 = 0;
    _127 *= _120.d0;
    _127 += _126;
    _a3_void_t _128 = _120.data[_127];
    _a1_bool _129;
    // Computing bound for m
    _129.d0 = _115;
    if (_115 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing total size of heap memory to allocate
    int64_t _130 = 1;
    _130 *= _115;
    _130 *= sizeof(bool);
    _129.data = jpl_alloc(_130);
    int64_t _131 = 0; // m
    _jump252:; // Begin body of loop
    bool _132 = false;
    int64_t _133 = 0;
    _133 *= _129.d0;
    _133 += _131;
    _129.data[_133] = _132;
    _131++;
    if (_131 < _115)
    goto _jump252;
    // End body of loop
    if (_117 >= 0)
    goto _jump253;
    fail_assertion("negative array index");
    _jump253:;
    if (_117 < _129.d0)
    goto _jump254;
    fail_assertion("index too large");
    _jump254:;
    int64_t _134 = 0;
    _134 *= _129.d0;
    _134 += _117;
    bool _135 = _129.data[_134];
    double _136 = b(c, _128, _135);
    _86 += _136;
    _115++;
    if (_115 < _114)
    goto _jump244;
    _115 = 0;
    _116++;
    if (_116 < c.d0)
    goto _jump244;
    _116 = 0;
    _117++;
    if (_117 < _87)
    goto _jump244;
    // End body of loop
    bool _137 = true;
    double _138;
    if (!_137)
    goto _jump255;
    double _139 = 85.0;
    double _140 = a - _139;
    double _141 = -_140;
    double _142;
    // Computing bound for j
    if (e.d0 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing bound for k
    int64_t _143 = 159;
    if (_143 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing bound for l
    if (e.d0 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    _142 = 0;
    int64_t _144 = 0; // l
    int64_t _145 = 0; // k
    int64_t _146 = 0; // j
    _jump259:; // Begin body of loop
    double _147 = 13.0;
    _142 += _147;
    _144++;
    if (_144 < e.d0)
    goto _jump259;
    _144 = 0;
    _145++;
    if (_145 < _143)
    goto _jump259;
    _145 = 0;
    _146++;
    if (_146 < e.d0)
    goto _jump259;
    // End body of loop
    double _148 = -_142;
    double _149 = 51.0;
    rgba _150 = { _141, a, _148, _149 };
    double _151 = _150.g;
    _138 = _151;
    goto _jump260;
    _jump255:;
    double _152 = 36.0;
    _138 = _152;
    _jump260:;
    double _153 = _86 + _138;
    bool _154 = _85 == _153;
    _a1__a2_int64_t _155;
    // Computing bound for k
    int64_t _156 = 679;
    _155.d0 = _156;
    if (_156 > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= _156;
    _157 *= sizeof(_a2_int64_t);
    _155.data = jpl_alloc(_157);
    int64_t _158 = 0; // k
    _jump262:; // Begin body of loop
    _a2_int64_t _159;
    // Computing bound for l
    _159.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing bound for m
    _159.d1 = e.d2;
    if (e.d2 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= c.d0;
    _160 *= e.d2;
    _160 *= sizeof(int64_t);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // m
    int64_t _162 = 0; // l
    _jump265:; // Begin body of loop
    _a1_int64_t _163;
    // Computing bound for n
    _163.d0 = _162;
    if (_162 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= _162;
    _164 *= sizeof(int64_t);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // n
    _jump267:; // Begin body of loop
    int64_t _166 = 0;
    _166 *= _163.d0;
    _166 += _165;
    _163.data[_166] = _158;
    _165++;
    if (_165 < _162)
    goto _jump267;
    // End body of loop
    if (_158 >= 0)
    goto _jump268;
    fail_assertion("negative array index");
    _jump268:;
    if (_158 < _163.d0)
    goto _jump269;
    fail_assertion("index too large");
    _jump269:;
    int64_t _167 = 0;
    _167 *= _163.d0;
    _167 += _158;
    int64_t _168 = _163.data[_167];
    int64_t _169 = 0;
    _169 *= _159.d0;
    _169 += _162;
    _169 *= _159.d1;
    _169 += _161;
    _159.data[_169] = _168;
    _161++;
    if (_161 < e.d2)
    goto _jump265;
    _161 = 0;
    _162++;
    if (_162 < c.d0)
    goto _jump265;
    // End body of loop
    int64_t _170 = 0;
    _170 *= _155.d0;
    _170 += _158;
    _155.data[_170] = _159;
    _158++;
    if (_158 < _156)
    goto _jump262;
    // End body of loop
    if (e.d2 >= 0)
    goto _jump270;
    fail_assertion("negative array index");
    _jump270:;
    if (e.d2 < _155.d0)
    goto _jump271;
    fail_assertion("index too large");
    _jump271:;
    int64_t _171 = 0;
    _171 *= _155.d0;
    _171 += e.d2;
    _a2_int64_t _172 = _155.data[_171];
    int64_t _173 = 374;
    int64_t _174 = -_173;
    if (_174 >= 0)
    goto _jump272;
    fail_assertion("negative array index");
    _jump272:;
    if (_174 < _172.d0)
    goto _jump273;
    fail_assertion("index too large");
    _jump273:;
    if (e.d2 >= 0)
    goto _jump274;
    fail_assertion("negative array index");
    _jump274:;
    if (e.d2 < _172.d1)
    goto _jump275;
    fail_assertion("index too large");
    _jump275:;
    int64_t _175 = 0;
    _175 *= _172.d0;
    _175 += _174;
    _175 *= _172.d1;
    _175 += e.d2;
    int64_t _176 = _172.data[_175];
    bool _177 = !_154;
    _a1_void_t _178;
    if (!_154)
    goto _jump276;
    _a1_void_t _179;
    if (!_154)
    goto _jump277;
    _179 = c;
    goto _jump278;
    _jump277:;
    _179 = c;
    _jump278:;
    _178 = _179;
    goto _jump279;
    _jump276:;
    _178 = c;
    _jump279:;
    _a1_bool _180;
    // Computing bound for s
    _180.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= e.d1;
    _181 *= sizeof(bool);
    _180.data = jpl_alloc(_181);
    int64_t _182 = 0; // s
    _jump281:; // Begin body of loop
    int64_t _183 = 0;
    _183 *= _180.d0;
    _183 += _182;
    _180.data[_183] = _177;
    _182++;
    if (_182 < e.d1)
    goto _jump281;
    // End body of loop
    if (e.d0 >= 0)
    goto _jump282;
    fail_assertion("negative array index");
    _jump282:;
    if (e.d0 < _180.d0)
    goto _jump283;
    fail_assertion("index too large");
    _jump283:;
    int64_t _184 = 0;
    _184 *= _180.d0;
    _184 += e.d0;
    bool _185 = _180.data[_184];
    _a3__a3_void_t _186;
    if (!_185)
    goto _jump284;
    _a3__a3_void_t _187;
    // Computing bound for s
    _187.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump285;
    fail_assertion("non-positive loop bound");
    _jump285:;
    // Computing bound for t
    _187.d1 = e.d2;
    if (e.d2 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing bound for u
    _187.d2 = e.d2;
    if (e.d2 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= e.d1;
    _188 *= e.d2;
    _188 *= e.d2;
    _188 *= sizeof(_a3_void_t);
    _187.data = jpl_alloc(_188);
    int64_t _189 = 0; // u
    int64_t _190 = 0; // t
    int64_t _191 = 0; // s
    _jump288:; // Begin body of loop
    int64_t _192 = 0;
    _192 *= _187.d0;
    _192 += _191;
    _192 *= _187.d1;
    _192 += _190;
    _192 *= _187.d2;
    _192 += _189;
    _187.data[_192] = e;
    _189++;
    if (_189 < e.d2)
    goto _jump288;
    _189 = 0;
    _190++;
    if (_190 < e.d2)
    goto _jump288;
    _190 = 0;
    _191++;
    if (_191 < e.d1)
    goto _jump288;
    // End body of loop
    _186 = _187;
    goto _jump289;
    _jump284:;
    _a3__a3_void_t _193;
    // Computing bound for s
    _193.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump290;
    fail_assertion("non-positive loop bound");
    _jump290:;
    // Computing bound for t
    _193.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump291;
    fail_assertion("non-positive loop bound");
    _jump291:;
    // Computing bound for u
    int64_t _194;
    // Computing bound for s
    if (e.d1 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    _194 = 0;
    int64_t _195 = 0; // s
    _jump293:; // Begin body of loop
    _194 += e.d1;
    _195++;
    if (_195 < e.d1)
    goto _jump293;
    // End body of loop
    _193.d2 = _194;
    if (_194 > 0) 
    goto _jump294;
    fail_assertion("non-positive loop bound");
    _jump294:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= e.d2;
    _196 *= e.d0;
    _196 *= _194;
    _196 *= sizeof(_a3_void_t);
    _193.data = jpl_alloc(_196);
    int64_t _197 = 0; // u
    int64_t _198 = 0; // t
    int64_t _199 = 0; // s
    _jump295:; // Begin body of loop
    int64_t _200 = 0;
    _200 *= _193.d0;
    _200 += _199;
    _200 *= _193.d1;
    _200 += _198;
    _200 *= _193.d2;
    _200 += _197;
    _193.data[_200] = e;
    _197++;
    if (_197 < _194)
    goto _jump295;
    _197 = 0;
    _198++;
    if (_198 < e.d0)
    goto _jump295;
    _198 = 0;
    _199++;
    if (_199 < e.d2)
    goto _jump295;
    // End body of loop
    _186 = _193;
    _jump289:;
    double _201 = 20.0;
    bool _202 = a < _201;
    bool _203 = !_202;
    int64_t _204;
    if (!_203)
    goto _jump296;
    int64_t _205 = 160;
    bool _206 = e.d1 > _205;
    int64_t _207;
    if (!_206)
    goto _jump297;
    _207 = e.d2;
    goto _jump298;
    _jump297:;
    _207 = e.d2;
    _jump298:;
    _204 = _207;
    goto _jump299;
    _jump296:;
    int64_t _208 = -e.d1;
    _204 = _208;
    _jump299:;
    if (e.d0 >= 0)
    goto _jump300;
    fail_assertion("negative array index");
    _jump300:;
    if (e.d0 < _186.d0)
    goto _jump301;
    fail_assertion("index too large");
    _jump301:;
    if (_204 >= 0)
    goto _jump302;
    fail_assertion("negative array index");
    _jump302:;
    if (_204 < _186.d1)
    goto _jump303;
    fail_assertion("index too large");
    _jump303:;
    if (c.d0 >= 0)
    goto _jump304;
    fail_assertion("negative array index");
    _jump304:;
    if (c.d0 < _186.d2)
    goto _jump305;
    fail_assertion("index too large");
    _jump305:;
    int64_t _209 = 0;
    _209 *= _186.d0;
    _209 += e.d0;
    _209 *= _186.d1;
    _209 += _204;
    _209 *= _186.d2;
    _209 += c.d0;
    _a3_void_t _210 = _186.data[_209];
    int64_t _211 = -c.d0;
    int64_t _212;
    // Computing bound for s
    int64_t _213;
    // Computing bound for s
    if (c.d0 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for t
    if (e.d1 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    // Computing bound for u
    if (e.d2 > 0) 
    goto _jump308;
    fail_assertion("non-positive loop bound");
    _jump308:;
    _213 = 0;
    int64_t _214 = 0; // u
    int64_t _215 = 0; // t
    int64_t _216 = 0; // s
    _jump309:; // Begin body of loop
    int64_t _217 = c.d0 * e.d0;
    _213 += _217;
    _214++;
    if (_214 < e.d2)
    goto _jump309;
    _214 = 0;
    _215++;
    if (_215 < e.d1)
    goto _jump309;
    _215 = 0;
    _216++;
    if (_216 < c.d0)
    goto _jump309;
    // End body of loop
    if (_213 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    _212 = 0;
    int64_t _218 = 0; // s
    _jump311:; // Begin body of loop
    int64_t _219 = -e.d1;
    int64_t _220 = _219 / _176;
    _212 += _220;
    _218++;
    if (_218 < _213)
    goto _jump311;
    // End body of loop
    bool _221 = _211 != _212;
    double _222 = b(_178, _210, _221);
    _a3_void_t _223;
    // Computing bound for s
    int64_t _224 = 73;
    _223.d0 = _224;
    if (_224 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for t
    _223.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for u
    bool _225 = false;
    int64_t _226;
    if (!_225)
    goto _jump314;
    int64_t _227 = 233;
    _226 = _227;
    goto _jump315;
    _jump314:;
    _226 = e.d0;
    _jump315:;
    _223.d2 = _226;
    if (_226 > 0) 
    goto _jump316;
    fail_assertion("non-positive loop bound");
    _jump316:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= _224;
    _228 *= e.d0;
    _228 *= _226;
    _228 *= sizeof(void_t);
    _223.data = jpl_alloc(_228);
    int64_t _229 = 0; // u
    int64_t _230 = 0; // t
    int64_t _231 = 0; // s
    _jump317:; // Begin body of loop
    if (e.d1 >= 0)
    goto _jump318;
    fail_assertion("negative array index");
    _jump318:;
    if (e.d1 < e.d0)
    goto _jump319;
    fail_assertion("index too large");
    _jump319:;
    if (e.d1 >= 0)
    goto _jump320;
    fail_assertion("negative array index");
    _jump320:;
    if (e.d1 < e.d1)
    goto _jump321;
    fail_assertion("index too large");
    _jump321:;
    if (_231 >= 0)
    goto _jump322;
    fail_assertion("negative array index");
    _jump322:;
    if (_231 < e.d2)
    goto _jump323;
    fail_assertion("index too large");
    _jump323:;
    int64_t _232 = 0;
    _232 *= e.d0;
    _232 += e.d1;
    _232 *= e.d1;
    _232 += e.d1;
    _232 *= e.d2;
    _232 += _231;
    void_t _233 = e.data[_232];
    int64_t _234 = 0;
    _234 *= _223.d0;
    _234 += _231;
    _234 *= _223.d1;
    _234 += _230;
    _234 *= _223.d2;
    _234 += _229;
    _223.data[_234] = _233;
    _229++;
    if (_229 < _226)
    goto _jump317;
    _229 = 0;
    _230++;
    if (_230 < e.d0)
    goto _jump317;
    _230 = 0;
    _231++;
    if (_231 < _224)
    goto _jump317;
    // End body of loop
    int64_t _235;
    // Computing bound for s
    if (_176 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    _235 = 0;
    int64_t _236 = 0; // s
    _jump325:; // Begin body of loop
    _235 += _176;
    _236++;
    if (_236 < _176)
    goto _jump325;
    // End body of loop
    if (_235 >= 0)
    goto _jump326;
    fail_assertion("negative array index");
    _jump326:;
    if (_235 < _223.d0)
    goto _jump327;
    fail_assertion("index too large");
    _jump327:;
    if (e.d2 >= 0)
    goto _jump328;
    fail_assertion("negative array index");
    _jump328:;
    if (e.d2 < _223.d1)
    goto _jump329;
    fail_assertion("index too large");
    _jump329:;
    if (_176 >= 0)
    goto _jump330;
    fail_assertion("negative array index");
    _jump330:;
    if (_176 < _223.d2)
    goto _jump331;
    fail_assertion("index too large");
    _jump331:;
    int64_t _237 = 0;
    _237 *= _223.d0;
    _237 += _235;
    _237 *= _223.d1;
    _237 += e.d2;
    _237 *= _223.d2;
    _237 += _176;
    void_t _238 = _223.data[_237];
    bool _239 = false;
    void_t _240;
    if (!_239)
    goto _jump332;
    int64_t _241 = 919;
    int64_t _242 = 2;
    int64_t _243 = -_242;
    if (_241 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (_241 < e.d0)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    if (_243 >= 0)
    goto _jump335;
    fail_assertion("negative array index");
    _jump335:;
    if (_243 < e.d1)
    goto _jump336;
    fail_assertion("index too large");
    _jump336:;
    if (e.d0 >= 0)
    goto _jump337;
    fail_assertion("negative array index");
    _jump337:;
    if (e.d0 < e.d2)
    goto _jump338;
    fail_assertion("index too large");
    _jump338:;
    int64_t _244 = 0;
    _244 *= e.d0;
    _244 += _241;
    _244 *= e.d1;
    _244 += _243;
    _244 *= e.d2;
    _244 += e.d0;
    void_t _245 = e.data[_244];
    _240 = _245;
    goto _jump339;
    _jump332:;
    if (_176 >= 0)
    goto _jump340;
    fail_assertion("negative array index");
    _jump340:;
    if (_176 < e.d0)
    goto _jump341;
    fail_assertion("index too large");
    _jump341:;
    if (e.d2 >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (e.d2 < e.d1)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    if (c.d0 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (c.d0 < e.d2)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    int64_t _246 = 0;
    _246 *= e.d0;
    _246 += _176;
    _246 *= e.d1;
    _246 += e.d2;
    _246 *= e.d2;
    _246 += c.d0;
    void_t _247 = e.data[_246];
    _240 = _247;
    _jump339:;
    bool _249 = false;
    bool _248 = _249;
    if (0 == _249)
    goto _jump346;
    bool _250 = false;
    _248 = _250;
    _jump346:;
    void_t _251;
    if (!_248)
    goto _jump347;
    void_t _252;
    if (!i)
    goto _jump348;
    int64_t _253 = 474;
    if (e.d1 >= 0)
    goto _jump349;
    fail_assertion("negative array index");
    _jump349:;
    if (e.d1 < e.d0)
    goto _jump350;
    fail_assertion("index too large");
    _jump350:;
    if (_253 >= 0)
    goto _jump351;
    fail_assertion("negative array index");
    _jump351:;
    if (_253 < e.d1)
    goto _jump352;
    fail_assertion("index too large");
    _jump352:;
    if (e.d1 >= 0)
    goto _jump353;
    fail_assertion("negative array index");
    _jump353:;
    if (e.d1 < e.d2)
    goto _jump354;
    fail_assertion("index too large");
    _jump354:;
    int64_t _254 = 0;
    _254 *= e.d0;
    _254 += e.d1;
    _254 *= e.d1;
    _254 += _253;
    _254 *= e.d2;
    _254 += e.d1;
    void_t _255 = e.data[_254];
    _252 = _255;
    goto _jump355;
    _jump348:;
    if (e.d2 >= 0)
    goto _jump356;
    fail_assertion("negative array index");
    _jump356:;
    if (e.d2 < e.d0)
    goto _jump357;
    fail_assertion("index too large");
    _jump357:;
    if (e.d1 >= 0)
    goto _jump358;
    fail_assertion("negative array index");
    _jump358:;
    if (e.d1 < e.d1)
    goto _jump359;
    fail_assertion("index too large");
    _jump359:;
    if (e.d2 >= 0)
    goto _jump360;
    fail_assertion("negative array index");
    _jump360:;
    if (e.d2 < e.d2)
    goto _jump361;
    fail_assertion("index too large");
    _jump361:;
    int64_t _256 = 0;
    _256 *= e.d0;
    _256 += e.d2;
    _256 *= e.d1;
    _256 += e.d1;
    _256 *= e.d2;
    _256 += e.d2;
    void_t _257 = e.data[_256];
    _252 = _257;
    _jump355:;
    _251 = _252;
    goto _jump362;
    _jump347:;
    if (e.d2 >= 0)
    goto _jump363;
    fail_assertion("negative array index");
    _jump363:;
    if (e.d2 < c.d0)
    goto _jump364;
    fail_assertion("index too large");
    _jump364:;
    int64_t _258 = 0;
    _258 *= c.d0;
    _258 += e.d2;
    void_t _259 = c.data[_258];
    _251 = _259;
    _jump362:;
    _a1_void_t _260;
    _260.d0 = 3;
    _260.data = jpl_alloc(sizeof(void_t) * 3);
    _260.data[0] = _238;
    _260.data[1] = _240;
    _260.data[2] = _251;
    _a3_bool _261;
    // Computing bound for s
    _261.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    // Computing bound for t
    int64_t _262 = -c.d0;
    _261.d1 = _262;
    if (_262 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing bound for u
    int64_t _263 = e.d1 * e.d2;
    _261.d2 = _263;
    if (_263 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= c.d0;
    _264 *= _262;
    _264 *= _263;
    _264 *= sizeof(bool);
    _261.data = jpl_alloc(_264);
    int64_t _265 = 0; // u
    int64_t _266 = 0; // t
    int64_t _267 = 0; // s
    _jump368:; // Begin body of loop
    bool _268 = e.d1 < e.d1;
    int64_t _269 = 0;
    _269 *= _261.d0;
    _269 += _267;
    _269 *= _261.d1;
    _269 += _266;
    _269 *= _261.d2;
    _269 += _265;
    _261.data[_269] = _268;
    _265++;
    if (_265 < _263)
    goto _jump368;
    _265 = 0;
    _266++;
    if (_266 < _262)
    goto _jump368;
    _266 = 0;
    _267++;
    if (_267 < c.d0)
    goto _jump368;
    // End body of loop
    if (e.d0 >= 0)
    goto _jump369;
    fail_assertion("negative array index");
    _jump369:;
    if (e.d0 < _261.d0)
    goto _jump370;
    fail_assertion("index too large");
    _jump370:;
    if (_176 >= 0)
    goto _jump371;
    fail_assertion("negative array index");
    _jump371:;
    if (_176 < _261.d1)
    goto _jump372;
    fail_assertion("index too large");
    _jump372:;
    if (e.d2 >= 0)
    goto _jump373;
    fail_assertion("negative array index");
    _jump373:;
    if (e.d2 < _261.d2)
    goto _jump374;
    fail_assertion("index too large");
    _jump374:;
    int64_t _270 = 0;
    _270 *= _261.d0;
    _270 += e.d0;
    _270 *= _261.d1;
    _270 += _176;
    _270 *= _261.d2;
    _270 += e.d2;
    bool _271 = _261.data[_270];
    _a3_void_t _272;
    if (!_271)
    goto _jump375;
    _272 = e;
    goto _jump376;
    _jump375:;
    _272 = e;
    _jump376:;
    int64_t _273 = _176 + e.d2;
    bool _274 = _273 >= e.d2;
    double _275 = b(_260, _272, _274);
    _a1_double _276;
    _276.d0 = 3;
    _276.data = jpl_alloc(sizeof(double) * 3);
    _276.data[0] = _222;
    _276.data[1] = a;
    _276.data[2] = _275;
    if (_176 >= 0)
    goto _jump377;
    fail_assertion("negative array index");
    _jump377:;
    if (_176 < _276.d0)
    goto _jump378;
    fail_assertion("index too large");
    _jump378:;
    int64_t _277 = 0;
    _277 *= _276.d0;
    _277 += _176;
    double _278 = _276.data[_277];
    return _278;
}

double e(rgba f, _a2_int64_t g) {
    _a3_bool _0;
    // Computing bound for j
    _0.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    // Computing bound for k
    int64_t _1 = 996;
    _0.d1 = _1;
    if (_1 > 0) 
    goto _jump563;
    fail_assertion("non-positive loop bound");
    _jump563:;
    // Computing bound for l
    _a2_int64_t _2;
    // Computing bound for j
    _2.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing bound for k
    _2.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= g.d0;
    _3 *= g.d0;
    _3 *= sizeof(int64_t);
    _2.data = jpl_alloc(_3);
    int64_t _4 = 0; // k
    int64_t _5 = 0; // j
    _jump566:; // Begin body of loop
    int64_t _6 = 0;
    _6 *= _2.d0;
    _6 += _5;
    _6 *= _2.d1;
    _6 += _4;
    _2.data[_6] = _4;
    _4++;
    if (_4 < g.d0)
    goto _jump566;
    _4 = 0;
    _5++;
    if (_5 < g.d0)
    goto _jump566;
    // End body of loop
    int64_t _7 = -g.d0;
    if (g.d1 >= 0)
    goto _jump567;
    fail_assertion("negative array index");
    _jump567:;
    if (g.d1 < _2.d0)
    goto _jump568;
    fail_assertion("index too large");
    _jump568:;
    if (_7 >= 0)
    goto _jump569;
    fail_assertion("negative array index");
    _jump569:;
    if (_7 < _2.d1)
    goto _jump570;
    fail_assertion("index too large");
    _jump570:;
    int64_t _8 = 0;
    _8 *= _2.d0;
    _8 += g.d1;
    _8 *= _2.d1;
    _8 += _7;
    int64_t _9 = _2.data[_8];
    int64_t _10;
    // Computing bound for j
    int64_t _11 = -g.d1;
    if (_11 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing bound for k
    int64_t _12 = 566;
    if (_12 > 0) 
    goto _jump572;
    fail_assertion("non-positive loop bound");
    _jump572:;
    // Computing bound for l
    int64_t _13 = 55;
    if (_13 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (_13 < g.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    if (g.d0 >= 0)
    goto _jump575;
    fail_assertion("negative array index");
    _jump575:;
    if (g.d0 < g.d1)
    goto _jump576;
    fail_assertion("index too large");
    _jump576:;
    int64_t _14 = 0;
    _14 *= g.d0;
    _14 += _13;
    _14 *= g.d1;
    _14 += g.d0;
    int64_t _15 = g.data[_14];
    if (_15 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    _10 = 0;
    int64_t _16 = 0; // l
    int64_t _17 = 0; // k
    int64_t _18 = 0; // j
    _jump578:; // Begin body of loop
    _10 += g.d0;
    _16++;
    if (_16 < _15)
    goto _jump578;
    _16 = 0;
    _17++;
    if (_17 < _12)
    goto _jump578;
    _17 = 0;
    _18++;
    if (_18 < _11)
    goto _jump578;
    // End body of loop
    int64_t _19 = _9 % _10;
    _0.d2 = _19;
    if (_19 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= g.d0;
    _20 *= _1;
    _20 *= _19;
    _20 *= sizeof(bool);
    _0.data = jpl_alloc(_20);
    int64_t _21 = 0; // l
    int64_t _22 = 0; // k
    int64_t _23 = 0; // j
    _jump580:; // Begin body of loop
    bool _24 = _23 == g.d1;
    bool _25 = !_24;
    int64_t _26 = 0;
    _26 *= _0.d0;
    _26 += _23;
    _26 *= _0.d1;
    _26 += _22;
    _26 *= _0.d2;
    _26 += _21;
    _0.data[_26] = _25;
    _21++;
    if (_21 < _19)
    goto _jump580;
    _21 = 0;
    _22++;
    if (_22 < _1)
    goto _jump580;
    _22 = 0;
    _23++;
    if (_23 < g.d0)
    goto _jump580;
    // End body of loop
    _a3_int64_t _27;
    // Computing bound for j
    int64_t _28 = 652;
    int64_t _29 = 93;
    int64_t _30 = _28 * _29;
    _27.d0 = _30;
    if (_30 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing bound for k
    _27.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    // Computing bound for l
    int64_t _31 = 630;
    int64_t _32 = 884;
    int64_t _33 = 922;
    int64_t _34 = _32 % _33;
    int64_t _35 = _31 + _34;
    _27.d2 = _35;
    if (_35 > 0) 
    goto _jump583;
    fail_assertion("non-positive loop bound");
    _jump583:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _30;
    _36 *= g.d0;
    _36 *= _35;
    _36 *= sizeof(int64_t);
    _27.data = jpl_alloc(_36);
    int64_t _37 = 0; // l
    int64_t _38 = 0; // k
    int64_t _39 = 0; // j
    _jump584:; // Begin body of loop
    int64_t _40 = 0;
    _40 *= _27.d0;
    _40 += _39;
    _40 *= _27.d1;
    _40 += _38;
    _40 *= _27.d2;
    _40 += _37;
    _27.data[_40] = _38;
    _37++;
    if (_37 < _35)
    goto _jump584;
    _37 = 0;
    _38++;
    if (_38 < g.d0)
    goto _jump584;
    _38 = 0;
    _39++;
    if (_39 < _30)
    goto _jump584;
    // End body of loop
    int64_t _41 = 339;
    int64_t _42 = -g.d0;
    if (_41 >= 0)
    goto _jump585;
    fail_assertion("negative array index");
    _jump585:;
    if (_41 < g.d0)
    goto _jump586;
    fail_assertion("index too large");
    _jump586:;
    if (_42 >= 0)
    goto _jump587;
    fail_assertion("negative array index");
    _jump587:;
    if (_42 < g.d1)
    goto _jump588;
    fail_assertion("index too large");
    _jump588:;
    int64_t _43 = 0;
    _43 *= g.d0;
    _43 += _41;
    _43 *= g.d1;
    _43 += _42;
    int64_t _44 = g.data[_43];
    int64_t _46 = 171;
    bool _47 = g.d0 == _46;
    bool _45 = _47;
    if (0 == _47)
    goto _jump589;
    _45 = c;
    _jump589:;
    int64_t _48;
    if (!_45)
    goto _jump590;
    int64_t _49 = -g.d1;
    int64_t _50 = -_49;
    _48 = _50;
    goto _jump591;
    _jump590:;
    _a3_int64_t _51;
    // Computing bound for j
    _51.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    // Computing bound for k
    _51.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump593;
    fail_assertion("non-positive loop bound");
    _jump593:;
    // Computing bound for l
    _51.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= g.d1;
    _52 *= g.d0;
    _52 *= g.d0;
    _52 *= sizeof(int64_t);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // l
    int64_t _54 = 0; // k
    int64_t _55 = 0; // j
    _jump595:; // Begin body of loop
    int64_t _56 = 0;
    _56 *= _51.d0;
    _56 += _55;
    _56 *= _51.d1;
    _56 += _54;
    _56 *= _51.d2;
    _56 += _53;
    _51.data[_56] = g.d1;
    _53++;
    if (_53 < g.d0)
    goto _jump595;
    _53 = 0;
    _54++;
    if (_54 < g.d0)
    goto _jump595;
    _54 = 0;
    _55++;
    if (_55 < g.d1)
    goto _jump595;
    // End body of loop
    if (g.d1 >= 0)
    goto _jump596;
    fail_assertion("negative array index");
    _jump596:;
    if (g.d1 < g.d0)
    goto _jump597;
    fail_assertion("index too large");
    _jump597:;
    if (g.d0 >= 0)
    goto _jump598;
    fail_assertion("negative array index");
    _jump598:;
    if (g.d0 < g.d1)
    goto _jump599;
    fail_assertion("index too large");
    _jump599:;
    int64_t _57 = 0;
    _57 *= g.d0;
    _57 += g.d1;
    _57 *= g.d1;
    _57 += g.d0;
    int64_t _58 = g.data[_57];
    int64_t _59 = 700;
    int64_t _60 = 636;
    if (_58 >= 0)
    goto _jump600;
    fail_assertion("negative array index");
    _jump600:;
    if (_58 < _51.d0)
    goto _jump601;
    fail_assertion("index too large");
    _jump601:;
    if (_59 >= 0)
    goto _jump602;
    fail_assertion("negative array index");
    _jump602:;
    if (_59 < _51.d1)
    goto _jump603;
    fail_assertion("index too large");
    _jump603:;
    if (_60 >= 0)
    goto _jump604;
    fail_assertion("negative array index");
    _jump604:;
    if (_60 < _51.d2)
    goto _jump605;
    fail_assertion("index too large");
    _jump605:;
    int64_t _61 = 0;
    _61 *= _51.d0;
    _61 += _58;
    _61 *= _51.d1;
    _61 += _59;
    _61 *= _51.d2;
    _61 += _60;
    int64_t _62 = _51.data[_61];
    _48 = _62;
    _jump591:;
    int64_t _63 = g.d1 % g.d1;
    int64_t _64 = 294;
    int64_t _65 = 567;
    int64_t _66 = _64 + _65;
    _a1_int64_t _67;
    _67.d0 = 2;
    _67.data = jpl_alloc(sizeof(int64_t) * 2);
    _67.data[0] = _63;
    _67.data[1] = _66;
    int64_t _68;
    if (!c)
    goto _jump606;
    int64_t _69 = -g.d1;
    _68 = _69;
    goto _jump607;
    _jump606:;
    int64_t _70 = g.d0 / g.d0;
    _68 = _70;
    _jump607:;
    if (_68 >= 0)
    goto _jump608;
    fail_assertion("negative array index");
    _jump608:;
    if (_68 < _67.d0)
    goto _jump609;
    fail_assertion("index too large");
    _jump609:;
    int64_t _71 = 0;
    _71 *= _67.d0;
    _71 += _68;
    int64_t _72 = _67.data[_71];
    if (_44 >= 0)
    goto _jump610;
    fail_assertion("negative array index");
    _jump610:;
    if (_44 < _27.d0)
    goto _jump611;
    fail_assertion("index too large");
    _jump611:;
    if (_48 >= 0)
    goto _jump612;
    fail_assertion("negative array index");
    _jump612:;
    if (_48 < _27.d1)
    goto _jump613;
    fail_assertion("index too large");
    _jump613:;
    if (_72 >= 0)
    goto _jump614;
    fail_assertion("negative array index");
    _jump614:;
    if (_72 < _27.d2)
    goto _jump615;
    fail_assertion("index too large");
    _jump615:;
    int64_t _73 = 0;
    _73 *= _27.d0;
    _73 += _44;
    _73 *= _27.d1;
    _73 += _48;
    _73 *= _27.d2;
    _73 += _72;
    int64_t _74 = _27.data[_73];
    int64_t _75 = 609;
    int64_t _76;
    if (!c)
    goto _jump616;
    int64_t _77;
    // Computing bound for j
    int64_t _78 = -g.d0;
    int64_t _79 = -_78;
    if (_79 > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    // Computing bound for k
    if (g.d0 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    _77 = 0;
    int64_t _80 = 0; // k
    int64_t _81 = 0; // j
    _jump619:; // Begin body of loop
    int64_t _82;
    // Computing bound for l
    int64_t _83 = 829;
    int64_t _84 = _83 / g.d1;
    if (_84 > 0) 
    goto _jump620;
    fail_assertion("non-positive loop bound");
    _jump620:;
    _82 = 0;
    int64_t _85 = 0; // l
    _jump621:; // Begin body of loop
    int64_t _86;
    // Computing bound for m
    int64_t _87 = 265;
    if (_87 > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    _86 = 0;
    int64_t _88 = 0; // m
    _jump623:; // Begin body of loop
    int64_t _89 = 616;
    _86 += _89;
    _88++;
    if (_88 < _87)
    goto _jump623;
    // End body of loop
    _82 += _86;
    _85++;
    if (_85 < _84)
    goto _jump621;
    // End body of loop
    _77 += _82;
    _80++;
    if (_80 < g.d0)
    goto _jump619;
    _80 = 0;
    _81++;
    if (_81 < _79)
    goto _jump619;
    // End body of loop
    _76 = _77;
    goto _jump624;
    _jump616:;
    int64_t _90 = 69;
    int64_t _91 = -_90;
    int64_t _92 = g.d1 / _91;
    _76 = _92;
    _jump624:;
    if (_74 >= 0)
    goto _jump625;
    fail_assertion("negative array index");
    _jump625:;
    if (_74 < _0.d0)
    goto _jump626;
    fail_assertion("index too large");
    _jump626:;
    if (_75 >= 0)
    goto _jump627;
    fail_assertion("negative array index");
    _jump627:;
    if (_75 < _0.d1)
    goto _jump628;
    fail_assertion("index too large");
    _jump628:;
    if (_76 >= 0)
    goto _jump629;
    fail_assertion("negative array index");
    _jump629:;
    if (_76 < _0.d2)
    goto _jump630;
    fail_assertion("index too large");
    _jump630:;
    int64_t _93 = 0;
    _93 *= _0.d0;
    _93 += _74;
    _93 *= _0.d1;
    _93 += _75;
    _93 *= _0.d2;
    _93 += _76;
    bool _94 = _0.data[_93];
    _a1__a3_bool _95;
    if (!_94)
    goto _jump631;
    _a1__a3_bool _96;
    // Computing bound for j
    int64_t _97;
    // Computing bound for j
    if (g.d1 >= 0)
    goto _jump632;
    fail_assertion("negative array index");
    _jump632:;
    if (g.d1 < g.d0)
    goto _jump633;
    fail_assertion("index too large");
    _jump633:;
    if (g.d0 >= 0)
    goto _jump634;
    fail_assertion("negative array index");
    _jump634:;
    if (g.d0 < g.d1)
    goto _jump635;
    fail_assertion("index too large");
    _jump635:;
    int64_t _98 = 0;
    _98 *= g.d0;
    _98 += g.d1;
    _98 *= g.d1;
    _98 += g.d0;
    int64_t _99 = g.data[_98];
    int64_t _100 = -_99;
    int64_t _101 = -_100;
    if (_101 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for k
    _a2_int64_t _102;
    // Computing bound for j
    int64_t _103;
    // Computing bound for j
    int64_t _104 = 509;
    if (_104 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for k
    int64_t _105 = 304;
    if (_105 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    _103 = 0;
    int64_t _106 = 0; // k
    int64_t _107 = 0; // j
    _jump639:; // Begin body of loop
    _103 += g.d0;
    _106++;
    if (_106 < _105)
    goto _jump639;
    _106 = 0;
    _107++;
    if (_107 < _104)
    goto _jump639;
    // End body of loop
    _102.d0 = _103;
    if (_103 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for k
    _102.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= _103;
    _108 *= g.d1;
    _108 *= sizeof(int64_t);
    _102.data = jpl_alloc(_108);
    int64_t _109 = 0; // k
    int64_t _110 = 0; // j
    _jump642:; // Begin body of loop
    int64_t _111 = 465;
    int64_t _112 = -_111;
    int64_t _113 = 0;
    _113 *= _102.d0;
    _113 += _110;
    _113 *= _102.d1;
    _113 += _109;
    _102.data[_113] = _112;
    _109++;
    if (_109 < g.d1)
    goto _jump642;
    _109 = 0;
    _110++;
    if (_110 < _103)
    goto _jump642;
    // End body of loop
    int64_t _114 = 557;
    int64_t _115 = g.d0 % g.d1;
    if (_114 >= 0)
    goto _jump643;
    fail_assertion("negative array index");
    _jump643:;
    if (_114 < _102.d0)
    goto _jump644;
    fail_assertion("index too large");
    _jump644:;
    if (_115 >= 0)
    goto _jump645;
    fail_assertion("negative array index");
    _jump645:;
    if (_115 < _102.d1)
    goto _jump646;
    fail_assertion("index too large");
    _jump646:;
    int64_t _116 = 0;
    _116 *= _102.d0;
    _116 += _114;
    _116 *= _102.d1;
    _116 += _115;
    int64_t _117 = _102.data[_116];
    if (_117 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    _97 = 0;
    int64_t _118 = 0; // k
    int64_t _119 = 0; // j
    _jump648:; // Begin body of loop
    _97 += g.d1;
    _118++;
    if (_118 < _117)
    goto _jump648;
    _118 = 0;
    _119++;
    if (_119 < _101)
    goto _jump648;
    // End body of loop
    _96.d0 = _97;
    if (_97 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    // Computing total size of heap memory to allocate
    int64_t _120 = 1;
    _120 *= _97;
    _120 *= sizeof(_a3_bool);
    _96.data = jpl_alloc(_120);
    int64_t _121 = 0; // j
    _jump650:; // Begin body of loop
    _a3_bool _122;
    // Computing bound for k
    int64_t _123 = 696;
    _122.d0 = _123;
    if (_123 > 0) 
    goto _jump651;
    fail_assertion("non-positive loop bound");
    _jump651:;
    // Computing bound for l
    _122.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing bound for m
    int64_t _124 = 175;
    _122.d2 = _124;
    if (_124 > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    // Computing total size of heap memory to allocate
    int64_t _125 = 1;
    _125 *= _123;
    _125 *= g.d1;
    _125 *= _124;
    _125 *= sizeof(bool);
    _122.data = jpl_alloc(_125);
    int64_t _126 = 0; // m
    int64_t _127 = 0; // l
    int64_t _128 = 0; // k
    _jump654:; // Begin body of loop
    bool _129 = false;
    int64_t _130 = 0;
    _130 *= _122.d0;
    _130 += _128;
    _130 *= _122.d1;
    _130 += _127;
    _130 *= _122.d2;
    _130 += _126;
    _122.data[_130] = _129;
    _126++;
    if (_126 < _124)
    goto _jump654;
    _126 = 0;
    _127++;
    if (_127 < g.d1)
    goto _jump654;
    _127 = 0;
    _128++;
    if (_128 < _123)
    goto _jump654;
    // End body of loop
    int64_t _131 = 0;
    _131 *= _96.d0;
    _131 += _121;
    _96.data[_131] = _122;
    _121++;
    if (_121 < _97)
    goto _jump650;
    // End body of loop
    _95 = _96;
    goto _jump655;
    _jump631:;
    _a1__a3_bool _132;
    // Computing bound for j
    _132.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= g.d1;
    _133 *= sizeof(_a3_bool);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // j
    _jump657:; // Begin body of loop
    bool _135 = true;
    _a3_bool _136;
    if (!_135)
    goto _jump658;
    _a3_bool _137;
    // Computing bound for k
    bool _138 = !c;
    int64_t _139;
    if (!_138)
    goto _jump659;
    _139 = g.d0;
    goto _jump660;
    _jump659:;
    int64_t _140;
    // Computing bound for k
    if (g.d1 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    _140 = 0;
    int64_t _141 = 0; // k
    _jump662:; // Begin body of loop
    _140 += g.d0;
    _141++;
    if (_141 < g.d1)
    goto _jump662;
    // End body of loop
    _139 = _140;
    _jump660:;
    _137.d0 = _139;
    if (_139 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing bound for l
    _137.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for m
    _137.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _139;
    _142 *= g.d0;
    _142 *= g.d0;
    _142 *= sizeof(bool);
    _137.data = jpl_alloc(_142);
    int64_t _143 = 0; // m
    int64_t _144 = 0; // l
    int64_t _145 = 0; // k
    _jump666:; // Begin body of loop
    bool _146 = c;
    if (0 == c)
    goto _jump667;
    _146 = c;
    _jump667:;
    int64_t _147 = 0;
    _147 *= _137.d0;
    _147 += _145;
    _147 *= _137.d1;
    _147 += _144;
    _147 *= _137.d2;
    _147 += _143;
    _137.data[_147] = _146;
    _143++;
    if (_143 < g.d0)
    goto _jump666;
    _143 = 0;
    _144++;
    if (_144 < g.d0)
    goto _jump666;
    _144 = 0;
    _145++;
    if (_145 < _139)
    goto _jump666;
    // End body of loop
    _136 = _137;
    goto _jump668;
    _jump658:;
    _a3_bool _148;
    // Computing bound for k
    int64_t _149;
    // Computing bound for k
    if (g.d0 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for l
    if (g.d0 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    _149 = 0;
    int64_t _150 = 0; // l
    int64_t _151 = 0; // k
    _jump671:; // Begin body of loop
    _149 += _150;
    _150++;
    if (_150 < g.d0)
    goto _jump671;
    _150 = 0;
    _151++;
    if (_151 < g.d0)
    goto _jump671;
    // End body of loop
    int64_t _152 = _149 % g.d1;
    _148.d0 = _152;
    if (_152 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing bound for l
    int64_t _153;
    // Computing bound for k
    if (g.d1 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    _153 = 0;
    int64_t _154 = 0; // k
    _jump674:; // Begin body of loop
    _153 += _134;
    _154++;
    if (_154 < g.d1)
    goto _jump674;
    // End body of loop
    bool _155 = true;
    int64_t _156;
    if (!_155)
    goto _jump675;
    int64_t _157 = 881;
    _156 = _157;
    goto _jump676;
    _jump675:;
    _156 = _134;
    _jump676:;
    int64_t _158 = _153 + _156;
    _148.d1 = _158;
    if (_158 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    // Computing bound for m
    _148.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _152;
    _159 *= _158;
    _159 *= g.d1;
    _159 *= sizeof(bool);
    _148.data = jpl_alloc(_159);
    int64_t _160 = 0; // m
    int64_t _161 = 0; // l
    int64_t _162 = 0; // k
    _jump679:; // Begin body of loop
    bool _163 = true;
    bool _164 = _162 != _160;
    bool _165 = _163 == _164;
    int64_t _166 = 0;
    _166 *= _148.d0;
    _166 += _162;
    _166 *= _148.d1;
    _166 += _161;
    _166 *= _148.d2;
    _166 += _160;
    _148.data[_166] = _165;
    _160++;
    if (_160 < g.d1)
    goto _jump679;
    _160 = 0;
    _161++;
    if (_161 < _158)
    goto _jump679;
    _161 = 0;
    _162++;
    if (_162 < _152)
    goto _jump679;
    // End body of loop
    _136 = _148;
    _jump668:;
    int64_t _167 = 0;
    _167 *= _132.d0;
    _167 += _134;
    _132.data[_167] = _136;
    _134++;
    if (_134 < g.d1)
    goto _jump657;
    // End body of loop
    _95 = _132;
    _jump655:;
    if (g.d0 >= 0)
    goto _jump680;
    fail_assertion("negative array index");
    _jump680:;
    if (g.d0 < _95.d0)
    goto _jump681;
    fail_assertion("index too large");
    _jump681:;
    int64_t _168 = 0;
    _168 *= _95.d0;
    _168 += g.d0;
    _a3_bool _169 = _95.data[_168];
    bool _171 = false;
    bool _170 = _171;
    if (0 == _171)
    goto _jump682;
    double _172;
    // Computing bound for n
    if (_169.d1 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    _172 = 0;
    int64_t _173 = 0; // n
    _jump684:; // Begin body of loop
    double _174 = 75.0;
    _172 += _174;
    _173++;
    if (_173 < _169.d1)
    goto _jump684;
    // End body of loop
    double _175;
    // Computing bound for n
    int64_t _176;
    // Computing bound for n
    int64_t _177 = 547;
    if (_177 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing bound for o
    int64_t _178 = -_169.d0;
    if (_178 > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    _176 = 0;
    int64_t _179 = 0; // o
    int64_t _180 = 0; // n
    _jump687:; // Begin body of loop
    _176 += g.d0;
    _179++;
    if (_179 < _178)
    goto _jump687;
    _179 = 0;
    _180++;
    if (_180 < _177)
    goto _jump687;
    // End body of loop
    if (_176 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for o
    int64_t _181 = 347;
    if (_181 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    _175 = 0;
    int64_t _182 = 0; // o
    int64_t _183 = 0; // n
    _jump690:; // Begin body of loop
    double _184 = f.b;
    double _185 = -_184;
    _175 += _185;
    _182++;
    if (_182 < _181)
    goto _jump690;
    _182 = 0;
    _183++;
    if (_183 < _176)
    goto _jump690;
    // End body of loop
    double _186 = e(f, g);
    double _187 = f.r;
    double _188 = _186 - _187;
    int64_t _189 = 949;
    bool _190 = _169.d1 > _189;
    rgba _191;
    if (!_190)
    goto _jump691;
    _191 = f;
    goto _jump692;
    _jump691:;
    _191 = f;
    _jump692:;
    double _192 = _191.a;
    double _193;
    if (!c)
    goto _jump693;
    double _194 = f.g;
    double _195 = -_194;
    _193 = _195;
    goto _jump694;
    _jump693:;
    double _196 = 3.0;
    _193 = _196;
    _jump694:;
    rgba _197 = { _175, _188, _192, _193 };
    double _198 = e(_197, g);
    bool _199 = _172 > _198;
    _170 = _199;
    _jump682:;
    if (0 != _170)
    goto _jump695;
    fail_assertion("n");
    _jump695:;
    bool _201 = !c;
    bool _202 = true;
    bool _203 = _201 == _202;
    bool _204 = !_203;
    bool _200 = _204;
    if (0 != _204)
    goto _jump696;
    bool _205 = false;
    bool _206 = !_205;
    int64_t _207;
    if (!_206)
    goto _jump697;
    _207 = _169.d0;
    goto _jump698;
    _jump697:;
    _207 = _169.d1;
    _jump698:;
    bool _208 = _169.d0 == _207;
    _200 = _208;
    _jump696:;
    _a2_double _209;
    if (!_200)
    goto _jump699;
    _a2_double _210;
    // Computing bound for n
    _210.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump700;
    fail_assertion("non-positive loop bound");
    _jump700:;
    // Computing bound for o
    _210.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= g.d1;
    _211 *= g.d1;
    _211 *= sizeof(double);
    _210.data = jpl_alloc(_211);
    int64_t _212 = 0; // o
    int64_t _213 = 0; // n
    _jump702:; // Begin body of loop
    int64_t _214 = 0;
    _214 *= _210.d0;
    _214 += _213;
    _214 *= _210.d1;
    _214 += _212;
    _210.data[_214] = a;
    _212++;
    if (_212 < g.d1)
    goto _jump702;
    _212 = 0;
    _213++;
    if (_213 < g.d1)
    goto _jump702;
    // End body of loop
    _209 = _210;
    goto _jump703;
    _jump699:;
    _a2_double _215;
    // Computing bound for n
    int64_t _216 = -_169.d2;
    int64_t _217 = -_216;
    _215.d0 = _217;
    if (_217 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for o
    int64_t _218 = -g.d1;
    _215.d1 = _218;
    if (_218 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing total size of heap memory to allocate
    int64_t _219 = 1;
    _219 *= _217;
    _219 *= _218;
    _219 *= sizeof(double);
    _215.data = jpl_alloc(_219);
    int64_t _220 = 0; // o
    int64_t _221 = 0; // n
    _jump706:; // Begin body of loop
    double _222 = -a;
    double _223;
    // Computing bound for p
    if (g.d0 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    _223 = 0;
    int64_t _224 = 0; // p
    _jump708:; // Begin body of loop
    double _225;
    // Computing bound for q
    if (_220 > 0) 
    goto _jump709;
    fail_assertion("non-positive loop bound");
    _jump709:;
    // Computing bound for r
    if (_221 > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing bound for s
    int64_t _226 = _221 * g.d1;
    if (_226 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    _225 = 0;
    int64_t _227 = 0; // s
    int64_t _228 = 0; // r
    int64_t _229 = 0; // q
    _jump712:; // Begin body of loop
    double _230 = e(f, g);
    _225 += _230;
    _227++;
    if (_227 < _226)
    goto _jump712;
    _227 = 0;
    _228++;
    if (_228 < _221)
    goto _jump712;
    _228 = 0;
    _229++;
    if (_229 < _220)
    goto _jump712;
    // End body of loop
    _223 += _225;
    _224++;
    if (_224 < g.d0)
    goto _jump708;
    // End body of loop
    double _231 = fmod(_222, _223);
    int64_t _232 = 0;
    _232 *= _215.d0;
    _232 += _221;
    _232 *= _215.d1;
    _232 += _220;
    _215.data[_232] = _231;
    _220++;
    if (_220 < _218)
    goto _jump706;
    _220 = 0;
    _221++;
    if (_221 < _217)
    goto _jump706;
    // End body of loop
    _209 = _215;
    _jump703:;
    _a1_int64_t _233;
    // Computing bound for n
    bool _234 = !c;
    int64_t _235;
    if (!_234)
    goto _jump713;
    _235 = _169.d1;
    goto _jump714;
    _jump713:;
    int64_t _236 = _169.d2 / _169.d2;
    _235 = _236;
    _jump714:;
    _233.d0 = _235;
    if (_235 > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    // Computing total size of heap memory to allocate
    int64_t _237 = 1;
    _237 *= _235;
    _237 *= sizeof(int64_t);
    _233.data = jpl_alloc(_237);
    int64_t _238 = 0; // n
    _jump716:; // Begin body of loop
    int64_t _239 = 0;
    _239 *= _233.d0;
    _239 += _238;
    _233.data[_239] = _169.d1;
    _238++;
    if (_238 < _235)
    goto _jump716;
    // End body of loop
    if (_169.d1 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (_169.d1 < _233.d0)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    int64_t _240 = 0;
    _240 *= _233.d0;
    _240 += _169.d1;
    int64_t _241 = _233.data[_240];
    bool _242 = _241 == g.d0;
    int64_t _243;
    if (!_242)
    goto _jump719;
    _243 = g.d0;
    goto _jump720;
    _jump719:;
    _243 = g.d1;
    _jump720:;
    int64_t _244;
    // Computing bound for n
    int64_t _245;
    // Computing bound for n
    if (_169.d2 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for o
    if (g.d0 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    _245 = 0;
    int64_t _246 = 0; // o
    int64_t _247 = 0; // n
    _jump723:; // Begin body of loop
    int64_t _248 = 862;
    _245 += _248;
    _246++;
    if (_246 < g.d0)
    goto _jump723;
    _246 = 0;
    _247++;
    if (_247 < _169.d2)
    goto _jump723;
    // End body of loop
    bool _249 = g.d1 > _245;
    double _250;
    if (!_249)
    goto _jump724;
    double _251 = 79.0;
    _a1_double _252;
    _252.d0 = 2;
    _252.data = jpl_alloc(sizeof(double) * 2);
    _252.data[0] = a;
    _252.data[1] = _251;
    if (_169.d0 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_169.d0 < _252.d0)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    int64_t _253 = 0;
    _253 *= _252.d0;
    _253 += _169.d0;
    double _254 = _252.data[_253];
    _250 = _254;
    goto _jump727;
    _jump724:;
    double _255 = 61.0;
    _250 = _255;
    _jump727:;
    double _256;
    // Computing bound for n
    if (_169.d0 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    _256 = 0;
    int64_t _257 = 0; // n
    _jump729:; // Begin body of loop
    _256 += a;
    _257++;
    if (_257 < _169.d0)
    goto _jump729;
    // End body of loop
    double _258 = 69.0;
    double _259 = -_258;
    double _260 = 78.0;
    double _261 = _260 - a;
    double _262 = 6.0;
    rgba _263 = { _256, _259, _261, _262 };
    double _264 = _263.b;
    bool _265 = _250 != _264;
    int64_t _266;
    if (!_265)
    goto _jump730;
    _266 = _169.d1;
    goto _jump731;
    _jump730:;
    _266 = _169.d1;
    _jump731:;
    if (_266 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    // Computing bound for o
    int64_t _267 = -_169.d0;
    if (_267 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    _244 = 0;
    int64_t _268 = 0; // o
    int64_t _269 = 0; // n
    _jump734:; // Begin body of loop
    _244 += g.d1;
    _268++;
    if (_268 < _267)
    goto _jump734;
    _268 = 0;
    _269++;
    if (_269 < _266)
    goto _jump734;
    // End body of loop
    if (_243 >= 0)
    goto _jump735;
    fail_assertion("negative array index");
    _jump735:;
    if (_243 < _209.d0)
    goto _jump736;
    fail_assertion("index too large");
    _jump736:;
    if (_244 >= 0)
    goto _jump737;
    fail_assertion("negative array index");
    _jump737:;
    if (_244 < _209.d1)
    goto _jump738;
    fail_assertion("index too large");
    _jump738:;
    int64_t _270 = 0;
    _270 *= _209.d0;
    _270 += _243;
    _270 *= _209.d1;
    _270 += _244;
    double _271 = _209.data[_270];
    return _271;
    _a1_bool _273;
    // Computing bound for t
    int64_t _274 = 515;
    _273.d0 = _274;
    if (_274 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing total size of heap memory to allocate
    int64_t _275 = 1;
    _275 *= _274;
    _275 *= sizeof(bool);
    _273.data = jpl_alloc(_275);
    int64_t _276 = 0; // t
    _jump740:; // Begin body of loop
    _a1_bool _277;
    // Computing bound for u
    _277.d0 = _169.d2;
    if (_169.d2 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing total size of heap memory to allocate
    int64_t _278 = 1;
    _278 *= _169.d2;
    _278 *= sizeof(bool);
    _277.data = jpl_alloc(_278);
    int64_t _279 = 0; // u
    _jump742:; // Begin body of loop
    bool _280 = false;
    bool _281 = !_280;
    int64_t _282 = 0;
    _282 *= _277.d0;
    _282 += _279;
    _277.data[_282] = _281;
    _279++;
    if (_279 < _169.d2)
    goto _jump742;
    // End body of loop
    if (_169.d1 >= 0)
    goto _jump743;
    fail_assertion("negative array index");
    _jump743:;
    if (_169.d1 < _277.d0)
    goto _jump744;
    fail_assertion("index too large");
    _jump744:;
    int64_t _283 = 0;
    _283 *= _277.d0;
    _283 += _169.d1;
    bool _284 = _277.data[_283];
    int64_t _285 = 0;
    _285 *= _273.d0;
    _285 += _276;
    _273.data[_285] = _284;
    _276++;
    if (_276 < _274)
    goto _jump740;
    // End body of loop
    if (_169.d1 >= 0)
    goto _jump745;
    fail_assertion("negative array index");
    _jump745:;
    if (_169.d1 < _273.d0)
    goto _jump746;
    fail_assertion("index too large");
    _jump746:;
    int64_t _286 = 0;
    _286 *= _273.d0;
    _286 += _169.d1;
    bool _287 = _273.data[_286];
    bool _272 = _287;
    if (0 == _287)
    goto _jump747;
    int64_t _288 = -_169.d1;
    bool _289 = _169.d1 == _288;
    _272 = _289;
    _jump747:;
    double _290;
    if (!_272)
    goto _jump748;
    _a3__a1_double _291;
    // Computing bound for t
    _291.d0 = _169.d1;
    if (_169.d1 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing bound for u
    int64_t _292 = 403;
    _291.d1 = _292;
    if (_292 > 0) 
    goto _jump750;
    fail_assertion("non-positive loop bound");
    _jump750:;
    // Computing bound for v
    _a3_int64_t _293;
    // Computing bound for t
    _293.d0 = _169.d2;
    if (_169.d2 > 0) 
    goto _jump751;
    fail_assertion("non-positive loop bound");
    _jump751:;
    // Computing bound for u
    _293.d1 = _169.d1;
    if (_169.d1 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for v
    _293.d2 = _169.d1;
    if (_169.d1 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing total size of heap memory to allocate
    int64_t _294 = 1;
    _294 *= _169.d2;
    _294 *= _169.d1;
    _294 *= _169.d1;
    _294 *= sizeof(int64_t);
    _293.data = jpl_alloc(_294);
    int64_t _295 = 0; // v
    int64_t _296 = 0; // u
    int64_t _297 = 0; // t
    _jump754:; // Begin body of loop
    int64_t _298 = 0;
    _298 *= _293.d0;
    _298 += _297;
    _298 *= _293.d1;
    _298 += _296;
    _298 *= _293.d2;
    _298 += _295;
    _293.data[_298] = _295;
    _295++;
    if (_295 < _169.d1)
    goto _jump754;
    _295 = 0;
    _296++;
    if (_296 < _169.d1)
    goto _jump754;
    _296 = 0;
    _297++;
    if (_297 < _169.d2)
    goto _jump754;
    // End body of loop
    int64_t _299 = 518;
    int64_t _300 = _169.d0 / _169.d1;
    int64_t _301 = -_300;
    if (_299 >= 0)
    goto _jump755;
    fail_assertion("negative array index");
    _jump755:;
    if (_299 < _293.d0)
    goto _jump756;
    fail_assertion("index too large");
    _jump756:;
    if (g.d1 >= 0)
    goto _jump757;
    fail_assertion("negative array index");
    _jump757:;
    if (g.d1 < _293.d1)
    goto _jump758;
    fail_assertion("index too large");
    _jump758:;
    if (_301 >= 0)
    goto _jump759;
    fail_assertion("negative array index");
    _jump759:;
    if (_301 < _293.d2)
    goto _jump760;
    fail_assertion("index too large");
    _jump760:;
    int64_t _302 = 0;
    _302 *= _293.d0;
    _302 += _299;
    _302 *= _293.d1;
    _302 += g.d1;
    _302 *= _293.d2;
    _302 += _301;
    int64_t _303 = _293.data[_302];
    _291.d2 = _303;
    if (_303 > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    // Computing total size of heap memory to allocate
    int64_t _304 = 1;
    _304 *= _169.d1;
    _304 *= _292;
    _304 *= _303;
    _304 *= sizeof(_a1_double);
    _291.data = jpl_alloc(_304);
    int64_t _305 = 0; // v
    int64_t _306 = 0; // u
    int64_t _307 = 0; // t
    _jump762:; // Begin body of loop
    double _308 = 97.0;
    _a1_double _309;
    _309.d0 = 1;
    _309.data = jpl_alloc(sizeof(double) * 1);
    _309.data[0] = _308;
    _a1__a1_double _310;
    _310.d0 = 1;
    _310.data = jpl_alloc(sizeof(_a1_double) * 1);
    _310.data[0] = _309;
    if (_306 >= 0)
    goto _jump763;
    fail_assertion("negative array index");
    _jump763:;
    if (_306 < _310.d0)
    goto _jump764;
    fail_assertion("index too large");
    _jump764:;
    int64_t _311 = 0;
    _311 *= _310.d0;
    _311 += _306;
    _a1_double _312 = _310.data[_311];
    int64_t _313 = 0;
    _313 *= _291.d0;
    _313 += _307;
    _313 *= _291.d1;
    _313 += _306;
    _313 *= _291.d2;
    _313 += _305;
    _291.data[_313] = _312;
    _305++;
    if (_305 < _303)
    goto _jump762;
    _305 = 0;
    _306++;
    if (_306 < _292)
    goto _jump762;
    _306 = 0;
    _307++;
    if (_307 < _169.d1)
    goto _jump762;
    // End body of loop
    double _314 = f.r;
    bool _315 = false;
    double _316;
    if (!_315)
    goto _jump765;
    _316 = a;
    goto _jump766;
    _jump765:;
    _316 = a;
    _jump766:;
    double _317 = fmod(a, _316);
    bool _318 = _314 != _317;
    int64_t _319;
    if (!_318)
    goto _jump767;
    _319 = _169.d2;
    goto _jump768;
    _jump767:;
    _319 = g.d0;
    _jump768:;
    if (_319 >= 0)
    goto _jump769;
    fail_assertion("negative array index");
    _jump769:;
    if (_319 < _291.d0)
    goto _jump770;
    fail_assertion("index too large");
    _jump770:;
    if (g.d0 >= 0)
    goto _jump771;
    fail_assertion("negative array index");
    _jump771:;
    if (g.d0 < _291.d1)
    goto _jump772;
    fail_assertion("index too large");
    _jump772:;
    if (_169.d2 >= 0)
    goto _jump773;
    fail_assertion("negative array index");
    _jump773:;
    if (_169.d2 < _291.d2)
    goto _jump774;
    fail_assertion("index too large");
    _jump774:;
    int64_t _320 = 0;
    _320 *= _291.d0;
    _320 += _319;
    _320 *= _291.d1;
    _320 += g.d0;
    _320 *= _291.d2;
    _320 += _169.d2;
    _a1_double _321 = _291.data[_320];
    int64_t _322;
    // Computing bound for t
    if (_169.d2 > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    // Computing bound for u
    _a1_int64_t _323;
    if (!c)
    goto _jump776;
    int64_t _324 = 913;
    _a1_int64_t _325;
    _325.d0 = 3;
    _325.data = jpl_alloc(sizeof(int64_t) * 3);
    _325.data[0] = _324;
    _325.data[1] = _169.d0;
    _325.data[2] = _169.d1;
    _323 = _325;
    goto _jump777;
    _jump776:;
    int64_t _326;
    if (!c)
    goto _jump778;
    _326 = _169.d0;
    goto _jump779;
    _jump778:;
    _326 = _169.d2;
    _jump779:;
    _a1_int64_t _327;
    _327.d0 = 3;
    _327.data = jpl_alloc(sizeof(int64_t) * 3);
    _327.data[0] = _169.d1;
    _327.data[1] = _326;
    _327.data[2] = _169.d2;
    _323 = _327;
    _jump777:;
    int64_t _328 = g.d1 * _169.d1;
    if (_328 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_328 < _323.d0)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _329 = 0;
    _329 *= _323.d0;
    _329 += _328;
    int64_t _330 = _323.data[_329];
    if (_330 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    _322 = 0;
    int64_t _331 = 0; // u
    int64_t _332 = 0; // t
    _jump783:; // Begin body of loop
    int64_t _333;
    // Computing bound for v
    int64_t _334 = -_169.d0;
    if (_334 > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    // Computing bound for w
    if (g.d0 > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    // Computing bound for x
    int64_t _335 = -_169.d1;
    if (_335 > 0) 
    goto _jump786;
    fail_assertion("non-positive loop bound");
    _jump786:;
    _333 = 0;
    int64_t _336 = 0; // x
    int64_t _337 = 0; // w
    int64_t _338 = 0; // v
    _jump787:; // Begin body of loop
    _333 += _332;
    _336++;
    if (_336 < _335)
    goto _jump787;
    _336 = 0;
    _337++;
    if (_337 < g.d0)
    goto _jump787;
    _337 = 0;
    _338++;
    if (_338 < _334)
    goto _jump787;
    // End body of loop
    int64_t _339 = -_333;
    _322 += _339;
    _331++;
    if (_331 < _330)
    goto _jump783;
    _331 = 0;
    _332++;
    if (_332 < _169.d2)
    goto _jump783;
    // End body of loop
    if (_322 >= 0)
    goto _jump788;
    fail_assertion("negative array index");
    _jump788:;
    if (_322 < _321.d0)
    goto _jump789;
    fail_assertion("index too large");
    _jump789:;
    int64_t _340 = 0;
    _340 *= _321.d0;
    _340 += _322;
    double _341 = _321.data[_340];
    _290 = _341;
    goto _jump790;
    _jump748:;
    double _342 = 54.0;
    _290 = _342;
    _jump790:;
    return _290;
}

void jpl_main(struct args args) {
    _a3_rgba _0;
    // Computing bound for a
    _a3__a1_int64_t _1;
    // Computing bound for a
    int64_t _2 = 909;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing bound for b
    int64_t _3 = 485;
    _1.d1 = _3;
    if (_3 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for c
    int64_t _4;
    // Computing bound for a
    int64_t _5 = 244;
    if (_5 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing bound for b
    int64_t _6 = 616;
    if (_6 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    // Computing bound for c
    int64_t _7 = 357;
    if (_7 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    _4 = 0;
    int64_t _8 = 0; // c
    int64_t _9 = 0; // b
    int64_t _10 = 0; // a
    _jump6:; // Begin body of loop
    _4 += _10;
    _8++;
    if (_8 < _7)
    goto _jump6;
    _8 = 0;
    _9++;
    if (_9 < _6)
    goto _jump6;
    _9 = 0;
    _10++;
    if (_10 < _5)
    goto _jump6;
    // End body of loop
    _1.d2 = _4;
    if (_4 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= _2;
    _11 *= _3;
    _11 *= _4;
    _11 *= sizeof(_a1_int64_t);
    _1.data = jpl_alloc(_11);
    int64_t _12 = 0; // c
    int64_t _13 = 0; // b
    int64_t _14 = 0; // a
    _jump8:; // Begin body of loop
    int64_t _15 = 912;
    _a1_int64_t _16;
    _16.d0 = 2;
    _16.data = jpl_alloc(sizeof(int64_t) * 2);
    _16.data[0] = _12;
    _16.data[1] = _15;
    int64_t _17 = 0;
    _17 *= _1.d0;
    _17 += _14;
    _17 *= _1.d1;
    _17 += _13;
    _17 *= _1.d2;
    _17 += _12;
    _1.data[_17] = _16;
    _12++;
    if (_12 < _4)
    goto _jump8;
    _12 = 0;
    _13++;
    if (_13 < _3)
    goto _jump8;
    _13 = 0;
    _14++;
    if (_14 < _2)
    goto _jump8;
    // End body of loop
    int64_t _18 = 667;
    int64_t _19 = -_18;
    int64_t _20 = 150;
    int64_t _21 = -_20;
    int64_t _22 = 278;
    int64_t _23 = -_22;
    int64_t _24 = -_23;
    if (_19 >= 0)
    goto _jump9;
    fail_assertion("negative array index");
    _jump9:;
    if (_19 < _1.d0)
    goto _jump10;
    fail_assertion("index too large");
    _jump10:;
    if (_21 >= 0)
    goto _jump11;
    fail_assertion("negative array index");
    _jump11:;
    if (_21 < _1.d1)
    goto _jump12;
    fail_assertion("index too large");
    _jump12:;
    if (_24 >= 0)
    goto _jump13;
    fail_assertion("negative array index");
    _jump13:;
    if (_24 < _1.d2)
    goto _jump14;
    fail_assertion("index too large");
    _jump14:;
    int64_t _25 = 0;
    _25 *= _1.d0;
    _25 += _19;
    _25 *= _1.d1;
    _25 += _21;
    _25 *= _1.d2;
    _25 += _24;
    _a1_int64_t _26 = _1.data[_25];
    int64_t _27;
    // Computing bound for a
    int64_t _28;
    // Computing bound for a
    int64_t _29 = 263;
    int64_t _30 = -_29;
    if (_30 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    // Computing bound for b
    int64_t _31 = 939;
    if (_31 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    // Computing bound for c
    int64_t _32 = 215;
    int64_t _33 = -_32;
    if (_33 > 0) 
    goto _jump17;
    fail_assertion("non-positive loop bound");
    _jump17:;
    _28 = 0;
    int64_t _34 = 0; // c
    int64_t _35 = 0; // b
    int64_t _36 = 0; // a
    _jump18:; // Begin body of loop
    int64_t _37;
    // Computing bound for d
    if (_36 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    // Computing bound for e
    if (_35 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    // Computing bound for f
    if (_36 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    _37 = 0;
    int64_t _38 = 0; // f
    int64_t _39 = 0; // e
    int64_t _40 = 0; // d
    _jump22:; // Begin body of loop
    int64_t _41 = 992;
    _37 += _41;
    _38++;
    if (_38 < _36)
    goto _jump22;
    _38 = 0;
    _39++;
    if (_39 < _35)
    goto _jump22;
    _39 = 0;
    _40++;
    if (_40 < _36)
    goto _jump22;
    // End body of loop
    _28 += _37;
    _34++;
    if (_34 < _33)
    goto _jump18;
    _34 = 0;
    _35++;
    if (_35 < _31)
    goto _jump18;
    _35 = 0;
    _36++;
    if (_36 < _30)
    goto _jump18;
    // End body of loop
    if (_28 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    // Computing bound for b
    int64_t _42;
    // Computing bound for a
    int64_t _43 = 769;
    if (_43 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    // Computing bound for b
    int64_t _44 = 867;
    if (_44 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for c
    int64_t _45 = 205;
    int64_t _46 = -_45;
    if (_46 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    _42 = 0;
    int64_t _47 = 0; // c
    int64_t _48 = 0; // b
    int64_t _49 = 0; // a
    _jump27:; // Begin body of loop
    int64_t _50 = -_49;
    _42 += _50;
    _47++;
    if (_47 < _46)
    goto _jump27;
    _47 = 0;
    _48++;
    if (_48 < _44)
    goto _jump27;
    _48 = 0;
    _49++;
    if (_49 < _43)
    goto _jump27;
    // End body of loop
    if (_42 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    _27 = 0;
    int64_t _51 = 0; // b
    int64_t _52 = 0; // a
    _jump29:; // Begin body of loop
    int64_t _53;
    // Computing bound for c
    int64_t _54 = 541;
    if (_54 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    // Computing bound for d
    if (_51 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    _53 = 0;
    int64_t _55 = 0; // d
    int64_t _56 = 0; // c
    _jump32:; // Begin body of loop
    _53 += _52;
    _55++;
    if (_55 < _51)
    goto _jump32;
    _55 = 0;
    _56++;
    if (_56 < _54)
    goto _jump32;
    // End body of loop
    _27 += _53;
    _51++;
    if (_51 < _42)
    goto _jump29;
    _51 = 0;
    _52++;
    if (_52 < _28)
    goto _jump29;
    // End body of loop
    if (_27 >= 0)
    goto _jump33;
    fail_assertion("negative array index");
    _jump33:;
    if (_27 < _26.d0)
    goto _jump34;
    fail_assertion("index too large");
    _jump34:;
    int64_t _57 = 0;
    _57 *= _26.d0;
    _57 += _27;
    int64_t _58 = _26.data[_57];
    _0.d0 = _58;
    if (_58 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for b
    int64_t _59 = 50;
    int64_t _60 = 138;
    int64_t _61 = -_60;
    bool _62 = _59 > _61;
    bool _63;
    if (!_62)
    goto _jump36;
    bool _64 = true;
    _63 = _64;
    goto _jump37;
    _jump36:;
    bool _65 = true;
    _63 = _65;
    _jump37:;
    int64_t _66;
    if (!_63)
    goto _jump38;
    int64_t _67;
    // Computing bound for a
    int64_t _68;
    // Computing bound for a
    int64_t _69 = 451;
    int64_t _70 = 471;
    int64_t _71 = _69 + _70;
    if (_71 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    // Computing bound for b
    int64_t _72;
    // Computing bound for a
    int64_t _73 = 292;
    if (_73 > 0) 
    goto _jump40;
    fail_assertion("non-positive loop bound");
    _jump40:;
    _72 = 0;
    int64_t _74 = 0; // a
    _jump41:; // Begin body of loop
    _72 += _74;
    _74++;
    if (_74 < _73)
    goto _jump41;
    // End body of loop
    if (_72 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    _68 = 0;
    int64_t _75 = 0; // b
    int64_t _76 = 0; // a
    _jump43:; // Begin body of loop
    int64_t _77 = 607;
    _68 += _77;
    _75++;
    if (_75 < _72)
    goto _jump43;
    _75 = 0;
    _76++;
    if (_76 < _71)
    goto _jump43;
    // End body of loop
    if (_68 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    _67 = 0;
    int64_t _78 = 0; // a
    _jump45:; // Begin body of loop
    int64_t _79 = -_78;
    _67 += _79;
    _78++;
    if (_78 < _68)
    goto _jump45;
    // End body of loop
    _66 = _67;
    goto _jump46;
    _jump38:;
    int64_t _80 = 212;
    int64_t _81 = -_80;
    int64_t _82 = -_81;
    _66 = _82;
    _jump46:;
    _0.d1 = _66;
    if (_66 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    // Computing bound for c
    _a3_int64_t _83;
    // Computing bound for a
    int64_t _84 = 249;
    _83.d0 = _84;
    if (_84 > 0) 
    goto _jump48;
    fail_assertion("non-positive loop bound");
    _jump48:;
    // Computing bound for b
    int64_t _85;
    // Computing bound for a
    int64_t _86 = 715;
    if (_86 > 0) 
    goto _jump49;
    fail_assertion("non-positive loop bound");
    _jump49:;
    // Computing bound for b
    int64_t _87 = 492;
    int64_t _88 = -_87;
    if (_88 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    // Computing bound for c
    int64_t _89 = 182;
    int64_t _90 = -_89;
    if (_90 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    _85 = 0;
    int64_t _91 = 0; // c
    int64_t _92 = 0; // b
    int64_t _93 = 0; // a
    _jump52:; // Begin body of loop
    int64_t _94 = 865;
    _85 += _94;
    _91++;
    if (_91 < _90)
    goto _jump52;
    _91 = 0;
    _92++;
    if (_92 < _88)
    goto _jump52;
    _92 = 0;
    _93++;
    if (_93 < _86)
    goto _jump52;
    // End body of loop
    _83.d1 = _85;
    if (_85 > 0) 
    goto _jump53;
    fail_assertion("non-positive loop bound");
    _jump53:;
    // Computing bound for c
    int64_t _95;
    // Computing bound for a
    int64_t _96 = 566;
    if (_96 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for b
    int64_t _97 = 274;
    if (_97 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    _95 = 0;
    int64_t _98 = 0; // b
    int64_t _99 = 0; // a
    _jump56:; // Begin body of loop
    int64_t _100;
    // Computing bound for c
    if (_99 > 0) 
    goto _jump57;
    fail_assertion("non-positive loop bound");
    _jump57:;
    // Computing bound for d
    int64_t _101 = 381;
    if (_101 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    _100 = 0;
    int64_t _102 = 0; // d
    int64_t _103 = 0; // c
    _jump59:; // Begin body of loop
    _100 += _103;
    _102++;
    if (_102 < _101)
    goto _jump59;
    _102 = 0;
    _103++;
    if (_103 < _99)
    goto _jump59;
    // End body of loop
    _95 += _100;
    _98++;
    if (_98 < _97)
    goto _jump56;
    _98 = 0;
    _99++;
    if (_99 < _96)
    goto _jump56;
    // End body of loop
    _83.d2 = _95;
    if (_95 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= _84;
    _104 *= _85;
    _104 *= _95;
    _104 *= sizeof(int64_t);
    _83.data = jpl_alloc(_104);
    int64_t _105 = 0; // c
    int64_t _106 = 0; // b
    int64_t _107 = 0; // a
    _jump61:; // Begin body of loop
    int64_t _108 = 0;
    _108 *= _83.d0;
    _108 += _107;
    _108 *= _83.d1;
    _108 += _106;
    _108 *= _83.d2;
    _108 += _105;
    _83.data[_108] = _106;
    _105++;
    if (_105 < _95)
    goto _jump61;
    _105 = 0;
    _106++;
    if (_106 < _85)
    goto _jump61;
    _106 = 0;
    _107++;
    if (_107 < _84)
    goto _jump61;
    // End body of loop
    _a2_int64_t _109;
    // Computing bound for a
    int64_t _110 = 810;
    _109.d0 = _110;
    if (_110 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    // Computing bound for b
    int64_t _111 = 1000;
    _109.d1 = _111;
    if (_111 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _110;
    _112 *= _111;
    _112 *= sizeof(int64_t);
    _109.data = jpl_alloc(_112);
    int64_t _113 = 0; // b
    int64_t _114 = 0; // a
    _jump64:; // Begin body of loop
    int64_t _115 = 470;
    int64_t _116 = 0;
    _116 *= _109.d0;
    _116 += _114;
    _116 *= _109.d1;
    _116 += _113;
    _109.data[_116] = _115;
    _113++;
    if (_113 < _111)
    goto _jump64;
    _113 = 0;
    _114++;
    if (_114 < _110)
    goto _jump64;
    // End body of loop
    int64_t _117 = 755;
    int64_t _118;
    // Computing bound for a
    int64_t _119 = 888;
    if (_119 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    _118 = 0;
    int64_t _120 = 0; // a
    _jump66:; // Begin body of loop
    _118 += _120;
    _120++;
    if (_120 < _119)
    goto _jump66;
    // End body of loop
    int64_t _121;
    // Computing bound for a
    int64_t _122 = 237;
    if (_122 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    _121 = 0;
    int64_t _123 = 0; // a
    _jump68:; // Begin body of loop
    int64_t _124 = 891;
    _121 += _124;
    _123++;
    if (_123 < _122)
    goto _jump68;
    // End body of loop
    int64_t _125 = _118 - _121;
    if (_117 >= 0)
    goto _jump69;
    fail_assertion("negative array index");
    _jump69:;
    if (_117 < _109.d0)
    goto _jump70;
    fail_assertion("index too large");
    _jump70:;
    if (_125 >= 0)
    goto _jump71;
    fail_assertion("negative array index");
    _jump71:;
    if (_125 < _109.d1)
    goto _jump72;
    fail_assertion("index too large");
    _jump72:;
    int64_t _126 = 0;
    _126 *= _109.d0;
    _126 += _117;
    _126 *= _109.d1;
    _126 += _125;
    int64_t _127 = _109.data[_126];
    int64_t _128 = 891;
    int64_t _129 = -_128;
    int64_t _130;
    // Computing bound for a
    int64_t _131 = 914;
    if (_131 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing bound for b
    int64_t _132 = 819;
    if (_132 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    // Computing bound for c
    int64_t _133 = 354;
    if (_133 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    _130 = 0;
    int64_t _134 = 0; // c
    int64_t _135 = 0; // b
    int64_t _136 = 0; // a
    _jump76:; // Begin body of loop
    _130 += _134;
    _134++;
    if (_134 < _133)
    goto _jump76;
    _134 = 0;
    _135++;
    if (_135 < _132)
    goto _jump76;
    _135 = 0;
    _136++;
    if (_136 < _131)
    goto _jump76;
    // End body of loop
    if (_127 >= 0)
    goto _jump77;
    fail_assertion("negative array index");
    _jump77:;
    if (_127 < _83.d0)
    goto _jump78;
    fail_assertion("index too large");
    _jump78:;
    if (_129 >= 0)
    goto _jump79;
    fail_assertion("negative array index");
    _jump79:;
    if (_129 < _83.d1)
    goto _jump80;
    fail_assertion("index too large");
    _jump80:;
    if (_130 >= 0)
    goto _jump81;
    fail_assertion("negative array index");
    _jump81:;
    if (_130 < _83.d2)
    goto _jump82;
    fail_assertion("index too large");
    _jump82:;
    int64_t _137 = 0;
    _137 *= _83.d0;
    _137 += _127;
    _137 *= _83.d1;
    _137 += _129;
    _137 *= _83.d2;
    _137 += _130;
    int64_t _138 = _83.data[_137];
    _0.d2 = _138;
    if (_138 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= _58;
    _139 *= _66;
    _139 *= _138;
    _139 *= sizeof(rgba);
    _0.data = jpl_alloc(_139);
    int64_t _140 = 0; // c
    int64_t _141 = 0; // b
    int64_t _142 = 0; // a
    _jump84:; // Begin body of loop
    double _143 = 96.0;
    double _144 = 67.0;
    bool _145 = _143 < _144;
    rgba _146;
    if (!_145)
    goto _jump85;
    double _147 = 42.0;
    double _148 = 47.0;
    double _149 = -_148;
    double _150 = 27.0;
    double _151;
    // Computing bound for d
    if (_140 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    // Computing bound for e
    int64_t _152 = 990;
    if (_152 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    // Computing bound for f
    if (_141 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    _151 = 0;
    int64_t _153 = 0; // f
    int64_t _154 = 0; // e
    int64_t _155 = 0; // d
    _jump89:; // Begin body of loop
    double _156 = 80.0;
    _151 += _156;
    _153++;
    if (_153 < _141)
    goto _jump89;
    _153 = 0;
    _154++;
    if (_154 < _152)
    goto _jump89;
    _154 = 0;
    _155++;
    if (_155 < _140)
    goto _jump89;
    // End body of loop
    double _157 = _150 / _151;
    double _158 = 46.0;
    rgba _159 = { _147, _149, _157, _158 };
    _146 = _159;
    goto _jump90;
    _jump85:;
    double _160;
    // Computing bound for d
    if (_140 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for e
    int64_t _161 = 835;
    if (_161 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    _160 = 0;
    int64_t _162 = 0; // e
    int64_t _163 = 0; // d
    _jump93:; // Begin body of loop
    bool _164 = true;
    double _165;
    if (!_164)
    goto _jump94;
    double _166 = 32.0;
    _165 = _166;
    goto _jump95;
    _jump94:;
    double _167 = 29.0;
    _165 = _167;
    _jump95:;
    _160 += _165;
    _162++;
    if (_162 < _161)
    goto _jump93;
    _162 = 0;
    _163++;
    if (_163 < _140)
    goto _jump93;
    // End body of loop
    double _168 = 97.0;
    _a3_double _169;
    // Computing bound for d
    _169.d0 = _142;
    if (_142 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing bound for e
    int64_t _170 = 51;
    _169.d1 = _170;
    if (_170 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing bound for f
    _169.d2 = _141;
    if (_141 > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _142;
    _171 *= _170;
    _171 *= _141;
    _171 *= sizeof(double);
    _169.data = jpl_alloc(_171);
    int64_t _172 = 0; // f
    int64_t _173 = 0; // e
    int64_t _174 = 0; // d
    _jump99:; // Begin body of loop
    double _175 = 51.0;
    int64_t _176 = 0;
    _176 *= _169.d0;
    _176 += _174;
    _176 *= _169.d1;
    _176 += _173;
    _176 *= _169.d2;
    _176 += _172;
    _169.data[_176] = _175;
    _172++;
    if (_172 < _141)
    goto _jump99;
    _172 = 0;
    _173++;
    if (_173 < _170)
    goto _jump99;
    _173 = 0;
    _174++;
    if (_174 < _142)
    goto _jump99;
    // End body of loop
    bool _177 = true;
    int64_t _178;
    if (!_177)
    goto _jump100;
    _178 = _140;
    goto _jump101;
    _jump100:;
    _178 = _141;
    _jump101:;
    int64_t _179 = 195;
    if (_142 >= 0)
    goto _jump102;
    fail_assertion("negative array index");
    _jump102:;
    if (_142 < _169.d0)
    goto _jump103;
    fail_assertion("index too large");
    _jump103:;
    if (_178 >= 0)
    goto _jump104;
    fail_assertion("negative array index");
    _jump104:;
    if (_178 < _169.d1)
    goto _jump105;
    fail_assertion("index too large");
    _jump105:;
    if (_179 >= 0)
    goto _jump106;
    fail_assertion("negative array index");
    _jump106:;
    if (_179 < _169.d2)
    goto _jump107;
    fail_assertion("index too large");
    _jump107:;
    int64_t _180 = 0;
    _180 *= _169.d0;
    _180 += _142;
    _180 *= _169.d1;
    _180 += _178;
    _180 *= _169.d2;
    _180 += _179;
    double _181 = _169.data[_180];
    double _182;
    // Computing bound for d
    int64_t _183 = -_140;
    if (_183 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    _182 = 0;
    int64_t _184 = 0; // d
    _jump109:; // Begin body of loop
    double _185 = 86.0;
    _182 += _185;
    _184++;
    if (_184 < _183)
    goto _jump109;
    // End body of loop
    rgba _186 = { _160, _168, _181, _182 };
    _146 = _186;
    _jump90:;
    int64_t _187 = 0;
    _187 *= _0.d0;
    _187 += _142;
    _187 *= _0.d1;
    _187 += _141;
    _187 *= _0.d2;
    _187 += _140;
    _0.data[_187] = _146;
    _140++;
    if (_140 < _138)
    goto _jump84;
    _140 = 0;
    _141++;
    if (_141 < _66)
    goto _jump84;
    _141 = 0;
    _142++;
    if (_142 < _58)
    goto _jump84;
    // End body of loop
    int64_t _188;
    // Computing bound for a
    int64_t _189;
    // Computing bound for a
    bool _190 = false;
    int64_t _191;
    if (!_190)
    goto _jump110;
    int64_t _192 = 619;
    int64_t _193 = -_192;
    int64_t _194 = 859;
    int64_t _195 = -_194;
    int64_t _196 = _193 * _195;
    _191 = _196;
    goto _jump111;
    _jump110:;
    _a1_int64_t _197;
    // Computing bound for a
    int64_t _198 = 985;
    _197.d0 = _198;
    if (_198 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= _198;
    _199 *= sizeof(int64_t);
    _197.data = jpl_alloc(_199);
    int64_t _200 = 0; // a
    _jump113:; // Begin body of loop
    int64_t _201 = 832;
    int64_t _202 = 0;
    _202 *= _197.d0;
    _202 += _200;
    _197.data[_202] = _201;
    _200++;
    if (_200 < _198)
    goto _jump113;
    // End body of loop
    int64_t _203 = 913;
    if (_203 >= 0)
    goto _jump114;
    fail_assertion("negative array index");
    _jump114:;
    if (_203 < _197.d0)
    goto _jump115;
    fail_assertion("index too large");
    _jump115:;
    int64_t _204 = 0;
    _204 *= _197.d0;
    _204 += _203;
    int64_t _205 = _197.data[_204];
    _191 = _205;
    _jump111:;
    if (_191 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _189 = 0;
    int64_t _206 = 0; // a
    _jump117:; // Begin body of loop
    int64_t _207 = 816;
    _189 += _207;
    _206++;
    if (_206 < _191)
    goto _jump117;
    // End body of loop
    if (_189 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    _188 = 0;
    int64_t _208 = 0; // a
    _jump119:; // Begin body of loop
    _a3_int64_t _209;
    // Computing bound for b
    _209.d0 = _208;
    if (_208 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    // Computing bound for c
    int64_t _210 = 516;
    _209.d1 = _210;
    if (_210 > 0) 
    goto _jump121;
    fail_assertion("non-positive loop bound");
    _jump121:;
    // Computing bound for d
    _209.d2 = _208;
    if (_208 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= _208;
    _211 *= _210;
    _211 *= _208;
    _211 *= sizeof(int64_t);
    _209.data = jpl_alloc(_211);
    int64_t _212 = 0; // d
    int64_t _213 = 0; // c
    int64_t _214 = 0; // b
    _jump123:; // Begin body of loop
    int64_t _215 = 13;
    int64_t _216 = 0;
    _216 *= _209.d0;
    _216 += _214;
    _216 *= _209.d1;
    _216 += _213;
    _216 *= _209.d2;
    _216 += _212;
    _209.data[_216] = _215;
    _212++;
    if (_212 < _208)
    goto _jump123;
    _212 = 0;
    _213++;
    if (_213 < _210)
    goto _jump123;
    _213 = 0;
    _214++;
    if (_214 < _208)
    goto _jump123;
    // End body of loop
    int64_t _217;
    // Computing bound for b
    int64_t _218 = 204;
    int64_t _219 = _208 + _218;
    if (_219 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    // Computing bound for c
    int64_t _220 = 772;
    if (_220 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    _217 = 0;
    int64_t _221 = 0; // c
    int64_t _222 = 0; // b
    _jump126:; // Begin body of loop
    int64_t _223 = 232;
    _217 += _223;
    _221++;
    if (_221 < _220)
    goto _jump126;
    _221 = 0;
    _222++;
    if (_222 < _219)
    goto _jump126;
    // End body of loop
    int64_t _224 = -_208;
    int64_t _225 = 554;
    int64_t _226 = _208 - _225;
    int64_t _227;
    // Computing bound for b
    int64_t _228 = 705;
    if (_228 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for c
    if (_208 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    _227 = 0;
    int64_t _229 = 0; // c
    int64_t _230 = 0; // b
    _jump129:; // Begin body of loop
    int64_t _231 = 637;
    _227 += _231;
    _229++;
    if (_229 < _208)
    goto _jump129;
    _229 = 0;
    _230++;
    if (_230 < _228)
    goto _jump129;
    // End body of loop
    int64_t _232 = _226 / _227;
    if (_217 >= 0)
    goto _jump130;
    fail_assertion("negative array index");
    _jump130:;
    if (_217 < _209.d0)
    goto _jump131;
    fail_assertion("index too large");
    _jump131:;
    if (_224 >= 0)
    goto _jump132;
    fail_assertion("negative array index");
    _jump132:;
    if (_224 < _209.d1)
    goto _jump133;
    fail_assertion("index too large");
    _jump133:;
    if (_232 >= 0)
    goto _jump134;
    fail_assertion("negative array index");
    _jump134:;
    if (_232 < _209.d2)
    goto _jump135;
    fail_assertion("index too large");
    _jump135:;
    int64_t _233 = 0;
    _233 *= _209.d0;
    _233 += _217;
    _233 *= _209.d1;
    _233 += _224;
    _233 *= _209.d2;
    _233 += _232;
    int64_t _234 = _209.data[_233];
    int64_t _235 = -_234;
    _188 += _235;
    _208++;
    if (_208 < _189)
    goto _jump119;
    // End body of loop
    double _236 = 93.0;
    double _237 = 79.0;
    bool _238 = _236 < _237;
    bool _239;
    if (!_238)
    goto _jump136;
    bool _240 = false;
    bool _241 = !_240;
    _239 = _241;
    goto _jump137;
    _jump136:;
    bool _242 = true;
    bool _243 = !_242;
    double _244 = 17.0;
    double _245 = 29.0;
    bool _246 = _244 >= _245;
    bool _247 = _243 != _246;
    _239 = _247;
    _jump137:;
    int64_t _248;
    if (!_239)
    goto _jump138;
    int64_t _249;
    // Computing bound for a
    int64_t _250 = 365;
    if (_250 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing bound for b
    int64_t _251 = 7;
    int64_t _252 = -_251;
    int64_t _253 = 298;
    int64_t _254 = _252 * _253;
    if (_254 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing bound for c
    int64_t _255;
    // Computing bound for a
    int64_t _256 = 125;
    int64_t _257 = 589;
    int64_t _258 = _256 - _257;
    if (_258 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    _255 = 0;
    int64_t _259 = 0; // a
    _jump142:; // Begin body of loop
    _255 += _259;
    _259++;
    if (_259 < _258)
    goto _jump142;
    // End body of loop
    if (_255 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    _249 = 0;
    int64_t _260 = 0; // c
    int64_t _261 = 0; // b
    int64_t _262 = 0; // a
    _jump144:; // Begin body of loop
    int64_t _263 = 345;
    _249 += _263;
    _260++;
    if (_260 < _255)
    goto _jump144;
    _260 = 0;
    _261++;
    if (_261 < _254)
    goto _jump144;
    _261 = 0;
    _262++;
    if (_262 < _250)
    goto _jump144;
    // End body of loop
    _248 = _249;
    goto _jump145;
    _jump138:;
    int64_t _264 = 891;
    int64_t _265 = -_264;
    int64_t _266 = 324;
    int64_t _267 = -_266;
    int64_t _268 = _265 % _267;
    int64_t _269 = -_268;
    _248 = _269;
    _jump145:;
    int64_t _270 = -_248;
    bool _271 = true;
    bool _272 = !_271;
    bool _273 = !_272;
    int64_t _274;
    if (!_273)
    goto _jump146;
    int64_t _275 = 615;
    _274 = _275;
    goto _jump147;
    _jump146:;
    int64_t _276;
    // Computing bound for a
    int64_t _277 = 424;
    if (_277 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    _276 = 0;
    int64_t _278 = 0; // a
    _jump149:; // Begin body of loop
    int64_t _279 = 538;
    _276 += _279;
    _278++;
    if (_278 < _277)
    goto _jump149;
    // End body of loop
    _274 = _276;
    _jump147:;
    int64_t _280 = -_274;
    bool _281 = false;
    bool _282 = true;
    bool _283 = !_282;
    bool _284 = _281 != _283;
    _a1_int64_t _285;
    if (!_284)
    goto _jump150;
    _a1_int64_t _286;
    // Computing bound for a
    int64_t _287 = 305;
    _286.d0 = _287;
    if (_287 > 0) 
    goto _jump151;
    fail_assertion("non-positive loop bound");
    _jump151:;
    // Computing total size of heap memory to allocate
    int64_t _288 = 1;
    _288 *= _287;
    _288 *= sizeof(int64_t);
    _286.data = jpl_alloc(_288);
    int64_t _289 = 0; // a
    _jump152:; // Begin body of loop
    bool _290 = true;
    int64_t _291;
    if (!_290)
    goto _jump153;
    int64_t _292 = 369;
    _291 = _292;
    goto _jump154;
    _jump153:;
    int64_t _293 = 466;
    _291 = _293;
    _jump154:;
    int64_t _294 = 0;
    _294 *= _286.d0;
    _294 += _289;
    _286.data[_294] = _291;
    _289++;
    if (_289 < _287)
    goto _jump152;
    // End body of loop
    _285 = _286;
    goto _jump155;
    _jump150:;
    int64_t _295 = 329;
    int64_t _296 = -_295;
    _a1_int64_t _297;
    _297.d0 = 1;
    _297.data = jpl_alloc(sizeof(int64_t) * 1);
    _297.data[0] = _296;
    _285 = _297;
    _jump155:;
    _a2_int64_t _298;
    // Computing bound for a
    int64_t _299 = 662;
    int64_t _300 = 481;
    int64_t _301 = _299 - _300;
    _298.d0 = _301;
    if (_301 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing bound for b
    int64_t _302 = 61;
    _298.d1 = _302;
    if (_302 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= _301;
    _303 *= _302;
    _303 *= sizeof(int64_t);
    _298.data = jpl_alloc(_303);
    int64_t _304 = 0; // b
    int64_t _305 = 0; // a
    _jump158:; // Begin body of loop
    int64_t _306 = 0;
    _306 *= _298.d0;
    _306 += _305;
    _306 *= _298.d1;
    _306 += _304;
    _298.data[_306] = _305;
    _304++;
    if (_304 < _302)
    goto _jump158;
    _304 = 0;
    _305++;
    if (_305 < _301)
    goto _jump158;
    // End body of loop
    int64_t _307 = 352;
    int64_t _308 = 805;
    if (_307 >= 0)
    goto _jump159;
    fail_assertion("negative array index");
    _jump159:;
    if (_307 < _298.d0)
    goto _jump160;
    fail_assertion("index too large");
    _jump160:;
    if (_308 >= 0)
    goto _jump161;
    fail_assertion("negative array index");
    _jump161:;
    if (_308 < _298.d1)
    goto _jump162;
    fail_assertion("index too large");
    _jump162:;
    int64_t _309 = 0;
    _309 *= _298.d0;
    _309 += _307;
    _309 *= _298.d1;
    _309 += _308;
    int64_t _310 = _298.data[_309];
    if (_310 >= 0)
    goto _jump163;
    fail_assertion("negative array index");
    _jump163:;
    if (_310 < _285.d0)
    goto _jump164;
    fail_assertion("index too large");
    _jump164:;
    int64_t _311 = 0;
    _311 *= _285.d0;
    _311 += _310;
    int64_t _312 = _285.data[_311];
    int64_t _313 = _280 - _312;
    if (_188 >= 0)
    goto _jump165;
    fail_assertion("negative array index");
    _jump165:;
    if (_188 < _0.d0)
    goto _jump166;
    fail_assertion("index too large");
    _jump166:;
    if (_270 >= 0)
    goto _jump167;
    fail_assertion("negative array index");
    _jump167:;
    if (_270 < _0.d1)
    goto _jump168;
    fail_assertion("index too large");
    _jump168:;
    if (_313 >= 0)
    goto _jump169;
    fail_assertion("negative array index");
    _jump169:;
    if (_313 < _0.d2)
    goto _jump170;
    fail_assertion("index too large");
    _jump170:;
    int64_t _314 = 0;
    _314 *= _0.d0;
    _314 += _188;
    _314 *= _0.d1;
    _314 += _270;
    _314 *= _0.d2;
    _314 += _313;
    rgba _315 = _0.data[_314];
    double _316 = _315.a;
    _a3_bool _318;
    // Computing bound for c
    int64_t _319 = 895;
    _318.d0 = _319;
    if (_319 > 0) 
    goto _jump379;
    fail_assertion("non-positive loop bound");
    _jump379:;
    // Computing bound for d
    int64_t _320 = 325;
    int64_t _321 = 918;
    int64_t _322 = -_321;
    int64_t _323 = _320 % _322;
    _318.d1 = _323;
    if (_323 > 0) 
    goto _jump380;
    fail_assertion("non-positive loop bound");
    _jump380:;
    // Computing bound for e
    int64_t _324 = 283;
    _318.d2 = _324;
    if (_324 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= _319;
    _325 *= _323;
    _325 *= _324;
    _325 *= sizeof(bool);
    _318.data = jpl_alloc(_325);
    int64_t _326 = 0; // e
    int64_t _327 = 0; // d
    int64_t _328 = 0; // c
    _jump382:; // Begin body of loop
    double _329 = -_316;
    double _330;
    // Computing bound for f
    if (_326 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    _330 = 0;
    int64_t _331 = 0; // f
    _jump384:; // Begin body of loop
    double _332 = 39.0;
    _330 += _332;
    _331++;
    if (_331 < _326)
    goto _jump384;
    // End body of loop
    bool _333 = _329 != _330;
    int64_t _334 = 0;
    _334 *= _318.d0;
    _334 += _328;
    _334 *= _318.d1;
    _334 += _327;
    _334 *= _318.d2;
    _334 += _326;
    _318.data[_334] = _333;
    _326++;
    if (_326 < _324)
    goto _jump382;
    _326 = 0;
    _327++;
    if (_327 < _323)
    goto _jump382;
    _327 = 0;
    _328++;
    if (_328 < _319)
    goto _jump382;
    // End body of loop
    _a1__a3_bool _335;
    _335.d0 = 1;
    _335.data = jpl_alloc(sizeof(_a3_bool) * 1);
    _335.data[0] = _318;
    int64_t _336;
    // Computing bound for c
    int64_t _337 = 122;
    if (_337 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    _336 = 0;
    int64_t _338 = 0; // c
    _jump386:; // Begin body of loop
    _a3_int64_t _339;
    // Computing bound for d
    int64_t _340 = 777;
    _339.d0 = _340;
    if (_340 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    // Computing bound for e
    _339.d1 = _338;
    if (_338 > 0) 
    goto _jump388;
    fail_assertion("non-positive loop bound");
    _jump388:;
    // Computing bound for f
    _339.d2 = _338;
    if (_338 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing total size of heap memory to allocate
    int64_t _341 = 1;
    _341 *= _340;
    _341 *= _338;
    _341 *= _338;
    _341 *= sizeof(int64_t);
    _339.data = jpl_alloc(_341);
    int64_t _342 = 0; // f
    int64_t _343 = 0; // e
    int64_t _344 = 0; // d
    _jump390:; // Begin body of loop
    int64_t _345 = _343 % _338;
    int64_t _346 = 0;
    _346 *= _339.d0;
    _346 += _344;
    _346 *= _339.d1;
    _346 += _343;
    _346 *= _339.d2;
    _346 += _342;
    _339.data[_346] = _345;
    _342++;
    if (_342 < _338)
    goto _jump390;
    _342 = 0;
    _343++;
    if (_343 < _338)
    goto _jump390;
    _343 = 0;
    _344++;
    if (_344 < _340)
    goto _jump390;
    // End body of loop
    int64_t _347;
    // Computing bound for d
    if (_338 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for e
    int64_t _348 = 765;
    int64_t _349 = -_348;
    if (_349 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing bound for f
    if (_338 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    _347 = 0;
    int64_t _350 = 0; // f
    int64_t _351 = 0; // e
    int64_t _352 = 0; // d
    _jump394:; // Begin body of loop
    _347 += _350;
    _350++;
    if (_350 < _338)
    goto _jump394;
    _350 = 0;
    _351++;
    if (_351 < _349)
    goto _jump394;
    _351 = 0;
    _352++;
    if (_352 < _338)
    goto _jump394;
    // End body of loop
    int64_t _353 = 457;
    if (_338 >= 0)
    goto _jump395;
    fail_assertion("negative array index");
    _jump395:;
    if (_338 < _339.d0)
    goto _jump396;
    fail_assertion("index too large");
    _jump396:;
    if (_347 >= 0)
    goto _jump397;
    fail_assertion("negative array index");
    _jump397:;
    if (_347 < _339.d1)
    goto _jump398;
    fail_assertion("index too large");
    _jump398:;
    if (_353 >= 0)
    goto _jump399;
    fail_assertion("negative array index");
    _jump399:;
    if (_353 < _339.d2)
    goto _jump400;
    fail_assertion("index too large");
    _jump400:;
    int64_t _354 = 0;
    _354 *= _339.d0;
    _354 += _338;
    _354 *= _339.d1;
    _354 += _347;
    _354 *= _339.d2;
    _354 += _353;
    int64_t _355 = _339.data[_354];
    _336 += _355;
    _338++;
    if (_338 < _337)
    goto _jump386;
    // End body of loop
    if (_336 >= 0)
    goto _jump401;
    fail_assertion("negative array index");
    _jump401:;
    if (_336 < _335.d0)
    goto _jump402;
    fail_assertion("index too large");
    _jump402:;
    int64_t _356 = 0;
    _356 *= _335.d0;
    _356 += _336;
    _a3_bool _357 = _335.data[_356];
    int64_t _358 = 604;
    bool _360 = _316 > _316;
    bool _359 = _360;
    if (0 != _360)
    goto _jump403;
    bool _361 = true;
    _359 = _361;
    _jump403:;
    double _363 = 42.0;
    bool _364 = _363 > _316;
    bool _362 = _364;
    if (0 != _364)
    goto _jump404;
    bool _365 = true;
    bool _366 = !_365;
    _362 = _366;
    _jump404:;
    bool _367 = _359 != _362;
    int64_t _368;
    if (!_367)
    goto _jump405;
    int64_t _369 = 462;
    int64_t _370 = 736;
    int64_t _371 = _369 + _370;
    bool _372 = false;
    int64_t _373;
    if (!_372)
    goto _jump406;
    int64_t _374;
    // Computing bound for c
    int64_t _375 = 238;
    if (_375 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    _374 = 0;
    int64_t _376 = 0; // c
    _jump408:; // Begin body of loop
    _374 += _376;
    _376++;
    if (_376 < _375)
    goto _jump408;
    // End body of loop
    _373 = _374;
    goto _jump409;
    _jump406:;
    bool _377 = true;
    int64_t _378;
    if (!_377)
    goto _jump410;
    int64_t _379 = 18;
    _378 = _379;
    goto _jump411;
    _jump410:;
    int64_t _380 = 464;
    _378 = _380;
    _jump411:;
    _373 = _378;
    _jump409:;
    int64_t _381 = _371 / _373;
    _368 = _381;
    goto _jump412;
    _jump405:;
    int64_t _382 = 507;
    _368 = _382;
    _jump412:;
    int64_t _383 = -_368;
    int64_t _384;
    // Computing bound for c
    bool _385 = true;
    bool _386;
    if (!_385)
    goto _jump413;
    double _387 = 40.0;
    bool _388 = _316 == _387;
    _386 = _388;
    goto _jump414;
    _jump413:;
    bool _389 = true;
    _386 = _389;
    _jump414:;
    bool _390 = !_386;
    int64_t _391;
    if (!_390)
    goto _jump415;
    int64_t _392 = 735;
    int64_t _393 = -_392;
    int64_t _394;
    // Computing bound for c
    int64_t _395 = 476;
    int64_t _396 = -_395;
    if (_396 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for d
    int64_t _397 = 887;
    int64_t _398 = -_397;
    if (_398 > 0) 
    goto _jump417;
    fail_assertion("non-positive loop bound");
    _jump417:;
    // Computing bound for e
    int64_t _399 = 154;
    int64_t _400 = -_399;
    if (_400 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    _394 = 0;
    int64_t _401 = 0; // e
    int64_t _402 = 0; // d
    int64_t _403 = 0; // c
    _jump419:; // Begin body of loop
    _394 += _401;
    _401++;
    if (_401 < _400)
    goto _jump419;
    _401 = 0;
    _402++;
    if (_402 < _398)
    goto _jump419;
    _402 = 0;
    _403++;
    if (_403 < _396)
    goto _jump419;
    // End body of loop
    int64_t _404 = _393 + _394;
    _391 = _404;
    goto _jump420;
    _jump415:;
    int64_t _405 = 441;
    _391 = _405;
    _jump420:;
    if (_391 > 0) 
    goto _jump421;
    fail_assertion("non-positive loop bound");
    _jump421:;
    // Computing bound for d
    int64_t _406;
    // Computing bound for c
    bool _407 = true;
    int64_t _408;
    if (!_407)
    goto _jump422;
    int64_t _409;
    // Computing bound for c
    int64_t _410 = 77;
    if (_410 > 0) 
    goto _jump423;
    fail_assertion("non-positive loop bound");
    _jump423:;
    // Computing bound for d
    int64_t _411 = 32;
    if (_411 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing bound for e
    int64_t _412 = 530;
    if (_412 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    _409 = 0;
    int64_t _413 = 0; // e
    int64_t _414 = 0; // d
    int64_t _415 = 0; // c
    _jump426:; // Begin body of loop
    _409 += _413;
    _413++;
    if (_413 < _412)
    goto _jump426;
    _413 = 0;
    _414++;
    if (_414 < _411)
    goto _jump426;
    _414 = 0;
    _415++;
    if (_415 < _410)
    goto _jump426;
    // End body of loop
    int64_t _416 = 986;
    int64_t _417 = _409 - _416;
    _408 = _417;
    goto _jump427;
    _jump422:;
    int64_t _418 = 424;
    int64_t _419 = 850;
    int64_t _420 = _418 * _419;
    int64_t _421 = 373;
    int64_t _422 = -_421;
    int64_t _423 = _420 + _422;
    _408 = _423;
    _jump427:;
    if (_408 > 0) 
    goto _jump428;
    fail_assertion("non-positive loop bound");
    _jump428:;
    // Computing bound for d
    int64_t _424 = 214;
    int64_t _425 = -_424;
    if (_425 > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    _406 = 0;
    int64_t _426 = 0; // d
    int64_t _427 = 0; // c
    _jump430:; // Begin body of loop
    _406 += _427;
    _426++;
    if (_426 < _425)
    goto _jump430;
    _426 = 0;
    _427++;
    if (_427 < _408)
    goto _jump430;
    // End body of loop
    if (_406 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    _384 = 0;
    int64_t _428 = 0; // d
    int64_t _429 = 0; // c
    _jump432:; // Begin body of loop
    _384 += _429;
    _428++;
    if (_428 < _406)
    goto _jump432;
    _428 = 0;
    _429++;
    if (_429 < _391)
    goto _jump432;
    // End body of loop
    if (_358 >= 0)
    goto _jump433;
    fail_assertion("negative array index");
    _jump433:;
    if (_358 < _357.d0)
    goto _jump434;
    fail_assertion("index too large");
    _jump434:;
    if (_383 >= 0)
    goto _jump435;
    fail_assertion("negative array index");
    _jump435:;
    if (_383 < _357.d1)
    goto _jump436;
    fail_assertion("index too large");
    _jump436:;
    if (_384 >= 0)
    goto _jump437;
    fail_assertion("negative array index");
    _jump437:;
    if (_384 < _357.d2)
    goto _jump438;
    fail_assertion("index too large");
    _jump438:;
    int64_t _430 = 0;
    _430 *= _357.d0;
    _430 += _358;
    _430 *= _357.d1;
    _430 += _383;
    _430 *= _357.d2;
    _430 += _384;
    bool _431 = _357.data[_430];
    bool _317 = _431;
    if (0 == _431)
    goto _jump439;
    double _432 = 45.0;
    bool _433 = _432 > _316;
    bool _434 = false;
    bool _435 = _433 == _434;
    double _436 = 84.0;
    bool _437 = _316 < _436;
    bool _438 = _435 != _437;
    bool _439;
    if (!_438)
    goto _jump440;
    bool _440 = true;
    _439 = _440;
    goto _jump441;
    _jump440:;
    _a3_bool _441;
    // Computing bound for c
    int64_t _442 = 155;
    int64_t _443 = 561;
    int64_t _444 = _442 % _443;
    _441.d0 = _444;
    if (_444 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    // Computing bound for d
    int64_t _445 = 344;
    _441.d1 = _445;
    if (_445 > 0) 
    goto _jump443;
    fail_assertion("non-positive loop bound");
    _jump443:;
    // Computing bound for e
    int64_t _446 = 220;
    _441.d2 = _446;
    if (_446 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= _444;
    _447 *= _445;
    _447 *= _446;
    _447 *= sizeof(bool);
    _441.data = jpl_alloc(_447);
    int64_t _448 = 0; // e
    int64_t _449 = 0; // d
    int64_t _450 = 0; // c
    _jump445:; // Begin body of loop
    double _451 = 41.0;
    bool _452 = _316 >= _451;
    int64_t _453 = 0;
    _453 *= _441.d0;
    _453 += _450;
    _453 *= _441.d1;
    _453 += _449;
    _453 *= _441.d2;
    _453 += _448;
    _441.data[_453] = _452;
    _448++;
    if (_448 < _446)
    goto _jump445;
    _448 = 0;
    _449++;
    if (_449 < _445)
    goto _jump445;
    _449 = 0;
    _450++;
    if (_450 < _444)
    goto _jump445;
    // End body of loop
    int64_t _454;
    // Computing bound for c
    int64_t _455 = 131;
    int64_t _456 = -_455;
    if (_456 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    _454 = 0;
    int64_t _457 = 0; // c
    _jump447:; // Begin body of loop
    int64_t _458 = -_457;
    _454 += _458;
    _457++;
    if (_457 < _456)
    goto _jump447;
    // End body of loop
    int64_t _459 = 108;
    int64_t _460 = 763;
    if (_454 >= 0)
    goto _jump448;
    fail_assertion("negative array index");
    _jump448:;
    if (_454 < _441.d0)
    goto _jump449;
    fail_assertion("index too large");
    _jump449:;
    if (_459 >= 0)
    goto _jump450;
    fail_assertion("negative array index");
    _jump450:;
    if (_459 < _441.d1)
    goto _jump451;
    fail_assertion("index too large");
    _jump451:;
    if (_460 >= 0)
    goto _jump452;
    fail_assertion("negative array index");
    _jump452:;
    if (_460 < _441.d2)
    goto _jump453;
    fail_assertion("index too large");
    _jump453:;
    int64_t _461 = 0;
    _461 *= _441.d0;
    _461 += _454;
    _461 *= _441.d1;
    _461 += _459;
    _461 *= _441.d2;
    _461 += _460;
    bool _462 = _441.data[_461];
    _439 = _462;
    _jump441:;
    _a2_bool _463;
    if (!_439)
    goto _jump454;
    _a1__a2_bool _464;
    // Computing bound for c
    int64_t _465 = 688;
    int64_t _466 = -_465;
    int64_t _467 = -_466;
    _464.d0 = _467;
    if (_467 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing total size of heap memory to allocate
    int64_t _468 = 1;
    _468 *= _467;
    _468 *= sizeof(_a2_bool);
    _464.data = jpl_alloc(_468);
    int64_t _469 = 0; // c
    _jump456:; // Begin body of loop
    _a2_bool _470;
    // Computing bound for d
    int64_t _471 = 523;
    int64_t _472 = -_471;
    _470.d0 = _472;
    if (_472 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    // Computing bound for e
    int64_t _473;
    // Computing bound for d
    if (_469 > 0) 
    goto _jump458;
    fail_assertion("non-positive loop bound");
    _jump458:;
    // Computing bound for e
    int64_t _474 = 431;
    if (_474 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    // Computing bound for f
    if (_469 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    _473 = 0;
    int64_t _475 = 0; // f
    int64_t _476 = 0; // e
    int64_t _477 = 0; // d
    _jump461:; // Begin body of loop
    _473 += _476;
    _475++;
    if (_475 < _469)
    goto _jump461;
    _475 = 0;
    _476++;
    if (_476 < _474)
    goto _jump461;
    _476 = 0;
    _477++;
    if (_477 < _469)
    goto _jump461;
    // End body of loop
    _470.d1 = _473;
    if (_473 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing total size of heap memory to allocate
    int64_t _478 = 1;
    _478 *= _472;
    _478 *= _473;
    _478 *= sizeof(bool);
    _470.data = jpl_alloc(_478);
    int64_t _479 = 0; // e
    int64_t _480 = 0; // d
    _jump463:; // Begin body of loop
    bool _481 = false;
    int64_t _482 = 0;
    _482 *= _470.d0;
    _482 += _480;
    _482 *= _470.d1;
    _482 += _479;
    _470.data[_482] = _481;
    _479++;
    if (_479 < _473)
    goto _jump463;
    _479 = 0;
    _480++;
    if (_480 < _472)
    goto _jump463;
    // End body of loop
    int64_t _483 = 0;
    _483 *= _464.d0;
    _483 += _469;
    _464.data[_483] = _470;
    _469++;
    if (_469 < _467)
    goto _jump456;
    // End body of loop
    _a2_int64_t _484;
    // Computing bound for c
    int64_t _485 = 719;
    _484.d0 = _485;
    if (_485 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing bound for d
    int64_t _486 = 470;
    int64_t _487 = -_486;
    _484.d1 = _487;
    if (_487 > 0) 
    goto _jump465;
    fail_assertion("non-positive loop bound");
    _jump465:;
    // Computing total size of heap memory to allocate
    int64_t _488 = 1;
    _488 *= _485;
    _488 *= _487;
    _488 *= sizeof(int64_t);
    _484.data = jpl_alloc(_488);
    int64_t _489 = 0; // d
    int64_t _490 = 0; // c
    _jump466:; // Begin body of loop
    int64_t _491 = -_489;
    int64_t _492 = 0;
    _492 *= _484.d0;
    _492 += _490;
    _492 *= _484.d1;
    _492 += _489;
    _484.data[_492] = _491;
    _489++;
    if (_489 < _487)
    goto _jump466;
    _489 = 0;
    _490++;
    if (_490 < _485)
    goto _jump466;
    // End body of loop
    int64_t _493 = 959;
    int64_t _494;
    // Computing bound for c
    int64_t _495 = 190;
    if (_495 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing bound for d
    int64_t _496 = 260;
    if (_496 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for e
    int64_t _497 = 742;
    if (_497 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    _494 = 0;
    int64_t _498 = 0; // e
    int64_t _499 = 0; // d
    int64_t _500 = 0; // c
    _jump470:; // Begin body of loop
    _494 += _498;
    _498++;
    if (_498 < _497)
    goto _jump470;
    _498 = 0;
    _499++;
    if (_499 < _496)
    goto _jump470;
    _499 = 0;
    _500++;
    if (_500 < _495)
    goto _jump470;
    // End body of loop
    int64_t _501 = _493 % _494;
    int64_t _502 = 998;
    int64_t _503 = -_502;
    if (_501 >= 0)
    goto _jump471;
    fail_assertion("negative array index");
    _jump471:;
    if (_501 < _484.d0)
    goto _jump472;
    fail_assertion("index too large");
    _jump472:;
    if (_503 >= 0)
    goto _jump473;
    fail_assertion("negative array index");
    _jump473:;
    if (_503 < _484.d1)
    goto _jump474;
    fail_assertion("index too large");
    _jump474:;
    int64_t _504 = 0;
    _504 *= _484.d0;
    _504 += _501;
    _504 *= _484.d1;
    _504 += _503;
    int64_t _505 = _484.data[_504];
    if (_505 >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (_505 < _464.d0)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    int64_t _506 = 0;
    _506 *= _464.d0;
    _506 += _505;
    _a2_bool _507 = _464.data[_506];
    _463 = _507;
    goto _jump477;
    _jump454:;
    _a2_bool _508;
    // Computing bound for c
    int64_t _509 = 119;
    _508.d0 = _509;
    if (_509 > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    // Computing bound for d
    int64_t _510 = 185;
    _a1_int64_t _511;
    _511.d0 = 1;
    _511.data = jpl_alloc(sizeof(int64_t) * 1);
    _511.data[0] = _510;
    int64_t _512 = 391;
    int64_t _513 = 792;
    _a1_int64_t _514;
    _514.d0 = 2;
    _514.data = jpl_alloc(sizeof(int64_t) * 2);
    _514.data[0] = _512;
    _514.data[1] = _513;
    int64_t _515;
    // Computing bound for c
    int64_t _516 = 664;
    if (_516 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing bound for d
    int64_t _517 = 381;
    if (_517 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    _515 = 0;
    int64_t _518 = 0; // d
    int64_t _519 = 0; // c
    _jump481:; // Begin body of loop
    int64_t _520 = 440;
    _515 += _520;
    _518++;
    if (_518 < _517)
    goto _jump481;
    _518 = 0;
    _519++;
    if (_519 < _516)
    goto _jump481;
    // End body of loop
    if (_515 >= 0)
    goto _jump482;
    fail_assertion("negative array index");
    _jump482:;
    if (_515 < _514.d0)
    goto _jump483;
    fail_assertion("index too large");
    _jump483:;
    int64_t _521 = 0;
    _521 *= _514.d0;
    _521 += _515;
    int64_t _522 = _514.data[_521];
    if (_522 >= 0)
    goto _jump484;
    fail_assertion("negative array index");
    _jump484:;
    if (_522 < _511.d0)
    goto _jump485;
    fail_assertion("index too large");
    _jump485:;
    int64_t _523 = 0;
    _523 *= _511.d0;
    _523 += _522;
    int64_t _524 = _511.data[_523];
    _508.d1 = _524;
    if (_524 > 0) 
    goto _jump486;
    fail_assertion("non-positive loop bound");
    _jump486:;
    // Computing total size of heap memory to allocate
    int64_t _525 = 1;
    _525 *= _509;
    _525 *= _524;
    _525 *= sizeof(bool);
    _508.data = jpl_alloc(_525);
    int64_t _526 = 0; // d
    int64_t _527 = 0; // c
    _jump487:; // Begin body of loop
    _a2_bool _528;
    // Computing bound for e
    int64_t _529 = 920;
    _528.d0 = _529;
    if (_529 > 0) 
    goto _jump488;
    fail_assertion("non-positive loop bound");
    _jump488:;
    // Computing bound for f
    _528.d1 = _526;
    if (_526 > 0) 
    goto _jump489;
    fail_assertion("non-positive loop bound");
    _jump489:;
    // Computing total size of heap memory to allocate
    int64_t _530 = 1;
    _530 *= _529;
    _530 *= _526;
    _530 *= sizeof(bool);
    _528.data = jpl_alloc(_530);
    int64_t _531 = 0; // f
    int64_t _532 = 0; // e
    _jump490:; // Begin body of loop
    bool _533 = true;
    int64_t _534 = 0;
    _534 *= _528.d0;
    _534 += _532;
    _534 *= _528.d1;
    _534 += _531;
    _528.data[_534] = _533;
    _531++;
    if (_531 < _526)
    goto _jump490;
    _531 = 0;
    _532++;
    if (_532 < _529)
    goto _jump490;
    // End body of loop
    int64_t _535 = 572;
    int64_t _536 = _535 / _526;
    if (_526 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_526 < _528.d0)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_536 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_536 < _528.d1)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    int64_t _537 = 0;
    _537 *= _528.d0;
    _537 += _526;
    _537 *= _528.d1;
    _537 += _536;
    bool _538 = _528.data[_537];
    int64_t _539 = 0;
    _539 *= _508.d0;
    _539 += _527;
    _539 *= _508.d1;
    _539 += _526;
    _508.data[_539] = _538;
    _526++;
    if (_526 < _524)
    goto _jump487;
    _526 = 0;
    _527++;
    if (_527 < _509)
    goto _jump487;
    // End body of loop
    _463 = _508;
    _jump477:;
    _a3_bool _540;
    // Computing bound for c
    int64_t _541 = 624;
    int64_t _542 = -_541;
    _540.d0 = _542;
    if (_542 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing bound for d
    int64_t _543 = 224;
    _540.d1 = _543;
    if (_543 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing bound for e
    int64_t _544 = 97;
    _540.d2 = _544;
    if (_544 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing total size of heap memory to allocate
    int64_t _545 = 1;
    _545 *= _542;
    _545 *= _543;
    _545 *= _544;
    _545 *= sizeof(bool);
    _540.data = jpl_alloc(_545);
    int64_t _546 = 0; // e
    int64_t _547 = 0; // d
    int64_t _548 = 0; // c
    _jump498:; // Begin body of loop
    bool _549 = false;
    int64_t _550 = 0;
    _550 *= _540.d0;
    _550 += _548;
    _550 *= _540.d1;
    _550 += _547;
    _550 *= _540.d2;
    _550 += _546;
    _540.data[_550] = _549;
    _546++;
    if (_546 < _544)
    goto _jump498;
    _546 = 0;
    _547++;
    if (_547 < _543)
    goto _jump498;
    _547 = 0;
    _548++;
    if (_548 < _542)
    goto _jump498;
    // End body of loop
    _a2_int64_t _551;
    // Computing bound for c
    int64_t _552 = 112;
    _551.d0 = _552;
    if (_552 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing bound for d
    int64_t _553 = 649;
    _551.d1 = _553;
    if (_553 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    // Computing total size of heap memory to allocate
    int64_t _554 = 1;
    _554 *= _552;
    _554 *= _553;
    _554 *= sizeof(int64_t);
    _551.data = jpl_alloc(_554);
    int64_t _555 = 0; // d
    int64_t _556 = 0; // c
    _jump501:; // Begin body of loop
    int64_t _557 = 0;
    _557 *= _551.d0;
    _557 += _556;
    _557 *= _551.d1;
    _557 += _555;
    _551.data[_557] = _555;
    _555++;
    if (_555 < _553)
    goto _jump501;
    _555 = 0;
    _556++;
    if (_556 < _552)
    goto _jump501;
    // End body of loop
    int64_t _558 = 797;
    int64_t _559 = 915;
    int64_t _560 = _558 * _559;
    int64_t _561 = 243;
    if (_560 >= 0)
    goto _jump502;
    fail_assertion("negative array index");
    _jump502:;
    if (_560 < _551.d0)
    goto _jump503;
    fail_assertion("index too large");
    _jump503:;
    if (_561 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (_561 < _551.d1)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    int64_t _562 = 0;
    _562 *= _551.d0;
    _562 += _560;
    _562 *= _551.d1;
    _562 += _561;
    int64_t _563 = _551.data[_562];
    int64_t _564 = 712;
    int64_t _565;
    // Computing bound for c
    int64_t _566 = 906;
    if (_566 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for d
    int64_t _567 = 380;
    int64_t _568 = 621;
    int64_t _569 = _567 / _568;
    if (_569 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    _565 = 0;
    int64_t _570 = 0; // d
    int64_t _571 = 0; // c
    _jump508:; // Begin body of loop
    int64_t _572 = 697;
    int64_t _573 = _572 / _570;
    _565 += _573;
    _570++;
    if (_570 < _569)
    goto _jump508;
    _570 = 0;
    _571++;
    if (_571 < _566)
    goto _jump508;
    // End body of loop
    if (_563 >= 0)
    goto _jump509;
    fail_assertion("negative array index");
    _jump509:;
    if (_563 < _540.d0)
    goto _jump510;
    fail_assertion("index too large");
    _jump510:;
    if (_564 >= 0)
    goto _jump511;
    fail_assertion("negative array index");
    _jump511:;
    if (_564 < _540.d1)
    goto _jump512;
    fail_assertion("index too large");
    _jump512:;
    if (_565 >= 0)
    goto _jump513;
    fail_assertion("negative array index");
    _jump513:;
    if (_565 < _540.d2)
    goto _jump514;
    fail_assertion("index too large");
    _jump514:;
    int64_t _574 = 0;
    _574 *= _540.d0;
    _574 += _563;
    _574 *= _540.d1;
    _574 += _564;
    _574 *= _540.d2;
    _574 += _565;
    bool _575 = _540.data[_574];
    bool _576 = !_575;
    int64_t _577;
    if (!_576)
    goto _jump515;
    _a1_int64_t _578;
    // Computing bound for c
    int64_t _579 = 297;
    _578.d0 = _579;
    if (_579 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing total size of heap memory to allocate
    int64_t _580 = 1;
    _580 *= _579;
    _580 *= sizeof(int64_t);
    _578.data = jpl_alloc(_580);
    int64_t _581 = 0; // c
    _jump517:; // Begin body of loop
    int64_t _582 = 840;
    int64_t _583 = 827;
    int64_t _584 = _582 + _583;
    int64_t _585 = 408;
    int64_t _586 = _584 - _585;
    int64_t _587 = 0;
    _587 *= _578.d0;
    _587 += _581;
    _578.data[_587] = _586;
    _581++;
    if (_581 < _579)
    goto _jump517;
    // End body of loop
    int64_t _588 = 940;
    int64_t _589 = -_588;
    int64_t _590 = 926;
    int64_t _591 = -_590;
    int64_t _592 = _589 - _591;
    int64_t _593 = -_592;
    if (_593 >= 0)
    goto _jump518;
    fail_assertion("negative array index");
    _jump518:;
    if (_593 < _578.d0)
    goto _jump519;
    fail_assertion("index too large");
    _jump519:;
    int64_t _594 = 0;
    _594 *= _578.d0;
    _594 += _593;
    int64_t _595 = _578.data[_594];
    _577 = _595;
    goto _jump520;
    _jump515:;
    int64_t _596 = 314;
    _577 = _596;
    _jump520:;
    int64_t _597 = 860;
    int64_t _598 = 274;
    bool _599 = _597 >= _598;
    bool _600 = false;
    bool _601 = _599 == _600;
    bool _602;
    if (!_601)
    goto _jump521;
    double _603 = 35.0;
    double _604 = 35.0;
    bool _605 = _603 > _604;
    _602 = _605;
    goto _jump522;
    _jump521:;
    bool _606 = false;
    bool _607 = !_606;
    _602 = _607;
    _jump522:;
    _a3_int64_t _608;
    if (!_602)
    goto _jump523;
    _a3_int64_t _609;
    // Computing bound for c
    bool _610 = false;
    int64_t _611;
    if (!_610)
    goto _jump524;
    int64_t _612 = 850;
    int64_t _613 = 817;
    int64_t _614 = _612 * _613;
    _611 = _614;
    goto _jump525;
    _jump524:;
    int64_t _615 = 554;
    _611 = _615;
    _jump525:;
    _609.d0 = _611;
    if (_611 > 0) 
    goto _jump526;
    fail_assertion("non-positive loop bound");
    _jump526:;
    // Computing bound for d
    int64_t _616 = 178;
    _609.d1 = _616;
    if (_616 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing bound for e
    int64_t _617 = 197;
    _609.d2 = _617;
    if (_617 > 0) 
    goto _jump528;
    fail_assertion("non-positive loop bound");
    _jump528:;
    // Computing total size of heap memory to allocate
    int64_t _618 = 1;
    _618 *= _611;
    _618 *= _616;
    _618 *= _617;
    _618 *= sizeof(int64_t);
    _609.data = jpl_alloc(_618);
    int64_t _619 = 0; // e
    int64_t _620 = 0; // d
    int64_t _621 = 0; // c
    _jump529:; // Begin body of loop
    int64_t _622 = 0;
    _622 *= _609.d0;
    _622 += _621;
    _622 *= _609.d1;
    _622 += _620;
    _622 *= _609.d2;
    _622 += _619;
    _609.data[_622] = _621;
    _619++;
    if (_619 < _617)
    goto _jump529;
    _619 = 0;
    _620++;
    if (_620 < _616)
    goto _jump529;
    _620 = 0;
    _621++;
    if (_621 < _611)
    goto _jump529;
    // End body of loop
    _608 = _609;
    goto _jump530;
    _jump523:;
    _a3_int64_t _623;
    // Computing bound for c
    int64_t _624 = 134;
    _623.d0 = _624;
    if (_624 > 0) 
    goto _jump531;
    fail_assertion("non-positive loop bound");
    _jump531:;
    // Computing bound for d
    int64_t _625 = 6;
    int64_t _626;
    // Computing bound for c
    int64_t _627 = 236;
    if (_627 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    _626 = 0;
    int64_t _628 = 0; // c
    _jump533:; // Begin body of loop
    int64_t _629 = 162;
    _626 += _629;
    _628++;
    if (_628 < _627)
    goto _jump533;
    // End body of loop
    int64_t _630 = _625 - _626;
    _623.d1 = _630;
    if (_630 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing bound for e
    int64_t _631;
    // Computing bound for c
    int64_t _632 = 711;
    if (_632 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    // Computing bound for d
    int64_t _633 = 839;
    int64_t _634 = -_633;
    if (_634 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    _631 = 0;
    int64_t _635 = 0; // d
    int64_t _636 = 0; // c
    _jump537:; // Begin body of loop
    _631 += _636;
    _635++;
    if (_635 < _634)
    goto _jump537;
    _635 = 0;
    _636++;
    if (_636 < _632)
    goto _jump537;
    // End body of loop
    _623.d2 = _631;
    if (_631 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _637 = 1;
    _637 *= _624;
    _637 *= _630;
    _637 *= _631;
    _637 *= sizeof(int64_t);
    _623.data = jpl_alloc(_637);
    int64_t _638 = 0; // e
    int64_t _639 = 0; // d
    int64_t _640 = 0; // c
    _jump539:; // Begin body of loop
    int64_t _641 = 548;
    _a1_int64_t _642;
    _642.d0 = 3;
    _642.data = jpl_alloc(sizeof(int64_t) * 3);
    _642.data[0] = _638;
    _642.data[1] = _641;
    _642.data[2] = _639;
    if (_640 >= 0)
    goto _jump540;
    fail_assertion("negative array index");
    _jump540:;
    if (_640 < _642.d0)
    goto _jump541;
    fail_assertion("index too large");
    _jump541:;
    int64_t _643 = 0;
    _643 *= _642.d0;
    _643 += _640;
    int64_t _644 = _642.data[_643];
    int64_t _645 = 0;
    _645 *= _623.d0;
    _645 += _640;
    _645 *= _623.d1;
    _645 += _639;
    _645 *= _623.d2;
    _645 += _638;
    _623.data[_645] = _644;
    _638++;
    if (_638 < _631)
    goto _jump539;
    _638 = 0;
    _639++;
    if (_639 < _630)
    goto _jump539;
    _639 = 0;
    _640++;
    if (_640 < _624)
    goto _jump539;
    // End body of loop
    _608 = _623;
    _jump530:;
    int64_t _646 = 888;
    int64_t _647;
    // Computing bound for c
    int64_t _648 = 449;
    int64_t _649 = 235;
    int64_t _650 = -_649;
    int64_t _651 = 702;
    int64_t _652 = -_651;
    int64_t _653 = _650 * _652;
    int64_t _654 = _648 - _653;
    if (_654 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    // Computing bound for d
    int64_t _655 = 529;
    int64_t _656 = 147;
    int64_t _657 = -_656;
    int64_t _658 = 318;
    int64_t _659 = -_658;
    int64_t _660 = _657 - _659;
    int64_t _661 = _655 - _660;
    if (_661 > 0) 
    goto _jump543;
    fail_assertion("non-positive loop bound");
    _jump543:;
    // Computing bound for e
    int64_t _662 = 595;
    if (_662 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    _647 = 0;
    int64_t _663 = 0; // e
    int64_t _664 = 0; // d
    int64_t _665 = 0; // c
    _jump545:; // Begin body of loop
    _647 += _663;
    _663++;
    if (_663 < _662)
    goto _jump545;
    _663 = 0;
    _664++;
    if (_664 < _661)
    goto _jump545;
    _664 = 0;
    _665++;
    if (_665 < _654)
    goto _jump545;
    // End body of loop
    bool _666 = true;
    _a1_bool _667;
    _667.d0 = 1;
    _667.data = jpl_alloc(sizeof(bool) * 1);
    _667.data[0] = _666;
    int64_t _668 = 275;
    _a1_int64_t _669;
    _669.d0 = 1;
    _669.data = jpl_alloc(sizeof(int64_t) * 1);
    _669.data[0] = _668;
    int64_t _670 = 905;
    if (_670 >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (_670 < _669.d0)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    int64_t _671 = 0;
    _671 *= _669.d0;
    _671 += _670;
    int64_t _672 = _669.data[_671];
    if (_672 >= 0)
    goto _jump548;
    fail_assertion("negative array index");
    _jump548:;
    if (_672 < _667.d0)
    goto _jump549;
    fail_assertion("index too large");
    _jump549:;
    int64_t _673 = 0;
    _673 *= _667.d0;
    _673 += _672;
    bool _674 = _667.data[_673];
    int64_t _675;
    if (!_674)
    goto _jump550;
    int64_t _676 = 487;
    int64_t _677 = 588;
    int64_t _678 = _676 * _677;
    int64_t _679 = -_678;
    int64_t _680 = -_679;
    _675 = _680;
    goto _jump551;
    _jump550:;
    int64_t _681 = 35;
    int64_t _682 = -_681;
    int64_t _683 = -_682;
    int64_t _684 = -_683;
    _675 = _684;
    _jump551:;
    if (_646 >= 0)
    goto _jump552;
    fail_assertion("negative array index");
    _jump552:;
    if (_646 < _608.d0)
    goto _jump553;
    fail_assertion("index too large");
    _jump553:;
    if (_647 >= 0)
    goto _jump554;
    fail_assertion("negative array index");
    _jump554:;
    if (_647 < _608.d1)
    goto _jump555;
    fail_assertion("index too large");
    _jump555:;
    if (_675 >= 0)
    goto _jump556;
    fail_assertion("negative array index");
    _jump556:;
    if (_675 < _608.d2)
    goto _jump557;
    fail_assertion("index too large");
    _jump557:;
    int64_t _685 = 0;
    _685 *= _608.d0;
    _685 += _646;
    _685 *= _608.d1;
    _685 += _647;
    _685 *= _608.d2;
    _685 += _675;
    int64_t _686 = _608.data[_685];
    if (_577 >= 0)
    goto _jump558;
    fail_assertion("negative array index");
    _jump558:;
    if (_577 < _463.d0)
    goto _jump559;
    fail_assertion("index too large");
    _jump559:;
    if (_686 >= 0)
    goto _jump560;
    fail_assertion("negative array index");
    _jump560:;
    if (_686 < _463.d1)
    goto _jump561;
    fail_assertion("index too large");
    _jump561:;
    int64_t _687 = 0;
    _687 *= _463.d0;
    _687 += _577;
    _687 *= _463.d1;
    _687 += _686;
    bool _688 = _463.data[_687];
    _317 = _688;
    _jump439:;
    _a2_rgba _689 = read_image("d.png");
    bool _690 = true;
    bool _691 = !_690;
    if (0 != _691)
    goto _jump791;
    fail_assertion("f");
    _jump791:;
    double _692;
    // Computing bound for f
    bool _693 = false;
    bool _694;
    if (!_693)
    goto _jump792;
    _694 = _317;
    goto _jump793;
    _jump792:;
    _694 = _317;
    _jump793:;
    _a2_int64_t _695;
    if (!_694)
    goto _jump794;
    _a2_int64_t _696;
    // Computing bound for f
    int64_t _697 = 51;
    _696.d0 = _697;
    if (_697 > 0) 
    goto _jump795;
    fail_assertion("non-positive loop bound");
    _jump795:;
    // Computing bound for g
    int64_t _698 = 916;
    _696.d1 = _698;
    if (_698 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing total size of heap memory to allocate
    int64_t _699 = 1;
    _699 *= _697;
    _699 *= _698;
    _699 *= sizeof(int64_t);
    _696.data = jpl_alloc(_699);
    int64_t _700 = 0; // g
    int64_t _701 = 0; // f
    _jump797:; // Begin body of loop
    int64_t _702 = _701 - _700;
    int64_t _703 = 0;
    _703 *= _696.d0;
    _703 += _701;
    _703 *= _696.d1;
    _703 += _700;
    _696.data[_703] = _702;
    _700++;
    if (_700 < _698)
    goto _jump797;
    _700 = 0;
    _701++;
    if (_701 < _697)
    goto _jump797;
    // End body of loop
    _695 = _696;
    goto _jump798;
    _jump794:;
    _a2_int64_t _704;
    // Computing bound for f
    int64_t _705 = 259;
    int64_t _706 = -_705;
    _704.d0 = _706;
    if (_706 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    // Computing bound for g
    int64_t _707 = 620;
    int64_t _708 = -_707;
    _704.d1 = _708;
    if (_708 > 0) 
    goto _jump800;
    fail_assertion("non-positive loop bound");
    _jump800:;
    // Computing total size of heap memory to allocate
    int64_t _709 = 1;
    _709 *= _706;
    _709 *= _708;
    _709 *= sizeof(int64_t);
    _704.data = jpl_alloc(_709);
    int64_t _710 = 0; // g
    int64_t _711 = 0; // f
    _jump801:; // Begin body of loop
    int64_t _712 = _710 + _710;
    int64_t _713 = 0;
    _713 *= _704.d0;
    _713 += _711;
    _713 *= _704.d1;
    _713 += _710;
    _704.data[_713] = _712;
    _710++;
    if (_710 < _708)
    goto _jump801;
    _710 = 0;
    _711++;
    if (_711 < _706)
    goto _jump801;
    // End body of loop
    _695 = _704;
    _jump798:;
    int64_t _714;
    // Computing bound for f
    int64_t _715 = 219;
    if (_715 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing bound for g
    int64_t _716 = 995;
    if (_716 > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    // Computing bound for h
    int64_t _717;
    // Computing bound for f
    int64_t _718 = 639;
    if (_718 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    _717 = 0;
    int64_t _719 = 0; // f
    _jump805:; // Begin body of loop
    int64_t _720 = 153;
    _717 += _720;
    _719++;
    if (_719 < _718)
    goto _jump805;
    // End body of loop
    int64_t _721 = 492;
    int64_t _722 = 802;
    int64_t _723 = _721 % _722;
    int64_t _724 = _717 - _723;
    if (_724 > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    _714 = 0;
    int64_t _725 = 0; // h
    int64_t _726 = 0; // g
    int64_t _727 = 0; // f
    _jump807:; // Begin body of loop
    _714 += _725;
    _725++;
    if (_725 < _724)
    goto _jump807;
    _725 = 0;
    _726++;
    if (_726 < _716)
    goto _jump807;
    _726 = 0;
    _727++;
    if (_727 < _715)
    goto _jump807;
    // End body of loop
    int64_t _728;
    if (!_317)
    goto _jump808;
    bool _729 = false;
    int64_t _730;
    if (!_729)
    goto _jump809;
    int64_t _731 = 82;
    int64_t _732 = -_731;
    _730 = _732;
    goto _jump810;
    _jump809:;
    int64_t _733 = 485;
    _730 = _733;
    _jump810:;
    _728 = _730;
    goto _jump811;
    _jump808:;
    bool _734 = false;
    bool _735 = _317 == _734;
    int64_t _736;
    if (!_735)
    goto _jump812;
    int64_t _737 = 331;
    int64_t _738 = -_737;
    _736 = _738;
    goto _jump813;
    _jump812:;
    int64_t _739 = 19;
    _736 = _739;
    _jump813:;
    _728 = _736;
    _jump811:;
    if (_714 >= 0)
    goto _jump814;
    fail_assertion("negative array index");
    _jump814:;
    if (_714 < _695.d0)
    goto _jump815;
    fail_assertion("index too large");
    _jump815:;
    if (_728 >= 0)
    goto _jump816;
    fail_assertion("negative array index");
    _jump816:;
    if (_728 < _695.d1)
    goto _jump817;
    fail_assertion("index too large");
    _jump817:;
    int64_t _740 = 0;
    _740 *= _695.d0;
    _740 += _714;
    _740 *= _695.d1;
    _740 += _728;
    int64_t _741 = _695.data[_740];
    if (_741 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for g
    bool _742 = true;
    bool _743 = !_742;
    bool _744;
    if (!_743)
    goto _jump819;
    bool _745 = _317;
    if (0 != _317)
    goto _jump820;
    _745 = _317;
    _jump820:;
    _744 = _745;
    goto _jump821;
    _jump819:;
    bool _746;
    if (!_317)
    goto _jump822;
    bool _747 = !_317;
    _746 = _747;
    goto _jump823;
    _jump822:;
    bool _748 = true;
    _746 = _748;
    _jump823:;
    _744 = _746;
    _jump821:;
    int64_t _749;
    if (!_744)
    goto _jump824;
    int64_t _750 = 269;
    int64_t _751 = -_750;
    int64_t _752 = 111;
    int64_t _753 = _751 / _752;
    int64_t _754 = 838;
    int64_t _755 = _753 * _754;
    _749 = _755;
    goto _jump825;
    _jump824:;
    int64_t _756;
    // Computing bound for f
    int64_t _757 = 381;
    if (_757 > 0) 
    goto _jump826;
    fail_assertion("non-positive loop bound");
    _jump826:;
    _756 = 0;
    int64_t _758 = 0; // f
    _jump827:; // Begin body of loop
    int64_t _759 = -_758;
    _756 += _759;
    _758++;
    if (_758 < _757)
    goto _jump827;
    // End body of loop
    _749 = _756;
    _jump825:;
    if (_749 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing bound for h
    int64_t _760 = 107;
    bool _761 = !_317;
    bool _762;
    if (!_761)
    goto _jump829;
    _762 = _317;
    goto _jump830;
    _jump829:;
    int64_t _763 = 682;
    int64_t _764 = 629;
    bool _765 = _763 != _764;
    _762 = _765;
    _jump830:;
    int64_t _766;
    if (!_762)
    goto _jump831;
    int64_t _767;
    // Computing bound for f
    int64_t _768 = 912;
    int64_t _769 = -_768;
    if (_769 > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    _767 = 0;
    int64_t _770 = 0; // f
    _jump833:; // Begin body of loop
    _767 += _770;
    _770++;
    if (_770 < _769)
    goto _jump833;
    // End body of loop
    _766 = _767;
    goto _jump834;
    _jump831:;
    int64_t _771 = 430;
    int64_t _772 = -_771;
    int64_t _773 = -_772;
    _766 = _773;
    _jump834:;
    int64_t _774 = _760 % _766;
    if (_774 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    _692 = 0;
    int64_t _775 = 0; // h
    int64_t _776 = 0; // g
    int64_t _777 = 0; // f
    _jump836:; // Begin body of loop
    _692 += _316;
    _775++;
    if (_775 < _774)
    goto _jump836;
    _775 = 0;
    _776++;
    if (_776 < _749)
    goto _jump836;
    _776 = 0;
    _777++;
    if (_777 < _741)
    goto _jump836;
    // End body of loop
    int64_t _778;
    if (!_317)
    goto _jump837;
    int64_t _779 = 757;
    int64_t _780 = -_779;
    _778 = _780;
    goto _jump838;
    _jump837:;
    int64_t _781 = 448;
    _778 = _781;
    _jump838:;
    int64_t _782 = 557;
    int64_t _783 = _778 / _782;
    int64_t _784 = 246;
    bool _785 = _783 != _784;
    double _786;
    if (!_785)
    goto _jump839;
    double _787 = 19.0;
    double _788 = -_787;
    double _789 = 94.0;
    double _790 = -_789;
    double _791 = 13.0;
    double _792 = 57.0;
    rgba _793 = { _788, _790, _791, _792 };
    double _794 = _793.g;
    _786 = _794;
    goto _jump840;
    _jump839:;
    double _795;
    // Computing bound for f
    int64_t _796 = 809;
    int64_t _797 = -_796;
    if (_797 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    _795 = 0;
    int64_t _798 = 0; // f
    _jump842:; // Begin body of loop
    _795 += _316;
    _798++;
    if (_798 < _797)
    goto _jump842;
    // End body of loop
    double _799 = -_795;
    double _800 = _799 / _316;
    _786 = _800;
    _jump840:;
    double _801 = 96.0;
    rgba _802 = { _692, _786, _316, _801 };
    double _803;
    if (!_317)
    goto _jump843;
    double _804;
    // Computing bound for f
    bool _805 = false;
    int64_t _806;
    if (!_805)
    goto _jump844;
    int64_t _807 = 654;
    int64_t _808 = 121;
    int64_t _809 = 515;
    int64_t _810 = _808 * _809;
    int64_t _811 = _807 / _810;
    _806 = _811;
    goto _jump845;
    _jump844:;
    int64_t _812 = 106;
    _806 = _812;
    _jump845:;
    if (_806 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    // Computing bound for g
    int64_t _813 = 771;
    if (_813 > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing bound for h
    int64_t _814 = 898;
    if (_814 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    _804 = 0;
    int64_t _815 = 0; // h
    int64_t _816 = 0; // g
    int64_t _817 = 0; // f
    _jump849:; // Begin body of loop
    double _818;
    // Computing bound for i
    bool _819 = true;
    bool _820;
    if (!_819)
    goto _jump850;
    bool _821 = false;
    _820 = _821;
    goto _jump851;
    _jump850:;
    bool _822 = false;
    _820 = _822;
    _jump851:;
    int64_t _823;
    if (!_820)
    goto _jump852;
    int64_t _824 = -_816;
    _823 = _824;
    goto _jump853;
    _jump852:;
    int64_t _825 = 457;
    _823 = _825;
    _jump853:;
    if (_823 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing bound for j
    int64_t _826;
    // Computing bound for i
    int64_t _827 = 555;
    int64_t _828 = _817 * _827;
    if (_828 > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    // Computing bound for j
    int64_t _829 = 645;
    if (_829 > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing bound for k
    if (_817 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    _826 = 0;
    int64_t _830 = 0; // k
    int64_t _831 = 0; // j
    int64_t _832 = 0; // i
    _jump858:; // Begin body of loop
    _826 += _831;
    _830++;
    if (_830 < _817)
    goto _jump858;
    _830 = 0;
    _831++;
    if (_831 < _829)
    goto _jump858;
    _831 = 0;
    _832++;
    if (_832 < _828)
    goto _jump858;
    // End body of loop
    if (_826 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    _818 = 0;
    int64_t _833 = 0; // j
    int64_t _834 = 0; // i
    _jump860:; // Begin body of loop
    double _835 = 0.0;
    _818 += _835;
    _833++;
    if (_833 < _826)
    goto _jump860;
    _833 = 0;
    _834++;
    if (_834 < _823)
    goto _jump860;
    // End body of loop
    _804 += _818;
    _815++;
    if (_815 < _814)
    goto _jump849;
    _815 = 0;
    _816++;
    if (_816 < _813)
    goto _jump849;
    _816 = 0;
    _817++;
    if (_817 < _806)
    goto _jump849;
    // End body of loop
    _803 = _804;
    goto _jump861;
    _jump843:;
    _a2_double _836;
    // Computing bound for f
    int64_t _837;
    // Computing bound for f
    int64_t _838 = 912;
    int64_t _839 = 633;
    int64_t _840 = _838 + _839;
    if (_840 > 0) 
    goto _jump862;
    fail_assertion("non-positive loop bound");
    _jump862:;
    // Computing bound for g
    int64_t _841;
    if (!_317)
    goto _jump863;
    int64_t _842 = 362;
    _841 = _842;
    goto _jump864;
    _jump863:;
    int64_t _843 = 375;
    _841 = _843;
    _jump864:;
    if (_841 > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    _837 = 0;
    int64_t _844 = 0; // g
    int64_t _845 = 0; // f
    _jump866:; // Begin body of loop
    _837 += _844;
    _844++;
    if (_844 < _841)
    goto _jump866;
    _844 = 0;
    _845++;
    if (_845 < _840)
    goto _jump866;
    // End body of loop
    _836.d0 = _837;
    if (_837 > 0) 
    goto _jump867;
    fail_assertion("non-positive loop bound");
    _jump867:;
    // Computing bound for g
    int64_t _846 = 497;
    int64_t _847 = -_846;
    _836.d1 = _847;
    if (_847 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing total size of heap memory to allocate
    int64_t _848 = 1;
    _848 *= _837;
    _848 *= _847;
    _848 *= sizeof(double);
    _836.data = jpl_alloc(_848);
    int64_t _849 = 0; // g
    int64_t _850 = 0; // f
    _jump869:; // Begin body of loop
    int64_t _851 = 0;
    _851 *= _836.d0;
    _851 += _850;
    _851 *= _836.d1;
    _851 += _849;
    _836.data[_851] = _316;
    _849++;
    if (_849 < _847)
    goto _jump869;
    _849 = 0;
    _850++;
    if (_850 < _837)
    goto _jump869;
    // End body of loop
    int64_t _852 = 951;
    int64_t _853 = 64;
    int64_t _854 = _852 % _853;
    int64_t _855 = -_854;
    int64_t _856 = 797;
    if (_855 >= 0)
    goto _jump870;
    fail_assertion("negative array index");
    _jump870:;
    if (_855 < _836.d0)
    goto _jump871;
    fail_assertion("index too large");
    _jump871:;
    if (_856 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_856 < _836.d1)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    int64_t _857 = 0;
    _857 *= _836.d0;
    _857 += _855;
    _857 *= _836.d1;
    _857 += _856;
    double _858 = _836.data[_857];
    _803 = _858;
    _jump861:;
    double _859 = 30.0;
    double _860 = 33.0;
    bool _861 = _859 <= _860;
    double _862;
    if (!_861)
    goto _jump874;
    double _863;
    // Computing bound for f
    _a2_int64_t _864;
    // Computing bound for f
    int64_t _865 = 35;
    _864.d0 = _865;
    if (_865 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for g
    int64_t _866 = 462;
    _864.d1 = _866;
    if (_866 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing total size of heap memory to allocate
    int64_t _867 = 1;
    _867 *= _865;
    _867 *= _866;
    _867 *= sizeof(int64_t);
    _864.data = jpl_alloc(_867);
    int64_t _868 = 0; // g
    int64_t _869 = 0; // f
    _jump877:; // Begin body of loop
    int64_t _870 = 0;
    _870 *= _864.d0;
    _870 += _869;
    _870 *= _864.d1;
    _870 += _868;
    _864.data[_870] = _868;
    _868++;
    if (_868 < _866)
    goto _jump877;
    _868 = 0;
    _869++;
    if (_869 < _865)
    goto _jump877;
    // End body of loop
    bool _871 = true;
    int64_t _872;
    if (!_871)
    goto _jump878;
    int64_t _873 = 155;
    _872 = _873;
    goto _jump879;
    _jump878:;
    int64_t _874 = 301;
    _872 = _874;
    _jump879:;
    int64_t _875 = 553;
    if (_872 >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (_872 < _864.d0)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    if (_875 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_875 < _864.d1)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    int64_t _876 = 0;
    _876 *= _864.d0;
    _876 += _872;
    _876 *= _864.d1;
    _876 += _875;
    int64_t _877 = _864.data[_876];
    if (_877 > 0) 
    goto _jump884;
    fail_assertion("non-positive loop bound");
    _jump884:;
    // Computing bound for g
    int64_t _878 = 581;
    int64_t _879 = -_878;
    int64_t _880 = -_879;
    if (_880 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing bound for h
    int64_t _881 = 595;
    int64_t _882 = -_881;
    int64_t _883 = -_882;
    if (_883 > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    _863 = 0;
    int64_t _884 = 0; // h
    int64_t _885 = 0; // g
    int64_t _886 = 0; // f
    _jump887:; // Begin body of loop
    double _887;
    // Computing bound for i
    int64_t _888 = 381;
    int64_t _889 = -_888;
    if (_889 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    _887 = 0;
    int64_t _890 = 0; // i
    _jump889:; // Begin body of loop
    double _891 = -_316;
    _887 += _891;
    _890++;
    if (_890 < _889)
    goto _jump889;
    // End body of loop
    _863 += _887;
    _884++;
    if (_884 < _883)
    goto _jump887;
    _884 = 0;
    _885++;
    if (_885 < _880)
    goto _jump887;
    _885 = 0;
    _886++;
    if (_886 < _877)
    goto _jump887;
    // End body of loop
    _862 = _863;
    goto _jump890;
    _jump874:;
    _862 = _316;
    _jump890:;
    double _892 = -_862;
    int64_t _893 = 18;
    int64_t _894;
    // Computing bound for f
    int64_t _895 = 793;
    if (_895 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing bound for g
    int64_t _896 = 238;
    if (_896 > 0) 
    goto _jump892;
    fail_assertion("non-positive loop bound");
    _jump892:;
    _894 = 0;
    int64_t _897 = 0; // g
    int64_t _898 = 0; // f
    _jump893:; // Begin body of loop
    _894 += _897;
    _897++;
    if (_897 < _896)
    goto _jump893;
    _897 = 0;
    _898++;
    if (_898 < _895)
    goto _jump893;
    // End body of loop
    if (_893 >= 0)
    goto _jump894;
    fail_assertion("negative array index");
    _jump894:;
    if (_893 < _689.d0)
    goto _jump895;
    fail_assertion("index too large");
    _jump895:;
    if (_894 >= 0)
    goto _jump896;
    fail_assertion("negative array index");
    _jump896:;
    if (_894 < _689.d1)
    goto _jump897;
    fail_assertion("index too large");
    _jump897:;
    int64_t _899 = 0;
    _899 *= _689.d0;
    _899 += _893;
    _899 *= _689.d1;
    _899 += _894;
    rgba _900 = _689.data[_899];
    bool _902 = !_317;
    bool _901 = _902;
    if (0 == _902)
    goto _jump898;
    bool _903 = true;
    bool _904 = !_903;
    _901 = _904;
    _jump898:;
    _a2_int64_t _905;
    if (!_901)
    goto _jump899;
    _a2_int64_t _906;
    // Computing bound for f
    int64_t _907 = 177;
    _906.d0 = _907;
    if (_907 > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for g
    int64_t _908 = 483;
    _906.d1 = _908;
    if (_908 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing total size of heap memory to allocate
    int64_t _909 = 1;
    _909 *= _907;
    _909 *= _908;
    _909 *= sizeof(int64_t);
    _906.data = jpl_alloc(_909);
    int64_t _910 = 0; // g
    int64_t _911 = 0; // f
    _jump902:; // Begin body of loop
    int64_t _912 = 416;
    int64_t _913 = _911 % _912;
    int64_t _914 = 0;
    _914 *= _906.d0;
    _914 += _911;
    _914 *= _906.d1;
    _914 += _910;
    _906.data[_914] = _913;
    _910++;
    if (_910 < _908)
    goto _jump902;
    _910 = 0;
    _911++;
    if (_911 < _907)
    goto _jump902;
    // End body of loop
    _905 = _906;
    goto _jump903;
    _jump899:;
    _a2_int64_t _915;
    // Computing bound for f
    int64_t _916 = 441;
    _915.d0 = _916;
    if (_916 > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for g
    int64_t _917;
    // Computing bound for f
    int64_t _918 = 511;
    if (_918 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    _917 = 0;
    int64_t _919 = 0; // f
    _jump906:; // Begin body of loop
    _917 += _919;
    _919++;
    if (_919 < _918)
    goto _jump906;
    // End body of loop
    _915.d1 = _917;
    if (_917 > 0) 
    goto _jump907;
    fail_assertion("non-positive loop bound");
    _jump907:;
    // Computing total size of heap memory to allocate
    int64_t _920 = 1;
    _920 *= _916;
    _920 *= _917;
    _920 *= sizeof(int64_t);
    _915.data = jpl_alloc(_920);
    int64_t _921 = 0; // g
    int64_t _922 = 0; // f
    _jump908:; // Begin body of loop
    int64_t _923;
    // Computing bound for h
    if (_921 > 0) 
    goto _jump909;
    fail_assertion("non-positive loop bound");
    _jump909:;
    // Computing bound for i
    if (_922 > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for j
    int64_t _924 = 693;
    if (_924 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    _923 = 0;
    int64_t _925 = 0; // j
    int64_t _926 = 0; // i
    int64_t _927 = 0; // h
    _jump912:; // Begin body of loop
    _923 += _927;
    _925++;
    if (_925 < _924)
    goto _jump912;
    _925 = 0;
    _926++;
    if (_926 < _922)
    goto _jump912;
    _926 = 0;
    _927++;
    if (_927 < _921)
    goto _jump912;
    // End body of loop
    int64_t _928 = 0;
    _928 *= _915.d0;
    _928 += _922;
    _928 *= _915.d1;
    _928 += _921;
    _915.data[_928] = _923;
    _921++;
    if (_921 < _917)
    goto _jump908;
    _921 = 0;
    _922++;
    if (_922 < _916)
    goto _jump908;
    // End body of loop
    _905 = _915;
    _jump903:;
    double _929 = e(_900, _905);
    double _930 = -_929;
    rgba _931 = { _803, _892, _316, _930 };
    int64_t _932;
    // Computing bound for f
    int64_t _933;
    // Computing bound for f
    int64_t _934;
    // Computing bound for f
    int64_t _935 = 379;
    if (_935 > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    _934 = 0;
    int64_t _936 = 0; // f
    _jump914:; // Begin body of loop
    int64_t _937 = 265;
    _934 += _937;
    _936++;
    if (_936 < _935)
    goto _jump914;
    // End body of loop
    int64_t _938 = -_934;
    if (_938 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    _933 = 0;
    int64_t _939 = 0; // f
    _jump916:; // Begin body of loop
    int64_t _940;
    // Computing bound for g
    if (_939 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for h
    int64_t _941 = 736;
    if (_941 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    _940 = 0;
    int64_t _942 = 0; // h
    int64_t _943 = 0; // g
    _jump919:; // Begin body of loop
    int64_t _944 = -_943;
    _940 += _944;
    _942++;
    if (_942 < _941)
    goto _jump919;
    _942 = 0;
    _943++;
    if (_943 < _939)
    goto _jump919;
    // End body of loop
    _933 += _940;
    _939++;
    if (_939 < _938)
    goto _jump916;
    // End body of loop
    if (_933 > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for g
    int64_t _945;
    if (!_317)
    goto _jump921;
    int64_t _946;
    // Computing bound for f
    int64_t _947 = 627;
    if (_947 > 0) 
    goto _jump922;
    fail_assertion("non-positive loop bound");
    _jump922:;
    _946 = 0;
    int64_t _948 = 0; // f
    _jump923:; // Begin body of loop
    int64_t _949 = 672;
    _946 += _949;
    _948++;
    if (_948 < _947)
    goto _jump923;
    // End body of loop
    int64_t _950 = -_946;
    _945 = _950;
    goto _jump924;
    _jump921:;
    _a1_int64_t _951;
    // Computing bound for f
    int64_t _952 = 721;
    _951.d0 = _952;
    if (_952 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing total size of heap memory to allocate
    int64_t _953 = 1;
    _953 *= _952;
    _953 *= sizeof(int64_t);
    _951.data = jpl_alloc(_953);
    int64_t _954 = 0; // f
    _jump926:; // Begin body of loop
    int64_t _955 = 572;
    int64_t _956 = 0;
    _956 *= _951.d0;
    _956 += _954;
    _951.data[_956] = _955;
    _954++;
    if (_954 < _952)
    goto _jump926;
    // End body of loop
    int64_t _957 = 648;
    int64_t _958 = -_957;
    if (_958 >= 0)
    goto _jump927;
    fail_assertion("negative array index");
    _jump927:;
    if (_958 < _951.d0)
    goto _jump928;
    fail_assertion("index too large");
    _jump928:;
    int64_t _959 = 0;
    _959 *= _951.d0;
    _959 += _958;
    int64_t _960 = _951.data[_959];
    _945 = _960;
    _jump924:;
    if (_945 > 0) 
    goto _jump929;
    fail_assertion("non-positive loop bound");
    _jump929:;
    _932 = 0;
    int64_t _961 = 0; // g
    int64_t _962 = 0; // f
    _jump930:; // Begin body of loop
    int64_t _963;
    // Computing bound for h
    int64_t _964 = 372;
    if (_964 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    _963 = 0;
    int64_t _965 = 0; // h
    _jump932:; // Begin body of loop
    _963 += _962;
    _965++;
    if (_965 < _964)
    goto _jump932;
    // End body of loop
    _932 += _963;
    _961++;
    if (_961 < _945)
    goto _jump930;
    _961 = 0;
    _962++;
    if (_962 < _933)
    goto _jump930;
    // End body of loop
    int64_t _966;
    // Computing bound for f
    _a3_int64_t _967;
    // Computing bound for f
    int64_t _968 = 157;
    _967.d0 = _968;
    if (_968 > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    // Computing bound for g
    int64_t _969 = 129;
    int64_t _970 = 458;
    int64_t _971 = _969 / _970;
    _967.d1 = _971;
    if (_971 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for h
    int64_t _972 = 464;
    int64_t _973 = -_972;
    _967.d2 = _973;
    if (_973 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _974 = 1;
    _974 *= _968;
    _974 *= _971;
    _974 *= _973;
    _974 *= sizeof(int64_t);
    _967.data = jpl_alloc(_974);
    int64_t _975 = 0; // h
    int64_t _976 = 0; // g
    int64_t _977 = 0; // f
    _jump936:; // Begin body of loop
    int64_t _978 = 0;
    _978 *= _967.d0;
    _978 += _977;
    _978 *= _967.d1;
    _978 += _976;
    _978 *= _967.d2;
    _978 += _975;
    _967.data[_978] = _975;
    _975++;
    if (_975 < _973)
    goto _jump936;
    _975 = 0;
    _976++;
    if (_976 < _971)
    goto _jump936;
    _976 = 0;
    _977++;
    if (_977 < _968)
    goto _jump936;
    // End body of loop
    int64_t _979 = 275;
    int64_t _980 = -_979;
    int64_t _981 = 162;
    int64_t _982 = 353;
    int64_t _983 = -_982;
    if (_980 >= 0)
    goto _jump937;
    fail_assertion("negative array index");
    _jump937:;
    if (_980 < _967.d0)
    goto _jump938;
    fail_assertion("index too large");
    _jump938:;
    if (_981 >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (_981 < _967.d1)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    if (_983 >= 0)
    goto _jump941;
    fail_assertion("negative array index");
    _jump941:;
    if (_983 < _967.d2)
    goto _jump942;
    fail_assertion("index too large");
    _jump942:;
    int64_t _984 = 0;
    _984 *= _967.d0;
    _984 += _980;
    _984 *= _967.d1;
    _984 += _981;
    _984 *= _967.d2;
    _984 += _983;
    int64_t _985 = _967.data[_984];
    if (_985 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    // Computing bound for g
    int64_t _986 = 497;
    int64_t _987 = 670;
    int64_t _988 = _986 % _987;
    int64_t _989 = -_988;
    int64_t _990 = 553;
    int64_t _991 = -_990;
    int64_t _992 = _989 * _991;
    if (_992 > 0) 
    goto _jump944;
    fail_assertion("non-positive loop bound");
    _jump944:;
    // Computing bound for h
    int64_t _993;
    if (!_317)
    goto _jump945;
    int64_t _994 = 165;
    int64_t _995 = -_994;
    _993 = _995;
    goto _jump946;
    _jump945:;
    int64_t _996 = 710;
    _993 = _996;
    _jump946:;
    if (_993 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    _966 = 0;
    int64_t _997 = 0; // h
    int64_t _998 = 0; // g
    int64_t _999 = 0; // f
    _jump948:; // Begin body of loop
    _966 += _998;
    _997++;
    if (_997 < _993)
    goto _jump948;
    _997 = 0;
    _998++;
    if (_998 < _992)
    goto _jump948;
    _998 = 0;
    _999++;
    if (_999 < _985)
    goto _jump948;
    // End body of loop
    bool _1000 = _932 < _966;
    rgba _1001;
    if (!_1000)
    goto _jump949;
    _a1_rgba _1002;
    // Computing bound for f
    int64_t _1003 = 978;
    int64_t _1004 = -_1003;
    int64_t _1005 = -_1004;
    int64_t _1006 = -_1005;
    _1002.d0 = _1006;
    if (_1006 > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing total size of heap memory to allocate
    int64_t _1007 = 1;
    _1007 *= _1006;
    _1007 *= sizeof(rgba);
    _1002.data = jpl_alloc(_1007);
    int64_t _1008 = 0; // f
    _jump951:; // Begin body of loop
    double _1009 = 79.0;
    _a2_double _1010;
    // Computing bound for g
    int64_t _1011 = 235;
    _1010.d0 = _1011;
    if (_1011 > 0) 
    goto _jump952;
    fail_assertion("non-positive loop bound");
    _jump952:;
    // Computing bound for h
    int64_t _1012 = 78;
    _1010.d1 = _1012;
    if (_1012 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    // Computing total size of heap memory to allocate
    int64_t _1013 = 1;
    _1013 *= _1011;
    _1013 *= _1012;
    _1013 *= sizeof(double);
    _1010.data = jpl_alloc(_1013);
    int64_t _1014 = 0; // h
    int64_t _1015 = 0; // g
    _jump954:; // Begin body of loop
    double _1016 = 68.0;
    int64_t _1017 = 0;
    _1017 *= _1010.d0;
    _1017 += _1015;
    _1017 *= _1010.d1;
    _1017 += _1014;
    _1010.data[_1017] = _1016;
    _1014++;
    if (_1014 < _1012)
    goto _jump954;
    _1014 = 0;
    _1015++;
    if (_1015 < _1011)
    goto _jump954;
    // End body of loop
    int64_t _1018 = 998;
    if (_1008 >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (_1008 < _1010.d0)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    if (_1018 >= 0)
    goto _jump957;
    fail_assertion("negative array index");
    _jump957:;
    if (_1018 < _1010.d1)
    goto _jump958;
    fail_assertion("index too large");
    _jump958:;
    int64_t _1019 = 0;
    _1019 *= _1010.d0;
    _1019 += _1008;
    _1019 *= _1010.d1;
    _1019 += _1018;
    double _1020 = _1010.data[_1019];
    double _1021 = 72.0;
    double _1022 = 88.0;
    rgba _1023 = { _1009, _1020, _1021, _1022 };
    int64_t _1024 = 0;
    _1024 *= _1002.d0;
    _1024 += _1008;
    _1002.data[_1024] = _1023;
    _1008++;
    if (_1008 < _1006)
    goto _jump951;
    // End body of loop
    int64_t _1025;
    // Computing bound for f
    int64_t _1026 = 417;
    int64_t _1027 = 403;
    int64_t _1028 = _1026 / _1027;
    if (_1028 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing bound for g
    int64_t _1029 = 3;
    if (_1029 > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for h
    int64_t _1030;
    if (!_317)
    goto _jump961;
    int64_t _1031 = 165;
    _1030 = _1031;
    goto _jump962;
    _jump961:;
    int64_t _1032 = 492;
    _1030 = _1032;
    _jump962:;
    if (_1030 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    _1025 = 0;
    int64_t _1033 = 0; // h
    int64_t _1034 = 0; // g
    int64_t _1035 = 0; // f
    _jump964:; // Begin body of loop
    int64_t _1036 = _1033 + _1035;
    _1025 += _1036;
    _1033++;
    if (_1033 < _1030)
    goto _jump964;
    _1033 = 0;
    _1034++;
    if (_1034 < _1029)
    goto _jump964;
    _1034 = 0;
    _1035++;
    if (_1035 < _1028)
    goto _jump964;
    // End body of loop
    int64_t _1037 = 901;
    int64_t _1038 = -_1037;
    int64_t _1039 = _1025 / _1038;
    int64_t _1040 = -_1039;
    if (_1040 >= 0)
    goto _jump965;
    fail_assertion("negative array index");
    _jump965:;
    if (_1040 < _1002.d0)
    goto _jump966;
    fail_assertion("index too large");
    _jump966:;
    int64_t _1041 = 0;
    _1041 *= _1002.d0;
    _1041 += _1040;
    rgba _1042 = _1002.data[_1041];
    _1001 = _1042;
    goto _jump967;
    _jump949:;
    _a1_double _1043;
    _1043.d0 = 1;
    _1043.data = jpl_alloc(sizeof(double) * 1);
    _1043.data[0] = _316;
    int64_t _1044 = 773;
    if (_1044 >= 0)
    goto _jump968;
    fail_assertion("negative array index");
    _jump968:;
    if (_1044 < _1043.d0)
    goto _jump969;
    fail_assertion("index too large");
    _jump969:;
    int64_t _1045 = 0;
    _1045 *= _1043.d0;
    _1045 += _1044;
    double _1046 = _1043.data[_1045];
    bool _1047 = !_317;
    double _1048;
    if (!_1047)
    goto _jump970;
    _1048 = _316;
    goto _jump971;
    _jump970:;
    double _1049 = 2.0;
    _1048 = _1049;
    _jump971:;
    bool _1050 = true;
    double _1051;
    if (!_1050)
    goto _jump972;
    double _1052 = 29.0;
    _1051 = _1052;
    goto _jump973;
    _jump972:;
    double _1053 = 80.0;
    _1051 = _1053;
    _jump973:;
    double _1054 = 52.0;
    rgba _1055 = { _1048, _1051, _1054, _316 };
    _a2_int64_t _1056;
    // Computing bound for f
    int64_t _1057;
    // Computing bound for f
    bool _1058 = false;
    int64_t _1059;
    if (!_1058)
    goto _jump974;
    int64_t _1060 = 264;
    _1059 = _1060;
    goto _jump975;
    _jump974:;
    int64_t _1061 = 672;
    _1059 = _1061;
    _jump975:;
    if (_1059 > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    _1057 = 0;
    int64_t _1062 = 0; // f
    _jump977:; // Begin body of loop
    int64_t _1063 = 962;
    int64_t _1064 = 539;
    int64_t _1065 = _1063 * _1064;
    _1057 += _1065;
    _1062++;
    if (_1062 < _1059)
    goto _jump977;
    // End body of loop
    _1056.d0 = _1057;
    if (_1057 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for g
    int64_t _1066 = 469;
    _1056.d1 = _1066;
    if (_1066 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing total size of heap memory to allocate
    int64_t _1067 = 1;
    _1067 *= _1057;
    _1067 *= _1066;
    _1067 *= sizeof(int64_t);
    _1056.data = jpl_alloc(_1067);
    int64_t _1068 = 0; // g
    int64_t _1069 = 0; // f
    _jump980:; // Begin body of loop
    _a1_int64_t _1070;
    // Computing bound for h
    _1070.d0 = _1069;
    if (_1069 > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    // Computing total size of heap memory to allocate
    int64_t _1071 = 1;
    _1071 *= _1069;
    _1071 *= sizeof(int64_t);
    _1070.data = jpl_alloc(_1071);
    int64_t _1072 = 0; // h
    _jump982:; // Begin body of loop
    int64_t _1073 = 521;
    int64_t _1074 = 0;
    _1074 *= _1070.d0;
    _1074 += _1072;
    _1070.data[_1074] = _1073;
    _1072++;
    if (_1072 < _1069)
    goto _jump982;
    // End body of loop
    int64_t _1075 = _1068 - _1068;
    if (_1075 >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (_1075 < _1070.d0)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    int64_t _1076 = 0;
    _1076 *= _1070.d0;
    _1076 += _1075;
    int64_t _1077 = _1070.data[_1076];
    int64_t _1078 = 0;
    _1078 *= _1056.d0;
    _1078 += _1069;
    _1078 *= _1056.d1;
    _1078 += _1068;
    _1056.data[_1078] = _1077;
    _1068++;
    if (_1068 < _1066)
    goto _jump980;
    _1068 = 0;
    _1069++;
    if (_1069 < _1057)
    goto _jump980;
    // End body of loop
    double _1079 = e(_1055, _1056);
    double _1080 = -_316;
    double _1081 = -_1080;
    double _1082 = -_1081;
    rgba _1083 = { _316, _1046, _1079, _1082 };
    _1001 = _1083;
    _jump967:;
    _a1_rgba _1084;
    _1084.d0 = 3;
    _1084.data = jpl_alloc(sizeof(rgba) * 3);
    _1084.data[0] = _802;
    _1084.data[1] = _931;
    _1084.data[2] = _1001;
    _a1_int64_t _1085;
    // Computing bound for h
    int64_t _1086 = 14;
    int64_t _1087 = -_1086;
    int64_t _1088;
    // Computing bound for h
    int64_t _1089 = 812;
    if (_1089 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    _1088 = 0;
    int64_t _1090 = 0; // h
    _jump986:; // Begin body of loop
    bool _1092;
    if (!_317)
    goto _jump987;
    bool _1093 = _317;
    if (0 != _317)
    goto _jump988;
    _1093 = _317;
    _jump988:;
    _1092 = _1093;
    goto _jump989;
    _jump987:;
    _1092 = _317;
    _jump989:;
    bool _1091 = _1092;
    if (0 != _1092)
    goto _jump990;
    bool _1094 = !_317;
    bool _1095;
    if (!_1094)
    goto _jump991;
    _1095 = _317;
    goto _jump992;
    _jump991:;
    int64_t _1096 = 746;
    bool _1097 = _1084.d0 > _1096;
    _1095 = _1097;
    _jump992:;
    _1091 = _1095;
    _jump990:;
    int64_t _1098;
    if (!_1091)
    goto _jump993;
    _1098 = _1084.d0;
    goto _jump994;
    _jump993:;
    int64_t _1099;
    // Computing bound for i
    if (_1090 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for j
    if (_1090 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing bound for k
    if (_1090 > 0) 
    goto _jump997;
    fail_assertion("non-positive loop bound");
    _jump997:;
    _1099 = 0;
    int64_t _1100 = 0; // k
    int64_t _1101 = 0; // j
    int64_t _1102 = 0; // i
    _jump998:; // Begin body of loop
    int64_t _1103;
    // Computing bound for l
    if (_1102 > 0) 
    goto _jump999;
    fail_assertion("non-positive loop bound");
    _jump999:;
    _1103 = 0;
    int64_t _1104 = 0; // l
    _jump1000:; // Begin body of loop
    _1103 += _1090;
    _1104++;
    if (_1104 < _1102)
    goto _jump1000;
    // End body of loop
    _1099 += _1103;
    _1100++;
    if (_1100 < _1090)
    goto _jump998;
    _1100 = 0;
    _1101++;
    if (_1101 < _1090)
    goto _jump998;
    _1101 = 0;
    _1102++;
    if (_1102 < _1090)
    goto _jump998;
    // End body of loop
    int64_t _1105 = _1084.d0 - _1099;
    _1098 = _1105;
    _jump994:;
    _1088 += _1098;
    _1090++;
    if (_1090 < _1089)
    goto _jump986;
    // End body of loop
    int64_t _1106 = _1087 - _1088;
    _1085.d0 = _1106;
    if (_1106 > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    // Computing total size of heap memory to allocate
    int64_t _1107 = 1;
    _1107 *= _1106;
    _1107 *= sizeof(int64_t);
    _1085.data = jpl_alloc(_1107);
    int64_t _1108 = 0; // h
    _jump1002:; // Begin body of loop
    int64_t _1109 = 0;
    _1109 *= _1085.d0;
    _1109 += _1108;
    _1085.data[_1109] = _1108;
    _1108++;
    if (_1108 < _1106)
    goto _jump1002;
    // End body of loop
    _a3__a2_rgba _1110;
    // Computing bound for j
    _1110.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    // Computing bound for k
    _1110.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for l
    int64_t _1111 = -_1085.d0;
    _a2_int64_t _1112;
    // Computing bound for j
    int64_t _1113;
    // Computing bound for j
    if (_1084.d0 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing bound for k
    if (_1084.d0 > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    // Computing bound for l
    if (_1085.d0 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    _1113 = 0;
    int64_t _1114 = 0; // l
    int64_t _1115 = 0; // k
    int64_t _1116 = 0; // j
    _jump1008:; // Begin body of loop
    _1113 += _1115;
    _1114++;
    if (_1114 < _1085.d0)
    goto _jump1008;
    _1114 = 0;
    _1115++;
    if (_1115 < _1084.d0)
    goto _jump1008;
    _1115 = 0;
    _1116++;
    if (_1116 < _1084.d0)
    goto _jump1008;
    // End body of loop
    int64_t _1117 = _1113 % _1084.d0;
    _1112.d0 = _1117;
    if (_1117 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing bound for k
    int64_t _1118 = 775;
    int64_t _1119 = 611;
    int64_t _1120 = _1118 % _1119;
    int64_t _1121 = -_1120;
    _1112.d1 = _1121;
    if (_1121 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing total size of heap memory to allocate
    int64_t _1122 = 1;
    _1122 *= _1117;
    _1122 *= _1121;
    _1122 *= sizeof(int64_t);
    _1112.data = jpl_alloc(_1122);
    int64_t _1123 = 0; // k
    int64_t _1124 = 0; // j
    _jump1011:; // Begin body of loop
    int64_t _1125 = 0;
    _1125 *= _1112.d0;
    _1125 += _1124;
    _1125 *= _1112.d1;
    _1125 += _1123;
    _1112.data[_1125] = _1124;
    _1123++;
    if (_1123 < _1121)
    goto _jump1011;
    _1123 = 0;
    _1124++;
    if (_1124 < _1117)
    goto _jump1011;
    // End body of loop
    if (_1084.d0 >= 0)
    goto _jump1012;
    fail_assertion("negative array index");
    _jump1012:;
    if (_1084.d0 < _1112.d0)
    goto _jump1013;
    fail_assertion("index too large");
    _jump1013:;
    if (_1085.d0 >= 0)
    goto _jump1014;
    fail_assertion("negative array index");
    _jump1014:;
    if (_1085.d0 < _1112.d1)
    goto _jump1015;
    fail_assertion("index too large");
    _jump1015:;
    int64_t _1126 = 0;
    _1126 *= _1112.d0;
    _1126 += _1084.d0;
    _1126 *= _1112.d1;
    _1126 += _1085.d0;
    int64_t _1127 = _1112.data[_1126];
    int64_t _1128 = _1111 % _1127;
    _1110.d2 = _1128;
    if (_1128 > 0) 
    goto _jump1016;
    fail_assertion("non-positive loop bound");
    _jump1016:;
    // Computing total size of heap memory to allocate
    int64_t _1129 = 1;
    _1129 *= _1084.d0;
    _1129 *= _1085.d0;
    _1129 *= _1128;
    _1129 *= sizeof(_a2_rgba);
    _1110.data = jpl_alloc(_1129);
    int64_t _1130 = 0; // l
    int64_t _1131 = 0; // k
    int64_t _1132 = 0; // j
    _jump1017:; // Begin body of loop
    int64_t _1133 = 0;
    _1133 *= _1110.d0;
    _1133 += _1132;
    _1133 *= _1110.d1;
    _1133 += _1131;
    _1133 *= _1110.d2;
    _1133 += _1130;
    _1110.data[_1133] = _689;
    _1130++;
    if (_1130 < _1128)
    goto _jump1017;
    _1130 = 0;
    _1131++;
    if (_1131 < _1085.d0)
    goto _jump1017;
    _1131 = 0;
    _1132++;
    if (_1132 < _1084.d0)
    goto _jump1017;
    // End body of loop
    int64_t _1134 = 943;
    int64_t _1135;
    // Computing bound for j
    _a1_int64_t _1136;
    _1136.d0 = 2;
    _1136.data = jpl_alloc(sizeof(int64_t) * 2);
    _1136.data[0] = _1084.d0;
    _1136.data[1] = _1085.d0;
    int64_t _1137 = 266;
    if (_1137 >= 0)
    goto _jump1018;
    fail_assertion("negative array index");
    _jump1018:;
    if (_1137 < _1136.d0)
    goto _jump1019;
    fail_assertion("index too large");
    _jump1019:;
    int64_t _1138 = 0;
    _1138 *= _1136.d0;
    _1138 += _1137;
    int64_t _1139 = _1136.data[_1138];
    if (_1139 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing bound for k
    bool _1140 = _317 != _317;
    int64_t _1141;
    if (!_1140)
    goto _jump1021;
    int64_t _1142 = -_1085.d0;
    int64_t _1143 = -_1142;
    _1141 = _1143;
    goto _jump1022;
    _jump1021:;
    int64_t _1144 = 930;
    _1141 = _1144;
    _jump1022:;
    if (_1141 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    _1135 = 0;
    int64_t _1145 = 0; // k
    int64_t _1146 = 0; // j
    _jump1024:; // Begin body of loop
    _a3_int64_t _1147;
    // Computing bound for l
    _1147.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1025;
    fail_assertion("non-positive loop bound");
    _jump1025:;
    // Computing bound for m
    _1147.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1026;
    fail_assertion("non-positive loop bound");
    _jump1026:;
    // Computing bound for n
    int64_t _1148 = 250;
    _1147.d2 = _1148;
    if (_1148 > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    // Computing total size of heap memory to allocate
    int64_t _1149 = 1;
    _1149 *= _1084.d0;
    _1149 *= _1085.d0;
    _1149 *= _1148;
    _1149 *= sizeof(int64_t);
    _1147.data = jpl_alloc(_1149);
    int64_t _1150 = 0; // n
    int64_t _1151 = 0; // m
    int64_t _1152 = 0; // l
    _jump1028:; // Begin body of loop
    int64_t _1153 = 0;
    _1153 *= _1147.d0;
    _1153 += _1152;
    _1153 *= _1147.d1;
    _1153 += _1151;
    _1153 *= _1147.d2;
    _1153 += _1150;
    _1147.data[_1153] = _1146;
    _1150++;
    if (_1150 < _1148)
    goto _jump1028;
    _1150 = 0;
    _1151++;
    if (_1151 < _1085.d0)
    goto _jump1028;
    _1151 = 0;
    _1152++;
    if (_1152 < _1084.d0)
    goto _jump1028;
    // End body of loop
    int64_t _1154 = -_1146;
    int64_t _1155 = -_1084.d0;
    if (_1154 >= 0)
    goto _jump1029;
    fail_assertion("negative array index");
    _jump1029:;
    if (_1154 < _1147.d0)
    goto _jump1030;
    fail_assertion("index too large");
    _jump1030:;
    if (_1085.d0 >= 0)
    goto _jump1031;
    fail_assertion("negative array index");
    _jump1031:;
    if (_1085.d0 < _1147.d1)
    goto _jump1032;
    fail_assertion("index too large");
    _jump1032:;
    if (_1155 >= 0)
    goto _jump1033;
    fail_assertion("negative array index");
    _jump1033:;
    if (_1155 < _1147.d2)
    goto _jump1034;
    fail_assertion("index too large");
    _jump1034:;
    int64_t _1156 = 0;
    _1156 *= _1147.d0;
    _1156 += _1154;
    _1156 *= _1147.d1;
    _1156 += _1085.d0;
    _1156 *= _1147.d2;
    _1156 += _1155;
    int64_t _1157 = _1147.data[_1156];
    _1135 += _1157;
    _1145++;
    if (_1145 < _1141)
    goto _jump1024;
    _1145 = 0;
    _1146++;
    if (_1146 < _1139)
    goto _jump1024;
    // End body of loop
    int64_t _1158 = -_1135;
    int64_t _1159 = _1158 % _1085.d0;
    if (_1134 >= 0)
    goto _jump1035;
    fail_assertion("negative array index");
    _jump1035:;
    if (_1134 < _1110.d0)
    goto _jump1036;
    fail_assertion("index too large");
    _jump1036:;
    if (_1085.d0 >= 0)
    goto _jump1037;
    fail_assertion("negative array index");
    _jump1037:;
    if (_1085.d0 < _1110.d1)
    goto _jump1038;
    fail_assertion("index too large");
    _jump1038:;
    if (_1159 >= 0)
    goto _jump1039;
    fail_assertion("negative array index");
    _jump1039:;
    if (_1159 < _1110.d2)
    goto _jump1040;
    fail_assertion("index too large");
    _jump1040:;
    int64_t _1160 = 0;
    _1160 *= _1110.d0;
    _1160 += _1134;
    _1160 *= _1110.d1;
    _1160 += _1085.d0;
    _1160 *= _1110.d2;
    _1160 += _1159;
    _a2_rgba _1161 = _1110.data[_1160];
    write_image(_1161, "j.png");
    int64_t _1162;
    // Computing bound for j
    _a1__a3_int64_t _1163;
    // Computing bound for j
    _1163.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1041;
    fail_assertion("non-positive loop bound");
    _jump1041:;
    // Computing total size of heap memory to allocate
    int64_t _1164 = 1;
    _1164 *= _1085.d0;
    _1164 *= sizeof(_a3_int64_t);
    _1163.data = jpl_alloc(_1164);
    int64_t _1165 = 0; // j
    _jump1042:; // Begin body of loop
    _a1__a3_int64_t _1166;
    // Computing bound for k
    int64_t _1167 = -_1084.d0;
    _1166.d0 = _1167;
    if (_1167 > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing total size of heap memory to allocate
    int64_t _1168 = 1;
    _1168 *= _1167;
    _1168 *= sizeof(_a3_int64_t);
    _1166.data = jpl_alloc(_1168);
    int64_t _1169 = 0; // k
    _jump1044:; // Begin body of loop
    _a3_int64_t _1170;
    // Computing bound for l
    _1170.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1045;
    fail_assertion("non-positive loop bound");
    _jump1045:;
    // Computing bound for m
    _1170.d1 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1046;
    fail_assertion("non-positive loop bound");
    _jump1046:;
    // Computing bound for n
    int64_t _1171 = 222;
    _1170.d2 = _1171;
    if (_1171 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing total size of heap memory to allocate
    int64_t _1172 = 1;
    _1172 *= _1085.d0;
    _1172 *= _1084.d0;
    _1172 *= _1171;
    _1172 *= sizeof(int64_t);
    _1170.data = jpl_alloc(_1172);
    int64_t _1173 = 0; // n
    int64_t _1174 = 0; // m
    int64_t _1175 = 0; // l
    _jump1048:; // Begin body of loop
    int64_t _1176 = 0;
    _1176 *= _1170.d0;
    _1176 += _1175;
    _1176 *= _1170.d1;
    _1176 += _1174;
    _1176 *= _1170.d2;
    _1176 += _1173;
    _1170.data[_1176] = _1169;
    _1173++;
    if (_1173 < _1171)
    goto _jump1048;
    _1173 = 0;
    _1174++;
    if (_1174 < _1084.d0)
    goto _jump1048;
    _1174 = 0;
    _1175++;
    if (_1175 < _1085.d0)
    goto _jump1048;
    // End body of loop
    int64_t _1177 = 0;
    _1177 *= _1166.d0;
    _1177 += _1169;
    _1166.data[_1177] = _1170;
    _1169++;
    if (_1169 < _1167)
    goto _jump1044;
    // End body of loop
    if (_1165 >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (_1165 < _1166.d0)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    int64_t _1178 = 0;
    _1178 *= _1166.d0;
    _1178 += _1165;
    _a3_int64_t _1179 = _1166.data[_1178];
    int64_t _1180 = 0;
    _1180 *= _1163.d0;
    _1180 += _1165;
    _1163.data[_1180] = _1179;
    _1165++;
    if (_1165 < _1085.d0)
    goto _jump1042;
    // End body of loop
    int64_t _1181 = 902;
    if (_1181 >= 0)
    goto _jump1051;
    fail_assertion("negative array index");
    _jump1051:;
    if (_1181 < _1163.d0)
    goto _jump1052;
    fail_assertion("index too large");
    _jump1052:;
    int64_t _1182 = 0;
    _1182 *= _1163.d0;
    _1182 += _1181;
    _a3_int64_t _1183 = _1163.data[_1182];
    int64_t _1184 = -_1085.d0;
    int64_t _1185 = -_1184;
    if (_1185 >= 0)
    goto _jump1053;
    fail_assertion("negative array index");
    _jump1053:;
    if (_1185 < _1183.d0)
    goto _jump1054;
    fail_assertion("index too large");
    _jump1054:;
    if (_1084.d0 >= 0)
    goto _jump1055;
    fail_assertion("negative array index");
    _jump1055:;
    if (_1084.d0 < _1183.d1)
    goto _jump1056;
    fail_assertion("index too large");
    _jump1056:;
    if (_1085.d0 >= 0)
    goto _jump1057;
    fail_assertion("negative array index");
    _jump1057:;
    if (_1085.d0 < _1183.d2)
    goto _jump1058;
    fail_assertion("index too large");
    _jump1058:;
    int64_t _1186 = 0;
    _1186 *= _1183.d0;
    _1186 += _1185;
    _1186 *= _1183.d1;
    _1186 += _1084.d0;
    _1186 *= _1183.d2;
    _1186 += _1085.d0;
    int64_t _1187 = _1183.data[_1186];
    if (_1187 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    _1162 = 0;
    int64_t _1188 = 0; // j
    _jump1060:; // Begin body of loop
    _1162 += _1084.d0;
    _1188++;
    if (_1188 < _1187)
    goto _jump1060;
    // End body of loop
    show("(IntType)", &_1162);
    _a1__a2_rgba _1189;
    // Computing bound for j
    int64_t _1190;
    // Computing bound for j
    int64_t _1191;
    // Computing bound for j
    int64_t _1192 = -_1085.d0;
    if (_1192 > 0) 
    goto _jump1061;
    fail_assertion("non-positive loop bound");
    _jump1061:;
    _1191 = 0;
    int64_t _1193 = 0; // j
    _jump1062:; // Begin body of loop
    int64_t _1194 = 422;
    _1191 += _1194;
    _1193++;
    if (_1193 < _1192)
    goto _jump1062;
    // End body of loop
    int64_t _1195 = _1191 + _1084.d0;
    if (_1195 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for k
    bool _1196 = false;
    bool _1197 = !_1196;
    int64_t _1198;
    if (!_1197)
    goto _jump1064;
    _1198 = _1084.d0;
    goto _jump1065;
    _jump1064:;
    int64_t _1199 = 861;
    _a3_int64_t _1200;
    // Computing bound for j
    _1200.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing bound for k
    _1200.d1 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1067;
    fail_assertion("non-positive loop bound");
    _jump1067:;
    // Computing bound for l
    int64_t _1201 = 344;
    _1200.d2 = _1201;
    if (_1201 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing total size of heap memory to allocate
    int64_t _1202 = 1;
    _1202 *= _1084.d0;
    _1202 *= _1084.d0;
    _1202 *= _1201;
    _1202 *= sizeof(int64_t);
    _1200.data = jpl_alloc(_1202);
    int64_t _1203 = 0; // l
    int64_t _1204 = 0; // k
    int64_t _1205 = 0; // j
    _jump1069:; // Begin body of loop
    int64_t _1206 = 0;
    _1206 *= _1200.d0;
    _1206 += _1205;
    _1206 *= _1200.d1;
    _1206 += _1204;
    _1206 *= _1200.d2;
    _1206 += _1203;
    _1200.data[_1206] = _1204;
    _1203++;
    if (_1203 < _1201)
    goto _jump1069;
    _1203 = 0;
    _1204++;
    if (_1204 < _1084.d0)
    goto _jump1069;
    _1204 = 0;
    _1205++;
    if (_1205 < _1084.d0)
    goto _jump1069;
    // End body of loop
    int64_t _1207 = 856;
    int64_t _1208 = 33;
    if (_1207 >= 0)
    goto _jump1070;
    fail_assertion("negative array index");
    _jump1070:;
    if (_1207 < _1200.d0)
    goto _jump1071;
    fail_assertion("index too large");
    _jump1071:;
    if (_1085.d0 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (_1085.d0 < _1200.d1)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    if (_1208 >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (_1208 < _1200.d2)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    int64_t _1209 = 0;
    _1209 *= _1200.d0;
    _1209 += _1207;
    _1209 *= _1200.d1;
    _1209 += _1085.d0;
    _1209 *= _1200.d2;
    _1209 += _1208;
    int64_t _1210 = _1200.data[_1209];
    int64_t _1211 = _1199 + _1210;
    _1198 = _1211;
    _jump1065:;
    if (_1198 > 0) 
    goto _jump1076;
    fail_assertion("non-positive loop bound");
    _jump1076:;
    // Computing bound for l
    if (_1085.d0 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    _1190 = 0;
    int64_t _1212 = 0; // l
    int64_t _1213 = 0; // k
    int64_t _1214 = 0; // j
    _jump1078:; // Begin body of loop
    double _1215 = 8.0;
    double _1216 = 94.0;
    double _1217 = 86.0;
    rgba _1218 = { _1215, _1216, _316, _1217 };
    double _1219 = _1218.a;
    bool _1220 = _1219 == _316;
    int64_t _1221;
    if (!_1220)
    goto _jump1079;
    _1221 = _1085.d0;
    goto _jump1080;
    _jump1079:;
    _1221 = _1084.d0;
    _jump1080:;
    _1190 += _1221;
    _1212++;
    if (_1212 < _1085.d0)
    goto _jump1078;
    _1212 = 0;
    _1213++;
    if (_1213 < _1198)
    goto _jump1078;
    _1213 = 0;
    _1214++;
    if (_1214 < _1195)
    goto _jump1078;
    // End body of loop
    _1189.d0 = _1190;
    if (_1190 > 0) 
    goto _jump1081;
    fail_assertion("non-positive loop bound");
    _jump1081:;
    // Computing total size of heap memory to allocate
    int64_t _1222 = 1;
    _1222 *= _1190;
    _1222 *= sizeof(_a2_rgba);
    _1189.data = jpl_alloc(_1222);
    int64_t _1223 = 0; // j
    _jump1082:; // Begin body of loop
    int64_t _1224 = 0;
    _1224 *= _1189.d0;
    _1224 += _1223;
    _1189.data[_1224] = _689;
    _1223++;
    if (_1223 < _1190)
    goto _jump1082;
    // End body of loop
    if (_1084.d0 >= 0)
    goto _jump1083;
    fail_assertion("negative array index");
    _jump1083:;
    if (_1084.d0 < _1189.d0)
    goto _jump1084;
    fail_assertion("index too large");
    _jump1084:;
    int64_t _1225 = 0;
    _1225 *= _1189.d0;
    _1225 += _1084.d0;
    _a2_rgba _1226 = _1189.data[_1225];
    bool _1227 = !_317;
    bool _1229 = true;
    bool _1228 = _1229;
    if (0 == _1229)
    goto _jump1085;
    _1228 = _317;
    _jump1085:;
    bool _1230;
    if (!_1228)
    goto _jump1086;
    bool _1231;
    if (!_1227)
    goto _jump1087;
    double _1233 = 27.0;
    double _1234 = 88.0;
    double _1235 = 96.0;
    double _1236 = fmod(_1234, _1235);
    bool _1237 = _1233 == _1236;
    bool _1232 = _1237;
    if (0 == _1237)
    goto _jump1088;
    _1232 = _317;
    _jump1088:;
    _1231 = _1232;
    goto _jump1089;
    _jump1087:;
    _a2_bool _1238;
    if (!_317)
    goto _jump1090;
    _a2_bool _1239;
    // Computing bound for o
    _1239.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    // Computing bound for p
    _1239.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing total size of heap memory to allocate
    int64_t _1240 = 1;
    _1240 *= _1085.d0;
    _1240 *= _1226.d0;
    _1240 *= sizeof(bool);
    _1239.data = jpl_alloc(_1240);
    int64_t _1241 = 0; // p
    int64_t _1242 = 0; // o
    _jump1093:; // Begin body of loop
    int64_t _1243 = 0;
    _1243 *= _1239.d0;
    _1243 += _1242;
    _1243 *= _1239.d1;
    _1243 += _1241;
    _1239.data[_1243] = _1227;
    _1241++;
    if (_1241 < _1226.d0)
    goto _jump1093;
    _1241 = 0;
    _1242++;
    if (_1242 < _1085.d0)
    goto _jump1093;
    // End body of loop
    _1238 = _1239;
    goto _jump1094;
    _jump1090:;
    _a2_bool _1244;
    // Computing bound for o
    _1244.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing bound for p
    _1244.d1 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    // Computing total size of heap memory to allocate
    int64_t _1245 = 1;
    _1245 *= _1084.d0;
    _1245 *= _1226.d1;
    _1245 *= sizeof(bool);
    _1244.data = jpl_alloc(_1245);
    int64_t _1246 = 0; // p
    int64_t _1247 = 0; // o
    _jump1097:; // Begin body of loop
    int64_t _1248 = 0;
    _1248 *= _1244.d0;
    _1248 += _1247;
    _1248 *= _1244.d1;
    _1248 += _1246;
    _1244.data[_1248] = _317;
    _1246++;
    if (_1246 < _1226.d1)
    goto _jump1097;
    _1246 = 0;
    _1247++;
    if (_1247 < _1084.d0)
    goto _jump1097;
    // End body of loop
    _1238 = _1244;
    _jump1094:;
    if (_1085.d0 >= 0)
    goto _jump1098;
    fail_assertion("negative array index");
    _jump1098:;
    if (_1085.d0 < _1238.d0)
    goto _jump1099;
    fail_assertion("index too large");
    _jump1099:;
    if (_1226.d1 >= 0)
    goto _jump1100;
    fail_assertion("negative array index");
    _jump1100:;
    if (_1226.d1 < _1238.d1)
    goto _jump1101;
    fail_assertion("index too large");
    _jump1101:;
    int64_t _1249 = 0;
    _1249 *= _1238.d0;
    _1249 += _1085.d0;
    _1249 *= _1238.d1;
    _1249 += _1226.d1;
    bool _1250 = _1238.data[_1249];
    _1231 = _1250;
    _jump1089:;
    bool _1251;
    if (!_1231)
    goto _jump1102;
    _a1_bool _1252;
    // Computing bound for o
    int64_t _1253 = _1084.d0 - _1084.d0;
    _1252.d0 = _1253;
    if (_1253 > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    // Computing total size of heap memory to allocate
    int64_t _1254 = 1;
    _1254 *= _1253;
    _1254 *= sizeof(bool);
    _1252.data = jpl_alloc(_1254);
    int64_t _1255 = 0; // o
    _jump1104:; // Begin body of loop
    int64_t _1256 = 0;
    _1256 *= _1252.d0;
    _1256 += _1255;
    _1252.data[_1256] = _317;
    _1255++;
    if (_1255 < _1253)
    goto _jump1104;
    // End body of loop
    if (_1084.d0 >= 0)
    goto _jump1105;
    fail_assertion("negative array index");
    _jump1105:;
    if (_1084.d0 < _1252.d0)
    goto _jump1106;
    fail_assertion("index too large");
    _jump1106:;
    int64_t _1257 = 0;
    _1257 *= _1252.d0;
    _1257 += _1084.d0;
    bool _1258 = _1252.data[_1257];
    bool _1259;
    if (!_1258)
    goto _jump1107;
    bool _1260 = true;
    _1259 = _1260;
    goto _jump1108;
    _jump1107:;
    double _1261;
    // Computing bound for o
    if (_1226.d1 > 0) 
    goto _jump1109;
    fail_assertion("non-positive loop bound");
    _jump1109:;
    // Computing bound for p
    if (_1226.d0 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for q
    int64_t _1262 = -_1085.d0;
    if (_1262 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    _1261 = 0;
    int64_t _1263 = 0; // q
    int64_t _1264 = 0; // p
    int64_t _1265 = 0; // o
    _jump1112:; // Begin body of loop
    double _1266 = 82.0;
    _1261 += _1266;
    _1263++;
    if (_1263 < _1262)
    goto _jump1112;
    _1263 = 0;
    _1264++;
    if (_1264 < _1226.d0)
    goto _jump1112;
    _1264 = 0;
    _1265++;
    if (_1265 < _1226.d1)
    goto _jump1112;
    // End body of loop
    bool _1267 = _316 < _1261;
    _1259 = _1267;
    _jump1108:;
    _1251 = _1259;
    goto _jump1113;
    _jump1102:;
    _1251 = _317;
    _jump1113:;
    _1230 = _1251;
    goto _jump1114;
    _jump1086:;
    bool _1270 = false;
    bool _1269 = _1270;
    if (0 != _1270)
    goto _jump1115;
    int64_t _1271 = -_1085.d0;
    bool _1272 = _1271 != _1226.d1;
    _1269 = _1272;
    _jump1115:;
    bool _1268 = _1269;
    if (0 != _1269)
    goto _jump1116;
    _1268 = _317;
    _jump1116:;
    bool _1273;
    if (!_1268)
    goto _jump1117;
    bool _1274 = false;
    _1273 = _1274;
    goto _jump1118;
    _jump1117:;
    bool _1275 = !_317;
    bool _1276 = !_1275;
    _a1_bool _1277;
    if (!_1276)
    goto _jump1119;
    _a1_bool _1278;
    if (!_317)
    goto _jump1120;
    _a1_bool _1279;
    // Computing bound for o
    _1279.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing total size of heap memory to allocate
    int64_t _1280 = 1;
    _1280 *= _1084.d0;
    _1280 *= sizeof(bool);
    _1279.data = jpl_alloc(_1280);
    int64_t _1281 = 0; // o
    _jump1122:; // Begin body of loop
    bool _1282 = false;
    int64_t _1283 = 0;
    _1283 *= _1279.d0;
    _1283 += _1281;
    _1279.data[_1283] = _1282;
    _1281++;
    if (_1281 < _1084.d0)
    goto _jump1122;
    // End body of loop
    _1278 = _1279;
    goto _jump1123;
    _jump1120:;
    _a1_bool _1284;
    _1284.d0 = 1;
    _1284.data = jpl_alloc(sizeof(bool) * 1);
    _1284.data[0] = _317;
    _1278 = _1284;
    _jump1123:;
    _1277 = _1278;
    goto _jump1124;
    _jump1119:;
    _a1_bool _1285;
    // Computing bound for o
    _1285.d0 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    // Computing total size of heap memory to allocate
    int64_t _1286 = 1;
    _1286 *= _1226.d0;
    _1286 *= sizeof(bool);
    _1285.data = jpl_alloc(_1286);
    int64_t _1287 = 0; // o
    _jump1126:; // Begin body of loop
    int64_t _1288 = 0;
    _1288 *= _1285.d0;
    _1288 += _1287;
    _1285.data[_1288] = _317;
    _1287++;
    if (_1287 < _1226.d0)
    goto _jump1126;
    // End body of loop
    _1277 = _1285;
    _jump1124:;
    int64_t _1289 = 772;
    if (_1289 >= 0)
    goto _jump1127;
    fail_assertion("negative array index");
    _jump1127:;
    if (_1289 < _1277.d0)
    goto _jump1128;
    fail_assertion("index too large");
    _jump1128:;
    int64_t _1290 = 0;
    _1290 *= _1277.d0;
    _1290 += _1289;
    bool _1291 = _1277.data[_1290];
    _1273 = _1291;
    _jump1118:;
    _1230 = _1273;
    _jump1114:;
    _a3_int64_t _1292;
    if (!_1230)
    goto _jump1129;
    bool _1293 = _1227;
    if (0 == _1227)
    goto _jump1130;
    bool _1294 = _317;
    if (0 != _317)
    goto _jump1131;
    _1294 = _317;
    _jump1131:;
    _1293 = _1294;
    _jump1130:;
    bool _1295 = !_1293;
    _a3_int64_t _1296;
    if (!_1295)
    goto _jump1132;
    _a3__a3_int64_t _1297;
    // Computing bound for o
    int64_t _1298 = _1226.d0 - _1226.d0;
    _1297.d0 = _1298;
    if (_1298 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    // Computing bound for p
    _1297.d1 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    // Computing bound for q
    int64_t _1299 = _1226.d1 % _1226.d1;
    _1297.d2 = _1299;
    if (_1299 > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    // Computing total size of heap memory to allocate
    int64_t _1300 = 1;
    _1300 *= _1298;
    _1300 *= _1084.d0;
    _1300 *= _1299;
    _1300 *= sizeof(_a3_int64_t);
    _1297.data = jpl_alloc(_1300);
    int64_t _1301 = 0; // q
    int64_t _1302 = 0; // p
    int64_t _1303 = 0; // o
    _jump1136:; // Begin body of loop
    _a3_int64_t _1304;
    // Computing bound for r
    _1304.d0 = _1302;
    if (_1302 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    // Computing bound for s
    _1304.d1 = _1301;
    if (_1301 > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing bound for t
    _1304.d2 = _1302;
    if (_1302 > 0) 
    goto _jump1139;
    fail_assertion("non-positive loop bound");
    _jump1139:;
    // Computing total size of heap memory to allocate
    int64_t _1305 = 1;
    _1305 *= _1302;
    _1305 *= _1301;
    _1305 *= _1302;
    _1305 *= sizeof(int64_t);
    _1304.data = jpl_alloc(_1305);
    int64_t _1306 = 0; // t
    int64_t _1307 = 0; // s
    int64_t _1308 = 0; // r
    _jump1140:; // Begin body of loop
    int64_t _1309 = 0;
    _1309 *= _1304.d0;
    _1309 += _1308;
    _1309 *= _1304.d1;
    _1309 += _1307;
    _1309 *= _1304.d2;
    _1309 += _1306;
    _1304.data[_1309] = _1084.d0;
    _1306++;
    if (_1306 < _1302)
    goto _jump1140;
    _1306 = 0;
    _1307++;
    if (_1307 < _1301)
    goto _jump1140;
    _1307 = 0;
    _1308++;
    if (_1308 < _1302)
    goto _jump1140;
    // End body of loop
    int64_t _1310 = 0;
    _1310 *= _1297.d0;
    _1310 += _1303;
    _1310 *= _1297.d1;
    _1310 += _1302;
    _1310 *= _1297.d2;
    _1310 += _1301;
    _1297.data[_1310] = _1304;
    _1301++;
    if (_1301 < _1299)
    goto _jump1136;
    _1301 = 0;
    _1302++;
    if (_1302 < _1084.d0)
    goto _jump1136;
    _1302 = 0;
    _1303++;
    if (_1303 < _1298)
    goto _jump1136;
    // End body of loop
    if (_1226.d0 >= 0)
    goto _jump1141;
    fail_assertion("negative array index");
    _jump1141:;
    if (_1226.d0 < _1297.d0)
    goto _jump1142;
    fail_assertion("index too large");
    _jump1142:;
    if (_1085.d0 >= 0)
    goto _jump1143;
    fail_assertion("negative array index");
    _jump1143:;
    if (_1085.d0 < _1297.d1)
    goto _jump1144;
    fail_assertion("index too large");
    _jump1144:;
    if (_1084.d0 >= 0)
    goto _jump1145;
    fail_assertion("negative array index");
    _jump1145:;
    if (_1084.d0 < _1297.d2)
    goto _jump1146;
    fail_assertion("index too large");
    _jump1146:;
    int64_t _1311 = 0;
    _1311 *= _1297.d0;
    _1311 += _1226.d0;
    _1311 *= _1297.d1;
    _1311 += _1085.d0;
    _1311 *= _1297.d2;
    _1311 += _1084.d0;
    _a3_int64_t _1312 = _1297.data[_1311];
    _1296 = _1312;
    goto _jump1147;
    _jump1132:;
    _a3_int64_t _1313;
    if (!_317)
    goto _jump1148;
    _a3_int64_t _1314;
    // Computing bound for o
    _1314.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    // Computing bound for p
    _1314.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    // Computing bound for q
    int64_t _1315;
    // Computing bound for o
    int64_t _1316 = 949;
    if (_1316 > 0) 
    goto _jump1151;
    fail_assertion("non-positive loop bound");
    _jump1151:;
    // Computing bound for p
    if (_1085.d0 > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    // Computing bound for q
    if (_1226.d0 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    _1315 = 0;
    int64_t _1317 = 0; // q
    int64_t _1318 = 0; // p
    int64_t _1319 = 0; // o
    _jump1154:; // Begin body of loop
    _1315 += _1319;
    _1317++;
    if (_1317 < _1226.d0)
    goto _jump1154;
    _1317 = 0;
    _1318++;
    if (_1318 < _1085.d0)
    goto _jump1154;
    _1318 = 0;
    _1319++;
    if (_1319 < _1316)
    goto _jump1154;
    // End body of loop
    _1314.d2 = _1315;
    if (_1315 > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing total size of heap memory to allocate
    int64_t _1320 = 1;
    _1320 *= _1084.d0;
    _1320 *= _1085.d0;
    _1320 *= _1315;
    _1320 *= sizeof(int64_t);
    _1314.data = jpl_alloc(_1320);
    int64_t _1321 = 0; // q
    int64_t _1322 = 0; // p
    int64_t _1323 = 0; // o
    _jump1156:; // Begin body of loop
    int64_t _1324;
    // Computing bound for r
    if (_1085.d0 > 0) 
    goto _jump1157;
    fail_assertion("non-positive loop bound");
    _jump1157:;
    // Computing bound for s
    if (_1084.d0 > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    // Computing bound for t
    if (_1226.d1 > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    _1324 = 0;
    int64_t _1325 = 0; // t
    int64_t _1326 = 0; // s
    int64_t _1327 = 0; // r
    _jump1160:; // Begin body of loop
    _1324 += _1226.d0;
    _1325++;
    if (_1325 < _1226.d1)
    goto _jump1160;
    _1325 = 0;
    _1326++;
    if (_1326 < _1084.d0)
    goto _jump1160;
    _1326 = 0;
    _1327++;
    if (_1327 < _1085.d0)
    goto _jump1160;
    // End body of loop
    int64_t _1328 = 0;
    _1328 *= _1314.d0;
    _1328 += _1323;
    _1328 *= _1314.d1;
    _1328 += _1322;
    _1328 *= _1314.d2;
    _1328 += _1321;
    _1314.data[_1328] = _1324;
    _1321++;
    if (_1321 < _1315)
    goto _jump1156;
    _1321 = 0;
    _1322++;
    if (_1322 < _1085.d0)
    goto _jump1156;
    _1322 = 0;
    _1323++;
    if (_1323 < _1084.d0)
    goto _jump1156;
    // End body of loop
    _1313 = _1314;
    goto _jump1161;
    _jump1148:;
    _a3_int64_t _1329;
    // Computing bound for o
    _1329.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1162;
    fail_assertion("non-positive loop bound");
    _jump1162:;
    // Computing bound for p
    _1329.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing bound for q
    bool _1330 = false;
    int64_t _1331;
    if (!_1330)
    goto _jump1164;
    int64_t _1332 = 964;
    _1331 = _1332;
    goto _jump1165;
    _jump1164:;
    _1331 = _1226.d1;
    _jump1165:;
    _1329.d2 = _1331;
    if (_1331 > 0) 
    goto _jump1166;
    fail_assertion("non-positive loop bound");
    _jump1166:;
    // Computing total size of heap memory to allocate
    int64_t _1333 = 1;
    _1333 *= _1085.d0;
    _1333 *= _1085.d0;
    _1333 *= _1331;
    _1333 *= sizeof(int64_t);
    _1329.data = jpl_alloc(_1333);
    int64_t _1334 = 0; // q
    int64_t _1335 = 0; // p
    int64_t _1336 = 0; // o
    _jump1167:; // Begin body of loop
    int64_t _1337 = -_1084.d0;
    int64_t _1338 = 0;
    _1338 *= _1329.d0;
    _1338 += _1336;
    _1338 *= _1329.d1;
    _1338 += _1335;
    _1338 *= _1329.d2;
    _1338 += _1334;
    _1329.data[_1338] = _1337;
    _1334++;
    if (_1334 < _1331)
    goto _jump1167;
    _1334 = 0;
    _1335++;
    if (_1335 < _1085.d0)
    goto _jump1167;
    _1335 = 0;
    _1336++;
    if (_1336 < _1085.d0)
    goto _jump1167;
    // End body of loop
    _1313 = _1329;
    _jump1161:;
    _1296 = _1313;
    _jump1147:;
    _a1__a3_int64_t _1339;
    _1339.d0 = 1;
    _1339.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _1339.data[0] = _1296;
    int64_t _1340 = _1226.d1 % _1226.d1;
    int64_t _1341 = _1340 % _1084.d0;
    int64_t _1342 = -_1341;
    if (_1342 >= 0)
    goto _jump1168;
    fail_assertion("negative array index");
    _jump1168:;
    if (_1342 < _1339.d0)
    goto _jump1169;
    fail_assertion("index too large");
    _jump1169:;
    int64_t _1343 = 0;
    _1343 *= _1339.d0;
    _1343 += _1342;
    _a3_int64_t _1344 = _1339.data[_1343];
    _1292 = _1344;
    goto _jump1170;
    _jump1129:;
    bool _1345 = false;
    _a3__a3_int64_t _1346;
    if (!_1345)
    goto _jump1171;
    bool _1347 = _1227;
    if (0 == _1227)
    goto _jump1172;
    bool _1349 = false;
    bool _1350 = !_1349;
    bool _1348 = _1350;
    if (0 != _1350)
    goto _jump1173;
    bool _1351 = true;
    bool _1352 = !_1351;
    _1348 = _1352;
    _jump1173:;
    _1347 = _1348;
    _jump1172:;
    _a3__a3_int64_t _1353;
    if (!_1347)
    goto _jump1174;
    _a3__a3_int64_t _1354;
    // Computing bound for o
    int64_t _1355 = 310;
    _1354.d0 = _1355;
    if (_1355 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    // Computing bound for p
    bool _1356 = _1227;
    if (0 != _1227)
    goto _jump1176;
    bool _1357 = true;
    _1356 = _1357;
    _jump1176:;
    int64_t _1358;
    if (!_1356)
    goto _jump1177;
    _1358 = _1084.d0;
    goto _jump1178;
    _jump1177:;
    int64_t _1359 = 855;
    _1358 = _1359;
    _jump1178:;
    _1354.d1 = _1358;
    if (_1358 > 0) 
    goto _jump1179;
    fail_assertion("non-positive loop bound");
    _jump1179:;
    // Computing bound for q
    _a2_int64_t _1360;
    // Computing bound for o
    _1360.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1180;
    fail_assertion("non-positive loop bound");
    _jump1180:;
    // Computing bound for p
    _1360.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    // Computing total size of heap memory to allocate
    int64_t _1361 = 1;
    _1361 *= _1084.d0;
    _1361 *= _1085.d0;
    _1361 *= sizeof(int64_t);
    _1360.data = jpl_alloc(_1361);
    int64_t _1362 = 0; // p
    int64_t _1363 = 0; // o
    _jump1182:; // Begin body of loop
    int64_t _1364 = 0;
    _1364 *= _1360.d0;
    _1364 += _1363;
    _1364 *= _1360.d1;
    _1364 += _1362;
    _1360.data[_1364] = _1226.d0;
    _1362++;
    if (_1362 < _1085.d0)
    goto _jump1182;
    _1362 = 0;
    _1363++;
    if (_1363 < _1084.d0)
    goto _jump1182;
    // End body of loop
    int64_t _1365 = -_1085.d0;
    int64_t _1366 = 976;
    if (_1365 >= 0)
    goto _jump1183;
    fail_assertion("negative array index");
    _jump1183:;
    if (_1365 < _1360.d0)
    goto _jump1184;
    fail_assertion("index too large");
    _jump1184:;
    if (_1366 >= 0)
    goto _jump1185;
    fail_assertion("negative array index");
    _jump1185:;
    if (_1366 < _1360.d1)
    goto _jump1186;
    fail_assertion("index too large");
    _jump1186:;
    int64_t _1367 = 0;
    _1367 *= _1360.d0;
    _1367 += _1365;
    _1367 *= _1360.d1;
    _1367 += _1366;
    int64_t _1368 = _1360.data[_1367];
    _1354.d2 = _1368;
    if (_1368 > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    // Computing total size of heap memory to allocate
    int64_t _1369 = 1;
    _1369 *= _1355;
    _1369 *= _1358;
    _1369 *= _1368;
    _1369 *= sizeof(_a3_int64_t);
    _1354.data = jpl_alloc(_1369);
    int64_t _1370 = 0; // q
    int64_t _1371 = 0; // p
    int64_t _1372 = 0; // o
    _jump1188:; // Begin body of loop
    _a3_int64_t _1373;
    if (!_317)
    goto _jump1189;
    _a3_int64_t _1374;
    // Computing bound for r
    _1374.d0 = _1370;
    if (_1370 > 0) 
    goto _jump1190;
    fail_assertion("non-positive loop bound");
    _jump1190:;
    // Computing bound for s
    _1374.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing bound for t
    _1374.d2 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    // Computing total size of heap memory to allocate
    int64_t _1375 = 1;
    _1375 *= _1370;
    _1375 *= _1226.d0;
    _1375 *= _1226.d0;
    _1375 *= sizeof(int64_t);
    _1374.data = jpl_alloc(_1375);
    int64_t _1376 = 0; // t
    int64_t _1377 = 0; // s
    int64_t _1378 = 0; // r
    _jump1193:; // Begin body of loop
    int64_t _1379 = 0;
    _1379 *= _1374.d0;
    _1379 += _1378;
    _1379 *= _1374.d1;
    _1379 += _1377;
    _1379 *= _1374.d2;
    _1379 += _1376;
    _1374.data[_1379] = _1226.d1;
    _1376++;
    if (_1376 < _1226.d0)
    goto _jump1193;
    _1376 = 0;
    _1377++;
    if (_1377 < _1226.d0)
    goto _jump1193;
    _1377 = 0;
    _1378++;
    if (_1378 < _1370)
    goto _jump1193;
    // End body of loop
    _1373 = _1374;
    goto _jump1194;
    _jump1189:;
    _a3_int64_t _1380;
    // Computing bound for r
    _1380.d0 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1195;
    fail_assertion("non-positive loop bound");
    _jump1195:;
    // Computing bound for s
    _1380.d1 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for t
    _1380.d2 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing total size of heap memory to allocate
    int64_t _1381 = 1;
    _1381 *= _1226.d0;
    _1381 *= _1226.d1;
    _1381 *= _1084.d0;
    _1381 *= sizeof(int64_t);
    _1380.data = jpl_alloc(_1381);
    int64_t _1382 = 0; // t
    int64_t _1383 = 0; // s
    int64_t _1384 = 0; // r
    _jump1198:; // Begin body of loop
    int64_t _1385 = 0;
    _1385 *= _1380.d0;
    _1385 += _1384;
    _1385 *= _1380.d1;
    _1385 += _1383;
    _1385 *= _1380.d2;
    _1385 += _1382;
    _1380.data[_1385] = _1226.d0;
    _1382++;
    if (_1382 < _1084.d0)
    goto _jump1198;
    _1382 = 0;
    _1383++;
    if (_1383 < _1226.d1)
    goto _jump1198;
    _1383 = 0;
    _1384++;
    if (_1384 < _1226.d0)
    goto _jump1198;
    // End body of loop
    _1373 = _1380;
    _jump1194:;
    int64_t _1386 = 0;
    _1386 *= _1354.d0;
    _1386 += _1372;
    _1386 *= _1354.d1;
    _1386 += _1371;
    _1386 *= _1354.d2;
    _1386 += _1370;
    _1354.data[_1386] = _1373;
    _1370++;
    if (_1370 < _1368)
    goto _jump1188;
    _1370 = 0;
    _1371++;
    if (_1371 < _1358)
    goto _jump1188;
    _1371 = 0;
    _1372++;
    if (_1372 < _1355)
    goto _jump1188;
    // End body of loop
    _1353 = _1354;
    goto _jump1199;
    _jump1174:;
    bool _1388 = !_1227;
    bool _1387 = _1388;
    if (0 != _1388)
    goto _jump1200;
    bool _1389 = !_1227;
    _1387 = _1389;
    _jump1200:;
    _a3__a3_int64_t _1390;
    if (!_1387)
    goto _jump1201;
    _a3__a3_int64_t _1391;
    // Computing bound for o
    int64_t _1392;
    // Computing bound for o
    int64_t _1393 = 831;
    if (_1393 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    _1392 = 0;
    int64_t _1394 = 0; // o
    _jump1203:; // Begin body of loop
    _1392 += _1085.d0;
    _1394++;
    if (_1394 < _1393)
    goto _jump1203;
    // End body of loop
    _1391.d0 = _1392;
    if (_1392 > 0) 
    goto _jump1204;
    fail_assertion("non-positive loop bound");
    _jump1204:;
    // Computing bound for p
    int64_t _1395;
    // Computing bound for o
    int64_t _1396 = 323;
    if (_1396 > 0) 
    goto _jump1205;
    fail_assertion("non-positive loop bound");
    _jump1205:;
    // Computing bound for p
    if (_1226.d0 > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    _1395 = 0;
    int64_t _1397 = 0; // p
    int64_t _1398 = 0; // o
    _jump1207:; // Begin body of loop
    _1395 += _1085.d0;
    _1397++;
    if (_1397 < _1226.d0)
    goto _jump1207;
    _1397 = 0;
    _1398++;
    if (_1398 < _1396)
    goto _jump1207;
    // End body of loop
    _1391.d1 = _1395;
    if (_1395 > 0) 
    goto _jump1208;
    fail_assertion("non-positive loop bound");
    _jump1208:;
    // Computing bound for q
    _1391.d2 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing total size of heap memory to allocate
    int64_t _1399 = 1;
    _1399 *= _1392;
    _1399 *= _1395;
    _1399 *= _1084.d0;
    _1399 *= sizeof(_a3_int64_t);
    _1391.data = jpl_alloc(_1399);
    int64_t _1400 = 0; // q
    int64_t _1401 = 0; // p
    int64_t _1402 = 0; // o
    _jump1210:; // Begin body of loop
    _a3_int64_t _1403;
    // Computing bound for r
    _1403.d0 = _1401;
    if (_1401 > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing bound for s
    _1403.d1 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    // Computing bound for t
    _1403.d2 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1213;
    fail_assertion("non-positive loop bound");
    _jump1213:;
    // Computing total size of heap memory to allocate
    int64_t _1404 = 1;
    _1404 *= _1401;
    _1404 *= _1084.d0;
    _1404 *= _1226.d1;
    _1404 *= sizeof(int64_t);
    _1403.data = jpl_alloc(_1404);
    int64_t _1405 = 0; // t
    int64_t _1406 = 0; // s
    int64_t _1407 = 0; // r
    _jump1214:; // Begin body of loop
    int64_t _1408 = 0;
    _1408 *= _1403.d0;
    _1408 += _1407;
    _1408 *= _1403.d1;
    _1408 += _1406;
    _1408 *= _1403.d2;
    _1408 += _1405;
    _1403.data[_1408] = _1406;
    _1405++;
    if (_1405 < _1226.d1)
    goto _jump1214;
    _1405 = 0;
    _1406++;
    if (_1406 < _1084.d0)
    goto _jump1214;
    _1406 = 0;
    _1407++;
    if (_1407 < _1401)
    goto _jump1214;
    // End body of loop
    int64_t _1409 = 0;
    _1409 *= _1391.d0;
    _1409 += _1402;
    _1409 *= _1391.d1;
    _1409 += _1401;
    _1409 *= _1391.d2;
    _1409 += _1400;
    _1391.data[_1409] = _1403;
    _1400++;
    if (_1400 < _1084.d0)
    goto _jump1210;
    _1400 = 0;
    _1401++;
    if (_1401 < _1395)
    goto _jump1210;
    _1401 = 0;
    _1402++;
    if (_1402 < _1392)
    goto _jump1210;
    // End body of loop
    _1390 = _1391;
    goto _jump1215;
    _jump1201:;
    _a3__a3_int64_t _1410;
    // Computing bound for o
    bool _1411 = true;
    int64_t _1412;
    if (!_1411)
    goto _jump1216;
    _1412 = _1084.d0;
    goto _jump1217;
    _jump1216:;
    _1412 = _1084.d0;
    _jump1217:;
    _1410.d0 = _1412;
    if (_1412 > 0) 
    goto _jump1218;
    fail_assertion("non-positive loop bound");
    _jump1218:;
    // Computing bound for p
    _1410.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing bound for q
    int64_t _1413 = -_1084.d0;
    _1410.d2 = _1413;
    if (_1413 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing total size of heap memory to allocate
    int64_t _1414 = 1;
    _1414 *= _1412;
    _1414 *= _1085.d0;
    _1414 *= _1413;
    _1414 *= sizeof(_a3_int64_t);
    _1410.data = jpl_alloc(_1414);
    int64_t _1415 = 0; // q
    int64_t _1416 = 0; // p
    int64_t _1417 = 0; // o
    _jump1221:; // Begin body of loop
    _a3_int64_t _1418;
    // Computing bound for r
    _1418.d0 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for s
    _1418.d1 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing bound for t
    int64_t _1419 = 889;
    _1418.d2 = _1419;
    if (_1419 > 0) 
    goto _jump1224;
    fail_assertion("non-positive loop bound");
    _jump1224:;
    // Computing total size of heap memory to allocate
    int64_t _1420 = 1;
    _1420 *= _1226.d0;
    _1420 *= _1226.d1;
    _1420 *= _1419;
    _1420 *= sizeof(int64_t);
    _1418.data = jpl_alloc(_1420);
    int64_t _1421 = 0; // t
    int64_t _1422 = 0; // s
    int64_t _1423 = 0; // r
    _jump1225:; // Begin body of loop
    int64_t _1424 = 0;
    _1424 *= _1418.d0;
    _1424 += _1423;
    _1424 *= _1418.d1;
    _1424 += _1422;
    _1424 *= _1418.d2;
    _1424 += _1421;
    _1418.data[_1424] = _1416;
    _1421++;
    if (_1421 < _1419)
    goto _jump1225;
    _1421 = 0;
    _1422++;
    if (_1422 < _1226.d1)
    goto _jump1225;
    _1422 = 0;
    _1423++;
    if (_1423 < _1226.d0)
    goto _jump1225;
    // End body of loop
    int64_t _1425 = 0;
    _1425 *= _1410.d0;
    _1425 += _1417;
    _1425 *= _1410.d1;
    _1425 += _1416;
    _1425 *= _1410.d2;
    _1425 += _1415;
    _1410.data[_1425] = _1418;
    _1415++;
    if (_1415 < _1413)
    goto _jump1221;
    _1415 = 0;
    _1416++;
    if (_1416 < _1085.d0)
    goto _jump1221;
    _1416 = 0;
    _1417++;
    if (_1417 < _1412)
    goto _jump1221;
    // End body of loop
    _1390 = _1410;
    _jump1215:;
    _1353 = _1390;
    _jump1199:;
    _1346 = _1353;
    goto _jump1226;
    _jump1171:;
    bool _1427 = _317;
    if (0 != _317)
    goto _jump1227;
    _1427 = _317;
    _jump1227:;
    bool _1428;
    if (!_1427)
    goto _jump1228;
    bool _1429 = _1084.d0 != _1084.d0;
    _1428 = _1429;
    goto _jump1229;
    _jump1228:;
    bool _1430 = false;
    bool _1431 = !_1430;
    _1428 = _1431;
    _jump1229:;
    bool _1426 = _1428;
    if (0 == _1428)
    goto _jump1230;
    bool _1432 = false;
    _1426 = _1432;
    _jump1230:;
    _a3__a3_int64_t _1433;
    if (!_1426)
    goto _jump1231;
    _a3__a3_int64_t _1434;
    // Computing bound for o
    _1434.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    // Computing bound for p
    _1434.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing bound for q
    _a3_int64_t _1435;
    // Computing bound for o
    _1435.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing bound for p
    _1435.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1235;
    fail_assertion("non-positive loop bound");
    _jump1235:;
    // Computing bound for q
    _1435.d2 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing total size of heap memory to allocate
    int64_t _1436 = 1;
    _1436 *= _1085.d0;
    _1436 *= _1226.d0;
    _1436 *= _1085.d0;
    _1436 *= sizeof(int64_t);
    _1435.data = jpl_alloc(_1436);
    int64_t _1437 = 0; // q
    int64_t _1438 = 0; // p
    int64_t _1439 = 0; // o
    _jump1237:; // Begin body of loop
    int64_t _1440 = 594;
    int64_t _1441 = 0;
    _1441 *= _1435.d0;
    _1441 += _1439;
    _1441 *= _1435.d1;
    _1441 += _1438;
    _1441 *= _1435.d2;
    _1441 += _1437;
    _1435.data[_1441] = _1440;
    _1437++;
    if (_1437 < _1085.d0)
    goto _jump1237;
    _1437 = 0;
    _1438++;
    if (_1438 < _1226.d0)
    goto _jump1237;
    _1438 = 0;
    _1439++;
    if (_1439 < _1085.d0)
    goto _jump1237;
    // End body of loop
    int64_t _1442;
    if (!_317)
    goto _jump1238;
    _1442 = _1084.d0;
    goto _jump1239;
    _jump1238:;
    int64_t _1443 = 604;
    _1442 = _1443;
    _jump1239:;
    if (_1442 >= 0)
    goto _jump1240;
    fail_assertion("negative array index");
    _jump1240:;
    if (_1442 < _1435.d0)
    goto _jump1241;
    fail_assertion("index too large");
    _jump1241:;
    if (_1226.d0 >= 0)
    goto _jump1242;
    fail_assertion("negative array index");
    _jump1242:;
    if (_1226.d0 < _1435.d1)
    goto _jump1243;
    fail_assertion("index too large");
    _jump1243:;
    if (_1085.d0 >= 0)
    goto _jump1244;
    fail_assertion("negative array index");
    _jump1244:;
    if (_1085.d0 < _1435.d2)
    goto _jump1245;
    fail_assertion("index too large");
    _jump1245:;
    int64_t _1444 = 0;
    _1444 *= _1435.d0;
    _1444 += _1442;
    _1444 *= _1435.d1;
    _1444 += _1226.d0;
    _1444 *= _1435.d2;
    _1444 += _1085.d0;
    int64_t _1445 = _1435.data[_1444];
    _1434.d2 = _1445;
    if (_1445 > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing total size of heap memory to allocate
    int64_t _1446 = 1;
    _1446 *= _1084.d0;
    _1446 *= _1085.d0;
    _1446 *= _1445;
    _1446 *= sizeof(_a3_int64_t);
    _1434.data = jpl_alloc(_1446);
    int64_t _1447 = 0; // q
    int64_t _1448 = 0; // p
    int64_t _1449 = 0; // o
    _jump1247:; // Begin body of loop
    _a3_int64_t _1450;
    // Computing bound for r
    int64_t _1451 = 291;
    _1450.d0 = _1451;
    if (_1451 > 0) 
    goto _jump1248;
    fail_assertion("non-positive loop bound");
    _jump1248:;
    // Computing bound for s
    _1450.d1 = _1448;
    if (_1448 > 0) 
    goto _jump1249;
    fail_assertion("non-positive loop bound");
    _jump1249:;
    // Computing bound for t
    if (_1449 >= 0)
    goto _jump1250;
    fail_assertion("negative array index");
    _jump1250:;
    if (_1449 < _1085.d0)
    goto _jump1251;
    fail_assertion("index too large");
    _jump1251:;
    int64_t _1452 = 0;
    _1452 *= _1085.d0;
    _1452 += _1449;
    int64_t _1453 = _1085.data[_1452];
    _1450.d2 = _1453;
    if (_1453 > 0) 
    goto _jump1252;
    fail_assertion("non-positive loop bound");
    _jump1252:;
    // Computing total size of heap memory to allocate
    int64_t _1454 = 1;
    _1454 *= _1451;
    _1454 *= _1448;
    _1454 *= _1453;
    _1454 *= sizeof(int64_t);
    _1450.data = jpl_alloc(_1454);
    int64_t _1455 = 0; // t
    int64_t _1456 = 0; // s
    int64_t _1457 = 0; // r
    _jump1253:; // Begin body of loop
    int64_t _1458 = 0;
    _1458 *= _1450.d0;
    _1458 += _1457;
    _1458 *= _1450.d1;
    _1458 += _1456;
    _1458 *= _1450.d2;
    _1458 += _1455;
    _1450.data[_1458] = _1455;
    _1455++;
    if (_1455 < _1453)
    goto _jump1253;
    _1455 = 0;
    _1456++;
    if (_1456 < _1448)
    goto _jump1253;
    _1456 = 0;
    _1457++;
    if (_1457 < _1451)
    goto _jump1253;
    // End body of loop
    int64_t _1459 = 0;
    _1459 *= _1434.d0;
    _1459 += _1449;
    _1459 *= _1434.d1;
    _1459 += _1448;
    _1459 *= _1434.d2;
    _1459 += _1447;
    _1434.data[_1459] = _1450;
    _1447++;
    if (_1447 < _1445)
    goto _jump1247;
    _1447 = 0;
    _1448++;
    if (_1448 < _1085.d0)
    goto _jump1247;
    _1448 = 0;
    _1449++;
    if (_1449 < _1084.d0)
    goto _jump1247;
    // End body of loop
    _1433 = _1434;
    goto _jump1254;
    _jump1231:;
    int64_t _1460 = 409;
    bool _1461 = _1460 == _1085.d0;
    bool _1462;
    if (!_1461)
    goto _jump1255;
    int64_t _1463 = 751;
    bool _1464 = _1463 == _1084.d0;
    _1462 = _1464;
    goto _jump1256;
    _jump1255:;
    bool _1465 = false;
    _1462 = _1465;
    _jump1256:;
    _a3__a3_int64_t _1466;
    if (!_1462)
    goto _jump1257;
    _a3__a3_int64_t _1467;
    // Computing bound for o
    _1467.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    // Computing bound for p
    int64_t _1468 = -_1085.d0;
    _1467.d1 = _1468;
    if (_1468 > 0) 
    goto _jump1259;
    fail_assertion("non-positive loop bound");
    _jump1259:;
    // Computing bound for q
    _1467.d2 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    // Computing total size of heap memory to allocate
    int64_t _1469 = 1;
    _1469 *= _1084.d0;
    _1469 *= _1468;
    _1469 *= _1226.d0;
    _1469 *= sizeof(_a3_int64_t);
    _1467.data = jpl_alloc(_1469);
    int64_t _1470 = 0; // q
    int64_t _1471 = 0; // p
    int64_t _1472 = 0; // o
    _jump1261:; // Begin body of loop
    _a3_int64_t _1473;
    // Computing bound for r
    _1473.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    // Computing bound for s
    _1473.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1263;
    fail_assertion("non-positive loop bound");
    _jump1263:;
    // Computing bound for t
    _1473.d2 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing total size of heap memory to allocate
    int64_t _1474 = 1;
    _1474 *= _1084.d0;
    _1474 *= _1226.d0;
    _1474 *= _1085.d0;
    _1474 *= sizeof(int64_t);
    _1473.data = jpl_alloc(_1474);
    int64_t _1475 = 0; // t
    int64_t _1476 = 0; // s
    int64_t _1477 = 0; // r
    _jump1265:; // Begin body of loop
    int64_t _1478 = 0;
    _1478 *= _1473.d0;
    _1478 += _1477;
    _1478 *= _1473.d1;
    _1478 += _1476;
    _1478 *= _1473.d2;
    _1478 += _1475;
    _1473.data[_1478] = _1470;
    _1475++;
    if (_1475 < _1085.d0)
    goto _jump1265;
    _1475 = 0;
    _1476++;
    if (_1476 < _1226.d0)
    goto _jump1265;
    _1476 = 0;
    _1477++;
    if (_1477 < _1084.d0)
    goto _jump1265;
    // End body of loop
    int64_t _1479 = 0;
    _1479 *= _1467.d0;
    _1479 += _1472;
    _1479 *= _1467.d1;
    _1479 += _1471;
    _1479 *= _1467.d2;
    _1479 += _1470;
    _1467.data[_1479] = _1473;
    _1470++;
    if (_1470 < _1226.d0)
    goto _jump1261;
    _1470 = 0;
    _1471++;
    if (_1471 < _1468)
    goto _jump1261;
    _1471 = 0;
    _1472++;
    if (_1472 < _1084.d0)
    goto _jump1261;
    // End body of loop
    _1466 = _1467;
    goto _jump1266;
    _jump1257:;
    _a3__a3_int64_t _1480;
    // Computing bound for o
    _1480.d0 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    // Computing bound for p
    _1480.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    // Computing bound for q
    int64_t _1481 = -_1226.d0;
    _1480.d2 = _1481;
    if (_1481 > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    // Computing total size of heap memory to allocate
    int64_t _1482 = 1;
    _1482 *= _1226.d1;
    _1482 *= _1226.d0;
    _1482 *= _1481;
    _1482 *= sizeof(_a3_int64_t);
    _1480.data = jpl_alloc(_1482);
    int64_t _1483 = 0; // q
    int64_t _1484 = 0; // p
    int64_t _1485 = 0; // o
    _jump1270:; // Begin body of loop
    _a3_int64_t _1486;
    // Computing bound for r
    _1486.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1271;
    fail_assertion("non-positive loop bound");
    _jump1271:;
    // Computing bound for s
    _1486.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for t
    _1486.d2 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing total size of heap memory to allocate
    int64_t _1487 = 1;
    _1487 *= _1084.d0;
    _1487 *= _1085.d0;
    _1487 *= _1226.d1;
    _1487 *= sizeof(int64_t);
    _1486.data = jpl_alloc(_1487);
    int64_t _1488 = 0; // t
    int64_t _1489 = 0; // s
    int64_t _1490 = 0; // r
    _jump1274:; // Begin body of loop
    int64_t _1491 = 0;
    _1491 *= _1486.d0;
    _1491 += _1490;
    _1491 *= _1486.d1;
    _1491 += _1489;
    _1491 *= _1486.d2;
    _1491 += _1488;
    _1486.data[_1491] = _1484;
    _1488++;
    if (_1488 < _1226.d1)
    goto _jump1274;
    _1488 = 0;
    _1489++;
    if (_1489 < _1085.d0)
    goto _jump1274;
    _1489 = 0;
    _1490++;
    if (_1490 < _1084.d0)
    goto _jump1274;
    // End body of loop
    int64_t _1492 = 0;
    _1492 *= _1480.d0;
    _1492 += _1485;
    _1492 *= _1480.d1;
    _1492 += _1484;
    _1492 *= _1480.d2;
    _1492 += _1483;
    _1480.data[_1492] = _1486;
    _1483++;
    if (_1483 < _1481)
    goto _jump1270;
    _1483 = 0;
    _1484++;
    if (_1484 < _1226.d0)
    goto _jump1270;
    _1484 = 0;
    _1485++;
    if (_1485 < _1226.d1)
    goto _jump1270;
    // End body of loop
    _1466 = _1480;
    _jump1266:;
    _1433 = _1466;
    _jump1254:;
    _1346 = _1433;
    _jump1226:;
    int64_t _1493 = 66;
    int64_t _1494 = -_1493;
    if (_1226.d0 >= 0)
    goto _jump1275;
    fail_assertion("negative array index");
    _jump1275:;
    if (_1226.d0 < _1346.d0)
    goto _jump1276;
    fail_assertion("index too large");
    _jump1276:;
    if (_1494 >= 0)
    goto _jump1277;
    fail_assertion("negative array index");
    _jump1277:;
    if (_1494 < _1346.d1)
    goto _jump1278;
    fail_assertion("index too large");
    _jump1278:;
    if (_1085.d0 >= 0)
    goto _jump1279;
    fail_assertion("negative array index");
    _jump1279:;
    if (_1085.d0 < _1346.d2)
    goto _jump1280;
    fail_assertion("index too large");
    _jump1280:;
    int64_t _1495 = 0;
    _1495 *= _1346.d0;
    _1495 += _1226.d0;
    _1495 *= _1346.d1;
    _1495 += _1494;
    _1495 *= _1346.d2;
    _1495 += _1085.d0;
    _a3_int64_t _1496 = _1346.data[_1495];
    _1292 = _1496;
    _jump1170:;
    _a2_rgba _1497;
    if (!_1227)
    goto _jump1281;
    _1497 = _689;
    goto _jump1282;
    _jump1281:;
    _1497 = _1226;
    _jump1282:;
    if (_1292.d2 >= 0)
    goto _jump1283;
    fail_assertion("negative array index");
    _jump1283:;
    if (_1292.d2 < _1497.d0)
    goto _jump1284;
    fail_assertion("index too large");
    _jump1284:;
    if (_1292.d1 >= 0)
    goto _jump1285;
    fail_assertion("negative array index");
    _jump1285:;
    if (_1292.d1 < _1497.d1)
    goto _jump1286;
    fail_assertion("index too large");
    _jump1286:;
    int64_t _1498 = 0;
    _1498 *= _1497.d0;
    _1498 += _1292.d2;
    _1498 *= _1497.d1;
    _1498 += _1292.d1;
    rgba _1499 = _1497.data[_1498];
    double _1500 = _1499.a;
    double _1501 = 80.0;
    _a3_double _1502;
    // Computing bound for s
    _1502.d0 = _1292.d1;
    if (_1292.d1 > 0) 
    goto _jump1287;
    fail_assertion("non-positive loop bound");
    _jump1287:;
    // Computing bound for t
    _1502.d1 = _1292.d1;
    if (_1292.d1 > 0) 
    goto _jump1288;
    fail_assertion("non-positive loop bound");
    _jump1288:;
    // Computing bound for u
    bool _1503 = false;
    int64_t _1504;
    if (!_1503)
    goto _jump1289;
    _1504 = _1085.d0;
    goto _jump1290;
    _jump1289:;
    _1504 = _1226.d1;
    _jump1290:;
    _1502.d2 = _1504;
    if (_1504 > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    // Computing total size of heap memory to allocate
    int64_t _1505 = 1;
    _1505 *= _1292.d1;
    _1505 *= _1292.d1;
    _1505 *= _1504;
    _1505 *= sizeof(double);
    _1502.data = jpl_alloc(_1505);
    int64_t _1506 = 0; // u
    int64_t _1507 = 0; // t
    int64_t _1508 = 0; // s
    _jump1292:; // Begin body of loop
    int64_t _1509 = 0;
    _1509 *= _1502.d0;
    _1509 += _1508;
    _1509 *= _1502.d1;
    _1509 += _1507;
    _1509 *= _1502.d2;
    _1509 += _1506;
    _1502.data[_1509] = _316;
    _1506++;
    if (_1506 < _1504)
    goto _jump1292;
    _1506 = 0;
    _1507++;
    if (_1507 < _1292.d1)
    goto _jump1292;
    _1507 = 0;
    _1508++;
    if (_1508 < _1292.d1)
    goto _jump1292;
    // End body of loop
    int64_t _1510 = 312;
    if (_1292.d2 >= 0)
    goto _jump1293;
    fail_assertion("negative array index");
    _jump1293:;
    if (_1292.d2 < _1502.d0)
    goto _jump1294;
    fail_assertion("index too large");
    _jump1294:;
    if (_1510 >= 0)
    goto _jump1295;
    fail_assertion("negative array index");
    _jump1295:;
    if (_1510 < _1502.d1)
    goto _jump1296;
    fail_assertion("index too large");
    _jump1296:;
    if (_1292.d2 >= 0)
    goto _jump1297;
    fail_assertion("negative array index");
    _jump1297:;
    if (_1292.d2 < _1502.d2)
    goto _jump1298;
    fail_assertion("index too large");
    _jump1298:;
    int64_t _1511 = 0;
    _1511 *= _1502.d0;
    _1511 += _1292.d2;
    _1511 *= _1502.d1;
    _1511 += _1510;
    _1511 *= _1502.d2;
    _1511 += _1292.d2;
    double _1512 = _1502.data[_1511];
    double _1513 = 21.0;
    double _1514 = _1512 - _1513;
    rgba _1515 = { _1500, _1501, _316, _1514 };
    double _1516 = _1515.g;
    _a2_bool _1517;
    // Computing bound for s
    bool _1518 = !_1227;
    int64_t _1519;
    if (!_1518)
    goto _jump1299;
    _1519 = _1084.d0;
    goto _jump1300;
    _jump1299:;
    _1519 = _1226.d0;
    _jump1300:;
    int64_t _1520 = -_1226.d1;
    int64_t _1521 = -_1520;
    int64_t _1522 = _1519 * _1521;
    _1517.d0 = _1522;
    if (_1522 > 0) 
    goto _jump1301;
    fail_assertion("non-positive loop bound");
    _jump1301:;
    // Computing bound for t
    _1517.d1 = _1292.d2;
    if (_1292.d2 > 0) 
    goto _jump1302;
    fail_assertion("non-positive loop bound");
    _jump1302:;
    // Computing total size of heap memory to allocate
    int64_t _1523 = 1;
    _1523 *= _1522;
    _1523 *= _1292.d2;
    _1523 *= sizeof(bool);
    _1517.data = jpl_alloc(_1523);
    int64_t _1524 = 0; // t
    int64_t _1525 = 0; // s
    _jump1303:; // Begin body of loop
    _a3_bool _1526;
    // Computing bound for u
    int64_t _1527;
    // Computing bound for u
    if (_1524 > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    _1527 = 0;
    int64_t _1528 = 0; // u
    _jump1305:; // Begin body of loop
    _1527 += _1292.d0;
    _1528++;
    if (_1528 < _1524)
    goto _jump1305;
    // End body of loop
    _1526.d0 = _1527;
    if (_1527 > 0) 
    goto _jump1306;
    fail_assertion("non-positive loop bound");
    _jump1306:;
    // Computing bound for v
    _1526.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing bound for w
    _1526.d2 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1308;
    fail_assertion("non-positive loop bound");
    _jump1308:;
    // Computing total size of heap memory to allocate
    int64_t _1529 = 1;
    _1529 *= _1527;
    _1529 *= _1226.d0;
    _1529 *= _1226.d1;
    _1529 *= sizeof(bool);
    _1526.data = jpl_alloc(_1529);
    int64_t _1530 = 0; // w
    int64_t _1531 = 0; // v
    int64_t _1532 = 0; // u
    _jump1309:; // Begin body of loop
    double _1533 = 5.0;
    bool _1534 = _316 == _1533;
    int64_t _1535 = 0;
    _1535 *= _1526.d0;
    _1535 += _1532;
    _1535 *= _1526.d1;
    _1535 += _1531;
    _1535 *= _1526.d2;
    _1535 += _1530;
    _1526.data[_1535] = _1534;
    _1530++;
    if (_1530 < _1226.d1)
    goto _jump1309;
    _1530 = 0;
    _1531++;
    if (_1531 < _1226.d0)
    goto _jump1309;
    _1531 = 0;
    _1532++;
    if (_1532 < _1527)
    goto _jump1309;
    // End body of loop
    int64_t _1536;
    // Computing bound for u
    int64_t _1537 = -_1085.d0;
    if (_1537 > 0) 
    goto _jump1310;
    fail_assertion("non-positive loop bound");
    _jump1310:;
    // Computing bound for v
    if (_1084.d0 > 0) 
    goto _jump1311;
    fail_assertion("non-positive loop bound");
    _jump1311:;
    // Computing bound for w
    if (_1226.d1 > 0) 
    goto _jump1312;
    fail_assertion("non-positive loop bound");
    _jump1312:;
    _1536 = 0;
    int64_t _1538 = 0; // w
    int64_t _1539 = 0; // v
    int64_t _1540 = 0; // u
    _jump1313:; // Begin body of loop
    int64_t _1541;
    if (!_1227)
    goto _jump1314;
    _1541 = _1292.d2;
    goto _jump1315;
    _jump1314:;
    _1541 = _1539;
    _jump1315:;
    _1536 += _1541;
    _1538++;
    if (_1538 < _1226.d1)
    goto _jump1313;
    _1538 = 0;
    _1539++;
    if (_1539 < _1084.d0)
    goto _jump1313;
    _1539 = 0;
    _1540++;
    if (_1540 < _1537)
    goto _jump1313;
    // End body of loop
    if (_1226.d0 >= 0)
    goto _jump1316;
    fail_assertion("negative array index");
    _jump1316:;
    if (_1226.d0 < _1526.d0)
    goto _jump1317;
    fail_assertion("index too large");
    _jump1317:;
    if (_1536 >= 0)
    goto _jump1318;
    fail_assertion("negative array index");
    _jump1318:;
    if (_1536 < _1526.d1)
    goto _jump1319;
    fail_assertion("index too large");
    _jump1319:;
    if (_1085.d0 >= 0)
    goto _jump1320;
    fail_assertion("negative array index");
    _jump1320:;
    if (_1085.d0 < _1526.d2)
    goto _jump1321;
    fail_assertion("index too large");
    _jump1321:;
    int64_t _1542 = 0;
    _1542 *= _1526.d0;
    _1542 += _1226.d0;
    _1542 *= _1526.d1;
    _1542 += _1536;
    _1542 *= _1526.d2;
    _1542 += _1085.d0;
    bool _1543 = _1526.data[_1542];
    int64_t _1544 = 0;
    _1544 *= _1517.d0;
    _1544 += _1525;
    _1544 *= _1517.d1;
    _1544 += _1524;
    _1517.data[_1544] = _1543;
    _1524++;
    if (_1524 < _1292.d2)
    goto _jump1303;
    _1524 = 0;
    _1525++;
    if (_1525 < _1522)
    goto _jump1303;
    // End body of loop
    int64_t _1545;
    // Computing bound for s
    if (_1292.d0 > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    _1545 = 0;
    int64_t _1546 = 0; // s
    _jump1323:; // Begin body of loop
    int64_t _1547 = 14;
    if (_1547 >= 0)
    goto _jump1324;
    fail_assertion("negative array index");
    _jump1324:;
    if (_1547 < _1085.d0)
    goto _jump1325;
    fail_assertion("index too large");
    _jump1325:;
    int64_t _1548 = 0;
    _1548 *= _1085.d0;
    _1548 += _1547;
    int64_t _1549 = _1085.data[_1548];
    _1545 += _1549;
    _1546++;
    if (_1546 < _1292.d0)
    goto _jump1323;
    // End body of loop
    if (_1084.d0 >= 0)
    goto _jump1326;
    fail_assertion("negative array index");
    _jump1326:;
    if (_1084.d0 < _1517.d0)
    goto _jump1327;
    fail_assertion("index too large");
    _jump1327:;
    if (_1545 >= 0)
    goto _jump1328;
    fail_assertion("negative array index");
    _jump1328:;
    if (_1545 < _1517.d1)
    goto _jump1329;
    fail_assertion("index too large");
    _jump1329:;
    int64_t _1550 = 0;
    _1550 *= _1517.d0;
    _1550 += _1084.d0;
    _1550 *= _1517.d1;
    _1550 += _1545;
    bool _1551 = _1517.data[_1550];
    double _1552;
    if (!_1551)
    goto _jump1330;
    double _1553;
    // Computing bound for s
    int64_t _1554 = -_1292.d0;
    int64_t _1555 = _1554 * _1226.d1;
    if (_1555 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    // Computing bound for t
    if (_1085.d0 > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    _1553 = 0;
    int64_t _1556 = 0; // t
    int64_t _1557 = 0; // s
    _jump1333:; // Begin body of loop
    double _1558 = 94.0;
    _1553 += _1558;
    _1556++;
    if (_1556 < _1085.d0)
    goto _jump1333;
    _1556 = 0;
    _1557++;
    if (_1557 < _1555)
    goto _jump1333;
    // End body of loop
    double _1559;
    // Computing bound for s
    int64_t _1560;
    // Computing bound for s
    if (_1292.d1 > 0) 
    goto _jump1334;
    fail_assertion("non-positive loop bound");
    _jump1334:;
    // Computing bound for t
    if (_1292.d2 > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    // Computing bound for u
    if (_1084.d0 > 0) 
    goto _jump1336;
    fail_assertion("non-positive loop bound");
    _jump1336:;
    _1560 = 0;
    int64_t _1561 = 0; // u
    int64_t _1562 = 0; // t
    int64_t _1563 = 0; // s
    _jump1337:; // Begin body of loop
    int64_t _1564;
    // Computing bound for v
    if (_1226.d1 > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing bound for w
    if (_1292.d2 > 0) 
    goto _jump1339;
    fail_assertion("non-positive loop bound");
    _jump1339:;
    _1564 = 0;
    int64_t _1565 = 0; // w
    int64_t _1566 = 0; // v
    _jump1340:; // Begin body of loop
    _1564 += _1562;
    _1565++;
    if (_1565 < _1292.d2)
    goto _jump1340;
    _1565 = 0;
    _1566++;
    if (_1566 < _1226.d1)
    goto _jump1340;
    // End body of loop
    _1560 += _1564;
    _1561++;
    if (_1561 < _1084.d0)
    goto _jump1337;
    _1561 = 0;
    _1562++;
    if (_1562 < _1292.d2)
    goto _jump1337;
    _1562 = 0;
    _1563++;
    if (_1563 < _1292.d1)
    goto _jump1337;
    // End body of loop
    if (_1560 > 0) 
    goto _jump1341;
    fail_assertion("non-positive loop bound");
    _jump1341:;
    // Computing bound for t
    int64_t _1567 = _1292.d1 + _1292.d2;
    int64_t _1568 = -_1567;
    if (_1568 > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    _1559 = 0;
    int64_t _1569 = 0; // t
    int64_t _1570 = 0; // s
    _jump1343:; // Begin body of loop
    double _1571 = 28.0;
    _1559 += _1571;
    _1569++;
    if (_1569 < _1568)
    goto _jump1343;
    _1569 = 0;
    _1570++;
    if (_1570 < _1560)
    goto _jump1343;
    // End body of loop
    double _1572 = fmod(_1553, _1559);
    _1552 = _1572;
    goto _jump1344;
    _jump1330:;
    double _1573;
    if (!_317)
    goto _jump1345;
    _1573 = _316;
    goto _jump1346;
    _jump1345:;
    _a1_double _1574;
    // Computing bound for s
    _1574.d0 = _1292.d0;
    if (_1292.d0 > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing total size of heap memory to allocate
    int64_t _1575 = 1;
    _1575 *= _1292.d0;
    _1575 *= sizeof(double);
    _1574.data = jpl_alloc(_1575);
    int64_t _1576 = 0; // s
    _jump1348:; // Begin body of loop
    double _1577 = 85.0;
    int64_t _1578 = 0;
    _1578 *= _1574.d0;
    _1578 += _1576;
    _1574.data[_1578] = _1577;
    _1576++;
    if (_1576 < _1292.d0)
    goto _jump1348;
    // End body of loop
    if (_1292.d2 >= 0)
    goto _jump1349;
    fail_assertion("negative array index");
    _jump1349:;
    if (_1292.d2 < _1574.d0)
    goto _jump1350;
    fail_assertion("index too large");
    _jump1350:;
    int64_t _1579 = 0;
    _1579 *= _1574.d0;
    _1579 += _1292.d2;
    double _1580 = _1574.data[_1579];
    _1573 = _1580;
    _jump1346:;
    if (_1226.d0 >= 0)
    goto _jump1351;
    fail_assertion("negative array index");
    _jump1351:;
    if (_1226.d0 < _689.d0)
    goto _jump1352;
    fail_assertion("index too large");
    _jump1352:;
    if (_1085.d0 >= 0)
    goto _jump1353;
    fail_assertion("negative array index");
    _jump1353:;
    if (_1085.d0 < _689.d1)
    goto _jump1354;
    fail_assertion("index too large");
    _jump1354:;
    int64_t _1581 = 0;
    _1581 *= _689.d0;
    _1581 += _1226.d0;
    _1581 *= _689.d1;
    _1581 += _1085.d0;
    rgba _1582 = _689.data[_1581];
    bool _1583 = _1226.d1 <= _1084.d0;
    _a2_int64_t _1584;
    if (!_1583)
    goto _jump1355;
    _a2_int64_t _1585;
    // Computing bound for s
    _1585.d0 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1356;
    fail_assertion("non-positive loop bound");
    _jump1356:;
    // Computing bound for t
    _1585.d1 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1357;
    fail_assertion("non-positive loop bound");
    _jump1357:;
    // Computing total size of heap memory to allocate
    int64_t _1586 = 1;
    _1586 *= _1226.d0;
    _1586 *= _1084.d0;
    _1586 *= sizeof(int64_t);
    _1585.data = jpl_alloc(_1586);
    int64_t _1587 = 0; // t
    int64_t _1588 = 0; // s
    _jump1358:; // Begin body of loop
    int64_t _1589 = 0;
    _1589 *= _1585.d0;
    _1589 += _1588;
    _1589 *= _1585.d1;
    _1589 += _1587;
    _1585.data[_1589] = _1226.d1;
    _1587++;
    if (_1587 < _1084.d0)
    goto _jump1358;
    _1587 = 0;
    _1588++;
    if (_1588 < _1226.d0)
    goto _jump1358;
    // End body of loop
    _1584 = _1585;
    goto _jump1359;
    _jump1355:;
    _a2_int64_t _1590;
    // Computing bound for s
    _1590.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1360;
    fail_assertion("non-positive loop bound");
    _jump1360:;
    // Computing bound for t
    _1590.d1 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing total size of heap memory to allocate
    int64_t _1591 = 1;
    _1591 *= _1085.d0;
    _1591 *= _1084.d0;
    _1591 *= sizeof(int64_t);
    _1590.data = jpl_alloc(_1591);
    int64_t _1592 = 0; // t
    int64_t _1593 = 0; // s
    _jump1362:; // Begin body of loop
    int64_t _1594 = 0;
    _1594 *= _1590.d0;
    _1594 += _1593;
    _1594 *= _1590.d1;
    _1594 += _1592;
    _1590.data[_1594] = _1084.d0;
    _1592++;
    if (_1592 < _1084.d0)
    goto _jump1362;
    _1592 = 0;
    _1593++;
    if (_1593 < _1085.d0)
    goto _jump1362;
    // End body of loop
    _1584 = _1590;
    _jump1359:;
    double _1595 = e(_1582, _1584);
    int64_t _1596 = 371;
    if (_1292.d2 >= 0)
    goto _jump1363;
    fail_assertion("negative array index");
    _jump1363:;
    if (_1292.d2 < _1292.d0)
    goto _jump1364;
    fail_assertion("index too large");
    _jump1364:;
    if (_1596 >= 0)
    goto _jump1365;
    fail_assertion("negative array index");
    _jump1365:;
    if (_1596 < _1292.d1)
    goto _jump1366;
    fail_assertion("index too large");
    _jump1366:;
    if (_1292.d0 >= 0)
    goto _jump1367;
    fail_assertion("negative array index");
    _jump1367:;
    if (_1292.d0 < _1292.d2)
    goto _jump1368;
    fail_assertion("index too large");
    _jump1368:;
    int64_t _1597 = 0;
    _1597 *= _1292.d0;
    _1597 += _1292.d2;
    _1597 *= _1292.d1;
    _1597 += _1596;
    _1597 *= _1292.d2;
    _1597 += _1292.d0;
    int64_t _1598 = _1292.data[_1597];
    bool _1599 = _1598 > _1292.d2;
    double _1600;
    if (!_1599)
    goto _jump1369;
    double _1601 = 72.0;
    _1600 = _1601;
    goto _jump1370;
    _jump1369:;
    double _1602 = 32.0;
    _1600 = _1602;
    _jump1370:;
    if (_1084.d0 >= 0)
    goto _jump1371;
    fail_assertion("negative array index");
    _jump1371:;
    if (_1084.d0 < _689.d0)
    goto _jump1372;
    fail_assertion("index too large");
    _jump1372:;
    if (_1085.d0 >= 0)
    goto _jump1373;
    fail_assertion("negative array index");
    _jump1373:;
    if (_1085.d0 < _689.d1)
    goto _jump1374;
    fail_assertion("index too large");
    _jump1374:;
    int64_t _1603 = 0;
    _1603 *= _689.d0;
    _1603 += _1084.d0;
    _1603 *= _689.d1;
    _1603 += _1085.d0;
    rgba _1604 = _689.data[_1603];
    _a2_int64_t _1605;
    // Computing bound for s
    _1605.d0 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1375;
    fail_assertion("non-positive loop bound");
    _jump1375:;
    // Computing bound for t
    bool _1606 = true;
    int64_t _1607;
    if (!_1606)
    goto _jump1376;
    _1607 = _1226.d0;
    goto _jump1377;
    _jump1376:;
    _1607 = _1084.d0;
    _jump1377:;
    _1605.d1 = _1607;
    if (_1607 > 0) 
    goto _jump1378;
    fail_assertion("non-positive loop bound");
    _jump1378:;
    // Computing total size of heap memory to allocate
    int64_t _1608 = 1;
    _1608 *= _1226.d0;
    _1608 *= _1607;
    _1608 *= sizeof(int64_t);
    _1605.data = jpl_alloc(_1608);
    int64_t _1609 = 0; // t
    int64_t _1610 = 0; // s
    _jump1379:; // Begin body of loop
    int64_t _1611 = -_1292.d1;
    int64_t _1612 = 0;
    _1612 *= _1605.d0;
    _1612 += _1610;
    _1612 *= _1605.d1;
    _1612 += _1609;
    _1605.data[_1612] = _1611;
    _1609++;
    if (_1609 < _1607)
    goto _jump1379;
    _1609 = 0;
    _1610++;
    if (_1610 < _1226.d0)
    goto _jump1379;
    // End body of loop
    double _1613 = e(_1604, _1605);
    rgba _1614 = { _1573, _1595, _1600, _1613 };
    double _1615 = _1614.r;
    _1552 = _1615;
    _jump1344:;
    bool _1616 = _1516 < _1552;
    if (0 != _1616)
    goto _jump1380;
    fail_assertion("s");
    _jump1380:;
    _a2_rgba _1617;
    // Computing bound for s
    _1617.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1381;
    fail_assertion("non-positive loop bound");
    _jump1381:;
    // Computing bound for t
    int64_t _1618 = -_1292.d1;
    int64_t _1619 = _1292.d1 - _1618;
    _1617.d1 = _1619;
    if (_1619 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    // Computing total size of heap memory to allocate
    int64_t _1620 = 1;
    _1620 *= _1085.d0;
    _1620 *= _1619;
    _1620 *= sizeof(rgba);
    _1617.data = jpl_alloc(_1620);
    int64_t _1621 = 0; // t
    int64_t _1622 = 0; // s
    _jump1383:; // Begin body of loop
    if (_1292.d1 >= 0)
    goto _jump1384;
    fail_assertion("negative array index");
    _jump1384:;
    if (_1292.d1 < _1226.d0)
    goto _jump1385;
    fail_assertion("index too large");
    _jump1385:;
    if (_1621 >= 0)
    goto _jump1386;
    fail_assertion("negative array index");
    _jump1386:;
    if (_1621 < _1226.d1)
    goto _jump1387;
    fail_assertion("index too large");
    _jump1387:;
    int64_t _1623 = 0;
    _1623 *= _1226.d0;
    _1623 += _1292.d1;
    _1623 *= _1226.d1;
    _1623 += _1621;
    rgba _1624 = _1226.data[_1623];
    int64_t _1625 = 0;
    _1625 *= _1617.d0;
    _1625 += _1622;
    _1625 *= _1617.d1;
    _1625 += _1621;
    _1617.data[_1625] = _1624;
    _1621++;
    if (_1621 < _1619)
    goto _jump1383;
    _1621 = 0;
    _1622++;
    if (_1622 < _1085.d0)
    goto _jump1383;
    // End body of loop
    write_image(_1617, "s.png");
    show("(ArrayType (TupleType (FloatType) (FloatType) (FloatType) (FloatType)) 1)", &_1084);
    double _1626 = get_time();
    print("s");
    double _1627 = get_time();
    print_time(_1627 - _1626);
    double _1628 = get_time();
    _a1__a2_int64_t _1629;
    // Computing bound for s
    _1629.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1388;
    fail_assertion("non-positive loop bound");
    _jump1388:;
    // Computing total size of heap memory to allocate
    int64_t _1630 = 1;
    _1630 *= _1085.d0;
    _1630 *= sizeof(_a2_int64_t);
    _1629.data = jpl_alloc(_1630);
    int64_t _1631 = 0; // s
    _jump1389:; // Begin body of loop
    _a2_int64_t _1632;
    // Computing bound for t
    int64_t _1633 = 63;
    _1632.d0 = _1633;
    if (_1633 > 0) 
    goto _jump1390;
    fail_assertion("non-positive loop bound");
    _jump1390:;
    // Computing bound for u
    _1632.d1 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1391;
    fail_assertion("non-positive loop bound");
    _jump1391:;
    // Computing total size of heap memory to allocate
    int64_t _1634 = 1;
    _1634 *= _1633;
    _1634 *= _1085.d0;
    _1634 *= sizeof(int64_t);
    _1632.data = jpl_alloc(_1634);
    int64_t _1635 = 0; // u
    int64_t _1636 = 0; // t
    _jump1392:; // Begin body of loop
    int64_t _1637 = 0;
    _1637 *= _1632.d0;
    _1637 += _1636;
    _1637 *= _1632.d1;
    _1637 += _1635;
    _1632.data[_1637] = _1084.d0;
    _1635++;
    if (_1635 < _1085.d0)
    goto _jump1392;
    _1635 = 0;
    _1636++;
    if (_1636 < _1633)
    goto _jump1392;
    // End body of loop
    int64_t _1638 = 0;
    _1638 *= _1629.d0;
    _1638 += _1631;
    _1629.data[_1638] = _1632;
    _1631++;
    if (_1631 < _1085.d0)
    goto _jump1389;
    // End body of loop
    int64_t _1639 = _1084.d0 + _1292.d0;
    int64_t _1640;
    // Computing bound for s
    if (_1226.d0 > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    // Computing bound for t
    int64_t _1641 = 710;
    if (_1641 > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing bound for u
    if (_1226.d1 > 0) 
    goto _jump1395;
    fail_assertion("non-positive loop bound");
    _jump1395:;
    _1640 = 0;
    int64_t _1642 = 0; // u
    int64_t _1643 = 0; // t
    int64_t _1644 = 0; // s
    _jump1396:; // Begin body of loop
    int64_t _1645 = 71;
    _1640 += _1645;
    _1642++;
    if (_1642 < _1226.d1)
    goto _jump1396;
    _1642 = 0;
    _1643++;
    if (_1643 < _1641)
    goto _jump1396;
    _1643 = 0;
    _1644++;
    if (_1644 < _1226.d0)
    goto _jump1396;
    // End body of loop
    int64_t _1646 = _1639 + _1640;
    if (_1646 >= 0)
    goto _jump1397;
    fail_assertion("negative array index");
    _jump1397:;
    if (_1646 < _1629.d0)
    goto _jump1398;
    fail_assertion("index too large");
    _jump1398:;
    int64_t _1647 = 0;
    _1647 *= _1629.d0;
    _1647 += _1646;
    _a2_int64_t _1648 = _1629.data[_1647];
    bool _1649 = false;
    int64_t _1650;
    if (!_1649)
    goto _jump1399;
    int64_t _1651;
    // Computing bound for s
    if (_1085.d0 > 0) 
    goto _jump1400;
    fail_assertion("non-positive loop bound");
    _jump1400:;
    // Computing bound for t
    if (_1292.d0 > 0) 
    goto _jump1401;
    fail_assertion("non-positive loop bound");
    _jump1401:;
    _1651 = 0;
    int64_t _1652 = 0; // t
    int64_t _1653 = 0; // s
    _jump1402:; // Begin body of loop
    int64_t _1654;
    if (!_317)
    goto _jump1403;
    _1654 = _1085.d0;
    goto _jump1404;
    _jump1403:;
    _1654 = _1085.d0;
    _jump1404:;
    _1651 += _1654;
    _1652++;
    if (_1652 < _1292.d0)
    goto _jump1402;
    _1652 = 0;
    _1653++;
    if (_1653 < _1085.d0)
    goto _jump1402;
    // End body of loop
    _1650 = _1651;
    goto _jump1405;
    _jump1399:;
    _1650 = _1226.d0;
    _jump1405:;
    if (_1650 >= 0)
    goto _jump1406;
    fail_assertion("negative array index");
    _jump1406:;
    if (_1650 < _1648.d0)
    goto _jump1407;
    fail_assertion("index too large");
    _jump1407:;
    if (_1292.d0 >= 0)
    goto _jump1408;
    fail_assertion("negative array index");
    _jump1408:;
    if (_1292.d0 < _1648.d1)
    goto _jump1409;
    fail_assertion("index too large");
    _jump1409:;
    int64_t _1655 = 0;
    _1655 *= _1648.d0;
    _1655 += _1650;
    _1655 *= _1648.d1;
    _1655 += _1292.d0;
    int64_t _1656 = _1648.data[_1655];
    bool _1657 = _1226.d1 != _1656;
    bool _1658 = !_1657;
    if (0 != _1658)
    goto _jump1410;
    fail_assertion("s");
    _jump1410:;
    double _1659 = get_time();
    print_time(_1659 - _1628);
    double _1660 = get_time();
    int64_t _1661;
    // Computing bound for s
    if (_1084.d0 > 0) 
    goto _jump1411;
    fail_assertion("non-positive loop bound");
    _jump1411:;
    // Computing bound for t
    int64_t _1662;
    // Computing bound for s
    if (_1084.d0 > 0) 
    goto _jump1412;
    fail_assertion("non-positive loop bound");
    _jump1412:;
    // Computing bound for t
    if (_1226.d0 > 0) 
    goto _jump1413;
    fail_assertion("non-positive loop bound");
    _jump1413:;
    // Computing bound for u
    int64_t _1663;
    // Computing bound for s
    int64_t _1664 = -_1226.d0;
    if (_1664 > 0) 
    goto _jump1414;
    fail_assertion("non-positive loop bound");
    _jump1414:;
    _1663 = 0;
    int64_t _1665 = 0; // s
    _jump1415:; // Begin body of loop
    _1663 += _1665;
    _1665++;
    if (_1665 < _1664)
    goto _jump1415;
    // End body of loop
    if (_1663 > 0) 
    goto _jump1416;
    fail_assertion("non-positive loop bound");
    _jump1416:;
    _1662 = 0;
    int64_t _1666 = 0; // u
    int64_t _1667 = 0; // t
    int64_t _1668 = 0; // s
    _jump1417:; // Begin body of loop
    bool _1669 = false;
    bool _1670 = _1669 == _1227;
    bool _1671 = !_1670;
    int64_t _1672;
    if (!_1671)
    goto _jump1418;
    _1672 = _1292.d0;
    goto _jump1419;
    _jump1418:;
    _1672 = _1085.d0;
    _jump1419:;
    _1662 += _1672;
    _1666++;
    if (_1666 < _1663)
    goto _jump1417;
    _1666 = 0;
    _1667++;
    if (_1667 < _1226.d0)
    goto _jump1417;
    _1667 = 0;
    _1668++;
    if (_1668 < _1084.d0)
    goto _jump1417;
    // End body of loop
    if (_1662 > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing bound for u
    int64_t _1673;
    // Computing bound for s
    _a1_bool _1675;
    // Computing bound for s
    int64_t _1676 = 703;
    _1675.d0 = _1676;
    if (_1676 > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    // Computing total size of heap memory to allocate
    int64_t _1677 = 1;
    _1677 *= _1676;
    _1677 *= sizeof(bool);
    _1675.data = jpl_alloc(_1677);
    int64_t _1678 = 0; // s
    _jump1422:; // Begin body of loop
    int64_t _1679 = 0;
    _1679 *= _1675.d0;
    _1679 += _1678;
    _1675.data[_1679] = _1227;
    _1678++;
    if (_1678 < _1676)
    goto _jump1422;
    // End body of loop
    if (_1085.d0 >= 0)
    goto _jump1423;
    fail_assertion("negative array index");
    _jump1423:;
    if (_1085.d0 < _1675.d0)
    goto _jump1424;
    fail_assertion("index too large");
    _jump1424:;
    int64_t _1680 = 0;
    _1680 *= _1675.d0;
    _1680 += _1085.d0;
    bool _1681 = _1675.data[_1680];
    bool _1674 = _1681;
    if (0 == _1681)
    goto _jump1425;
    int64_t _1682 = -_1226.d1;
    bool _1683 = _1292.d0 <= _1682;
    _1674 = _1683;
    _jump1425:;
    int64_t _1684;
    if (!_1674)
    goto _jump1426;
    _1684 = _1292.d1;
    goto _jump1427;
    _jump1426:;
    _1684 = _1085.d0;
    _jump1427:;
    if (_1684 > 0) 
    goto _jump1428;
    fail_assertion("non-positive loop bound");
    _jump1428:;
    // Computing bound for t
    int64_t _1685 = 514;
    if (_1685 > 0) 
    goto _jump1429;
    fail_assertion("non-positive loop bound");
    _jump1429:;
    // Computing bound for u
    if (_1226.d0 > 0) 
    goto _jump1430;
    fail_assertion("non-positive loop bound");
    _jump1430:;
    _1673 = 0;
    int64_t _1686 = 0; // u
    int64_t _1687 = 0; // t
    int64_t _1688 = 0; // s
    _jump1431:; // Begin body of loop
    _1673 += _1686;
    _1686++;
    if (_1686 < _1226.d0)
    goto _jump1431;
    _1686 = 0;
    _1687++;
    if (_1687 < _1685)
    goto _jump1431;
    _1687 = 0;
    _1688++;
    if (_1688 < _1684)
    goto _jump1431;
    // End body of loop
    if (_1673 > 0) 
    goto _jump1432;
    fail_assertion("non-positive loop bound");
    _jump1432:;
    _1661 = 0;
    int64_t _1689 = 0; // u
    int64_t _1690 = 0; // t
    int64_t _1691 = 0; // s
    _jump1433:; // Begin body of loop
    _1661 += _1292.d0;
    _1689++;
    if (_1689 < _1673)
    goto _jump1433;
    _1689 = 0;
    _1690++;
    if (_1690 < _1662)
    goto _jump1433;
    _1690 = 0;
    _1691++;
    if (_1691 < _1084.d0)
    goto _jump1433;
    // End body of loop
    double _1692 = get_time();
    print_time(_1692 - _1660);
    show("(BoolType)", &_317);
    int64_t _1693;
    // Computing bound for u
    if (_1226.d0 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing bound for v
    if (_1292.d1 > 0) 
    goto _jump1435;
    fail_assertion("non-positive loop bound");
    _jump1435:;
    _1693 = 0;
    int64_t _1694 = 0; // v
    int64_t _1695 = 0; // u
    _jump1436:; // Begin body of loop
    int64_t _1696 = _1661 - _1085.d0;
    _1693 += _1696;
    _1694++;
    if (_1694 < _1292.d1)
    goto _jump1436;
    _1694 = 0;
    _1695++;
    if (_1695 < _1226.d0)
    goto _jump1436;
    // End body of loop
    int64_t _1700;
    if (!_317)
    goto _jump1437;
    _1700 = _1292.d1;
    goto _jump1438;
    _jump1437:;
    _1700 = _1084.d0;
    _jump1438:;
    int64_t _1701 = 954;
    bool _1702 = _1700 >= _1701;
    bool _1699 = _1702;
    if (0 != _1702)
    goto _jump1439;
    _1699 = _1227;
    _jump1439:;
    bool _1698 = _1699;
    if (0 == _1699)
    goto _jump1440;
    _1698 = _317;
    _jump1440:;
    t _1703;
    if (!_1698)
    goto _jump1441;
    double _1704 = 45.0;
    double _1705 = 75.0;
    bool _1706 = _1704 == _1705;
    t _1707;
    if (!_1706)
    goto _jump1442;
    _a1_t _1708;
    // Computing bound for v
    _1708.d0 = _1085.d0;
    if (_1085.d0 > 0) 
    goto _jump1443;
    fail_assertion("non-positive loop bound");
    _jump1443:;
    // Computing total size of heap memory to allocate
    int64_t _1709 = 1;
    _1709 *= _1085.d0;
    _1709 *= sizeof(t);
    _1708.data = jpl_alloc(_1709);
    int64_t _1710 = 0; // v
    _jump1444:; // Begin body of loop
    t _1711 = { _317 };
    int64_t _1712 = 0;
    _1712 *= _1708.d0;
    _1712 += _1710;
    _1708.data[_1712] = _1711;
    _1710++;
    if (_1710 < _1085.d0)
    goto _jump1444;
    // End body of loop
    if (_1084.d0 >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (_1084.d0 < _1708.d0)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    int64_t _1713 = 0;
    _1713 *= _1708.d0;
    _1713 += _1084.d0;
    t _1714 = _1708.data[_1713];
    _1707 = _1714;
    goto _jump1447;
    _jump1442:;
    _a3_bool _1715;
    // Computing bound for v
    _1715.d0 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1448;
    fail_assertion("non-positive loop bound");
    _jump1448:;
    // Computing bound for w
    _1715.d1 = _1226.d1;
    if (_1226.d1 > 0) 
    goto _jump1449;
    fail_assertion("non-positive loop bound");
    _jump1449:;
    // Computing bound for x
    _1715.d2 = _1292.d1;
    if (_1292.d1 > 0) 
    goto _jump1450;
    fail_assertion("non-positive loop bound");
    _jump1450:;
    // Computing total size of heap memory to allocate
    int64_t _1716 = 1;
    _1716 *= _1226.d0;
    _1716 *= _1226.d1;
    _1716 *= _1292.d1;
    _1716 *= sizeof(bool);
    _1715.data = jpl_alloc(_1716);
    int64_t _1717 = 0; // x
    int64_t _1718 = 0; // w
    int64_t _1719 = 0; // v
    _jump1451:; // Begin body of loop
    int64_t _1720 = 0;
    _1720 *= _1715.d0;
    _1720 += _1719;
    _1720 *= _1715.d1;
    _1720 += _1718;
    _1720 *= _1715.d2;
    _1720 += _1717;
    _1715.data[_1720] = _1227;
    _1717++;
    if (_1717 < _1292.d1)
    goto _jump1451;
    _1717 = 0;
    _1718++;
    if (_1718 < _1226.d1)
    goto _jump1451;
    _1718 = 0;
    _1719++;
    if (_1719 < _1226.d0)
    goto _jump1451;
    // End body of loop
    int64_t _1721 = 761;
    if (_1292.d0 >= 0)
    goto _jump1452;
    fail_assertion("negative array index");
    _jump1452:;
    if (_1292.d0 < _1715.d0)
    goto _jump1453;
    fail_assertion("index too large");
    _jump1453:;
    if (_1084.d0 >= 0)
    goto _jump1454;
    fail_assertion("negative array index");
    _jump1454:;
    if (_1084.d0 < _1715.d1)
    goto _jump1455;
    fail_assertion("index too large");
    _jump1455:;
    if (_1721 >= 0)
    goto _jump1456;
    fail_assertion("negative array index");
    _jump1456:;
    if (_1721 < _1715.d2)
    goto _jump1457;
    fail_assertion("index too large");
    _jump1457:;
    int64_t _1722 = 0;
    _1722 *= _1715.d0;
    _1722 += _1292.d0;
    _1722 *= _1715.d1;
    _1722 += _1084.d0;
    _1722 *= _1715.d2;
    _1722 += _1721;
    bool _1723 = _1715.data[_1722];
    t _1724 = { _1723 };
    _1707 = _1724;
    _jump1447:;
    _1703 = _1707;
    goto _jump1458;
    _jump1441:;
    bool _1725 = true;
    t _1726 = { _1725 };
    _1703 = _1726;
    _jump1458:;
    bool _1727 = _1703.a;
    bool _1697 = _1727;
    if (0 == _1727)
    goto _jump1459;
    bool _1729 = _1084.d0 >= _1292.d2;
    bool _1728 = _1729;
    if (0 == _1729)
    goto _jump1460;
    _1728 = _317;
    _jump1460:;
    bool _1730 = _1728 != _317;
    bool _1731;
    if (!_1730)
    goto _jump1461;
    double _1732 = 5.0;
    bool _1733 = _1732 >= _316;
    _a2_bool _1734;
    if (!_1733)
    goto _jump1462;
    _a2_bool _1735;
    // Computing bound for v
    int64_t _1736 = 797;
    _1735.d0 = _1736;
    if (_1736 > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing bound for w
    _1735.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing total size of heap memory to allocate
    int64_t _1737 = 1;
    _1737 *= _1736;
    _1737 *= _1226.d0;
    _1737 *= sizeof(bool);
    _1735.data = jpl_alloc(_1737);
    int64_t _1738 = 0; // w
    int64_t _1739 = 0; // v
    _jump1465:; // Begin body of loop
    int64_t _1740 = 0;
    _1740 *= _1735.d0;
    _1740 += _1739;
    _1740 *= _1735.d1;
    _1740 += _1738;
    _1735.data[_1740] = _317;
    _1738++;
    if (_1738 < _1226.d0)
    goto _jump1465;
    _1738 = 0;
    _1739++;
    if (_1739 < _1736)
    goto _jump1465;
    // End body of loop
    _1734 = _1735;
    goto _jump1466;
    _jump1462:;
    _a2_bool _1741;
    // Computing bound for v
    _1741.d0 = _1292.d0;
    if (_1292.d0 > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    // Computing bound for w
    _1741.d1 = _1292.d2;
    if (_1292.d2 > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing total size of heap memory to allocate
    int64_t _1742 = 1;
    _1742 *= _1292.d0;
    _1742 *= _1292.d2;
    _1742 *= sizeof(bool);
    _1741.data = jpl_alloc(_1742);
    int64_t _1743 = 0; // w
    int64_t _1744 = 0; // v
    _jump1469:; // Begin body of loop
    bool _1745 = true;
    int64_t _1746 = 0;
    _1746 *= _1741.d0;
    _1746 += _1744;
    _1746 *= _1741.d1;
    _1746 += _1743;
    _1741.data[_1746] = _1745;
    _1743++;
    if (_1743 < _1292.d2)
    goto _jump1469;
    _1743 = 0;
    _1744++;
    if (_1744 < _1292.d0)
    goto _jump1469;
    // End body of loop
    _1734 = _1741;
    _jump1466:;
    if (_1693 >= 0)
    goto _jump1470;
    fail_assertion("negative array index");
    _jump1470:;
    if (_1693 < _1734.d0)
    goto _jump1471;
    fail_assertion("index too large");
    _jump1471:;
    if (_1084.d0 >= 0)
    goto _jump1472;
    fail_assertion("negative array index");
    _jump1472:;
    if (_1084.d0 < _1734.d1)
    goto _jump1473;
    fail_assertion("index too large");
    _jump1473:;
    int64_t _1747 = 0;
    _1747 *= _1734.d0;
    _1747 += _1693;
    _1747 *= _1734.d1;
    _1747 += _1084.d0;
    bool _1748 = _1734.data[_1747];
    _1731 = _1748;
    goto _jump1474;
    _jump1461:;
    bool _1749;
    if (!_1227)
    goto _jump1475;
    _a1_bool _1750;
    // Computing bound for v
    _1750.d0 = _1084.d0;
    if (_1084.d0 > 0) 
    goto _jump1476;
    fail_assertion("non-positive loop bound");
    _jump1476:;
    // Computing total size of heap memory to allocate
    int64_t _1751 = 1;
    _1751 *= _1084.d0;
    _1751 *= sizeof(bool);
    _1750.data = jpl_alloc(_1751);
    int64_t _1752 = 0; // v
    _jump1477:; // Begin body of loop
    int64_t _1753 = 0;
    _1753 *= _1750.d0;
    _1753 += _1752;
    _1750.data[_1753] = _1227;
    _1752++;
    if (_1752 < _1084.d0)
    goto _jump1477;
    // End body of loop
    if (_1226.d0 >= 0)
    goto _jump1478;
    fail_assertion("negative array index");
    _jump1478:;
    if (_1226.d0 < _1750.d0)
    goto _jump1479;
    fail_assertion("index too large");
    _jump1479:;
    int64_t _1754 = 0;
    _1754 *= _1750.d0;
    _1754 += _1226.d0;
    bool _1755 = _1750.data[_1754];
    _1749 = _1755;
    goto _jump1480;
    _jump1475:;
    bool _1756 = false;
    _1749 = _1756;
    _jump1480:;
    _1731 = _1749;
    _jump1474:;
    int64_t _1757;
    if (!_1731)
    goto _jump1481;
    int64_t _1758 = 416;
    int64_t _1759 = -_1758;
    _1757 = _1759;
    goto _jump1482;
    _jump1481:;
    _1757 = _1693;
    _jump1482:;
    bool _1760 = _1085.d0 == _1757;
    _1697 = _1760;
    _jump1459:;
    if (0 != _1697)
    goto _jump1483;
    fail_assertion("v");
    _jump1483:;
}

