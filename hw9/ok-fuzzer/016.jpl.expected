
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
    _a2_bool a;
} a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a2_int64_t *data;
} _a2__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_double *data;
} _a3__a3__a3_double;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  _a3__a2_int64_t *data;
} _a1__a3__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1__a2_int64_t *data;
} _a1__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1__a2_int64_t *data;
} _a3__a1__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  a *data;
} _a3_a;

typedef struct {
  int64_t d0;
  a *data;
} _a1_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

bool g(rgba h, double i) {
    bool _1 = d != e;
    bool _0 = _1;
    if (0 != _1)
    goto _jump139;
    double _2 = 5.0;
    _a3_double _3;
    // Computing bound for j
    int64_t _4 = -e;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing bound for k
    int64_t _5 = 648;
    _3.d1 = _5;
    if (_5 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    // Computing bound for l
    int64_t _6 = 217;
    int64_t _7 = 733;
    int64_t _8 = _6 + _7;
    _3.d2 = _8;
    if (_8 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    // Computing total size of heap memory to allocate
    int64_t _9 = 1;
    _9 *= _4;
    _9 *= _5;
    _9 *= _8;
    _9 *= sizeof(double);
    _3.data = jpl_alloc(_9);
    int64_t _10 = 0; // l
    int64_t _11 = 0; // k
    int64_t _12 = 0; // j
    _jump143:; // Begin body of loop
    double _13 = 12.0;
    int64_t _14 = 0;
    _14 *= _3.d0;
    _14 += _12;
    _14 *= _3.d1;
    _14 += _11;
    _14 *= _3.d2;
    _14 += _10;
    _3.data[_14] = _13;
    _10++;
    if (_10 < _8)
    goto _jump143;
    _10 = 0;
    _11++;
    if (_11 < _5)
    goto _jump143;
    _11 = 0;
    _12++;
    if (_12 < _4)
    goto _jump143;
    // End body of loop
    int64_t _15 = 537;
    int64_t _16 = _15 % d;
    int64_t _17;
    // Computing bound for j
    if (e > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    // Computing bound for k
    if (d > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    _17 = 0;
    int64_t _18 = 0; // k
    int64_t _19 = 0; // j
    _jump146:; // Begin body of loop
    _17 += _19;
    _18++;
    if (_18 < d)
    goto _jump146;
    _18 = 0;
    _19++;
    if (_19 < e)
    goto _jump146;
    // End body of loop
    int64_t _20 = e + _17;
    if (_16 >= 0)
    goto _jump147;
    fail_assertion("negative array index");
    _jump147:;
    if (_16 < _3.d0)
    goto _jump148;
    fail_assertion("index too large");
    _jump148:;
    if (d >= 0)
    goto _jump149;
    fail_assertion("negative array index");
    _jump149:;
    if (d < _3.d1)
    goto _jump150;
    fail_assertion("index too large");
    _jump150:;
    if (_20 >= 0)
    goto _jump151;
    fail_assertion("negative array index");
    _jump151:;
    if (_20 < _3.d2)
    goto _jump152;
    fail_assertion("index too large");
    _jump152:;
    int64_t _21 = 0;
    _21 *= _3.d0;
    _21 += _16;
    _21 *= _3.d1;
    _21 += d;
    _21 *= _3.d2;
    _21 += _20;
    double _22 = _3.data[_21];
    bool _23 = _2 == _22;
    _0 = _23;
    _jump139:;
    bool _24;
    if (!_0)
    goto _jump153;
    double _25;
    // Computing bound for j
    int64_t _26;
    // Computing bound for j
    int64_t _27 = 852;
    if (_27 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for k
    _a1_int64_t _28;
    // Computing bound for j
    _28.d0 = d;
    if (d > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= d;
    _29 *= sizeof(int64_t);
    _28.data = jpl_alloc(_29);
    int64_t _30 = 0; // j
    _jump156:; // Begin body of loop
    int64_t _31 = 412;
    int64_t _32 = 0;
    _32 *= _28.d0;
    _32 += _30;
    _28.data[_32] = _31;
    _30++;
    if (_30 < d)
    goto _jump156;
    // End body of loop
    int64_t _33 = 199;
    int64_t _34 = -_33;
    if (_34 >= 0)
    goto _jump157;
    fail_assertion("negative array index");
    _jump157:;
    if (_34 < _28.d0)
    goto _jump158;
    fail_assertion("index too large");
    _jump158:;
    int64_t _35 = 0;
    _35 *= _28.d0;
    _35 += _34;
    int64_t _36 = _28.data[_35];
    if (_36 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    _26 = 0;
    int64_t _37 = 0; // k
    int64_t _38 = 0; // j
    _jump160:; // Begin body of loop
    int64_t _39 = 812;
    int64_t _40 = -_39;
    int64_t _41 = d / _40;
    _26 += _41;
    _37++;
    if (_37 < _36)
    goto _jump160;
    _37 = 0;
    _38++;
    if (_38 < _27)
    goto _jump160;
    // End body of loop
    if (_26 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for k
    if (e > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    // Computing bound for l
    int64_t _42;
    // Computing bound for j
    int64_t _43 = 983;
    int64_t _44 = -_43;
    if (_44 > 0) 
    goto _jump163;
    fail_assertion("non-positive loop bound");
    _jump163:;
    // Computing bound for k
    int64_t _45 = -d;
    if (_45 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing bound for l
    int64_t _46 = -e;
    if (_46 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    _42 = 0;
    int64_t _47 = 0; // l
    int64_t _48 = 0; // k
    int64_t _49 = 0; // j
    _jump166:; // Begin body of loop
    _42 += d;
    _47++;
    if (_47 < _46)
    goto _jump166;
    _47 = 0;
    _48++;
    if (_48 < _45)
    goto _jump166;
    _48 = 0;
    _49++;
    if (_49 < _44)
    goto _jump166;
    // End body of loop
    int64_t _50 = e + _42;
    if (_50 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    _25 = 0;
    int64_t _51 = 0; // l
    int64_t _52 = 0; // k
    int64_t _53 = 0; // j
    _jump168:; // Begin body of loop
    if (d >= 0)
    goto _jump169;
    fail_assertion("negative array index");
    _jump169:;
    if (d < f.d0)
    goto _jump170;
    fail_assertion("index too large");
    _jump170:;
    if (_51 >= 0)
    goto _jump171;
    fail_assertion("negative array index");
    _jump171:;
    if (_51 < f.d1)
    goto _jump172;
    fail_assertion("index too large");
    _jump172:;
    int64_t _54 = 0;
    _54 *= f.d0;
    _54 += d;
    _54 *= f.d1;
    _54 += _51;
    rgba _55 = f.data[_54];
    double _56 = _55.r;
    double _57 = -_56;
    _25 += _57;
    _51++;
    if (_51 < _50)
    goto _jump168;
    _51 = 0;
    _52++;
    if (_52 < e)
    goto _jump168;
    _52 = 0;
    _53++;
    if (_53 < _26)
    goto _jump168;
    // End body of loop
    double _58 = 6.0;
    bool _59 = _25 >= _58;
    _24 = _59;
    goto _jump173;
    _jump153:;
    double _60 = -i;
    bool _61 = _60 < b;
    _24 = _61;
    _jump173:;
    _a1_bool _62;
    if (!_24)
    goto _jump174;
    _a3_bool _63;
    // Computing bound for j
    int64_t _64;
    // Computing bound for j
    if (d > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    _64 = 0;
    int64_t _65 = 0; // j
    _jump176:; // Begin body of loop
    int64_t _66 = 625;
    _64 += _66;
    _65++;
    if (_65 < d)
    goto _jump176;
    // End body of loop
    _63.d0 = _64;
    if (_64 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing bound for k
    int64_t _67 = 149;
    _63.d1 = _67;
    if (_67 > 0) 
    goto _jump178;
    fail_assertion("non-positive loop bound");
    _jump178:;
    // Computing bound for l
    int64_t _68 = e + d;
    _63.d2 = _68;
    if (_68 > 0) 
    goto _jump179;
    fail_assertion("non-positive loop bound");
    _jump179:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= _64;
    _69 *= _67;
    _69 *= _68;
    _69 *= sizeof(bool);
    _63.data = jpl_alloc(_69);
    int64_t _70 = 0; // l
    int64_t _71 = 0; // k
    int64_t _72 = 0; // j
    _jump180:; // Begin body of loop
    bool _73 = e != _70;
    bool _74 = !_73;
    int64_t _75 = 0;
    _75 *= _63.d0;
    _75 += _72;
    _75 *= _63.d1;
    _75 += _71;
    _75 *= _63.d2;
    _75 += _70;
    _63.data[_75] = _74;
    _70++;
    if (_70 < _68)
    goto _jump180;
    _70 = 0;
    _71++;
    if (_71 < _67)
    goto _jump180;
    _71 = 0;
    _72++;
    if (_72 < _64)
    goto _jump180;
    // End body of loop
    int64_t _76;
    // Computing bound for j
    if (e > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing bound for k
    _a2_int64_t _77;
    // Computing bound for j
    int64_t _78 = 103;
    _77.d0 = _78;
    if (_78 > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing bound for k
    _77.d1 = d;
    if (d > 0) 
    goto _jump183;
    fail_assertion("non-positive loop bound");
    _jump183:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= _78;
    _79 *= d;
    _79 *= sizeof(int64_t);
    _77.data = jpl_alloc(_79);
    int64_t _80 = 0; // k
    int64_t _81 = 0; // j
    _jump184:; // Begin body of loop
    int64_t _82 = 23;
    int64_t _83 = 0;
    _83 *= _77.d0;
    _83 += _81;
    _83 *= _77.d1;
    _83 += _80;
    _77.data[_83] = _82;
    _80++;
    if (_80 < d)
    goto _jump184;
    _80 = 0;
    _81++;
    if (_81 < _78)
    goto _jump184;
    // End body of loop
    int64_t _84 = 433;
    if (e >= 0)
    goto _jump185;
    fail_assertion("negative array index");
    _jump185:;
    if (e < _77.d0)
    goto _jump186;
    fail_assertion("index too large");
    _jump186:;
    if (_84 >= 0)
    goto _jump187;
    fail_assertion("negative array index");
    _jump187:;
    if (_84 < _77.d1)
    goto _jump188;
    fail_assertion("index too large");
    _jump188:;
    int64_t _85 = 0;
    _85 *= _77.d0;
    _85 += e;
    _85 *= _77.d1;
    _85 += _84;
    int64_t _86 = _77.data[_85];
    if (_86 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    _76 = 0;
    int64_t _87 = 0; // k
    int64_t _88 = 0; // j
    _jump190:; // Begin body of loop
    int64_t _89 = 903;
    _76 += _89;
    _87++;
    if (_87 < _86)
    goto _jump190;
    _87 = 0;
    _88++;
    if (_88 < e)
    goto _jump190;
    // End body of loop
    int64_t _90 = 895;
    int64_t _91 = 212;
    int64_t _92 = -_91;
    if (_76 >= 0)
    goto _jump191;
    fail_assertion("negative array index");
    _jump191:;
    if (_76 < _63.d0)
    goto _jump192;
    fail_assertion("index too large");
    _jump192:;
    if (_90 >= 0)
    goto _jump193;
    fail_assertion("negative array index");
    _jump193:;
    if (_90 < _63.d1)
    goto _jump194;
    fail_assertion("index too large");
    _jump194:;
    if (_92 >= 0)
    goto _jump195;
    fail_assertion("negative array index");
    _jump195:;
    if (_92 < _63.d2)
    goto _jump196;
    fail_assertion("index too large");
    _jump196:;
    int64_t _93 = 0;
    _93 *= _63.d0;
    _93 += _76;
    _93 *= _63.d1;
    _93 += _90;
    _93 *= _63.d2;
    _93 += _92;
    bool _94 = _63.data[_93];
    double _95 = 29.0;
    double _96 = 36.0;
    double _97 = _95 / _96;
    double _98 = -i;
    bool _99 = _97 <= _98;
    _a1_bool _100;
    if (!_99)
    goto _jump197;
    bool _101 = false;
    _a1_bool _102;
    if (!_101)
    goto _jump198;
    _a1_bool _103;
    // Computing bound for j
    _103.d0 = e;
    if (e > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= e;
    _104 *= sizeof(bool);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // j
    _jump200:; // Begin body of loop
    bool _106 = true;
    int64_t _107 = 0;
    _107 *= _103.d0;
    _107 += _105;
    _103.data[_107] = _106;
    _105++;
    if (_105 < e)
    goto _jump200;
    // End body of loop
    _102 = _103;
    goto _jump201;
    _jump198:;
    _a1_bool _108;
    // Computing bound for j
    _108.d0 = e;
    if (e > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= e;
    _109 *= sizeof(bool);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // j
    _jump203:; // Begin body of loop
    bool _111 = false;
    int64_t _112 = 0;
    _112 *= _108.d0;
    _112 += _110;
    _108.data[_112] = _111;
    _110++;
    if (_110 < e)
    goto _jump203;
    // End body of loop
    _102 = _108;
    _jump201:;
    _100 = _102;
    goto _jump204;
    _jump197:;
    _a1_bool _113;
    // Computing bound for j
    _113.d0 = e;
    if (e > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= e;
    _114 *= sizeof(bool);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // j
    _jump206:; // Begin body of loop
    bool _116 = b > b;
    int64_t _117 = 0;
    _117 *= _113.d0;
    _117 += _115;
    _113.data[_117] = _116;
    _115++;
    if (_115 < e)
    goto _jump206;
    // End body of loop
    _100 = _113;
    _jump204:;
    bool _118 = false;
    int64_t _119;
    if (!_118)
    goto _jump207;
    int64_t _120;
    // Computing bound for j
    if (e > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing bound for k
    if (d > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    _120 = 0;
    int64_t _121 = 0; // k
    int64_t _122 = 0; // j
    _jump210:; // Begin body of loop
    _120 += _121;
    _121++;
    if (_121 < d)
    goto _jump210;
    _121 = 0;
    _122++;
    if (_122 < e)
    goto _jump210;
    // End body of loop
    _119 = _120;
    goto _jump211;
    _jump207:;
    _119 = d;
    _jump211:;
    if (_119 >= 0)
    goto _jump212;
    fail_assertion("negative array index");
    _jump212:;
    if (_119 < _100.d0)
    goto _jump213;
    fail_assertion("index too large");
    _jump213:;
    int64_t _123 = 0;
    _123 *= _100.d0;
    _123 += _119;
    bool _124 = _100.data[_123];
    bool _125 = _94 == _124;
    _a1_bool _126;
    if (!_125)
    goto _jump214;
    _a1_bool _127;
    // Computing bound for j
    bool _128 = e < e;
    bool _129;
    if (!_128)
    goto _jump215;
    bool _130 = false;
    bool _131 = !_130;
    _129 = _131;
    goto _jump216;
    _jump215:;
    double _132 = 41.0;
    double _133 = fmod(b, _132);
    bool _134 = g(h, _133);
    _129 = _134;
    _jump216:;
    int64_t _135;
    if (!_129)
    goto _jump217;
    int64_t _136;
    // Computing bound for j
    if (d > 0) 
    goto _jump218;
    fail_assertion("non-positive loop bound");
    _jump218:;
    _136 = 0;
    int64_t _137 = 0; // j
    _jump219:; // Begin body of loop
    _136 += _137;
    _137++;
    if (_137 < d)
    goto _jump219;
    // End body of loop
    int64_t _138 = e * _136;
    int64_t _139 = -_138;
    _135 = _139;
    goto _jump220;
    _jump217:;
    _135 = d;
    _jump220:;
    _127.d0 = _135;
    if (_135 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= _135;
    _140 *= sizeof(bool);
    _127.data = jpl_alloc(_140);
    int64_t _141 = 0; // j
    _jump222:; // Begin body of loop
    bool _142 = true;
    int64_t _143 = 0;
    _143 *= _127.d0;
    _143 += _141;
    _127.data[_143] = _142;
    _141++;
    if (_141 < _135)
    goto _jump222;
    // End body of loop
    _126 = _127;
    goto _jump223;
    _jump214:;
    int64_t _144;
    // Computing bound for j
    if (e > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    _144 = 0;
    int64_t _145 = 0; // j
    _jump225:; // Begin body of loop
    int64_t _146 = 25;
    _144 += _146;
    _145++;
    if (_145 < e)
    goto _jump225;
    // End body of loop
    int64_t _147 = -_144;
    int64_t _148 = -e;
    bool _149 = _147 == _148;
    bool _150 = !_149;
    bool _153 = g(h, i);
    bool _154 = !_153;
    bool _152 = _154;
    if (0 == _154)
    goto _jump226;
    bool _155 = true;
    _152 = _155;
    _jump226:;
    bool _151 = _152;
    if (0 != _152)
    goto _jump227;
    bool _156 = true;
    _151 = _156;
    _jump227:;
    double _157 = -i;
    double _158 = h.a;
    double _159 = _157 * _158;
    double _160 = 93.0;
    rgba _161 = { b, _159, i, _160 };
    double _162 = i / i;
    double _163 = 71.0;
    double _164 = _163 - b;
    double _165 = -i;
    rgba _166 = { _162, b, _164, _165 };
    double _167 = _166.r;
    bool _168 = g(_161, _167);
    _a1_bool _169;
    _169.d0 = 3;
    _169.data = jpl_alloc(sizeof(bool) * 3);
    _169.data[0] = _150;
    _169.data[1] = _151;
    _169.data[2] = _168;
    _126 = _169;
    _jump223:;
    _62 = _126;
    goto _jump228;
    _jump174:;
    bool _170 = true;
    _a1_bool _171;
    _171.d0 = 1;
    _171.data = jpl_alloc(sizeof(bool) * 1);
    _171.data[0] = _170;
    _62 = _171;
    _jump228:;
    double _172 = 84.0;
    double _173 = -_172;
    _a2_double _174;
    // Computing bound for m
    _174.d0 = _62.d0;
    if (_62.d0 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for n
    _174.d1 = _62.d0;
    if (_62.d0 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing total size of heap memory to allocate
    int64_t _175 = 1;
    _175 *= _62.d0;
    _175 *= _62.d0;
    _175 *= sizeof(double);
    _174.data = jpl_alloc(_175);
    int64_t _176 = 0; // n
    int64_t _177 = 0; // m
    _jump231:; // Begin body of loop
    double _178 = h.g;
    int64_t _179 = 0;
    _179 *= _174.d0;
    _179 += _177;
    _179 *= _174.d1;
    _179 += _176;
    _174.data[_179] = _178;
    _176++;
    if (_176 < _62.d0)
    goto _jump231;
    _176 = 0;
    _177++;
    if (_177 < _62.d0)
    goto _jump231;
    // End body of loop
    int64_t _180 = 75;
    if (_180 >= 0)
    goto _jump232;
    fail_assertion("negative array index");
    _jump232:;
    if (_180 < _174.d0)
    goto _jump233;
    fail_assertion("index too large");
    _jump233:;
    if (_62.d0 >= 0)
    goto _jump234;
    fail_assertion("negative array index");
    _jump234:;
    if (_62.d0 < _174.d1)
    goto _jump235;
    fail_assertion("index too large");
    _jump235:;
    int64_t _181 = 0;
    _181 *= _174.d0;
    _181 += _180;
    _181 *= _174.d1;
    _181 += _62.d0;
    double _182 = _174.data[_181];
    double _183 = -_182;
    double _184 = 90.0;
    double _185 = 64.0;
    rgba _186 = { _184, i, b, _185 };
    double _187 = _186.b;
    double _188 = -_187;
    double _189 = h.r;
    double _190 = -_189;
    double _191 = _188 / _190;
    double _192 = _183 / _191;
    bool _193 = _173 <= _192;
    _a3_double _194;
    if (!_193)
    goto _jump236;
    _a3_double _195;
    // Computing bound for m
    _195.d0 = e;
    if (e > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing bound for n
    int64_t _197 = 703;
    int64_t _198 = 583;
    bool _199 = _197 != _198;
    bool _196 = _199;
    if (0 != _199)
    goto _jump238;
    bool _201 = true;
    bool _202 = !_201;
    bool _200 = _202;
    if (0 == _202)
    goto _jump239;
    bool _203 = i != i;
    _200 = _203;
    _jump239:;
    _196 = _200;
    _jump238:;
    int64_t _204;
    if (!_196)
    goto _jump240;
    int64_t _205 = -d;
    _204 = _205;
    goto _jump241;
    _jump240:;
    _204 = e;
    _jump241:;
    int64_t _206 = e % _204;
    _195.d1 = _206;
    if (_206 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for o
    int64_t _207 = -d;
    int64_t _208 = -e;
    _a1_int64_t _209;
    _209.d0 = 3;
    _209.data = jpl_alloc(sizeof(int64_t) * 3);
    _209.data[0] = e;
    _209.data[1] = d;
    _209.data[2] = _208;
    if (e >= 0)
    goto _jump243;
    fail_assertion("negative array index");
    _jump243:;
    if (e < _209.d0)
    goto _jump244;
    fail_assertion("index too large");
    _jump244:;
    int64_t _210 = 0;
    _210 *= _209.d0;
    _210 += e;
    int64_t _211 = _209.data[_210];
    int64_t _212 = _207 + _211;
    int64_t _213 = -_212;
    _195.d2 = _213;
    if (_213 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _214 = 1;
    _214 *= e;
    _214 *= _206;
    _214 *= _213;
    _214 *= sizeof(double);
    _195.data = jpl_alloc(_214);
    int64_t _215 = 0; // o
    int64_t _216 = 0; // n
    int64_t _217 = 0; // m
    _jump246:; // Begin body of loop
    int64_t _218 = 0;
    _218 *= _195.d0;
    _218 += _217;
    _218 *= _195.d1;
    _218 += _216;
    _218 *= _195.d2;
    _218 += _215;
    _195.data[_218] = i;
    _215++;
    if (_215 < _213)
    goto _jump246;
    _215 = 0;
    _216++;
    if (_216 < _206)
    goto _jump246;
    _216 = 0;
    _217++;
    if (_217 < e)
    goto _jump246;
    // End body of loop
    _194 = _195;
    goto _jump247;
    _jump236:;
    _a3_double _219;
    // Computing bound for m
    _219.d0 = e;
    if (e > 0) 
    goto _jump248;
    fail_assertion("non-positive loop bound");
    _jump248:;
    // Computing bound for n
    int64_t _220;
    // Computing bound for m
    int64_t _221 = 828;
    int64_t _222 = 80;
    if (_221 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (_221 < c.d0)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    if (_222 >= 0)
    goto _jump251;
    fail_assertion("negative array index");
    _jump251:;
    if (_222 < c.d1)
    goto _jump252;
    fail_assertion("index too large");
    _jump252:;
    int64_t _223 = 0;
    _223 *= c.d0;
    _223 += _221;
    _223 *= c.d1;
    _223 += _222;
    int64_t _224 = c.data[_223];
    if (_224 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    _220 = 0;
    int64_t _225 = 0; // m
    _jump254:; // Begin body of loop
    int64_t _226 = d + _225;
    _220 += _226;
    _225++;
    if (_225 < _224)
    goto _jump254;
    // End body of loop
    _a1_int64_t _227;
    _227.d0 = 1;
    _227.data = jpl_alloc(sizeof(int64_t) * 1);
    _227.data[0] = _220;
    bool _228 = _62.d0 != e;
    bool _229;
    if (!_228)
    goto _jump255;
    bool _230 = false;
    _229 = _230;
    goto _jump256;
    _jump255:;
    bool _231 = true;
    _229 = _231;
    _jump256:;
    int64_t _232;
    if (!_229)
    goto _jump257;
    int64_t _233 = _62.d0 - e;
    _232 = _233;
    goto _jump258;
    _jump257:;
    _232 = d;
    _jump258:;
    if (_232 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_232 < _227.d0)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    int64_t _234 = 0;
    _234 *= _227.d0;
    _234 += _232;
    int64_t _235 = _227.data[_234];
    int64_t _236 = -_235;
    _219.d1 = _236;
    if (_236 > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    // Computing bound for o
    double _237 = 61.0;
    double _238 = _172 + _237;
    double _239;
    // Computing bound for m
    int64_t _240 = 542;
    if (_240 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    _239 = 0;
    int64_t _241 = 0; // m
    _jump263:; // Begin body of loop
    double _242 = 49.0;
    _239 += _242;
    _241++;
    if (_241 < _240)
    goto _jump263;
    // End body of loop
    bool _243 = _238 < _239;
    _a3__a2_int64_t _244;
    if (!_243)
    goto _jump264;
    _a3__a2_int64_t _245;
    // Computing bound for m
    bool _246 = true;
    int64_t _247;
    if (!_246)
    goto _jump265;
    _247 = d;
    goto _jump266;
    _jump265:;
    int64_t _248 = 860;
    _247 = _248;
    _jump266:;
    _245.d0 = _247;
    if (_247 > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    // Computing bound for n
    int64_t _249 = -e;
    _245.d1 = _249;
    if (_249 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for o
    int64_t _250 = 503;
    _245.d2 = _250;
    if (_250 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    // Computing total size of heap memory to allocate
    int64_t _251 = 1;
    _251 *= _247;
    _251 *= _249;
    _251 *= _250;
    _251 *= sizeof(_a2_int64_t);
    _245.data = jpl_alloc(_251);
    int64_t _252 = 0; // o
    int64_t _253 = 0; // n
    int64_t _254 = 0; // m
    _jump270:; // Begin body of loop
    int64_t _255 = 0;
    _255 *= _245.d0;
    _255 += _254;
    _255 *= _245.d1;
    _255 += _253;
    _255 *= _245.d2;
    _255 += _252;
    _245.data[_255] = c;
    _252++;
    if (_252 < _250)
    goto _jump270;
    _252 = 0;
    _253++;
    if (_253 < _249)
    goto _jump270;
    _253 = 0;
    _254++;
    if (_254 < _247)
    goto _jump270;
    // End body of loop
    _244 = _245;
    goto _jump271;
    _jump264:;
    _a3__a2_int64_t _256;
    // Computing bound for m
    bool _257 = true;
    int64_t _258;
    if (!_257)
    goto _jump272;
    int64_t _259 = 567;
    _258 = _259;
    goto _jump273;
    _jump272:;
    int64_t _260 = 288;
    _258 = _260;
    _jump273:;
    _256.d0 = _258;
    if (_258 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing bound for n
    int64_t _261;
    // Computing bound for m
    if (e > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    // Computing bound for n
    if (e > 0) 
    goto _jump276;
    fail_assertion("non-positive loop bound");
    _jump276:;
    _261 = 0;
    int64_t _262 = 0; // n
    int64_t _263 = 0; // m
    _jump277:; // Begin body of loop
    _261 += _263;
    _262++;
    if (_262 < e)
    goto _jump277;
    _262 = 0;
    _263++;
    if (_263 < e)
    goto _jump277;
    // End body of loop
    _256.d1 = _261;
    if (_261 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing bound for o
    _256.d2 = _62.d0;
    if (_62.d0 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= _258;
    _264 *= _261;
    _264 *= _62.d0;
    _264 *= sizeof(_a2_int64_t);
    _256.data = jpl_alloc(_264);
    int64_t _265 = 0; // o
    int64_t _266 = 0; // n
    int64_t _267 = 0; // m
    _jump280:; // Begin body of loop
    int64_t _268 = 0;
    _268 *= _256.d0;
    _268 += _267;
    _268 *= _256.d1;
    _268 += _266;
    _268 *= _256.d2;
    _268 += _265;
    _256.data[_268] = c;
    _265++;
    if (_265 < _62.d0)
    goto _jump280;
    _265 = 0;
    _266++;
    if (_266 < _261)
    goto _jump280;
    _266 = 0;
    _267++;
    if (_267 < _258)
    goto _jump280;
    // End body of loop
    _244 = _256;
    _jump271:;
    int64_t _269;
    // Computing bound for m
    _a1_int64_t _270;
    _270.d0 = 2;
    _270.data = jpl_alloc(sizeof(int64_t) * 2);
    _270.data[0] = _62.d0;
    _270.data[1] = e;
    int64_t _271 = 569;
    int64_t _272 = -_271;
    if (_272 >= 0)
    goto _jump281;
    fail_assertion("negative array index");
    _jump281:;
    if (_272 < _270.d0)
    goto _jump282;
    fail_assertion("index too large");
    _jump282:;
    int64_t _273 = 0;
    _273 *= _270.d0;
    _273 += _272;
    int64_t _274 = _270.data[_273];
    if (_274 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    // Computing bound for n
    int64_t _275 = 159;
    if (_275 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    _269 = 0;
    int64_t _276 = 0; // n
    int64_t _277 = 0; // m
    _jump285:; // Begin body of loop
    int64_t _278 = 622;
    _269 += _278;
    _276++;
    if (_276 < _275)
    goto _jump285;
    _276 = 0;
    _277++;
    if (_277 < _274)
    goto _jump285;
    // End body of loop
    if (d >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (d < _244.d0)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    if (_269 >= 0)
    goto _jump288;
    fail_assertion("negative array index");
    _jump288:;
    if (_269 < _244.d1)
    goto _jump289;
    fail_assertion("index too large");
    _jump289:;
    if (_62.d0 >= 0)
    goto _jump290;
    fail_assertion("negative array index");
    _jump290:;
    if (_62.d0 < _244.d2)
    goto _jump291;
    fail_assertion("index too large");
    _jump291:;
    int64_t _279 = 0;
    _279 *= _244.d0;
    _279 += d;
    _279 *= _244.d1;
    _279 += _269;
    _279 *= _244.d2;
    _279 += _62.d0;
    _a2_int64_t _280 = _244.data[_279];
    int64_t _281 = 990;
    int64_t _282 = -d;
    int64_t _283 = _281 * _282;
    if (_283 >= 0)
    goto _jump292;
    fail_assertion("negative array index");
    _jump292:;
    if (_283 < _280.d0)
    goto _jump293;
    fail_assertion("index too large");
    _jump293:;
    if (e >= 0)
    goto _jump294;
    fail_assertion("negative array index");
    _jump294:;
    if (e < _280.d1)
    goto _jump295;
    fail_assertion("index too large");
    _jump295:;
    int64_t _284 = 0;
    _284 *= _280.d0;
    _284 += _283;
    _284 *= _280.d1;
    _284 += e;
    int64_t _285 = _280.data[_284];
    _219.d2 = _285;
    if (_285 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= e;
    _286 *= _236;
    _286 *= _285;
    _286 *= sizeof(double);
    _219.data = jpl_alloc(_286);
    int64_t _287 = 0; // o
    int64_t _288 = 0; // n
    int64_t _289 = 0; // m
    _jump297:; // Begin body of loop
    int64_t _290 = 0;
    _290 *= _219.d0;
    _290 += _289;
    _290 *= _219.d1;
    _290 += _288;
    _290 *= _219.d2;
    _290 += _287;
    _219.data[_290] = i;
    _287++;
    if (_287 < _285)
    goto _jump297;
    _287 = 0;
    _288++;
    if (_288 < _236)
    goto _jump297;
    _288 = 0;
    _289++;
    if (_289 < e)
    goto _jump297;
    // End body of loop
    _194 = _219;
    _jump247:;
    _a3__a3_double _291;
    // Computing bound for q
    _291.d0 = _194.d1;
    if (_194.d1 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing bound for r
    _291.d1 = e;
    if (e > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for s
    _a2_int64_t _292;
    // Computing bound for q
    int64_t _293 = _62.d0 - _194.d1;
    _292.d0 = _293;
    if (_293 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing bound for r
    _a3__a3_int64_t _294;
    // Computing bound for q
    int64_t _295 = -e;
    _294.d0 = _295;
    if (_295 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing bound for r
    _294.d1 = _194.d1;
    if (_194.d1 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    // Computing bound for s
    _294.d2 = _194.d0;
    if (_194.d0 > 0) 
    goto _jump303;
    fail_assertion("non-positive loop bound");
    _jump303:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _295;
    _296 *= _194.d1;
    _296 *= _194.d0;
    _296 *= sizeof(_a3_int64_t);
    _294.data = jpl_alloc(_296);
    int64_t _297 = 0; // s
    int64_t _298 = 0; // r
    int64_t _299 = 0; // q
    _jump304:; // Begin body of loop
    _a3_int64_t _300;
    // Computing bound for t
    int64_t _301 = 131;
    _300.d0 = _301;
    if (_301 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing bound for u
    _300.d1 = _194.d1;
    if (_194.d1 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for v
    _300.d2 = _297;
    if (_297 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _301;
    _302 *= _194.d1;
    _302 *= _297;
    _302 *= sizeof(int64_t);
    _300.data = jpl_alloc(_302);
    int64_t _303 = 0; // v
    int64_t _304 = 0; // u
    int64_t _305 = 0; // t
    _jump308:; // Begin body of loop
    int64_t _306 = 0;
    _306 *= _300.d0;
    _306 += _305;
    _306 *= _300.d1;
    _306 += _304;
    _306 *= _300.d2;
    _306 += _303;
    _300.data[_306] = _298;
    _303++;
    if (_303 < _297)
    goto _jump308;
    _303 = 0;
    _304++;
    if (_304 < _194.d1)
    goto _jump308;
    _304 = 0;
    _305++;
    if (_305 < _301)
    goto _jump308;
    // End body of loop
    int64_t _307 = 0;
    _307 *= _294.d0;
    _307 += _299;
    _307 *= _294.d1;
    _307 += _298;
    _307 *= _294.d2;
    _307 += _297;
    _294.data[_307] = _300;
    _297++;
    if (_297 < _194.d0)
    goto _jump304;
    _297 = 0;
    _298++;
    if (_298 < _194.d1)
    goto _jump304;
    _298 = 0;
    _299++;
    if (_299 < _295)
    goto _jump304;
    // End body of loop
    int64_t _308 = _194.d0 / _194.d1;
    int64_t _309 = 922;
    if (d >= 0)
    goto _jump309;
    fail_assertion("negative array index");
    _jump309:;
    if (d < _294.d0)
    goto _jump310;
    fail_assertion("index too large");
    _jump310:;
    if (_308 >= 0)
    goto _jump311;
    fail_assertion("negative array index");
    _jump311:;
    if (_308 < _294.d1)
    goto _jump312;
    fail_assertion("index too large");
    _jump312:;
    if (_309 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (_309 < _294.d2)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    int64_t _310 = 0;
    _310 *= _294.d0;
    _310 += d;
    _310 *= _294.d1;
    _310 += _308;
    _310 *= _294.d2;
    _310 += _309;
    _a3_int64_t _311 = _294.data[_310];
    if (e >= 0)
    goto _jump315;
    fail_assertion("negative array index");
    _jump315:;
    if (e < _311.d0)
    goto _jump316;
    fail_assertion("index too large");
    _jump316:;
    if (d >= 0)
    goto _jump317;
    fail_assertion("negative array index");
    _jump317:;
    if (d < _311.d1)
    goto _jump318;
    fail_assertion("index too large");
    _jump318:;
    if (e >= 0)
    goto _jump319;
    fail_assertion("negative array index");
    _jump319:;
    if (e < _311.d2)
    goto _jump320;
    fail_assertion("index too large");
    _jump320:;
    int64_t _312 = 0;
    _312 *= _311.d0;
    _312 += e;
    _312 *= _311.d1;
    _312 += d;
    _312 *= _311.d2;
    _312 += e;
    int64_t _313 = _311.data[_312];
    _292.d1 = _313;
    if (_313 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing total size of heap memory to allocate
    int64_t _314 = 1;
    _314 *= _293;
    _314 *= _313;
    _314 *= sizeof(int64_t);
    _292.data = jpl_alloc(_314);
    int64_t _315 = 0; // r
    int64_t _316 = 0; // q
    _jump322:; // Begin body of loop
    int64_t _317 = 0;
    _317 *= _292.d0;
    _317 += _316;
    _317 *= _292.d1;
    _317 += _315;
    _292.data[_317] = d;
    _315++;
    if (_315 < _313)
    goto _jump322;
    _315 = 0;
    _316++;
    if (_316 < _293)
    goto _jump322;
    // End body of loop
    int64_t _318;
    // Computing bound for q
    int64_t _319 = 247;
    if (_319 > 0) 
    goto _jump323;
    fail_assertion("non-positive loop bound");
    _jump323:;
    // Computing bound for r
    _a2__a2_int64_t _320;
    // Computing bound for q
    _320.d0 = e;
    if (e > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing bound for r
    _320.d1 = _194.d2;
    if (_194.d2 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= e;
    _321 *= _194.d2;
    _321 *= sizeof(_a2_int64_t);
    _320.data = jpl_alloc(_321);
    int64_t _322 = 0; // r
    int64_t _323 = 0; // q
    _jump326:; // Begin body of loop
    int64_t _324 = 0;
    _324 *= _320.d0;
    _324 += _323;
    _324 *= _320.d1;
    _324 += _322;
    _320.data[_324] = c;
    _322++;
    if (_322 < _194.d2)
    goto _jump326;
    _322 = 0;
    _323++;
    if (_323 < e)
    goto _jump326;
    // End body of loop
    int64_t _325 = -_62.d0;
    int64_t _326 = 634;
    if (_325 >= 0)
    goto _jump327;
    fail_assertion("negative array index");
    _jump327:;
    if (_325 < _320.d0)
    goto _jump328;
    fail_assertion("index too large");
    _jump328:;
    if (_326 >= 0)
    goto _jump329;
    fail_assertion("negative array index");
    _jump329:;
    if (_326 < _320.d1)
    goto _jump330;
    fail_assertion("index too large");
    _jump330:;
    int64_t _327 = 0;
    _327 *= _320.d0;
    _327 += _325;
    _327 *= _320.d1;
    _327 += _326;
    _a2_int64_t _328 = _320.data[_327];
    if (d >= 0)
    goto _jump331;
    fail_assertion("negative array index");
    _jump331:;
    if (d < _328.d0)
    goto _jump332;
    fail_assertion("index too large");
    _jump332:;
    if (e >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (e < _328.d1)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    int64_t _329 = 0;
    _329 *= _328.d0;
    _329 += d;
    _329 *= _328.d1;
    _329 += e;
    int64_t _330 = _328.data[_329];
    if (_330 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    // Computing bound for s
    if (e > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    _318 = 0;
    int64_t _331 = 0; // s
    int64_t _332 = 0; // r
    int64_t _333 = 0; // q
    _jump337:; // Begin body of loop
    _318 += _194.d1;
    _331++;
    if (_331 < e)
    goto _jump337;
    _331 = 0;
    _332++;
    if (_332 < _330)
    goto _jump337;
    _332 = 0;
    _333++;
    if (_333 < _319)
    goto _jump337;
    // End body of loop
    bool _334 = e > d;
    int64_t _335;
    if (!_334)
    goto _jump338;
    _335 = e;
    goto _jump339;
    _jump338:;
    _335 = d;
    _jump339:;
    int64_t _336 = _318 / _335;
    bool _337 = g(h, b);
    bool _338 = g(h, i);
    double _339;
    if (!_338)
    goto _jump340;
    _339 = _172;
    goto _jump341;
    _jump340:;
    _339 = b;
    _jump341:;
    bool _340 = g(h, _339);
    bool _341 = _337 != _340;
    int64_t _342;
    if (!_341)
    goto _jump342;
    _342 = _62.d0;
    goto _jump343;
    _jump342:;
    _342 = _62.d0;
    _jump343:;
    if (_336 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (_336 < _292.d0)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    if (_342 >= 0)
    goto _jump346;
    fail_assertion("negative array index");
    _jump346:;
    if (_342 < _292.d1)
    goto _jump347;
    fail_assertion("index too large");
    _jump347:;
    int64_t _343 = 0;
    _343 *= _292.d0;
    _343 += _336;
    _343 *= _292.d1;
    _343 += _342;
    int64_t _344 = _292.data[_343];
    _291.d2 = _344;
    if (_344 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing total size of heap memory to allocate
    int64_t _345 = 1;
    _345 *= _194.d1;
    _345 *= e;
    _345 *= _344;
    _345 *= sizeof(_a3_double);
    _291.data = jpl_alloc(_345);
    int64_t _346 = 0; // s
    int64_t _347 = 0; // r
    int64_t _348 = 0; // q
    _jump349:; // Begin body of loop
    int64_t _349 = 0;
    _349 *= _291.d0;
    _349 += _348;
    _349 *= _291.d1;
    _349 += _347;
    _349 *= _291.d2;
    _349 += _346;
    _291.data[_349] = _194;
    _346++;
    if (_346 < _344)
    goto _jump349;
    _346 = 0;
    _347++;
    if (_347 < e)
    goto _jump349;
    _347 = 0;
    _348++;
    if (_348 < _194.d1)
    goto _jump349;
    // End body of loop
    double _350;
    // Computing bound for u
    int64_t _351;
    // Computing bound for u
    int64_t _352 = 51;
    if (_352 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for v
    bool _353 = false;
    bool _354 = !_353;
    int64_t _355;
    if (!_354)
    goto _jump351;
    int64_t _356 = e / _291.d0;
    _355 = _356;
    goto _jump352;
    _jump351:;
    _355 = _194.d0;
    _jump352:;
    if (_355 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    // Computing bound for w
    if (_194.d0 > 0) 
    goto _jump354;
    fail_assertion("non-positive loop bound");
    _jump354:;
    _351 = 0;
    int64_t _357 = 0; // w
    int64_t _358 = 0; // v
    int64_t _359 = 0; // u
    _jump355:; // Begin body of loop
    int64_t _360;
    // Computing bound for x
    if (_291.d0 > 0) 
    goto _jump356;
    fail_assertion("non-positive loop bound");
    _jump356:;
    _360 = 0;
    int64_t _361 = 0; // x
    _jump357:; // Begin body of loop
    _360 += d;
    _361++;
    if (_361 < _291.d0)
    goto _jump357;
    // End body of loop
    int64_t _362 = _357 / _360;
    _351 += _362;
    _357++;
    if (_357 < _194.d0)
    goto _jump355;
    _357 = 0;
    _358++;
    if (_358 < _355)
    goto _jump355;
    _358 = 0;
    _359++;
    if (_359 < _352)
    goto _jump355;
    // End body of loop
    if (_351 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    // Computing bound for v
    if (_291.d1 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing bound for w
    if (_291.d0 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    _350 = 0;
    int64_t _363 = 0; // w
    int64_t _364 = 0; // v
    int64_t _365 = 0; // u
    _jump361:; // Begin body of loop
    _350 += b;
    _363++;
    if (_363 < _291.d0)
    goto _jump361;
    _363 = 0;
    _364++;
    if (_364 < _291.d1)
    goto _jump361;
    _364 = 0;
    _365++;
    if (_365 < _351)
    goto _jump361;
    // End body of loop
    double _366 = i * _350;
    double _367 = h.g;
    double _368 = 37.0;
    _a1_double _369;
    _369.d0 = 3;
    _369.data = jpl_alloc(sizeof(double) * 3);
    _369.data[0] = i;
    _369.data[1] = _368;
    _369.data[2] = i;
    double _370 = 73.0;
    double _371 = h.g;
    bool _372 = _370 == _371;
    _a2_int64_t _373;
    if (!_372)
    goto _jump362;
    _373 = c;
    goto _jump363;
    _jump362:;
    bool _374 = false;
    _a2_int64_t _375;
    if (!_374)
    goto _jump364;
    _375 = c;
    goto _jump365;
    _jump364:;
    _a2_int64_t _376;
    // Computing bound for u
    _376.d0 = _291.d0;
    if (_291.d0 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing bound for v
    _376.d1 = _194.d0;
    if (_194.d0 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing total size of heap memory to allocate
    int64_t _377 = 1;
    _377 *= _291.d0;
    _377 *= _194.d0;
    _377 *= sizeof(int64_t);
    _376.data = jpl_alloc(_377);
    int64_t _378 = 0; // v
    int64_t _379 = 0; // u
    _jump368:; // Begin body of loop
    int64_t _380 = 0;
    _380 *= _376.d0;
    _380 += _379;
    _380 *= _376.d1;
    _380 += _378;
    _376.data[_380] = e;
    _378++;
    if (_378 < _194.d0)
    goto _jump368;
    _378 = 0;
    _379++;
    if (_379 < _291.d0)
    goto _jump368;
    // End body of loop
    _375 = _376;
    _jump365:;
    _373 = _375;
    _jump363:;
    if (e >= 0)
    goto _jump369;
    fail_assertion("negative array index");
    _jump369:;
    if (e < _373.d0)
    goto _jump370;
    fail_assertion("index too large");
    _jump370:;
    if (_194.d1 >= 0)
    goto _jump371;
    fail_assertion("negative array index");
    _jump371:;
    if (_194.d1 < _373.d1)
    goto _jump372;
    fail_assertion("index too large");
    _jump372:;
    int64_t _381 = 0;
    _381 *= _373.d0;
    _381 += e;
    _381 *= _373.d1;
    _381 += _194.d1;
    int64_t _382 = _373.data[_381];
    if (_382 >= 0)
    goto _jump373;
    fail_assertion("negative array index");
    _jump373:;
    if (_382 < _369.d0)
    goto _jump374;
    fail_assertion("index too large");
    _jump374:;
    int64_t _383 = 0;
    _383 *= _369.d0;
    _383 += _382;
    double _384 = _369.data[_383];
    double _385 = 26.0;
    rgba _386 = { _366, _367, _384, _385 };
    bool _387 = g(_386, _172);
    _a1_int64_t _388;
    // Computing bound for v
    _388.d0 = _291.d2;
    if (_291.d2 > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _291.d2;
    _389 *= sizeof(int64_t);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // v
    _jump376:; // Begin body of loop
    int64_t _391;
    // Computing bound for w
    int64_t _392 = 62;
    if (_392 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    _391 = 0;
    int64_t _393 = 0; // w
    _jump378:; // Begin body of loop
    int64_t _394 = 734;
    _391 += _394;
    _393++;
    if (_393 < _392)
    goto _jump378;
    // End body of loop
    int64_t _395 = 0;
    _395 *= _388.d0;
    _395 += _390;
    _388.data[_395] = _391;
    _390++;
    if (_390 < _291.d2)
    goto _jump376;
    // End body of loop
    bool _396 = false;
    rgba _397;
    if (!_396)
    goto _jump379;
    bool _398 = g(h, _172);
    rgba _399;
    if (!_398)
    goto _jump380;
    bool _400 = false;
    rgba _401;
    if (!_400)
    goto _jump381;
    _401 = h;
    goto _jump382;
    _jump381:;
    _401 = h;
    _jump382:;
    _399 = _401;
    goto _jump383;
    _jump380:;
    if (_194.d1 >= 0)
    goto _jump384;
    fail_assertion("negative array index");
    _jump384:;
    if (_194.d1 < f.d0)
    goto _jump385;
    fail_assertion("index too large");
    _jump385:;
    if (_388.d0 >= 0)
    goto _jump386;
    fail_assertion("negative array index");
    _jump386:;
    if (_388.d0 < f.d1)
    goto _jump387;
    fail_assertion("index too large");
    _jump387:;
    int64_t _402 = 0;
    _402 *= f.d0;
    _402 += _194.d1;
    _402 *= f.d1;
    _402 += _388.d0;
    rgba _403 = f.data[_402];
    _399 = _403;
    _jump383:;
    _397 = _399;
    goto _jump388;
    _jump379:;
    _397 = h;
    _jump388:;
    bool _404 = g(_397, i);
    _a3_double _405;
    if (!_404)
    goto _jump389;
    bool _406 = _194.d0 < d;
    _a3__a3_double _407;
    if (!_406)
    goto _jump390;
    _a3__a3__a3_double _408;
    // Computing bound for x
    _408.d0 = _291.d2;
    if (_291.d2 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for y
    _408.d1 = _388.d0;
    if (_388.d0 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing bound for z
    int64_t _409 = 306;
    _408.d2 = _409;
    if (_409 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing total size of heap memory to allocate
    int64_t _410 = 1;
    _410 *= _291.d2;
    _410 *= _388.d0;
    _410 *= _409;
    _410 *= sizeof(_a3__a3_double);
    _408.data = jpl_alloc(_410);
    int64_t _411 = 0; // z
    int64_t _412 = 0; // y
    int64_t _413 = 0; // x
    _jump394:; // Begin body of loop
    int64_t _414 = 0;
    _414 *= _408.d0;
    _414 += _413;
    _414 *= _408.d1;
    _414 += _412;
    _414 *= _408.d2;
    _414 += _411;
    _408.data[_414] = _291;
    _411++;
    if (_411 < _409)
    goto _jump394;
    _411 = 0;
    _412++;
    if (_412 < _388.d0)
    goto _jump394;
    _412 = 0;
    _413++;
    if (_413 < _291.d2)
    goto _jump394;
    // End body of loop
    if (_291.d1 >= 0)
    goto _jump395;
    fail_assertion("negative array index");
    _jump395:;
    if (_291.d1 < _408.d0)
    goto _jump396;
    fail_assertion("index too large");
    _jump396:;
    if (_291.d2 >= 0)
    goto _jump397;
    fail_assertion("negative array index");
    _jump397:;
    if (_291.d2 < _408.d1)
    goto _jump398;
    fail_assertion("index too large");
    _jump398:;
    if (e >= 0)
    goto _jump399;
    fail_assertion("negative array index");
    _jump399:;
    if (e < _408.d2)
    goto _jump400;
    fail_assertion("index too large");
    _jump400:;
    int64_t _415 = 0;
    _415 *= _408.d0;
    _415 += _291.d1;
    _415 *= _408.d1;
    _415 += _291.d2;
    _415 *= _408.d2;
    _415 += e;
    _a3__a3_double _416 = _408.data[_415];
    _407 = _416;
    goto _jump401;
    _jump390:;
    double _417 = 76.0;
    bool _418 = _417 > _172;
    _a3__a3_double _419;
    if (!_418)
    goto _jump402;
    _419 = _291;
    goto _jump403;
    _jump402:;
    _419 = _291;
    _jump403:;
    _407 = _419;
    _jump401:;
    bool _420 = _387;
    if (0 != _387)
    goto _jump404;
    bool _421 = true;
    _420 = _421;
    _jump404:;
    bool _422 = !_420;
    int64_t _423;
    if (!_422)
    goto _jump405;
    _423 = _62.d0;
    goto _jump406;
    _jump405:;
    _423 = _291.d2;
    _jump406:;
    if (_291.d2 >= 0)
    goto _jump407;
    fail_assertion("negative array index");
    _jump407:;
    if (_291.d2 < _407.d0)
    goto _jump408;
    fail_assertion("index too large");
    _jump408:;
    if (_194.d2 >= 0)
    goto _jump409;
    fail_assertion("negative array index");
    _jump409:;
    if (_194.d2 < _407.d1)
    goto _jump410;
    fail_assertion("index too large");
    _jump410:;
    if (_423 >= 0)
    goto _jump411;
    fail_assertion("negative array index");
    _jump411:;
    if (_423 < _407.d2)
    goto _jump412;
    fail_assertion("index too large");
    _jump412:;
    int64_t _424 = 0;
    _424 *= _407.d0;
    _424 += _291.d2;
    _424 *= _407.d1;
    _424 += _194.d2;
    _424 *= _407.d2;
    _424 += _423;
    _a3_double _425 = _407.data[_424];
    _405 = _425;
    goto _jump413;
    _jump389:;
    _405 = _194;
    _jump413:;
    int64_t _426 = -_62.d0;
    int64_t _427 = _291.d0 % d;
    if (_426 >= 0)
    goto _jump414;
    fail_assertion("negative array index");
    _jump414:;
    if (_426 < _405.d0)
    goto _jump415;
    fail_assertion("index too large");
    _jump415:;
    if (_427 >= 0)
    goto _jump416;
    fail_assertion("negative array index");
    _jump416:;
    if (_427 < _405.d1)
    goto _jump417;
    fail_assertion("index too large");
    _jump417:;
    if (_291.d1 >= 0)
    goto _jump418;
    fail_assertion("negative array index");
    _jump418:;
    if (_291.d1 < _405.d2)
    goto _jump419;
    fail_assertion("index too large");
    _jump419:;
    int64_t _428 = 0;
    _428 *= _405.d0;
    _428 += _426;
    _428 *= _405.d1;
    _428 += _427;
    _428 *= _405.d2;
    _428 += _291.d1;
    double _429 = _405.data[_428];
    bool _430 = g(h, _429);
    return _430;
}

rgba w() {
    double _0 = 1.0;
    double _1 = 91.0;
    double _2 = -_1;
    bool _3 = _0 == _2;
    _a2__a3_bool _4;
    // Computing bound for x
    int64_t _5 = s * e;
    _4.d0 = _5;
    if (_5 > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing bound for y
    _4.d1 = d;
    if (d > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _5;
    _6 *= d;
    _6 *= sizeof(_a3_bool);
    _4.data = jpl_alloc(_6);
    int64_t _7 = 0; // y
    int64_t _8 = 0; // x
    _jump809:; // Begin body of loop
    _a3_bool _9;
    // Computing bound for z
    _9.d0 = t;
    if (t > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    // Computing bound for A
    int64_t _10 = -u;
    _9.d1 = _10;
    if (_10 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    // Computing bound for B
    _9.d2 = p;
    if (p > 0) 
    goto _jump812;
    fail_assertion("non-positive loop bound");
    _jump812:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= t;
    _11 *= _10;
    _11 *= p;
    _11 *= sizeof(bool);
    _9.data = jpl_alloc(_11);
    int64_t _12 = 0; // B
    int64_t _13 = 0; // A
    int64_t _14 = 0; // z
    _jump813:; // Begin body of loop
    bool _15 = _7 >= o;
    int64_t _16 = 0;
    _16 *= _9.d0;
    _16 += _14;
    _16 *= _9.d1;
    _16 += _13;
    _16 *= _9.d2;
    _16 += _12;
    _9.data[_16] = _15;
    _12++;
    if (_12 < p)
    goto _jump813;
    _12 = 0;
    _13++;
    if (_13 < _10)
    goto _jump813;
    _13 = 0;
    _14++;
    if (_14 < t)
    goto _jump813;
    // End body of loop
    int64_t _17 = 0;
    _17 *= _4.d0;
    _17 += _8;
    _17 *= _4.d1;
    _17 += _7;
    _4.data[_17] = _9;
    _7++;
    if (_7 < d)
    goto _jump809;
    _7 = 0;
    _8++;
    if (_8 < _5)
    goto _jump809;
    // End body of loop
    int64_t _18;
    // Computing bound for x
    if (p > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    _18 = 0;
    int64_t _19 = 0; // x
    _jump815:; // Begin body of loop
    int64_t _20 = d / e;
    _18 += _20;
    _19++;
    if (_19 < p)
    goto _jump815;
    // End body of loop
    int64_t _22 = 224;
    bool _23 = _22 == j;
    bool _21 = _23;
    if (0 != _23)
    goto _jump816;
    double _24 = 40.0;
    bool _25 = _24 == b;
    _21 = _25;
    _jump816:;
    int64_t _26;
    if (!_21)
    goto _jump817;
    _26 = p;
    goto _jump818;
    _jump817:;
    _26 = l;
    _jump818:;
    if (_18 >= 0)
    goto _jump819;
    fail_assertion("negative array index");
    _jump819:;
    if (_18 < _4.d0)
    goto _jump820;
    fail_assertion("index too large");
    _jump820:;
    if (_26 >= 0)
    goto _jump821;
    fail_assertion("negative array index");
    _jump821:;
    if (_26 < _4.d1)
    goto _jump822;
    fail_assertion("index too large");
    _jump822:;
    int64_t _27 = 0;
    _27 *= _4.d0;
    _27 += _18;
    _27 *= _4.d1;
    _27 += _26;
    _a3_bool _28 = _4.data[_27];
    if (l >= 0)
    goto _jump823;
    fail_assertion("negative array index");
    _jump823:;
    if (l < _28.d0)
    goto _jump824;
    fail_assertion("index too large");
    _jump824:;
    if (t >= 0)
    goto _jump825;
    fail_assertion("negative array index");
    _jump825:;
    if (t < _28.d1)
    goto _jump826;
    fail_assertion("index too large");
    _jump826:;
    if (u >= 0)
    goto _jump827;
    fail_assertion("negative array index");
    _jump827:;
    if (u < _28.d2)
    goto _jump828;
    fail_assertion("index too large");
    _jump828:;
    int64_t _29 = 0;
    _29 *= _28.d0;
    _29 += l;
    _29 *= _28.d1;
    _29 += t;
    _29 *= _28.d2;
    _29 += u;
    bool _30 = _28.data[_29];
    bool _31 = _3 == _30;
    _a3_a _32;
    if (!_31)
    goto _jump829;
    _a3_a _33;
    // Computing bound for x
    _33.d0 = l;
    if (l > 0) 
    goto _jump830;
    fail_assertion("non-positive loop bound");
    _jump830:;
    // Computing bound for y
    _a1_bool _35;
    // Computing bound for x
    _35.d0 = o;
    if (o > 0) 
    goto _jump831;
    fail_assertion("non-positive loop bound");
    _jump831:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= o;
    _36 *= sizeof(bool);
    _35.data = jpl_alloc(_36);
    int64_t _37 = 0; // x
    _jump832:; // Begin body of loop
    bool _38 = s != _37;
    int64_t _39 = 0;
    _39 *= _35.d0;
    _39 += _37;
    _35.data[_39] = _38;
    _37++;
    if (_37 < o)
    goto _jump832;
    // End body of loop
    int64_t _40 = -u;
    if (_40 >= 0)
    goto _jump833;
    fail_assertion("negative array index");
    _jump833:;
    if (_40 < _35.d0)
    goto _jump834;
    fail_assertion("index too large");
    _jump834:;
    int64_t _41 = 0;
    _41 *= _35.d0;
    _41 += _40;
    bool _42 = _35.data[_41];
    bool _34 = _42;
    if (0 != _42)
    goto _jump835;
    bool _43 = true;
    _34 = _43;
    _jump835:;
    int64_t _44;
    if (!_34)
    goto _jump836;
    int64_t _45;
    // Computing bound for x
    if (s > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    _45 = 0;
    int64_t _46 = 0; // x
    _jump838:; // Begin body of loop
    _45 += v;
    _46++;
    if (_46 < s)
    goto _jump838;
    // End body of loop
    _44 = _45;
    goto _jump839;
    _jump836:;
    _44 = t;
    _jump839:;
    _33.d1 = _44;
    if (_44 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for z
    _33.d2 = s;
    if (s > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= l;
    _47 *= _44;
    _47 *= s;
    _47 *= sizeof(a);
    _33.data = jpl_alloc(_47);
    int64_t _48 = 0; // z
    int64_t _49 = 0; // y
    int64_t _50 = 0; // x
    _jump842:; // Begin body of loop
    _a2_bool _51;
    // Computing bound for A
    _51.d0 = j;
    if (j > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    // Computing bound for B
    _51.d1 = o;
    if (o > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= j;
    _52 *= o;
    _52 *= sizeof(bool);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // B
    int64_t _54 = 0; // A
    _jump845:; // Begin body of loop
    bool _56 = _48 == s;
    bool _55 = _56;
    if (0 == _56)
    goto _jump846;
    bool _57 = false;
    bool _58 = !_57;
    _55 = _58;
    _jump846:;
    int64_t _59 = 0;
    _59 *= _51.d0;
    _59 += _54;
    _59 *= _51.d1;
    _59 += _53;
    _51.data[_59] = _55;
    _53++;
    if (_53 < o)
    goto _jump845;
    _53 = 0;
    _54++;
    if (_54 < j)
    goto _jump845;
    // End body of loop
    a _60 = { _51 };
    int64_t _61 = 0;
    _61 *= _33.d0;
    _61 += _50;
    _61 *= _33.d1;
    _61 += _49;
    _61 *= _33.d2;
    _61 += _48;
    _33.data[_61] = _60;
    _48++;
    if (_48 < s)
    goto _jump842;
    _48 = 0;
    _49++;
    if (_49 < _44)
    goto _jump842;
    _49 = 0;
    _50++;
    if (_50 < l)
    goto _jump842;
    // End body of loop
    _32 = _33;
    goto _jump847;
    _jump829:;
    bool _64 = false;
    bool _63 = _64;
    if (0 == _64)
    goto _jump848;
    bool _65 = j > l;
    _63 = _65;
    _jump848:;
    bool _62 = _63;
    if (0 != _63)
    goto _jump849;
    double _67 = 9.0;
    bool _68 = _67 <= b;
    bool _66 = _68;
    if (0 != _68)
    goto _jump850;
    double _70 = 33.0;
    double _71 = 59.0;
    rgba _72 = { _70, _71, m, m };
    double _73 = fmod(m, m);
    bool _74 = g(_72, _73);
    bool _69 = _74;
    if (0 == _74)
    goto _jump851;
    bool _76 = true;
    bool _75 = _76;
    if (0 != _76)
    goto _jump852;
    bool _77 = true;
    _75 = _77;
    _jump852:;
    bool _78 = !_75;
    _69 = _78;
    _jump851:;
    _66 = _69;
    _jump850:;
    _62 = _66;
    _jump849:;
    _a3_a _79;
    if (!_62)
    goto _jump853;
    _a3_a _80;
    // Computing bound for x
    bool _81 = true;
    int64_t _82;
    if (!_81)
    goto _jump854;
    int64_t _83 = 101;
    _82 = _83;
    goto _jump855;
    _jump854:;
    int64_t _84;
    // Computing bound for x
    if (j > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing bound for y
    if (d > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    _84 = 0;
    int64_t _85 = 0; // y
    int64_t _86 = 0; // x
    _jump858:; // Begin body of loop
    _84 += _85;
    _85++;
    if (_85 < d)
    goto _jump858;
    _85 = 0;
    _86++;
    if (_86 < j)
    goto _jump858;
    // End body of loop
    _82 = _84;
    _jump855:;
    int64_t _87 = _82 + j;
    _80.d0 = _87;
    if (_87 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    // Computing bound for y
    _80.d1 = u;
    if (u > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    // Computing bound for z
    int64_t _88 = l % s;
    _80.d2 = _88;
    if (_88 > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _87;
    _89 *= u;
    _89 *= _88;
    _89 *= sizeof(a);
    _80.data = jpl_alloc(_89);
    int64_t _90 = 0; // z
    int64_t _91 = 0; // y
    int64_t _92 = 0; // x
    _jump862:; // Begin body of loop
    _a1_a _93;
    // Computing bound for A
    _93.d0 = _91;
    if (_91 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing total size of heap memory to allocate
    int64_t _94 = 1;
    _94 *= _91;
    _94 *= sizeof(a);
    _93.data = jpl_alloc(_94);
    int64_t _95 = 0; // A
    _jump864:; // Begin body of loop
    _a2_bool _96;
    // Computing bound for B
    _96.d0 = p;
    if (p > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    // Computing bound for C
    _96.d1 = _90;
    if (_90 > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= p;
    _97 *= _90;
    _97 *= sizeof(bool);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // C
    int64_t _99 = 0; // B
    _jump867:; // Begin body of loop
    bool _100 = false;
    int64_t _101 = 0;
    _101 *= _96.d0;
    _101 += _99;
    _101 *= _96.d1;
    _101 += _98;
    _96.data[_101] = _100;
    _98++;
    if (_98 < _90)
    goto _jump867;
    _98 = 0;
    _99++;
    if (_99 < p)
    goto _jump867;
    // End body of loop
    a _102 = { _96 };
    int64_t _103 = 0;
    _103 *= _93.d0;
    _103 += _95;
    _93.data[_103] = _102;
    _95++;
    if (_95 < _91)
    goto _jump864;
    // End body of loop
    bool _104 = false;
    int64_t _105;
    if (!_104)
    goto _jump868;
    _105 = e;
    goto _jump869;
    _jump868:;
    _105 = e;
    _jump869:;
    int64_t _106;
    // Computing bound for A
    int64_t _107 = 874;
    if (_107 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    _106 = 0;
    int64_t _108 = 0; // A
    _jump871:; // Begin body of loop
    _106 += p;
    _108++;
    if (_108 < _107)
    goto _jump871;
    // End body of loop
    if (_105 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_105 < n.d0)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    if (_106 >= 0)
    goto _jump874;
    fail_assertion("negative array index");
    _jump874:;
    if (_106 < n.d1)
    goto _jump875;
    fail_assertion("index too large");
    _jump875:;
    int64_t _109 = 0;
    _109 *= n.d0;
    _109 += _105;
    _109 *= n.d1;
    _109 += _106;
    int64_t _110 = n.data[_109];
    if (_110 >= 0)
    goto _jump876;
    fail_assertion("negative array index");
    _jump876:;
    if (_110 < _93.d0)
    goto _jump877;
    fail_assertion("index too large");
    _jump877:;
    int64_t _111 = 0;
    _111 *= _93.d0;
    _111 += _110;
    a _112 = _93.data[_111];
    int64_t _113 = 0;
    _113 *= _80.d0;
    _113 += _92;
    _113 *= _80.d1;
    _113 += _91;
    _113 *= _80.d2;
    _113 += _90;
    _80.data[_113] = _112;
    _90++;
    if (_90 < _88)
    goto _jump862;
    _90 = 0;
    _91++;
    if (_91 < u)
    goto _jump862;
    _91 = 0;
    _92++;
    if (_92 < _87)
    goto _jump862;
    // End body of loop
    _79 = _80;
    goto _jump878;
    _jump853:;
    _a3_a _114;
    // Computing bound for x
    int64_t _115 = 920;
    _114.d0 = _115;
    if (_115 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing bound for y
    _114.d1 = u;
    if (u > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    // Computing bound for z
    int64_t _116 = 905;
    int64_t _117 = -j;
    _a1_int64_t _118;
    _118.d0 = 3;
    _118.data = jpl_alloc(sizeof(int64_t) * 3);
    _118.data[0] = _116;
    _118.data[1] = o;
    _118.data[2] = _117;
    if (s >= 0)
    goto _jump881;
    fail_assertion("negative array index");
    _jump881:;
    if (s < _118.d0)
    goto _jump882;
    fail_assertion("index too large");
    _jump882:;
    int64_t _119 = 0;
    _119 *= _118.d0;
    _119 += s;
    int64_t _120 = _118.data[_119];
    _114.d2 = _120;
    if (_120 > 0) 
    goto _jump883;
    fail_assertion("non-positive loop bound");
    _jump883:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= _115;
    _121 *= u;
    _121 *= _120;
    _121 *= sizeof(a);
    _114.data = jpl_alloc(_121);
    int64_t _122 = 0; // z
    int64_t _123 = 0; // y
    int64_t _124 = 0; // x
    _jump884:; // Begin body of loop
    bool _125 = true;
    _a2_bool _126;
    if (!_125)
    goto _jump885;
    _a2_bool _127;
    // Computing bound for A
    int64_t _128;
    // Computing bound for A
    if (t > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing bound for B
    if (p > 0) 
    goto _jump887;
    fail_assertion("non-positive loop bound");
    _jump887:;
    // Computing bound for C
    if (t > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    _128 = 0;
    int64_t _129 = 0; // C
    int64_t _130 = 0; // B
    int64_t _131 = 0; // A
    _jump889:; // Begin body of loop
    _128 += _124;
    _129++;
    if (_129 < t)
    goto _jump889;
    _129 = 0;
    _130++;
    if (_130 < p)
    goto _jump889;
    _130 = 0;
    _131++;
    if (_131 < t)
    goto _jump889;
    // End body of loop
    _127.d0 = _128;
    if (_128 > 0) 
    goto _jump890;
    fail_assertion("non-positive loop bound");
    _jump890:;
    // Computing bound for B
    int64_t _132;
    // Computing bound for A
    if (_122 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    _132 = 0;
    int64_t _133 = 0; // A
    _jump892:; // Begin body of loop
    _132 += t;
    _133++;
    if (_133 < _122)
    goto _jump892;
    // End body of loop
    _127.d1 = _132;
    if (_132 > 0) 
    goto _jump893;
    fail_assertion("non-positive loop bound");
    _jump893:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= _128;
    _134 *= _132;
    _134 *= sizeof(bool);
    _127.data = jpl_alloc(_134);
    int64_t _135 = 0; // B
    int64_t _136 = 0; // A
    _jump894:; // Begin body of loop
    bool _137 = true;
    int64_t _138 = 0;
    _138 *= _127.d0;
    _138 += _136;
    _138 *= _127.d1;
    _138 += _135;
    _127.data[_138] = _137;
    _135++;
    if (_135 < _132)
    goto _jump894;
    _135 = 0;
    _136++;
    if (_136 < _128)
    goto _jump894;
    // End body of loop
    _126 = _127;
    goto _jump895;
    _jump885:;
    _a2_bool _139;
    // Computing bound for A
    _139.d0 = _124;
    if (_124 > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    // Computing bound for B
    _139.d1 = o;
    if (o > 0) 
    goto _jump897;
    fail_assertion("non-positive loop bound");
    _jump897:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= _124;
    _140 *= o;
    _140 *= sizeof(bool);
    _139.data = jpl_alloc(_140);
    int64_t _141 = 0; // B
    int64_t _142 = 0; // A
    _jump898:; // Begin body of loop
    bool _143 = true;
    bool _144 = !_143;
    int64_t _145 = 0;
    _145 *= _139.d0;
    _145 += _142;
    _145 *= _139.d1;
    _145 += _141;
    _139.data[_145] = _144;
    _141++;
    if (_141 < o)
    goto _jump898;
    _141 = 0;
    _142++;
    if (_142 < _124)
    goto _jump898;
    // End body of loop
    _126 = _139;
    _jump895:;
    a _146 = { _126 };
    int64_t _147 = 0;
    _147 *= _114.d0;
    _147 += _124;
    _147 *= _114.d1;
    _147 += _123;
    _147 *= _114.d2;
    _147 += _122;
    _114.data[_147] = _146;
    _122++;
    if (_122 < _120)
    goto _jump884;
    _122 = 0;
    _123++;
    if (_123 < u)
    goto _jump884;
    _123 = 0;
    _124++;
    if (_124 < _115)
    goto _jump884;
    // End body of loop
    _79 = _114;
    _jump878:;
    _32 = _79;
    _jump847:;
    double _148 = 48.0;
    rgba _149 = w();
    return _149;
    rgba _150 = w();
    return _150;
    rgba _151 = w();
    return _151;
}

bool x(_a3_double y, void_t C) {
    int64_t _0 = 642;
    _a3_double _1;
    // Computing bound for H
    _1.d0 = j;
    if (j > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    // Computing bound for I
    _1.d1 = p;
    if (p > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for J
    _1.d2 = t;
    if (t > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= j;
    _2 *= p;
    _2 *= t;
    _2 *= sizeof(double);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // J
    int64_t _4 = 0; // I
    int64_t _5 = 0; // H
    _jump902:; // Begin body of loop
    rgba _6 = w();
    rgba _7 = w();
    double _8 = _7.g;
    bool _9 = g(_6, _8);
    double _10;
    if (!_9)
    goto _jump903;
    _a3_double _11;
    // Computing bound for K
    _11.d0 = _5;
    if (_5 > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for L
    _11.d1 = d;
    if (d > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for M
    int64_t _12 = 143;
    _11.d2 = _12;
    if (_12 > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _5;
    _13 *= d;
    _13 *= _12;
    _13 *= sizeof(double);
    _11.data = jpl_alloc(_13);
    int64_t _14 = 0; // M
    int64_t _15 = 0; // L
    int64_t _16 = 0; // K
    _jump907:; // Begin body of loop
    int64_t _17 = 0;
    _17 *= _11.d0;
    _17 += _16;
    _17 *= _11.d1;
    _17 += _15;
    _17 *= _11.d2;
    _17 += _14;
    _11.data[_17] = b;
    _14++;
    if (_14 < _12)
    goto _jump907;
    _14 = 0;
    _15++;
    if (_15 < d)
    goto _jump907;
    _15 = 0;
    _16++;
    if (_16 < _5)
    goto _jump907;
    // End body of loop
    bool _18 = true;
    void_t _19;
    if (!_18)
    goto _jump908;
    _19 = C;
    goto _jump909;
    _jump908:;
    _19 = C;
    _jump909:;
    bool _20 = x(_11, _19);
    rgba _21;
    if (!_20)
    goto _jump910;
    rgba _22 = w();
    _21 = _22;
    goto _jump911;
    _jump910:;
    bool _23 = false;
    double _24;
    if (!_23)
    goto _jump912;
    _24 = b;
    goto _jump913;
    _jump912:;
    double _25 = 2.0;
    _24 = _25;
    _jump913:;
    double _26 = 49.0;
    double _27;
    // Computing bound for K
    if (y.d0 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    _27 = 0;
    int64_t _28 = 0; // K
    _jump915:; // Begin body of loop
    _27 += b;
    _28++;
    if (_28 < y.d0)
    goto _jump915;
    // End body of loop
    rgba _29 = { b, _24, _26, _27 };
    _21 = _29;
    _jump911:;
    double _30 = _21.b;
    _10 = _30;
    goto _jump916;
    _jump903:;
    double _31 = 64.0;
    _10 = _31;
    _jump916:;
    int64_t _32 = 0;
    _32 *= _1.d0;
    _32 += _5;
    _32 *= _1.d1;
    _32 += _4;
    _32 *= _1.d2;
    _32 += _3;
    _1.data[_32] = _10;
    _3++;
    if (_3 < t)
    goto _jump902;
    _3 = 0;
    _4++;
    if (_4 < p)
    goto _jump902;
    _4 = 0;
    _5++;
    if (_5 < j)
    goto _jump902;
    // End body of loop
    _a3_double _33;
    // Computing bound for H
    int64_t _34;
    // Computing bound for H
    int64_t _35 = 192;
    if (_35 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for I
    if (d > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing bound for J
    int64_t _36 = 330;
    int64_t _37 = d + _36;
    if (_37 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    _34 = 0;
    int64_t _38 = 0; // J
    int64_t _39 = 0; // I
    int64_t _40 = 0; // H
    _jump920:; // Begin body of loop
    _34 += u;
    _38++;
    if (_38 < _37)
    goto _jump920;
    _38 = 0;
    _39++;
    if (_39 < d)
    goto _jump920;
    _39 = 0;
    _40++;
    if (_40 < _35)
    goto _jump920;
    // End body of loop
    _33.d0 = _34;
    if (_34 > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing bound for I
    _33.d1 = v;
    if (v > 0) 
    goto _jump922;
    fail_assertion("non-positive loop bound");
    _jump922:;
    // Computing bound for J
    bool _41 = o > l;
    int64_t _42;
    if (!_41)
    goto _jump923;
    int64_t _43 = d - o;
    _42 = _43;
    goto _jump924;
    _jump923:;
    int64_t _44;
    // Computing bound for H
    if (p > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for I
    if (d > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    _44 = 0;
    int64_t _45 = 0; // I
    int64_t _46 = 0; // H
    _jump927:; // Begin body of loop
    _44 += t;
    _45++;
    if (_45 < d)
    goto _jump927;
    _45 = 0;
    _46++;
    if (_46 < p)
    goto _jump927;
    // End body of loop
    _42 = _44;
    _jump924:;
    _33.d2 = _42;
    if (_42 > 0) 
    goto _jump928;
    fail_assertion("non-positive loop bound");
    _jump928:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= _34;
    _47 *= v;
    _47 *= _42;
    _47 *= sizeof(double);
    _33.data = jpl_alloc(_47);
    int64_t _48 = 0; // J
    int64_t _49 = 0; // I
    int64_t _50 = 0; // H
    _jump929:; // Begin body of loop
    int64_t _51 = 0;
    _51 *= _33.d0;
    _51 += _50;
    _51 *= _33.d1;
    _51 += _49;
    _51 *= _33.d2;
    _51 += _48;
    _33.data[_51] = b;
    _48++;
    if (_48 < _42)
    goto _jump929;
    _48 = 0;
    _49++;
    if (_49 < v)
    goto _jump929;
    _49 = 0;
    _50++;
    if (_50 < _34)
    goto _jump929;
    // End body of loop
    bool _52 = false;
    void_t _53;
    if (!_52)
    goto _jump930;
    bool _54 = b != b;
    void_t _55;
    if (!_54)
    goto _jump931;
    _55 = C;
    goto _jump932;
    _jump931:;
    _55 = C;
    _jump932:;
    _53 = _55;
    goto _jump933;
    _jump930:;
    _53 = C;
    _jump933:;
    bool _56 = x(_33, _53);
    bool _57;
    if (!_56)
    goto _jump934;
    double _58 = 67.0;
    double _59;
    // Computing bound for H
    _a3_int64_t _60;
    // Computing bound for H
    _60.d0 = y.d1;
    if (y.d1 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing bound for I
    _60.d1 = y.d1;
    if (y.d1 > 0) 
    goto _jump936;
    fail_assertion("non-positive loop bound");
    _jump936:;
    // Computing bound for J
    _60.d2 = s;
    if (s > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= y.d1;
    _61 *= y.d1;
    _61 *= s;
    _61 *= sizeof(int64_t);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // J
    int64_t _63 = 0; // I
    int64_t _64 = 0; // H
    _jump938:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _60.d0;
    _65 += _64;
    _65 *= _60.d1;
    _65 += _63;
    _65 *= _60.d2;
    _65 += _62;
    _60.data[_65] = s;
    _62++;
    if (_62 < s)
    goto _jump938;
    _62 = 0;
    _63++;
    if (_63 < y.d1)
    goto _jump938;
    _63 = 0;
    _64++;
    if (_64 < y.d1)
    goto _jump938;
    // End body of loop
    if (d >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (d < _60.d0)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    if (o >= 0)
    goto _jump941;
    fail_assertion("negative array index");
    _jump941:;
    if (o < _60.d1)
    goto _jump942;
    fail_assertion("index too large");
    _jump942:;
    if (s >= 0)
    goto _jump943;
    fail_assertion("negative array index");
    _jump943:;
    if (s < _60.d2)
    goto _jump944;
    fail_assertion("index too large");
    _jump944:;
    int64_t _66 = 0;
    _66 *= _60.d0;
    _66 += d;
    _66 *= _60.d1;
    _66 += o;
    _66 *= _60.d2;
    _66 += s;
    int64_t _67 = _60.data[_66];
    if (_67 > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    _59 = 0;
    int64_t _68 = 0; // H
    _jump946:; // Begin body of loop
    double _69;
    // Computing bound for I
    if (l > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for J
    if (y.d2 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    _69 = 0;
    int64_t _70 = 0; // J
    int64_t _71 = 0; // I
    _jump949:; // Begin body of loop
    _69 += b;
    _70++;
    if (_70 < y.d2)
    goto _jump949;
    _70 = 0;
    _71++;
    if (_71 < l)
    goto _jump949;
    // End body of loop
    double _72 = -_69;
    _59 += _72;
    _68++;
    if (_68 < _67)
    goto _jump946;
    // End body of loop
    bool _73 = _58 >= _59;
    _57 = _73;
    goto _jump950;
    _jump934:;
    int64_t _74 = 312;
    if (u >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (u < y.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    if (o >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (o < y.d1)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    if (_74 >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (_74 < y.d2)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    int64_t _75 = 0;
    _75 *= y.d0;
    _75 += u;
    _75 *= y.d1;
    _75 += o;
    _75 *= y.d2;
    _75 += _74;
    double _76 = y.data[_75];
    double _77 = -_76;
    rgba _78 = w();
    double _79 = _78.g;
    double _80 = fmod(_77, _79);
    rgba _81 = w();
    double _82 = _81.a;
    bool _83 = _80 == _82;
    _57 = _83;
    _jump950:;
    void_t _84;
    if (!_57)
    goto _jump957;
    bool _86 = y.d2 >= j;
    bool _85 = _86;
    if (0 == _86)
    goto _jump958;
    bool _87 = t >= d;
    _85 = _87;
    _jump958:;
    _a3__a2_void_t _88;
    if (!_85)
    goto _jump959;
    _a3__a2_void_t _89;
    // Computing bound for H
    _89.d0 = s;
    if (s > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for I
    _89.d1 = u;
    if (u > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for J
    int64_t _90 = 380;
    _89.d2 = _90;
    if (_90 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= s;
    _91 *= u;
    _91 *= _90;
    _91 *= sizeof(_a2_void_t);
    _89.data = jpl_alloc(_91);
    int64_t _92 = 0; // J
    int64_t _93 = 0; // I
    int64_t _94 = 0; // H
    _jump963:; // Begin body of loop
    _a2_void_t _95;
    // Computing bound for K
    _95.d0 = _94;
    if (_94 > 0) 
    goto _jump964;
    fail_assertion("non-positive loop bound");
    _jump964:;
    // Computing bound for L
    _95.d1 = s;
    if (s > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= _94;
    _96 *= s;
    _96 *= sizeof(void_t);
    _95.data = jpl_alloc(_96);
    int64_t _97 = 0; // L
    int64_t _98 = 0; // K
    _jump966:; // Begin body of loop
    int64_t _99 = 0;
    _99 *= _95.d0;
    _99 += _98;
    _99 *= _95.d1;
    _99 += _97;
    _95.data[_99] = C;
    _97++;
    if (_97 < s)
    goto _jump966;
    _97 = 0;
    _98++;
    if (_98 < _94)
    goto _jump966;
    // End body of loop
    int64_t _100 = 0;
    _100 *= _89.d0;
    _100 += _94;
    _100 *= _89.d1;
    _100 += _93;
    _100 *= _89.d2;
    _100 += _92;
    _89.data[_100] = _95;
    _92++;
    if (_92 < _90)
    goto _jump963;
    _92 = 0;
    _93++;
    if (_93 < u)
    goto _jump963;
    _93 = 0;
    _94++;
    if (_94 < s)
    goto _jump963;
    // End body of loop
    _88 = _89;
    goto _jump967;
    _jump959:;
    _a3__a2_void_t _101;
    // Computing bound for H
    _101.d0 = o;
    if (o > 0) 
    goto _jump968;
    fail_assertion("non-positive loop bound");
    _jump968:;
    // Computing bound for I
    _101.d1 = y.d1;
    if (y.d1 > 0) 
    goto _jump969;
    fail_assertion("non-positive loop bound");
    _jump969:;
    // Computing bound for J
    bool _102 = true;
    int64_t _103;
    if (!_102)
    goto _jump970;
    _103 = l;
    goto _jump971;
    _jump970:;
    _103 = y.d0;
    _jump971:;
    _101.d2 = _103;
    if (_103 > 0) 
    goto _jump972;
    fail_assertion("non-positive loop bound");
    _jump972:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= o;
    _104 *= y.d1;
    _104 *= _103;
    _104 *= sizeof(_a2_void_t);
    _101.data = jpl_alloc(_104);
    int64_t _105 = 0; // J
    int64_t _106 = 0; // I
    int64_t _107 = 0; // H
    _jump973:; // Begin body of loop
    _a2_void_t _108;
    // Computing bound for K
    _108.d0 = y.d1;
    if (y.d1 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for L
    _108.d1 = j;
    if (j > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= y.d1;
    _109 *= j;
    _109 *= sizeof(void_t);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // L
    int64_t _111 = 0; // K
    _jump976:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _108.d0;
    _112 += _111;
    _112 *= _108.d1;
    _112 += _110;
    _108.data[_112] = C;
    _110++;
    if (_110 < j)
    goto _jump976;
    _110 = 0;
    _111++;
    if (_111 < y.d1)
    goto _jump976;
    // End body of loop
    int64_t _113 = 0;
    _113 *= _101.d0;
    _113 += _107;
    _113 *= _101.d1;
    _113 += _106;
    _113 *= _101.d2;
    _113 += _105;
    _101.data[_113] = _108;
    _105++;
    if (_105 < _103)
    goto _jump973;
    _105 = 0;
    _106++;
    if (_106 < y.d1)
    goto _jump973;
    _106 = 0;
    _107++;
    if (_107 < o)
    goto _jump973;
    // End body of loop
    _88 = _101;
    _jump967:;
    _a1_int64_t _114;
    _114.d0 = 1;
    _114.data = jpl_alloc(sizeof(int64_t) * 1);
    _114.data[0] = l;
    if (s >= 0)
    goto _jump977;
    fail_assertion("negative array index");
    _jump977:;
    if (s < _114.d0)
    goto _jump978;
    fail_assertion("index too large");
    _jump978:;
    int64_t _115 = 0;
    _115 *= _114.d0;
    _115 += s;
    int64_t _116 = _114.data[_115];
    if (y.d0 >= 0)
    goto _jump979;
    fail_assertion("negative array index");
    _jump979:;
    if (y.d0 < _88.d0)
    goto _jump980;
    fail_assertion("index too large");
    _jump980:;
    if (_116 >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (_116 < _88.d1)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    if (d >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (d < _88.d2)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    int64_t _117 = 0;
    _117 *= _88.d0;
    _117 += y.d0;
    _117 *= _88.d1;
    _117 += _116;
    _117 *= _88.d2;
    _117 += d;
    _a2_void_t _118 = _88.data[_117];
    _a2_int64_t _119;
    // Computing bound for H
    bool _120 = false;
    int64_t _121;
    if (!_120)
    goto _jump985;
    int64_t _122 = 224;
    _121 = _122;
    goto _jump986;
    _jump985:;
    _121 = s;
    _jump986:;
    _119.d0 = _121;
    if (_121 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing bound for I
    int64_t _123 = -v;
    _119.d1 = _123;
    if (_123 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _121;
    _124 *= _123;
    _124 *= sizeof(int64_t);
    _119.data = jpl_alloc(_124);
    int64_t _125 = 0; // I
    int64_t _126 = 0; // H
    _jump989:; // Begin body of loop
    int64_t _127 = 0;
    _127 *= _119.d0;
    _127 += _126;
    _127 *= _119.d1;
    _127 += _125;
    _119.data[_127] = y.d1;
    _125++;
    if (_125 < _123)
    goto _jump989;
    _125 = 0;
    _126++;
    if (_126 < _121)
    goto _jump989;
    // End body of loop
    if (d >= 0)
    goto _jump990;
    fail_assertion("negative array index");
    _jump990:;
    if (d < _119.d0)
    goto _jump991;
    fail_assertion("index too large");
    _jump991:;
    if (y.d0 >= 0)
    goto _jump992;
    fail_assertion("negative array index");
    _jump992:;
    if (y.d0 < _119.d1)
    goto _jump993;
    fail_assertion("index too large");
    _jump993:;
    int64_t _128 = 0;
    _128 *= _119.d0;
    _128 += d;
    _128 *= _119.d1;
    _128 += y.d0;
    int64_t _129 = _119.data[_128];
    int64_t _130 = 445;
    if (_129 >= 0)
    goto _jump994;
    fail_assertion("negative array index");
    _jump994:;
    if (_129 < _118.d0)
    goto _jump995;
    fail_assertion("index too large");
    _jump995:;
    if (_130 >= 0)
    goto _jump996;
    fail_assertion("negative array index");
    _jump996:;
    if (_130 < _118.d1)
    goto _jump997;
    fail_assertion("index too large");
    _jump997:;
    int64_t _131 = 0;
    _131 *= _118.d0;
    _131 += _129;
    _131 *= _118.d1;
    _131 += _130;
    void_t _132 = _118.data[_131];
    _84 = _132;
    goto _jump998;
    _jump957:;
    int64_t _134 = _0 - v;
    bool _135 = _134 >= s;
    bool _133 = _135;
    if (0 != _135)
    goto _jump999;
    rgba _136 = w();
    rgba _137 = w();
    double _138 = _137.b;
    bool _139 = g(_136, _138);
    _133 = _139;
    _jump999:;
    bool _140;
    if (!_133)
    goto _jump1000;
    bool _141 = false;
    bool _142 = true;
    bool _143 = false;
    _a1_bool _144;
    _144.d0 = 3;
    _144.data = jpl_alloc(sizeof(bool) * 3);
    _144.data[0] = _141;
    _144.data[1] = _142;
    _144.data[2] = _143;
    if (l >= 0)
    goto _jump1001;
    fail_assertion("negative array index");
    _jump1001:;
    if (l < _144.d0)
    goto _jump1002;
    fail_assertion("index too large");
    _jump1002:;
    int64_t _145 = 0;
    _145 *= _144.d0;
    _145 += l;
    bool _146 = _144.data[_145];
    _140 = _146;
    goto _jump1003;
    _jump1000:;
    bool _147 = false;
    _140 = _147;
    _jump1003:;
    void_t _148;
    if (!_140)
    goto _jump1004;
    bool _149 = y.d0 != s;
    _a3_void_t _150;
    if (!_149)
    goto _jump1005;
    bool _151 = e != d;
    _a3_void_t _152;
    if (!_151)
    goto _jump1006;
    _a3_void_t _153;
    // Computing bound for H
    _153.d0 = d;
    if (d > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for I
    _153.d1 = _0;
    if (_0 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for J
    _153.d2 = s;
    if (s > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= d;
    _154 *= _0;
    _154 *= s;
    _154 *= sizeof(void_t);
    _153.data = jpl_alloc(_154);
    int64_t _155 = 0; // J
    int64_t _156 = 0; // I
    int64_t _157 = 0; // H
    _jump1010:; // Begin body of loop
    int64_t _158 = 0;
    _158 *= _153.d0;
    _158 += _157;
    _158 *= _153.d1;
    _158 += _156;
    _158 *= _153.d2;
    _158 += _155;
    _153.data[_158] = C;
    _155++;
    if (_155 < s)
    goto _jump1010;
    _155 = 0;
    _156++;
    if (_156 < _0)
    goto _jump1010;
    _156 = 0;
    _157++;
    if (_157 < d)
    goto _jump1010;
    // End body of loop
    _152 = _153;
    goto _jump1011;
    _jump1006:;
    _a3_void_t _159;
    // Computing bound for H
    _159.d0 = t;
    if (t > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    // Computing bound for I
    _159.d1 = d;
    if (d > 0) 
    goto _jump1013;
    fail_assertion("non-positive loop bound");
    _jump1013:;
    // Computing bound for J
    _159.d2 = y.d1;
    if (y.d1 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= t;
    _160 *= d;
    _160 *= y.d1;
    _160 *= sizeof(void_t);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // J
    int64_t _162 = 0; // I
    int64_t _163 = 0; // H
    _jump1015:; // Begin body of loop
    int64_t _164 = 0;
    _164 *= _159.d0;
    _164 += _163;
    _164 *= _159.d1;
    _164 += _162;
    _164 *= _159.d2;
    _164 += _161;
    _159.data[_164] = C;
    _161++;
    if (_161 < y.d1)
    goto _jump1015;
    _161 = 0;
    _162++;
    if (_162 < d)
    goto _jump1015;
    _162 = 0;
    _163++;
    if (_163 < t)
    goto _jump1015;
    // End body of loop
    _152 = _159;
    _jump1011:;
    _150 = _152;
    goto _jump1016;
    _jump1005:;
    _a3_void_t _165;
    // Computing bound for H
    _165.d0 = j;
    if (j > 0) 
    goto _jump1017;
    fail_assertion("non-positive loop bound");
    _jump1017:;
    // Computing bound for I
    int64_t _166 = 113;
    _165.d1 = _166;
    if (_166 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    // Computing bound for J
    _165.d2 = l;
    if (l > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= j;
    _167 *= _166;
    _167 *= l;
    _167 *= sizeof(void_t);
    _165.data = jpl_alloc(_167);
    int64_t _168 = 0; // J
    int64_t _169 = 0; // I
    int64_t _170 = 0; // H
    _jump1020:; // Begin body of loop
    int64_t _171 = 0;
    _171 *= _165.d0;
    _171 += _170;
    _171 *= _165.d1;
    _171 += _169;
    _171 *= _165.d2;
    _171 += _168;
    _165.data[_171] = C;
    _168++;
    if (_168 < l)
    goto _jump1020;
    _168 = 0;
    _169++;
    if (_169 < _166)
    goto _jump1020;
    _169 = 0;
    _170++;
    if (_170 < j)
    goto _jump1020;
    // End body of loop
    _150 = _165;
    _jump1016:;
    int64_t _172 = 384;
    if (_172 >= 0)
    goto _jump1021;
    fail_assertion("negative array index");
    _jump1021:;
    if (_172 < _150.d0)
    goto _jump1022;
    fail_assertion("index too large");
    _jump1022:;
    if (l >= 0)
    goto _jump1023;
    fail_assertion("negative array index");
    _jump1023:;
    if (l < _150.d1)
    goto _jump1024;
    fail_assertion("index too large");
    _jump1024:;
    if (y.d0 >= 0)
    goto _jump1025;
    fail_assertion("negative array index");
    _jump1025:;
    if (y.d0 < _150.d2)
    goto _jump1026;
    fail_assertion("index too large");
    _jump1026:;
    int64_t _173 = 0;
    _173 *= _150.d0;
    _173 += _172;
    _173 *= _150.d1;
    _173 += l;
    _173 *= _150.d2;
    _173 += y.d0;
    void_t _174 = _150.data[_173];
    _148 = _174;
    goto _jump1027;
    _jump1004:;
    _a1__a3_void_t _175;
    // Computing bound for H
    int64_t _176 = y.d2 % v;
    _175.d0 = _176;
    if (_176 > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _176;
    _177 *= sizeof(_a3_void_t);
    _175.data = jpl_alloc(_177);
    int64_t _178 = 0; // H
    _jump1029:; // Begin body of loop
    _a3_void_t _179;
    // Computing bound for I
    _179.d0 = j;
    if (j > 0) 
    goto _jump1030;
    fail_assertion("non-positive loop bound");
    _jump1030:;
    // Computing bound for J
    _179.d1 = y.d0;
    if (y.d0 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    // Computing bound for K
    _179.d2 = y.d1;
    if (y.d1 > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= j;
    _180 *= y.d0;
    _180 *= y.d1;
    _180 *= sizeof(void_t);
    _179.data = jpl_alloc(_180);
    int64_t _181 = 0; // K
    int64_t _182 = 0; // J
    int64_t _183 = 0; // I
    _jump1033:; // Begin body of loop
    int64_t _184 = 0;
    _184 *= _179.d0;
    _184 += _183;
    _184 *= _179.d1;
    _184 += _182;
    _184 *= _179.d2;
    _184 += _181;
    _179.data[_184] = C;
    _181++;
    if (_181 < y.d1)
    goto _jump1033;
    _181 = 0;
    _182++;
    if (_182 < y.d0)
    goto _jump1033;
    _182 = 0;
    _183++;
    if (_183 < j)
    goto _jump1033;
    // End body of loop
    int64_t _185 = 0;
    _185 *= _175.d0;
    _185 += _178;
    _175.data[_185] = _179;
    _178++;
    if (_178 < _176)
    goto _jump1029;
    // End body of loop
    int64_t _186 = 575;
    if (_186 >= 0)
    goto _jump1034;
    fail_assertion("negative array index");
    _jump1034:;
    if (_186 < _175.d0)
    goto _jump1035;
    fail_assertion("index too large");
    _jump1035:;
    int64_t _187 = 0;
    _187 *= _175.d0;
    _187 += _186;
    _a3_void_t _188 = _175.data[_187];
    if (y.d1 >= 0)
    goto _jump1036;
    fail_assertion("negative array index");
    _jump1036:;
    if (y.d1 < _188.d0)
    goto _jump1037;
    fail_assertion("index too large");
    _jump1037:;
    if (e >= 0)
    goto _jump1038;
    fail_assertion("negative array index");
    _jump1038:;
    if (e < _188.d1)
    goto _jump1039;
    fail_assertion("index too large");
    _jump1039:;
    if (y.d1 >= 0)
    goto _jump1040;
    fail_assertion("negative array index");
    _jump1040:;
    if (y.d1 < _188.d2)
    goto _jump1041;
    fail_assertion("index too large");
    _jump1041:;
    int64_t _189 = 0;
    _189 *= _188.d0;
    _189 += y.d1;
    _189 *= _188.d1;
    _189 += e;
    _189 *= _188.d2;
    _189 += y.d1;
    void_t _190 = _188.data[_189];
    _148 = _190;
    _jump1027:;
    _84 = _148;
    _jump998:;
    bool _191 = x(_1, _84);
    return _191;
    bool _192 = false;
    return _192;
}

void jpl_main(struct args args) {
    double _0;
    // Computing bound for b
    bool _1 = false;
    int64_t _2;
    if (!_1)
    goto _jump1;
    int64_t _3;
    // Computing bound for b
    int64_t _4;
    // Computing bound for b
    _a2_int64_t _5;
    // Computing bound for b
    int64_t _6 = 131;
    _5.d0 = _6;
    if (_6 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for c
    int64_t _7 = 870;
    _5.d1 = _7;
    if (_7 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= _6;
    _8 *= _7;
    _8 *= sizeof(int64_t);
    _5.data = jpl_alloc(_8);
    int64_t _9 = 0; // c
    int64_t _10 = 0; // b
    _jump4:; // Begin body of loop
    int64_t _11 = 0;
    _11 *= _5.d0;
    _11 += _10;
    _11 *= _5.d1;
    _11 += _9;
    _5.data[_11] = _9;
    _9++;
    if (_9 < _7)
    goto _jump4;
    _9 = 0;
    _10++;
    if (_10 < _6)
    goto _jump4;
    // End body of loop
    int64_t _12 = 647;
    int64_t _13 = 682;
    if (_12 >= 0)
    goto _jump5;
    fail_assertion("negative array index");
    _jump5:;
    if (_12 < _5.d0)
    goto _jump6;
    fail_assertion("index too large");
    _jump6:;
    if (_13 >= 0)
    goto _jump7;
    fail_assertion("negative array index");
    _jump7:;
    if (_13 < _5.d1)
    goto _jump8;
    fail_assertion("index too large");
    _jump8:;
    int64_t _14 = 0;
    _14 *= _5.d0;
    _14 += _12;
    _14 *= _5.d1;
    _14 += _13;
    int64_t _15 = _5.data[_14];
    if (_15 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    // Computing bound for c
    int64_t _16 = 363;
    if (_16 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    // Computing bound for d
    double _17 = 28.0;
    double _18 = 22.0;
    bool _19 = _17 > _18;
    int64_t _20;
    if (!_19)
    goto _jump11;
    int64_t _21 = 974;
    _20 = _21;
    goto _jump12;
    _jump11:;
    int64_t _22;
    // Computing bound for b
    int64_t _23 = 843;
    if (_23 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    _22 = 0;
    int64_t _24 = 0; // b
    _jump14:; // Begin body of loop
    int64_t _25 = 806;
    _22 += _25;
    _24++;
    if (_24 < _23)
    goto _jump14;
    // End body of loop
    _20 = _22;
    _jump12:;
    if (_20 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    _4 = 0;
    int64_t _26 = 0; // d
    int64_t _27 = 0; // c
    int64_t _28 = 0; // b
    _jump16:; // Begin body of loop
    int64_t _29;
    // Computing bound for e
    int64_t _30 = 113;
    if (_30 > 0) 
    goto _jump17;
    fail_assertion("non-positive loop bound");
    _jump17:;
    // Computing bound for f
    int64_t _31 = 185;
    int64_t _32 = _27 * _31;
    if (_32 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    // Computing bound for g
    if (_27 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    _29 = 0;
    int64_t _33 = 0; // g
    int64_t _34 = 0; // f
    int64_t _35 = 0; // e
    _jump20:; // Begin body of loop
    int64_t _36 = 404;
    _29 += _36;
    _33++;
    if (_33 < _27)
    goto _jump20;
    _33 = 0;
    _34++;
    if (_34 < _32)
    goto _jump20;
    _34 = 0;
    _35++;
    if (_35 < _30)
    goto _jump20;
    // End body of loop
    _4 += _29;
    _26++;
    if (_26 < _20)
    goto _jump16;
    _26 = 0;
    _27++;
    if (_27 < _16)
    goto _jump16;
    _27 = 0;
    _28++;
    if (_28 < _15)
    goto _jump16;
    // End body of loop
    if (_4 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing bound for c
    bool _37 = false;
    _a1_int64_t _38;
    if (!_37)
    goto _jump22;
    _a1_int64_t _39;
    // Computing bound for b
    int64_t _40 = 763;
    _39.d0 = _40;
    if (_40 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= _40;
    _41 *= sizeof(int64_t);
    _39.data = jpl_alloc(_41);
    int64_t _42 = 0; // b
    _jump24:; // Begin body of loop
    int64_t _43 = 0;
    _43 *= _39.d0;
    _43 += _42;
    _39.data[_43] = _42;
    _42++;
    if (_42 < _40)
    goto _jump24;
    // End body of loop
    _38 = _39;
    goto _jump25;
    _jump22:;
    _a1_int64_t _44;
    // Computing bound for b
    int64_t _45 = 392;
    _44.d0 = _45;
    if (_45 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= _45;
    _46 *= sizeof(int64_t);
    _44.data = jpl_alloc(_46);
    int64_t _47 = 0; // b
    _jump27:; // Begin body of loop
    int64_t _48 = 0;
    _48 *= _44.d0;
    _48 += _47;
    _44.data[_48] = _47;
    _47++;
    if (_47 < _45)
    goto _jump27;
    // End body of loop
    _38 = _44;
    _jump25:;
    int64_t _49 = 401;
    int64_t _50 = -_49;
    if (_50 >= 0)
    goto _jump28;
    fail_assertion("negative array index");
    _jump28:;
    if (_50 < _38.d0)
    goto _jump29;
    fail_assertion("index too large");
    _jump29:;
    int64_t _51 = 0;
    _51 *= _38.d0;
    _51 += _50;
    int64_t _52 = _38.data[_51];
    if (_52 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    _3 = 0;
    int64_t _53 = 0; // c
    int64_t _54 = 0; // b
    _jump31:; // Begin body of loop
    int64_t _55 = 673;
    _3 += _55;
    _53++;
    if (_53 < _52)
    goto _jump31;
    _53 = 0;
    _54++;
    if (_54 < _4)
    goto _jump31;
    // End body of loop
    _2 = _3;
    goto _jump32;
    _jump1:;
    _a2_int64_t _56;
    // Computing bound for b
    int64_t _57;
    // Computing bound for b
    int64_t _58 = 133;
    int64_t _59 = -_58;
    if (_59 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    _57 = 0;
    int64_t _60 = 0; // b
    _jump34:; // Begin body of loop
    int64_t _61 = 69;
    _57 += _61;
    _60++;
    if (_60 < _59)
    goto _jump34;
    // End body of loop
    _56.d0 = _57;
    if (_57 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for c
    int64_t _62 = 822;
    _56.d1 = _62;
    if (_62 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= _57;
    _63 *= _62;
    _63 *= sizeof(int64_t);
    _56.data = jpl_alloc(_63);
    int64_t _64 = 0; // c
    int64_t _65 = 0; // b
    _jump37:; // Begin body of loop
    int64_t _66 = 0;
    _66 *= _56.d0;
    _66 += _65;
    _66 *= _56.d1;
    _66 += _64;
    _56.data[_66] = _65;
    _64++;
    if (_64 < _62)
    goto _jump37;
    _64 = 0;
    _65++;
    if (_65 < _57)
    goto _jump37;
    // End body of loop
    int64_t _67 = 372;
    int64_t _68 = 163;
    int64_t _69 = -_68;
    int64_t _70 = -_69;
    if (_67 >= 0)
    goto _jump38;
    fail_assertion("negative array index");
    _jump38:;
    if (_67 < _56.d0)
    goto _jump39;
    fail_assertion("index too large");
    _jump39:;
    if (_70 >= 0)
    goto _jump40;
    fail_assertion("negative array index");
    _jump40:;
    if (_70 < _56.d1)
    goto _jump41;
    fail_assertion("index too large");
    _jump41:;
    int64_t _71 = 0;
    _71 *= _56.d0;
    _71 += _67;
    _71 *= _56.d1;
    _71 += _70;
    int64_t _72 = _56.data[_71];
    _2 = _72;
    _jump32:;
    int64_t _73 = -_2;
    if (_73 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    // Computing bound for c
    int64_t _74;
    // Computing bound for b
    bool _75 = true;
    int64_t _76;
    if (!_75)
    goto _jump43;
    int64_t _77;
    // Computing bound for b
    int64_t _78 = 449;
    int64_t _79 = 80;
    int64_t _80 = _78 / _79;
    int64_t _81 = 253;
    int64_t _82 = _80 * _81;
    if (_82 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    // Computing bound for c
    int64_t _83 = 371;
    int64_t _84 = 649;
    int64_t _85 = -_84;
    int64_t _86 = _83 + _85;
    if (_86 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    _77 = 0;
    int64_t _87 = 0; // c
    int64_t _88 = 0; // b
    _jump46:; // Begin body of loop
    _77 += _87;
    _87++;
    if (_87 < _86)
    goto _jump46;
    _87 = 0;
    _88++;
    if (_88 < _82)
    goto _jump46;
    // End body of loop
    _76 = _77;
    goto _jump47;
    _jump43:;
    bool _89 = true;
    int64_t _90;
    if (!_89)
    goto _jump48;
    int64_t _91 = 629;
    int64_t _92 = -_91;
    _90 = _92;
    goto _jump49;
    _jump48:;
    bool _93 = false;
    int64_t _94;
    if (!_93)
    goto _jump50;
    int64_t _95;
    // Computing bound for b
    int64_t _96 = 394;
    if (_96 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    _95 = 0;
    int64_t _97 = 0; // b
    _jump52:; // Begin body of loop
    _95 += _97;
    _97++;
    if (_97 < _96)
    goto _jump52;
    // End body of loop
    _94 = _95;
    goto _jump53;
    _jump50:;
    int64_t _98 = 951;
    _94 = _98;
    _jump53:;
    _90 = _94;
    _jump49:;
    _76 = _90;
    _jump47:;
    if (_76 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for c
    int64_t _99;
    // Computing bound for b
    int64_t _100 = 83;
    if (_100 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    _99 = 0;
    int64_t _101 = 0; // b
    _jump56:; // Begin body of loop
    int64_t _102 = 842;
    _99 += _102;
    _101++;
    if (_101 < _100)
    goto _jump56;
    // End body of loop
    if (_99 > 0) 
    goto _jump57;
    fail_assertion("non-positive loop bound");
    _jump57:;
    _74 = 0;
    int64_t _103 = 0; // c
    int64_t _104 = 0; // b
    _jump58:; // Begin body of loop
    bool _106 = true;
    bool _105 = _106;
    if (0 != _106)
    goto _jump59;
    bool _107 = true;
    _105 = _107;
    _jump59:;
    bool _108 = !_105;
    bool _109;
    if (!_108)
    goto _jump60;
    int64_t _110;
    // Computing bound for d
    if (_103 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    _110 = 0;
    int64_t _111 = 0; // d
    _jump62:; // Begin body of loop
    _110 += _104;
    _111++;
    if (_111 < _103)
    goto _jump62;
    // End body of loop
    int64_t _112;
    // Computing bound for d
    if (_104 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing bound for e
    if (_104 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    _112 = 0;
    int64_t _113 = 0; // e
    int64_t _114 = 0; // d
    _jump65:; // Begin body of loop
    _112 += _104;
    _113++;
    if (_113 < _104)
    goto _jump65;
    _113 = 0;
    _114++;
    if (_114 < _104)
    goto _jump65;
    // End body of loop
    bool _115 = _110 > _112;
    _109 = _115;
    goto _jump66;
    _jump60:;
    int64_t _116 = 944;
    int64_t _117 = _103 + _116;
    int64_t _118 = 973;
    bool _119 = _117 < _118;
    _109 = _119;
    _jump66:;
    int64_t _120;
    if (!_109)
    goto _jump67;
    int64_t _121 = _104 / _103;
    int64_t _122 = -_121;
    int64_t _123 = 24;
    bool _124 = _104 != _123;
    int64_t _125;
    if (!_124)
    goto _jump68;
    int64_t _126 = -_104;
    _125 = _126;
    goto _jump69;
    _jump68:;
    _125 = _103;
    _jump69:;
    int64_t _127 = _122 % _125;
    _120 = _127;
    goto _jump70;
    _jump67:;
    int64_t _128 = -_103;
    int64_t _129 = -_103;
    bool _130 = _128 != _129;
    int64_t _131;
    if (!_130)
    goto _jump71;
    _131 = _104;
    goto _jump72;
    _jump71:;
    int64_t _132 = 682;
    _131 = _132;
    _jump72:;
    _120 = _131;
    _jump70:;
    _74 += _120;
    _103++;
    if (_103 < _99)
    goto _jump58;
    _103 = 0;
    _104++;
    if (_104 < _76)
    goto _jump58;
    // End body of loop
    int64_t _133 = -_74;
    if (_133 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    _0 = 0;
    int64_t _134 = 0; // c
    int64_t _135 = 0; // b
    _jump74:; // Begin body of loop
    double _136 = 15.0;
    _0 += _136;
    _134++;
    if (_134 < _133)
    goto _jump74;
    _134 = 0;
    _135++;
    if (_135 < _73)
    goto _jump74;
    // End body of loop
    _a2__a1__a2_int64_t _137;
    // Computing bound for c
    int64_t _138 = 837;
    _137.d0 = _138;
    if (_138 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for d
    _a2__a1_int64_t _139;
    // Computing bound for c
    int64_t _140 = 667;
    _139.d0 = _140;
    if (_140 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for d
    int64_t _141 = 386;
    _139.d1 = _141;
    if (_141 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _140;
    _142 *= _141;
    _142 *= sizeof(_a1_int64_t);
    _139.data = jpl_alloc(_142);
    int64_t _143 = 0; // d
    int64_t _144 = 0; // c
    _jump78:; // Begin body of loop
    _a1_int64_t _145;
    // Computing bound for e
    int64_t _146 = 234;
    _145.d0 = _146;
    if (_146 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= _146;
    _147 *= sizeof(int64_t);
    _145.data = jpl_alloc(_147);
    int64_t _148 = 0; // e
    _jump80:; // Begin body of loop
    int64_t _149 = 0;
    _149 *= _145.d0;
    _149 += _148;
    _145.data[_149] = _144;
    _148++;
    if (_148 < _146)
    goto _jump80;
    // End body of loop
    int64_t _150 = 0;
    _150 *= _139.d0;
    _150 += _144;
    _150 *= _139.d1;
    _150 += _143;
    _139.data[_150] = _145;
    _143++;
    if (_143 < _141)
    goto _jump78;
    _143 = 0;
    _144++;
    if (_144 < _140)
    goto _jump78;
    // End body of loop
    int64_t _151 = 307;
    int64_t _152 = 247;
    int64_t _153 = _151 / _152;
    int64_t _154 = 377;
    int64_t _155 = -_154;
    if (_153 >= 0)
    goto _jump81;
    fail_assertion("negative array index");
    _jump81:;
    if (_153 < _139.d0)
    goto _jump82;
    fail_assertion("index too large");
    _jump82:;
    if (_155 >= 0)
    goto _jump83;
    fail_assertion("negative array index");
    _jump83:;
    if (_155 < _139.d1)
    goto _jump84;
    fail_assertion("index too large");
    _jump84:;
    int64_t _156 = 0;
    _156 *= _139.d0;
    _156 += _153;
    _156 *= _139.d1;
    _156 += _155;
    _a1_int64_t _157 = _139.data[_156];
    bool _158 = false;
    int64_t _159;
    if (!_158)
    goto _jump85;
    int64_t _160 = 508;
    int64_t _161 = -_160;
    _159 = _161;
    goto _jump86;
    _jump85:;
    int64_t _162 = 516;
    _159 = _162;
    _jump86:;
    int64_t _163 = 681;
    int64_t _164 = _159 / _163;
    if (_164 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_164 < _157.d0)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    int64_t _165 = 0;
    _165 *= _157.d0;
    _165 += _164;
    int64_t _166 = _157.data[_165];
    _137.d1 = _166;
    if (_166 > 0) 
    goto _jump89;
    fail_assertion("non-positive loop bound");
    _jump89:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= _138;
    _167 *= _166;
    _167 *= sizeof(_a1__a2_int64_t);
    _137.data = jpl_alloc(_167);
    int64_t _168 = 0; // d
    int64_t _169 = 0; // c
    _jump90:; // Begin body of loop
    _a1__a2_int64_t _170;
    // Computing bound for e
    _170.d0 = _168;
    if (_168 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _168;
    _171 *= sizeof(_a2_int64_t);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // e
    _jump92:; // Begin body of loop
    int64_t _173 = 835;
    int64_t _174 = 152;
    bool _175 = _173 > _174;
    _a2_int64_t _176;
    if (!_175)
    goto _jump93;
    _a2_int64_t _177;
    // Computing bound for f
    int64_t _178;
    // Computing bound for f
    int64_t _179 = 176;
    if (_179 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    // Computing bound for g
    if (_169 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    _178 = 0;
    int64_t _180 = 0; // g
    int64_t _181 = 0; // f
    _jump96:; // Begin body of loop
    int64_t _182 = 71;
    _178 += _182;
    _180++;
    if (_180 < _169)
    goto _jump96;
    _180 = 0;
    _181++;
    if (_181 < _179)
    goto _jump96;
    // End body of loop
    _177.d0 = _178;
    if (_178 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing bound for g
    int64_t _183 = _169 * _168;
    _177.d1 = _183;
    if (_183 > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= _178;
    _184 *= _183;
    _184 *= sizeof(int64_t);
    _177.data = jpl_alloc(_184);
    int64_t _185 = 0; // g
    int64_t _186 = 0; // f
    _jump99:; // Begin body of loop
    int64_t _187;
    // Computing bound for h
    if (_185 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    _187 = 0;
    int64_t _188 = 0; // h
    _jump101:; // Begin body of loop
    _187 += _188;
    _188++;
    if (_188 < _185)
    goto _jump101;
    // End body of loop
    int64_t _189 = 0;
    _189 *= _177.d0;
    _189 += _186;
    _189 *= _177.d1;
    _189 += _185;
    _177.data[_189] = _187;
    _185++;
    if (_185 < _183)
    goto _jump99;
    _185 = 0;
    _186++;
    if (_186 < _178)
    goto _jump99;
    // End body of loop
    _176 = _177;
    goto _jump102;
    _jump93:;
    _a2_int64_t _190;
    // Computing bound for f
    int64_t _191 = 815;
    _190.d0 = _191;
    if (_191 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    // Computing bound for g
    int64_t _192 = _168 % _168;
    _190.d1 = _192;
    if (_192 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= _191;
    _193 *= _192;
    _193 *= sizeof(int64_t);
    _190.data = jpl_alloc(_193);
    int64_t _194 = 0; // g
    int64_t _195 = 0; // f
    _jump105:; // Begin body of loop
    int64_t _196 = -_169;
    int64_t _197 = 0;
    _197 *= _190.d0;
    _197 += _195;
    _197 *= _190.d1;
    _197 += _194;
    _190.data[_197] = _196;
    _194++;
    if (_194 < _192)
    goto _jump105;
    _194 = 0;
    _195++;
    if (_195 < _191)
    goto _jump105;
    // End body of loop
    _176 = _190;
    _jump102:;
    int64_t _198 = 0;
    _198 *= _170.d0;
    _198 += _172;
    _170.data[_198] = _176;
    _172++;
    if (_172 < _168)
    goto _jump92;
    // End body of loop
    int64_t _199 = 0;
    _199 *= _137.d0;
    _199 += _169;
    _199 *= _137.d1;
    _199 += _168;
    _137.data[_199] = _170;
    _168++;
    if (_168 < _166)
    goto _jump90;
    _168 = 0;
    _169++;
    if (_169 < _138)
    goto _jump90;
    // End body of loop
    int64_t _200;
    // Computing bound for c
    int64_t _201 = 629;
    int64_t _202 = 271;
    int64_t _203 = _201 / _202;
    if (_203 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing bound for d
    _a1_int64_t _204;
    // Computing bound for c
    int64_t _205 = 821;
    _204.d0 = _205;
    if (_205 > 0) 
    goto _jump107;
    fail_assertion("non-positive loop bound");
    _jump107:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= _205;
    _206 *= sizeof(int64_t);
    _204.data = jpl_alloc(_206);
    int64_t _207 = 0; // c
    _jump108:; // Begin body of loop
    int64_t _208 = 257;
    int64_t _209 = 0;
    _209 *= _204.d0;
    _209 += _207;
    _204.data[_209] = _208;
    _207++;
    if (_207 < _205)
    goto _jump108;
    // End body of loop
    int64_t _210 = 388;
    if (_210 >= 0)
    goto _jump109;
    fail_assertion("negative array index");
    _jump109:;
    if (_210 < _204.d0)
    goto _jump110;
    fail_assertion("index too large");
    _jump110:;
    int64_t _211 = 0;
    _211 *= _204.d0;
    _211 += _210;
    int64_t _212 = _204.data[_211];
    int64_t _213 = 987;
    int64_t _214 = -_213;
    _a1_int64_t _215;
    _215.d0 = 2;
    _215.data = jpl_alloc(sizeof(int64_t) * 2);
    _215.data[0] = _212;
    _215.data[1] = _214;
    int64_t _216 = 543;
    int64_t _217 = -_216;
    int64_t _218 = 158;
    int64_t _219 = _217 + _218;
    if (_219 >= 0)
    goto _jump111;
    fail_assertion("negative array index");
    _jump111:;
    if (_219 < _215.d0)
    goto _jump112;
    fail_assertion("index too large");
    _jump112:;
    int64_t _220 = 0;
    _220 *= _215.d0;
    _220 += _219;
    int64_t _221 = _215.data[_220];
    if (_221 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    _200 = 0;
    int64_t _222 = 0; // d
    int64_t _223 = 0; // c
    _jump114:; // Begin body of loop
    bool _224 = false;
    bool _225;
    if (!_224)
    goto _jump115;
    bool _226 = true;
    bool _227 = !_226;
    _225 = _227;
    goto _jump116;
    _jump115:;
    bool _228 = false;
    _225 = _228;
    _jump116:;
    int64_t _229;
    if (!_225)
    goto _jump117;
    int64_t _230 = 430;
    _229 = _230;
    goto _jump118;
    _jump117:;
    int64_t _231 = 967;
    _229 = _231;
    _jump118:;
    bool _232 = true;
    int64_t _233;
    if (!_232)
    goto _jump119;
    _233 = _222;
    goto _jump120;
    _jump119:;
    bool _234 = true;
    bool _235 = !_234;
    int64_t _236;
    if (!_235)
    goto _jump121;
    int64_t _237 = -_223;
    _236 = _237;
    goto _jump122;
    _jump121:;
    int64_t _238 = 154;
    int64_t _239 = _238 % _223;
    _236 = _239;
    _jump122:;
    _233 = _236;
    _jump120:;
    int64_t _240 = _229 % _233;
    _200 += _240;
    _222++;
    if (_222 < _221)
    goto _jump114;
    _222 = 0;
    _223++;
    if (_223 < _203)
    goto _jump114;
    // End body of loop
    int64_t _241;
    // Computing bound for c
    double _242 = 90.0;
    double _243 = 48.0;
    double _244 = _242 * _243;
    double _245 = _244 - _0;
    bool _246 = _0 <= _245;
    int64_t _247;
    if (!_246)
    goto _jump123;
    int64_t _248 = 893;
    _247 = _248;
    goto _jump124;
    _jump123:;
    int64_t _249 = 948;
    _247 = _249;
    _jump124:;
    if (_247 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    // Computing bound for d
    int64_t _250 = 478;
    int64_t _251 = -_250;
    int64_t _252 = -_251;
    if (_252 > 0) 
    goto _jump126;
    fail_assertion("non-positive loop bound");
    _jump126:;
    // Computing bound for e
    int64_t _253 = 186;
    bool _254 = false;
    int64_t _255;
    if (!_254)
    goto _jump127;
    int64_t _256 = 783;
    _255 = _256;
    goto _jump128;
    _jump127:;
    int64_t _257 = 196;
    _255 = _257;
    _jump128:;
    bool _258 = _253 <= _255;
    int64_t _259;
    if (!_258)
    goto _jump129;
    int64_t _260 = 583;
    int64_t _261 = -_260;
    int64_t _262 = -_261;
    _259 = _262;
    goto _jump130;
    _jump129:;
    int64_t _263 = 482;
    _259 = _263;
    _jump130:;
    if (_259 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    _241 = 0;
    int64_t _264 = 0; // e
    int64_t _265 = 0; // d
    int64_t _266 = 0; // c
    _jump132:; // Begin body of loop
    _241 += _266;
    _264++;
    if (_264 < _259)
    goto _jump132;
    _264 = 0;
    _265++;
    if (_265 < _252)
    goto _jump132;
    _265 = 0;
    _266++;
    if (_266 < _247)
    goto _jump132;
    // End body of loop
    if (_200 >= 0)
    goto _jump133;
    fail_assertion("negative array index");
    _jump133:;
    if (_200 < _137.d0)
    goto _jump134;
    fail_assertion("index too large");
    _jump134:;
    if (_241 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_241 < _137.d1)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    int64_t _267 = 0;
    _267 *= _137.d0;
    _267 += _200;
    _267 *= _137.d1;
    _267 += _241;
    _a1__a2_int64_t _268 = _137.data[_267];
    int64_t _269 = 296;
    if (_269 >= 0)
    goto _jump137;
    fail_assertion("negative array index");
    _jump137:;
    if (_269 < _268.d0)
    goto _jump138;
    fail_assertion("index too large");
    _jump138:;
    int64_t _270 = 0;
    _270 *= _268.d0;
    _270 += _269;
    _a2_int64_t _271 = _268.data[_270];
    _a2_rgba _272 = read_image("f.png");
    _a2_rgba _273 = read_image("h.png");
    _a1__a2_rgba _274;
    // Computing bound for i
    _a3__a2_int64_t _275;
    // Computing bound for i
    _275.d0 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump420;
    fail_assertion("non-positive loop bound");
    _jump420:;
    // Computing bound for j
    int64_t _276 = 871;
    int64_t _277 = 112;
    if (_276 >= 0)
    goto _jump421;
    fail_assertion("negative array index");
    _jump421:;
    if (_276 < _271.d0)
    goto _jump422;
    fail_assertion("index too large");
    _jump422:;
    if (_277 >= 0)
    goto _jump423;
    fail_assertion("negative array index");
    _jump423:;
    if (_277 < _271.d1)
    goto _jump424;
    fail_assertion("index too large");
    _jump424:;
    int64_t _278 = 0;
    _278 *= _271.d0;
    _278 += _276;
    _278 *= _271.d1;
    _278 += _277;
    int64_t _279 = _271.data[_278];
    _275.d1 = _279;
    if (_279 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing bound for k
    int64_t _280 = _271.d0 % _271.d0;
    _275.d2 = _280;
    if (_280 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    // Computing total size of heap memory to allocate
    int64_t _281 = 1;
    _281 *= _271.d1;
    _281 *= _279;
    _281 *= _280;
    _281 *= sizeof(_a2_int64_t);
    _275.data = jpl_alloc(_281);
    int64_t _282 = 0; // k
    int64_t _283 = 0; // j
    int64_t _284 = 0; // i
    _jump427:; // Begin body of loop
    int64_t _285 = 0;
    _285 *= _275.d0;
    _285 += _284;
    _285 *= _275.d1;
    _285 += _283;
    _285 *= _275.d2;
    _285 += _282;
    _275.data[_285] = _271;
    _282++;
    if (_282 < _280)
    goto _jump427;
    _282 = 0;
    _283++;
    if (_283 < _279)
    goto _jump427;
    _283 = 0;
    _284++;
    if (_284 < _271.d1)
    goto _jump427;
    // End body of loop
    int64_t _286 = 699;
    bool _287 = _271.d1 > _286;
    bool _288;
    if (!_287)
    goto _jump428;
    double _289 = 67.0;
    double _290 = 97.0;
    bool _291 = _289 >= _290;
    _288 = _291;
    goto _jump429;
    _jump428:;
    bool _292 = true;
    _288 = _292;
    _jump429:;
    int64_t _293;
    if (!_288)
    goto _jump430;
    bool _294 = false;
    int64_t _295;
    if (!_294)
    goto _jump431;
    _295 = _271.d0;
    goto _jump432;
    _jump431:;
    int64_t _296;
    // Computing bound for i
    int64_t _297 = 472;
    if (_297 > 0) 
    goto _jump433;
    fail_assertion("non-positive loop bound");
    _jump433:;
    _296 = 0;
    int64_t _298 = 0; // i
    _jump434:; // Begin body of loop
    _296 += _271.d0;
    _298++;
    if (_298 < _297)
    goto _jump434;
    // End body of loop
    _295 = _296;
    _jump432:;
    _293 = _295;
    goto _jump435;
    _jump430:;
    int64_t _299 = 115;
    int64_t _300 = 477;
    int64_t _301 = _299 - _300;
    int64_t _302 = -_301;
    _293 = _302;
    _jump435:;
    if (_293 >= 0)
    goto _jump436;
    fail_assertion("negative array index");
    _jump436:;
    if (_293 < _275.d0)
    goto _jump437;
    fail_assertion("index too large");
    _jump437:;
    if (_271.d0 >= 0)
    goto _jump438;
    fail_assertion("negative array index");
    _jump438:;
    if (_271.d0 < _275.d1)
    goto _jump439;
    fail_assertion("index too large");
    _jump439:;
    if (_271.d0 >= 0)
    goto _jump440;
    fail_assertion("negative array index");
    _jump440:;
    if (_271.d0 < _275.d2)
    goto _jump441;
    fail_assertion("index too large");
    _jump441:;
    int64_t _303 = 0;
    _303 *= _275.d0;
    _303 += _293;
    _303 *= _275.d1;
    _303 += _271.d0;
    _303 *= _275.d2;
    _303 += _271.d0;
    _a2_int64_t _304 = _275.data[_303];
    bool _306 = true;
    bool _305 = _306;
    if (0 == _306)
    goto _jump442;
    int64_t _307 = 153;
    bool _308 = _307 == _271.d1;
    _305 = _308;
    _jump442:;
    _a1_int64_t _309;
    if (!_305)
    goto _jump443;
    _a1_int64_t _310;
    _310.d0 = 1;
    _310.data = jpl_alloc(sizeof(int64_t) * 1);
    _310.data[0] = _271.d0;
    _309 = _310;
    goto _jump444;
    _jump443:;
    int64_t _311 = 859;
    _a1_int64_t _312;
    _312.d0 = 1;
    _312.data = jpl_alloc(sizeof(int64_t) * 1);
    _312.data[0] = _311;
    _309 = _312;
    _jump444:;
    int64_t _313;
    // Computing bound for i
    int64_t _314 = 795;
    if (_314 >= 0)
    goto _jump445;
    fail_assertion("negative array index");
    _jump445:;
    if (_314 < _271.d0)
    goto _jump446;
    fail_assertion("index too large");
    _jump446:;
    if (_271.d1 >= 0)
    goto _jump447;
    fail_assertion("negative array index");
    _jump447:;
    if (_271.d1 < _271.d1)
    goto _jump448;
    fail_assertion("index too large");
    _jump448:;
    int64_t _315 = 0;
    _315 *= _271.d0;
    _315 += _314;
    _315 *= _271.d1;
    _315 += _271.d1;
    int64_t _316 = _271.data[_315];
    if (_316 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for j
    int64_t _317 = -_271.d1;
    if (_317 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    _313 = 0;
    int64_t _318 = 0; // j
    int64_t _319 = 0; // i
    _jump451:; // Begin body of loop
    int64_t _320 = _319 / _319;
    _313 += _320;
    _318++;
    if (_318 < _317)
    goto _jump451;
    _318 = 0;
    _319++;
    if (_319 < _316)
    goto _jump451;
    // End body of loop
    int64_t _321 = -_313;
    if (_321 >= 0)
    goto _jump452;
    fail_assertion("negative array index");
    _jump452:;
    if (_321 < _309.d0)
    goto _jump453;
    fail_assertion("index too large");
    _jump453:;
    int64_t _322 = 0;
    _322 *= _309.d0;
    _322 += _321;
    int64_t _323 = _309.data[_322];
    bool _324 = true;
    int64_t _325;
    if (!_324)
    goto _jump454;
    _325 = _271.d1;
    goto _jump455;
    _jump454:;
    int64_t _326 = 523;
    _325 = _326;
    _jump455:;
    int64_t _327 = _325 * _271.d0;
    int64_t _328 = -_271.d1;
    int64_t _329 = _271.d1 * _328;
    int64_t _330 = _327 / _329;
    int64_t _331 = -_330;
    if (_323 >= 0)
    goto _jump456;
    fail_assertion("negative array index");
    _jump456:;
    if (_323 < _304.d0)
    goto _jump457;
    fail_assertion("index too large");
    _jump457:;
    if (_331 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_331 < _304.d1)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    int64_t _332 = 0;
    _332 *= _304.d0;
    _332 += _323;
    _332 *= _304.d1;
    _332 += _331;
    int64_t _333 = _304.data[_332];
    _274.d0 = _333;
    if (_333 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing total size of heap memory to allocate
    int64_t _334 = 1;
    _334 *= _333;
    _334 *= sizeof(_a2_rgba);
    _274.data = jpl_alloc(_334);
    int64_t _335 = 0; // i
    _jump461:; // Begin body of loop
    int64_t _336 = 0;
    _336 *= _274.d0;
    _336 += _335;
    _274.data[_336] = _273;
    _335++;
    if (_335 < _333)
    goto _jump461;
    // End body of loop
    int64_t _337 = -_271.d0;
    int64_t _338 = _271.d0 - _337;
    int64_t _339 = _271.d0 - _338;
    int64_t _340 = -_339;
    if (_340 >= 0)
    goto _jump462;
    fail_assertion("negative array index");
    _jump462:;
    if (_340 < _274.d0)
    goto _jump463;
    fail_assertion("index too large");
    _jump463:;
    int64_t _341 = 0;
    _341 *= _274.d0;
    _341 += _340;
    _a2_rgba _342 = _274.data[_341];
    write_image(_342, "i.png");
    double _343 = get_time();
    _a2__a3_bool _344;
    // Computing bound for i
    int64_t _345;
    // Computing bound for i
    if (_271.d0 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing bound for j
    if (_271.d0 > 0) 
    goto _jump465;
    fail_assertion("non-positive loop bound");
    _jump465:;
    // Computing bound for k
    int64_t _346 = 504;
    if (_346 > 0) 
    goto _jump466;
    fail_assertion("non-positive loop bound");
    _jump466:;
    _345 = 0;
    int64_t _347 = 0; // k
    int64_t _348 = 0; // j
    int64_t _349 = 0; // i
    _jump467:; // Begin body of loop
    int64_t _350 = 959;
    _345 += _350;
    _347++;
    if (_347 < _346)
    goto _jump467;
    _347 = 0;
    _348++;
    if (_348 < _271.d0)
    goto _jump467;
    _348 = 0;
    _349++;
    if (_349 < _271.d0)
    goto _jump467;
    // End body of loop
    _344.d0 = _345;
    if (_345 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for j
    _344.d1 = _271.d0;
    if (_271.d0 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    // Computing total size of heap memory to allocate
    int64_t _351 = 1;
    _351 *= _345;
    _351 *= _271.d0;
    _351 *= sizeof(_a3_bool);
    _344.data = jpl_alloc(_351);
    int64_t _352 = 0; // j
    int64_t _353 = 0; // i
    _jump470:; // Begin body of loop
    _a3_bool _354;
    // Computing bound for k
    int64_t _355 = 901;
    _354.d0 = _355;
    if (_355 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing bound for l
    _354.d1 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for m
    _354.d2 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing total size of heap memory to allocate
    int64_t _356 = 1;
    _356 *= _355;
    _356 *= _271.d1;
    _356 *= _271.d1;
    _356 *= sizeof(bool);
    _354.data = jpl_alloc(_356);
    int64_t _357 = 0; // m
    int64_t _358 = 0; // l
    int64_t _359 = 0; // k
    _jump474:; // Begin body of loop
    bool _360 = false;
    int64_t _361 = 0;
    _361 *= _354.d0;
    _361 += _359;
    _361 *= _354.d1;
    _361 += _358;
    _361 *= _354.d2;
    _361 += _357;
    _354.data[_361] = _360;
    _357++;
    if (_357 < _271.d1)
    goto _jump474;
    _357 = 0;
    _358++;
    if (_358 < _271.d1)
    goto _jump474;
    _358 = 0;
    _359++;
    if (_359 < _355)
    goto _jump474;
    // End body of loop
    int64_t _362 = 0;
    _362 *= _344.d0;
    _362 += _353;
    _362 *= _344.d1;
    _362 += _352;
    _344.data[_362] = _354;
    _352++;
    if (_352 < _271.d0)
    goto _jump470;
    _352 = 0;
    _353++;
    if (_353 < _345)
    goto _jump470;
    // End body of loop
    int64_t _363 = 359;
    int64_t _364 = _363 + _271.d0;
    if (_364 >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (_364 < _344.d0)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    if (_271.d1 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_271.d1 < _344.d1)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    int64_t _365 = 0;
    _365 *= _344.d0;
    _365 += _364;
    _365 *= _344.d1;
    _365 += _271.d1;
    _a3_bool _366 = _344.data[_365];
    int64_t _367 = 895;
    int64_t _368 = 326;
    int64_t _369 = _367 % _368;
    int64_t _370 = _271.d1 + _369;
    int64_t _371 = -_370;
    if (_371 >= 0)
    goto _jump479;
    fail_assertion("negative array index");
    _jump479:;
    if (_371 < _366.d0)
    goto _jump480;
    fail_assertion("index too large");
    _jump480:;
    if (_271.d1 >= 0)
    goto _jump481;
    fail_assertion("negative array index");
    _jump481:;
    if (_271.d1 < _366.d1)
    goto _jump482;
    fail_assertion("index too large");
    _jump482:;
    if (_271.d0 >= 0)
    goto _jump483;
    fail_assertion("negative array index");
    _jump483:;
    if (_271.d0 < _366.d2)
    goto _jump484;
    fail_assertion("index too large");
    _jump484:;
    int64_t _372 = 0;
    _372 *= _366.d0;
    _372 += _371;
    _372 *= _366.d1;
    _372 += _271.d1;
    _372 *= _366.d2;
    _372 += _271.d0;
    bool _373 = _366.data[_372];
    bool _374;
    if (!_373)
    goto _jump485;
    int64_t _377 = _271.d0 * _271.d0;
    bool _378 = _271.d1 <= _377;
    bool _376 = _378;
    if (0 == _378)
    goto _jump486;
    if (_271.d0 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_271.d0 < _273.d0)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (_271.d0 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_271.d0 < _273.d1)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _379 = 0;
    _379 *= _273.d0;
    _379 += _271.d0;
    _379 *= _273.d1;
    _379 += _271.d0;
    rgba _380 = _273.data[_379];
    double _381;
    // Computing bound for i
    if (_271.d0 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for j
    int64_t _382 = 378;
    if (_382 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    _381 = 0;
    int64_t _383 = 0; // j
    int64_t _384 = 0; // i
    _jump493:; // Begin body of loop
    _381 += _0;
    _383++;
    if (_383 < _382)
    goto _jump493;
    _383 = 0;
    _384++;
    if (_384 < _271.d0)
    goto _jump493;
    // End body of loop
    bool _385 = g(_380, _381);
    _376 = _385;
    _jump486:;
    bool _375 = _376;
    if (0 == _376)
    goto _jump494;
    bool _387 = false;
    bool _386 = _387;
    if (0 != _387)
    goto _jump495;
    int64_t _388 = 417;
    bool _389 = _388 > _271.d0;
    _386 = _389;
    _jump495:;
    bool _390 = !_386;
    _375 = _390;
    _jump494:;
    _374 = _375;
    goto _jump496;
    _jump485:;
    bool _392 = _271.d0 >= _271.d1;
    bool _391 = _392;
    if (0 != _392)
    goto _jump497;
    bool _394 = false;
    bool _393 = _394;
    if (0 == _394)
    goto _jump498;
    bool _395 = true;
    _393 = _395;
    _jump498:;
    _391 = _393;
    _jump497:;
    bool _396 = !_391;
    _374 = _396;
    _jump496:;
    bool _397 = true;
    bool _398 = false;
    _a1_bool _399;
    _399.d0 = 2;
    _399.data = jpl_alloc(sizeof(bool) * 2);
    _399.data[0] = _397;
    _399.data[1] = _398;
    int64_t _400 = 13;
    if (_400 >= 0)
    goto _jump499;
    fail_assertion("negative array index");
    _jump499:;
    if (_400 < _399.d0)
    goto _jump500;
    fail_assertion("index too large");
    _jump500:;
    int64_t _401 = 0;
    _401 *= _399.d0;
    _401 += _400;
    bool _402 = _399.data[_401];
    double _403;
    if (!_402)
    goto _jump501;
    double _404;
    // Computing bound for i
    int64_t _405 = 928;
    int64_t _406 = _271.d0 - _405;
    if (_406 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    _404 = 0;
    int64_t _407 = 0; // i
    _jump503:; // Begin body of loop
    double _408 = -_0;
    _404 += _408;
    _407++;
    if (_407 < _406)
    goto _jump503;
    // End body of loop
    _403 = _404;
    goto _jump504;
    _jump501:;
    double _409 = 11.0;
    double _410 = _409 - _0;
    _403 = _410;
    _jump504:;
    double _411 = -_0;
    bool _412 = _403 >= _411;
    bool _413 = !_412;
    bool _414 = _374 == _413;
    show("(BoolType)", &_414);
    double _415 = get_time();
    print_time(_415 - _343);
    double _416;
    // Computing bound for i
    int64_t _417 = 74;
    _a1_int64_t _418;
    _418.d0 = 2;
    _418.data = jpl_alloc(sizeof(int64_t) * 2);
    _418.data[0] = _417;
    _418.data[1] = _271.d1;
    bool _419 = false;
    int64_t _420;
    if (!_419)
    goto _jump505;
    _420 = _271.d1;
    goto _jump506;
    _jump505:;
    _420 = _271.d0;
    _jump506:;
    if (_420 >= 0)
    goto _jump507;
    fail_assertion("negative array index");
    _jump507:;
    if (_420 < _418.d0)
    goto _jump508;
    fail_assertion("index too large");
    _jump508:;
    int64_t _421 = 0;
    _421 *= _418.d0;
    _421 += _420;
    int64_t _422 = _418.data[_421];
    int64_t _423 = -_422;
    if (_423 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    // Computing bound for j
    if (_271.d0 > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing bound for k
    int64_t _424 = 930;
    if (_424 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    _416 = 0;
    int64_t _425 = 0; // k
    int64_t _426 = 0; // j
    int64_t _427 = 0; // i
    _jump512:; // Begin body of loop
    double _428 = 45.0;
    _416 += _428;
    _425++;
    if (_425 < _424)
    goto _jump512;
    _425 = 0;
    _426++;
    if (_426 < _271.d0)
    goto _jump512;
    _426 = 0;
    _427++;
    if (_427 < _423)
    goto _jump512;
    // End body of loop
    bool _429 = _416 >= _0;
    _a1__a2_int64_t _430;
    if (!_429)
    goto _jump513;
    _a1__a2_int64_t _431;
    _431.d0 = 3;
    _431.data = jpl_alloc(sizeof(_a2_int64_t) * 3);
    _431.data[0] = _271;
    _431.data[1] = _271;
    _431.data[2] = _271;
    _430 = _431;
    goto _jump514;
    _jump513:;
    bool _432 = true;
    _a1__a2_int64_t _433;
    if (!_432)
    goto _jump515;
    _a3__a2_int64_t _434;
    // Computing bound for i
    int64_t _435 = 885;
    _434.d0 = _435;
    if (_435 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for j
    int64_t _436 = 852;
    _434.d1 = _436;
    if (_436 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for k
    int64_t _437 = 264;
    _434.d2 = _437;
    if (_437 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    // Computing total size of heap memory to allocate
    int64_t _438 = 1;
    _438 *= _435;
    _438 *= _436;
    _438 *= _437;
    _438 *= sizeof(_a2_int64_t);
    _434.data = jpl_alloc(_438);
    int64_t _439 = 0; // k
    int64_t _440 = 0; // j
    int64_t _441 = 0; // i
    _jump519:; // Begin body of loop
    int64_t _442 = 0;
    _442 *= _434.d0;
    _442 += _441;
    _442 *= _434.d1;
    _442 += _440;
    _442 *= _434.d2;
    _442 += _439;
    _434.data[_442] = _271;
    _439++;
    if (_439 < _437)
    goto _jump519;
    _439 = 0;
    _440++;
    if (_440 < _436)
    goto _jump519;
    _440 = 0;
    _441++;
    if (_441 < _435)
    goto _jump519;
    // End body of loop
    _a1__a3__a2_int64_t _443;
    _443.d0 = 1;
    _443.data = jpl_alloc(sizeof(_a3__a2_int64_t) * 1);
    _443.data[0] = _434;
    int64_t _444 = _271.d1 / _271.d1;
    if (_444 >= 0)
    goto _jump520;
    fail_assertion("negative array index");
    _jump520:;
    if (_444 < _443.d0)
    goto _jump521;
    fail_assertion("index too large");
    _jump521:;
    int64_t _445 = 0;
    _445 *= _443.d0;
    _445 += _444;
    _a3__a2_int64_t _446 = _443.data[_445];
    _a3_bool _447;
    // Computing bound for i
    int64_t _448 = 486;
    _447.d0 = _448;
    if (_448 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for j
    _447.d1 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing bound for k
    int64_t _449 = 545;
    _447.d2 = _449;
    if (_449 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= _448;
    _450 *= _271.d1;
    _450 *= _449;
    _450 *= sizeof(bool);
    _447.data = jpl_alloc(_450);
    int64_t _451 = 0; // k
    int64_t _452 = 0; // j
    int64_t _453 = 0; // i
    _jump525:; // Begin body of loop
    bool _454 = false;
    int64_t _455 = 0;
    _455 *= _447.d0;
    _455 += _453;
    _455 *= _447.d1;
    _455 += _452;
    _455 *= _447.d2;
    _455 += _451;
    _447.data[_455] = _454;
    _451++;
    if (_451 < _449)
    goto _jump525;
    _451 = 0;
    _452++;
    if (_452 < _271.d1)
    goto _jump525;
    _452 = 0;
    _453++;
    if (_453 < _448)
    goto _jump525;
    // End body of loop
    int64_t _456 = 375;
    if (_271.d0 >= 0)
    goto _jump526;
    fail_assertion("negative array index");
    _jump526:;
    if (_271.d0 < _447.d0)
    goto _jump527;
    fail_assertion("index too large");
    _jump527:;
    if (_271.d0 >= 0)
    goto _jump528;
    fail_assertion("negative array index");
    _jump528:;
    if (_271.d0 < _447.d1)
    goto _jump529;
    fail_assertion("index too large");
    _jump529:;
    if (_456 >= 0)
    goto _jump530;
    fail_assertion("negative array index");
    _jump530:;
    if (_456 < _447.d2)
    goto _jump531;
    fail_assertion("index too large");
    _jump531:;
    int64_t _457 = 0;
    _457 *= _447.d0;
    _457 += _271.d0;
    _457 *= _447.d1;
    _457 += _271.d0;
    _457 *= _447.d2;
    _457 += _456;
    bool _458 = _447.data[_457];
    int64_t _459;
    if (!_458)
    goto _jump532;
    int64_t _460 = 7;
    _459 = _460;
    goto _jump533;
    _jump532:;
    int64_t _461 = 125;
    bool _462 = _461 >= _271.d1;
    int64_t _463;
    if (!_462)
    goto _jump534;
    _463 = _271.d1;
    goto _jump535;
    _jump534:;
    _463 = _271.d0;
    _jump535:;
    _459 = _463;
    _jump533:;
    int64_t _464 = -_271.d1;
    int64_t _465;
    // Computing bound for i
    if (_271.d1 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    // Computing bound for j
    int64_t _466;
    // Computing bound for i
    int64_t _467 = 283;
    if (_467 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for j
    int64_t _468 = 309;
    if (_468 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing bound for k
    int64_t _469 = 435;
    if (_469 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    _466 = 0;
    int64_t _470 = 0; // k
    int64_t _471 = 0; // j
    int64_t _472 = 0; // i
    _jump540:; // Begin body of loop
    _466 += _271.d0;
    _470++;
    if (_470 < _469)
    goto _jump540;
    _470 = 0;
    _471++;
    if (_471 < _468)
    goto _jump540;
    _471 = 0;
    _472++;
    if (_472 < _467)
    goto _jump540;
    // End body of loop
    if (_466 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    _465 = 0;
    int64_t _473 = 0; // j
    int64_t _474 = 0; // i
    _jump542:; // Begin body of loop
    _465 += _473;
    _473++;
    if (_473 < _466)
    goto _jump542;
    _473 = 0;
    _474++;
    if (_474 < _271.d1)
    goto _jump542;
    // End body of loop
    int64_t _475 = _464 % _465;
    _a3_bool _476;
    // Computing bound for i
    _476.d0 = _271.d0;
    if (_271.d0 > 0) 
    goto _jump543;
    fail_assertion("non-positive loop bound");
    _jump543:;
    // Computing bound for j
    int64_t _477 = 723;
    _476.d1 = _477;
    if (_477 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for k
    _476.d2 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing total size of heap memory to allocate
    int64_t _478 = 1;
    _478 *= _271.d0;
    _478 *= _477;
    _478 *= _271.d1;
    _478 *= sizeof(bool);
    _476.data = jpl_alloc(_478);
    int64_t _479 = 0; // k
    int64_t _480 = 0; // j
    int64_t _481 = 0; // i
    _jump546:; // Begin body of loop
    bool _482 = false;
    int64_t _483 = 0;
    _483 *= _476.d0;
    _483 += _481;
    _483 *= _476.d1;
    _483 += _480;
    _483 *= _476.d2;
    _483 += _479;
    _476.data[_483] = _482;
    _479++;
    if (_479 < _271.d1)
    goto _jump546;
    _479 = 0;
    _480++;
    if (_480 < _477)
    goto _jump546;
    _480 = 0;
    _481++;
    if (_481 < _271.d0)
    goto _jump546;
    // End body of loop
    int64_t _484 = 775;
    int64_t _485;
    // Computing bound for i
    if (_271.d1 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    _485 = 0;
    int64_t _486 = 0; // i
    _jump548:; // Begin body of loop
    _485 += _486;
    _486++;
    if (_486 < _271.d1)
    goto _jump548;
    // End body of loop
    int64_t _487 = 237;
    if (_484 >= 0)
    goto _jump549;
    fail_assertion("negative array index");
    _jump549:;
    if (_484 < _476.d0)
    goto _jump550;
    fail_assertion("index too large");
    _jump550:;
    if (_485 >= 0)
    goto _jump551;
    fail_assertion("negative array index");
    _jump551:;
    if (_485 < _476.d1)
    goto _jump552;
    fail_assertion("index too large");
    _jump552:;
    if (_487 >= 0)
    goto _jump553;
    fail_assertion("negative array index");
    _jump553:;
    if (_487 < _476.d2)
    goto _jump554;
    fail_assertion("index too large");
    _jump554:;
    int64_t _488 = 0;
    _488 *= _476.d0;
    _488 += _484;
    _488 *= _476.d1;
    _488 += _485;
    _488 *= _476.d2;
    _488 += _487;
    bool _489 = _476.data[_488];
    int64_t _490;
    if (!_489)
    goto _jump555;
    _490 = _271.d0;
    goto _jump556;
    _jump555:;
    int64_t _491 = -_271.d0;
    int64_t _492 = 681;
    int64_t _493 = _491 * _492;
    _490 = _493;
    _jump556:;
    if (_459 >= 0)
    goto _jump557;
    fail_assertion("negative array index");
    _jump557:;
    if (_459 < _446.d0)
    goto _jump558;
    fail_assertion("index too large");
    _jump558:;
    if (_475 >= 0)
    goto _jump559;
    fail_assertion("negative array index");
    _jump559:;
    if (_475 < _446.d1)
    goto _jump560;
    fail_assertion("index too large");
    _jump560:;
    if (_490 >= 0)
    goto _jump561;
    fail_assertion("negative array index");
    _jump561:;
    if (_490 < _446.d2)
    goto _jump562;
    fail_assertion("index too large");
    _jump562:;
    int64_t _494 = 0;
    _494 *= _446.d0;
    _494 += _459;
    _494 *= _446.d1;
    _494 += _475;
    _494 *= _446.d2;
    _494 += _490;
    _a2_int64_t _495 = _446.data[_494];
    _a1_bool _496;
    // Computing bound for i
    bool _497 = true;
    int64_t _498;
    if (!_497)
    goto _jump563;
    _498 = _271.d0;
    goto _jump564;
    _jump563:;
    _498 = _271.d0;
    _jump564:;
    _496.d0 = _498;
    if (_498 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing total size of heap memory to allocate
    int64_t _499 = 1;
    _499 *= _498;
    _499 *= sizeof(bool);
    _496.data = jpl_alloc(_499);
    int64_t _500 = 0; // i
    _jump566:; // Begin body of loop
    double _501 = 80.0;
    double _502 = 97.0;
    bool _503 = _501 < _502;
    int64_t _504 = 0;
    _504 *= _496.d0;
    _504 += _500;
    _496.data[_504] = _503;
    _500++;
    if (_500 < _498)
    goto _jump566;
    // End body of loop
    int64_t _505 = 616;
    if (_505 >= 0)
    goto _jump567;
    fail_assertion("negative array index");
    _jump567:;
    if (_505 < _496.d0)
    goto _jump568;
    fail_assertion("index too large");
    _jump568:;
    int64_t _506 = 0;
    _506 *= _496.d0;
    _506 += _505;
    bool _507 = _496.data[_506];
    _a2_int64_t _508;
    if (!_507)
    goto _jump569;
    _a2__a2_int64_t _509;
    // Computing bound for i
    int64_t _510 = 612;
    _509.d0 = _510;
    if (_510 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for j
    int64_t _511 = -_271.d0;
    _509.d1 = _511;
    if (_511 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _512 = 1;
    _512 *= _510;
    _512 *= _511;
    _512 *= sizeof(_a2_int64_t);
    _509.data = jpl_alloc(_512);
    int64_t _513 = 0; // j
    int64_t _514 = 0; // i
    _jump572:; // Begin body of loop
    int64_t _515 = 0;
    _515 *= _509.d0;
    _515 += _514;
    _515 *= _509.d1;
    _515 += _513;
    _509.data[_515] = _271;
    _513++;
    if (_513 < _511)
    goto _jump572;
    _513 = 0;
    _514++;
    if (_514 < _510)
    goto _jump572;
    // End body of loop
    int64_t _516 = 74;
    int64_t _517 = _271.d0 - _516;
    int64_t _518 = 107;
    if (_517 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (_517 < _509.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    if (_518 >= 0)
    goto _jump575;
    fail_assertion("negative array index");
    _jump575:;
    if (_518 < _509.d1)
    goto _jump576;
    fail_assertion("index too large");
    _jump576:;
    int64_t _519 = 0;
    _519 *= _509.d0;
    _519 += _517;
    _519 *= _509.d1;
    _519 += _518;
    _a2_int64_t _520 = _509.data[_519];
    _508 = _520;
    goto _jump577;
    _jump569:;
    double _521 = 5.0;
    rgba _522 = { _0, _521, _0, _0 };
    double _523 = -_0;
    bool _524 = g(_522, _523);
    _a2_int64_t _525;
    if (!_524)
    goto _jump578;
    _525 = _271;
    goto _jump579;
    _jump578:;
    _525 = _271;
    _jump579:;
    _508 = _525;
    _jump577:;
    _a2_int64_t _526;
    // Computing bound for i
    int64_t _527 = 957;
    int64_t _528 = _271.d1 / _527;
    _526.d0 = _528;
    if (_528 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    // Computing bound for j
    _526.d1 = _271.d0;
    if (_271.d0 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing total size of heap memory to allocate
    int64_t _529 = 1;
    _529 *= _528;
    _529 *= _271.d0;
    _529 *= sizeof(int64_t);
    _526.data = jpl_alloc(_529);
    int64_t _530 = 0; // j
    int64_t _531 = 0; // i
    _jump582:; // Begin body of loop
    int64_t _532 = 0;
    _532 *= _526.d0;
    _532 += _531;
    _532 *= _526.d1;
    _532 += _530;
    _526.data[_532] = _531;
    _530++;
    if (_530 < _271.d0)
    goto _jump582;
    _530 = 0;
    _531++;
    if (_531 < _528)
    goto _jump582;
    // End body of loop
    _a1__a2_int64_t _533;
    _533.d0 = 3;
    _533.data = jpl_alloc(sizeof(_a2_int64_t) * 3);
    _533.data[0] = _495;
    _533.data[1] = _508;
    _533.data[2] = _526;
    _433 = _533;
    goto _jump583;
    _jump515:;
    _a2__a1__a2_int64_t _534;
    // Computing bound for i
    _534.d0 = _271.d0;
    if (_271.d0 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing bound for j
    _534.d1 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing total size of heap memory to allocate
    int64_t _535 = 1;
    _535 *= _271.d0;
    _535 *= _271.d1;
    _535 *= sizeof(_a1__a2_int64_t);
    _534.data = jpl_alloc(_535);
    int64_t _536 = 0; // j
    int64_t _537 = 0; // i
    _jump586:; // Begin body of loop
    _a1__a2_int64_t _538;
    // Computing bound for k
    int64_t _539;
    // Computing bound for k
    if (_271.d0 > 0) 
    goto _jump587;
    fail_assertion("non-positive loop bound");
    _jump587:;
    // Computing bound for l
    if (_271.d0 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    _539 = 0;
    int64_t _540 = 0; // l
    int64_t _541 = 0; // k
    _jump589:; // Begin body of loop
    int64_t _542;
    // Computing bound for m
    if (_271.d0 > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing bound for n
    if (_271.d1 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for o
    if (_536 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    _542 = 0;
    int64_t _543 = 0; // o
    int64_t _544 = 0; // n
    int64_t _545 = 0; // m
    _jump593:; // Begin body of loop
    _542 += _545;
    _543++;
    if (_543 < _536)
    goto _jump593;
    _543 = 0;
    _544++;
    if (_544 < _271.d1)
    goto _jump593;
    _544 = 0;
    _545++;
    if (_545 < _271.d0)
    goto _jump593;
    // End body of loop
    _539 += _542;
    _540++;
    if (_540 < _271.d0)
    goto _jump589;
    _540 = 0;
    _541++;
    if (_541 < _271.d0)
    goto _jump589;
    // End body of loop
    _538.d0 = _539;
    if (_539 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing total size of heap memory to allocate
    int64_t _546 = 1;
    _546 *= _539;
    _546 *= sizeof(_a2_int64_t);
    _538.data = jpl_alloc(_546);
    int64_t _547 = 0; // k
    _jump595:; // Begin body of loop
    int64_t _548 = 0;
    _548 *= _538.d0;
    _548 += _547;
    _538.data[_548] = _271;
    _547++;
    if (_547 < _539)
    goto _jump595;
    // End body of loop
    int64_t _549 = 0;
    _549 *= _534.d0;
    _549 += _537;
    _549 *= _534.d1;
    _549 += _536;
    _534.data[_549] = _538;
    _536++;
    if (_536 < _271.d1)
    goto _jump586;
    _536 = 0;
    _537++;
    if (_537 < _271.d0)
    goto _jump586;
    // End body of loop
    int64_t _550;
    // Computing bound for i
    if (_271.d0 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    _550 = 0;
    int64_t _551 = 0; // i
    _jump597:; // Begin body of loop
    bool _552 = true;
    bool _553 = !_552;
    int64_t _554;
    if (!_553)
    goto _jump598;
    int64_t _555;
    // Computing bound for j
    int64_t _556 = 789;
    if (_556 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    // Computing bound for k
    if (_551 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    _555 = 0;
    int64_t _557 = 0; // k
    int64_t _558 = 0; // j
    _jump601:; // Begin body of loop
    _555 += _557;
    _557++;
    if (_557 < _551)
    goto _jump601;
    _557 = 0;
    _558++;
    if (_558 < _556)
    goto _jump601;
    // End body of loop
    _554 = _555;
    goto _jump602;
    _jump598:;
    _554 = _271.d1;
    _jump602:;
    int64_t _559;
    // Computing bound for j
    int64_t _560 = 42;
    if (_560 > 0) 
    goto _jump603;
    fail_assertion("non-positive loop bound");
    _jump603:;
    // Computing bound for k
    int64_t _561 = 434;
    int64_t _562 = _561 / _271.d1;
    if (_562 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    _559 = 0;
    int64_t _563 = 0; // k
    int64_t _564 = 0; // j
    _jump605:; // Begin body of loop
    _559 += _271.d1;
    _563++;
    if (_563 < _562)
    goto _jump605;
    _563 = 0;
    _564++;
    if (_564 < _560)
    goto _jump605;
    // End body of loop
    int64_t _565 = _554 % _559;
    _550 += _565;
    _551++;
    if (_551 < _271.d0)
    goto _jump597;
    // End body of loop
    int64_t _566;
    // Computing bound for i
    bool _568 = true;
    bool _567 = _568;
    if (0 != _568)
    goto _jump606;
    bool _569 = false;
    _567 = _569;
    _jump606:;
    int64_t _570;
    if (!_567)
    goto _jump607;
    _570 = _271.d0;
    goto _jump608;
    _jump607:;
    int64_t _571 = 814;
    _570 = _571;
    _jump608:;
    if (_570 > 0) 
    goto _jump609;
    fail_assertion("non-positive loop bound");
    _jump609:;
    // Computing bound for j
    int64_t _572 = 60;
    if (_572 > 0) 
    goto _jump610;
    fail_assertion("non-positive loop bound");
    _jump610:;
    _566 = 0;
    int64_t _573 = 0; // j
    int64_t _574 = 0; // i
    _jump611:; // Begin body of loop
    _566 += _271.d1;
    _573++;
    if (_573 < _572)
    goto _jump611;
    _573 = 0;
    _574++;
    if (_574 < _570)
    goto _jump611;
    // End body of loop
    int64_t _575 = 130;
    int64_t _576 = 312;
    int64_t _577 = _575 * _576;
    int64_t _578 = -_577;
    int64_t _579 = -_578;
    int64_t _580 = _566 - _579;
    if (_550 >= 0)
    goto _jump612;
    fail_assertion("negative array index");
    _jump612:;
    if (_550 < _534.d0)
    goto _jump613;
    fail_assertion("index too large");
    _jump613:;
    if (_580 >= 0)
    goto _jump614;
    fail_assertion("negative array index");
    _jump614:;
    if (_580 < _534.d1)
    goto _jump615;
    fail_assertion("index too large");
    _jump615:;
    int64_t _581 = 0;
    _581 *= _534.d0;
    _581 += _550;
    _581 *= _534.d1;
    _581 += _580;
    _a1__a2_int64_t _582 = _534.data[_581];
    _433 = _582;
    _jump583:;
    _430 = _433;
    _jump514:;
    print("k");
    double _583 = 34.0;
    double _584 = -_583;
    _a3__a1__a1__a2_int64_t _585;
    // Computing bound for r
    _585.d0 = _271.d0;
    if (_271.d0 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing bound for s
    bool _586 = true;
    bool _587 = !_586;
    int64_t _588;
    if (!_587)
    goto _jump617;
    int64_t _589;
    // Computing bound for r
    int64_t _590 = -_430.d0;
    if (_590 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    _589 = 0;
    int64_t _591 = 0; // r
    _jump619:; // Begin body of loop
    _589 += _271.d1;
    _591++;
    if (_591 < _590)
    goto _jump619;
    // End body of loop
    _588 = _589;
    goto _jump620;
    _jump617:;
    _588 = _271.d0;
    _jump620:;
    int64_t _592 = -_588;
    _585.d1 = _592;
    if (_592 > 0) 
    goto _jump621;
    fail_assertion("non-positive loop bound");
    _jump621:;
    // Computing bound for t
    int64_t _593 = 51;
    _a1_bool _594;
    // Computing bound for r
    int64_t _595 = 987;
    _594.d0 = _595;
    if (_595 > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    // Computing total size of heap memory to allocate
    int64_t _596 = 1;
    _596 *= _595;
    _596 *= sizeof(bool);
    _594.data = jpl_alloc(_596);
    int64_t _597 = 0; // r
    _jump623:; // Begin body of loop
    bool _598 = true;
    int64_t _599 = 0;
    _599 *= _594.d0;
    _599 += _597;
    _594.data[_599] = _598;
    _597++;
    if (_597 < _595)
    goto _jump623;
    // End body of loop
    if (_271.d1 >= 0)
    goto _jump624;
    fail_assertion("negative array index");
    _jump624:;
    if (_271.d1 < _271.d0)
    goto _jump625;
    fail_assertion("index too large");
    _jump625:;
    if (_430.d0 >= 0)
    goto _jump626;
    fail_assertion("negative array index");
    _jump626:;
    if (_430.d0 < _271.d1)
    goto _jump627;
    fail_assertion("index too large");
    _jump627:;
    int64_t _600 = 0;
    _600 *= _271.d0;
    _600 += _271.d1;
    _600 *= _271.d1;
    _600 += _430.d0;
    int64_t _601 = _271.data[_600];
    if (_601 >= 0)
    goto _jump628;
    fail_assertion("negative array index");
    _jump628:;
    if (_601 < _594.d0)
    goto _jump629;
    fail_assertion("index too large");
    _jump629:;
    int64_t _602 = 0;
    _602 *= _594.d0;
    _602 += _601;
    bool _603 = _594.data[_602];
    double _604;
    if (!_603)
    goto _jump630;
    double _605 = _0 - _584;
    _604 = _605;
    goto _jump631;
    _jump630:;
    double _606 = 81.0;
    bool _607 = _606 <= _584;
    double _608;
    if (!_607)
    goto _jump632;
    double _609 = 75.0;
    double _610 = -_609;
    _608 = _610;
    goto _jump633;
    _jump632:;
    double _611;
    // Computing bound for r
    if (_271.d1 > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing bound for s
    if (_430.d0 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    _611 = 0;
    int64_t _612 = 0; // s
    int64_t _613 = 0; // r
    _jump636:; // Begin body of loop
    _611 += _0;
    _612++;
    if (_612 < _430.d0)
    goto _jump636;
    _612 = 0;
    _613++;
    if (_613 < _271.d1)
    goto _jump636;
    // End body of loop
    _608 = _611;
    _jump633:;
    _604 = _608;
    _jump631:;
    bool _614 = true;
    bool _615 = !_614;
    double _616;
    if (!_615)
    goto _jump637;
    _616 = _584;
    goto _jump638;
    _jump637:;
    double _617 = 89.0;
    _616 = _617;
    _jump638:;
    double _618 = -_616;
    bool _619 = _604 >= _618;
    int64_t _620;
    if (!_619)
    goto _jump639;
    bool _621 = true;
    bool _622;
    if (!_621)
    goto _jump640;
    bool _624 = false;
    bool _623 = _624;
    if (0 != _624)
    goto _jump641;
    bool _625 = false;
    _623 = _625;
    _jump641:;
    _622 = _623;
    goto _jump642;
    _jump640:;
    double _626 = 75.0;
    bool _627 = _584 != _626;
    _622 = _627;
    _jump642:;
    bool _628;
    if (!_622)
    goto _jump643;
    bool _629 = _271.d1 != _271.d0;
    _628 = _629;
    goto _jump644;
    _jump643:;
    bool _630 = false;
    _628 = _630;
    _jump644:;
    int64_t _631;
    if (!_628)
    goto _jump645;
    bool _632 = _271.d0 != _430.d0;
    _a1_int64_t _633;
    if (!_632)
    goto _jump646;
    _a1_int64_t _634;
    _634.d0 = 2;
    _634.data = jpl_alloc(sizeof(int64_t) * 2);
    _634.data[0] = _271.d1;
    _634.data[1] = _271.d0;
    _633 = _634;
    goto _jump647;
    _jump646:;
    _a1_int64_t _635;
    _635.d0 = 2;
    _635.data = jpl_alloc(sizeof(int64_t) * 2);
    _635.data[0] = _430.d0;
    _635.data[1] = _271.d1;
    _633 = _635;
    _jump647:;
    if (_271.d0 >= 0)
    goto _jump648;
    fail_assertion("negative array index");
    _jump648:;
    if (_271.d0 < _633.d0)
    goto _jump649;
    fail_assertion("index too large");
    _jump649:;
    int64_t _636 = 0;
    _636 *= _633.d0;
    _636 += _271.d0;
    int64_t _637 = _633.data[_636];
    _631 = _637;
    goto _jump650;
    _jump645:;
    _631 = _271.d0;
    _jump650:;
    _620 = _631;
    goto _jump651;
    _jump639:;
    int64_t _638 = _430.d0 * _430.d0;
    int64_t _639 = _638 / _271.d1;
    _620 = _639;
    _jump651:;
    int64_t _640 = _593 / _620;
    _585.d2 = _640;
    if (_640 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing total size of heap memory to allocate
    int64_t _641 = 1;
    _641 *= _271.d0;
    _641 *= _592;
    _641 *= _640;
    _641 *= sizeof(_a1__a1__a2_int64_t);
    _585.data = jpl_alloc(_641);
    int64_t _642 = 0; // t
    int64_t _643 = 0; // s
    int64_t _644 = 0; // r
    _jump653:; // Begin body of loop
    _a1__a1__a2_int64_t _645;
    // Computing bound for u
    bool _646 = false;
    _a2__a2_int64_t _647;
    if (!_646)
    goto _jump654;
    _a2__a2_int64_t _648;
    // Computing bound for u
    int64_t _649;
    // Computing bound for u
    if (_643 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for v
    if (_271.d1 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing bound for w
    if (_271.d1 > 0) 
    goto _jump657;
    fail_assertion("non-positive loop bound");
    _jump657:;
    _649 = 0;
    int64_t _650 = 0; // w
    int64_t _651 = 0; // v
    int64_t _652 = 0; // u
    _jump658:; // Begin body of loop
    _649 += _652;
    _650++;
    if (_650 < _271.d1)
    goto _jump658;
    _650 = 0;
    _651++;
    if (_651 < _271.d1)
    goto _jump658;
    _651 = 0;
    _652++;
    if (_652 < _643)
    goto _jump658;
    // End body of loop
    _648.d0 = _649;
    if (_649 > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing bound for v
    _648.d1 = _271.d0;
    if (_271.d0 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing total size of heap memory to allocate
    int64_t _653 = 1;
    _653 *= _649;
    _653 *= _271.d0;
    _653 *= sizeof(_a2_int64_t);
    _648.data = jpl_alloc(_653);
    int64_t _654 = 0; // v
    int64_t _655 = 0; // u
    _jump661:; // Begin body of loop
    _a2_int64_t _656;
    // Computing bound for w
    _656.d0 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing bound for x
    _656.d1 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing total size of heap memory to allocate
    int64_t _657 = 1;
    _657 *= _271.d1;
    _657 *= _271.d1;
    _657 *= sizeof(int64_t);
    _656.data = jpl_alloc(_657);
    int64_t _658 = 0; // x
    int64_t _659 = 0; // w
    _jump664:; // Begin body of loop
    int64_t _660 = 0;
    _660 *= _656.d0;
    _660 += _659;
    _660 *= _656.d1;
    _660 += _658;
    _656.data[_660] = _271.d1;
    _658++;
    if (_658 < _271.d1)
    goto _jump664;
    _658 = 0;
    _659++;
    if (_659 < _271.d1)
    goto _jump664;
    // End body of loop
    int64_t _661 = 0;
    _661 *= _648.d0;
    _661 += _655;
    _661 *= _648.d1;
    _661 += _654;
    _648.data[_661] = _656;
    _654++;
    if (_654 < _271.d0)
    goto _jump661;
    _654 = 0;
    _655++;
    if (_655 < _649)
    goto _jump661;
    // End body of loop
    _647 = _648;
    goto _jump665;
    _jump654:;
    bool _662 = _584 <= _584;
    _a2__a2_int64_t _663;
    if (!_662)
    goto _jump666;
    _a2__a2_int64_t _664;
    // Computing bound for u
    _664.d0 = _643;
    if (_643 > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    // Computing bound for v
    _664.d1 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    // Computing total size of heap memory to allocate
    int64_t _665 = 1;
    _665 *= _643;
    _665 *= _271.d1;
    _665 *= sizeof(_a2_int64_t);
    _664.data = jpl_alloc(_665);
    int64_t _666 = 0; // v
    int64_t _667 = 0; // u
    _jump669:; // Begin body of loop
    int64_t _668 = 0;
    _668 *= _664.d0;
    _668 += _667;
    _668 *= _664.d1;
    _668 += _666;
    _664.data[_668] = _271;
    _666++;
    if (_666 < _271.d1)
    goto _jump669;
    _666 = 0;
    _667++;
    if (_667 < _643)
    goto _jump669;
    // End body of loop
    _663 = _664;
    goto _jump670;
    _jump666:;
    _a2__a2_int64_t _669;
    // Computing bound for u
    _669.d0 = _642;
    if (_642 > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    // Computing bound for v
    int64_t _670 = 645;
    _669.d1 = _670;
    if (_670 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing total size of heap memory to allocate
    int64_t _671 = 1;
    _671 *= _642;
    _671 *= _670;
    _671 *= sizeof(_a2_int64_t);
    _669.data = jpl_alloc(_671);
    int64_t _672 = 0; // v
    int64_t _673 = 0; // u
    _jump673:; // Begin body of loop
    int64_t _674 = 0;
    _674 *= _669.d0;
    _674 += _673;
    _674 *= _669.d1;
    _674 += _672;
    _669.data[_674] = _271;
    _672++;
    if (_672 < _670)
    goto _jump673;
    _672 = 0;
    _673++;
    if (_673 < _642)
    goto _jump673;
    // End body of loop
    _663 = _669;
    _jump670:;
    _647 = _663;
    _jump665:;
    int64_t _675;
    // Computing bound for u
    if (_643 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing bound for v
    _a1_int64_t _676;
    // Computing bound for u
    _676.d0 = _644;
    if (_644 > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    // Computing total size of heap memory to allocate
    int64_t _677 = 1;
    _677 *= _644;
    _677 *= sizeof(int64_t);
    _676.data = jpl_alloc(_677);
    int64_t _678 = 0; // u
    _jump676:; // Begin body of loop
    int64_t _679 = 0;
    _679 *= _676.d0;
    _679 += _678;
    _676.data[_679] = _271.d1;
    _678++;
    if (_678 < _644)
    goto _jump676;
    // End body of loop
    if (_644 >= 0)
    goto _jump677;
    fail_assertion("negative array index");
    _jump677:;
    if (_644 < _676.d0)
    goto _jump678;
    fail_assertion("index too large");
    _jump678:;
    int64_t _680 = 0;
    _680 *= _676.d0;
    _680 += _644;
    int64_t _681 = _676.data[_680];
    if (_681 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    _675 = 0;
    int64_t _682 = 0; // v
    int64_t _683 = 0; // u
    _jump680:; // Begin body of loop
    int64_t _684 = -_682;
    _675 += _684;
    _682++;
    if (_682 < _681)
    goto _jump680;
    _682 = 0;
    _683++;
    if (_683 < _643)
    goto _jump680;
    // End body of loop
    _a3_int64_t _685;
    // Computing bound for u
    int64_t _686 = 44;
    _685.d0 = _686;
    if (_686 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    // Computing bound for v
    _685.d1 = _644;
    if (_644 > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing bound for w
    _685.d2 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing total size of heap memory to allocate
    int64_t _687 = 1;
    _687 *= _686;
    _687 *= _644;
    _687 *= _430.d0;
    _687 *= sizeof(int64_t);
    _685.data = jpl_alloc(_687);
    int64_t _688 = 0; // w
    int64_t _689 = 0; // v
    int64_t _690 = 0; // u
    _jump684:; // Begin body of loop
    int64_t _691 = 0;
    _691 *= _685.d0;
    _691 += _690;
    _691 *= _685.d1;
    _691 += _689;
    _691 *= _685.d2;
    _691 += _688;
    _685.data[_691] = _271.d0;
    _688++;
    if (_688 < _430.d0)
    goto _jump684;
    _688 = 0;
    _689++;
    if (_689 < _644)
    goto _jump684;
    _689 = 0;
    _690++;
    if (_690 < _686)
    goto _jump684;
    // End body of loop
    int64_t _692 = _271.d0 / _271.d1;
    int64_t _693;
    // Computing bound for u
    if (_644 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing bound for v
    if (_644 > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    // Computing bound for w
    int64_t _694 = _271.d0 - _271.d1;
    if (_694 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    _693 = 0;
    int64_t _695 = 0; // w
    int64_t _696 = 0; // v
    int64_t _697 = 0; // u
    _jump688:; // Begin body of loop
    _693 += _644;
    _695++;
    if (_695 < _694)
    goto _jump688;
    _695 = 0;
    _696++;
    if (_696 < _644)
    goto _jump688;
    _696 = 0;
    _697++;
    if (_697 < _644)
    goto _jump688;
    // End body of loop
    if (_692 >= 0)
    goto _jump689;
    fail_assertion("negative array index");
    _jump689:;
    if (_692 < _685.d0)
    goto _jump690;
    fail_assertion("index too large");
    _jump690:;
    if (_693 >= 0)
    goto _jump691;
    fail_assertion("negative array index");
    _jump691:;
    if (_693 < _685.d1)
    goto _jump692;
    fail_assertion("index too large");
    _jump692:;
    if (_643 >= 0)
    goto _jump693;
    fail_assertion("negative array index");
    _jump693:;
    if (_643 < _685.d2)
    goto _jump694;
    fail_assertion("index too large");
    _jump694:;
    int64_t _698 = 0;
    _698 *= _685.d0;
    _698 += _692;
    _698 *= _685.d1;
    _698 += _693;
    _698 *= _685.d2;
    _698 += _643;
    int64_t _699 = _685.data[_698];
    if (_675 >= 0)
    goto _jump695;
    fail_assertion("negative array index");
    _jump695:;
    if (_675 < _647.d0)
    goto _jump696;
    fail_assertion("index too large");
    _jump696:;
    if (_699 >= 0)
    goto _jump697;
    fail_assertion("negative array index");
    _jump697:;
    if (_699 < _647.d1)
    goto _jump698;
    fail_assertion("index too large");
    _jump698:;
    int64_t _700 = 0;
    _700 *= _647.d0;
    _700 += _675;
    _700 *= _647.d1;
    _700 += _699;
    _a2_int64_t _701 = _647.data[_700];
    int64_t _702 = 635;
    if (_702 >= 0)
    goto _jump699;
    fail_assertion("negative array index");
    _jump699:;
    if (_702 < _701.d0)
    goto _jump700;
    fail_assertion("index too large");
    _jump700:;
    if (_430.d0 >= 0)
    goto _jump701;
    fail_assertion("negative array index");
    _jump701:;
    if (_430.d0 < _701.d1)
    goto _jump702;
    fail_assertion("index too large");
    _jump702:;
    int64_t _703 = 0;
    _703 *= _701.d0;
    _703 += _702;
    _703 *= _701.d1;
    _703 += _430.d0;
    int64_t _704 = _701.data[_703];
    _645.d0 = _704;
    if (_704 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing total size of heap memory to allocate
    int64_t _705 = 1;
    _705 *= _704;
    _705 *= sizeof(_a1__a2_int64_t);
    _645.data = jpl_alloc(_705);
    int64_t _706 = 0; // u
    _jump704:; // Begin body of loop
    int64_t _707 = 0;
    _707 *= _645.d0;
    _707 += _706;
    _645.data[_707] = _430;
    _706++;
    if (_706 < _704)
    goto _jump704;
    // End body of loop
    int64_t _708 = 0;
    _708 *= _585.d0;
    _708 += _644;
    _708 *= _585.d1;
    _708 += _643;
    _708 *= _585.d2;
    _708 += _642;
    _585.data[_708] = _645;
    _642++;
    if (_642 < _640)
    goto _jump653;
    _642 = 0;
    _643++;
    if (_643 < _592)
    goto _jump653;
    _643 = 0;
    _644++;
    if (_644 < _271.d0)
    goto _jump653;
    // End body of loop
    bool _709 = true;
    bool _710 = !_709;
    bool _711 = true;
    rgba _712;
    if (!_711)
    goto _jump705;
    if (_430.d0 >= 0)
    goto _jump706;
    fail_assertion("negative array index");
    _jump706:;
    if (_430.d0 < _273.d0)
    goto _jump707;
    fail_assertion("index too large");
    _jump707:;
    if (_430.d0 >= 0)
    goto _jump708;
    fail_assertion("negative array index");
    _jump708:;
    if (_430.d0 < _273.d1)
    goto _jump709;
    fail_assertion("index too large");
    _jump709:;
    int64_t _713 = 0;
    _713 *= _273.d0;
    _713 += _430.d0;
    _713 *= _273.d1;
    _713 += _430.d0;
    rgba _714 = _273.data[_713];
    _712 = _714;
    goto _jump710;
    _jump705:;
    if (_271.d1 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (_271.d1 < _273.d0)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    if (_585.d2 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_585.d2 < _273.d1)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    int64_t _715 = 0;
    _715 *= _273.d0;
    _715 += _271.d1;
    _715 *= _273.d1;
    _715 += _585.d2;
    rgba _716 = _273.data[_715];
    _712 = _716;
    _jump710:;
    double _717 = _712.g;
    double _718 = 91.0;
    double _719;
    // Computing bound for v
    if (_430.d0 > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    // Computing bound for w
    if (_271.d1 > 0) 
    goto _jump716;
    fail_assertion("non-positive loop bound");
    _jump716:;
    _719 = 0;
    int64_t _720 = 0; // w
    int64_t _721 = 0; // v
    _jump717:; // Begin body of loop
    double _722;
    // Computing bound for x
    int64_t _723;
    // Computing bound for x
    if (_585.d1 > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for y
    if (_430.d0 > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    _723 = 0;
    int64_t _724 = 0; // y
    int64_t _725 = 0; // x
    _jump720:; // Begin body of loop
    _723 += _271.d1;
    _724++;
    if (_724 < _430.d0)
    goto _jump720;
    _724 = 0;
    _725++;
    if (_725 < _585.d1)
    goto _jump720;
    // End body of loop
    if (_723 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for y
    if (_585.d2 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing bound for z
    if (_271.d1 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    _722 = 0;
    int64_t _726 = 0; // z
    int64_t _727 = 0; // y
    int64_t _728 = 0; // x
    _jump724:; // Begin body of loop
    double _729;
    // Computing bound for A
    if (_271.d0 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing bound for B
    if (_271.d1 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    _729 = 0;
    int64_t _730 = 0; // B
    int64_t _731 = 0; // A
    _jump727:; // Begin body of loop
    double _732 = 35.0;
    _729 += _732;
    _730++;
    if (_730 < _271.d1)
    goto _jump727;
    _730 = 0;
    _731++;
    if (_731 < _271.d0)
    goto _jump727;
    // End body of loop
    _722 += _729;
    _726++;
    if (_726 < _271.d1)
    goto _jump724;
    _726 = 0;
    _727++;
    if (_727 < _585.d2)
    goto _jump724;
    _727 = 0;
    _728++;
    if (_728 < _723)
    goto _jump724;
    // End body of loop
    _719 += _722;
    _720++;
    if (_720 < _271.d1)
    goto _jump717;
    _720 = 0;
    _721++;
    if (_721 < _430.d0)
    goto _jump717;
    // End body of loop
    rgba _733 = { _717, _718, _584, _719 };
    _a3_double _734;
    // Computing bound for v
    _734.d0 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for w
    _734.d1 = _271.d1;
    if (_271.d1 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing bound for x
    _734.d2 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump730;
    fail_assertion("non-positive loop bound");
    _jump730:;
    // Computing total size of heap memory to allocate
    int64_t _735 = 1;
    _735 *= _271.d1;
    _735 *= _271.d1;
    _735 *= _430.d0;
    _735 *= sizeof(double);
    _734.data = jpl_alloc(_735);
    int64_t _736 = 0; // x
    int64_t _737 = 0; // w
    int64_t _738 = 0; // v
    _jump731:; // Begin body of loop
    int64_t _739 = 0;
    _739 *= _734.d0;
    _739 += _738;
    _739 *= _734.d1;
    _739 += _737;
    _739 *= _734.d2;
    _739 += _736;
    _734.data[_739] = _0;
    _736++;
    if (_736 < _430.d0)
    goto _jump731;
    _736 = 0;
    _737++;
    if (_737 < _271.d1)
    goto _jump731;
    _737 = 0;
    _738++;
    if (_738 < _271.d1)
    goto _jump731;
    // End body of loop
    _a3_double _740;
    // Computing bound for v
    _740.d0 = _585.d1;
    if (_585.d1 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    // Computing bound for w
    _740.d1 = _585.d0;
    if (_585.d0 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for x
    _740.d2 = _585.d0;
    if (_585.d0 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing total size of heap memory to allocate
    int64_t _741 = 1;
    _741 *= _585.d1;
    _741 *= _585.d0;
    _741 *= _585.d0;
    _741 *= sizeof(double);
    _740.data = jpl_alloc(_741);
    int64_t _742 = 0; // x
    int64_t _743 = 0; // w
    int64_t _744 = 0; // v
    _jump735:; // Begin body of loop
    int64_t _745 = 0;
    _745 *= _740.d0;
    _745 += _744;
    _745 *= _740.d1;
    _745 += _743;
    _745 *= _740.d2;
    _745 += _742;
    _740.data[_745] = _584;
    _742++;
    if (_742 < _585.d0)
    goto _jump735;
    _742 = 0;
    _743++;
    if (_743 < _585.d0)
    goto _jump735;
    _743 = 0;
    _744++;
    if (_744 < _585.d1)
    goto _jump735;
    // End body of loop
    _a1__a3_double _746;
    _746.d0 = 2;
    _746.data = jpl_alloc(sizeof(_a3_double) * 2);
    _746.data[0] = _734;
    _746.data[1] = _740;
    int64_t _747;
    // Computing bound for v
    if (_585.d1 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    _747 = 0;
    int64_t _748 = 0; // v
    _jump737:; // Begin body of loop
    _747 += _430.d0;
    _748++;
    if (_748 < _585.d1)
    goto _jump737;
    // End body of loop
    if (_747 >= 0)
    goto _jump738;
    fail_assertion("negative array index");
    _jump738:;
    if (_747 < _746.d0)
    goto _jump739;
    fail_assertion("index too large");
    _jump739:;
    int64_t _749 = 0;
    _749 *= _746.d0;
    _749 += _747;
    _a3_double _750 = _746.data[_749];
    int64_t _751 = _430.d0 + _271.d0;
    int64_t _752 = _751 + _430.d0;
    if (_271.d1 >= 0)
    goto _jump740;
    fail_assertion("negative array index");
    _jump740:;
    if (_271.d1 < _750.d0)
    goto _jump741;
    fail_assertion("index too large");
    _jump741:;
    if (_271.d1 >= 0)
    goto _jump742;
    fail_assertion("negative array index");
    _jump742:;
    if (_271.d1 < _750.d1)
    goto _jump743;
    fail_assertion("index too large");
    _jump743:;
    if (_752 >= 0)
    goto _jump744;
    fail_assertion("negative array index");
    _jump744:;
    if (_752 < _750.d2)
    goto _jump745;
    fail_assertion("index too large");
    _jump745:;
    int64_t _753 = 0;
    _753 *= _750.d0;
    _753 += _271.d1;
    _753 *= _750.d1;
    _753 += _271.d1;
    _753 *= _750.d2;
    _753 += _752;
    double _754 = _750.data[_753];
    bool _755 = g(_733, _754);
    bool _756 = _710 == _755;
    _a2_rgba _757;
    if (!_756)
    goto _jump746;
    _a2__a2_rgba _758;
    // Computing bound for v
    double _759;
    // Computing bound for v
    if (_271.d1 > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    _759 = 0;
    int64_t _760 = 0; // v
    _jump748:; // Begin body of loop
    double _761 = 98.0;
    _759 += _761;
    _760++;
    if (_760 < _271.d1)
    goto _jump748;
    // End body of loop
    double _762 = -_0;
    bool _763 = _759 >= _762;
    bool _764 = !_763;
    int64_t _765;
    if (!_764)
    goto _jump749;
    int64_t _766 = _430.d0 - _271.d1;
    _765 = _766;
    goto _jump750;
    _jump749:;
    _765 = _585.d2;
    _jump750:;
    _758.d0 = _765;
    if (_765 > 0) 
    goto _jump751;
    fail_assertion("non-positive loop bound");
    _jump751:;
    // Computing bound for w
    _758.d1 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing total size of heap memory to allocate
    int64_t _767 = 1;
    _767 *= _765;
    _767 *= _430.d0;
    _767 *= sizeof(_a2_rgba);
    _758.data = jpl_alloc(_767);
    int64_t _768 = 0; // w
    int64_t _769 = 0; // v
    _jump753:; // Begin body of loop
    bool _770 = false;
    bool _771;
    if (!_770)
    goto _jump754;
    bool _772 = true;
    _771 = _772;
    goto _jump755;
    _jump754:;
    bool _773 = true;
    _771 = _773;
    _jump755:;
    bool _774 = !_771;
    bool _775;
    if (!_774)
    goto _jump756;
    bool _776 = true;
    bool _777 = !_776;
    bool _778 = !_777;
    _775 = _778;
    goto _jump757;
    _jump756:;
    int64_t _779;
    // Computing bound for x
    if (_271.d1 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing bound for y
    if (_585.d2 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing bound for z
    if (_585.d0 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    _779 = 0;
    int64_t _780 = 0; // z
    int64_t _781 = 0; // y
    int64_t _782 = 0; // x
    _jump761:; // Begin body of loop
    _779 += _585.d2;
    _780++;
    if (_780 < _585.d0)
    goto _jump761;
    _780 = 0;
    _781++;
    if (_781 < _585.d2)
    goto _jump761;
    _781 = 0;
    _782++;
    if (_782 < _271.d1)
    goto _jump761;
    // End body of loop
    bool _783 = _271.d0 != _779;
    _775 = _783;
    _jump757:;
    _a2_rgba _784;
    if (!_775)
    goto _jump762;
    _a1__a2_rgba _785;
    // Computing bound for x
    _785.d0 = _585.d0;
    if (_585.d0 > 0) 
    goto _jump763;
    fail_assertion("non-positive loop bound");
    _jump763:;
    // Computing total size of heap memory to allocate
    int64_t _786 = 1;
    _786 *= _585.d0;
    _786 *= sizeof(_a2_rgba);
    _785.data = jpl_alloc(_786);
    int64_t _787 = 0; // x
    _jump764:; // Begin body of loop
    int64_t _788 = 0;
    _788 *= _785.d0;
    _788 += _787;
    _785.data[_788] = _273;
    _787++;
    if (_787 < _585.d0)
    goto _jump764;
    // End body of loop
    bool _789 = true;
    int64_t _790;
    if (!_789)
    goto _jump765;
    int64_t _791;
    // Computing bound for x
    if (_430.d0 > 0) 
    goto _jump766;
    fail_assertion("non-positive loop bound");
    _jump766:;
    _791 = 0;
    int64_t _792 = 0; // x
    _jump767:; // Begin body of loop
    _791 += _585.d2;
    _792++;
    if (_792 < _430.d0)
    goto _jump767;
    // End body of loop
    _790 = _791;
    goto _jump768;
    _jump765:;
    _790 = _585.d2;
    _jump768:;
    if (_790 >= 0)
    goto _jump769;
    fail_assertion("negative array index");
    _jump769:;
    if (_790 < _785.d0)
    goto _jump770;
    fail_assertion("index too large");
    _jump770:;
    int64_t _793 = 0;
    _793 *= _785.d0;
    _793 += _790;
    _a2_rgba _794 = _785.data[_793];
    _784 = _794;
    goto _jump771;
    _jump762:;
    _784 = _273;
    _jump771:;
    int64_t _795 = 0;
    _795 *= _758.d0;
    _795 += _769;
    _795 *= _758.d1;
    _795 += _768;
    _758.data[_795] = _784;
    _768++;
    if (_768 < _430.d0)
    goto _jump753;
    _768 = 0;
    _769++;
    if (_769 < _765)
    goto _jump753;
    // End body of loop
    if (_271.d1 >= 0)
    goto _jump772;
    fail_assertion("negative array index");
    _jump772:;
    if (_271.d1 < _758.d0)
    goto _jump773;
    fail_assertion("index too large");
    _jump773:;
    if (_271.d1 >= 0)
    goto _jump774;
    fail_assertion("negative array index");
    _jump774:;
    if (_271.d1 < _758.d1)
    goto _jump775;
    fail_assertion("index too large");
    _jump775:;
    int64_t _796 = 0;
    _796 *= _758.d0;
    _796 += _271.d1;
    _796 *= _758.d1;
    _796 += _271.d1;
    _a2_rgba _797 = _758.data[_796];
    _757 = _797;
    goto _jump776;
    _jump746:;
    _757 = _272;
    _jump776:;
    write_image(_757, "v.png");
    _a1_bool _798;
    // Computing bound for v
    _798.d0 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump777;
    fail_assertion("non-positive loop bound");
    _jump777:;
    // Computing total size of heap memory to allocate
    int64_t _799 = 1;
    _799 *= _430.d0;
    _799 *= sizeof(bool);
    _798.data = jpl_alloc(_799);
    int64_t _800 = 0; // v
    _jump778:; // Begin body of loop
    bool _801 = true;
    _a2_rgba _802;
    if (!_801)
    goto _jump779;
    _802 = _272;
    goto _jump780;
    _jump779:;
    _802 = _273;
    _jump780:;
    if (_585.d1 >= 0)
    goto _jump781;
    fail_assertion("negative array index");
    _jump781:;
    if (_585.d1 < _802.d0)
    goto _jump782;
    fail_assertion("index too large");
    _jump782:;
    if (_585.d2 >= 0)
    goto _jump783;
    fail_assertion("negative array index");
    _jump783:;
    if (_585.d2 < _802.d1)
    goto _jump784;
    fail_assertion("index too large");
    _jump784:;
    int64_t _803 = 0;
    _803 *= _802.d0;
    _803 += _585.d1;
    _803 *= _802.d1;
    _803 += _585.d2;
    rgba _804 = _802.data[_803];
    double _805 = _804.b;
    double _806 = 42.0;
    double _807;
    // Computing bound for w
    if (_585.d2 > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    // Computing bound for x
    if (_271.d1 > 0) 
    goto _jump786;
    fail_assertion("non-positive loop bound");
    _jump786:;
    // Computing bound for y
    int64_t _808 = 741;
    if (_808 >= 0)
    goto _jump787;
    fail_assertion("negative array index");
    _jump787:;
    if (_808 < _271.d0)
    goto _jump788;
    fail_assertion("index too large");
    _jump788:;
    if (_585.d1 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_585.d1 < _271.d1)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    int64_t _809 = 0;
    _809 *= _271.d0;
    _809 += _808;
    _809 *= _271.d1;
    _809 += _585.d1;
    int64_t _810 = _271.data[_809];
    if (_810 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    _807 = 0;
    int64_t _811 = 0; // y
    int64_t _812 = 0; // x
    int64_t _813 = 0; // w
    _jump792:; // Begin body of loop
    double _814;
    // Computing bound for z
    if (_800 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    // Computing bound for A
    if (_271.d0 > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    _814 = 0;
    int64_t _815 = 0; // A
    int64_t _816 = 0; // z
    _jump795:; // Begin body of loop
    _814 += _0;
    _815++;
    if (_815 < _271.d0)
    goto _jump795;
    _815 = 0;
    _816++;
    if (_816 < _800)
    goto _jump795;
    // End body of loop
    double _817 = -_814;
    _807 += _817;
    _811++;
    if (_811 < _810)
    goto _jump792;
    _811 = 0;
    _812++;
    if (_812 < _271.d1)
    goto _jump792;
    _812 = 0;
    _813++;
    if (_813 < _585.d2)
    goto _jump792;
    // End body of loop
    rgba _818 = { _805, _806, _807, _584 };
    _a1_double _819;
    // Computing bound for w
    _819.d0 = _585.d0;
    if (_585.d0 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing total size of heap memory to allocate
    int64_t _820 = 1;
    _820 *= _585.d0;
    _820 *= sizeof(double);
    _819.data = jpl_alloc(_820);
    int64_t _821 = 0; // w
    _jump797:; // Begin body of loop
    double _822;
    // Computing bound for x
    int64_t _823 = 79;
    int64_t _824 = _821 % _823;
    if (_824 > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing bound for y
    if (_430.d0 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    // Computing bound for z
    if (_800 > 0) 
    goto _jump800;
    fail_assertion("non-positive loop bound");
    _jump800:;
    _822 = 0;
    int64_t _825 = 0; // z
    int64_t _826 = 0; // y
    int64_t _827 = 0; // x
    _jump801:; // Begin body of loop
    _822 += _0;
    _825++;
    if (_825 < _800)
    goto _jump801;
    _825 = 0;
    _826++;
    if (_826 < _430.d0)
    goto _jump801;
    _826 = 0;
    _827++;
    if (_827 < _824)
    goto _jump801;
    // End body of loop
    int64_t _828 = 0;
    _828 *= _819.d0;
    _828 += _821;
    _819.data[_828] = _822;
    _821++;
    if (_821 < _585.d0)
    goto _jump797;
    // End body of loop
    if (_430.d0 >= 0)
    goto _jump802;
    fail_assertion("negative array index");
    _jump802:;
    if (_430.d0 < _819.d0)
    goto _jump803;
    fail_assertion("index too large");
    _jump803:;
    int64_t _829 = 0;
    _829 *= _819.d0;
    _829 += _430.d0;
    double _830 = _819.data[_829];
    bool _831 = g(_818, _830);
    int64_t _832 = 0;
    _832 *= _798.d0;
    _832 += _800;
    _798.data[_832] = _831;
    _800++;
    if (_800 < _430.d0)
    goto _jump778;
    // End body of loop
    int64_t _833 = -_585.d0;
    if (_833 >= 0)
    goto _jump804;
    fail_assertion("negative array index");
    _jump804:;
    if (_833 < _798.d0)
    goto _jump805;
    fail_assertion("index too large");
    _jump805:;
    int64_t _834 = 0;
    _834 *= _798.d0;
    _834 += _833;
    bool _835 = _798.data[_834];
    if (0 != _835)
    goto _jump806;
    fail_assertion("v");
    _jump806:;
    int64_t _836 = 819;
    show("(IntType)", &_836);
    print("w");
    double _837 = get_time();
    double _838 = get_time();
    print_time(_838 - _837);
}

