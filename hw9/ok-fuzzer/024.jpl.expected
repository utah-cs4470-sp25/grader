
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a1_int64_t *data;
} _a1__a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_rgba *data;
} _a2__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a1_int64_t *data;
} _a2__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a3__a1_int64_t *data;
} _a1__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_bool *data;
} _a2__a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2__a1_bool *data;
} _a3__a2__a2__a1_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  _a1_rgba *data;
} _a1__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_bool *data;
} _a3__a2__a1_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_int64_t *data;
} _a3__a3__a2_int64_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  _a2__a2_int64_t *data;
} _a1__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1_int64_t *data;
} _a2__a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
    bool a;
    _a3_bool b;
    rgba c;
} l;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
    l a;
    rgba b;
    bool c;
} o;

typedef struct {
  int64_t d0;
  o *data;
} _a1_o;

typedef struct {
  int64_t d0;
  int64_t d1;
  o *data;
} _a2_o;

typedef struct {
  int64_t d0;
  _a2_o *data;
} _a1__a2_o;

typedef struct {
  int64_t d0;
  int64_t d1;
  l *data;
} _a2_l;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a2_int64_t *data;
} _a3__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_bool *data;
} _a3__a3__a1_bool;

typedef struct {
  int64_t d0;
  _a2_l *data;
} _a1__a2_l;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  l *data;
} _a3_l;

typedef struct {
  int64_t d0;
  _a3__a3_bool *data;
} _a1__a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_rgba *data;
} _a3__a3_rgba;

typedef struct {
  int64_t d0;
  _a3_rgba *data;
} _a1__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_o *data;
} _a3__a2_o;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  o *data;
} _a3_o;

typedef struct {
  int64_t d0;
  l *data;
} _a1_l;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_l *data;
} _a2__a1_l;

rgba a() {
    bool _0 = false;
    _a2_int64_t _1;
    if (!_0)
    goto _jump109;
    bool _2 = false;
    bool _3 = true;
    bool _4 = false;
    bool _5 = _3 == _4;
    _a1_bool _6;
    _6.d0 = 2;
    _6.data = jpl_alloc(sizeof(bool) * 2);
    _6.data[0] = _2;
    _6.data[1] = _5;
    int64_t _7 = 501;
    int64_t _8 = 156;
    int64_t _9 = _7 - _8;
    int64_t _10 = 385;
    int64_t _11 = _9 / _10;
    if (_11 >= 0)
    goto _jump110;
    fail_assertion("negative array index");
    _jump110:;
    if (_11 < _6.d0)
    goto _jump111;
    fail_assertion("index too large");
    _jump111:;
    int64_t _12 = 0;
    _12 *= _6.d0;
    _12 += _11;
    bool _13 = _6.data[_12];
    _a2_int64_t _14;
    if (!_13)
    goto _jump112;
    _a2_int64_t _15;
    if (!_0)
    goto _jump113;
    _a2_int64_t _16;
    // Computing bound for c
    int64_t _17 = 930;
    _16.d0 = _17;
    if (_17 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    // Computing bound for d
    int64_t _18 = 183;
    _16.d1 = _18;
    if (_18 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= _17;
    _19 *= _18;
    _19 *= sizeof(int64_t);
    _16.data = jpl_alloc(_19);
    int64_t _20 = 0; // d
    int64_t _21 = 0; // c
    _jump116:; // Begin body of loop
    int64_t _22 = 988;
    int64_t _23 = 0;
    _23 *= _16.d0;
    _23 += _21;
    _23 *= _16.d1;
    _23 += _20;
    _16.data[_23] = _22;
    _20++;
    if (_20 < _18)
    goto _jump116;
    _20 = 0;
    _21++;
    if (_21 < _17)
    goto _jump116;
    // End body of loop
    _a2_int64_t _24;
    // Computing bound for c
    int64_t _25 = 346;
    _24.d0 = _25;
    if (_25 > 0) 
    goto _jump117;
    fail_assertion("non-positive loop bound");
    _jump117:;
    // Computing bound for d
    int64_t _26 = 753;
    _24.d1 = _26;
    if (_26 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= _25;
    _27 *= _26;
    _27 *= sizeof(int64_t);
    _24.data = jpl_alloc(_27);
    int64_t _28 = 0; // d
    int64_t _29 = 0; // c
    _jump119:; // Begin body of loop
    int64_t _30 = 0;
    _30 *= _24.d0;
    _30 += _29;
    _30 *= _24.d1;
    _30 += _28;
    _24.data[_30] = _28;
    _28++;
    if (_28 < _26)
    goto _jump119;
    _28 = 0;
    _29++;
    if (_29 < _25)
    goto _jump119;
    // End body of loop
    _a1__a2_int64_t _31;
    _31.d0 = 2;
    _31.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _31.data[0] = _16;
    _31.data[1] = _24;
    bool _32 = false;
    int64_t _33;
    if (!_32)
    goto _jump120;
    int64_t _34 = 396;
    int64_t _35 = 988;
    int64_t _36 = _34 - _35;
    _33 = _36;
    goto _jump121;
    _jump120:;
    int64_t _37 = 505;
    _33 = _37;
    _jump121:;
    if (_33 >= 0)
    goto _jump122;
    fail_assertion("negative array index");
    _jump122:;
    if (_33 < _31.d0)
    goto _jump123;
    fail_assertion("index too large");
    _jump123:;
    int64_t _38 = 0;
    _38 *= _31.d0;
    _38 += _33;
    _a2_int64_t _39 = _31.data[_38];
    _15 = _39;
    goto _jump124;
    _jump113:;
    _a2_int64_t _40;
    // Computing bound for c
    _a1_int64_t _41;
    // Computing bound for c
    int64_t _42 = 462;
    _41.d0 = _42;
    if (_42 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= _42;
    _43 *= sizeof(int64_t);
    _41.data = jpl_alloc(_43);
    int64_t _44 = 0; // c
    _jump126:; // Begin body of loop
    int64_t _45 = 0;
    _45 *= _41.d0;
    _45 += _44;
    _41.data[_45] = _44;
    _44++;
    if (_44 < _42)
    goto _jump126;
    // End body of loop
    int64_t _46 = 892;
    int64_t _47 = -_46;
    if (_47 >= 0)
    goto _jump127;
    fail_assertion("negative array index");
    _jump127:;
    if (_47 < _41.d0)
    goto _jump128;
    fail_assertion("index too large");
    _jump128:;
    int64_t _48 = 0;
    _48 *= _41.d0;
    _48 += _47;
    int64_t _49 = _41.data[_48];
    _40.d0 = _49;
    if (_49 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    // Computing bound for d
    _a2_int64_t _50;
    // Computing bound for c
    int64_t _51 = 892;
    _50.d0 = _51;
    if (_51 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for d
    int64_t _52 = 769;
    _50.d1 = _52;
    if (_52 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= _51;
    _53 *= _52;
    _53 *= sizeof(int64_t);
    _50.data = jpl_alloc(_53);
    int64_t _54 = 0; // d
    int64_t _55 = 0; // c
    _jump132:; // Begin body of loop
    int64_t _56 = 0;
    _56 *= _50.d0;
    _56 += _55;
    _56 *= _50.d1;
    _56 += _54;
    _50.data[_56] = _55;
    _54++;
    if (_54 < _52)
    goto _jump132;
    _54 = 0;
    _55++;
    if (_55 < _51)
    goto _jump132;
    // End body of loop
    int64_t _57;
    // Computing bound for c
    int64_t _58 = 214;
    if (_58 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    _57 = 0;
    int64_t _59 = 0; // c
    _jump134:; // Begin body of loop
    _57 += _59;
    _59++;
    if (_59 < _58)
    goto _jump134;
    // End body of loop
    int64_t _60 = 534;
    if (_57 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_57 < _50.d0)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    if (_60 >= 0)
    goto _jump137;
    fail_assertion("negative array index");
    _jump137:;
    if (_60 < _50.d1)
    goto _jump138;
    fail_assertion("index too large");
    _jump138:;
    int64_t _61 = 0;
    _61 *= _50.d0;
    _61 += _57;
    _61 *= _50.d1;
    _61 += _60;
    int64_t _62 = _50.data[_61];
    _40.d1 = _62;
    if (_62 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= _49;
    _63 *= _62;
    _63 *= sizeof(int64_t);
    _40.data = jpl_alloc(_63);
    int64_t _64 = 0; // d
    int64_t _65 = 0; // c
    _jump140:; // Begin body of loop
    int64_t _66 = 0;
    _66 *= _40.d0;
    _66 += _65;
    _66 *= _40.d1;
    _66 += _64;
    _40.data[_66] = _64;
    _64++;
    if (_64 < _62)
    goto _jump140;
    _64 = 0;
    _65++;
    if (_65 < _49)
    goto _jump140;
    // End body of loop
    _15 = _40;
    _jump124:;
    _14 = _15;
    goto _jump141;
    _jump112:;
    _a2_int64_t _67;
    // Computing bound for c
    int64_t _68 = 281;
    int64_t _69 = -_68;
    _67.d0 = _69;
    if (_69 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    // Computing bound for d
    int64_t _70 = 438;
    _67.d1 = _70;
    if (_70 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= _69;
    _71 *= _70;
    _71 *= sizeof(int64_t);
    _67.data = jpl_alloc(_71);
    int64_t _72 = 0; // d
    int64_t _73 = 0; // c
    _jump144:; // Begin body of loop
    int64_t _74 = 442;
    int64_t _75 = 0;
    _75 *= _67.d0;
    _75 += _73;
    _75 *= _67.d1;
    _75 += _72;
    _67.data[_75] = _74;
    _72++;
    if (_72 < _70)
    goto _jump144;
    _72 = 0;
    _73++;
    if (_73 < _69)
    goto _jump144;
    // End body of loop
    _14 = _67;
    _jump141:;
    _1 = _14;
    goto _jump145;
    _jump109:;
    _a2__a2_int64_t _76;
    // Computing bound for c
    int64_t _77;
    // Computing bound for c
    int64_t _78 = 982;
    int64_t _79 = -_78;
    if (_79 > 0) 
    goto _jump146;
    fail_assertion("non-positive loop bound");
    _jump146:;
    // Computing bound for d
    int64_t _80 = 3;
    if (_80 > 0) 
    goto _jump147;
    fail_assertion("non-positive loop bound");
    _jump147:;
    _77 = 0;
    int64_t _81 = 0; // d
    int64_t _82 = 0; // c
    _jump148:; // Begin body of loop
    _77 += _81;
    _81++;
    if (_81 < _80)
    goto _jump148;
    _81 = 0;
    _82++;
    if (_82 < _79)
    goto _jump148;
    // End body of loop
    int64_t _83 = -_77;
    _76.d0 = _83;
    if (_83 > 0) 
    goto _jump149;
    fail_assertion("non-positive loop bound");
    _jump149:;
    // Computing bound for d
    int64_t _84 = 649;
    _76.d1 = _84;
    if (_84 > 0) 
    goto _jump150;
    fail_assertion("non-positive loop bound");
    _jump150:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= _83;
    _85 *= _84;
    _85 *= sizeof(_a2_int64_t);
    _76.data = jpl_alloc(_85);
    int64_t _86 = 0; // d
    int64_t _87 = 0; // c
    _jump151:; // Begin body of loop
    _a2_int64_t _88;
    // Computing bound for e
    _88.d0 = _86;
    if (_86 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing bound for f
    _88.d1 = _86;
    if (_86 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _86;
    _89 *= _86;
    _89 *= sizeof(int64_t);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // f
    int64_t _91 = 0; // e
    _jump154:; // Begin body of loop
    int64_t _92 = -_87;
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _91;
    _93 *= _88.d1;
    _93 += _90;
    _88.data[_93] = _92;
    _90++;
    if (_90 < _86)
    goto _jump154;
    _90 = 0;
    _91++;
    if (_91 < _86)
    goto _jump154;
    // End body of loop
    int64_t _94 = 0;
    _94 *= _76.d0;
    _94 += _87;
    _94 *= _76.d1;
    _94 += _86;
    _76.data[_94] = _88;
    _86++;
    if (_86 < _84)
    goto _jump151;
    _86 = 0;
    _87++;
    if (_87 < _83)
    goto _jump151;
    // End body of loop
    int64_t _95;
    // Computing bound for c
    int64_t _96 = 300;
    if (_96 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    _95 = 0;
    int64_t _97 = 0; // c
    _jump156:; // Begin body of loop
    int64_t _98;
    // Computing bound for d
    int64_t _99 = -_97;
    int64_t _100 = 311;
    int64_t _101 = _99 / _100;
    if (_101 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing bound for e
    int64_t _102;
    // Computing bound for d
    if (_97 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    // Computing bound for e
    int64_t _103 = 818;
    if (_103 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    _102 = 0;
    int64_t _104 = 0; // e
    int64_t _105 = 0; // d
    _jump160:; // Begin body of loop
    _102 += _97;
    _104++;
    if (_104 < _103)
    goto _jump160;
    _104 = 0;
    _105++;
    if (_105 < _97)
    goto _jump160;
    // End body of loop
    if (_102 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    _98 = 0;
    int64_t _106 = 0; // e
    int64_t _107 = 0; // d
    _jump162:; // Begin body of loop
    _98 += _106;
    _106++;
    if (_106 < _102)
    goto _jump162;
    _106 = 0;
    _107++;
    if (_107 < _101)
    goto _jump162;
    // End body of loop
    _95 += _98;
    _97++;
    if (_97 < _96)
    goto _jump156;
    // End body of loop
    bool _108 = _0 != _0;
    bool _109;
    if (!_108)
    goto _jump163;
    bool _110 = !_0;
    _109 = _110;
    goto _jump164;
    _jump163:;
    _109 = _0;
    _jump164:;
    int64_t _111;
    if (!_109)
    goto _jump165;
    int64_t _112 = 158;
    _111 = _112;
    goto _jump166;
    _jump165:;
    int64_t _113 = 695;
    _111 = _113;
    _jump166:;
    bool _114 = _0;
    if (0 != _0)
    goto _jump167;
    bool _115 = true;
    _114 = _115;
    _jump167:;
    bool _116 = true;
    bool _117 = !_116;
    bool _118 = _114 == _117;
    int64_t _119;
    if (!_118)
    goto _jump168;
    bool _120 = false;
    int64_t _121;
    if (!_120)
    goto _jump169;
    int64_t _122 = 879;
    _121 = _122;
    goto _jump170;
    _jump169:;
    int64_t _123 = 592;
    _121 = _123;
    _jump170:;
    int64_t _124 = -_121;
    _119 = _124;
    goto _jump171;
    _jump168:;
    int64_t _125 = 711;
    _119 = _125;
    _jump171:;
    int64_t _126 = _111 * _119;
    if (_95 >= 0)
    goto _jump172;
    fail_assertion("negative array index");
    _jump172:;
    if (_95 < _76.d0)
    goto _jump173;
    fail_assertion("index too large");
    _jump173:;
    if (_126 >= 0)
    goto _jump174;
    fail_assertion("negative array index");
    _jump174:;
    if (_126 < _76.d1)
    goto _jump175;
    fail_assertion("index too large");
    _jump175:;
    int64_t _127 = 0;
    _127 *= _76.d0;
    _127 += _95;
    _127 *= _76.d1;
    _127 += _126;
    _a2_int64_t _128 = _76.data[_127];
    _1 = _128;
    _jump145:;
    int64_t _129 = 795;
    rgba _130 = a();
    double _131 = _130.a;
    rgba _132 = a();
    double _133 = _132.a;
    bool _134 = _131 == _133;
    _a1_int64_t _135;
    if (!_134)
    goto _jump176;
    _a1_int64_t _136;
    // Computing bound for c
    int64_t _137 = 255;
    _136.d0 = _137;
    if (_137 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= _137;
    _138 *= sizeof(int64_t);
    _136.data = jpl_alloc(_138);
    int64_t _139 = 0; // c
    _jump178:; // Begin body of loop
    int64_t _140 = -_139;
    int64_t _141 = 0;
    _141 *= _136.d0;
    _141 += _139;
    _136.data[_141] = _140;
    _139++;
    if (_139 < _137)
    goto _jump178;
    // End body of loop
    _a1__a1_int64_t _142;
    _142.d0 = 1;
    _142.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _142.data[0] = _136;
    int64_t _143 = 79;
    if (_143 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_143 < _142.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    int64_t _144 = 0;
    _144 *= _142.d0;
    _144 += _143;
    _a1_int64_t _145 = _142.data[_144];
    _135 = _145;
    goto _jump181;
    _jump176:;
    _a1_int64_t _146;
    if (!_0)
    goto _jump182;
    int64_t _147 = 138;
    int64_t _148 = 975;
    int64_t _149 = -_148;
    bool _150 = _147 == _149;
    _a1_int64_t _151;
    if (!_150)
    goto _jump183;
    int64_t _152 = 206;
    int64_t _153 = 362;
    _a1_int64_t _154;
    _154.d0 = 2;
    _154.data = jpl_alloc(sizeof(int64_t) * 2);
    _154.data[0] = _152;
    _154.data[1] = _153;
    _151 = _154;
    goto _jump184;
    _jump183:;
    _a1_int64_t _155;
    // Computing bound for c
    int64_t _156 = 328;
    _155.d0 = _156;
    if (_156 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= _156;
    _157 *= sizeof(int64_t);
    _155.data = jpl_alloc(_157);
    int64_t _158 = 0; // c
    _jump186:; // Begin body of loop
    int64_t _159 = 0;
    _159 *= _155.d0;
    _159 += _158;
    _155.data[_159] = _158;
    _158++;
    if (_158 < _156)
    goto _jump186;
    // End body of loop
    _151 = _155;
    _jump184:;
    _146 = _151;
    goto _jump187;
    _jump182:;
    _a1_int64_t _160;
    // Computing bound for c
    int64_t _161 = 258;
    _160.d0 = _161;
    if (_161 > 0) 
    goto _jump188;
    fail_assertion("non-positive loop bound");
    _jump188:;
    // Computing total size of heap memory to allocate
    int64_t _162 = 1;
    _162 *= _161;
    _162 *= sizeof(int64_t);
    _160.data = jpl_alloc(_162);
    int64_t _163 = 0; // c
    _jump189:; // Begin body of loop
    int64_t _164 = 938;
    int64_t _165 = -_164;
    int64_t _166 = 0;
    _166 *= _160.d0;
    _166 += _163;
    _160.data[_166] = _165;
    _163++;
    if (_163 < _161)
    goto _jump189;
    // End body of loop
    _146 = _160;
    _jump187:;
    _135 = _146;
    _jump181:;
    _a2_int64_t _167;
    // Computing bound for c
    int64_t _168 = 779;
    int64_t _169 = 290;
    int64_t _170 = _168 / _169;
    _167.d0 = _170;
    if (_170 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing bound for d
    int64_t _171 = 294;
    _167.d1 = _171;
    if (_171 > 0) 
    goto _jump191;
    fail_assertion("non-positive loop bound");
    _jump191:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= _170;
    _172 *= _171;
    _172 *= sizeof(int64_t);
    _167.data = jpl_alloc(_172);
    int64_t _173 = 0; // d
    int64_t _174 = 0; // c
    _jump192:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _167.d0;
    _175 += _174;
    _175 *= _167.d1;
    _175 += _173;
    _167.data[_175] = _174;
    _173++;
    if (_173 < _171)
    goto _jump192;
    _173 = 0;
    _174++;
    if (_174 < _170)
    goto _jump192;
    // End body of loop
    int64_t _176 = 254;
    int64_t _177;
    // Computing bound for c
    int64_t _178;
    // Computing bound for c
    int64_t _179 = 736;
    if (_179 > 0) 
    goto _jump193;
    fail_assertion("non-positive loop bound");
    _jump193:;
    // Computing bound for d
    int64_t _180 = 535;
    if (_180 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for e
    int64_t _181 = 506;
    if (_181 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    _178 = 0;
    int64_t _182 = 0; // e
    int64_t _183 = 0; // d
    int64_t _184 = 0; // c
    _jump196:; // Begin body of loop
    _178 += _182;
    _182++;
    if (_182 < _181)
    goto _jump196;
    _182 = 0;
    _183++;
    if (_183 < _180)
    goto _jump196;
    _183 = 0;
    _184++;
    if (_184 < _179)
    goto _jump196;
    // End body of loop
    if (_178 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing bound for d
    int64_t _185 = 154;
    if (_185 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    _177 = 0;
    int64_t _186 = 0; // d
    int64_t _187 = 0; // c
    _jump199:; // Begin body of loop
    int64_t _188 = 169;
    int64_t _189 = -_188;
    _177 += _189;
    _186++;
    if (_186 < _185)
    goto _jump199;
    _186 = 0;
    _187++;
    if (_187 < _178)
    goto _jump199;
    // End body of loop
    if (_176 >= 0)
    goto _jump200;
    fail_assertion("negative array index");
    _jump200:;
    if (_176 < _167.d0)
    goto _jump201;
    fail_assertion("index too large");
    _jump201:;
    if (_177 >= 0)
    goto _jump202;
    fail_assertion("negative array index");
    _jump202:;
    if (_177 < _167.d1)
    goto _jump203;
    fail_assertion("index too large");
    _jump203:;
    int64_t _190 = 0;
    _190 *= _167.d0;
    _190 += _176;
    _190 *= _167.d1;
    _190 += _177;
    int64_t _191 = _167.data[_190];
    bool _193 = true;
    bool _192 = _193;
    if (0 != _193)
    goto _jump204;
    bool _194 = false;
    _192 = _194;
    _jump204:;
    int64_t _195;
    if (!_192)
    goto _jump205;
    bool _196 = true;
    int64_t _197;
    if (!_196)
    goto _jump206;
    int64_t _198 = 149;
    _197 = _198;
    goto _jump207;
    _jump206:;
    int64_t _199 = 210;
    _197 = _199;
    _jump207:;
    _195 = _197;
    goto _jump208;
    _jump205:;
    int64_t _200 = 883;
    _195 = _200;
    _jump208:;
    int64_t _201 = -_195;
    int64_t _202 = _191 - _201;
    _a1_int64_t _203;
    // Computing bound for c
    int64_t _204 = 871;
    _203.d0 = _204;
    if (_204 > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _204;
    _205 *= sizeof(int64_t);
    _203.data = jpl_alloc(_205);
    int64_t _206 = 0; // c
    _jump210:; // Begin body of loop
    int64_t _207 = 415;
    int64_t _208 = _206 * _207;
    int64_t _209 = 0;
    _209 *= _203.d0;
    _209 += _206;
    _203.data[_209] = _208;
    _206++;
    if (_206 < _204)
    goto _jump210;
    // End body of loop
    int64_t _210 = 918;
    if (_210 >= 0)
    goto _jump211;
    fail_assertion("negative array index");
    _jump211:;
    if (_210 < _203.d0)
    goto _jump212;
    fail_assertion("index too large");
    _jump212:;
    int64_t _211 = 0;
    _211 *= _203.d0;
    _211 += _210;
    int64_t _212 = _203.data[_211];
    int64_t _213 = -_212;
    int64_t _214 = _202 + _213;
    if (_214 >= 0)
    goto _jump213;
    fail_assertion("negative array index");
    _jump213:;
    if (_214 < _135.d0)
    goto _jump214;
    fail_assertion("index too large");
    _jump214:;
    int64_t _215 = 0;
    _215 *= _135.d0;
    _215 += _214;
    int64_t _216 = _135.data[_215];
    if (_129 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (_129 < _1.d0)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    if (_216 >= 0)
    goto _jump217;
    fail_assertion("negative array index");
    _jump217:;
    if (_216 < _1.d1)
    goto _jump218;
    fail_assertion("index too large");
    _jump218:;
    int64_t _217 = 0;
    _217 *= _1.d0;
    _217 += _129;
    _217 *= _1.d1;
    _217 += _216;
    int64_t _218 = _1.data[_217];
    _a3__a2_double _219;
    // Computing bound for d
    int64_t _220 = 950;
    _219.d0 = _220;
    if (_220 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing bound for e
    int64_t _221 = 229;
    _219.d1 = _221;
    if (_221 > 0) 
    goto _jump220;
    fail_assertion("non-positive loop bound");
    _jump220:;
    // Computing bound for f
    int64_t _222;
    // Computing bound for d
    int64_t _223;
    // Computing bound for d
    _a1_int64_t _224;
    // Computing bound for d
    int64_t _225 = 451;
    _224.d0 = _225;
    if (_225 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing total size of heap memory to allocate
    int64_t _226 = 1;
    _226 *= _225;
    _226 *= sizeof(int64_t);
    _224.data = jpl_alloc(_226);
    int64_t _227 = 0; // d
    _jump222:; // Begin body of loop
    int64_t _228 = 532;
    int64_t _229 = 0;
    _229 *= _224.d0;
    _229 += _227;
    _224.data[_229] = _228;
    _227++;
    if (_227 < _225)
    goto _jump222;
    // End body of loop
    int64_t _230;
    // Computing bound for d
    int64_t _231 = 159;
    int64_t _232 = _218 / _231;
    if (_232 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing bound for e
    int64_t _233 = 480;
    int64_t _234 = -_233;
    if (_234 > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    // Computing bound for f
    if (_218 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    _230 = 0;
    int64_t _235 = 0; // f
    int64_t _236 = 0; // e
    int64_t _237 = 0; // d
    _jump226:; // Begin body of loop
    _230 += _235;
    _235++;
    if (_235 < _218)
    goto _jump226;
    _235 = 0;
    _236++;
    if (_236 < _234)
    goto _jump226;
    _236 = 0;
    _237++;
    if (_237 < _232)
    goto _jump226;
    // End body of loop
    if (_230 >= 0)
    goto _jump227;
    fail_assertion("negative array index");
    _jump227:;
    if (_230 < _224.d0)
    goto _jump228;
    fail_assertion("index too large");
    _jump228:;
    int64_t _238 = 0;
    _238 *= _224.d0;
    _238 += _230;
    int64_t _239 = _224.data[_238];
    if (_239 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for e
    if (_218 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    _223 = 0;
    int64_t _240 = 0; // e
    int64_t _241 = 0; // d
    _jump231:; // Begin body of loop
    int64_t _242;
    // Computing bound for f
    int64_t _243;
    // Computing bound for f
    if (_240 > 0) 
    goto _jump232;
    fail_assertion("non-positive loop bound");
    _jump232:;
    _243 = 0;
    int64_t _244 = 0; // f
    _jump233:; // Begin body of loop
    _243 += _240;
    _244++;
    if (_244 < _240)
    goto _jump233;
    // End body of loop
    if (_243 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing bound for g
    int64_t _245 = 148;
    if (_245 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    _242 = 0;
    int64_t _246 = 0; // g
    int64_t _247 = 0; // f
    _jump236:; // Begin body of loop
    int64_t _248;
    // Computing bound for h
    if (_241 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing bound for i
    int64_t _249;
    // Computing bound for h
    if (_247 > 0) 
    goto _jump238;
    fail_assertion("non-positive loop bound");
    _jump238:;
    _249 = 0;
    int64_t _250 = 0; // h
    _jump239:; // Begin body of loop
    int64_t _251 = 530;
    _249 += _251;
    _250++;
    if (_250 < _247)
    goto _jump239;
    // End body of loop
    if (_249 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    _248 = 0;
    int64_t _252 = 0; // i
    int64_t _253 = 0; // h
    _jump241:; // Begin body of loop
    _248 += _247;
    _252++;
    if (_252 < _249)
    goto _jump241;
    _252 = 0;
    _253++;
    if (_253 < _241)
    goto _jump241;
    // End body of loop
    _242 += _248;
    _246++;
    if (_246 < _245)
    goto _jump236;
    _246 = 0;
    _247++;
    if (_247 < _243)
    goto _jump236;
    // End body of loop
    _223 += _242;
    _240++;
    if (_240 < _218)
    goto _jump231;
    _240 = 0;
    _241++;
    if (_241 < _239)
    goto _jump231;
    // End body of loop
    if (_223 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for e
    _a3_int64_t _254;
    // Computing bound for d
    int64_t _255 = 733;
    int64_t _256 = _218 % _255;
    int64_t _257 = -_256;
    _254.d0 = _257;
    if (_257 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    // Computing bound for e
    int64_t _258 = -_218;
    _254.d1 = _258;
    if (_258 > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing bound for f
    int64_t _259 = 656;
    int64_t _260 = 973;
    int64_t _261 = -_260;
    int64_t _262 = _259 - _261;
    _254.d2 = _262;
    if (_262 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _257;
    _263 *= _258;
    _263 *= _262;
    _263 *= sizeof(int64_t);
    _254.data = jpl_alloc(_263);
    int64_t _264 = 0; // f
    int64_t _265 = 0; // e
    int64_t _266 = 0; // d
    _jump246:; // Begin body of loop
    int64_t _267 = 0;
    _267 *= _254.d0;
    _267 += _266;
    _267 *= _254.d1;
    _267 += _265;
    _267 *= _254.d2;
    _267 += _264;
    _254.data[_267] = _218;
    _264++;
    if (_264 < _262)
    goto _jump246;
    _264 = 0;
    _265++;
    if (_265 < _258)
    goto _jump246;
    _265 = 0;
    _266++;
    if (_266 < _257)
    goto _jump246;
    // End body of loop
    int64_t _268 = 5;
    bool _269 = true;
    double _270;
    if (!_269)
    goto _jump247;
    double _271 = 9.0;
    _270 = _271;
    goto _jump248;
    _jump247:;
    double _272 = 10.0;
    _270 = _272;
    _jump248:;
    double _273 = 16.0;
    double _274 = 78.0;
    double _275 = _273 - _274;
    bool _276 = _270 >= _275;
    int64_t _277;
    if (!_276)
    goto _jump249;
    int64_t _278;
    if (!_0)
    goto _jump250;
    int64_t _279 = 758;
    _278 = _279;
    goto _jump251;
    _jump250:;
    _278 = _218;
    _jump251:;
    _277 = _278;
    goto _jump252;
    _jump249:;
    int64_t _280;
    if (!_0)
    goto _jump253;
    int64_t _281;
    // Computing bound for d
    int64_t _282 = 76;
    if (_282 > 0) 
    goto _jump254;
    fail_assertion("non-positive loop bound");
    _jump254:;
    // Computing bound for e
    int64_t _283 = 507;
    if (_283 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    _281 = 0;
    int64_t _284 = 0; // e
    int64_t _285 = 0; // d
    _jump256:; // Begin body of loop
    _281 += _285;
    _284++;
    if (_284 < _283)
    goto _jump256;
    _284 = 0;
    _285++;
    if (_285 < _282)
    goto _jump256;
    // End body of loop
    _280 = _281;
    goto _jump257;
    _jump253:;
    int64_t _286 = -_218;
    _280 = _286;
    _jump257:;
    _277 = _280;
    _jump252:;
    if (_218 >= 0)
    goto _jump258;
    fail_assertion("negative array index");
    _jump258:;
    if (_218 < _254.d0)
    goto _jump259;
    fail_assertion("index too large");
    _jump259:;
    if (_268 >= 0)
    goto _jump260;
    fail_assertion("negative array index");
    _jump260:;
    if (_268 < _254.d1)
    goto _jump261;
    fail_assertion("index too large");
    _jump261:;
    if (_277 >= 0)
    goto _jump262;
    fail_assertion("negative array index");
    _jump262:;
    if (_277 < _254.d2)
    goto _jump263;
    fail_assertion("index too large");
    _jump263:;
    int64_t _287 = 0;
    _287 *= _254.d0;
    _287 += _218;
    _287 *= _254.d1;
    _287 += _268;
    _287 *= _254.d2;
    _287 += _277;
    int64_t _288 = _254.data[_287];
    if (_288 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    // Computing bound for f
    int64_t _289 = 923;
    if (_289 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    _222 = 0;
    int64_t _290 = 0; // f
    int64_t _291 = 0; // e
    int64_t _292 = 0; // d
    _jump266:; // Begin body of loop
    _222 += _291;
    _290++;
    if (_290 < _289)
    goto _jump266;
    _290 = 0;
    _291++;
    if (_291 < _288)
    goto _jump266;
    _291 = 0;
    _292++;
    if (_292 < _223)
    goto _jump266;
    // End body of loop
    _219.d2 = _222;
    if (_222 > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    // Computing total size of heap memory to allocate
    int64_t _293 = 1;
    _293 *= _220;
    _293 *= _221;
    _293 *= _222;
    _293 *= sizeof(_a2_double);
    _219.data = jpl_alloc(_293);
    int64_t _294 = 0; // f
    int64_t _295 = 0; // e
    int64_t _296 = 0; // d
    _jump268:; // Begin body of loop
    _a2_double _297;
    // Computing bound for g
    _297.d0 = _294;
    if (_294 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    // Computing bound for h
    _a3_int64_t _298;
    // Computing bound for g
    _298.d0 = _295;
    if (_295 > 0) 
    goto _jump270;
    fail_assertion("non-positive loop bound");
    _jump270:;
    // Computing bound for h
    int64_t _299;
    // Computing bound for g
    int64_t _300;
    // Computing bound for g
    if (_294 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for h
    if (_294 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    _300 = 0;
    int64_t _301 = 0; // h
    int64_t _302 = 0; // g
    _jump273:; // Begin body of loop
    _300 += _296;
    _301++;
    if (_301 < _294)
    goto _jump273;
    _301 = 0;
    _302++;
    if (_302 < _294)
    goto _jump273;
    // End body of loop
    if (_300 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing bound for h
    if (_296 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    _299 = 0;
    int64_t _303 = 0; // h
    int64_t _304 = 0; // g
    _jump276:; // Begin body of loop
    _299 += _304;
    _303++;
    if (_303 < _296)
    goto _jump276;
    _303 = 0;
    _304++;
    if (_304 < _300)
    goto _jump276;
    // End body of loop
    _298.d1 = _299;
    if (_299 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for i
    int64_t _305 = 929;
    bool _306 = _294 > _305;
    int64_t _307;
    if (!_306)
    goto _jump278;
    int64_t _308;
    // Computing bound for g
    int64_t _309 = 854;
    if (_309 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing bound for h
    if (_295 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    // Computing bound for i
    int64_t _310 = 34;
    if (_310 > 0) 
    goto _jump281;
    fail_assertion("non-positive loop bound");
    _jump281:;
    _308 = 0;
    int64_t _311 = 0; // i
    int64_t _312 = 0; // h
    int64_t _313 = 0; // g
    _jump282:; // Begin body of loop
    _308 += _294;
    _311++;
    if (_311 < _310)
    goto _jump282;
    _311 = 0;
    _312++;
    if (_312 < _295)
    goto _jump282;
    _312 = 0;
    _313++;
    if (_313 < _309)
    goto _jump282;
    // End body of loop
    _307 = _308;
    goto _jump283;
    _jump278:;
    int64_t _314 = -_296;
    _307 = _314;
    _jump283:;
    _298.d2 = _307;
    if (_307 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    // Computing total size of heap memory to allocate
    int64_t _315 = 1;
    _315 *= _295;
    _315 *= _299;
    _315 *= _307;
    _315 *= sizeof(int64_t);
    _298.data = jpl_alloc(_315);
    int64_t _316 = 0; // i
    int64_t _317 = 0; // h
    int64_t _318 = 0; // g
    _jump285:; // Begin body of loop
    int64_t _319 = _316 + _317;
    int64_t _320 = 0;
    _320 *= _298.d0;
    _320 += _318;
    _320 *= _298.d1;
    _320 += _317;
    _320 *= _298.d2;
    _320 += _316;
    _298.data[_320] = _319;
    _316++;
    if (_316 < _307)
    goto _jump285;
    _316 = 0;
    _317++;
    if (_317 < _299)
    goto _jump285;
    _317 = 0;
    _318++;
    if (_318 < _295)
    goto _jump285;
    // End body of loop
    if (_295 >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (_295 < _298.d0)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    if (_296 >= 0)
    goto _jump288;
    fail_assertion("negative array index");
    _jump288:;
    if (_296 < _298.d1)
    goto _jump289;
    fail_assertion("index too large");
    _jump289:;
    if (_295 >= 0)
    goto _jump290;
    fail_assertion("negative array index");
    _jump290:;
    if (_295 < _298.d2)
    goto _jump291;
    fail_assertion("index too large");
    _jump291:;
    int64_t _321 = 0;
    _321 *= _298.d0;
    _321 += _295;
    _321 *= _298.d1;
    _321 += _296;
    _321 *= _298.d2;
    _321 += _295;
    int64_t _322 = _298.data[_321];
    _297.d1 = _322;
    if (_322 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= _294;
    _323 *= _322;
    _323 *= sizeof(double);
    _297.data = jpl_alloc(_323);
    int64_t _324 = 0; // h
    int64_t _325 = 0; // g
    _jump293:; // Begin body of loop
    rgba _326 = a();
    double _327 = _326.a;
    int64_t _328 = 0;
    _328 *= _297.d0;
    _328 += _325;
    _328 *= _297.d1;
    _328 += _324;
    _297.data[_328] = _327;
    _324++;
    if (_324 < _322)
    goto _jump293;
    _324 = 0;
    _325++;
    if (_325 < _294)
    goto _jump293;
    // End body of loop
    int64_t _329 = 0;
    _329 *= _219.d0;
    _329 += _296;
    _329 *= _219.d1;
    _329 += _295;
    _329 *= _219.d2;
    _329 += _294;
    _219.data[_329] = _297;
    _294++;
    if (_294 < _222)
    goto _jump268;
    _294 = 0;
    _295++;
    if (_295 < _221)
    goto _jump268;
    _295 = 0;
    _296++;
    if (_296 < _220)
    goto _jump268;
    // End body of loop
    bool _331 = _0;
    if (0 != _0)
    goto _jump294;
    double _333 = 77.0;
    double _334 = 89.0;
    bool _335 = _333 != _334;
    bool _332 = _335;
    if (0 == _335)
    goto _jump295;
    bool _336 = _0;
    if (0 == _0)
    goto _jump296;
    bool _337 = true;
    _336 = _337;
    _jump296:;
    _332 = _336;
    _jump295:;
    _331 = _332;
    _jump294:;
    bool _330 = _331;
    if (0 == _331)
    goto _jump297;
    rgba _338 = a();
    double _339 = _338.r;
    double _340;
    if (!_0)
    goto _jump298;
    rgba _341 = a();
    double _342 = _341.a;
    _340 = _342;
    goto _jump299;
    _jump298:;
    double _343;
    // Computing bound for d
    int64_t _344 = 840;
    if (_344 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    _343 = 0;
    int64_t _345 = 0; // d
    _jump301:; // Begin body of loop
    double _346 = 91.0;
    _343 += _346;
    _345++;
    if (_345 < _344)
    goto _jump301;
    // End body of loop
    _340 = _343;
    _jump299:;
    bool _347 = _339 < _340;
    bool _348 = !_347;
    _330 = _348;
    _jump297:;
    int64_t _349;
    if (!_330)
    goto _jump302;
    int64_t _350;
    if (!_0)
    goto _jump303;
    bool _352 = _0;
    if (0 != _0)
    goto _jump304;
    _352 = _0;
    _jump304:;
    bool _351 = _352;
    if (0 != _352)
    goto _jump305;
    bool _353 = true;
    _351 = _353;
    _jump305:;
    int64_t _354;
    if (!_351)
    goto _jump306;
    int64_t _355 = -_218;
    _354 = _355;
    goto _jump307;
    _jump306:;
    _354 = _218;
    _jump307:;
    _350 = _354;
    goto _jump308;
    _jump303:;
    _350 = _218;
    _jump308:;
    int64_t _356 = _350 / _218;
    _349 = _356;
    goto _jump309;
    _jump302:;
    int64_t _357 = 893;
    int64_t _358;
    // Computing bound for d
    int64_t _359;
    // Computing bound for d
    if (_218 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    _359 = 0;
    int64_t _360 = 0; // d
    _jump311:; // Begin body of loop
    _359 += _218;
    _360++;
    if (_360 < _218)
    goto _jump311;
    // End body of loop
    int64_t _361 = -_359;
    if (_361 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for e
    int64_t _362;
    // Computing bound for d
    int64_t _363 = 608;
    if (_363 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    _362 = 0;
    int64_t _364 = 0; // d
    _jump314:; // Begin body of loop
    _362 += _364;
    _364++;
    if (_364 < _363)
    goto _jump314;
    // End body of loop
    int64_t _365 = _362 - _218;
    bool _366 = !_0;
    int64_t _367;
    if (!_366)
    goto _jump315;
    int64_t _368;
    if (!_0)
    goto _jump316;
    int64_t _369 = 688;
    _368 = _369;
    goto _jump317;
    _jump316:;
    int64_t _370 = 304;
    _368 = _370;
    _jump317:;
    _367 = _368;
    goto _jump318;
    _jump315:;
    int64_t _371 = 15;
    _367 = _371;
    _jump318:;
    int64_t _372 = _365 + _367;
    if (_372 > 0) 
    goto _jump319;
    fail_assertion("non-positive loop bound");
    _jump319:;
    // Computing bound for f
    int64_t _373;
    if (!_0)
    goto _jump320;
    int64_t _374 = 478;
    _373 = _374;
    goto _jump321;
    _jump320:;
    _373 = _218;
    _jump321:;
    int64_t _375 = _218 - _373;
    if (_375 > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    _358 = 0;
    int64_t _376 = 0; // f
    int64_t _377 = 0; // e
    int64_t _378 = 0; // d
    _jump323:; // Begin body of loop
    _358 += _376;
    _376++;
    if (_376 < _375)
    goto _jump323;
    _376 = 0;
    _377++;
    if (_377 < _372)
    goto _jump323;
    _377 = 0;
    _378++;
    if (_378 < _361)
    goto _jump323;
    // End body of loop
    int64_t _379 = _357 * _358;
    _349 = _379;
    _jump309:;
    int64_t _380;
    // Computing bound for d
    int64_t _381 = 364;
    if (_381 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    _380 = 0;
    int64_t _382 = 0; // d
    _jump325:; // Begin body of loop
    _a1_int64_t _383;
    // Computing bound for e
    _a1_int64_t _384;
    // Computing bound for e
    int64_t _385 = 129;
    _384.d0 = _385;
    if (_385 > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing total size of heap memory to allocate
    int64_t _386 = 1;
    _386 *= _385;
    _386 *= sizeof(int64_t);
    _384.data = jpl_alloc(_386);
    int64_t _387 = 0; // e
    _jump327:; // Begin body of loop
    int64_t _388 = -_382;
    int64_t _389 = 0;
    _389 *= _384.d0;
    _389 += _387;
    _384.data[_389] = _388;
    _387++;
    if (_387 < _385)
    goto _jump327;
    // End body of loop
    int64_t _390 = 301;
    if (_390 >= 0)
    goto _jump328;
    fail_assertion("negative array index");
    _jump328:;
    if (_390 < _384.d0)
    goto _jump329;
    fail_assertion("index too large");
    _jump329:;
    int64_t _391 = 0;
    _391 *= _384.d0;
    _391 += _390;
    int64_t _392 = _384.data[_391];
    _383.d0 = _392;
    if (_392 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing total size of heap memory to allocate
    int64_t _393 = 1;
    _393 *= _392;
    _393 *= sizeof(int64_t);
    _383.data = jpl_alloc(_393);
    int64_t _394 = 0; // e
    _jump331:; // Begin body of loop
    int64_t _395 = 0;
    _395 *= _383.d0;
    _395 += _394;
    _383.data[_395] = _394;
    _394++;
    if (_394 < _392)
    goto _jump331;
    // End body of loop
    bool _396;
    if (!_0)
    goto _jump332;
    bool _397 = !_0;
    _396 = _397;
    goto _jump333;
    _jump332:;
    bool _398 = false;
    _396 = _398;
    _jump333:;
    _a3_int64_t _399;
    if (!_396)
    goto _jump334;
    bool _400 = true;
    _a3_int64_t _401;
    if (!_400)
    goto _jump335;
    _a3_int64_t _402;
    // Computing bound for e
    _402.d0 = _382;
    if (_382 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    // Computing bound for f
    _402.d1 = _218;
    if (_218 > 0) 
    goto _jump337;
    fail_assertion("non-positive loop bound");
    _jump337:;
    // Computing bound for g
    int64_t _403 = 206;
    _402.d2 = _403;
    if (_403 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing total size of heap memory to allocate
    int64_t _404 = 1;
    _404 *= _382;
    _404 *= _218;
    _404 *= _403;
    _404 *= sizeof(int64_t);
    _402.data = jpl_alloc(_404);
    int64_t _405 = 0; // g
    int64_t _406 = 0; // f
    int64_t _407 = 0; // e
    _jump339:; // Begin body of loop
    int64_t _408 = 0;
    _408 *= _402.d0;
    _408 += _407;
    _408 *= _402.d1;
    _408 += _406;
    _408 *= _402.d2;
    _408 += _405;
    _402.data[_408] = _405;
    _405++;
    if (_405 < _403)
    goto _jump339;
    _405 = 0;
    _406++;
    if (_406 < _218)
    goto _jump339;
    _406 = 0;
    _407++;
    if (_407 < _382)
    goto _jump339;
    // End body of loop
    _401 = _402;
    goto _jump340;
    _jump335:;
    _a3_int64_t _409;
    // Computing bound for e
    _409.d0 = _218;
    if (_218 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    // Computing bound for f
    _409.d1 = _218;
    if (_218 > 0) 
    goto _jump342;
    fail_assertion("non-positive loop bound");
    _jump342:;
    // Computing bound for g
    _409.d2 = _218;
    if (_218 > 0) 
    goto _jump343;
    fail_assertion("non-positive loop bound");
    _jump343:;
    // Computing total size of heap memory to allocate
    int64_t _410 = 1;
    _410 *= _218;
    _410 *= _218;
    _410 *= _218;
    _410 *= sizeof(int64_t);
    _409.data = jpl_alloc(_410);
    int64_t _411 = 0; // g
    int64_t _412 = 0; // f
    int64_t _413 = 0; // e
    _jump344:; // Begin body of loop
    int64_t _414 = 142;
    int64_t _415 = 0;
    _415 *= _409.d0;
    _415 += _413;
    _415 *= _409.d1;
    _415 += _412;
    _415 *= _409.d2;
    _415 += _411;
    _409.data[_415] = _414;
    _411++;
    if (_411 < _218)
    goto _jump344;
    _411 = 0;
    _412++;
    if (_412 < _218)
    goto _jump344;
    _412 = 0;
    _413++;
    if (_413 < _218)
    goto _jump344;
    // End body of loop
    _401 = _409;
    _jump340:;
    _399 = _401;
    goto _jump345;
    _jump334:;
    _a3_int64_t _416;
    // Computing bound for e
    _416.d0 = _218;
    if (_218 > 0) 
    goto _jump346;
    fail_assertion("non-positive loop bound");
    _jump346:;
    // Computing bound for f
    int64_t _417;
    // Computing bound for e
    if (_382 > 0) 
    goto _jump347;
    fail_assertion("non-positive loop bound");
    _jump347:;
    // Computing bound for f
    if (_218 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    _417 = 0;
    int64_t _418 = 0; // f
    int64_t _419 = 0; // e
    _jump349:; // Begin body of loop
    _417 += _419;
    _418++;
    if (_418 < _218)
    goto _jump349;
    _418 = 0;
    _419++;
    if (_419 < _382)
    goto _jump349;
    // End body of loop
    _416.d1 = _417;
    if (_417 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for g
    _416.d2 = _382;
    if (_382 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing total size of heap memory to allocate
    int64_t _420 = 1;
    _420 *= _218;
    _420 *= _417;
    _420 *= _382;
    _420 *= sizeof(int64_t);
    _416.data = jpl_alloc(_420);
    int64_t _421 = 0; // g
    int64_t _422 = 0; // f
    int64_t _423 = 0; // e
    _jump352:; // Begin body of loop
    int64_t _424 = 237;
    int64_t _425 = -_424;
    int64_t _426 = 0;
    _426 *= _416.d0;
    _426 += _423;
    _426 *= _416.d1;
    _426 += _422;
    _426 *= _416.d2;
    _426 += _421;
    _416.data[_426] = _425;
    _421++;
    if (_421 < _382)
    goto _jump352;
    _421 = 0;
    _422++;
    if (_422 < _417)
    goto _jump352;
    _422 = 0;
    _423++;
    if (_423 < _218)
    goto _jump352;
    // End body of loop
    _399 = _416;
    _jump345:;
    int64_t _427 = -_218;
    int64_t _428 = 119;
    int64_t _429 = -_428;
    if (_427 >= 0)
    goto _jump353;
    fail_assertion("negative array index");
    _jump353:;
    if (_427 < _399.d0)
    goto _jump354;
    fail_assertion("index too large");
    _jump354:;
    if (_218 >= 0)
    goto _jump355;
    fail_assertion("negative array index");
    _jump355:;
    if (_218 < _399.d1)
    goto _jump356;
    fail_assertion("index too large");
    _jump356:;
    if (_429 >= 0)
    goto _jump357;
    fail_assertion("negative array index");
    _jump357:;
    if (_429 < _399.d2)
    goto _jump358;
    fail_assertion("index too large");
    _jump358:;
    int64_t _430 = 0;
    _430 *= _399.d0;
    _430 += _427;
    _430 *= _399.d1;
    _430 += _218;
    _430 *= _399.d2;
    _430 += _429;
    int64_t _431 = _399.data[_430];
    if (_431 >= 0)
    goto _jump359;
    fail_assertion("negative array index");
    _jump359:;
    if (_431 < _383.d0)
    goto _jump360;
    fail_assertion("index too large");
    _jump360:;
    int64_t _432 = 0;
    _432 *= _383.d0;
    _432 += _431;
    int64_t _433 = _383.data[_432];
    _380 += _433;
    _382++;
    if (_382 < _381)
    goto _jump325;
    // End body of loop
    int64_t _434;
    // Computing bound for d
    int64_t _435;
    // Computing bound for d
    int64_t _436 = -_218;
    if (_436 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    _435 = 0;
    int64_t _437 = 0; // d
    _jump362:; // Begin body of loop
    int64_t _438 = 157;
    _435 += _438;
    _437++;
    if (_437 < _436)
    goto _jump362;
    // End body of loop
    int64_t _439;
    // Computing bound for d
    if (_218 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for e
    int64_t _440;
    // Computing bound for d
    if (_218 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing bound for e
    int64_t _441 = 739;
    if (_441 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    // Computing bound for f
    int64_t _442 = 450;
    if (_442 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    _440 = 0;
    int64_t _443 = 0; // f
    int64_t _444 = 0; // e
    int64_t _445 = 0; // d
    _jump367:; // Begin body of loop
    int64_t _446 = 494;
    _440 += _446;
    _443++;
    if (_443 < _442)
    goto _jump367;
    _443 = 0;
    _444++;
    if (_444 < _441)
    goto _jump367;
    _444 = 0;
    _445++;
    if (_445 < _218)
    goto _jump367;
    // End body of loop
    if (_440 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    _439 = 0;
    int64_t _447 = 0; // e
    int64_t _448 = 0; // d
    _jump369:; // Begin body of loop
    int64_t _449 = _448 % _218;
    _439 += _449;
    _447++;
    if (_447 < _440)
    goto _jump369;
    _447 = 0;
    _448++;
    if (_448 < _218)
    goto _jump369;
    // End body of loop
    int64_t _450 = _435 / _439;
    int64_t _451 = 697;
    int64_t _452;
    // Computing bound for d
    int64_t _453 = 481;
    if (_453 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    // Computing bound for e
    if (_218 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing bound for f
    if (_218 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    _452 = 0;
    int64_t _454 = 0; // f
    int64_t _455 = 0; // e
    int64_t _456 = 0; // d
    _jump373:; // Begin body of loop
    int64_t _457 = 726;
    int64_t _458 = -_457;
    _452 += _458;
    _454++;
    if (_454 < _218)
    goto _jump373;
    _454 = 0;
    _455++;
    if (_455 < _218)
    goto _jump373;
    _455 = 0;
    _456++;
    if (_456 < _453)
    goto _jump373;
    // End body of loop
    int64_t _459 = _451 % _452;
    bool _460 = _450 >= _459;
    int64_t _461;
    if (!_460)
    goto _jump374;
    _461 = _218;
    goto _jump375;
    _jump374:;
    int64_t _462 = 994;
    _461 = _462;
    _jump375:;
    if (_461 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing bound for e
    int64_t _463;
    // Computing bound for d
    int64_t _464 = 280;
    if (_464 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    // Computing bound for e
    int64_t _465;
    if (!_0)
    goto _jump378;
    int64_t _466 = 555;
    int64_t _467 = -_466;
    _465 = _467;
    goto _jump379;
    _jump378:;
    int64_t _468 = 738;
    _465 = _468;
    _jump379:;
    int64_t _469 = 844;
    int64_t _470 = _469 / _218;
    int64_t _471 = _465 + _470;
    int64_t _472;
    // Computing bound for d
    int64_t _473 = 529;
    int64_t _474 = -_473;
    if (_474 > 0) 
    goto _jump380;
    fail_assertion("non-positive loop bound");
    _jump380:;
    // Computing bound for e
    int64_t _475 = 198;
    int64_t _476 = -_475;
    if (_476 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    _472 = 0;
    int64_t _477 = 0; // e
    int64_t _478 = 0; // d
    _jump382:; // Begin body of loop
    int64_t _479;
    if (!_0)
    goto _jump383;
    _479 = _477;
    goto _jump384;
    _jump383:;
    int64_t _480 = 226;
    _479 = _480;
    _jump384:;
    _472 += _479;
    _477++;
    if (_477 < _476)
    goto _jump382;
    _477 = 0;
    _478++;
    if (_478 < _474)
    goto _jump382;
    // End body of loop
    int64_t _481 = _218 / _472;
    int64_t _482 = _471 * _481;
    if (_482 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing bound for f
    _a2_int64_t _483;
    // Computing bound for d
    _483.d0 = _218;
    if (_218 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing bound for e
    int64_t _484 = 647;
    _483.d1 = _484;
    if (_484 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    // Computing total size of heap memory to allocate
    int64_t _485 = 1;
    _485 *= _218;
    _485 *= _484;
    _485 *= sizeof(int64_t);
    _483.data = jpl_alloc(_485);
    int64_t _486 = 0; // e
    int64_t _487 = 0; // d
    _jump388:; // Begin body of loop
    int64_t _488;
    // Computing bound for f
    int64_t _489 = _218 + _487;
    if (_489 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    _488 = 0;
    int64_t _490 = 0; // f
    _jump390:; // Begin body of loop
    int64_t _491;
    // Computing bound for g
    if (_490 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for h
    if (_487 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    _491 = 0;
    int64_t _492 = 0; // h
    int64_t _493 = 0; // g
    _jump393:; // Begin body of loop
    _491 += _493;
    _492++;
    if (_492 < _487)
    goto _jump393;
    _492 = 0;
    _493++;
    if (_493 < _490)
    goto _jump393;
    // End body of loop
    _488 += _491;
    _490++;
    if (_490 < _489)
    goto _jump390;
    // End body of loop
    int64_t _494 = 0;
    _494 *= _483.d0;
    _494 += _487;
    _494 *= _483.d1;
    _494 += _486;
    _483.data[_494] = _488;
    _486++;
    if (_486 < _484)
    goto _jump388;
    _486 = 0;
    _487++;
    if (_487 < _218)
    goto _jump388;
    // End body of loop
    bool _496 = _218 < _218;
    bool _495 = _496;
    if (0 == _496)
    goto _jump394;
    bool _497 = true;
    _495 = _497;
    _jump394:;
    int64_t _498;
    if (!_495)
    goto _jump395;
    _498 = _218;
    goto _jump396;
    _jump395:;
    int64_t _499 = 404;
    int64_t _500 = _218 * _499;
    int64_t _501 = 168;
    int64_t _502 = _500 / _501;
    _498 = _502;
    _jump396:;
    if (_498 >= 0)
    goto _jump397;
    fail_assertion("negative array index");
    _jump397:;
    if (_498 < _483.d0)
    goto _jump398;
    fail_assertion("index too large");
    _jump398:;
    if (_218 >= 0)
    goto _jump399;
    fail_assertion("negative array index");
    _jump399:;
    if (_218 < _483.d1)
    goto _jump400;
    fail_assertion("index too large");
    _jump400:;
    int64_t _503 = 0;
    _503 *= _483.d0;
    _503 += _498;
    _503 *= _483.d1;
    _503 += _218;
    int64_t _504 = _483.data[_503];
    if (_504 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    _463 = 0;
    int64_t _505 = 0; // f
    int64_t _506 = 0; // e
    int64_t _507 = 0; // d
    _jump402:; // Begin body of loop
    bool _508 = _505 != _218;
    double _509;
    if (!_508)
    goto _jump403;
    double _510 = 58.0;
    double _511 = 17.0;
    double _512 = _510 / _511;
    _509 = _512;
    goto _jump404;
    _jump403:;
    double _513 = 28.0;
    double _514 = 22.0;
    double _515 = _513 + _514;
    _509 = _515;
    _jump404:;
    rgba _516 = a();
    double _517 = _516.r;
    bool _518 = _509 <= _517;
    int64_t _519;
    if (!_518)
    goto _jump405;
    _519 = _505;
    goto _jump406;
    _jump405:;
    _519 = _218;
    _jump406:;
    _463 += _519;
    _505++;
    if (_505 < _504)
    goto _jump402;
    _505 = 0;
    _506++;
    if (_506 < _482)
    goto _jump402;
    _506 = 0;
    _507++;
    if (_507 < _464)
    goto _jump402;
    // End body of loop
    if (_463 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    _434 = 0;
    int64_t _520 = 0; // e
    int64_t _521 = 0; // d
    _jump408:; // Begin body of loop
    _a1_int64_t _522;
    // Computing bound for f
    _522.d0 = _520;
    if (_520 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    // Computing total size of heap memory to allocate
    int64_t _523 = 1;
    _523 *= _520;
    _523 *= sizeof(int64_t);
    _522.data = jpl_alloc(_523);
    int64_t _524 = 0; // f
    _jump410:; // Begin body of loop
    _a2_int64_t _525;
    // Computing bound for g
    int64_t _526 = 279;
    _525.d0 = _526;
    if (_526 > 0) 
    goto _jump411;
    fail_assertion("non-positive loop bound");
    _jump411:;
    // Computing bound for h
    int64_t _527 = _521 / _218;
    _525.d1 = _527;
    if (_527 > 0) 
    goto _jump412;
    fail_assertion("non-positive loop bound");
    _jump412:;
    // Computing total size of heap memory to allocate
    int64_t _528 = 1;
    _528 *= _526;
    _528 *= _527;
    _528 *= sizeof(int64_t);
    _525.data = jpl_alloc(_528);
    int64_t _529 = 0; // h
    int64_t _530 = 0; // g
    _jump413:; // Begin body of loop
    int64_t _531 = 508;
    int64_t _532 = 0;
    _532 *= _525.d0;
    _532 += _530;
    _532 *= _525.d1;
    _532 += _529;
    _525.data[_532] = _531;
    _529++;
    if (_529 < _527)
    goto _jump413;
    _529 = 0;
    _530++;
    if (_530 < _526)
    goto _jump413;
    // End body of loop
    int64_t _533 = 791;
    bool _534 = _533 == _521;
    int64_t _535;
    if (!_534)
    goto _jump414;
    _535 = _218;
    goto _jump415;
    _jump414:;
    _535 = _524;
    _jump415:;
    if (_218 >= 0)
    goto _jump416;
    fail_assertion("negative array index");
    _jump416:;
    if (_218 < _525.d0)
    goto _jump417;
    fail_assertion("index too large");
    _jump417:;
    if (_535 >= 0)
    goto _jump418;
    fail_assertion("negative array index");
    _jump418:;
    if (_535 < _525.d1)
    goto _jump419;
    fail_assertion("index too large");
    _jump419:;
    int64_t _536 = 0;
    _536 *= _525.d0;
    _536 += _218;
    _536 *= _525.d1;
    _536 += _535;
    int64_t _537 = _525.data[_536];
    int64_t _538 = 0;
    _538 *= _522.d0;
    _538 += _524;
    _522.data[_538] = _537;
    _524++;
    if (_524 < _520)
    goto _jump410;
    // End body of loop
    if (_218 >= 0)
    goto _jump420;
    fail_assertion("negative array index");
    _jump420:;
    if (_218 < _522.d0)
    goto _jump421;
    fail_assertion("index too large");
    _jump421:;
    int64_t _539 = 0;
    _539 *= _522.d0;
    _539 += _218;
    int64_t _540 = _522.data[_539];
    _434 += _540;
    _520++;
    if (_520 < _463)
    goto _jump408;
    _520 = 0;
    _521++;
    if (_521 < _461)
    goto _jump408;
    // End body of loop
    if (_349 >= 0)
    goto _jump422;
    fail_assertion("negative array index");
    _jump422:;
    if (_349 < _219.d0)
    goto _jump423;
    fail_assertion("index too large");
    _jump423:;
    if (_380 >= 0)
    goto _jump424;
    fail_assertion("negative array index");
    _jump424:;
    if (_380 < _219.d1)
    goto _jump425;
    fail_assertion("index too large");
    _jump425:;
    if (_434 >= 0)
    goto _jump426;
    fail_assertion("negative array index");
    _jump426:;
    if (_434 < _219.d2)
    goto _jump427;
    fail_assertion("index too large");
    _jump427:;
    int64_t _541 = 0;
    _541 *= _219.d0;
    _541 += _349;
    _541 *= _219.d1;
    _541 += _380;
    _541 *= _219.d2;
    _541 += _434;
    _a2_double _542 = _219.data[_541];
    bool _544 = true;
    bool _543 = _544;
    if (0 != _544)
    goto _jump428;
    int64_t _545 = 501;
    int64_t _546 = 874;
    bool _547 = _545 >= _546;
    bool _548;
    if (!_547)
    goto _jump429;
    bool _549 = _0;
    if (0 != _0)
    goto _jump430;
    _549 = _0;
    _jump430:;
    bool _550 = !_549;
    _548 = _550;
    goto _jump431;
    _jump429:;
    _548 = _0;
    _jump431:;
    _543 = _548;
    _jump428:;
    bool _551 = !_543;
    bool _552 = !_551;
    bool _553 = !_552;
    _a1__a1_int64_t _554;
    if (!_553)
    goto _jump432;
    _a1__a1__a1_int64_t _555;
    if (!_552)
    goto _jump433;
    _a1__a1_int64_t _556;
    // Computing bound for h
    int64_t _557;
    // Computing bound for h
    if (_542.d0 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    _557 = 0;
    int64_t _558 = 0; // h
    _jump435:; // Begin body of loop
    _557 += _218;
    _558++;
    if (_558 < _542.d0)
    goto _jump435;
    // End body of loop
    _556.d0 = _557;
    if (_557 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing total size of heap memory to allocate
    int64_t _559 = 1;
    _559 *= _557;
    _559 *= sizeof(_a1_int64_t);
    _556.data = jpl_alloc(_559);
    int64_t _560 = 0; // h
    _jump437:; // Begin body of loop
    _a1_int64_t _561;
    // Computing bound for i
    int64_t _562 = 781;
    _561.d0 = _562;
    if (_562 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    // Computing total size of heap memory to allocate
    int64_t _563 = 1;
    _563 *= _562;
    _563 *= sizeof(int64_t);
    _561.data = jpl_alloc(_563);
    int64_t _564 = 0; // i
    _jump439:; // Begin body of loop
    int64_t _565 = 0;
    _565 *= _561.d0;
    _565 += _564;
    _561.data[_565] = _560;
    _564++;
    if (_564 < _562)
    goto _jump439;
    // End body of loop
    int64_t _566 = 0;
    _566 *= _556.d0;
    _566 += _560;
    _556.data[_566] = _561;
    _560++;
    if (_560 < _557)
    goto _jump437;
    // End body of loop
    _a1_int64_t _567;
    // Computing bound for h
    int64_t _568 = 187;
    _567.d0 = _568;
    if (_568 > 0) 
    goto _jump440;
    fail_assertion("non-positive loop bound");
    _jump440:;
    // Computing total size of heap memory to allocate
    int64_t _569 = 1;
    _569 *= _568;
    _569 *= sizeof(int64_t);
    _567.data = jpl_alloc(_569);
    int64_t _570 = 0; // h
    _jump441:; // Begin body of loop
    int64_t _571 = 0;
    _571 *= _567.d0;
    _571 += _570;
    _567.data[_571] = _542.d1;
    _570++;
    if (_570 < _568)
    goto _jump441;
    // End body of loop
    _a1_int64_t _572;
    // Computing bound for h
    _572.d0 = _542.d1;
    if (_542.d1 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    // Computing total size of heap memory to allocate
    int64_t _573 = 1;
    _573 *= _542.d1;
    _573 *= sizeof(int64_t);
    _572.data = jpl_alloc(_573);
    int64_t _574 = 0; // h
    _jump443:; // Begin body of loop
    int64_t _575 = 715;
    int64_t _576 = 0;
    _576 *= _572.d0;
    _576 += _574;
    _572.data[_576] = _575;
    _574++;
    if (_574 < _542.d1)
    goto _jump443;
    // End body of loop
    _a1__a1_int64_t _577;
    _577.d0 = 2;
    _577.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _577.data[0] = _567;
    _577.data[1] = _572;
    _a1_int64_t _578;
    // Computing bound for h
    _578.d0 = _542.d1;
    if (_542.d1 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing total size of heap memory to allocate
    int64_t _579 = 1;
    _579 *= _542.d1;
    _579 *= sizeof(int64_t);
    _578.data = jpl_alloc(_579);
    int64_t _580 = 0; // h
    _jump445:; // Begin body of loop
    int64_t _581 = 0;
    _581 *= _578.d0;
    _581 += _580;
    _578.data[_581] = _580;
    _580++;
    if (_580 < _542.d1)
    goto _jump445;
    // End body of loop
    _a1_int64_t _582;
    // Computing bound for h
    _582.d0 = _542.d1;
    if (_542.d1 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing total size of heap memory to allocate
    int64_t _583 = 1;
    _583 *= _542.d1;
    _583 *= sizeof(int64_t);
    _582.data = jpl_alloc(_583);
    int64_t _584 = 0; // h
    _jump447:; // Begin body of loop
    int64_t _585 = 407;
    int64_t _586 = 0;
    _586 *= _582.d0;
    _586 += _584;
    _582.data[_586] = _585;
    _584++;
    if (_584 < _542.d1)
    goto _jump447;
    // End body of loop
    _a1__a1_int64_t _587;
    _587.d0 = 2;
    _587.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _587.data[0] = _578;
    _587.data[1] = _582;
    _a1__a1__a1_int64_t _588;
    _588.d0 = 3;
    _588.data = jpl_alloc(sizeof(_a1__a1_int64_t) * 3);
    _588.data[0] = _556;
    _588.data[1] = _577;
    _588.data[2] = _587;
    _555 = _588;
    goto _jump448;
    _jump433:;
    _a1__a1__a1_int64_t _589;
    // Computing bound for h
    _589.d0 = _542.d0;
    if (_542.d0 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing total size of heap memory to allocate
    int64_t _590 = 1;
    _590 *= _542.d0;
    _590 *= sizeof(_a1__a1_int64_t);
    _589.data = jpl_alloc(_590);
    int64_t _591 = 0; // h
    _jump450:; // Begin body of loop
    _a1_int64_t _592;
    _592.d0 = 3;
    _592.data = jpl_alloc(sizeof(int64_t) * 3);
    _592.data[0] = _218;
    _592.data[1] = _591;
    _592.data[2] = _542.d0;
    _a1_int64_t _593;
    _593.d0 = 1;
    _593.data = jpl_alloc(sizeof(int64_t) * 1);
    _593.data[0] = _591;
    _a1_int64_t _594;
    _594.d0 = 1;
    _594.data = jpl_alloc(sizeof(int64_t) * 1);
    _594.data[0] = _591;
    _a1__a1_int64_t _595;
    _595.d0 = 3;
    _595.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _595.data[0] = _592;
    _595.data[1] = _593;
    _595.data[2] = _594;
    int64_t _596 = 0;
    _596 *= _589.d0;
    _596 += _591;
    _589.data[_596] = _595;
    _591++;
    if (_591 < _542.d0)
    goto _jump450;
    // End body of loop
    _555 = _589;
    _jump448:;
    int64_t _597;
    // Computing bound for h
    int64_t _598;
    if (!_0)
    goto _jump451;
    int64_t _599 = 324;
    _598 = _599;
    goto _jump452;
    _jump451:;
    bool _600 = _0;
    if (0 == _0)
    goto _jump453;
    bool _601 = true;
    _600 = _601;
    _jump453:;
    int64_t _602;
    if (!_600)
    goto _jump454;
    _602 = _542.d1;
    goto _jump455;
    _jump454:;
    int64_t _603 = -_218;
    _602 = _603;
    _jump455:;
    _598 = _602;
    _jump452:;
    if (_598 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    _597 = 0;
    int64_t _604 = 0; // h
    _jump457:; // Begin body of loop
    int64_t _605 = -_542.d0;
    _597 += _605;
    _604++;
    if (_604 < _598)
    goto _jump457;
    // End body of loop
    if (_597 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_597 < _555.d0)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    int64_t _606 = 0;
    _606 *= _555.d0;
    _606 += _597;
    _a1__a1_int64_t _607 = _555.data[_606];
    _554 = _607;
    goto _jump460;
    _jump432:;
    double _608 = 93.0;
    double _609 = 77.0;
    double _610 = fmod(_608, _609);
    double _611;
    // Computing bound for h
    if (_218 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    _611 = 0;
    int64_t _612 = 0; // h
    _jump462:; // Begin body of loop
    double _613 = 16.0;
    _611 += _613;
    _612++;
    if (_612 < _218)
    goto _jump462;
    // End body of loop
    double _614 = -_611;
    bool _615 = _610 >= _614;
    _a1__a1_int64_t _616;
    if (!_615)
    goto _jump463;
    bool _617;
    if (!_0)
    goto _jump464;
    _617 = _552;
    goto _jump465;
    _jump464:;
    _617 = _0;
    _jump465:;
    bool _618 = !_617;
    _a1__a1_int64_t _619;
    if (!_618)
    goto _jump466;
    int64_t _620 = 654;
    int64_t _621 = 369;
    _a1_int64_t _622;
    _622.d0 = 3;
    _622.data = jpl_alloc(sizeof(int64_t) * 3);
    _622.data[0] = _620;
    _622.data[1] = _218;
    _622.data[2] = _621;
    _a1_int64_t _623;
    // Computing bound for h
    _623.d0 = _218;
    if (_218 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing total size of heap memory to allocate
    int64_t _624 = 1;
    _624 *= _218;
    _624 *= sizeof(int64_t);
    _623.data = jpl_alloc(_624);
    int64_t _625 = 0; // h
    _jump468:; // Begin body of loop
    int64_t _626 = 0;
    _626 *= _623.d0;
    _626 += _625;
    _623.data[_626] = _218;
    _625++;
    if (_625 < _218)
    goto _jump468;
    // End body of loop
    _a1__a1_int64_t _627;
    _627.d0 = 2;
    _627.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _627.data[0] = _622;
    _627.data[1] = _623;
    _619 = _627;
    goto _jump469;
    _jump466:;
    _a1_int64_t _628;
    // Computing bound for h
    _628.d0 = _542.d0;
    if (_542.d0 > 0) 
    goto _jump470;
    fail_assertion("non-positive loop bound");
    _jump470:;
    // Computing total size of heap memory to allocate
    int64_t _629 = 1;
    _629 *= _542.d0;
    _629 *= sizeof(int64_t);
    _628.data = jpl_alloc(_629);
    int64_t _630 = 0; // h
    _jump471:; // Begin body of loop
    int64_t _631 = -_542.d1;
    int64_t _632 = 0;
    _632 *= _628.d0;
    _632 += _630;
    _628.data[_632] = _631;
    _630++;
    if (_630 < _542.d0)
    goto _jump471;
    // End body of loop
    int64_t _633;
    if (!_0)
    goto _jump472;
    int64_t _634 = 164;
    _633 = _634;
    goto _jump473;
    _jump472:;
    _633 = _542.d0;
    _jump473:;
    _a1_int64_t _635;
    _635.d0 = 1;
    _635.data = jpl_alloc(sizeof(int64_t) * 1);
    _635.data[0] = _633;
    _a1__a1_int64_t _636;
    _636.d0 = 2;
    _636.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _636.data[0] = _628;
    _636.data[1] = _635;
    _619 = _636;
    _jump469:;
    _616 = _619;
    goto _jump474;
    _jump463:;
    _a1_int64_t _637;
    // Computing bound for h
    _637.d0 = _542.d0;
    if (_542.d0 > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing total size of heap memory to allocate
    int64_t _638 = 1;
    _638 *= _542.d0;
    _638 *= sizeof(int64_t);
    _637.data = jpl_alloc(_638);
    int64_t _639 = 0; // h
    _jump476:; // Begin body of loop
    int64_t _640 = 0;
    _640 *= _637.d0;
    _640 += _639;
    _637.data[_640] = _542.d0;
    _639++;
    if (_639 < _542.d0)
    goto _jump476;
    // End body of loop
    _a1_int64_t _641;
    _641.d0 = 1;
    _641.data = jpl_alloc(sizeof(int64_t) * 1);
    _641.data[0] = _542.d0;
    _a1__a1_int64_t _642;
    _642.d0 = 2;
    _642.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _642.data[0] = _637;
    _642.data[1] = _641;
    _a1__a1__a1_int64_t _643;
    _643.d0 = 1;
    _643.data = jpl_alloc(sizeof(_a1__a1_int64_t) * 1);
    _643.data[0] = _642;
    if (_542.d1 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_542.d1 < _643.d0)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    int64_t _644 = 0;
    _644 *= _643.d0;
    _644 += _542.d1;
    _a1__a1_int64_t _645 = _643.data[_644];
    _616 = _645;
    _jump474:;
    _554 = _616;
    _jump460:;
    _a3_int64_t _646;
    // Computing bound for h
    int64_t _647;
    // Computing bound for h
    int64_t _648 = -_218;
    if (_648 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing bound for i
    int64_t _649 = 725;
    if (_649 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for j
    if (_542.d0 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    _647 = 0;
    int64_t _650 = 0; // j
    int64_t _651 = 0; // i
    int64_t _652 = 0; // h
    _jump482:; // Begin body of loop
    _647 += _650;
    _650++;
    if (_650 < _542.d0)
    goto _jump482;
    _650 = 0;
    _651++;
    if (_651 < _649)
    goto _jump482;
    _651 = 0;
    _652++;
    if (_652 < _648)
    goto _jump482;
    // End body of loop
    _646.d0 = _647;
    if (_647 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    // Computing bound for i
    _646.d1 = _542.d1;
    if (_542.d1 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing bound for j
    _646.d2 = _542.d0;
    if (_542.d0 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing total size of heap memory to allocate
    int64_t _653 = 1;
    _653 *= _647;
    _653 *= _542.d1;
    _653 *= _542.d0;
    _653 *= sizeof(int64_t);
    _646.data = jpl_alloc(_653);
    int64_t _654 = 0; // j
    int64_t _655 = 0; // i
    int64_t _656 = 0; // h
    _jump486:; // Begin body of loop
    int64_t _657;
    // Computing bound for k
    if (_656 > 0) 
    goto _jump487;
    fail_assertion("non-positive loop bound");
    _jump487:;
    _657 = 0;
    int64_t _658 = 0; // k
    _jump488:; // Begin body of loop
    _657 += _655;
    _658++;
    if (_658 < _656)
    goto _jump488;
    // End body of loop
    int64_t _659 = 0;
    _659 *= _646.d0;
    _659 += _656;
    _659 *= _646.d1;
    _659 += _655;
    _659 *= _646.d2;
    _659 += _654;
    _646.data[_659] = _657;
    _654++;
    if (_654 < _542.d0)
    goto _jump486;
    _654 = 0;
    _655++;
    if (_655 < _542.d1)
    goto _jump486;
    _655 = 0;
    _656++;
    if (_656 < _647)
    goto _jump486;
    // End body of loop
    if (_542.d1 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_542.d1 < _646.d0)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    if (_542.d0 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_542.d0 < _646.d1)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_218 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_218 < _646.d2)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    int64_t _660 = 0;
    _660 *= _646.d0;
    _660 += _542.d1;
    _660 *= _646.d1;
    _660 += _542.d0;
    _660 *= _646.d2;
    _660 += _218;
    int64_t _661 = _646.data[_660];
    int64_t _662 = _542.d0 % _661;
    if (_662 >= 0)
    goto _jump495;
    fail_assertion("negative array index");
    _jump495:;
    if (_662 < _554.d0)
    goto _jump496;
    fail_assertion("index too large");
    _jump496:;
    int64_t _663 = 0;
    _663 *= _554.d0;
    _663 += _662;
    _a1_int64_t _664 = _554.data[_663];
    double _665 = 27.0;
    double _666;
    // Computing bound for l
    if (_542.d1 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing bound for m
    if (_664.d0 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing bound for n
    int64_t _667 = 432;
    int64_t _668 = _664.d0 / _667;
    if (_668 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    _666 = 0;
    int64_t _669 = 0; // n
    int64_t _670 = 0; // m
    int64_t _671 = 0; // l
    _jump500:; // Begin body of loop
    _a3_double _672;
    // Computing bound for o
    _672.d0 = _664.d0;
    if (_664.d0 > 0) 
    goto _jump501;
    fail_assertion("non-positive loop bound");
    _jump501:;
    // Computing bound for p
    _672.d1 = _664.d0;
    if (_664.d0 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    // Computing bound for q
    int64_t _673 = 27;
    _672.d2 = _673;
    if (_673 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing total size of heap memory to allocate
    int64_t _674 = 1;
    _674 *= _664.d0;
    _674 *= _664.d0;
    _674 *= _673;
    _674 *= sizeof(double);
    _672.data = jpl_alloc(_674);
    int64_t _675 = 0; // q
    int64_t _676 = 0; // p
    int64_t _677 = 0; // o
    _jump504:; // Begin body of loop
    double _678 = 47.0;
    int64_t _679 = 0;
    _679 *= _672.d0;
    _679 += _677;
    _679 *= _672.d1;
    _679 += _676;
    _679 *= _672.d2;
    _679 += _675;
    _672.data[_679] = _678;
    _675++;
    if (_675 < _673)
    goto _jump504;
    _675 = 0;
    _676++;
    if (_676 < _664.d0)
    goto _jump504;
    _676 = 0;
    _677++;
    if (_677 < _664.d0)
    goto _jump504;
    // End body of loop
    if (_542.d1 >= 0)
    goto _jump505;
    fail_assertion("negative array index");
    _jump505:;
    if (_542.d1 < _672.d0)
    goto _jump506;
    fail_assertion("index too large");
    _jump506:;
    if (_664.d0 >= 0)
    goto _jump507;
    fail_assertion("negative array index");
    _jump507:;
    if (_664.d0 < _672.d1)
    goto _jump508;
    fail_assertion("index too large");
    _jump508:;
    if (_670 >= 0)
    goto _jump509;
    fail_assertion("negative array index");
    _jump509:;
    if (_670 < _672.d2)
    goto _jump510;
    fail_assertion("index too large");
    _jump510:;
    int64_t _680 = 0;
    _680 *= _672.d0;
    _680 += _542.d1;
    _680 *= _672.d1;
    _680 += _664.d0;
    _680 *= _672.d2;
    _680 += _670;
    double _681 = _672.data[_680];
    _666 += _681;
    _669++;
    if (_669 < _668)
    goto _jump500;
    _669 = 0;
    _670++;
    if (_670 < _664.d0)
    goto _jump500;
    _670 = 0;
    _671++;
    if (_671 < _542.d1)
    goto _jump500;
    // End body of loop
    double _682 = -_666;
    double _683;
    // Computing bound for l
    if (_542.d0 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    _683 = 0;
    int64_t _684 = 0; // l
    _jump512:; // Begin body of loop
    int64_t _685 = -_664.d0;
    bool _686 = _685 > _542.d1;
    double _687;
    if (!_686)
    goto _jump513;
    int64_t _688 = 580;
    int64_t _689 = _664.d0 - _688;
    if (_218 >= 0)
    goto _jump514;
    fail_assertion("negative array index");
    _jump514:;
    if (_218 < _542.d0)
    goto _jump515;
    fail_assertion("index too large");
    _jump515:;
    if (_689 >= 0)
    goto _jump516;
    fail_assertion("negative array index");
    _jump516:;
    if (_689 < _542.d1)
    goto _jump517;
    fail_assertion("index too large");
    _jump517:;
    int64_t _690 = 0;
    _690 *= _542.d0;
    _690 += _218;
    _690 *= _542.d1;
    _690 += _689;
    double _691 = _542.data[_690];
    _687 = _691;
    goto _jump518;
    _jump513:;
    double _692 = 27.0;
    _687 = _692;
    _jump518:;
    _683 += _687;
    _684++;
    if (_684 < _542.d0)
    goto _jump512;
    // End body of loop
    double _693 = _682 / _683;
    double _694 = -_693;
    double _695 = 80.0;
    double _696;
    // Computing bound for l
    if (_664.d0 > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    // Computing bound for m
    _a2_bool _697;
    if (!_0)
    goto _jump520;
    _a2_bool _698;
    // Computing bound for l
    _698.d0 = _218;
    if (_218 > 0) 
    goto _jump521;
    fail_assertion("non-positive loop bound");
    _jump521:;
    // Computing bound for m
    _698.d1 = _664.d0;
    if (_664.d0 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing total size of heap memory to allocate
    int64_t _699 = 1;
    _699 *= _218;
    _699 *= _664.d0;
    _699 *= sizeof(bool);
    _698.data = jpl_alloc(_699);
    int64_t _700 = 0; // m
    int64_t _701 = 0; // l
    _jump523:; // Begin body of loop
    int64_t _702 = 0;
    _702 *= _698.d0;
    _702 += _701;
    _702 *= _698.d1;
    _702 += _700;
    _698.data[_702] = _552;
    _700++;
    if (_700 < _664.d0)
    goto _jump523;
    _700 = 0;
    _701++;
    if (_701 < _218)
    goto _jump523;
    // End body of loop
    _697 = _698;
    goto _jump524;
    _jump520:;
    _a2_bool _703;
    // Computing bound for l
    int64_t _704 = 820;
    _703.d0 = _704;
    if (_704 > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    // Computing bound for m
    _703.d1 = _664.d0;
    if (_664.d0 > 0) 
    goto _jump526;
    fail_assertion("non-positive loop bound");
    _jump526:;
    // Computing total size of heap memory to allocate
    int64_t _705 = 1;
    _705 *= _704;
    _705 *= _664.d0;
    _705 *= sizeof(bool);
    _703.data = jpl_alloc(_705);
    int64_t _706 = 0; // m
    int64_t _707 = 0; // l
    _jump527:; // Begin body of loop
    bool _708 = false;
    int64_t _709 = 0;
    _709 *= _703.d0;
    _709 += _707;
    _709 *= _703.d1;
    _709 += _706;
    _703.data[_709] = _708;
    _706++;
    if (_706 < _664.d0)
    goto _jump527;
    _706 = 0;
    _707++;
    if (_707 < _704)
    goto _jump527;
    // End body of loop
    _697 = _703;
    _jump524:;
    if (_664.d0 >= 0)
    goto _jump528;
    fail_assertion("negative array index");
    _jump528:;
    if (_664.d0 < _697.d0)
    goto _jump529;
    fail_assertion("index too large");
    _jump529:;
    if (_542.d0 >= 0)
    goto _jump530;
    fail_assertion("negative array index");
    _jump530:;
    if (_542.d0 < _697.d1)
    goto _jump531;
    fail_assertion("index too large");
    _jump531:;
    int64_t _710 = 0;
    _710 *= _697.d0;
    _710 += _664.d0;
    _710 *= _697.d1;
    _710 += _542.d0;
    bool _711 = _697.data[_710];
    _a2_int64_t _712;
    if (!_711)
    goto _jump532;
    _a2_int64_t _713;
    // Computing bound for l
    _713.d0 = _218;
    if (_218 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for m
    _713.d1 = _542.d0;
    if (_542.d0 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing total size of heap memory to allocate
    int64_t _714 = 1;
    _714 *= _218;
    _714 *= _542.d0;
    _714 *= sizeof(int64_t);
    _713.data = jpl_alloc(_714);
    int64_t _715 = 0; // m
    int64_t _716 = 0; // l
    _jump535:; // Begin body of loop
    int64_t _717 = _542.d1 + _716;
    int64_t _718 = 0;
    _718 *= _713.d0;
    _718 += _716;
    _718 *= _713.d1;
    _718 += _715;
    _713.data[_718] = _717;
    _715++;
    if (_715 < _542.d0)
    goto _jump535;
    _715 = 0;
    _716++;
    if (_716 < _218)
    goto _jump535;
    // End body of loop
    _712 = _713;
    goto _jump536;
    _jump532:;
    _a2_int64_t _719;
    // Computing bound for l
    _719.d0 = _664.d0;
    if (_664.d0 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for m
    _719.d1 = _218;
    if (_218 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _720 = 1;
    _720 *= _664.d0;
    _720 *= _218;
    _720 *= sizeof(int64_t);
    _719.data = jpl_alloc(_720);
    int64_t _721 = 0; // m
    int64_t _722 = 0; // l
    _jump539:; // Begin body of loop
    int64_t _723 = 0;
    _723 *= _719.d0;
    _723 += _722;
    _723 *= _719.d1;
    _723 += _721;
    _719.data[_723] = _542.d1;
    _721++;
    if (_721 < _218)
    goto _jump539;
    _721 = 0;
    _722++;
    if (_722 < _664.d0)
    goto _jump539;
    // End body of loop
    _a1__a2_int64_t _724;
    _724.d0 = 1;
    _724.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _724.data[0] = _719;
    int64_t _725;
    // Computing bound for l
    int64_t _726 = _542.d0 % _664.d0;
    if (_726 > 0) 
    goto _jump540;
    fail_assertion("non-positive loop bound");
    _jump540:;
    // Computing bound for m
    if (_542.d0 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    _725 = 0;
    int64_t _727 = 0; // m
    int64_t _728 = 0; // l
    _jump542:; // Begin body of loop
    int64_t _729 = -_727;
    _725 += _729;
    _727++;
    if (_727 < _542.d0)
    goto _jump542;
    _727 = 0;
    _728++;
    if (_728 < _726)
    goto _jump542;
    // End body of loop
    if (_725 >= 0)
    goto _jump543;
    fail_assertion("negative array index");
    _jump543:;
    if (_725 < _724.d0)
    goto _jump544;
    fail_assertion("index too large");
    _jump544:;
    int64_t _730 = 0;
    _730 *= _724.d0;
    _730 += _725;
    _a2_int64_t _731 = _724.data[_730];
    _712 = _731;
    _jump536:;
    if (_542.d1 >= 0)
    goto _jump545;
    fail_assertion("negative array index");
    _jump545:;
    if (_542.d1 < _712.d0)
    goto _jump546;
    fail_assertion("index too large");
    _jump546:;
    if (_664.d0 >= 0)
    goto _jump547;
    fail_assertion("negative array index");
    _jump547:;
    if (_664.d0 < _712.d1)
    goto _jump548;
    fail_assertion("index too large");
    _jump548:;
    int64_t _732 = 0;
    _732 *= _712.d0;
    _732 += _542.d1;
    _732 *= _712.d1;
    _732 += _664.d0;
    int64_t _733 = _712.data[_732];
    if (_733 > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    _696 = 0;
    int64_t _734 = 0; // m
    int64_t _735 = 0; // l
    _jump550:; // Begin body of loop
    bool _736 = true;
    double _737;
    if (!_736)
    goto _jump551;
    rgba _738 = a();
    double _739 = _738.g;
    double _740 = -_739;
    double _741 = 62.0;
    double _742 = _740 + _741;
    _737 = _742;
    goto _jump552;
    _jump551:;
    double _743 = 8.0;
    _737 = _743;
    _jump552:;
    _696 += _737;
    _734++;
    if (_734 < _733)
    goto _jump550;
    _734 = 0;
    _735++;
    if (_735 < _664.d0)
    goto _jump550;
    // End body of loop
    rgba _744 = { _665, _694, _695, _696 };
    return _744;
}

_a3_rgba e(int64_t f, _a2_void_t g, _a2__a3_rgba j) {
    _a2_int64_t _0;
    // Computing bound for k
    _0.d0 = c;
    if (c > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    // Computing bound for l
    _0.d1 = c;
    if (c > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= c;
    _1 *= c;
    _1 *= sizeof(int64_t);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // l
    int64_t _3 = 0; // k
    _jump766:; // Begin body of loop
    int64_t _4 = 0;
    _4 *= _0.d0;
    _4 += _3;
    _4 *= _0.d1;
    _4 += _2;
    _0.data[_4] = g.d1;
    _2++;
    if (_2 < c)
    goto _jump766;
    _2 = 0;
    _3++;
    if (_3 < c)
    goto _jump766;
    // End body of loop
    bool _5 = false;
    bool _6;
    if (!_5)
    goto _jump767;
    _a3_bool _7;
    // Computing bound for l
    _7.d0 = c;
    if (c > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    // Computing bound for m
    _7.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    // Computing bound for n
    _7.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump770;
    fail_assertion("non-positive loop bound");
    _jump770:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= c;
    _8 *= g.d1;
    _8 *= g.d1;
    _8 *= sizeof(bool);
    _7.data = jpl_alloc(_8);
    int64_t _9 = 0; // n
    int64_t _10 = 0; // m
    int64_t _11 = 0; // l
    _jump771:; // Begin body of loop
    int64_t _12 = g.d1 % _10;
    bool _13 = d >= _12;
    int64_t _14 = 0;
    _14 *= _7.d0;
    _14 += _11;
    _14 *= _7.d1;
    _14 += _10;
    _14 *= _7.d2;
    _14 += _9;
    _7.data[_14] = _13;
    _9++;
    if (_9 < g.d1)
    goto _jump771;
    _9 = 0;
    _10++;
    if (_10 < g.d1)
    goto _jump771;
    _10 = 0;
    _11++;
    if (_11 < c)
    goto _jump771;
    // End body of loop
    bool _15 = false;
    int64_t _16;
    if (!_15)
    goto _jump772;
    _a1_int64_t _17;
    // Computing bound for l
    _17.d0 = c;
    if (c > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= c;
    _18 *= sizeof(int64_t);
    _17.data = jpl_alloc(_18);
    int64_t _19 = 0; // l
    _jump774:; // Begin body of loop
    int64_t _20 = 0;
    _20 *= _17.d0;
    _20 += _19;
    _17.data[_20] = g.d1;
    _19++;
    if (_19 < c)
    goto _jump774;
    // End body of loop
    bool _21 = false;
    int64_t _22;
    if (!_21)
    goto _jump775;
    int64_t _23 = 265;
    _22 = _23;
    goto _jump776;
    _jump775:;
    _22 = d;
    _jump776:;
    if (_22 >= 0)
    goto _jump777;
    fail_assertion("negative array index");
    _jump777:;
    if (_22 < _17.d0)
    goto _jump778;
    fail_assertion("index too large");
    _jump778:;
    int64_t _24 = 0;
    _24 *= _17.d0;
    _24 += _22;
    int64_t _25 = _17.data[_24];
    _16 = _25;
    goto _jump779;
    _jump772:;
    int64_t _26 = 391;
    int64_t _27 = 856;
    bool _28 = _26 >= _27;
    int64_t _29;
    if (!_28)
    goto _jump780;
    int64_t _30 = 246;
    _29 = _30;
    goto _jump781;
    _jump780:;
    _29 = d;
    _jump781:;
    _16 = _29;
    _jump779:;
    double _31 = 44.0;
    double _32 = 97.0;
    double _33 = -_32;
    bool _34 = _31 < _33;
    int64_t _35;
    if (!_34)
    goto _jump782;
    _35 = c;
    goto _jump783;
    _jump782:;
    _35 = c;
    _jump783:;
    if (_16 >= 0)
    goto _jump784;
    fail_assertion("negative array index");
    _jump784:;
    if (_16 < _7.d0)
    goto _jump785;
    fail_assertion("index too large");
    _jump785:;
    if (_35 >= 0)
    goto _jump786;
    fail_assertion("negative array index");
    _jump786:;
    if (_35 < _7.d1)
    goto _jump787;
    fail_assertion("index too large");
    _jump787:;
    if (d >= 0)
    goto _jump788;
    fail_assertion("negative array index");
    _jump788:;
    if (d < _7.d2)
    goto _jump789;
    fail_assertion("index too large");
    _jump789:;
    int64_t _36 = 0;
    _36 *= _7.d0;
    _36 += _16;
    _36 *= _7.d1;
    _36 += _35;
    _36 *= _7.d2;
    _36 += d;
    bool _37 = _7.data[_36];
    _6 = _37;
    goto _jump790;
    _jump767:;
    double _38 = 8.0;
    double _39 = -_38;
    double _40 = -_39;
    bool _41 = true;
    double _42;
    if (!_41)
    goto _jump791;
    rgba _43 = a();
    double _44 = _43.r;
    _42 = _44;
    goto _jump792;
    _jump791:;
    double _45 = 28.0;
    double _46 = -_45;
    _42 = _46;
    _jump792:;
    double _47 = -_42;
    bool _48 = _40 >= _47;
    _6 = _48;
    _jump790:;
    _a2_int64_t _49;
    if (!_6)
    goto _jump793;
    _49 = _0;
    goto _jump794;
    _jump793:;
    bool _50 = true;
    _a2_int64_t _51;
    if (!_50)
    goto _jump795;
    _51 = b;
    goto _jump796;
    _jump795:;
    bool _52 = true;
    bool _53 = false;
    _a1_bool _54;
    _54.d0 = 2;
    _54.data = jpl_alloc(sizeof(bool) * 2);
    _54.data[0] = _52;
    _54.data[1] = _53;
    if (f >= 0)
    goto _jump797;
    fail_assertion("negative array index");
    _jump797:;
    if (f < _54.d0)
    goto _jump798;
    fail_assertion("index too large");
    _jump798:;
    int64_t _55 = 0;
    _55 *= _54.d0;
    _55 += f;
    bool _56 = _54.data[_55];
    bool _57;
    if (!_56)
    goto _jump799;
    double _59 = 11.0;
    double _60 = 77.0;
    bool _61 = _59 != _60;
    bool _58 = _61;
    if (0 == _61)
    goto _jump800;
    bool _62 = true;
    _58 = _62;
    _jump800:;
    _57 = _58;
    goto _jump801;
    _jump799:;
    bool _63 = g.d1 != g.d1;
    bool _64 = !_63;
    _57 = _64;
    _jump801:;
    _a2_int64_t _65;
    if (!_57)
    goto _jump802;
    _a2_int64_t _66;
    // Computing bound for l
    _66.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    // Computing bound for m
    int64_t _67 = 945;
    _66.d1 = _67;
    if (_67 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= g.d1;
    _68 *= _67;
    _68 *= sizeof(int64_t);
    _66.data = jpl_alloc(_68);
    int64_t _69 = 0; // m
    int64_t _70 = 0; // l
    _jump805:; // Begin body of loop
    int64_t _71 = 0;
    _71 *= _66.d0;
    _71 += _70;
    _71 *= _66.d1;
    _71 += _69;
    _66.data[_71] = c;
    _69++;
    if (_69 < _67)
    goto _jump805;
    _69 = 0;
    _70++;
    if (_70 < g.d1)
    goto _jump805;
    // End body of loop
    _65 = _66;
    goto _jump806;
    _jump802:;
    _a2_int64_t _72;
    // Computing bound for l
    int64_t _73;
    // Computing bound for l
    int64_t _74;
    // Computing bound for l
    if (f > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    _74 = 0;
    int64_t _75 = 0; // l
    _jump808:; // Begin body of loop
    _74 += f;
    _75++;
    if (_75 < f)
    goto _jump808;
    // End body of loop
    if (_74 > 0) 
    goto _jump809;
    fail_assertion("non-positive loop bound");
    _jump809:;
    // Computing bound for m
    int64_t _76 = g.d0 - g.d0;
    if (_76 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    // Computing bound for n
    if (g.d0 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    _73 = 0;
    int64_t _77 = 0; // n
    int64_t _78 = 0; // m
    int64_t _79 = 0; // l
    _jump812:; // Begin body of loop
    _73 += _78;
    _77++;
    if (_77 < g.d0)
    goto _jump812;
    _77 = 0;
    _78++;
    if (_78 < _76)
    goto _jump812;
    _78 = 0;
    _79++;
    if (_79 < _74)
    goto _jump812;
    // End body of loop
    _72.d0 = _73;
    if (_73 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    // Computing bound for m
    _72.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= _73;
    _80 *= g.d0;
    _80 *= sizeof(int64_t);
    _72.data = jpl_alloc(_80);
    int64_t _81 = 0; // m
    int64_t _82 = 0; // l
    _jump815:; // Begin body of loop
    int64_t _83 = 0;
    _83 *= _72.d0;
    _83 += _82;
    _83 *= _72.d1;
    _83 += _81;
    _72.data[_83] = c;
    _81++;
    if (_81 < g.d0)
    goto _jump815;
    _81 = 0;
    _82++;
    if (_82 < _73)
    goto _jump815;
    // End body of loop
    _65 = _72;
    _jump806:;
    _51 = _65;
    _jump796:;
    _49 = _51;
    _jump794:;
    int64_t _84 = 117;
    if (c >= 0)
    goto _jump816;
    fail_assertion("negative array index");
    _jump816:;
    if (c < _49.d0)
    goto _jump817;
    fail_assertion("index too large");
    _jump817:;
    if (_84 >= 0)
    goto _jump818;
    fail_assertion("negative array index");
    _jump818:;
    if (_84 < _49.d1)
    goto _jump819;
    fail_assertion("index too large");
    _jump819:;
    int64_t _85 = 0;
    _85 *= _49.d0;
    _85 += c;
    _85 *= _49.d1;
    _85 += _84;
    int64_t _86 = _49.data[_85];
    _a2_rgba _87;
    // Computing bound for n
    int64_t _88;
    // Computing bound for n
    if (_86 > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    // Computing bound for o
    if (d > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    // Computing bound for p
    int64_t _89 = 796;
    if (_89 > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    _88 = 0;
    int64_t _90 = 0; // p
    int64_t _91 = 0; // o
    int64_t _92 = 0; // n
    _jump823:; // Begin body of loop
    _88 += g.d0;
    _90++;
    if (_90 < _89)
    goto _jump823;
    _90 = 0;
    _91++;
    if (_91 < d)
    goto _jump823;
    _91 = 0;
    _92++;
    if (_92 < _86)
    goto _jump823;
    // End body of loop
    _87.d0 = _88;
    if (_88 > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    // Computing bound for o
    _87.d1 = c;
    if (c > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= _88;
    _93 *= c;
    _93 *= sizeof(rgba);
    _87.data = jpl_alloc(_93);
    int64_t _94 = 0; // o
    int64_t _95 = 0; // n
    _jump826:; // Begin body of loop
    _a3_rgba _96;
    // Computing bound for p
    int64_t _97 = 981;
    int64_t _98 = g.d1 + _97;
    int64_t _99 = -_98;
    _96.d0 = _99;
    if (_99 > 0) 
    goto _jump827;
    fail_assertion("non-positive loop bound");
    _jump827:;
    // Computing bound for q
    int64_t _100 = 823;
    _96.d1 = _100;
    if (_100 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing bound for r
    int64_t _101 = 715;
    int64_t _102 = -_101;
    _96.d2 = _102;
    if (_102 > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= _99;
    _103 *= _100;
    _103 *= _102;
    _103 *= sizeof(rgba);
    _96.data = jpl_alloc(_103);
    int64_t _104 = 0; // r
    int64_t _105 = 0; // q
    int64_t _106 = 0; // p
    _jump830:; // Begin body of loop
    _a2_rgba _107;
    // Computing bound for s
    _107.d0 = f;
    if (f > 0) 
    goto _jump831;
    fail_assertion("non-positive loop bound");
    _jump831:;
    // Computing bound for t
    _107.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= f;
    _108 *= g.d0;
    _108 *= sizeof(rgba);
    _107.data = jpl_alloc(_108);
    int64_t _109 = 0; // t
    int64_t _110 = 0; // s
    _jump833:; // Begin body of loop
    rgba _111 = a();
    int64_t _112 = 0;
    _112 *= _107.d0;
    _112 += _110;
    _112 *= _107.d1;
    _112 += _109;
    _107.data[_112] = _111;
    _109++;
    if (_109 < g.d0)
    goto _jump833;
    _109 = 0;
    _110++;
    if (_110 < f)
    goto _jump833;
    // End body of loop
    if (c >= 0)
    goto _jump834;
    fail_assertion("negative array index");
    _jump834:;
    if (c < _107.d0)
    goto _jump835;
    fail_assertion("index too large");
    _jump835:;
    if (_105 >= 0)
    goto _jump836;
    fail_assertion("negative array index");
    _jump836:;
    if (_105 < _107.d1)
    goto _jump837;
    fail_assertion("index too large");
    _jump837:;
    int64_t _113 = 0;
    _113 *= _107.d0;
    _113 += c;
    _113 *= _107.d1;
    _113 += _105;
    rgba _114 = _107.data[_113];
    int64_t _115 = 0;
    _115 *= _96.d0;
    _115 += _106;
    _115 *= _96.d1;
    _115 += _105;
    _115 *= _96.d2;
    _115 += _104;
    _96.data[_115] = _114;
    _104++;
    if (_104 < _102)
    goto _jump830;
    _104 = 0;
    _105++;
    if (_105 < _100)
    goto _jump830;
    _105 = 0;
    _106++;
    if (_106 < _99)
    goto _jump830;
    // End body of loop
    int64_t _116 = 494;
    if (_86 >= 0)
    goto _jump838;
    fail_assertion("negative array index");
    _jump838:;
    if (_86 < _96.d0)
    goto _jump839;
    fail_assertion("index too large");
    _jump839:;
    if (c >= 0)
    goto _jump840;
    fail_assertion("negative array index");
    _jump840:;
    if (c < _96.d1)
    goto _jump841;
    fail_assertion("index too large");
    _jump841:;
    if (_116 >= 0)
    goto _jump842;
    fail_assertion("negative array index");
    _jump842:;
    if (_116 < _96.d2)
    goto _jump843;
    fail_assertion("index too large");
    _jump843:;
    int64_t _117 = 0;
    _117 *= _96.d0;
    _117 += _86;
    _117 *= _96.d1;
    _117 += c;
    _117 *= _96.d2;
    _117 += _116;
    rgba _118 = _96.data[_117];
    int64_t _119 = 0;
    _119 *= _87.d0;
    _119 += _95;
    _119 *= _87.d1;
    _119 += _94;
    _87.data[_119] = _118;
    _94++;
    if (_94 < c)
    goto _jump826;
    _94 = 0;
    _95++;
    if (_95 < _88)
    goto _jump826;
    // End body of loop
    _a2_bool _120;
    // Computing bound for n
    _120.d0 = d;
    if (d > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    // Computing bound for o
    bool _121 = true;
    bool _122 = false;
    bool _123 = _121 == _122;
    int64_t _124;
    if (!_123)
    goto _jump845;
    _124 = c;
    goto _jump846;
    _jump845:;
    _124 = g.d1;
    _jump846:;
    _120.d1 = _124;
    if (_124 > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing total size of heap memory to allocate
    int64_t _125 = 1;
    _125 *= d;
    _125 *= _124;
    _125 *= sizeof(bool);
    _120.data = jpl_alloc(_125);
    int64_t _126 = 0; // o
    int64_t _127 = 0; // n
    _jump848:; // Begin body of loop
    bool _128 = _86 >= _86;
    bool _129 = !_128;
    int64_t _130 = 0;
    _130 *= _120.d0;
    _130 += _127;
    _130 *= _120.d1;
    _130 += _126;
    _120.data[_130] = _129;
    _126++;
    if (_126 < _124)
    goto _jump848;
    _126 = 0;
    _127++;
    if (_127 < d)
    goto _jump848;
    // End body of loop
    int64_t _131 = -c;
    if (_86 >= 0)
    goto _jump849;
    fail_assertion("negative array index");
    _jump849:;
    if (_86 < _120.d0)
    goto _jump850;
    fail_assertion("index too large");
    _jump850:;
    if (_131 >= 0)
    goto _jump851;
    fail_assertion("negative array index");
    _jump851:;
    if (_131 < _120.d1)
    goto _jump852;
    fail_assertion("index too large");
    _jump852:;
    int64_t _132 = 0;
    _132 *= _120.d0;
    _132 += _86;
    _132 *= _120.d1;
    _132 += _131;
    bool _133 = _120.data[_132];
    int64_t _134;
    if (!_133)
    goto _jump853;
    bool _136 = false;
    bool _135 = _136;
    if (0 != _136)
    goto _jump854;
    bool _138 = g.d1 < f;
    bool _137 = _138;
    if (0 == _138)
    goto _jump855;
    bool _139 = true;
    _137 = _139;
    _jump855:;
    _135 = _137;
    _jump854:;
    int64_t _140;
    if (!_135)
    goto _jump856;
    _140 = _86;
    goto _jump857;
    _jump856:;
    int64_t _141 = -c;
    _140 = _141;
    _jump857:;
    _134 = _140;
    goto _jump858;
    _jump853:;
    int64_t _142 = 526;
    int64_t _143 = 508;
    int64_t _144 = _143 * c;
    bool _145 = _142 < _144;
    bool _146;
    if (!_145)
    goto _jump859;
    bool _148 = true;
    bool _147 = _148;
    if (0 == _148)
    goto _jump860;
    double _149 = 40.0;
    double _150 = 20.0;
    bool _151 = _149 > _150;
    _147 = _151;
    _jump860:;
    _146 = _147;
    goto _jump861;
    _jump859:;
    bool _152 = false;
    _146 = _152;
    _jump861:;
    int64_t _153;
    if (!_146)
    goto _jump862;
    _153 = _86;
    goto _jump863;
    _jump862:;
    int64_t _154 = 351;
    _153 = _154;
    _jump863:;
    _134 = _153;
    _jump858:;
    int64_t _155;
    // Computing bound for n
    int64_t _156;
    // Computing bound for n
    if (f >= 0)
    goto _jump864;
    fail_assertion("negative array index");
    _jump864:;
    if (f < b.d0)
    goto _jump865;
    fail_assertion("index too large");
    _jump865:;
    if (_86 >= 0)
    goto _jump866;
    fail_assertion("negative array index");
    _jump866:;
    if (_86 < b.d1)
    goto _jump867;
    fail_assertion("index too large");
    _jump867:;
    int64_t _157 = 0;
    _157 *= b.d0;
    _157 += f;
    _157 *= b.d1;
    _157 += _86;
    int64_t _158 = b.data[_157];
    if (_158 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing bound for o
    if (d >= 0)
    goto _jump869;
    fail_assertion("negative array index");
    _jump869:;
    if (d < b.d0)
    goto _jump870;
    fail_assertion("index too large");
    _jump870:;
    if (d >= 0)
    goto _jump871;
    fail_assertion("negative array index");
    _jump871:;
    if (d < b.d1)
    goto _jump872;
    fail_assertion("index too large");
    _jump872:;
    int64_t _159 = 0;
    _159 *= b.d0;
    _159 += d;
    _159 *= b.d1;
    _159 += d;
    int64_t _160 = b.data[_159];
    if (_160 > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    _156 = 0;
    int64_t _161 = 0; // o
    int64_t _162 = 0; // n
    _jump874:; // Begin body of loop
    _156 += _161;
    _161++;
    if (_161 < _160)
    goto _jump874;
    _161 = 0;
    _162++;
    if (_162 < _158)
    goto _jump874;
    // End body of loop
    if (_156 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    _155 = 0;
    int64_t _163 = 0; // n
    _jump876:; // Begin body of loop
    int64_t _164 = 269;
    _155 += _164;
    _163++;
    if (_163 < _156)
    goto _jump876;
    // End body of loop
    int64_t _165 = _86 / _155;
    if (_134 >= 0)
    goto _jump877;
    fail_assertion("negative array index");
    _jump877:;
    if (_134 < _87.d0)
    goto _jump878;
    fail_assertion("index too large");
    _jump878:;
    if (_165 >= 0)
    goto _jump879;
    fail_assertion("negative array index");
    _jump879:;
    if (_165 < _87.d1)
    goto _jump880;
    fail_assertion("index too large");
    _jump880:;
    int64_t _166 = 0;
    _166 *= _87.d0;
    _166 += _134;
    _166 *= _87.d1;
    _166 += _165;
    rgba _167 = _87.data[_166];
    double _168 = _167.r;
    _a2_bool _170;
    // Computing bound for o
    int64_t _171;
    // Computing bound for o
    if (c > 0) 
    goto _jump881;
    fail_assertion("non-positive loop bound");
    _jump881:;
    // Computing bound for p
    if (c > 0) 
    goto _jump882;
    fail_assertion("non-positive loop bound");
    _jump882:;
    _171 = 0;
    int64_t _172 = 0; // p
    int64_t _173 = 0; // o
    _jump883:; // Begin body of loop
    _171 += _173;
    _172++;
    if (_172 < c)
    goto _jump883;
    _172 = 0;
    _173++;
    if (_173 < c)
    goto _jump883;
    // End body of loop
    _170.d0 = _171;
    if (_171 > 0) 
    goto _jump884;
    fail_assertion("non-positive loop bound");
    _jump884:;
    // Computing bound for p
    if (_86 >= 0)
    goto _jump885;
    fail_assertion("negative array index");
    _jump885:;
    if (_86 < _0.d0)
    goto _jump886;
    fail_assertion("index too large");
    _jump886:;
    if (g.d1 >= 0)
    goto _jump887;
    fail_assertion("negative array index");
    _jump887:;
    if (g.d1 < _0.d1)
    goto _jump888;
    fail_assertion("index too large");
    _jump888:;
    int64_t _174 = 0;
    _174 *= _0.d0;
    _174 += _86;
    _174 *= _0.d1;
    _174 += g.d1;
    int64_t _175 = _0.data[_174];
    _170.d1 = _175;
    if (_175 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= _171;
    _176 *= _175;
    _176 *= sizeof(bool);
    _170.data = jpl_alloc(_176);
    int64_t _177 = 0; // p
    int64_t _178 = 0; // o
    _jump890:; // Begin body of loop
    double _179 = 12.0;
    bool _180 = _168 != _179;
    int64_t _181 = 0;
    _181 *= _170.d0;
    _181 += _178;
    _181 *= _170.d1;
    _181 += _177;
    _170.data[_181] = _180;
    _177++;
    if (_177 < _175)
    goto _jump890;
    _177 = 0;
    _178++;
    if (_178 < _171)
    goto _jump890;
    // End body of loop
    _a2_int64_t _182;
    // Computing bound for o
    _182.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing bound for p
    _182.d1 = _86;
    if (_86 > 0) 
    goto _jump892;
    fail_assertion("non-positive loop bound");
    _jump892:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= g.d0;
    _183 *= _86;
    _183 *= sizeof(int64_t);
    _182.data = jpl_alloc(_183);
    int64_t _184 = 0; // p
    int64_t _185 = 0; // o
    _jump893:; // Begin body of loop
    int64_t _186 = 468;
    int64_t _187 = 0;
    _187 *= _182.d0;
    _187 += _185;
    _187 *= _182.d1;
    _187 += _184;
    _182.data[_187] = _186;
    _184++;
    if (_184 < _86)
    goto _jump893;
    _184 = 0;
    _185++;
    if (_185 < g.d0)
    goto _jump893;
    // End body of loop
    if (d >= 0)
    goto _jump894;
    fail_assertion("negative array index");
    _jump894:;
    if (d < _182.d0)
    goto _jump895;
    fail_assertion("index too large");
    _jump895:;
    if (g.d1 >= 0)
    goto _jump896;
    fail_assertion("negative array index");
    _jump896:;
    if (g.d1 < _182.d1)
    goto _jump897;
    fail_assertion("index too large");
    _jump897:;
    int64_t _188 = 0;
    _188 *= _182.d0;
    _188 += d;
    _188 *= _182.d1;
    _188 += g.d1;
    int64_t _189 = _182.data[_188];
    int64_t _190 = _86 % g.d1;
    if (_189 >= 0)
    goto _jump898;
    fail_assertion("negative array index");
    _jump898:;
    if (_189 < _170.d0)
    goto _jump899;
    fail_assertion("index too large");
    _jump899:;
    if (_190 >= 0)
    goto _jump900;
    fail_assertion("negative array index");
    _jump900:;
    if (_190 < _170.d1)
    goto _jump901;
    fail_assertion("index too large");
    _jump901:;
    int64_t _191 = 0;
    _191 *= _170.d0;
    _191 += _189;
    _191 *= _170.d1;
    _191 += _190;
    bool _192 = _170.data[_191];
    double _193;
    if (!_192)
    goto _jump902;
    _193 = _168;
    goto _jump903;
    _jump902:;
    bool _194 = false;
    rgba _195;
    if (!_194)
    goto _jump904;
    rgba _196 = a();
    _195 = _196;
    goto _jump905;
    _jump904:;
    double _197 = 4.0;
    double _198 = 72.0;
    double _199 = 11.0;
    rgba _200 = { _197, _168, _198, _199 };
    _195 = _200;
    _jump905:;
    double _201 = _195.g;
    _193 = _201;
    _jump903:;
    bool _202 = _193 == _168;
    bool _169 = _202;
    if (0 != _202)
    goto _jump906;
    rgba _203 = a();
    double _204 = _203.r;
    double _205 = -_204;
    bool _206 = _168 > _205;
    _169 = _206;
    _jump906:;
    _a1_bool _207;
    _207.d0 = 1;
    _207.data = jpl_alloc(sizeof(bool) * 1);
    _207.data[0] = _169;
    bool _208 = true;
    rgba _209 = a();
    double _210 = _209.a;
    bool _211 = _168 != _210;
    bool _212 = _208 != _211;
    bool _213;
    if (!_212)
    goto _jump907;
    double _214 = -_168;
    rgba _215 = a();
    double _216 = _215.b;
    double _217 = _216 / _168;
    double _218 = -_217;
    bool _219 = _214 < _218;
    _213 = _219;
    goto _jump908;
    _jump907:;
    bool _220 = true;
    bool _221;
    if (!_220)
    goto _jump909;
    bool _223 = false;
    bool _224 = !_223;
    bool _222 = _224;
    if (0 != _224)
    goto _jump910;
    bool _225 = true;
    _222 = _225;
    _jump910:;
    bool _226;
    if (!_222)
    goto _jump911;
    bool _228 = true;
    bool _229 = !_228;
    bool _227 = _229;
    if (0 != _229)
    goto _jump912;
    bool _230 = false;
    _227 = _230;
    _jump912:;
    _226 = _227;
    goto _jump913;
    _jump911:;
    double _231;
    // Computing bound for p
    if (f > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing bound for q
    if (d > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    _231 = 0;
    int64_t _232 = 0; // q
    int64_t _233 = 0; // p
    _jump916:; // Begin body of loop
    _231 += _168;
    _232++;
    if (_232 < d)
    goto _jump916;
    _232 = 0;
    _233++;
    if (_233 < f)
    goto _jump916;
    // End body of loop
    double _234 = 92.0;
    double _235 = 2.0;
    double _236 = fmod(_234, _235);
    bool _237 = _231 > _236;
    _226 = _237;
    _jump913:;
    _221 = _226;
    goto _jump917;
    _jump909:;
    bool _238 = false;
    _221 = _238;
    _jump917:;
    _213 = _221;
    _jump908:;
    _a3__a1_int64_t _239;
    if (!_213)
    goto _jump918;
    _a2__a3__a1_int64_t _240;
    // Computing bound for p
    int64_t _241 = f + f;
    int64_t _242 = c + _241;
    int64_t _243 = -_242;
    _240.d0 = _243;
    if (_243 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    // Computing bound for q
    _a3_int64_t _244;
    // Computing bound for p
    int64_t _245 = -d;
    _244.d0 = _245;
    if (_245 > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for q
    if (d >= 0)
    goto _jump921;
    fail_assertion("negative array index");
    _jump921:;
    if (d < b.d0)
    goto _jump922;
    fail_assertion("index too large");
    _jump922:;
    if (d >= 0)
    goto _jump923;
    fail_assertion("negative array index");
    _jump923:;
    if (d < b.d1)
    goto _jump924;
    fail_assertion("index too large");
    _jump924:;
    int64_t _246 = 0;
    _246 *= b.d0;
    _246 += d;
    _246 *= b.d1;
    _246 += d;
    int64_t _247 = b.data[_246];
    _244.d1 = _247;
    if (_247 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for r
    _244.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= _245;
    _248 *= _247;
    _248 *= g.d0;
    _248 *= sizeof(int64_t);
    _244.data = jpl_alloc(_248);
    int64_t _249 = 0; // r
    int64_t _250 = 0; // q
    int64_t _251 = 0; // p
    _jump927:; // Begin body of loop
    int64_t _252 = 0;
    _252 *= _244.d0;
    _252 += _251;
    _252 *= _244.d1;
    _252 += _250;
    _252 *= _244.d2;
    _252 += _249;
    _244.data[_252] = _250;
    _249++;
    if (_249 < g.d0)
    goto _jump927;
    _249 = 0;
    _250++;
    if (_250 < _247)
    goto _jump927;
    _250 = 0;
    _251++;
    if (_251 < _245)
    goto _jump927;
    // End body of loop
    int64_t _253 = -d;
    int64_t _254 = -_86;
    int64_t _255;
    // Computing bound for p
    if (f > 0) 
    goto _jump928;
    fail_assertion("non-positive loop bound");
    _jump928:;
    _255 = 0;
    int64_t _256 = 0; // p
    _jump929:; // Begin body of loop
    bool _257 = false;
    int64_t _258;
    if (!_257)
    goto _jump930;
    _258 = g.d1;
    goto _jump931;
    _jump930:;
    _258 = f;
    _jump931:;
    _255 += _258;
    _256++;
    if (_256 < f)
    goto _jump929;
    // End body of loop
    if (_253 >= 0)
    goto _jump932;
    fail_assertion("negative array index");
    _jump932:;
    if (_253 < _244.d0)
    goto _jump933;
    fail_assertion("index too large");
    _jump933:;
    if (_254 >= 0)
    goto _jump934;
    fail_assertion("negative array index");
    _jump934:;
    if (_254 < _244.d1)
    goto _jump935;
    fail_assertion("index too large");
    _jump935:;
    if (_255 >= 0)
    goto _jump936;
    fail_assertion("negative array index");
    _jump936:;
    if (_255 < _244.d2)
    goto _jump937;
    fail_assertion("index too large");
    _jump937:;
    int64_t _259 = 0;
    _259 *= _244.d0;
    _259 += _253;
    _259 *= _244.d1;
    _259 += _254;
    _259 *= _244.d2;
    _259 += _255;
    int64_t _260 = _244.data[_259];
    _240.d1 = _260;
    if (_260 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _243;
    _261 *= _260;
    _261 *= sizeof(_a3__a1_int64_t);
    _240.data = jpl_alloc(_261);
    int64_t _262 = 0; // q
    int64_t _263 = 0; // p
    _jump939:; // Begin body of loop
    _a3__a1_int64_t _264;
    // Computing bound for r
    _264.d0 = _86;
    if (_86 > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    // Computing bound for s
    _264.d1 = f;
    if (f > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    // Computing bound for t
    _264.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= _86;
    _265 *= f;
    _265 *= g.d1;
    _265 *= sizeof(_a1_int64_t);
    _264.data = jpl_alloc(_265);
    int64_t _266 = 0; // t
    int64_t _267 = 0; // s
    int64_t _268 = 0; // r
    _jump943:; // Begin body of loop
    int64_t _269;
    // Computing bound for u
    if (c > 0) 
    goto _jump944;
    fail_assertion("non-positive loop bound");
    _jump944:;
    // Computing bound for v
    if (_266 > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    _269 = 0;
    int64_t _270 = 0; // v
    int64_t _271 = 0; // u
    _jump946:; // Begin body of loop
    _269 += c;
    _270++;
    if (_270 < _266)
    goto _jump946;
    _270 = 0;
    _271++;
    if (_271 < c)
    goto _jump946;
    // End body of loop
    _a1_int64_t _272;
    _272.d0 = 2;
    _272.data = jpl_alloc(sizeof(int64_t) * 2);
    _272.data[0] = d;
    _272.data[1] = _269;
    int64_t _273 = 0;
    _273 *= _264.d0;
    _273 += _268;
    _273 *= _264.d1;
    _273 += _267;
    _273 *= _264.d2;
    _273 += _266;
    _264.data[_273] = _272;
    _266++;
    if (_266 < g.d1)
    goto _jump943;
    _266 = 0;
    _267++;
    if (_267 < f)
    goto _jump943;
    _267 = 0;
    _268++;
    if (_268 < _86)
    goto _jump943;
    // End body of loop
    int64_t _274 = 0;
    _274 *= _240.d0;
    _274 += _263;
    _274 *= _240.d1;
    _274 += _262;
    _240.data[_274] = _264;
    _262++;
    if (_262 < _260)
    goto _jump939;
    _262 = 0;
    _263++;
    if (_263 < _243)
    goto _jump939;
    // End body of loop
    double _275;
    // Computing bound for p
    if (_86 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for q
    if (g.d1 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    _275 = 0;
    int64_t _276 = 0; // q
    int64_t _277 = 0; // p
    _jump949:; // Begin body of loop
    _275 += _168;
    _276++;
    if (_276 < g.d1)
    goto _jump949;
    _276 = 0;
    _277++;
    if (_277 < _86)
    goto _jump949;
    // End body of loop
    double _278 = 32.0;
    bool _279 = _275 == _278;
    bool _280 = !_279;
    int64_t _281;
    if (!_280)
    goto _jump950;
    int64_t _282 = -c;
    _281 = _282;
    goto _jump951;
    _jump950:;
    if (g.d0 >= 0)
    goto _jump952;
    fail_assertion("negative array index");
    _jump952:;
    if (g.d0 < _0.d0)
    goto _jump953;
    fail_assertion("index too large");
    _jump953:;
    if (g.d1 >= 0)
    goto _jump954;
    fail_assertion("negative array index");
    _jump954:;
    if (g.d1 < _0.d1)
    goto _jump955;
    fail_assertion("index too large");
    _jump955:;
    int64_t _283 = 0;
    _283 *= _0.d0;
    _283 += g.d0;
    _283 *= _0.d1;
    _283 += g.d1;
    int64_t _284 = _0.data[_283];
    int64_t _285 = -_284;
    _281 = _285;
    _jump951:;
    if (f >= 0)
    goto _jump956;
    fail_assertion("negative array index");
    _jump956:;
    if (f < _207.d0)
    goto _jump957;
    fail_assertion("index too large");
    _jump957:;
    int64_t _287 = 0;
    _287 *= _207.d0;
    _287 += f;
    bool _288 = _207.data[_287];
    bool _289;
    if (!_288)
    goto _jump958;
    bool _290 = g.d1 != g.d0;
    _289 = _290;
    goto _jump959;
    _jump958:;
    int64_t _291 = 559;
    bool _292 = _291 <= f;
    _289 = _292;
    _jump959:;
    bool _286 = _289;
    if (0 == _289)
    goto _jump960;
    if (g.d1 >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (g.d1 < _207.d0)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    int64_t _293 = 0;
    _293 *= _207.d0;
    _293 += g.d1;
    bool _294 = _207.data[_293];
    bool _295;
    if (!_294)
    goto _jump963;
    bool _297 = true;
    bool _296 = _297;
    if (0 != _297)
    goto _jump964;
    bool _298 = false;
    _296 = _298;
    _jump964:;
    _295 = _296;
    goto _jump965;
    _jump963:;
    bool _299 = true;
    bool _300 = false;
    bool _301 = _299 != _300;
    _295 = _301;
    _jump965:;
    _286 = _295;
    _jump960:;
    int64_t _302;
    if (!_286)
    goto _jump966;
    _302 = d;
    goto _jump967;
    _jump966:;
    _302 = g.d0;
    _jump967:;
    if (_281 >= 0)
    goto _jump968;
    fail_assertion("negative array index");
    _jump968:;
    if (_281 < _240.d0)
    goto _jump969;
    fail_assertion("index too large");
    _jump969:;
    if (_302 >= 0)
    goto _jump970;
    fail_assertion("negative array index");
    _jump970:;
    if (_302 < _240.d1)
    goto _jump971;
    fail_assertion("index too large");
    _jump971:;
    int64_t _303 = 0;
    _303 *= _240.d0;
    _303 += _281;
    _303 *= _240.d1;
    _303 += _302;
    _a3__a1_int64_t _304 = _240.data[_303];
    _239 = _304;
    goto _jump972;
    _jump918:;
    _a1__a3__a1_int64_t _305;
    // Computing bound for p
    int64_t _306 = 126;
    _305.d0 = _306;
    if (_306 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing total size of heap memory to allocate
    int64_t _307 = 1;
    _307 *= _306;
    _307 *= sizeof(_a3__a1_int64_t);
    _305.data = jpl_alloc(_307);
    int64_t _308 = 0; // p
    _jump974:; // Begin body of loop
    bool _309 = false;
    bool _310;
    if (!_309)
    goto _jump975;
    int64_t _311 = 671;
    bool _312 = _86 == _311;
    _310 = _312;
    goto _jump976;
    _jump975:;
    bool _313 = false;
    _310 = _313;
    _jump976:;
    _a3__a1_int64_t _314;
    if (!_310)
    goto _jump977;
    _a3__a1_int64_t _315;
    // Computing bound for q
    int64_t _316 = d + g.d0;
    _315.d0 = _316;
    if (_316 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for r
    int64_t _317 = 757;
    _315.d1 = _317;
    if (_317 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing bound for s
    _315.d2 = f;
    if (f > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing total size of heap memory to allocate
    int64_t _318 = 1;
    _318 *= _316;
    _318 *= _317;
    _318 *= f;
    _318 *= sizeof(_a1_int64_t);
    _315.data = jpl_alloc(_318);
    int64_t _319 = 0; // s
    int64_t _320 = 0; // r
    int64_t _321 = 0; // q
    _jump981:; // Begin body of loop
    _a1_int64_t _322;
    // Computing bound for t
    _322.d0 = _321;
    if (_321 > 0) 
    goto _jump982;
    fail_assertion("non-positive loop bound");
    _jump982:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= _321;
    _323 *= sizeof(int64_t);
    _322.data = jpl_alloc(_323);
    int64_t _324 = 0; // t
    _jump983:; // Begin body of loop
    int64_t _325 = 64;
    int64_t _326 = 0;
    _326 *= _322.d0;
    _326 += _324;
    _322.data[_326] = _325;
    _324++;
    if (_324 < _321)
    goto _jump983;
    // End body of loop
    int64_t _327 = 0;
    _327 *= _315.d0;
    _327 += _321;
    _327 *= _315.d1;
    _327 += _320;
    _327 *= _315.d2;
    _327 += _319;
    _315.data[_327] = _322;
    _319++;
    if (_319 < f)
    goto _jump981;
    _319 = 0;
    _320++;
    if (_320 < _317)
    goto _jump981;
    _320 = 0;
    _321++;
    if (_321 < _316)
    goto _jump981;
    // End body of loop
    _314 = _315;
    goto _jump984;
    _jump977:;
    _a3__a1_int64_t _328;
    // Computing bound for q
    _328.d0 = _308;
    if (_308 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    // Computing bound for r
    _328.d1 = d;
    if (d > 0) 
    goto _jump986;
    fail_assertion("non-positive loop bound");
    _jump986:;
    // Computing bound for s
    _328.d2 = _86;
    if (_86 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _308;
    _329 *= d;
    _329 *= _86;
    _329 *= sizeof(_a1_int64_t);
    _328.data = jpl_alloc(_329);
    int64_t _330 = 0; // s
    int64_t _331 = 0; // r
    int64_t _332 = 0; // q
    _jump988:; // Begin body of loop
    _a1_int64_t _333;
    // Computing bound for t
    _333.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing total size of heap memory to allocate
    int64_t _334 = 1;
    _334 *= g.d1;
    _334 *= sizeof(int64_t);
    _333.data = jpl_alloc(_334);
    int64_t _335 = 0; // t
    _jump990:; // Begin body of loop
    int64_t _336 = 0;
    _336 *= _333.d0;
    _336 += _335;
    _333.data[_336] = _86;
    _335++;
    if (_335 < g.d1)
    goto _jump990;
    // End body of loop
    int64_t _337 = 0;
    _337 *= _328.d0;
    _337 += _332;
    _337 *= _328.d1;
    _337 += _331;
    _337 *= _328.d2;
    _337 += _330;
    _328.data[_337] = _333;
    _330++;
    if (_330 < _86)
    goto _jump988;
    _330 = 0;
    _331++;
    if (_331 < d)
    goto _jump988;
    _331 = 0;
    _332++;
    if (_332 < _308)
    goto _jump988;
    // End body of loop
    _314 = _328;
    _jump984:;
    int64_t _338 = 0;
    _338 *= _305.d0;
    _338 += _308;
    _305.data[_338] = _314;
    _308++;
    if (_308 < _306)
    goto _jump974;
    // End body of loop
    int64_t _339 = d * g.d0;
    if (_339 >= 0)
    goto _jump991;
    fail_assertion("negative array index");
    _jump991:;
    if (_339 < _305.d0)
    goto _jump992;
    fail_assertion("index too large");
    _jump992:;
    int64_t _340 = 0;
    _340 *= _305.d0;
    _340 += _339;
    _a3__a1_int64_t _341 = _305.data[_340];
    _239 = _341;
    _jump972:;
    int64_t _342 = -_86;
    if (_86 >= 0)
    goto _jump993;
    fail_assertion("negative array index");
    _jump993:;
    if (_86 < _239.d0)
    goto _jump994;
    fail_assertion("index too large");
    _jump994:;
    if (_342 >= 0)
    goto _jump995;
    fail_assertion("negative array index");
    _jump995:;
    if (_342 < _239.d1)
    goto _jump996;
    fail_assertion("index too large");
    _jump996:;
    if (g.d0 >= 0)
    goto _jump997;
    fail_assertion("negative array index");
    _jump997:;
    if (g.d0 < _239.d2)
    goto _jump998;
    fail_assertion("index too large");
    _jump998:;
    int64_t _343 = 0;
    _343 *= _239.d0;
    _343 += _86;
    _343 *= _239.d1;
    _343 += _342;
    _343 *= _239.d2;
    _343 += g.d0;
    _a1_int64_t _344 = _239.data[_343];
    _a3_rgba _345 = e(c, g, j);
    return _345;
}

rgba h(_a2__a1_bool i, _a3_bool l) {
    _a3_rgba _0;
    // Computing bound for p
    int64_t _1 = 687;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    // Computing bound for q
    _0.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing bound for r
    _0.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= _1;
    _2 *= i.d1;
    _2 *= i.d1;
    _2 *= sizeof(rgba);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // r
    int64_t _4 = 0; // q
    int64_t _5 = 0; // p
    _jump1102:; // Begin body of loop
    bool _6 = false;
    rgba _7;
    if (!_6)
    goto _jump1103;
    rgba _8 = a();
    _7 = _8;
    goto _jump1104;
    _jump1103:;
    _a3_bool _9;
    // Computing bound for s
    _9.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing bound for t
    _9.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1106;
    fail_assertion("non-positive loop bound");
    _jump1106:;
    // Computing bound for u
    int64_t _10 = 820;
    _9.d2 = _10;
    if (_10 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= l.d0;
    _11 *= i.d0;
    _11 *= _10;
    _11 *= sizeof(bool);
    _9.data = jpl_alloc(_11);
    int64_t _12 = 0; // u
    int64_t _13 = 0; // t
    int64_t _14 = 0; // s
    _jump1108:; // Begin body of loop
    bool _15 = l.d1 > d;
    int64_t _16 = 0;
    _16 *= _9.d0;
    _16 += _14;
    _16 *= _9.d1;
    _16 += _13;
    _16 *= _9.d2;
    _16 += _12;
    _9.data[_16] = _15;
    _12++;
    if (_12 < _10)
    goto _jump1108;
    _12 = 0;
    _13++;
    if (_13 < i.d0)
    goto _jump1108;
    _13 = 0;
    _14++;
    if (_14 < l.d0)
    goto _jump1108;
    // End body of loop
    rgba _17 = h(i, _9);
    _7 = _17;
    _jump1104:;
    int64_t _18 = 0;
    _18 *= _0.d0;
    _18 += _5;
    _18 *= _0.d1;
    _18 += _4;
    _18 *= _0.d2;
    _18 += _3;
    _0.data[_18] = _7;
    _3++;
    if (_3 < i.d1)
    goto _jump1102;
    _3 = 0;
    _4++;
    if (_4 < i.d1)
    goto _jump1102;
    _4 = 0;
    _5++;
    if (_5 < _1)
    goto _jump1102;
    // End body of loop
    int64_t _19 = 694;
    if (l.d0 >= 0)
    goto _jump1109;
    fail_assertion("negative array index");
    _jump1109:;
    if (l.d0 < _0.d0)
    goto _jump1110;
    fail_assertion("index too large");
    _jump1110:;
    if (l.d0 >= 0)
    goto _jump1111;
    fail_assertion("negative array index");
    _jump1111:;
    if (l.d0 < _0.d1)
    goto _jump1112;
    fail_assertion("index too large");
    _jump1112:;
    if (_19 >= 0)
    goto _jump1113;
    fail_assertion("negative array index");
    _jump1113:;
    if (_19 < _0.d2)
    goto _jump1114;
    fail_assertion("index too large");
    _jump1114:;
    int64_t _20 = 0;
    _20 *= _0.d0;
    _20 += l.d0;
    _20 *= _0.d1;
    _20 += l.d0;
    _20 *= _0.d2;
    _20 += _19;
    rgba _21 = _0.data[_20];
    _a3__a2__a2__a1_bool _22;
    // Computing bound for q
    _a1_int64_t _23;
    _23.d0 = 2;
    _23.data = jpl_alloc(sizeof(int64_t) * 2);
    _23.data[0] = d;
    _23.data[1] = c;
    if (c >= 0)
    goto _jump1115;
    fail_assertion("negative array index");
    _jump1115:;
    if (c < _23.d0)
    goto _jump1116;
    fail_assertion("index too large");
    _jump1116:;
    int64_t _24 = 0;
    _24 *= _23.d0;
    _24 += c;
    int64_t _25 = _23.data[_24];
    _22.d0 = _25;
    if (_25 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for r
    _22.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    // Computing bound for s
    _22.d2 = c;
    if (c > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= _25;
    _26 *= i.d1;
    _26 *= c;
    _26 *= sizeof(_a2__a2__a1_bool);
    _22.data = jpl_alloc(_26);
    int64_t _27 = 0; // s
    int64_t _28 = 0; // r
    int64_t _29 = 0; // q
    _jump1120:; // Begin body of loop
    _a2__a2__a1_bool _30;
    // Computing bound for t
    _30.d0 = d;
    if (d > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing bound for u
    _30.d1 = _28;
    if (_28 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= d;
    _31 *= _28;
    _31 *= sizeof(_a2__a1_bool);
    _30.data = jpl_alloc(_31);
    int64_t _32 = 0; // u
    int64_t _33 = 0; // t
    _jump1123:; // Begin body of loop
    _a2__a1_bool _34;
    // Computing bound for v
    int64_t _35;
    // Computing bound for v
    if (d > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing bound for w
    if (l.d1 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    _35 = 0;
    int64_t _36 = 0; // w
    int64_t _37 = 0; // v
    _jump1126:; // Begin body of loop
    _35 += _29;
    _36++;
    if (_36 < l.d1)
    goto _jump1126;
    _36 = 0;
    _37++;
    if (_37 < d)
    goto _jump1126;
    // End body of loop
    _34.d0 = _35;
    if (_35 > 0) 
    goto _jump1127;
    fail_assertion("non-positive loop bound");
    _jump1127:;
    // Computing bound for w
    _34.d1 = c;
    if (c > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= _35;
    _38 *= c;
    _38 *= sizeof(_a1_bool);
    _34.data = jpl_alloc(_38);
    int64_t _39 = 0; // w
    int64_t _40 = 0; // v
    _jump1129:; // Begin body of loop
    _a1_bool _41;
    // Computing bound for x
    _41.d0 = c;
    if (c > 0) 
    goto _jump1130;
    fail_assertion("non-positive loop bound");
    _jump1130:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= c;
    _42 *= sizeof(bool);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // x
    _jump1131:; // Begin body of loop
    bool _44 = true;
    int64_t _45 = 0;
    _45 *= _41.d0;
    _45 += _43;
    _41.data[_45] = _44;
    _43++;
    if (_43 < c)
    goto _jump1131;
    // End body of loop
    int64_t _46 = 0;
    _46 *= _34.d0;
    _46 += _40;
    _46 *= _34.d1;
    _46 += _39;
    _34.data[_46] = _41;
    _39++;
    if (_39 < c)
    goto _jump1129;
    _39 = 0;
    _40++;
    if (_40 < _35)
    goto _jump1129;
    // End body of loop
    int64_t _47 = 0;
    _47 *= _30.d0;
    _47 += _33;
    _47 *= _30.d1;
    _47 += _32;
    _30.data[_47] = _34;
    _32++;
    if (_32 < _28)
    goto _jump1123;
    _32 = 0;
    _33++;
    if (_33 < d)
    goto _jump1123;
    // End body of loop
    int64_t _48 = 0;
    _48 *= _22.d0;
    _48 += _29;
    _48 *= _22.d1;
    _48 += _28;
    _48 *= _22.d2;
    _48 += _27;
    _22.data[_48] = _30;
    _27++;
    if (_27 < c)
    goto _jump1120;
    _27 = 0;
    _28++;
    if (_28 < i.d1)
    goto _jump1120;
    _28 = 0;
    _29++;
    if (_29 < _25)
    goto _jump1120;
    // End body of loop
    int64_t _49 = -l.d0;
    _a2_int64_t _50;
    // Computing bound for q
    int64_t _51 = -l.d2;
    int64_t _52 = l.d2 % _51;
    _50.d0 = _52;
    if (_52 > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing bound for r
    _50.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= _52;
    _53 *= i.d1;
    _53 *= sizeof(int64_t);
    _50.data = jpl_alloc(_53);
    int64_t _54 = 0; // r
    int64_t _55 = 0; // q
    _jump1134:; // Begin body of loop
    int64_t _56 = 0;
    _56 *= _50.d0;
    _56 += _55;
    _56 *= _50.d1;
    _56 += _54;
    _50.data[_56] = _55;
    _54++;
    if (_54 < i.d1)
    goto _jump1134;
    _54 = 0;
    _55++;
    if (_55 < _52)
    goto _jump1134;
    // End body of loop
    int64_t _57 = -d;
    if (_57 >= 0)
    goto _jump1135;
    fail_assertion("negative array index");
    _jump1135:;
    if (_57 < _50.d0)
    goto _jump1136;
    fail_assertion("index too large");
    _jump1136:;
    if (l.d2 >= 0)
    goto _jump1137;
    fail_assertion("negative array index");
    _jump1137:;
    if (l.d2 < _50.d1)
    goto _jump1138;
    fail_assertion("index too large");
    _jump1138:;
    int64_t _58 = 0;
    _58 *= _50.d0;
    _58 += _57;
    _58 *= _50.d1;
    _58 += l.d2;
    int64_t _59 = _50.data[_58];
    if (i.d0 >= 0)
    goto _jump1139;
    fail_assertion("negative array index");
    _jump1139:;
    if (i.d0 < _22.d0)
    goto _jump1140;
    fail_assertion("index too large");
    _jump1140:;
    if (_49 >= 0)
    goto _jump1141;
    fail_assertion("negative array index");
    _jump1141:;
    if (_49 < _22.d1)
    goto _jump1142;
    fail_assertion("index too large");
    _jump1142:;
    if (_59 >= 0)
    goto _jump1143;
    fail_assertion("negative array index");
    _jump1143:;
    if (_59 < _22.d2)
    goto _jump1144;
    fail_assertion("index too large");
    _jump1144:;
    int64_t _60 = 0;
    _60 *= _22.d0;
    _60 += i.d0;
    _60 *= _22.d1;
    _60 += _49;
    _60 *= _22.d2;
    _60 += _59;
    _a2__a2__a1_bool _61 = _22.data[_60];
    int64_t _62 = 969;
    if (i.d1 >= 0)
    goto _jump1145;
    fail_assertion("negative array index");
    _jump1145:;
    if (i.d1 < _61.d0)
    goto _jump1146;
    fail_assertion("index too large");
    _jump1146:;
    if (_62 >= 0)
    goto _jump1147;
    fail_assertion("negative array index");
    _jump1147:;
    if (_62 < _61.d1)
    goto _jump1148;
    fail_assertion("index too large");
    _jump1148:;
    int64_t _63 = 0;
    _63 *= _61.d0;
    _63 += i.d1;
    _63 *= _61.d1;
    _63 += _62;
    _a2__a1_bool _64 = _61.data[_63];
    _a1_double _65;
    // Computing bound for q
    _65.d0 = c;
    if (c > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= c;
    _66 *= sizeof(double);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // q
    _jump1150:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _65.d0;
    _68 += _67;
    _65.data[_68] = g;
    _67++;
    if (_67 < c)
    goto _jump1150;
    // End body of loop
    if (l.d0 >= 0)
    goto _jump1151;
    fail_assertion("negative array index");
    _jump1151:;
    if (l.d0 < _65.d0)
    goto _jump1152;
    fail_assertion("index too large");
    _jump1152:;
    int64_t _69 = 0;
    _69 *= _65.d0;
    _69 += l.d0;
    double _70 = _65.data[_69];
    bool _71 = i.d1 >= l.d0;
    bool _72 = !_71;
    double _73;
    if (!_72)
    goto _jump1153;
    _73 = g;
    goto _jump1154;
    _jump1153:;
    bool _74 = i.d0 > l.d2;
    double _75;
    if (!_74)
    goto _jump1155;
    double _76;
    // Computing bound for q
    int64_t _77 = 460;
    if (_77 > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    // Computing bound for r
    if (d > 0) 
    goto _jump1157;
    fail_assertion("non-positive loop bound");
    _jump1157:;
    // Computing bound for s
    if (l.d0 > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    _76 = 0;
    int64_t _78 = 0; // s
    int64_t _79 = 0; // r
    int64_t _80 = 0; // q
    _jump1159:; // Begin body of loop
    _76 += g;
    _78++;
    if (_78 < l.d0)
    goto _jump1159;
    _78 = 0;
    _79++;
    if (_79 < d)
    goto _jump1159;
    _79 = 0;
    _80++;
    if (_80 < _77)
    goto _jump1159;
    // End body of loop
    _75 = _76;
    goto _jump1160;
    _jump1155:;
    double _81 = -g;
    _75 = _81;
    _jump1160:;
    _73 = _75;
    _jump1154:;
    double _82 = _70 / _73;
    double _83;
    // Computing bound for q
    if (l.d1 > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    _83 = 0;
    int64_t _84 = 0; // q
    _jump1162:; // Begin body of loop
    int64_t _85 = 796;
    int64_t _86 = _84 * _84;
    bool _87 = _85 >= _86;
    double _88;
    if (!_87)
    goto _jump1163;
    double _89 = 84.0;
    _88 = _89;
    goto _jump1164;
    _jump1163:;
    _88 = g;
    _jump1164:;
    _83 += _88;
    _84++;
    if (_84 < l.d1)
    goto _jump1162;
    // End body of loop
    bool _90 = _82 == _83;
    _a3_bool _91;
    if (!_90)
    goto _jump1165;
    _91 = l;
    goto _jump1166;
    _jump1165:;
    bool _92 = true;
    bool _93;
    if (!_92)
    goto _jump1167;
    double _94;
    // Computing bound for q
    if (l.d0 > 0) 
    goto _jump1168;
    fail_assertion("non-positive loop bound");
    _jump1168:;
    // Computing bound for r
    if (i.d1 > 0) 
    goto _jump1169;
    fail_assertion("non-positive loop bound");
    _jump1169:;
    _94 = 0;
    int64_t _95 = 0; // r
    int64_t _96 = 0; // q
    _jump1170:; // Begin body of loop
    double _97 = 14.0;
    _94 += _97;
    _95++;
    if (_95 < i.d1)
    goto _jump1170;
    _95 = 0;
    _96++;
    if (_96 < l.d0)
    goto _jump1170;
    // End body of loop
    double _98 = 71.0;
    bool _99 = _94 <= _98;
    _93 = _99;
    goto _jump1171;
    _jump1167:;
    bool _100 = l.d0 != l.d2;
    _93 = _100;
    _jump1171:;
    bool _101;
    if (!_93)
    goto _jump1172;
    bool _102 = true;
    int64_t _103;
    if (!_102)
    goto _jump1173;
    _103 = i.d0;
    goto _jump1174;
    _jump1173:;
    _103 = l.d0;
    _jump1174:;
    bool _104 = _103 > c;
    bool _105 = !_104;
    _101 = _105;
    goto _jump1175;
    _jump1172:;
    int64_t _106;
    // Computing bound for q
    if (l.d2 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    _106 = 0;
    int64_t _107 = 0; // q
    _jump1177:; // Begin body of loop
    _106 += l.d0;
    _107++;
    if (_107 < l.d2)
    goto _jump1177;
    // End body of loop
    int64_t _108 = 348;
    int64_t _109 = _108 - i.d0;
    int64_t _110 = _106 - _109;
    bool _111 = _110 <= c;
    _101 = _111;
    _jump1175:;
    _a3_bool _112;
    if (!_101)
    goto _jump1178;
    _a1_bool _114;
    // Computing bound for q
    _114.d0 = c;
    if (c > 0) 
    goto _jump1179;
    fail_assertion("non-positive loop bound");
    _jump1179:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= c;
    _115 *= sizeof(bool);
    _114.data = jpl_alloc(_115);
    int64_t _116 = 0; // q
    _jump1180:; // Begin body of loop
    bool _117 = true;
    int64_t _118 = 0;
    _118 *= _114.d0;
    _118 += _116;
    _114.data[_118] = _117;
    _116++;
    if (_116 < c)
    goto _jump1180;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump1181;
    fail_assertion("negative array index");
    _jump1181:;
    if (i.d0 < _114.d0)
    goto _jump1182;
    fail_assertion("index too large");
    _jump1182:;
    int64_t _119 = 0;
    _119 *= _114.d0;
    _119 += i.d0;
    bool _120 = _114.data[_119];
    bool _113 = _120;
    if (0 == _120)
    goto _jump1183;
    bool _121 = true;
    _113 = _121;
    _jump1183:;
    _a3_bool _122;
    if (!_113)
    goto _jump1184;
    int64_t _123 = 790;
    bool _124 = c >= _123;
    bool _125 = !_124;
    _a3_bool _126;
    if (!_125)
    goto _jump1185;
    _126 = l;
    goto _jump1186;
    _jump1185:;
    _a3_bool _127;
    // Computing bound for q
    _127.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    // Computing bound for r
    _127.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    // Computing bound for s
    _127.d2 = l.d0;
    if (l.d0 > 0) 
    goto _jump1189;
    fail_assertion("non-positive loop bound");
    _jump1189:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= i.d1;
    _128 *= i.d1;
    _128 *= l.d0;
    _128 *= sizeof(bool);
    _127.data = jpl_alloc(_128);
    int64_t _129 = 0; // s
    int64_t _130 = 0; // r
    int64_t _131 = 0; // q
    _jump1190:; // Begin body of loop
    double _132 = 40.0;
    bool _133 = _132 > g;
    int64_t _134 = 0;
    _134 *= _127.d0;
    _134 += _131;
    _134 *= _127.d1;
    _134 += _130;
    _134 *= _127.d2;
    _134 += _129;
    _127.data[_134] = _133;
    _129++;
    if (_129 < l.d0)
    goto _jump1190;
    _129 = 0;
    _130++;
    if (_130 < i.d1)
    goto _jump1190;
    _130 = 0;
    _131++;
    if (_131 < i.d1)
    goto _jump1190;
    // End body of loop
    _126 = _127;
    _jump1186:;
    _122 = _126;
    goto _jump1191;
    _jump1184:;
    _122 = l;
    _jump1191:;
    _112 = _122;
    goto _jump1192;
    _jump1178:;
    double _135 = 29.0;
    double _136 = fmod(g, g);
    bool _137 = _135 > _136;
    _a3_bool _138;
    if (!_137)
    goto _jump1193;
    _a3__a3_bool _139;
    // Computing bound for q
    _139.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1194;
    fail_assertion("non-positive loop bound");
    _jump1194:;
    // Computing bound for r
    int64_t _140 = 285;
    int64_t _141 = -_140;
    _139.d1 = _141;
    if (_141 > 0) 
    goto _jump1195;
    fail_assertion("non-positive loop bound");
    _jump1195:;
    // Computing bound for s
    int64_t _142;
    // Computing bound for q
    if (l.d1 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for r
    if (l.d0 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing bound for s
    if (l.d2 > 0) 
    goto _jump1198;
    fail_assertion("non-positive loop bound");
    _jump1198:;
    _142 = 0;
    int64_t _143 = 0; // s
    int64_t _144 = 0; // r
    int64_t _145 = 0; // q
    _jump1199:; // Begin body of loop
    _142 += _145;
    _143++;
    if (_143 < l.d2)
    goto _jump1199;
    _143 = 0;
    _144++;
    if (_144 < l.d0)
    goto _jump1199;
    _144 = 0;
    _145++;
    if (_145 < l.d1)
    goto _jump1199;
    // End body of loop
    _139.d2 = _142;
    if (_142 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= i.d1;
    _146 *= _141;
    _146 *= _142;
    _146 *= sizeof(_a3_bool);
    _139.data = jpl_alloc(_146);
    int64_t _147 = 0; // s
    int64_t _148 = 0; // r
    int64_t _149 = 0; // q
    _jump1201:; // Begin body of loop
    _a3_bool _150;
    // Computing bound for t
    _150.d0 = _147;
    if (_147 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for u
    _150.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing bound for v
    _150.d2 = l.d2;
    if (l.d2 > 0) 
    goto _jump1204;
    fail_assertion("non-positive loop bound");
    _jump1204:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= _147;
    _151 *= i.d0;
    _151 *= l.d2;
    _151 *= sizeof(bool);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // v
    int64_t _153 = 0; // u
    int64_t _154 = 0; // t
    _jump1205:; // Begin body of loop
    bool _155 = true;
    int64_t _156 = 0;
    _156 *= _150.d0;
    _156 += _154;
    _156 *= _150.d1;
    _156 += _153;
    _156 *= _150.d2;
    _156 += _152;
    _150.data[_156] = _155;
    _152++;
    if (_152 < l.d2)
    goto _jump1205;
    _152 = 0;
    _153++;
    if (_153 < i.d0)
    goto _jump1205;
    _153 = 0;
    _154++;
    if (_154 < _147)
    goto _jump1205;
    // End body of loop
    int64_t _157 = 0;
    _157 *= _139.d0;
    _157 += _149;
    _157 *= _139.d1;
    _157 += _148;
    _157 *= _139.d2;
    _157 += _147;
    _139.data[_157] = _150;
    _147++;
    if (_147 < _142)
    goto _jump1201;
    _147 = 0;
    _148++;
    if (_148 < _141)
    goto _jump1201;
    _148 = 0;
    _149++;
    if (_149 < i.d1)
    goto _jump1201;
    // End body of loop
    bool _158 = false;
    bool _159 = true;
    bool _160 = _158 != _159;
    int64_t _161;
    if (!_160)
    goto _jump1206;
    _161 = c;
    goto _jump1207;
    _jump1206:;
    _161 = l.d0;
    _jump1207:;
    if (c >= 0)
    goto _jump1208;
    fail_assertion("negative array index");
    _jump1208:;
    if (c < _139.d0)
    goto _jump1209;
    fail_assertion("index too large");
    _jump1209:;
    if (_161 >= 0)
    goto _jump1210;
    fail_assertion("negative array index");
    _jump1210:;
    if (_161 < _139.d1)
    goto _jump1211;
    fail_assertion("index too large");
    _jump1211:;
    if (i.d0 >= 0)
    goto _jump1212;
    fail_assertion("negative array index");
    _jump1212:;
    if (i.d0 < _139.d2)
    goto _jump1213;
    fail_assertion("index too large");
    _jump1213:;
    int64_t _162 = 0;
    _162 *= _139.d0;
    _162 += c;
    _162 *= _139.d1;
    _162 += _161;
    _162 *= _139.d2;
    _162 += i.d0;
    _a3_bool _163 = _139.data[_162];
    _138 = _163;
    goto _jump1214;
    _jump1193:;
    _a3_bool _164;
    // Computing bound for q
    bool _165 = false;
    int64_t _166;
    if (!_165)
    goto _jump1215;
    _166 = i.d1;
    goto _jump1216;
    _jump1215:;
    _166 = d;
    _jump1216:;
    int64_t _167 = -_166;
    _164.d0 = _167;
    if (_167 > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    // Computing bound for r
    if (l.d2 >= 0)
    goto _jump1218;
    fail_assertion("negative array index");
    _jump1218:;
    if (l.d2 < b.d0)
    goto _jump1219;
    fail_assertion("index too large");
    _jump1219:;
    if (l.d2 >= 0)
    goto _jump1220;
    fail_assertion("negative array index");
    _jump1220:;
    if (l.d2 < b.d1)
    goto _jump1221;
    fail_assertion("index too large");
    _jump1221:;
    int64_t _168 = 0;
    _168 *= b.d0;
    _168 += l.d2;
    _168 *= b.d1;
    _168 += l.d2;
    int64_t _169 = b.data[_168];
    _164.d1 = _169;
    if (_169 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for s
    int64_t _170 = -l.d0;
    int64_t _171 = -_170;
    _164.d2 = _171;
    if (_171 > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= _167;
    _172 *= _169;
    _172 *= _171;
    _172 *= sizeof(bool);
    _164.data = jpl_alloc(_172);
    int64_t _173 = 0; // s
    int64_t _174 = 0; // r
    int64_t _175 = 0; // q
    _jump1224:; // Begin body of loop
    bool _177 = true;
    bool _178 = !_177;
    bool _176 = _178;
    if (0 != _178)
    goto _jump1225;
    bool _179 = false;
    bool _180 = !_179;
    _176 = _180;
    _jump1225:;
    int64_t _181 = 0;
    _181 *= _164.d0;
    _181 += _175;
    _181 *= _164.d1;
    _181 += _174;
    _181 *= _164.d2;
    _181 += _173;
    _164.data[_181] = _176;
    _173++;
    if (_173 < _171)
    goto _jump1224;
    _173 = 0;
    _174++;
    if (_174 < _169)
    goto _jump1224;
    _174 = 0;
    _175++;
    if (_175 < _167)
    goto _jump1224;
    // End body of loop
    _138 = _164;
    _jump1214:;
    _112 = _138;
    _jump1192:;
    _91 = _112;
    _jump1166:;
    rgba _182 = h(_64, _91);
    bool _184 = true;
    bool _183 = _184;
    if (0 != _184)
    goto _jump1226;
    bool _185 = true;
    _183 = _185;
    _jump1226:;
    bool _186;
    if (!_183)
    goto _jump1227;
    _a3_bool _187;
    // Computing bound for r
    _187.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    // Computing bound for s
    _187.d1 = c;
    if (c > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    // Computing bound for t
    _187.d2 = l.d0;
    if (l.d0 > 0) 
    goto _jump1230;
    fail_assertion("non-positive loop bound");
    _jump1230:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= i.d0;
    _188 *= c;
    _188 *= l.d0;
    _188 *= sizeof(bool);
    _187.data = jpl_alloc(_188);
    int64_t _189 = 0; // t
    int64_t _190 = 0; // s
    int64_t _191 = 0; // r
    _jump1231:; // Begin body of loop
    bool _192 = true;
    int64_t _193 = 0;
    _193 *= _187.d0;
    _193 += _191;
    _193 *= _187.d1;
    _193 += _190;
    _193 *= _187.d2;
    _193 += _189;
    _187.data[_193] = _192;
    _189++;
    if (_189 < l.d0)
    goto _jump1231;
    _189 = 0;
    _190++;
    if (_190 < c)
    goto _jump1231;
    _190 = 0;
    _191++;
    if (_191 < i.d0)
    goto _jump1231;
    // End body of loop
    int64_t _194;
    // Computing bound for r
    if (i.d1 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    _194 = 0;
    int64_t _195 = 0; // r
    _jump1233:; // Begin body of loop
    _194 += l.d2;
    _195++;
    if (_195 < i.d1)
    goto _jump1233;
    // End body of loop
    _a3_int64_t _196;
    // Computing bound for r
    _196.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing bound for s
    _196.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1235;
    fail_assertion("non-positive loop bound");
    _jump1235:;
    // Computing bound for t
    _196.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= i.d1;
    _197 *= l.d0;
    _197 *= i.d1;
    _197 *= sizeof(int64_t);
    _196.data = jpl_alloc(_197);
    int64_t _198 = 0; // t
    int64_t _199 = 0; // s
    int64_t _200 = 0; // r
    _jump1237:; // Begin body of loop
    int64_t _201 = 0;
    _201 *= _196.d0;
    _201 += _200;
    _201 *= _196.d1;
    _201 += _199;
    _201 *= _196.d2;
    _201 += _198;
    _196.data[_201] = l.d1;
    _198++;
    if (_198 < i.d1)
    goto _jump1237;
    _198 = 0;
    _199++;
    if (_199 < l.d0)
    goto _jump1237;
    _199 = 0;
    _200++;
    if (_200 < i.d1)
    goto _jump1237;
    // End body of loop
    if (l.d1 >= 0)
    goto _jump1238;
    fail_assertion("negative array index");
    _jump1238:;
    if (l.d1 < _196.d0)
    goto _jump1239;
    fail_assertion("index too large");
    _jump1239:;
    if (l.d2 >= 0)
    goto _jump1240;
    fail_assertion("negative array index");
    _jump1240:;
    if (l.d2 < _196.d1)
    goto _jump1241;
    fail_assertion("index too large");
    _jump1241:;
    if (l.d1 >= 0)
    goto _jump1242;
    fail_assertion("negative array index");
    _jump1242:;
    if (l.d1 < _196.d2)
    goto _jump1243;
    fail_assertion("index too large");
    _jump1243:;
    int64_t _202 = 0;
    _202 *= _196.d0;
    _202 += l.d1;
    _202 *= _196.d1;
    _202 += l.d2;
    _202 *= _196.d2;
    _202 += l.d1;
    int64_t _203 = _196.data[_202];
    if (_194 >= 0)
    goto _jump1244;
    fail_assertion("negative array index");
    _jump1244:;
    if (_194 < _187.d0)
    goto _jump1245;
    fail_assertion("index too large");
    _jump1245:;
    if (l.d1 >= 0)
    goto _jump1246;
    fail_assertion("negative array index");
    _jump1246:;
    if (l.d1 < _187.d1)
    goto _jump1247;
    fail_assertion("index too large");
    _jump1247:;
    if (_203 >= 0)
    goto _jump1248;
    fail_assertion("negative array index");
    _jump1248:;
    if (_203 < _187.d2)
    goto _jump1249;
    fail_assertion("index too large");
    _jump1249:;
    int64_t _204 = 0;
    _204 *= _187.d0;
    _204 += _194;
    _204 *= _187.d1;
    _204 += l.d1;
    _204 *= _187.d2;
    _204 += _203;
    bool _205 = _187.data[_204];
    _186 = _205;
    goto _jump1250;
    _jump1227:;
    _a2_bool _206;
    // Computing bound for r
    _206.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    // Computing bound for s
    _206.d1 = d;
    if (d > 0) 
    goto _jump1252;
    fail_assertion("non-positive loop bound");
    _jump1252:;
    // Computing total size of heap memory to allocate
    int64_t _207 = 1;
    _207 *= l.d0;
    _207 *= d;
    _207 *= sizeof(bool);
    _206.data = jpl_alloc(_207);
    int64_t _208 = 0; // s
    int64_t _209 = 0; // r
    _jump1253:; // Begin body of loop
    bool _210 = false;
    int64_t _211 = 0;
    _211 *= _206.d0;
    _211 += _209;
    _211 *= _206.d1;
    _211 += _208;
    _206.data[_211] = _210;
    _208++;
    if (_208 < d)
    goto _jump1253;
    _208 = 0;
    _209++;
    if (_209 < l.d0)
    goto _jump1253;
    // End body of loop
    int64_t _212 = c / d;
    if (c >= 0)
    goto _jump1254;
    fail_assertion("negative array index");
    _jump1254:;
    if (c < _206.d0)
    goto _jump1255;
    fail_assertion("index too large");
    _jump1255:;
    if (_212 >= 0)
    goto _jump1256;
    fail_assertion("negative array index");
    _jump1256:;
    if (_212 < _206.d1)
    goto _jump1257;
    fail_assertion("index too large");
    _jump1257:;
    int64_t _213 = 0;
    _213 *= _206.d0;
    _213 += c;
    _213 *= _206.d1;
    _213 += _212;
    bool _214 = _206.data[_213];
    bool _215 = !_214;
    _186 = _215;
    _jump1250:;
    rgba _216;
    if (!_186)
    goto _jump1258;
    rgba _217 = a();
    _216 = _217;
    goto _jump1259;
    _jump1258:;
    bool _218 = false;
    rgba _219;
    if (!_218)
    goto _jump1260;
    bool _221 = true;
    bool _220 = _221;
    if (0 != _221)
    goto _jump1261;
    bool _222 = true;
    _220 = _222;
    _jump1261:;
    rgba _223;
    if (!_220)
    goto _jump1262;
    rgba _224 = a();
    _223 = _224;
    goto _jump1263;
    _jump1262:;
    _223 = _182;
    _jump1263:;
    _219 = _223;
    goto _jump1264;
    _jump1260:;
    _219 = _21;
    _jump1264:;
    _216 = _219;
    _jump1259:;
    double _225 = _216.g;
    double _226 = -g;
    double _227;
    // Computing bound for r
    int64_t _228 = 239;
    if (_228 > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    _227 = 0;
    int64_t _229 = 0; // r
    _jump1266:; // Begin body of loop
    double _230;
    // Computing bound for s
    if (_229 > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    _230 = 0;
    int64_t _231 = 0; // s
    _jump1268:; // Begin body of loop
    double _232 = 81.0;
    _230 += _232;
    _231++;
    if (_231 < _229)
    goto _jump1268;
    // End body of loop
    _227 += _230;
    _229++;
    if (_229 < _228)
    goto _jump1266;
    // End body of loop
    bool _233 = _226 <= _227;
    bool _234 = !_233;
    double _235;
    if (!_234)
    goto _jump1269;
    _a2_bool _236;
    // Computing bound for r
    _236.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    // Computing bound for s
    _236.d1 = l.d2;
    if (l.d2 > 0) 
    goto _jump1271;
    fail_assertion("non-positive loop bound");
    _jump1271:;
    // Computing total size of heap memory to allocate
    int64_t _237 = 1;
    _237 *= i.d1;
    _237 *= l.d2;
    _237 *= sizeof(bool);
    _236.data = jpl_alloc(_237);
    int64_t _238 = 0; // s
    int64_t _239 = 0; // r
    _jump1272:; // Begin body of loop
    bool _240 = false;
    int64_t _241 = 0;
    _241 *= _236.d0;
    _241 += _239;
    _241 *= _236.d1;
    _241 += _238;
    _236.data[_241] = _240;
    _238++;
    if (_238 < l.d2)
    goto _jump1272;
    _238 = 0;
    _239++;
    if (_239 < i.d1)
    goto _jump1272;
    // End body of loop
    int64_t _242;
    // Computing bound for r
    if (l.d1 > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing bound for s
    if (l.d1 > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    _242 = 0;
    int64_t _243 = 0; // s
    int64_t _244 = 0; // r
    _jump1275:; // Begin body of loop
    _242 += i.d0;
    _243++;
    if (_243 < l.d1)
    goto _jump1275;
    _243 = 0;
    _244++;
    if (_244 < l.d1)
    goto _jump1275;
    // End body of loop
    if (i.d1 >= 0)
    goto _jump1276;
    fail_assertion("negative array index");
    _jump1276:;
    if (i.d1 < _236.d0)
    goto _jump1277;
    fail_assertion("index too large");
    _jump1277:;
    if (_242 >= 0)
    goto _jump1278;
    fail_assertion("negative array index");
    _jump1278:;
    if (_242 < _236.d1)
    goto _jump1279;
    fail_assertion("index too large");
    _jump1279:;
    int64_t _245 = 0;
    _245 *= _236.d0;
    _245 += i.d1;
    _245 *= _236.d1;
    _245 += _242;
    bool _246 = _236.data[_245];
    double _247;
    if (!_246)
    goto _jump1280;
    double _248 = _21.r;
    _247 = _248;
    goto _jump1281;
    _jump1280:;
    double _249 = 40.0;
    _247 = _249;
    _jump1281:;
    double _250 = _182.g;
    double _251 = fmod(_247, _250);
    _235 = _251;
    goto _jump1282;
    _jump1269:;
    _a2_double _252;
    // Computing bound for r
    _252.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for s
    int64_t _253 = 604;
    _252.d1 = _253;
    if (_253 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= i.d1;
    _254 *= _253;
    _254 *= sizeof(double);
    _252.data = jpl_alloc(_254);
    int64_t _255 = 0; // s
    int64_t _256 = 0; // r
    _jump1285:; // Begin body of loop
    double _257 = _182.g;
    int64_t _258 = 0;
    _258 *= _252.d0;
    _258 += _256;
    _258 *= _252.d1;
    _258 += _255;
    _252.data[_258] = _257;
    _255++;
    if (_255 < _253)
    goto _jump1285;
    _255 = 0;
    _256++;
    if (_256 < i.d1)
    goto _jump1285;
    // End body of loop
    if (l.d0 >= 0)
    goto _jump1286;
    fail_assertion("negative array index");
    _jump1286:;
    if (l.d0 < _252.d0)
    goto _jump1287;
    fail_assertion("index too large");
    _jump1287:;
    if (d >= 0)
    goto _jump1288;
    fail_assertion("negative array index");
    _jump1288:;
    if (d < _252.d1)
    goto _jump1289;
    fail_assertion("index too large");
    _jump1289:;
    int64_t _259 = 0;
    _259 *= _252.d0;
    _259 += l.d0;
    _259 *= _252.d1;
    _259 += d;
    double _260 = _252.data[_259];
    _235 = _260;
    _jump1282:;
    double _261;
    // Computing bound for r
    if (l.d2 > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing bound for s
    if (i.d1 > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    _261 = 0;
    int64_t _262 = 0; // s
    int64_t _263 = 0; // r
    _jump1292:; // Begin body of loop
    bool _264 = false;
    _a3_bool _265;
    if (!_264)
    goto _jump1293;
    _265 = l;
    goto _jump1294;
    _jump1293:;
    _265 = l;
    _jump1294:;
    rgba _266 = h(i, _265);
    double _267 = _266.b;
    _261 += _267;
    _262++;
    if (_262 < i.d1)
    goto _jump1292;
    _262 = 0;
    _263++;
    if (_263 < l.d2)
    goto _jump1292;
    // End body of loop
    double _268 = _235 + _261;
    bool _269 = _225 <= _268;
    _a1_rgba _270;
    // Computing bound for s
    _270.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= l.d1;
    _271 *= sizeof(rgba);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // s
    _jump1296:; // Begin body of loop
    int64_t _273 = 0;
    _273 *= _270.d0;
    _273 += _272;
    _270.data[_273] = _21;
    _272++;
    if (_272 < l.d1)
    goto _jump1296;
    // End body of loop
    double _274 = -g;
    double _275 = 18.0;
    double _276;
    // Computing bound for s
    if (i.d0 > 0) 
    goto _jump1297;
    fail_assertion("non-positive loop bound");
    _jump1297:;
    _276 = 0;
    int64_t _277 = 0; // s
    _jump1298:; // Begin body of loop
    rgba _278 = h(i, l);
    double _279 = _278.a;
    _276 += _279;
    _277++;
    if (_277 < i.d0)
    goto _jump1298;
    // End body of loop
    rgba _280 = { _274, g, _275, _276 };
    _a1_rgba _281;
    _281.d0 = 2;
    _281.data = jpl_alloc(sizeof(rgba) * 2);
    _281.data[0] = _280;
    _281.data[1] = _21;
    _a1__a1_rgba _282;
    _282.d0 = 2;
    _282.data = jpl_alloc(sizeof(_a1_rgba) * 2);
    _282.data[0] = _270;
    _282.data[1] = _281;
    bool _283 = l.d2 >= l.d2;
    int64_t _284;
    if (!_283)
    goto _jump1299;
    _284 = i.d1;
    goto _jump1300;
    _jump1299:;
    int64_t _285 = -l.d0;
    _284 = _285;
    _jump1300:;
    int64_t _286 = -_284;
    if (_286 >= 0)
    goto _jump1301;
    fail_assertion("negative array index");
    _jump1301:;
    if (_286 < _282.d0)
    goto _jump1302;
    fail_assertion("index too large");
    _jump1302:;
    int64_t _287 = 0;
    _287 *= _282.d0;
    _287 += _286;
    _a1_rgba _288 = _282.data[_287];
    _a1_int64_t _289;
    // Computing bound for u
    int64_t _290 = -l.d1;
    _289.d0 = _290;
    if (_290 > 0) 
    goto _jump1303;
    fail_assertion("non-positive loop bound");
    _jump1303:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= _290;
    _291 *= sizeof(int64_t);
    _289.data = jpl_alloc(_291);
    int64_t _292 = 0; // u
    _jump1304:; // Begin body of loop
    int64_t _293 = 0;
    _293 *= _289.d0;
    _293 += _292;
    _289.data[_293] = _292;
    _292++;
    if (_292 < _290)
    goto _jump1304;
    // End body of loop
    if (l.d2 >= 0)
    goto _jump1305;
    fail_assertion("negative array index");
    _jump1305:;
    if (l.d2 < _289.d0)
    goto _jump1306;
    fail_assertion("index too large");
    _jump1306:;
    int64_t _294 = 0;
    _294 *= _289.d0;
    _294 += l.d2;
    int64_t _295 = _289.data[_294];
    _a3_int64_t _296;
    // Computing bound for u
    int64_t _297 = 129;
    _296.d0 = _297;
    if (_297 > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing bound for v
    _296.d1 = c;
    if (c > 0) 
    goto _jump1308;
    fail_assertion("non-positive loop bound");
    _jump1308:;
    // Computing bound for w
    _296.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump1309;
    fail_assertion("non-positive loop bound");
    _jump1309:;
    // Computing total size of heap memory to allocate
    int64_t _298 = 1;
    _298 *= _297;
    _298 *= c;
    _298 *= i.d1;
    _298 *= sizeof(int64_t);
    _296.data = jpl_alloc(_298);
    int64_t _299 = 0; // w
    int64_t _300 = 0; // v
    int64_t _301 = 0; // u
    _jump1310:; // Begin body of loop
    int64_t _302 = 0;
    _302 *= _296.d0;
    _302 += _301;
    _302 *= _296.d1;
    _302 += _300;
    _302 *= _296.d2;
    _302 += _299;
    _296.data[_302] = l.d2;
    _299++;
    if (_299 < i.d1)
    goto _jump1310;
    _299 = 0;
    _300++;
    if (_300 < c)
    goto _jump1310;
    _300 = 0;
    _301++;
    if (_301 < _297)
    goto _jump1310;
    // End body of loop
    int64_t _303 = 641;
    if (_303 >= 0)
    goto _jump1311;
    fail_assertion("negative array index");
    _jump1311:;
    if (_303 < _296.d0)
    goto _jump1312;
    fail_assertion("index too large");
    _jump1312:;
    if (_288.d0 >= 0)
    goto _jump1313;
    fail_assertion("negative array index");
    _jump1313:;
    if (_288.d0 < _296.d1)
    goto _jump1314;
    fail_assertion("index too large");
    _jump1314:;
    if (l.d0 >= 0)
    goto _jump1315;
    fail_assertion("negative array index");
    _jump1315:;
    if (l.d0 < _296.d2)
    goto _jump1316;
    fail_assertion("index too large");
    _jump1316:;
    int64_t _304 = 0;
    _304 *= _296.d0;
    _304 += _303;
    _304 *= _296.d1;
    _304 += _288.d0;
    _304 *= _296.d2;
    _304 += l.d0;
    int64_t _305 = _296.data[_304];
    int64_t _306 = -_305;
    int64_t _307 = -_306;
    bool _308 = _295 <= _307;
    _a3_rgba _309;
    if (!_308)
    goto _jump1317;
    _a3_rgba _310;
    // Computing bound for u
    _310.d0 = l.d2;
    if (l.d2 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for v
    _310.d1 = _288.d0;
    if (_288.d0 > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    // Computing bound for w
    _310.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump1320;
    fail_assertion("non-positive loop bound");
    _jump1320:;
    // Computing total size of heap memory to allocate
    int64_t _311 = 1;
    _311 *= l.d2;
    _311 *= _288.d0;
    _311 *= i.d1;
    _311 *= sizeof(rgba);
    _310.data = jpl_alloc(_311);
    int64_t _312 = 0; // w
    int64_t _313 = 0; // v
    int64_t _314 = 0; // u
    _jump1321:; // Begin body of loop
    rgba _315 = a();
    double _316 = _315.b;
    double _317 = 14.0;
    bool _318 = _316 != _317;
    rgba _319;
    if (!_318)
    goto _jump1322;
    _a2__a1_bool _320;
    // Computing bound for x
    int64_t _321 = 674;
    _320.d0 = _321;
    if (_321 > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    // Computing bound for y
    _320.d1 = _314;
    if (_314 > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing total size of heap memory to allocate
    int64_t _322 = 1;
    _322 *= _321;
    _322 *= _314;
    _322 *= sizeof(_a1_bool);
    _320.data = jpl_alloc(_322);
    int64_t _323 = 0; // y
    int64_t _324 = 0; // x
    _jump1325:; // Begin body of loop
    bool _325 = true;
    bool _326 = true;
    bool _327 = false;
    _a1_bool _328;
    _328.d0 = 3;
    _328.data = jpl_alloc(sizeof(bool) * 3);
    _328.data[0] = _325;
    _328.data[1] = _326;
    _328.data[2] = _327;
    int64_t _329 = 0;
    _329 *= _320.d0;
    _329 += _324;
    _329 *= _320.d1;
    _329 += _323;
    _320.data[_329] = _328;
    _323++;
    if (_323 < _314)
    goto _jump1325;
    _323 = 0;
    _324++;
    if (_324 < _321)
    goto _jump1325;
    // End body of loop
    _a3_bool _330;
    // Computing bound for x
    int64_t _331;
    // Computing bound for x
    int64_t _332 = 836;
    if (_332 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    _331 = 0;
    int64_t _333 = 0; // x
    _jump1327:; // Begin body of loop
    _331 += _312;
    _333++;
    if (_333 < _332)
    goto _jump1327;
    // End body of loop
    _330.d0 = _331;
    if (_331 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    // Computing bound for y
    _330.d1 = l.d1;
    if (l.d1 > 0) 
    goto _jump1329;
    fail_assertion("non-positive loop bound");
    _jump1329:;
    // Computing bound for z
    _330.d2 = l.d1;
    if (l.d1 > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    // Computing total size of heap memory to allocate
    int64_t _334 = 1;
    _334 *= _331;
    _334 *= l.d1;
    _334 *= l.d1;
    _334 *= sizeof(bool);
    _330.data = jpl_alloc(_334);
    int64_t _335 = 0; // z
    int64_t _336 = 0; // y
    int64_t _337 = 0; // x
    _jump1331:; // Begin body of loop
    int64_t _338 = 0;
    _338 *= _330.d0;
    _338 += _337;
    _338 *= _330.d1;
    _338 += _336;
    _338 *= _330.d2;
    _338 += _335;
    _330.data[_338] = _269;
    _335++;
    if (_335 < l.d1)
    goto _jump1331;
    _335 = 0;
    _336++;
    if (_336 < l.d1)
    goto _jump1331;
    _336 = 0;
    _337++;
    if (_337 < _331)
    goto _jump1331;
    // End body of loop
    rgba _339 = h(_320, _330);
    _319 = _339;
    goto _jump1332;
    _jump1322:;
    _319 = _21;
    _jump1332:;
    int64_t _340 = 0;
    _340 *= _310.d0;
    _340 += _314;
    _340 *= _310.d1;
    _340 += _313;
    _340 *= _310.d2;
    _340 += _312;
    _310.data[_340] = _319;
    _312++;
    if (_312 < i.d1)
    goto _jump1321;
    _312 = 0;
    _313++;
    if (_313 < _288.d0)
    goto _jump1321;
    _313 = 0;
    _314++;
    if (_314 < l.d2)
    goto _jump1321;
    // End body of loop
    _309 = _310;
    goto _jump1333;
    _jump1317:;
    bool _341 = true;
    bool _342 = !_341;
    _a3_rgba _343;
    if (!_342)
    goto _jump1334;
    bool _344 = false;
    _a3_rgba _345;
    if (!_344)
    goto _jump1335;
    bool _346 = _269;
    if (0 != _269)
    goto _jump1336;
    _346 = _269;
    _jump1336:;
    bool _347;
    if (!_346)
    goto _jump1337;
    _347 = _269;
    goto _jump1338;
    _jump1337:;
    bool _348 = false;
    _347 = _348;
    _jump1338:;
    _a3_rgba _349;
    if (!_347)
    goto _jump1339;
    _a3_rgba _350;
    // Computing bound for u
    _350.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1340;
    fail_assertion("non-positive loop bound");
    _jump1340:;
    // Computing bound for v
    _350.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1341;
    fail_assertion("non-positive loop bound");
    _jump1341:;
    // Computing bound for w
    bool _351 = true;
    int64_t _352;
    if (!_351)
    goto _jump1342;
    _352 = i.d0;
    goto _jump1343;
    _jump1342:;
    _352 = i.d1;
    _jump1343:;
    _350.d2 = _352;
    if (_352 > 0) 
    goto _jump1344;
    fail_assertion("non-positive loop bound");
    _jump1344:;
    // Computing total size of heap memory to allocate
    int64_t _353 = 1;
    _353 *= i.d0;
    _353 *= i.d1;
    _353 *= _352;
    _353 *= sizeof(rgba);
    _350.data = jpl_alloc(_353);
    int64_t _354 = 0; // w
    int64_t _355 = 0; // v
    int64_t _356 = 0; // u
    _jump1345:; // Begin body of loop
    int64_t _357 = 0;
    _357 *= _350.d0;
    _357 += _356;
    _357 *= _350.d1;
    _357 += _355;
    _357 *= _350.d2;
    _357 += _354;
    _350.data[_357] = _182;
    _354++;
    if (_354 < _352)
    goto _jump1345;
    _354 = 0;
    _355++;
    if (_355 < i.d1)
    goto _jump1345;
    _355 = 0;
    _356++;
    if (_356 < i.d0)
    goto _jump1345;
    // End body of loop
    _349 = _350;
    goto _jump1346;
    _jump1339:;
    _a3_rgba _358;
    // Computing bound for u
    int64_t _359 = c * l.d2;
    _358.d0 = _359;
    if (_359 > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing bound for v
    _358.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1348;
    fail_assertion("non-positive loop bound");
    _jump1348:;
    // Computing bound for w
    _358.d2 = l.d1;
    if (l.d1 > 0) 
    goto _jump1349;
    fail_assertion("non-positive loop bound");
    _jump1349:;
    // Computing total size of heap memory to allocate
    int64_t _360 = 1;
    _360 *= _359;
    _360 *= i.d0;
    _360 *= l.d1;
    _360 *= sizeof(rgba);
    _358.data = jpl_alloc(_360);
    int64_t _361 = 0; // w
    int64_t _362 = 0; // v
    int64_t _363 = 0; // u
    _jump1350:; // Begin body of loop
    int64_t _364 = 0;
    _364 *= _358.d0;
    _364 += _363;
    _364 *= _358.d1;
    _364 += _362;
    _364 *= _358.d2;
    _364 += _361;
    _358.data[_364] = _21;
    _361++;
    if (_361 < l.d1)
    goto _jump1350;
    _361 = 0;
    _362++;
    if (_362 < i.d0)
    goto _jump1350;
    _362 = 0;
    _363++;
    if (_363 < _359)
    goto _jump1350;
    // End body of loop
    _349 = _358;
    _jump1346:;
    _345 = _349;
    goto _jump1351;
    _jump1335:;
    _a3_rgba _365;
    // Computing bound for u
    _365.d0 = d;
    if (d > 0) 
    goto _jump1352;
    fail_assertion("non-positive loop bound");
    _jump1352:;
    // Computing bound for v
    _365.d1 = d;
    if (d > 0) 
    goto _jump1353;
    fail_assertion("non-positive loop bound");
    _jump1353:;
    // Computing bound for w
    _365.d2 = _288.d0;
    if (_288.d0 > 0) 
    goto _jump1354;
    fail_assertion("non-positive loop bound");
    _jump1354:;
    // Computing total size of heap memory to allocate
    int64_t _366 = 1;
    _366 *= d;
    _366 *= d;
    _366 *= _288.d0;
    _366 *= sizeof(rgba);
    _365.data = jpl_alloc(_366);
    int64_t _367 = 0; // w
    int64_t _368 = 0; // v
    int64_t _369 = 0; // u
    _jump1355:; // Begin body of loop
    rgba _370;
    if (!_269)
    goto _jump1356;
    rgba _371 = h(i, l);
    _370 = _371;
    goto _jump1357;
    _jump1356:;
    _370 = _21;
    _jump1357:;
    int64_t _372 = 0;
    _372 *= _365.d0;
    _372 += _369;
    _372 *= _365.d1;
    _372 += _368;
    _372 *= _365.d2;
    _372 += _367;
    _365.data[_372] = _370;
    _367++;
    if (_367 < _288.d0)
    goto _jump1355;
    _367 = 0;
    _368++;
    if (_368 < d)
    goto _jump1355;
    _368 = 0;
    _369++;
    if (_369 < d)
    goto _jump1355;
    // End body of loop
    _345 = _365;
    _jump1351:;
    _343 = _345;
    goto _jump1358;
    _jump1334:;
    _a3_rgba _373;
    // Computing bound for u
    int64_t _374;
    // Computing bound for u
    if (_288.d0 > 0) 
    goto _jump1359;
    fail_assertion("non-positive loop bound");
    _jump1359:;
    _374 = 0;
    int64_t _375 = 0; // u
    _jump1360:; // Begin body of loop
    _374 += l.d0;
    _375++;
    if (_375 < _288.d0)
    goto _jump1360;
    // End body of loop
    _373.d0 = _374;
    if (_374 > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing bound for v
    _373.d1 = l.d1;
    if (l.d1 > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    // Computing bound for w
    _373.d2 = l.d0;
    if (l.d0 > 0) 
    goto _jump1363;
    fail_assertion("non-positive loop bound");
    _jump1363:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= _374;
    _376 *= l.d1;
    _376 *= l.d0;
    _376 *= sizeof(rgba);
    _373.data = jpl_alloc(_376);
    int64_t _377 = 0; // w
    int64_t _378 = 0; // v
    int64_t _379 = 0; // u
    _jump1364:; // Begin body of loop
    double _380;
    // Computing bound for x
    int64_t _381 = i.d0 + _288.d0;
    if (_381 > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing bound for y
    int64_t _382 = -i.d1;
    if (_382 > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    _380 = 0;
    int64_t _383 = 0; // y
    int64_t _384 = 0; // x
    _jump1367:; // Begin body of loop
    _380 += g;
    _383++;
    if (_383 < _382)
    goto _jump1367;
    _383 = 0;
    _384++;
    if (_384 < _381)
    goto _jump1367;
    // End body of loop
    double _385 = 74.0;
    double _386 = -_385;
    double _387 = 17.0;
    double _388;
    // Computing bound for x
    if (l.d2 > 0) 
    goto _jump1368;
    fail_assertion("non-positive loop bound");
    _jump1368:;
    // Computing bound for y
    int64_t _389 = _378 / _378;
    if (_389 > 0) 
    goto _jump1369;
    fail_assertion("non-positive loop bound");
    _jump1369:;
    // Computing bound for z
    int64_t _390 = 663;
    if (_390 > 0) 
    goto _jump1370;
    fail_assertion("non-positive loop bound");
    _jump1370:;
    _388 = 0;
    int64_t _391 = 0; // z
    int64_t _392 = 0; // y
    int64_t _393 = 0; // x
    _jump1371:; // Begin body of loop
    double _394 = 94.0;
    _388 += _394;
    _391++;
    if (_391 < _390)
    goto _jump1371;
    _391 = 0;
    _392++;
    if (_392 < _389)
    goto _jump1371;
    _392 = 0;
    _393++;
    if (_393 < l.d2)
    goto _jump1371;
    // End body of loop
    rgba _395 = { _380, _386, _387, _388 };
    int64_t _396 = 0;
    _396 *= _373.d0;
    _396 += _379;
    _396 *= _373.d1;
    _396 += _378;
    _396 *= _373.d2;
    _396 += _377;
    _373.data[_396] = _395;
    _377++;
    if (_377 < l.d0)
    goto _jump1364;
    _377 = 0;
    _378++;
    if (_378 < l.d1)
    goto _jump1364;
    _378 = 0;
    _379++;
    if (_379 < _374)
    goto _jump1364;
    // End body of loop
    _343 = _373;
    _jump1358:;
    _309 = _343;
    _jump1333:;
    bool _398 = true;
    bool _399 = false;
    bool _400 = _398 == _399;
    bool _401 = false;
    bool _402 = !_401;
    bool _403 = _400 != _402;
    bool _404 = _403 != _269;
    bool _405;
    if (!_404)
    goto _jump1372;
    bool _407 = true;
    bool _406 = _407;
    if (0 == _407)
    goto _jump1373;
    bool _408 = true;
    bool _409 = !_408;
    _406 = _409;
    _jump1373:;
    _405 = _406;
    goto _jump1374;
    _jump1372:;
    bool _411 = l.d1 <= i.d1;
    bool _410 = _411;
    if (0 == _411)
    goto _jump1375;
    bool _412 = l.d0 <= l.d1;
    bool _413;
    if (!_412)
    goto _jump1376;
    int64_t _414 = 823;
    int64_t _415 = 363;
    bool _416 = _414 == _415;
    _413 = _416;
    goto _jump1377;
    _jump1376:;
    bool _417 = g < g;
    _413 = _417;
    _jump1377:;
    _410 = _413;
    _jump1375:;
    _405 = _410;
    _jump1374:;
    bool _397 = _405;
    if (0 != _405)
    goto _jump1378;
    _397 = _269;
    _jump1378:;
    int64_t _418;
    if (!_397)
    goto _jump1379;
    _418 = l.d2;
    goto _jump1380;
    _jump1379:;
    double _419 = -g;
    bool _420 = g <= _419;
    int64_t _421;
    if (!_420)
    goto _jump1381;
    int64_t _422 = 518;
    _421 = _422;
    goto _jump1382;
    _jump1381:;
    int64_t _423 = -c;
    _a1_int64_t _424;
    // Computing bound for u
    _424.d0 = d;
    if (d > 0) 
    goto _jump1383;
    fail_assertion("non-positive loop bound");
    _jump1383:;
    // Computing total size of heap memory to allocate
    int64_t _425 = 1;
    _425 *= d;
    _425 *= sizeof(int64_t);
    _424.data = jpl_alloc(_425);
    int64_t _426 = 0; // u
    _jump1384:; // Begin body of loop
    int64_t _427 = 0;
    _427 *= _424.d0;
    _427 += _426;
    _424.data[_427] = _426;
    _426++;
    if (_426 < d)
    goto _jump1384;
    // End body of loop
    if (l.d0 >= 0)
    goto _jump1385;
    fail_assertion("negative array index");
    _jump1385:;
    if (l.d0 < _424.d0)
    goto _jump1386;
    fail_assertion("index too large");
    _jump1386:;
    int64_t _428 = 0;
    _428 *= _424.d0;
    _428 += l.d0;
    int64_t _429 = _424.data[_428];
    int64_t _430 = _423 + _429;
    _421 = _430;
    _jump1382:;
    int64_t _431 = -_421;
    _418 = _431;
    _jump1380:;
    bool _432 = !_269;
    bool _433 = _269 == _432;
    bool _434 = !_433;
    int64_t _435;
    if (!_434)
    goto _jump1387;
    double _436 = _182.b;
    double _437 = _182.g;
    bool _438 = _436 < _437;
    bool _439;
    if (!_438)
    goto _jump1388;
    bool _440 = false;
    _439 = _440;
    goto _jump1389;
    _jump1388:;
    bool _441 = i.d1 > l.d2;
    _439 = _441;
    _jump1389:;
    int64_t _442;
    if (!_439)
    goto _jump1390;
    bool _444 = false;
    bool _443 = _444;
    if (0 == _444)
    goto _jump1391;
    bool _445 = true;
    bool _446 = !_445;
    _443 = _446;
    _jump1391:;
    int64_t _447;
    if (!_443)
    goto _jump1392;
    _a1_int64_t _448;
    _448.d0 = 1;
    _448.data = jpl_alloc(sizeof(int64_t) * 1);
    _448.data[0] = i.d0;
    if (l.d0 >= 0)
    goto _jump1393;
    fail_assertion("negative array index");
    _jump1393:;
    if (l.d0 < _448.d0)
    goto _jump1394;
    fail_assertion("index too large");
    _jump1394:;
    int64_t _449 = 0;
    _449 *= _448.d0;
    _449 += l.d0;
    int64_t _450 = _448.data[_449];
    _447 = _450;
    goto _jump1395;
    _jump1392:;
    int64_t _451;
    // Computing bound for u
    if (i.d0 > 0) 
    goto _jump1396;
    fail_assertion("non-positive loop bound");
    _jump1396:;
    // Computing bound for v
    if (d > 0) 
    goto _jump1397;
    fail_assertion("non-positive loop bound");
    _jump1397:;
    // Computing bound for w
    if (c > 0) 
    goto _jump1398;
    fail_assertion("non-positive loop bound");
    _jump1398:;
    _451 = 0;
    int64_t _452 = 0; // w
    int64_t _453 = 0; // v
    int64_t _454 = 0; // u
    _jump1399:; // Begin body of loop
    _451 += l.d2;
    _452++;
    if (_452 < c)
    goto _jump1399;
    _452 = 0;
    _453++;
    if (_453 < d)
    goto _jump1399;
    _453 = 0;
    _454++;
    if (_454 < i.d0)
    goto _jump1399;
    // End body of loop
    int64_t _455 = -_451;
    _447 = _455;
    _jump1395:;
    _442 = _447;
    goto _jump1400;
    _jump1390:;
    int64_t _456 = 177;
    _442 = _456;
    _jump1400:;
    _435 = _442;
    goto _jump1401;
    _jump1387:;
    int64_t _457 = 882;
    _435 = _457;
    _jump1401:;
    bool _459 = true;
    bool _458 = _459;
    if (0 != _459)
    goto _jump1402;
    rgba _460 = a();
    double _461 = _460.a;
    double _462 = g * _461;
    double _463;
    // Computing bound for u
    if (_288.d0 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    _463 = 0;
    int64_t _464 = 0; // u
    _jump1404:; // Begin body of loop
    double _465 = _182.a;
    _463 += _465;
    _464++;
    if (_464 < _288.d0)
    goto _jump1404;
    // End body of loop
    bool _466 = _462 == _463;
    _458 = _466;
    _jump1402:;
    int64_t _467;
    if (!_458)
    goto _jump1405;
    int64_t _468;
    // Computing bound for u
    if (i.d1 > 0) 
    goto _jump1406;
    fail_assertion("non-positive loop bound");
    _jump1406:;
    // Computing bound for v
    if (l.d1 > 0) 
    goto _jump1407;
    fail_assertion("non-positive loop bound");
    _jump1407:;
    // Computing bound for w
    if (_288.d0 > 0) 
    goto _jump1408;
    fail_assertion("non-positive loop bound");
    _jump1408:;
    _468 = 0;
    int64_t _469 = 0; // w
    int64_t _470 = 0; // v
    int64_t _471 = 0; // u
    _jump1409:; // Begin body of loop
    _468 += c;
    _469++;
    if (_469 < _288.d0)
    goto _jump1409;
    _469 = 0;
    _470++;
    if (_470 < l.d1)
    goto _jump1409;
    _470 = 0;
    _471++;
    if (_471 < i.d1)
    goto _jump1409;
    // End body of loop
    _467 = _468;
    goto _jump1410;
    _jump1405:;
    _467 = l.d2;
    _jump1410:;
    int64_t _472 = _435 + _467;
    if (_418 >= 0)
    goto _jump1411;
    fail_assertion("negative array index");
    _jump1411:;
    if (_418 < _309.d0)
    goto _jump1412;
    fail_assertion("index too large");
    _jump1412:;
    if (_472 >= 0)
    goto _jump1413;
    fail_assertion("negative array index");
    _jump1413:;
    if (_472 < _309.d1)
    goto _jump1414;
    fail_assertion("index too large");
    _jump1414:;
    if (l.d1 >= 0)
    goto _jump1415;
    fail_assertion("negative array index");
    _jump1415:;
    if (l.d1 < _309.d2)
    goto _jump1416;
    fail_assertion("index too large");
    _jump1416:;
    int64_t _473 = 0;
    _473 *= _309.d0;
    _473 += _418;
    _473 *= _309.d1;
    _473 += _472;
    _473 *= _309.d2;
    _473 += l.d1;
    rgba _474 = _309.data[_473];
    return _474;
    double _475;
    // Computing bound for y
    if (_288.d0 > 0) 
    goto _jump1417;
    fail_assertion("non-positive loop bound");
    _jump1417:;
    _475 = 0;
    int64_t _476 = 0; // y
    _jump1418:; // Begin body of loop
    rgba _477 = h(i, l);
    double _478 = _477.a;
    double _479 = 89.0;
    double _480 = g - _479;
    bool _481 = _478 >= _480;
    rgba _482;
    if (!_481)
    goto _jump1419;
    _a3_rgba _483;
    // Computing bound for z
    _483.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing bound for A
    int64_t _484 = 288;
    _483.d1 = _484;
    if (_484 > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    // Computing bound for B
    _483.d2 = l.d1;
    if (l.d1 > 0) 
    goto _jump1422;
    fail_assertion("non-positive loop bound");
    _jump1422:;
    // Computing total size of heap memory to allocate
    int64_t _485 = 1;
    _485 *= l.d1;
    _485 *= _484;
    _485 *= l.d1;
    _485 *= sizeof(rgba);
    _483.data = jpl_alloc(_485);
    int64_t _486 = 0; // B
    int64_t _487 = 0; // A
    int64_t _488 = 0; // z
    _jump1423:; // Begin body of loop
    rgba _489;
    if (!_269)
    goto _jump1424;
    rgba _490 = a();
    _489 = _490;
    goto _jump1425;
    _jump1424:;
    _489 = _182;
    _jump1425:;
    int64_t _491 = 0;
    _491 *= _483.d0;
    _491 += _488;
    _491 *= _483.d1;
    _491 += _487;
    _491 *= _483.d2;
    _491 += _486;
    _483.data[_491] = _489;
    _486++;
    if (_486 < l.d1)
    goto _jump1423;
    _486 = 0;
    _487++;
    if (_487 < _484)
    goto _jump1423;
    _487 = 0;
    _488++;
    if (_488 < l.d1)
    goto _jump1423;
    // End body of loop
    bool _492 = true;
    bool _493;
    if (!_492)
    goto _jump1426;
    bool _494 = false;
    _493 = _494;
    goto _jump1427;
    _jump1426:;
    _493 = _269;
    _jump1427:;
    int64_t _495;
    if (!_493)
    goto _jump1428;
    int64_t _496 = -l.d2;
    _495 = _496;
    goto _jump1429;
    _jump1428:;
    _495 = d;
    _jump1429:;
    if (_288.d0 >= 0)
    goto _jump1430;
    fail_assertion("negative array index");
    _jump1430:;
    if (_288.d0 < _483.d0)
    goto _jump1431;
    fail_assertion("index too large");
    _jump1431:;
    if (_495 >= 0)
    goto _jump1432;
    fail_assertion("negative array index");
    _jump1432:;
    if (_495 < _483.d1)
    goto _jump1433;
    fail_assertion("index too large");
    _jump1433:;
    if (l.d1 >= 0)
    goto _jump1434;
    fail_assertion("negative array index");
    _jump1434:;
    if (l.d1 < _483.d2)
    goto _jump1435;
    fail_assertion("index too large");
    _jump1435:;
    int64_t _497 = 0;
    _497 *= _483.d0;
    _497 += _288.d0;
    _497 *= _483.d1;
    _497 += _495;
    _497 *= _483.d2;
    _497 += l.d1;
    rgba _498 = _483.data[_497];
    _482 = _498;
    goto _jump1436;
    _jump1419:;
    rgba _499 = a();
    _482 = _499;
    _jump1436:;
    double _500 = _482.a;
    _475 += _500;
    _476++;
    if (_476 < _288.d0)
    goto _jump1418;
    // End body of loop
    _a2__a2_double _501;
    // Computing bound for y
    int64_t _502 = 40;
    _501.d0 = _502;
    if (_502 > 0) 
    goto _jump1437;
    fail_assertion("non-positive loop bound");
    _jump1437:;
    // Computing bound for z
    _501.d1 = _288.d0;
    if (_288.d0 > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    // Computing total size of heap memory to allocate
    int64_t _503 = 1;
    _503 *= _502;
    _503 *= _288.d0;
    _503 *= sizeof(_a2_double);
    _501.data = jpl_alloc(_503);
    int64_t _504 = 0; // z
    int64_t _505 = 0; // y
    _jump1439:; // Begin body of loop
    _a2_double _506;
    // Computing bound for A
    _506.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1440;
    fail_assertion("non-positive loop bound");
    _jump1440:;
    // Computing bound for B
    _506.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1441;
    fail_assertion("non-positive loop bound");
    _jump1441:;
    // Computing total size of heap memory to allocate
    int64_t _507 = 1;
    _507 *= l.d1;
    _507 *= l.d0;
    _507 *= sizeof(double);
    _506.data = jpl_alloc(_507);
    int64_t _508 = 0; // B
    int64_t _509 = 0; // A
    _jump1442:; // Begin body of loop
    _a3_double _510;
    // Computing bound for C
    _510.d0 = _508;
    if (_508 > 0) 
    goto _jump1443;
    fail_assertion("non-positive loop bound");
    _jump1443:;
    // Computing bound for D
    _510.d1 = _508;
    if (_508 > 0) 
    goto _jump1444;
    fail_assertion("non-positive loop bound");
    _jump1444:;
    // Computing bound for E
    _510.d2 = l.d1;
    if (l.d1 > 0) 
    goto _jump1445;
    fail_assertion("non-positive loop bound");
    _jump1445:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= _508;
    _511 *= _508;
    _511 *= l.d1;
    _511 *= sizeof(double);
    _510.data = jpl_alloc(_511);
    int64_t _512 = 0; // E
    int64_t _513 = 0; // D
    int64_t _514 = 0; // C
    _jump1446:; // Begin body of loop
    int64_t _515 = 0;
    _515 *= _510.d0;
    _515 += _514;
    _515 *= _510.d1;
    _515 += _513;
    _515 *= _510.d2;
    _515 += _512;
    _510.data[_515] = g;
    _512++;
    if (_512 < l.d1)
    goto _jump1446;
    _512 = 0;
    _513++;
    if (_513 < _508)
    goto _jump1446;
    _513 = 0;
    _514++;
    if (_514 < _508)
    goto _jump1446;
    // End body of loop
    int64_t _516 = 276;
    if (_508 >= 0)
    goto _jump1447;
    fail_assertion("negative array index");
    _jump1447:;
    if (_508 < _510.d0)
    goto _jump1448;
    fail_assertion("index too large");
    _jump1448:;
    if (l.d0 >= 0)
    goto _jump1449;
    fail_assertion("negative array index");
    _jump1449:;
    if (l.d0 < _510.d1)
    goto _jump1450;
    fail_assertion("index too large");
    _jump1450:;
    if (_516 >= 0)
    goto _jump1451;
    fail_assertion("negative array index");
    _jump1451:;
    if (_516 < _510.d2)
    goto _jump1452;
    fail_assertion("index too large");
    _jump1452:;
    int64_t _517 = 0;
    _517 *= _510.d0;
    _517 += _508;
    _517 *= _510.d1;
    _517 += l.d0;
    _517 *= _510.d2;
    _517 += _516;
    double _518 = _510.data[_517];
    int64_t _519 = 0;
    _519 *= _506.d0;
    _519 += _509;
    _519 *= _506.d1;
    _519 += _508;
    _506.data[_519] = _518;
    _508++;
    if (_508 < l.d0)
    goto _jump1442;
    _508 = 0;
    _509++;
    if (_509 < l.d1)
    goto _jump1442;
    // End body of loop
    int64_t _520 = 0;
    _520 *= _501.d0;
    _520 += _505;
    _520 *= _501.d1;
    _520 += _504;
    _501.data[_520] = _506;
    _504++;
    if (_504 < _288.d0)
    goto _jump1439;
    _504 = 0;
    _505++;
    if (_505 < _502)
    goto _jump1439;
    // End body of loop
    _a2_int64_t _521;
    // Computing bound for y
    _521.d0 = l.d2;
    if (l.d2 > 0) 
    goto _jump1453;
    fail_assertion("non-positive loop bound");
    _jump1453:;
    // Computing bound for z
    _521.d1 = l.d2;
    if (l.d2 > 0) 
    goto _jump1454;
    fail_assertion("non-positive loop bound");
    _jump1454:;
    // Computing total size of heap memory to allocate
    int64_t _522 = 1;
    _522 *= l.d2;
    _522 *= l.d2;
    _522 *= sizeof(int64_t);
    _521.data = jpl_alloc(_522);
    int64_t _523 = 0; // z
    int64_t _524 = 0; // y
    _jump1455:; // Begin body of loop
    _a1_int64_t _525;
    _525.d0 = 2;
    _525.data = jpl_alloc(sizeof(int64_t) * 2);
    _525.data[0] = i.d0;
    _525.data[1] = l.d1;
    if (l.d2 >= 0)
    goto _jump1456;
    fail_assertion("negative array index");
    _jump1456:;
    if (l.d2 < _525.d0)
    goto _jump1457;
    fail_assertion("index too large");
    _jump1457:;
    int64_t _526 = 0;
    _526 *= _525.d0;
    _526 += l.d2;
    int64_t _527 = _525.data[_526];
    int64_t _528 = 0;
    _528 *= _521.d0;
    _528 += _524;
    _528 *= _521.d1;
    _528 += _523;
    _521.data[_528] = _527;
    _523++;
    if (_523 < l.d2)
    goto _jump1455;
    _523 = 0;
    _524++;
    if (_524 < l.d2)
    goto _jump1455;
    // End body of loop
    int64_t _529 = 623;
    int64_t _530 = l.d2 % l.d2;
    if (_529 >= 0)
    goto _jump1458;
    fail_assertion("negative array index");
    _jump1458:;
    if (_529 < _521.d0)
    goto _jump1459;
    fail_assertion("index too large");
    _jump1459:;
    if (_530 >= 0)
    goto _jump1460;
    fail_assertion("negative array index");
    _jump1460:;
    if (_530 < _521.d1)
    goto _jump1461;
    fail_assertion("index too large");
    _jump1461:;
    int64_t _531 = 0;
    _531 *= _521.d0;
    _531 += _529;
    _531 *= _521.d1;
    _531 += _530;
    int64_t _532 = _521.data[_531];
    if (_288.d0 >= 0)
    goto _jump1462;
    fail_assertion("negative array index");
    _jump1462:;
    if (_288.d0 < _501.d0)
    goto _jump1463;
    fail_assertion("index too large");
    _jump1463:;
    if (_532 >= 0)
    goto _jump1464;
    fail_assertion("negative array index");
    _jump1464:;
    if (_532 < _501.d1)
    goto _jump1465;
    fail_assertion("index too large");
    _jump1465:;
    int64_t _533 = 0;
    _533 *= _501.d0;
    _533 += _288.d0;
    _533 *= _501.d1;
    _533 += _532;
    _a2_double _534 = _501.data[_533];
    int64_t _535 = 505;
    if (_535 >= 0)
    goto _jump1466;
    fail_assertion("negative array index");
    _jump1466:;
    if (_535 < _534.d0)
    goto _jump1467;
    fail_assertion("index too large");
    _jump1467:;
    if (c >= 0)
    goto _jump1468;
    fail_assertion("negative array index");
    _jump1468:;
    if (c < _534.d1)
    goto _jump1469;
    fail_assertion("index too large");
    _jump1469:;
    int64_t _536 = 0;
    _536 *= _534.d0;
    _536 += _535;
    _536 *= _534.d1;
    _536 += c;
    double _537 = _534.data[_536];
    double _538 = 79.0;
    double _539;
    // Computing bound for y
    if (l.d0 > 0) 
    goto _jump1470;
    fail_assertion("non-positive loop bound");
    _jump1470:;
    // Computing bound for z
    if (l.d0 > 0) 
    goto _jump1471;
    fail_assertion("non-positive loop bound");
    _jump1471:;
    // Computing bound for A
    if (l.d1 > 0) 
    goto _jump1472;
    fail_assertion("non-positive loop bound");
    _jump1472:;
    _539 = 0;
    int64_t _540 = 0; // A
    int64_t _541 = 0; // z
    int64_t _542 = 0; // y
    _jump1473:; // Begin body of loop
    double _543 = _182.b;
    double _544 = g + _543;
    double _545 = 73.0;
    _a1_double _546;
    _546.d0 = 1;
    _546.data = jpl_alloc(sizeof(double) * 1);
    _546.data[0] = _545;
    int64_t _547 = l.d1 % l.d0;
    if (_547 >= 0)
    goto _jump1474;
    fail_assertion("negative array index");
    _jump1474:;
    if (_547 < _546.d0)
    goto _jump1475;
    fail_assertion("index too large");
    _jump1475:;
    int64_t _548 = 0;
    _548 *= _546.d0;
    _548 += _547;
    double _549 = _546.data[_548];
    rgba _550 = { g, g, _544, _549 };
    double _551 = _550.b;
    _539 += _551;
    _540++;
    if (_540 < l.d1)
    goto _jump1473;
    _540 = 0;
    _541++;
    if (_541 < l.d0)
    goto _jump1473;
    _541 = 0;
    _542++;
    if (_542 < l.d0)
    goto _jump1473;
    // End body of loop
    double _552 = _21.r;
    double _553 = _539 / _552;
    rgba _554 = { _475, _537, _538, _553 };
    return _554;
}

bool i(int64_t j) {
    bool _0 = false;
    bool _1;
    if (!_0)
    goto _jump1476;
    double _2 = 26.0;
    double _3 = -_2;
    bool _4 = g > _3;
    _1 = _4;
    goto _jump1477;
    _jump1476:;
    bool _5 = i(d);
    _1 = _5;
    _jump1477:;
    bool _7 = false;
    bool _6 = _7;
    if (0 == _7)
    goto _jump1478;
    bool _8 = false;
    bool _9 = !_8;
    _6 = _9;
    _jump1478:;
    bool _10 = !_6;
    bool _11 = !_10;
    bool _12 = _1 != _11;
    _a3_double _13;
    if (!_12)
    goto _jump1479;
    _a2__a3_double _14;
    // Computing bound for k
    int64_t _15 = 805;
    _14.d0 = _15;
    if (_15 > 0) 
    goto _jump1480;
    fail_assertion("non-positive loop bound");
    _jump1480:;
    // Computing bound for l
    _14.d1 = j;
    if (j > 0) 
    goto _jump1481;
    fail_assertion("non-positive loop bound");
    _jump1481:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _15;
    _16 *= j;
    _16 *= sizeof(_a3_double);
    _14.data = jpl_alloc(_16);
    int64_t _17 = 0; // l
    int64_t _18 = 0; // k
    _jump1482:; // Begin body of loop
    _a3_double _19;
    // Computing bound for m
    _19.d0 = c;
    if (c > 0) 
    goto _jump1483;
    fail_assertion("non-positive loop bound");
    _jump1483:;
    // Computing bound for n
    int64_t _20 = 128;
    _19.d1 = _20;
    if (_20 > 0) 
    goto _jump1484;
    fail_assertion("non-positive loop bound");
    _jump1484:;
    // Computing bound for o
    _a3_int64_t _21;
    // Computing bound for m
    bool _22 = false;
    int64_t _23;
    if (!_22)
    goto _jump1485;
    _23 = j;
    goto _jump1486;
    _jump1485:;
    int64_t _24 = 988;
    _23 = _24;
    _jump1486:;
    _21.d0 = _23;
    if (_23 > 0) 
    goto _jump1487;
    fail_assertion("non-positive loop bound");
    _jump1487:;
    // Computing bound for n
    _21.d1 = d;
    if (d > 0) 
    goto _jump1488;
    fail_assertion("non-positive loop bound");
    _jump1488:;
    // Computing bound for o
    _21.d2 = j;
    if (j > 0) 
    goto _jump1489;
    fail_assertion("non-positive loop bound");
    _jump1489:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= _23;
    _25 *= d;
    _25 *= j;
    _25 *= sizeof(int64_t);
    _21.data = jpl_alloc(_25);
    int64_t _26 = 0; // o
    int64_t _27 = 0; // n
    int64_t _28 = 0; // m
    _jump1490:; // Begin body of loop
    int64_t _29 = 0;
    _29 *= _21.d0;
    _29 += _28;
    _29 *= _21.d1;
    _29 += _27;
    _29 *= _21.d2;
    _29 += _26;
    _21.data[_29] = _18;
    _26++;
    if (_26 < j)
    goto _jump1490;
    _26 = 0;
    _27++;
    if (_27 < d)
    goto _jump1490;
    _27 = 0;
    _28++;
    if (_28 < _23)
    goto _jump1490;
    // End body of loop
    int64_t _30 = 380;
    bool _31 = true;
    bool _32;
    if (!_31)
    goto _jump1491;
    bool _33 = true;
    _32 = _33;
    goto _jump1492;
    _jump1491:;
    bool _34 = true;
    _32 = _34;
    _jump1492:;
    int64_t _35;
    if (!_32)
    goto _jump1493;
    _35 = _18;
    goto _jump1494;
    _jump1493:;
    int64_t _36;
    // Computing bound for m
    if (j > 0) 
    goto _jump1495;
    fail_assertion("non-positive loop bound");
    _jump1495:;
    _36 = 0;
    int64_t _37 = 0; // m
    _jump1496:; // Begin body of loop
    _36 += d;
    _37++;
    if (_37 < j)
    goto _jump1496;
    // End body of loop
    _35 = _36;
    _jump1494:;
    if (_30 >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (_30 < _21.d0)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    if (_35 >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (_35 < _21.d1)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    if (c >= 0)
    goto _jump1501;
    fail_assertion("negative array index");
    _jump1501:;
    if (c < _21.d2)
    goto _jump1502;
    fail_assertion("index too large");
    _jump1502:;
    int64_t _38 = 0;
    _38 *= _21.d0;
    _38 += _30;
    _38 *= _21.d1;
    _38 += _35;
    _38 *= _21.d2;
    _38 += c;
    int64_t _39 = _21.data[_38];
    _19.d2 = _39;
    if (_39 > 0) 
    goto _jump1503;
    fail_assertion("non-positive loop bound");
    _jump1503:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= c;
    _40 *= _20;
    _40 *= _39;
    _40 *= sizeof(double);
    _19.data = jpl_alloc(_40);
    int64_t _41 = 0; // o
    int64_t _42 = 0; // n
    int64_t _43 = 0; // m
    _jump1504:; // Begin body of loop
    double _44 = 9.0;
    int64_t _45 = 0;
    _45 *= _19.d0;
    _45 += _43;
    _45 *= _19.d1;
    _45 += _42;
    _45 *= _19.d2;
    _45 += _41;
    _19.data[_45] = _44;
    _41++;
    if (_41 < _39)
    goto _jump1504;
    _41 = 0;
    _42++;
    if (_42 < _20)
    goto _jump1504;
    _42 = 0;
    _43++;
    if (_43 < c)
    goto _jump1504;
    // End body of loop
    int64_t _46 = 0;
    _46 *= _14.d0;
    _46 += _18;
    _46 *= _14.d1;
    _46 += _17;
    _14.data[_46] = _19;
    _17++;
    if (_17 < j)
    goto _jump1482;
    _17 = 0;
    _18++;
    if (_18 < _15)
    goto _jump1482;
    // End body of loop
    int64_t _47;
    // Computing bound for k
    bool _48 = i(c);
    bool _49;
    if (!_48)
    goto _jump1505;
    bool _50 = d >= c;
    bool _51;
    if (!_50)
    goto _jump1506;
    bool _52 = i(j);
    _51 = _52;
    goto _jump1507;
    _jump1506:;
    bool _53 = i(d);
    _51 = _53;
    _jump1507:;
    _49 = _51;
    goto _jump1508;
    _jump1505:;
    _a2_bool _54;
    // Computing bound for k
    _54.d0 = d;
    if (d > 0) 
    goto _jump1509;
    fail_assertion("non-positive loop bound");
    _jump1509:;
    // Computing bound for l
    int64_t _55 = 710;
    _54.d1 = _55;
    if (_55 > 0) 
    goto _jump1510;
    fail_assertion("non-positive loop bound");
    _jump1510:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= d;
    _56 *= _55;
    _56 *= sizeof(bool);
    _54.data = jpl_alloc(_56);
    int64_t _57 = 0; // l
    int64_t _58 = 0; // k
    _jump1511:; // Begin body of loop
    bool _59 = true;
    int64_t _60 = 0;
    _60 *= _54.d0;
    _60 += _58;
    _60 *= _54.d1;
    _60 += _57;
    _54.data[_60] = _59;
    _57++;
    if (_57 < _55)
    goto _jump1511;
    _57 = 0;
    _58++;
    if (_58 < d)
    goto _jump1511;
    // End body of loop
    if (j >= 0)
    goto _jump1512;
    fail_assertion("negative array index");
    _jump1512:;
    if (j < _54.d0)
    goto _jump1513;
    fail_assertion("index too large");
    _jump1513:;
    if (c >= 0)
    goto _jump1514;
    fail_assertion("negative array index");
    _jump1514:;
    if (c < _54.d1)
    goto _jump1515;
    fail_assertion("index too large");
    _jump1515:;
    int64_t _61 = 0;
    _61 *= _54.d0;
    _61 += j;
    _61 *= _54.d1;
    _61 += c;
    bool _62 = _54.data[_61];
    _49 = _62;
    _jump1508:;
    int64_t _63;
    if (!_49)
    goto _jump1516;
    _63 = d;
    goto _jump1517;
    _jump1516:;
    bool _64 = true;
    int64_t _65;
    if (!_64)
    goto _jump1518;
    _65 = j;
    goto _jump1519;
    _jump1518:;
    int64_t _66 = 963;
    _65 = _66;
    _jump1519:;
    int64_t _67 = _65 % c;
    _63 = _67;
    _jump1517:;
    if (_63 > 0) 
    goto _jump1520;
    fail_assertion("non-positive loop bound");
    _jump1520:;
    // Computing bound for l
    if (c > 0) 
    goto _jump1521;
    fail_assertion("non-positive loop bound");
    _jump1521:;
    // Computing bound for m
    if (c > 0) 
    goto _jump1522;
    fail_assertion("non-positive loop bound");
    _jump1522:;
    _47 = 0;
    int64_t _68 = 0; // m
    int64_t _69 = 0; // l
    int64_t _70 = 0; // k
    _jump1523:; // Begin body of loop
    _47 += _68;
    _68++;
    if (_68 < c)
    goto _jump1523;
    _68 = 0;
    _69++;
    if (_69 < c)
    goto _jump1523;
    _69 = 0;
    _70++;
    if (_70 < _63)
    goto _jump1523;
    // End body of loop
    bool _72 = true;
    bool _71 = _72;
    if (0 == _72)
    goto _jump1524;
    bool _73 = false;
    _71 = _73;
    _jump1524:;
    _a1__a2_int64_t _74;
    if (!_71)
    goto _jump1525;
    _a1__a2_int64_t _75;
    _75.d0 = 2;
    _75.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _75.data[0] = b;
    _75.data[1] = f;
    _74 = _75;
    goto _jump1526;
    _jump1525:;
    _a1__a2_int64_t _76;
    // Computing bound for k
    _76.d0 = j;
    if (j > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= j;
    _77 *= sizeof(_a2_int64_t);
    _76.data = jpl_alloc(_77);
    int64_t _78 = 0; // k
    _jump1528:; // Begin body of loop
    int64_t _79 = 0;
    _79 *= _76.d0;
    _79 += _78;
    _76.data[_79] = f;
    _78++;
    if (_78 < j)
    goto _jump1528;
    // End body of loop
    _74 = _76;
    _jump1526:;
    int64_t _80 = 154;
    if (_80 >= 0)
    goto _jump1529;
    fail_assertion("negative array index");
    _jump1529:;
    if (_80 < _74.d0)
    goto _jump1530;
    fail_assertion("index too large");
    _jump1530:;
    int64_t _81 = 0;
    _81 *= _74.d0;
    _81 += _80;
    _a2_int64_t _82 = _74.data[_81];
    if (c >= 0)
    goto _jump1531;
    fail_assertion("negative array index");
    _jump1531:;
    if (c < _82.d0)
    goto _jump1532;
    fail_assertion("index too large");
    _jump1532:;
    if (c >= 0)
    goto _jump1533;
    fail_assertion("negative array index");
    _jump1533:;
    if (c < _82.d1)
    goto _jump1534;
    fail_assertion("index too large");
    _jump1534:;
    int64_t _83 = 0;
    _83 *= _82.d0;
    _83 += c;
    _83 *= _82.d1;
    _83 += c;
    int64_t _84 = _82.data[_83];
    int64_t _85 = -_84;
    if (_47 >= 0)
    goto _jump1535;
    fail_assertion("negative array index");
    _jump1535:;
    if (_47 < _14.d0)
    goto _jump1536;
    fail_assertion("index too large");
    _jump1536:;
    if (_85 >= 0)
    goto _jump1537;
    fail_assertion("negative array index");
    _jump1537:;
    if (_85 < _14.d1)
    goto _jump1538;
    fail_assertion("index too large");
    _jump1538:;
    int64_t _86 = 0;
    _86 *= _14.d0;
    _86 += _47;
    _86 *= _14.d1;
    _86 += _85;
    _a3_double _87 = _14.data[_86];
    _13 = _87;
    goto _jump1539;
    _jump1479:;
    _a3_double _88;
    // Computing bound for k
    _88.d0 = d;
    if (d > 0) 
    goto _jump1540;
    fail_assertion("non-positive loop bound");
    _jump1540:;
    // Computing bound for l
    int64_t _89;
    // Computing bound for k
    int64_t _90;
    // Computing bound for k
    int64_t _91 = -d;
    int64_t _92 = -_91;
    if (_92 > 0) 
    goto _jump1541;
    fail_assertion("non-positive loop bound");
    _jump1541:;
    _90 = 0;
    int64_t _93 = 0; // k
    _jump1542:; // Begin body of loop
    _a2_int64_t _94;
    // Computing bound for l
    _94.d0 = j;
    if (j > 0) 
    goto _jump1543;
    fail_assertion("non-positive loop bound");
    _jump1543:;
    // Computing bound for m
    _94.d1 = c;
    if (c > 0) 
    goto _jump1544;
    fail_assertion("non-positive loop bound");
    _jump1544:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= j;
    _95 *= c;
    _95 *= sizeof(int64_t);
    _94.data = jpl_alloc(_95);
    int64_t _96 = 0; // m
    int64_t _97 = 0; // l
    _jump1545:; // Begin body of loop
    int64_t _98 = 0;
    _98 *= _94.d0;
    _98 += _97;
    _98 *= _94.d1;
    _98 += _96;
    _94.data[_98] = _97;
    _96++;
    if (_96 < c)
    goto _jump1545;
    _96 = 0;
    _97++;
    if (_97 < j)
    goto _jump1545;
    // End body of loop
    int64_t _99 = 378;
    int64_t _100 = j + _99;
    if (_100 >= 0)
    goto _jump1546;
    fail_assertion("negative array index");
    _jump1546:;
    if (_100 < _94.d0)
    goto _jump1547;
    fail_assertion("index too large");
    _jump1547:;
    if (c >= 0)
    goto _jump1548;
    fail_assertion("negative array index");
    _jump1548:;
    if (c < _94.d1)
    goto _jump1549;
    fail_assertion("index too large");
    _jump1549:;
    int64_t _101 = 0;
    _101 *= _94.d0;
    _101 += _100;
    _101 *= _94.d1;
    _101 += c;
    int64_t _102 = _94.data[_101];
    _90 += _102;
    _93++;
    if (_93 < _92)
    goto _jump1542;
    // End body of loop
    bool _103 = true;
    int64_t _104;
    if (!_103)
    goto _jump1550;
    int64_t _105 = 138;
    _104 = _105;
    goto _jump1551;
    _jump1550:;
    _104 = d;
    _jump1551:;
    int64_t _106;
    // Computing bound for k
    if (d > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    _106 = 0;
    int64_t _107 = 0; // k
    _jump1553:; // Begin body of loop
    _106 += d;
    _107++;
    if (_107 < d)
    goto _jump1553;
    // End body of loop
    int64_t _108 = _104 % _106;
    int64_t _109 = 939;
    int64_t _110 = -_109;
    int64_t _111 = _110 * c;
    int64_t _112 = _108 + _111;
    int64_t _113 = _90 - _112;
    if (_113 > 0) 
    goto _jump1554;
    fail_assertion("non-positive loop bound");
    _jump1554:;
    // Computing bound for l
    double _114 = 97.0;
    double _115 = -_114;
    double _116 = 90.0;
    bool _117 = _115 != _116;
    bool _118;
    if (!_117)
    goto _jump1555;
    bool _119 = false;
    _118 = _119;
    goto _jump1556;
    _jump1555:;
    bool _120 = i(j);
    _118 = _120;
    _jump1556:;
    int64_t _121;
    if (!_118)
    goto _jump1557;
    int64_t _122 = 613;
    int64_t _123 = -_122;
    _121 = _123;
    goto _jump1558;
    _jump1557:;
    int64_t _124 = 960;
    int64_t _125 = -_124;
    int64_t _126 = -_125;
    _121 = _126;
    _jump1558:;
    if (_121 > 0) 
    goto _jump1559;
    fail_assertion("non-positive loop bound");
    _jump1559:;
    // Computing bound for m
    int64_t _127 = 509;
    int64_t _128 = c + _127;
    int64_t _129 = j + _128;
    if (_129 > 0) 
    goto _jump1560;
    fail_assertion("non-positive loop bound");
    _jump1560:;
    _89 = 0;
    int64_t _130 = 0; // m
    int64_t _131 = 0; // l
    int64_t _132 = 0; // k
    _jump1561:; // Begin body of loop
    int64_t _133 = 255;
    _89 += _133;
    _130++;
    if (_130 < _129)
    goto _jump1561;
    _130 = 0;
    _131++;
    if (_131 < _121)
    goto _jump1561;
    _131 = 0;
    _132++;
    if (_132 < _113)
    goto _jump1561;
    // End body of loop
    _88.d1 = _89;
    if (_89 > 0) 
    goto _jump1562;
    fail_assertion("non-positive loop bound");
    _jump1562:;
    // Computing bound for m
    int64_t _134 = 741;
    _88.d2 = _134;
    if (_134 > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= d;
    _135 *= _89;
    _135 *= _134;
    _135 *= sizeof(double);
    _88.data = jpl_alloc(_135);
    int64_t _136 = 0; // m
    int64_t _137 = 0; // l
    int64_t _138 = 0; // k
    _jump1564:; // Begin body of loop
    rgba _139 = a();
    double _140 = _139.b;
    _a1_double _141;
    _141.d0 = 1;
    _141.data = jpl_alloc(sizeof(double) * 1);
    _141.data[0] = _140;
    int64_t _142 = -j;
    int64_t _143 = _136 + _142;
    if (_143 >= 0)
    goto _jump1565;
    fail_assertion("negative array index");
    _jump1565:;
    if (_143 < _141.d0)
    goto _jump1566;
    fail_assertion("index too large");
    _jump1566:;
    int64_t _144 = 0;
    _144 *= _141.d0;
    _144 += _143;
    double _145 = _141.data[_144];
    int64_t _146 = 0;
    _146 *= _88.d0;
    _146 += _138;
    _146 *= _88.d1;
    _146 += _137;
    _146 *= _88.d2;
    _146 += _136;
    _88.data[_146] = _145;
    _136++;
    if (_136 < _134)
    goto _jump1564;
    _136 = 0;
    _137++;
    if (_137 < _89)
    goto _jump1564;
    _137 = 0;
    _138++;
    if (_138 < d)
    goto _jump1564;
    // End body of loop
    _13 = _88;
    _jump1539:;
    _a1_int64_t _147;
    // Computing bound for p
    _147.d0 = _13.d1;
    if (_13.d1 > 0) 
    goto _jump1567;
    fail_assertion("non-positive loop bound");
    _jump1567:;
    // Computing total size of heap memory to allocate
    int64_t _148 = 1;
    _148 *= _13.d1;
    _148 *= sizeof(int64_t);
    _147.data = jpl_alloc(_148);
    int64_t _149 = 0; // p
    _jump1568:; // Begin body of loop
    int64_t _150 = 0;
    _150 *= _147.d0;
    _150 += _149;
    _147.data[_150] = d;
    _149++;
    if (_149 < _13.d1)
    goto _jump1568;
    // End body of loop
    _a3__a2__a1_bool _151;
    // Computing bound for r
    int64_t _152 = -_147.d0;
    int64_t _153 = -_152;
    _151.d0 = _153;
    if (_153 > 0) 
    goto _jump1569;
    fail_assertion("non-positive loop bound");
    _jump1569:;
    // Computing bound for s
    int64_t _154 = 590;
    _151.d1 = _154;
    if (_154 > 0) 
    goto _jump1570;
    fail_assertion("non-positive loop bound");
    _jump1570:;
    // Computing bound for t
    _151.d2 = d;
    if (d > 0) 
    goto _jump1571;
    fail_assertion("non-positive loop bound");
    _jump1571:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= _153;
    _155 *= _154;
    _155 *= d;
    _155 *= sizeof(_a2__a1_bool);
    _151.data = jpl_alloc(_155);
    int64_t _156 = 0; // t
    int64_t _157 = 0; // s
    int64_t _158 = 0; // r
    _jump1572:; // Begin body of loop
    _a2__a1_bool _159;
    // Computing bound for u
    _159.d0 = _13.d1;
    if (_13.d1 > 0) 
    goto _jump1573;
    fail_assertion("non-positive loop bound");
    _jump1573:;
    // Computing bound for v
    _159.d1 = _158;
    if (_158 > 0) 
    goto _jump1574;
    fail_assertion("non-positive loop bound");
    _jump1574:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= _13.d1;
    _160 *= _158;
    _160 *= sizeof(_a1_bool);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // v
    int64_t _162 = 0; // u
    _jump1575:; // Begin body of loop
    bool _163 = _156 >= _157;
    _a1_bool _164;
    if (!_163)
    goto _jump1576;
    bool _165 = true;
    bool _166 = i(_161);
    bool _167 = true;
    bool _168 = !_167;
    _a1_bool _169;
    _169.d0 = 3;
    _169.data = jpl_alloc(sizeof(bool) * 3);
    _169.data[0] = _165;
    _169.data[1] = _166;
    _169.data[2] = _168;
    _164 = _169;
    goto _jump1577;
    _jump1576:;
    _a1_bool _170;
    // Computing bound for w
    _170.d0 = _161;
    if (_161 > 0) 
    goto _jump1578;
    fail_assertion("non-positive loop bound");
    _jump1578:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _161;
    _171 *= sizeof(bool);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // w
    _jump1579:; // Begin body of loop
    bool _173 = false;
    int64_t _174 = 0;
    _174 *= _170.d0;
    _174 += _172;
    _170.data[_174] = _173;
    _172++;
    if (_172 < _161)
    goto _jump1579;
    // End body of loop
    _164 = _170;
    _jump1577:;
    int64_t _175 = 0;
    _175 *= _159.d0;
    _175 += _162;
    _175 *= _159.d1;
    _175 += _161;
    _159.data[_175] = _164;
    _161++;
    if (_161 < _158)
    goto _jump1575;
    _161 = 0;
    _162++;
    if (_162 < _13.d1)
    goto _jump1575;
    // End body of loop
    int64_t _176 = 0;
    _176 *= _151.d0;
    _176 += _158;
    _176 *= _151.d1;
    _176 += _157;
    _176 *= _151.d2;
    _176 += _156;
    _151.data[_176] = _159;
    _156++;
    if (_156 < d)
    goto _jump1572;
    _156 = 0;
    _157++;
    if (_157 < _154)
    goto _jump1572;
    _157 = 0;
    _158++;
    if (_158 < _153)
    goto _jump1572;
    // End body of loop
    int64_t _177 = 514;
    if (_13.d1 >= 0)
    goto _jump1580;
    fail_assertion("negative array index");
    _jump1580:;
    if (_13.d1 < _151.d0)
    goto _jump1581;
    fail_assertion("index too large");
    _jump1581:;
    if (_13.d2 >= 0)
    goto _jump1582;
    fail_assertion("negative array index");
    _jump1582:;
    if (_13.d2 < _151.d1)
    goto _jump1583;
    fail_assertion("index too large");
    _jump1583:;
    if (_177 >= 0)
    goto _jump1584;
    fail_assertion("negative array index");
    _jump1584:;
    if (_177 < _151.d2)
    goto _jump1585;
    fail_assertion("index too large");
    _jump1585:;
    int64_t _178 = 0;
    _178 *= _151.d0;
    _178 += _13.d1;
    _178 *= _151.d1;
    _178 += _13.d2;
    _178 *= _151.d2;
    _178 += _177;
    _a2__a1_bool _179 = _151.data[_178];
    _a3_bool _180;
    // Computing bound for r
    _180.d0 = c;
    if (c > 0) 
    goto _jump1586;
    fail_assertion("non-positive loop bound");
    _jump1586:;
    // Computing bound for s
    _180.d1 = c;
    if (c > 0) 
    goto _jump1587;
    fail_assertion("non-positive loop bound");
    _jump1587:;
    // Computing bound for t
    bool _181 = i(_147.d0);
    bool _182;
    if (!_181)
    goto _jump1588;
    bool _183 = _13.d2 == _13.d2;
    _182 = _183;
    goto _jump1589;
    _jump1588:;
    bool _184 = j < d;
    _182 = _184;
    _jump1589:;
    int64_t _185;
    if (!_182)
    goto _jump1590;
    _185 = _147.d0;
    goto _jump1591;
    _jump1590:;
    _185 = _13.d1;
    _jump1591:;
    _a1_int64_t _186;
    _186.d0 = 3;
    _186.data = jpl_alloc(sizeof(int64_t) * 3);
    _186.data[0] = _185;
    _186.data[1] = _13.d0;
    _186.data[2] = _13.d1;
    bool _187 = false;
    int64_t _188;
    if (!_187)
    goto _jump1592;
    _188 = j;
    goto _jump1593;
    _jump1592:;
    _188 = _13.d0;
    _jump1593:;
    bool _189 = j == _188;
    int64_t _190;
    if (!_189)
    goto _jump1594;
    int64_t _191;
    // Computing bound for r
    if (_13.d1 > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    _191 = 0;
    int64_t _192 = 0; // r
    _jump1596:; // Begin body of loop
    _191 += _147.d0;
    _192++;
    if (_192 < _13.d1)
    goto _jump1596;
    // End body of loop
    _190 = _191;
    goto _jump1597;
    _jump1594:;
    int64_t _193 = 101;
    int64_t _194 = _13.d1 - _193;
    _190 = _194;
    _jump1597:;
    if (_190 >= 0)
    goto _jump1598;
    fail_assertion("negative array index");
    _jump1598:;
    if (_190 < _186.d0)
    goto _jump1599;
    fail_assertion("index too large");
    _jump1599:;
    int64_t _195 = 0;
    _195 *= _186.d0;
    _195 += _190;
    int64_t _196 = _186.data[_195];
    _180.d2 = _196;
    if (_196 > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= c;
    _197 *= c;
    _197 *= _196;
    _197 *= sizeof(bool);
    _180.data = jpl_alloc(_197);
    int64_t _198 = 0; // t
    int64_t _199 = 0; // s
    int64_t _200 = 0; // r
    _jump1601:; // Begin body of loop
    _a3_bool _201;
    // Computing bound for u
    _a3_int64_t _202;
    // Computing bound for u
    int64_t _203;
    // Computing bound for u
    if (_200 > 0) 
    goto _jump1602;
    fail_assertion("non-positive loop bound");
    _jump1602:;
    // Computing bound for v
    if (_200 > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    _203 = 0;
    int64_t _204 = 0; // v
    int64_t _205 = 0; // u
    _jump1604:; // Begin body of loop
    _203 += _13.d1;
    _204++;
    if (_204 < _200)
    goto _jump1604;
    _204 = 0;
    _205++;
    if (_205 < _200)
    goto _jump1604;
    // End body of loop
    _202.d0 = _203;
    if (_203 > 0) 
    goto _jump1605;
    fail_assertion("non-positive loop bound");
    _jump1605:;
    // Computing bound for v
    _202.d1 = _13.d1;
    if (_13.d1 > 0) 
    goto _jump1606;
    fail_assertion("non-positive loop bound");
    _jump1606:;
    // Computing bound for w
    bool _206 = false;
    int64_t _207;
    if (!_206)
    goto _jump1607;
    int64_t _208 = 676;
    _207 = _208;
    goto _jump1608;
    _jump1607:;
    _207 = _198;
    _jump1608:;
    _202.d2 = _207;
    if (_207 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing total size of heap memory to allocate
    int64_t _209 = 1;
    _209 *= _203;
    _209 *= _13.d1;
    _209 *= _207;
    _209 *= sizeof(int64_t);
    _202.data = jpl_alloc(_209);
    int64_t _210 = 0; // w
    int64_t _211 = 0; // v
    int64_t _212 = 0; // u
    _jump1610:; // Begin body of loop
    int64_t _213 = 0;
    _213 *= _202.d0;
    _213 += _212;
    _213 *= _202.d1;
    _213 += _211;
    _213 *= _202.d2;
    _213 += _210;
    _202.data[_213] = d;
    _210++;
    if (_210 < _207)
    goto _jump1610;
    _210 = 0;
    _211++;
    if (_211 < _13.d1)
    goto _jump1610;
    _211 = 0;
    _212++;
    if (_212 < _203)
    goto _jump1610;
    // End body of loop
    int64_t _214 = _198 - _198;
    int64_t _215 = d / _13.d1;
    int64_t _216;
    // Computing bound for u
    int64_t _217;
    // Computing bound for u
    if (_199 > 0) 
    goto _jump1611;
    fail_assertion("non-positive loop bound");
    _jump1611:;
    // Computing bound for v
    if (j > 0) 
    goto _jump1612;
    fail_assertion("non-positive loop bound");
    _jump1612:;
    _217 = 0;
    int64_t _218 = 0; // v
    int64_t _219 = 0; // u
    _jump1613:; // Begin body of loop
    _217 += _199;
    _218++;
    if (_218 < j)
    goto _jump1613;
    _218 = 0;
    _219++;
    if (_219 < _199)
    goto _jump1613;
    // End body of loop
    if (_217 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for v
    if (_198 > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    // Computing bound for w
    if (j > 0) 
    goto _jump1616;
    fail_assertion("non-positive loop bound");
    _jump1616:;
    _216 = 0;
    int64_t _220 = 0; // w
    int64_t _221 = 0; // v
    int64_t _222 = 0; // u
    _jump1617:; // Begin body of loop
    _216 += _13.d0;
    _220++;
    if (_220 < j)
    goto _jump1617;
    _220 = 0;
    _221++;
    if (_221 < _198)
    goto _jump1617;
    _221 = 0;
    _222++;
    if (_222 < _217)
    goto _jump1617;
    // End body of loop
    if (_214 >= 0)
    goto _jump1618;
    fail_assertion("negative array index");
    _jump1618:;
    if (_214 < _202.d0)
    goto _jump1619;
    fail_assertion("index too large");
    _jump1619:;
    if (_215 >= 0)
    goto _jump1620;
    fail_assertion("negative array index");
    _jump1620:;
    if (_215 < _202.d1)
    goto _jump1621;
    fail_assertion("index too large");
    _jump1621:;
    if (_216 >= 0)
    goto _jump1622;
    fail_assertion("negative array index");
    _jump1622:;
    if (_216 < _202.d2)
    goto _jump1623;
    fail_assertion("index too large");
    _jump1623:;
    int64_t _223 = 0;
    _223 *= _202.d0;
    _223 += _214;
    _223 *= _202.d1;
    _223 += _215;
    _223 *= _202.d2;
    _223 += _216;
    int64_t _224 = _202.data[_223];
    _201.d0 = _224;
    if (_224 > 0) 
    goto _jump1624;
    fail_assertion("non-positive loop bound");
    _jump1624:;
    // Computing bound for v
    _201.d1 = _13.d1;
    if (_13.d1 > 0) 
    goto _jump1625;
    fail_assertion("non-positive loop bound");
    _jump1625:;
    // Computing bound for w
    _201.d2 = _147.d0;
    if (_147.d0 > 0) 
    goto _jump1626;
    fail_assertion("non-positive loop bound");
    _jump1626:;
    // Computing total size of heap memory to allocate
    int64_t _225 = 1;
    _225 *= _224;
    _225 *= _13.d1;
    _225 *= _147.d0;
    _225 *= sizeof(bool);
    _201.data = jpl_alloc(_225);
    int64_t _226 = 0; // w
    int64_t _227 = 0; // v
    int64_t _228 = 0; // u
    _jump1627:; // Begin body of loop
    rgba _229 = a();
    double _230 = _229.r;
    double _231;
    // Computing bound for x
    if (_228 > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing bound for y
    int64_t _232 = _200 * d;
    if (_232 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing bound for z
    if (_13.d2 > 0) 
    goto _jump1630;
    fail_assertion("non-positive loop bound");
    _jump1630:;
    _231 = 0;
    int64_t _233 = 0; // z
    int64_t _234 = 0; // y
    int64_t _235 = 0; // x
    _jump1631:; // Begin body of loop
    double _236 = 79.0;
    double _237 = -_236;
    _231 += _237;
    _233++;
    if (_233 < _13.d2)
    goto _jump1631;
    _233 = 0;
    _234++;
    if (_234 < _232)
    goto _jump1631;
    _234 = 0;
    _235++;
    if (_235 < _228)
    goto _jump1631;
    // End body of loop
    bool _238 = _230 > _231;
    int64_t _239 = 0;
    _239 *= _201.d0;
    _239 += _228;
    _239 *= _201.d1;
    _239 += _227;
    _239 *= _201.d2;
    _239 += _226;
    _201.data[_239] = _238;
    _226++;
    if (_226 < _147.d0)
    goto _jump1627;
    _226 = 0;
    _227++;
    if (_227 < _13.d1)
    goto _jump1627;
    _227 = 0;
    _228++;
    if (_228 < _224)
    goto _jump1627;
    // End body of loop
    int64_t _240 = 902;
    bool _241 = i(_198);
    bool _242 = !_241;
    bool _243 = i(_198);
    bool _244 = _242 != _243;
    int64_t _245;
    if (!_244)
    goto _jump1632;
    _245 = d;
    goto _jump1633;
    _jump1632:;
    _245 = j;
    _jump1633:;
    if (_240 >= 0)
    goto _jump1634;
    fail_assertion("negative array index");
    _jump1634:;
    if (_240 < _201.d0)
    goto _jump1635;
    fail_assertion("index too large");
    _jump1635:;
    if (_245 >= 0)
    goto _jump1636;
    fail_assertion("negative array index");
    _jump1636:;
    if (_245 < _201.d1)
    goto _jump1637;
    fail_assertion("index too large");
    _jump1637:;
    if (_13.d2 >= 0)
    goto _jump1638;
    fail_assertion("negative array index");
    _jump1638:;
    if (_13.d2 < _201.d2)
    goto _jump1639;
    fail_assertion("index too large");
    _jump1639:;
    int64_t _246 = 0;
    _246 *= _201.d0;
    _246 += _240;
    _246 *= _201.d1;
    _246 += _245;
    _246 *= _201.d2;
    _246 += _13.d2;
    bool _247 = _201.data[_246];
    int64_t _248 = 0;
    _248 *= _180.d0;
    _248 += _200;
    _248 *= _180.d1;
    _248 += _199;
    _248 *= _180.d2;
    _248 += _198;
    _180.data[_248] = _247;
    _198++;
    if (_198 < _196)
    goto _jump1601;
    _198 = 0;
    _199++;
    if (_199 < c)
    goto _jump1601;
    _199 = 0;
    _200++;
    if (_200 < c)
    goto _jump1601;
    // End body of loop
    rgba _249 = h(_179, _180);
    bool _250 = i(_147.d0);
    bool _251;
    if (!_250)
    goto _jump1640;
    int64_t _253 = c - _147.d0;
    int64_t _254 = _13.d2 + _253;
    bool _255 = _254 >= _13.d2;
    bool _256;
    if (!_255)
    goto _jump1641;
    bool _257 = _147.d0 > _147.d0;
    _256 = _257;
    goto _jump1642;
    _jump1641:;
    _a1_bool _258;
    // Computing bound for u
    int64_t _259 = -_13.d1;
    _258.d0 = _259;
    if (_259 > 0) 
    goto _jump1643;
    fail_assertion("non-positive loop bound");
    _jump1643:;
    // Computing total size of heap memory to allocate
    int64_t _260 = 1;
    _260 *= _259;
    _260 *= sizeof(bool);
    _258.data = jpl_alloc(_260);
    int64_t _261 = 0; // u
    _jump1644:; // Begin body of loop
    bool _262 = false;
    int64_t _263 = 0;
    _263 *= _258.d0;
    _263 += _261;
    _258.data[_263] = _262;
    _261++;
    if (_261 < _259)
    goto _jump1644;
    // End body of loop
    if (_147.d0 >= 0)
    goto _jump1645;
    fail_assertion("negative array index");
    _jump1645:;
    if (_147.d0 < _258.d0)
    goto _jump1646;
    fail_assertion("index too large");
    _jump1646:;
    int64_t _264 = 0;
    _264 *= _258.d0;
    _264 += _147.d0;
    bool _265 = _258.data[_264];
    _256 = _265;
    _jump1642:;
    bool _266;
    if (!_256)
    goto _jump1647;
    if (c >= 0)
    goto _jump1648;
    fail_assertion("negative array index");
    _jump1648:;
    if (c < _147.d0)
    goto _jump1649;
    fail_assertion("index too large");
    _jump1649:;
    int64_t _267 = 0;
    _267 *= _147.d0;
    _267 += c;
    int64_t _268 = _147.data[_267];
    if (_147.d0 >= 0)
    goto _jump1650;
    fail_assertion("negative array index");
    _jump1650:;
    if (_147.d0 < _13.d0)
    goto _jump1651;
    fail_assertion("index too large");
    _jump1651:;
    if (c >= 0)
    goto _jump1652;
    fail_assertion("negative array index");
    _jump1652:;
    if (c < _13.d1)
    goto _jump1653;
    fail_assertion("index too large");
    _jump1653:;
    if (_268 >= 0)
    goto _jump1654;
    fail_assertion("negative array index");
    _jump1654:;
    if (_268 < _13.d2)
    goto _jump1655;
    fail_assertion("index too large");
    _jump1655:;
    int64_t _269 = 0;
    _269 *= _13.d0;
    _269 += _147.d0;
    _269 *= _13.d1;
    _269 += c;
    _269 *= _13.d2;
    _269 += _268;
    double _270 = _13.data[_269];
    double _271 = -_270;
    double _272 = 44.0;
    double _273 = -_272;
    double _274;
    // Computing bound for u
    if (_13.d1 > 0) 
    goto _jump1656;
    fail_assertion("non-positive loop bound");
    _jump1656:;
    // Computing bound for v
    int64_t _275;
    // Computing bound for u
    if (c > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    // Computing bound for v
    if (c > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    _275 = 0;
    int64_t _276 = 0; // v
    int64_t _277 = 0; // u
    _jump1659:; // Begin body of loop
    _275 += _13.d2;
    _276++;
    if (_276 < c)
    goto _jump1659;
    _276 = 0;
    _277++;
    if (_277 < c)
    goto _jump1659;
    // End body of loop
    if (_275 > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing bound for w
    if (_147.d0 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    _274 = 0;
    int64_t _278 = 0; // w
    int64_t _279 = 0; // v
    int64_t _280 = 0; // u
    _jump1662:; // Begin body of loop
    if (_279 >= 0)
    goto _jump1663;
    fail_assertion("negative array index");
    _jump1663:;
    if (_279 < _13.d0)
    goto _jump1664;
    fail_assertion("index too large");
    _jump1664:;
    if (j >= 0)
    goto _jump1665;
    fail_assertion("negative array index");
    _jump1665:;
    if (j < _13.d1)
    goto _jump1666;
    fail_assertion("index too large");
    _jump1666:;
    if (_279 >= 0)
    goto _jump1667;
    fail_assertion("negative array index");
    _jump1667:;
    if (_279 < _13.d2)
    goto _jump1668;
    fail_assertion("index too large");
    _jump1668:;
    int64_t _281 = 0;
    _281 *= _13.d0;
    _281 += _279;
    _281 *= _13.d1;
    _281 += j;
    _281 *= _13.d2;
    _281 += _279;
    double _282 = _13.data[_281];
    _274 += _282;
    _278++;
    if (_278 < _147.d0)
    goto _jump1662;
    _278 = 0;
    _279++;
    if (_279 < _275)
    goto _jump1662;
    _279 = 0;
    _280++;
    if (_280 < _13.d1)
    goto _jump1662;
    // End body of loop
    double _283 = _273 * _274;
    bool _284 = _271 != _283;
    _266 = _284;
    goto _jump1669;
    _jump1647:;
    double _285;
    // Computing bound for u
    int64_t _286 = 598;
    if (_286 > 0) 
    goto _jump1670;
    fail_assertion("non-positive loop bound");
    _jump1670:;
    _285 = 0;
    int64_t _287 = 0; // u
    _jump1671:; // Begin body of loop
    double _288 = 35.0;
    double _289;
    // Computing bound for v
    if (c > 0) 
    goto _jump1672;
    fail_assertion("non-positive loop bound");
    _jump1672:;
    // Computing bound for w
    if (_13.d1 > 0) 
    goto _jump1673;
    fail_assertion("non-positive loop bound");
    _jump1673:;
    // Computing bound for x
    if (_287 > 0) 
    goto _jump1674;
    fail_assertion("non-positive loop bound");
    _jump1674:;
    _289 = 0;
    int64_t _290 = 0; // x
    int64_t _291 = 0; // w
    int64_t _292 = 0; // v
    _jump1675:; // Begin body of loop
    _289 += g;
    _290++;
    if (_290 < _287)
    goto _jump1675;
    _290 = 0;
    _291++;
    if (_291 < _13.d1)
    goto _jump1675;
    _291 = 0;
    _292++;
    if (_292 < c)
    goto _jump1675;
    // End body of loop
    double _293 = _288 * _289;
    _285 += _293;
    _287++;
    if (_287 < _286)
    goto _jump1671;
    // End body of loop
    double _294 = -g;
    bool _295 = _285 > _294;
    _266 = _295;
    _jump1669:;
    bool _252 = _266;
    if (0 != _266)
    goto _jump1676;
    double _296;
    // Computing bound for u
    if (_13.d1 > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    // Computing bound for v
    if (_13.d1 > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    // Computing bound for w
    if (_13.d2 > 0) 
    goto _jump1679;
    fail_assertion("non-positive loop bound");
    _jump1679:;
    _296 = 0;
    int64_t _297 = 0; // w
    int64_t _298 = 0; // v
    int64_t _299 = 0; // u
    _jump1680:; // Begin body of loop
    _296 += g;
    _297++;
    if (_297 < _13.d2)
    goto _jump1680;
    _297 = 0;
    _298++;
    if (_298 < _13.d1)
    goto _jump1680;
    _298 = 0;
    _299++;
    if (_299 < _13.d1)
    goto _jump1680;
    // End body of loop
    if (_13.d1 >= 0)
    goto _jump1681;
    fail_assertion("negative array index");
    _jump1681:;
    if (_13.d1 < _13.d0)
    goto _jump1682;
    fail_assertion("index too large");
    _jump1682:;
    if (d >= 0)
    goto _jump1683;
    fail_assertion("negative array index");
    _jump1683:;
    if (d < _13.d1)
    goto _jump1684;
    fail_assertion("index too large");
    _jump1684:;
    if (j >= 0)
    goto _jump1685;
    fail_assertion("negative array index");
    _jump1685:;
    if (j < _13.d2)
    goto _jump1686;
    fail_assertion("index too large");
    _jump1686:;
    int64_t _300 = 0;
    _300 *= _13.d0;
    _300 += _13.d1;
    _300 *= _13.d1;
    _300 += d;
    _300 *= _13.d2;
    _300 += j;
    double _301 = _13.data[_300];
    bool _302 = _296 < _301;
    bool _303 = !_302;
    _a1_bool _304;
    if (!_303)
    goto _jump1687;
    bool _305 = _147.d0 < _13.d0;
    bool _306;
    if (!_305)
    goto _jump1688;
    bool _307 = false;
    _306 = _307;
    goto _jump1689;
    _jump1688:;
    bool _308 = i(_13.d2);
    _306 = _308;
    _jump1689:;
    _a1_bool _309;
    if (!_306)
    goto _jump1690;
    _a1_bool _310;
    // Computing bound for u
    _310.d0 = c;
    if (c > 0) 
    goto _jump1691;
    fail_assertion("non-positive loop bound");
    _jump1691:;
    // Computing total size of heap memory to allocate
    int64_t _311 = 1;
    _311 *= c;
    _311 *= sizeof(bool);
    _310.data = jpl_alloc(_311);
    int64_t _312 = 0; // u
    _jump1692:; // Begin body of loop
    bool _313 = i(d);
    int64_t _314 = 0;
    _314 *= _310.d0;
    _314 += _312;
    _310.data[_314] = _313;
    _312++;
    if (_312 < c)
    goto _jump1692;
    // End body of loop
    _309 = _310;
    goto _jump1693;
    _jump1690:;
    _a1_bool _315;
    // Computing bound for u
    _315.d0 = _147.d0;
    if (_147.d0 > 0) 
    goto _jump1694;
    fail_assertion("non-positive loop bound");
    _jump1694:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= _147.d0;
    _316 *= sizeof(bool);
    _315.data = jpl_alloc(_316);
    int64_t _317 = 0; // u
    _jump1695:; // Begin body of loop
    bool _318 = i(d);
    int64_t _319 = 0;
    _319 *= _315.d0;
    _319 += _317;
    _315.data[_319] = _318;
    _317++;
    if (_317 < _147.d0)
    goto _jump1695;
    // End body of loop
    _309 = _315;
    _jump1693:;
    _304 = _309;
    goto _jump1696;
    _jump1687:;
    _a1_bool _320;
    // Computing bound for u
    _320.d0 = _147.d0;
    if (_147.d0 > 0) 
    goto _jump1697;
    fail_assertion("non-positive loop bound");
    _jump1697:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= _147.d0;
    _321 *= sizeof(bool);
    _320.data = jpl_alloc(_321);
    int64_t _322 = 0; // u
    _jump1698:; // Begin body of loop
    bool _323 = true;
    int64_t _324 = 0;
    _324 *= _320.d0;
    _324 += _322;
    _320.data[_324] = _323;
    _322++;
    if (_322 < _147.d0)
    goto _jump1698;
    // End body of loop
    _a1__a1_bool _325;
    _325.d0 = 1;
    _325.data = jpl_alloc(sizeof(_a1_bool) * 1);
    _325.data[0] = _320;
    if (_13.d0 >= 0)
    goto _jump1699;
    fail_assertion("negative array index");
    _jump1699:;
    if (_13.d0 < _325.d0)
    goto _jump1700;
    fail_assertion("index too large");
    _jump1700:;
    int64_t _326 = 0;
    _326 *= _325.d0;
    _326 += _13.d0;
    _a1_bool _327 = _325.data[_326];
    _304 = _327;
    _jump1696:;
    int64_t _328;
    // Computing bound for u
    int64_t _329;
    // Computing bound for u
    int64_t _330 = _13.d0 % _147.d0;
    if (_330 > 0) 
    goto _jump1701;
    fail_assertion("non-positive loop bound");
    _jump1701:;
    // Computing bound for v
    if (_13.d2 > 0) 
    goto _jump1702;
    fail_assertion("non-positive loop bound");
    _jump1702:;
    // Computing bound for w
    if (_147.d0 > 0) 
    goto _jump1703;
    fail_assertion("non-positive loop bound");
    _jump1703:;
    _329 = 0;
    int64_t _331 = 0; // w
    int64_t _332 = 0; // v
    int64_t _333 = 0; // u
    _jump1704:; // Begin body of loop
    _329 += d;
    _331++;
    if (_331 < _147.d0)
    goto _jump1704;
    _331 = 0;
    _332++;
    if (_332 < _13.d2)
    goto _jump1704;
    _332 = 0;
    _333++;
    if (_333 < _330)
    goto _jump1704;
    // End body of loop
    if (_329 > 0) 
    goto _jump1705;
    fail_assertion("non-positive loop bound");
    _jump1705:;
    // Computing bound for v
    if (c > 0) 
    goto _jump1706;
    fail_assertion("non-positive loop bound");
    _jump1706:;
    // Computing bound for w
    if (d > 0) 
    goto _jump1707;
    fail_assertion("non-positive loop bound");
    _jump1707:;
    _328 = 0;
    int64_t _334 = 0; // w
    int64_t _335 = 0; // v
    int64_t _336 = 0; // u
    _jump1708:; // Begin body of loop
    int64_t _337;
    // Computing bound for x
    if (_13.d0 > 0) 
    goto _jump1709;
    fail_assertion("non-positive loop bound");
    _jump1709:;
    // Computing bound for y
    if (d >= 0)
    goto _jump1710;
    fail_assertion("negative array index");
    _jump1710:;
    if (d < f.d0)
    goto _jump1711;
    fail_assertion("index too large");
    _jump1711:;
    if (j >= 0)
    goto _jump1712;
    fail_assertion("negative array index");
    _jump1712:;
    if (j < f.d1)
    goto _jump1713;
    fail_assertion("index too large");
    _jump1713:;
    int64_t _338 = 0;
    _338 *= f.d0;
    _338 += d;
    _338 *= f.d1;
    _338 += j;
    int64_t _339 = f.data[_338];
    if (_339 > 0) 
    goto _jump1714;
    fail_assertion("non-positive loop bound");
    _jump1714:;
    // Computing bound for z
    int64_t _340;
    // Computing bound for x
    if (_13.d2 > 0) 
    goto _jump1715;
    fail_assertion("non-positive loop bound");
    _jump1715:;
    _340 = 0;
    int64_t _341 = 0; // x
    _jump1716:; // Begin body of loop
    _340 += _13.d2;
    _341++;
    if (_341 < _13.d2)
    goto _jump1716;
    // End body of loop
    if (_340 > 0) 
    goto _jump1717;
    fail_assertion("non-positive loop bound");
    _jump1717:;
    _337 = 0;
    int64_t _342 = 0; // z
    int64_t _343 = 0; // y
    int64_t _344 = 0; // x
    _jump1718:; // Begin body of loop
    int64_t _345 = -_343;
    _337 += _345;
    _342++;
    if (_342 < _340)
    goto _jump1718;
    _342 = 0;
    _343++;
    if (_343 < _339)
    goto _jump1718;
    _343 = 0;
    _344++;
    if (_344 < _13.d0)
    goto _jump1718;
    // End body of loop
    _328 += _337;
    _334++;
    if (_334 < d)
    goto _jump1708;
    _334 = 0;
    _335++;
    if (_335 < c)
    goto _jump1708;
    _335 = 0;
    _336++;
    if (_336 < _329)
    goto _jump1708;
    // End body of loop
    int64_t _346 = _328 / _13.d2;
    if (_346 >= 0)
    goto _jump1719;
    fail_assertion("negative array index");
    _jump1719:;
    if (_346 < _304.d0)
    goto _jump1720;
    fail_assertion("index too large");
    _jump1720:;
    int64_t _347 = 0;
    _347 *= _304.d0;
    _347 += _346;
    bool _348 = _304.data[_347];
    _252 = _348;
    _jump1676:;
    _251 = _252;
    goto _jump1721;
    _jump1640:;
    double _351 = -g;
    double _352;
    // Computing bound for u
    if (_13.d1 > 0) 
    goto _jump1722;
    fail_assertion("non-positive loop bound");
    _jump1722:;
    // Computing bound for v
    if (_13.d1 > 0) 
    goto _jump1723;
    fail_assertion("non-positive loop bound");
    _jump1723:;
    // Computing bound for w
    if (_13.d1 > 0) 
    goto _jump1724;
    fail_assertion("non-positive loop bound");
    _jump1724:;
    _352 = 0;
    int64_t _353 = 0; // w
    int64_t _354 = 0; // v
    int64_t _355 = 0; // u
    _jump1725:; // Begin body of loop
    double _356 = 71.0;
    _352 += _356;
    _353++;
    if (_353 < _13.d1)
    goto _jump1725;
    _353 = 0;
    _354++;
    if (_354 < _13.d1)
    goto _jump1725;
    _354 = 0;
    _355++;
    if (_355 < _13.d1)
    goto _jump1725;
    // End body of loop
    bool _357 = _351 != _352;
    bool _358 = !_357;
    bool _359;
    if (!_358)
    goto _jump1726;
    bool _360 = true;
    bool _361 = !_360;
    bool _362;
    if (!_361)
    goto _jump1727;
    bool _363 = true;
    bool _364 = !_363;
    _362 = _364;
    goto _jump1728;
    _jump1727:;
    bool _365 = _13.d1 == _13.d0;
    _362 = _365;
    _jump1728:;
    bool _366;
    if (!_362)
    goto _jump1729;
    bool _367 = i(_13.d2);
    bool _368;
    if (!_367)
    goto _jump1730;
    bool _370 = true;
    bool _369 = _370;
    if (0 != _370)
    goto _jump1731;
    bool _371 = true;
    _369 = _371;
    _jump1731:;
    _368 = _369;
    goto _jump1732;
    _jump1730:;
    bool _372 = false;
    _368 = _372;
    _jump1732:;
    _366 = _368;
    goto _jump1733;
    _jump1729:;
    bool _373 = false;
    bool _374 = !_373;
    bool _375;
    if (!_374)
    goto _jump1734;
    bool _376 = false;
    _375 = _376;
    goto _jump1735;
    _jump1734:;
    bool _377 = true;
    _375 = _377;
    _jump1735:;
    _366 = _375;
    _jump1733:;
    _359 = _366;
    goto _jump1736;
    _jump1726:;
    bool _378 = false;
    _359 = _378;
    _jump1736:;
    bool _350 = _359;
    if (0 != _359)
    goto _jump1737;
    bool _379 = j < c;
    _350 = _379;
    _jump1737:;
    bool _349 = _350;
    if (0 != _350)
    goto _jump1738;
    int64_t _380 = -c;
    int64_t _381 = _147.d0 + _13.d1;
    int64_t _382 = _381 * _147.d0;
    bool _383 = _380 != _382;
    bool _384;
    if (!_383)
    goto _jump1739;
    bool _385 = false;
    _384 = _385;
    goto _jump1740;
    _jump1739:;
    double _386 = 92.0;
    double _387 = 95.0;
    double _388 = -_387;
    double _389 = -_388;
    bool _390 = _386 != _389;
    bool _391 = !_390;
    _384 = _391;
    _jump1740:;
    _349 = _384;
    _jump1738:;
    _251 = _349;
    _jump1721:;
    return _251;
    bool _392 = false;
    return _392;
}

int64_t j(void_t k, _a3_double l, int64_t m) {
    _a2_double _0;
    // Computing bound for n
    int64_t _1 = -d;
    int64_t _2 = -_1;
    int64_t _3 = -_2;
    _0.d0 = _3;
    if (_3 > 0) 
    goto _jump1870;
    fail_assertion("non-positive loop bound");
    _jump1870:;
    // Computing bound for o
    _a3__a3__a2_int64_t _4;
    // Computing bound for n
    double _5 = 47.0;
    bool _6 = _5 >= g;
    int64_t _7;
    if (!_6)
    goto _jump1871;
    int64_t _8 = 177;
    if (d >= 0)
    goto _jump1872;
    fail_assertion("negative array index");
    _jump1872:;
    if (d < f.d0)
    goto _jump1873;
    fail_assertion("index too large");
    _jump1873:;
    if (_8 >= 0)
    goto _jump1874;
    fail_assertion("negative array index");
    _jump1874:;
    if (_8 < f.d1)
    goto _jump1875;
    fail_assertion("index too large");
    _jump1875:;
    int64_t _9 = 0;
    _9 *= f.d0;
    _9 += d;
    _9 *= f.d1;
    _9 += _8;
    int64_t _10 = f.data[_9];
    _7 = _10;
    goto _jump1876;
    _jump1871:;
    _7 = m;
    _jump1876:;
    _4.d0 = _7;
    if (_7 > 0) 
    goto _jump1877;
    fail_assertion("non-positive loop bound");
    _jump1877:;
    // Computing bound for o
    int64_t _11 = 967;
    _4.d1 = _11;
    if (_11 > 0) 
    goto _jump1878;
    fail_assertion("non-positive loop bound");
    _jump1878:;
    // Computing bound for p
    int64_t _12 = 340;
    _4.d2 = _12;
    if (_12 > 0) 
    goto _jump1879;
    fail_assertion("non-positive loop bound");
    _jump1879:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _7;
    _13 *= _11;
    _13 *= _12;
    _13 *= sizeof(_a3__a2_int64_t);
    _4.data = jpl_alloc(_13);
    int64_t _14 = 0; // p
    int64_t _15 = 0; // o
    int64_t _16 = 0; // n
    _jump1880:; // Begin body of loop
    _a3__a2_int64_t _17;
    // Computing bound for q
    int64_t _18;
    // Computing bound for q
    if (_14 > 0) 
    goto _jump1881;
    fail_assertion("non-positive loop bound");
    _jump1881:;
    // Computing bound for r
    if (_14 > 0) 
    goto _jump1882;
    fail_assertion("non-positive loop bound");
    _jump1882:;
    _18 = 0;
    int64_t _19 = 0; // r
    int64_t _20 = 0; // q
    _jump1883:; // Begin body of loop
    _18 += d;
    _19++;
    if (_19 < _14)
    goto _jump1883;
    _19 = 0;
    _20++;
    if (_20 < _14)
    goto _jump1883;
    // End body of loop
    _17.d0 = _18;
    if (_18 > 0) 
    goto _jump1884;
    fail_assertion("non-positive loop bound");
    _jump1884:;
    // Computing bound for r
    int64_t _21 = -c;
    _17.d1 = _21;
    if (_21 > 0) 
    goto _jump1885;
    fail_assertion("non-positive loop bound");
    _jump1885:;
    // Computing bound for s
    _17.d2 = c;
    if (c > 0) 
    goto _jump1886;
    fail_assertion("non-positive loop bound");
    _jump1886:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= _18;
    _22 *= _21;
    _22 *= c;
    _22 *= sizeof(_a2_int64_t);
    _17.data = jpl_alloc(_22);
    int64_t _23 = 0; // s
    int64_t _24 = 0; // r
    int64_t _25 = 0; // q
    _jump1887:; // Begin body of loop
    _a2_int64_t _26;
    // Computing bound for t
    _26.d0 = _24;
    if (_24 > 0) 
    goto _jump1888;
    fail_assertion("non-positive loop bound");
    _jump1888:;
    // Computing bound for u
    _26.d1 = d;
    if (d > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= _24;
    _27 *= d;
    _27 *= sizeof(int64_t);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // u
    int64_t _29 = 0; // t
    _jump1890:; // Begin body of loop
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += _29;
    _30 *= _26.d1;
    _30 += _28;
    _26.data[_30] = _28;
    _28++;
    if (_28 < d)
    goto _jump1890;
    _28 = 0;
    _29++;
    if (_29 < _24)
    goto _jump1890;
    // End body of loop
    int64_t _31 = 0;
    _31 *= _17.d0;
    _31 += _25;
    _31 *= _17.d1;
    _31 += _24;
    _31 *= _17.d2;
    _31 += _23;
    _17.data[_31] = _26;
    _23++;
    if (_23 < c)
    goto _jump1887;
    _23 = 0;
    _24++;
    if (_24 < _21)
    goto _jump1887;
    _24 = 0;
    _25++;
    if (_25 < _18)
    goto _jump1887;
    // End body of loop
    int64_t _32 = 0;
    _32 *= _4.d0;
    _32 += _16;
    _32 *= _4.d1;
    _32 += _15;
    _32 *= _4.d2;
    _32 += _14;
    _4.data[_32] = _17;
    _14++;
    if (_14 < _12)
    goto _jump1880;
    _14 = 0;
    _15++;
    if (_15 < _11)
    goto _jump1880;
    _15 = 0;
    _16++;
    if (_16 < _7)
    goto _jump1880;
    // End body of loop
    int64_t _33;
    // Computing bound for n
    if (d > 0) 
    goto _jump1891;
    fail_assertion("non-positive loop bound");
    _jump1891:;
    // Computing bound for o
    int64_t _34;
    // Computing bound for n
    if (m > 0) 
    goto _jump1892;
    fail_assertion("non-positive loop bound");
    _jump1892:;
    // Computing bound for o
    if (c > 0) 
    goto _jump1893;
    fail_assertion("non-positive loop bound");
    _jump1893:;
    _34 = 0;
    int64_t _35 = 0; // o
    int64_t _36 = 0; // n
    _jump1894:; // Begin body of loop
    int64_t _37 = j(k, l, _36);
    _34 += _37;
    _35++;
    if (_35 < c)
    goto _jump1894;
    _35 = 0;
    _36++;
    if (_36 < m)
    goto _jump1894;
    // End body of loop
    if (_34 > 0) 
    goto _jump1895;
    fail_assertion("non-positive loop bound");
    _jump1895:;
    _33 = 0;
    int64_t _38 = 0; // o
    int64_t _39 = 0; // n
    _jump1896:; // Begin body of loop
    _33 += c;
    _38++;
    if (_38 < _34)
    goto _jump1896;
    _38 = 0;
    _39++;
    if (_39 < d)
    goto _jump1896;
    // End body of loop
    double _40;
    // Computing bound for n
    if (d > 0) 
    goto _jump1897;
    fail_assertion("non-positive loop bound");
    _jump1897:;
    _40 = 0;
    int64_t _41 = 0; // n
    _jump1898:; // Begin body of loop
    double _42 = 60.0;
    _40 += _42;
    _41++;
    if (_41 < d)
    goto _jump1898;
    // End body of loop
    bool _43 = _40 >= g;
    int64_t _44;
    if (!_43)
    goto _jump1899;
    _44 = m;
    goto _jump1900;
    _jump1899:;
    int64_t _45;
    // Computing bound for n
    if (c > 0) 
    goto _jump1901;
    fail_assertion("non-positive loop bound");
    _jump1901:;
    // Computing bound for o
    if (m > 0) 
    goto _jump1902;
    fail_assertion("non-positive loop bound");
    _jump1902:;
    // Computing bound for p
    if (d > 0) 
    goto _jump1903;
    fail_assertion("non-positive loop bound");
    _jump1903:;
    _45 = 0;
    int64_t _46 = 0; // p
    int64_t _47 = 0; // o
    int64_t _48 = 0; // n
    _jump1904:; // Begin body of loop
    _45 += m;
    _46++;
    if (_46 < d)
    goto _jump1904;
    _46 = 0;
    _47++;
    if (_47 < m)
    goto _jump1904;
    _47 = 0;
    _48++;
    if (_48 < c)
    goto _jump1904;
    // End body of loop
    int64_t _49 = -_45;
    _44 = _49;
    _jump1900:;
    if (_33 >= 0)
    goto _jump1905;
    fail_assertion("negative array index");
    _jump1905:;
    if (_33 < _4.d0)
    goto _jump1906;
    fail_assertion("index too large");
    _jump1906:;
    if (_44 >= 0)
    goto _jump1907;
    fail_assertion("negative array index");
    _jump1907:;
    if (_44 < _4.d1)
    goto _jump1908;
    fail_assertion("index too large");
    _jump1908:;
    if (c >= 0)
    goto _jump1909;
    fail_assertion("negative array index");
    _jump1909:;
    if (c < _4.d2)
    goto _jump1910;
    fail_assertion("index too large");
    _jump1910:;
    int64_t _50 = 0;
    _50 *= _4.d0;
    _50 += _33;
    _50 *= _4.d1;
    _50 += _44;
    _50 *= _4.d2;
    _50 += c;
    _a3__a2_int64_t _51 = _4.data[_50];
    bool _52 = true;
    int64_t _53;
    if (!_52)
    goto _jump1911;
    int64_t _54 = -c;
    _53 = _54;
    goto _jump1912;
    _jump1911:;
    _a1_int64_t _55;
    // Computing bound for n
    _55.d0 = c;
    if (c > 0) 
    goto _jump1913;
    fail_assertion("non-positive loop bound");
    _jump1913:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= c;
    _56 *= sizeof(int64_t);
    _55.data = jpl_alloc(_56);
    int64_t _57 = 0; // n
    _jump1914:; // Begin body of loop
    int64_t _58 = 0;
    _58 *= _55.d0;
    _58 += _57;
    _55.data[_58] = d;
    _57++;
    if (_57 < c)
    goto _jump1914;
    // End body of loop
    if (m >= 0)
    goto _jump1915;
    fail_assertion("negative array index");
    _jump1915:;
    if (m < _55.d0)
    goto _jump1916;
    fail_assertion("index too large");
    _jump1916:;
    int64_t _59 = 0;
    _59 *= _55.d0;
    _59 += m;
    int64_t _60 = _55.data[_59];
    int64_t _61 = -_60;
    _53 = _61;
    _jump1912:;
    if (m >= 0)
    goto _jump1917;
    fail_assertion("negative array index");
    _jump1917:;
    if (m < _51.d0)
    goto _jump1918;
    fail_assertion("index too large");
    _jump1918:;
    if (d >= 0)
    goto _jump1919;
    fail_assertion("negative array index");
    _jump1919:;
    if (d < _51.d1)
    goto _jump1920;
    fail_assertion("index too large");
    _jump1920:;
    if (_53 >= 0)
    goto _jump1921;
    fail_assertion("negative array index");
    _jump1921:;
    if (_53 < _51.d2)
    goto _jump1922;
    fail_assertion("index too large");
    _jump1922:;
    int64_t _62 = 0;
    _62 *= _51.d0;
    _62 += m;
    _62 *= _51.d1;
    _62 += d;
    _62 *= _51.d2;
    _62 += _53;
    _a2_int64_t _63 = _51.data[_62];
    _a3_double _64;
    // Computing bound for n
    int64_t _65 = 94;
    _64.d0 = _65;
    if (_65 > 0) 
    goto _jump1923;
    fail_assertion("non-positive loop bound");
    _jump1923:;
    // Computing bound for o
    int64_t _66 = 974;
    _64.d1 = _66;
    if (_66 > 0) 
    goto _jump1924;
    fail_assertion("non-positive loop bound");
    _jump1924:;
    // Computing bound for p
    int64_t _67;
    // Computing bound for n
    if (d > 0) 
    goto _jump1925;
    fail_assertion("non-positive loop bound");
    _jump1925:;
    _67 = 0;
    int64_t _68 = 0; // n
    _jump1926:; // Begin body of loop
    _67 += m;
    _68++;
    if (_68 < d)
    goto _jump1926;
    // End body of loop
    int64_t _69 = -_67;
    _64.d2 = _69;
    if (_69 > 0) 
    goto _jump1927;
    fail_assertion("non-positive loop bound");
    _jump1927:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= _65;
    _70 *= _66;
    _70 *= _69;
    _70 *= sizeof(double);
    _64.data = jpl_alloc(_70);
    int64_t _71 = 0; // p
    int64_t _72 = 0; // o
    int64_t _73 = 0; // n
    _jump1928:; // Begin body of loop
    _a2_double _74;
    // Computing bound for q
    _74.d0 = d;
    if (d > 0) 
    goto _jump1929;
    fail_assertion("non-positive loop bound");
    _jump1929:;
    // Computing bound for r
    int64_t _75 = m % _72;
    _74.d1 = _75;
    if (_75 > 0) 
    goto _jump1930;
    fail_assertion("non-positive loop bound");
    _jump1930:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= d;
    _76 *= _75;
    _76 *= sizeof(double);
    _74.data = jpl_alloc(_76);
    int64_t _77 = 0; // r
    int64_t _78 = 0; // q
    _jump1931:; // Begin body of loop
    double _79;
    // Computing bound for s
    int64_t _80 = 682;
    if (_80 > 0) 
    goto _jump1932;
    fail_assertion("non-positive loop bound");
    _jump1932:;
    // Computing bound for t
    if (_72 > 0) 
    goto _jump1933;
    fail_assertion("non-positive loop bound");
    _jump1933:;
    // Computing bound for u
    if (_71 > 0) 
    goto _jump1934;
    fail_assertion("non-positive loop bound");
    _jump1934:;
    _79 = 0;
    int64_t _81 = 0; // u
    int64_t _82 = 0; // t
    int64_t _83 = 0; // s
    _jump1935:; // Begin body of loop
    double _84 = 18.0;
    _79 += _84;
    _81++;
    if (_81 < _71)
    goto _jump1935;
    _81 = 0;
    _82++;
    if (_82 < _72)
    goto _jump1935;
    _82 = 0;
    _83++;
    if (_83 < _80)
    goto _jump1935;
    // End body of loop
    int64_t _85 = 0;
    _85 *= _74.d0;
    _85 += _78;
    _85 *= _74.d1;
    _85 += _77;
    _74.data[_85] = _79;
    _77++;
    if (_77 < _75)
    goto _jump1931;
    _77 = 0;
    _78++;
    if (_78 < d)
    goto _jump1931;
    // End body of loop
    int64_t _86 = -m;
    if (_71 >= 0)
    goto _jump1936;
    fail_assertion("negative array index");
    _jump1936:;
    if (_71 < _74.d0)
    goto _jump1937;
    fail_assertion("index too large");
    _jump1937:;
    if (_86 >= 0)
    goto _jump1938;
    fail_assertion("negative array index");
    _jump1938:;
    if (_86 < _74.d1)
    goto _jump1939;
    fail_assertion("index too large");
    _jump1939:;
    int64_t _87 = 0;
    _87 *= _74.d0;
    _87 += _71;
    _87 *= _74.d1;
    _87 += _86;
    double _88 = _74.data[_87];
    int64_t _89 = 0;
    _89 *= _64.d0;
    _89 += _73;
    _89 *= _64.d1;
    _89 += _72;
    _89 *= _64.d2;
    _89 += _71;
    _64.data[_89] = _88;
    _71++;
    if (_71 < _69)
    goto _jump1928;
    _71 = 0;
    _72++;
    if (_72 < _66)
    goto _jump1928;
    _72 = 0;
    _73++;
    if (_73 < _65)
    goto _jump1928;
    // End body of loop
    _a1_void_t _90;
    _90.d0 = 3;
    _90.data = jpl_alloc(sizeof(void_t) * 3);
    _90.data[0] = k;
    _90.data[1] = k;
    _90.data[2] = k;
    int64_t _91 = -m;
    int64_t _92 = -_91;
    if (_92 >= 0)
    goto _jump1940;
    fail_assertion("negative array index");
    _jump1940:;
    if (_92 < _90.d0)
    goto _jump1941;
    fail_assertion("index too large");
    _jump1941:;
    int64_t _93 = 0;
    _93 *= _90.d0;
    _93 += _92;
    void_t _94 = _90.data[_93];
    _a3_double _95;
    // Computing bound for n
    _95.d0 = d;
    if (d > 0) 
    goto _jump1942;
    fail_assertion("non-positive loop bound");
    _jump1942:;
    // Computing bound for o
    _95.d1 = m;
    if (m > 0) 
    goto _jump1943;
    fail_assertion("non-positive loop bound");
    _jump1943:;
    // Computing bound for p
    int64_t _96;
    // Computing bound for n
    if (c > 0) 
    goto _jump1944;
    fail_assertion("non-positive loop bound");
    _jump1944:;
    // Computing bound for o
    if (d > 0) 
    goto _jump1945;
    fail_assertion("non-positive loop bound");
    _jump1945:;
    _96 = 0;
    int64_t _97 = 0; // o
    int64_t _98 = 0; // n
    _jump1946:; // Begin body of loop
    _96 += c;
    _97++;
    if (_97 < d)
    goto _jump1946;
    _97 = 0;
    _98++;
    if (_98 < c)
    goto _jump1946;
    // End body of loop
    if (d >= 0)
    goto _jump1947;
    fail_assertion("negative array index");
    _jump1947:;
    if (d < b.d0)
    goto _jump1948;
    fail_assertion("index too large");
    _jump1948:;
    if (_96 >= 0)
    goto _jump1949;
    fail_assertion("negative array index");
    _jump1949:;
    if (_96 < b.d1)
    goto _jump1950;
    fail_assertion("index too large");
    _jump1950:;
    int64_t _99 = 0;
    _99 *= b.d0;
    _99 += d;
    _99 *= b.d1;
    _99 += _96;
    int64_t _100 = b.data[_99];
    _95.d2 = _100;
    if (_100 > 0) 
    goto _jump1951;
    fail_assertion("non-positive loop bound");
    _jump1951:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= d;
    _101 *= m;
    _101 *= _100;
    _101 *= sizeof(double);
    _95.data = jpl_alloc(_101);
    int64_t _102 = 0; // p
    int64_t _103 = 0; // o
    int64_t _104 = 0; // n
    _jump1952:; // Begin body of loop
    rgba _105 = a();
    double _106 = _105.r;
    int64_t _107 = 0;
    _107 *= _95.d0;
    _107 += _104;
    _107 *= _95.d1;
    _107 += _103;
    _107 *= _95.d2;
    _107 += _102;
    _95.data[_107] = _106;
    _102++;
    if (_102 < _100)
    goto _jump1952;
    _102 = 0;
    _103++;
    if (_103 < m)
    goto _jump1952;
    _103 = 0;
    _104++;
    if (_104 < d)
    goto _jump1952;
    // End body of loop
    int64_t _108 = j(_94, _95, c);
    int64_t _109 = j(k, _64, _108);
    if (_109 >= 0)
    goto _jump1953;
    fail_assertion("negative array index");
    _jump1953:;
    if (_109 < _63.d0)
    goto _jump1954;
    fail_assertion("index too large");
    _jump1954:;
    if (d >= 0)
    goto _jump1955;
    fail_assertion("negative array index");
    _jump1955:;
    if (d < _63.d1)
    goto _jump1956;
    fail_assertion("index too large");
    _jump1956:;
    int64_t _110 = 0;
    _110 *= _63.d0;
    _110 += _109;
    _110 *= _63.d1;
    _110 += d;
    int64_t _111 = _63.data[_110];
    _0.d1 = _111;
    if (_111 > 0) 
    goto _jump1957;
    fail_assertion("non-positive loop bound");
    _jump1957:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _3;
    _112 *= _111;
    _112 *= sizeof(double);
    _0.data = jpl_alloc(_112);
    int64_t _113 = 0; // o
    int64_t _114 = 0; // n
    _jump1958:; // Begin body of loop
    double _115 = 73.0;
    double _116 = -_115;
    int64_t _117 = 0;
    _117 *= _0.d0;
    _117 += _114;
    _117 *= _0.d1;
    _117 += _113;
    _0.data[_117] = _116;
    _113++;
    if (_113 < _111)
    goto _jump1958;
    _113 = 0;
    _114++;
    if (_114 < _3)
    goto _jump1958;
    // End body of loop
    return _0.d0;
    double _118 = 35.0;
    rgba _119 = a();
    double _120 = _119.r;
    double _121 = 40.0;
    rgba _122 = { _120, _121, _118, _118 };
    double _123 = _122.g;
    double _124 = _118 + _123;
    bool _125 = _0.d0 <= _0.d0;
    void_t _126;
    if (!_125)
    goto _jump1959;
    _126 = k;
    goto _jump1960;
    _jump1959:;
    _126 = k;
    _jump1960:;
    _a3_double _127;
    // Computing bound for r
    int64_t _128 = 410;
    int64_t _129 = _128 / c;
    _127.d0 = _129;
    if (_129 > 0) 
    goto _jump1961;
    fail_assertion("non-positive loop bound");
    _jump1961:;
    // Computing bound for s
    _127.d1 = m;
    if (m > 0) 
    goto _jump1962;
    fail_assertion("non-positive loop bound");
    _jump1962:;
    // Computing bound for t
    int64_t _130;
    // Computing bound for r
    if (_0.d0 > 0) 
    goto _jump1963;
    fail_assertion("non-positive loop bound");
    _jump1963:;
    // Computing bound for s
    if (c > 0) 
    goto _jump1964;
    fail_assertion("non-positive loop bound");
    _jump1964:;
    // Computing bound for t
    int64_t _131 = 172;
    if (_131 > 0) 
    goto _jump1965;
    fail_assertion("non-positive loop bound");
    _jump1965:;
    _130 = 0;
    int64_t _132 = 0; // t
    int64_t _133 = 0; // s
    int64_t _134 = 0; // r
    _jump1966:; // Begin body of loop
    _130 += m;
    _132++;
    if (_132 < _131)
    goto _jump1966;
    _132 = 0;
    _133++;
    if (_133 < c)
    goto _jump1966;
    _133 = 0;
    _134++;
    if (_134 < _0.d0)
    goto _jump1966;
    // End body of loop
    _127.d2 = _130;
    if (_130 > 0) 
    goto _jump1967;
    fail_assertion("non-positive loop bound");
    _jump1967:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= _129;
    _135 *= m;
    _135 *= _130;
    _135 *= sizeof(double);
    _127.data = jpl_alloc(_135);
    int64_t _136 = 0; // t
    int64_t _137 = 0; // s
    int64_t _138 = 0; // r
    _jump1968:; // Begin body of loop
    double _139 = 68.0;
    double _140 = _139 + _118;
    int64_t _141 = 0;
    _141 *= _127.d0;
    _141 += _138;
    _141 *= _127.d1;
    _141 += _137;
    _141 *= _127.d2;
    _141 += _136;
    _127.data[_141] = _140;
    _136++;
    if (_136 < _130)
    goto _jump1968;
    _136 = 0;
    _137++;
    if (_137 < m)
    goto _jump1968;
    _137 = 0;
    _138++;
    if (_138 < _129)
    goto _jump1968;
    // End body of loop
    int64_t _142;
    // Computing bound for r
    if (_0.d0 > 0) 
    goto _jump1969;
    fail_assertion("non-positive loop bound");
    _jump1969:;
    // Computing bound for s
    int64_t _143 = m + _0.d1;
    if (_143 > 0) 
    goto _jump1970;
    fail_assertion("non-positive loop bound");
    _jump1970:;
    _142 = 0;
    int64_t _144 = 0; // s
    int64_t _145 = 0; // r
    _jump1971:; // Begin body of loop
    _142 += c;
    _144++;
    if (_144 < _143)
    goto _jump1971;
    _144 = 0;
    _145++;
    if (_145 < _0.d0)
    goto _jump1971;
    // End body of loop
    int64_t _146 = j(_126, _127, _142);
    int64_t _147 = -_146;
    bool _148 = i(_147);
    double _149;
    if (!_148)
    goto _jump1972;
    _149 = _118;
    goto _jump1973;
    _jump1972:;
    double _150 = -g;
    _149 = _150;
    _jump1973:;
    bool _151 = _124 != _149;
    if (0 != _151)
    goto _jump1974;
    fail_assertion("r");
    _jump1974:;
    bool _152 = true;
    if (0 != _152)
    goto _jump1975;
    fail_assertion("r");
    _jump1975:;
    bool _153 = m == _0.d1;
    int64_t _154;
    if (!_153)
    goto _jump1976;
    int64_t _155 = 321;
    bool _156 = _0.d1 > _155;
    _a3_int64_t _157;
    if (!_156)
    goto _jump1977;
    _a3_int64_t _158;
    // Computing bound for r
    _158.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1978;
    fail_assertion("non-positive loop bound");
    _jump1978:;
    // Computing bound for s
    _158.d1 = m;
    if (m > 0) 
    goto _jump1979;
    fail_assertion("non-positive loop bound");
    _jump1979:;
    // Computing bound for t
    _158.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1980;
    fail_assertion("non-positive loop bound");
    _jump1980:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _0.d1;
    _159 *= m;
    _159 *= _0.d1;
    _159 *= sizeof(int64_t);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // t
    int64_t _161 = 0; // s
    int64_t _162 = 0; // r
    _jump1981:; // Begin body of loop
    int64_t _163 = 0;
    _163 *= _158.d0;
    _163 += _162;
    _163 *= _158.d1;
    _163 += _161;
    _163 *= _158.d2;
    _163 += _160;
    _158.data[_163] = d;
    _160++;
    if (_160 < _0.d1)
    goto _jump1981;
    _160 = 0;
    _161++;
    if (_161 < m)
    goto _jump1981;
    _161 = 0;
    _162++;
    if (_162 < _0.d1)
    goto _jump1981;
    // End body of loop
    _157 = _158;
    goto _jump1982;
    _jump1977:;
    _a3_int64_t _164;
    // Computing bound for r
    _164.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1983;
    fail_assertion("non-positive loop bound");
    _jump1983:;
    // Computing bound for s
    _164.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1984;
    fail_assertion("non-positive loop bound");
    _jump1984:;
    // Computing bound for t
    _164.d2 = m;
    if (m > 0) 
    goto _jump1985;
    fail_assertion("non-positive loop bound");
    _jump1985:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= _0.d0;
    _165 *= _0.d0;
    _165 *= m;
    _165 *= sizeof(int64_t);
    _164.data = jpl_alloc(_165);
    int64_t _166 = 0; // t
    int64_t _167 = 0; // s
    int64_t _168 = 0; // r
    _jump1986:; // Begin body of loop
    int64_t _169 = 0;
    _169 *= _164.d0;
    _169 += _168;
    _169 *= _164.d1;
    _169 += _167;
    _169 *= _164.d2;
    _169 += _166;
    _164.data[_169] = _168;
    _166++;
    if (_166 < m)
    goto _jump1986;
    _166 = 0;
    _167++;
    if (_167 < _0.d0)
    goto _jump1986;
    _167 = 0;
    _168++;
    if (_168 < _0.d0)
    goto _jump1986;
    // End body of loop
    _157 = _164;
    _jump1982:;
    int64_t _170;
    // Computing bound for r
    if (_0.d1 > 0) 
    goto _jump1987;
    fail_assertion("non-positive loop bound");
    _jump1987:;
    // Computing bound for s
    if (_0.d1 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    _170 = 0;
    int64_t _171 = 0; // s
    int64_t _172 = 0; // r
    _jump1989:; // Begin body of loop
    _170 += _171;
    _171++;
    if (_171 < _0.d1)
    goto _jump1989;
    _171 = 0;
    _172++;
    if (_172 < _0.d1)
    goto _jump1989;
    // End body of loop
    int64_t _173;
    // Computing bound for r
    if (d >= 0)
    goto _jump1990;
    fail_assertion("negative array index");
    _jump1990:;
    if (d < f.d0)
    goto _jump1991;
    fail_assertion("index too large");
    _jump1991:;
    if (_0.d0 >= 0)
    goto _jump1992;
    fail_assertion("negative array index");
    _jump1992:;
    if (_0.d0 < f.d1)
    goto _jump1993;
    fail_assertion("index too large");
    _jump1993:;
    int64_t _174 = 0;
    _174 *= f.d0;
    _174 += d;
    _174 *= f.d1;
    _174 += _0.d0;
    int64_t _175 = f.data[_174];
    if (_175 > 0) 
    goto _jump1994;
    fail_assertion("non-positive loop bound");
    _jump1994:;
    _173 = 0;
    int64_t _176 = 0; // r
    _jump1995:; // Begin body of loop
    _173 += c;
    _176++;
    if (_176 < _175)
    goto _jump1995;
    // End body of loop
    if (m >= 0)
    goto _jump1996;
    fail_assertion("negative array index");
    _jump1996:;
    if (m < _157.d0)
    goto _jump1997;
    fail_assertion("index too large");
    _jump1997:;
    if (_170 >= 0)
    goto _jump1998;
    fail_assertion("negative array index");
    _jump1998:;
    if (_170 < _157.d1)
    goto _jump1999;
    fail_assertion("index too large");
    _jump1999:;
    if (_173 >= 0)
    goto _jump2000;
    fail_assertion("negative array index");
    _jump2000:;
    if (_173 < _157.d2)
    goto _jump2001;
    fail_assertion("index too large");
    _jump2001:;
    int64_t _177 = 0;
    _177 *= _157.d0;
    _177 += m;
    _177 *= _157.d1;
    _177 += _170;
    _177 *= _157.d2;
    _177 += _173;
    int64_t _178 = _157.data[_177];
    bool _179 = i(c);
    _a3_int64_t _180;
    if (!_179)
    goto _jump2002;
    _a3_int64_t _181;
    // Computing bound for r
    _181.d0 = d;
    if (d > 0) 
    goto _jump2003;
    fail_assertion("non-positive loop bound");
    _jump2003:;
    // Computing bound for s
    _181.d1 = d;
    if (d > 0) 
    goto _jump2004;
    fail_assertion("non-positive loop bound");
    _jump2004:;
    // Computing bound for t
    int64_t _182 = 867;
    _181.d2 = _182;
    if (_182 > 0) 
    goto _jump2005;
    fail_assertion("non-positive loop bound");
    _jump2005:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= d;
    _183 *= d;
    _183 *= _182;
    _183 *= sizeof(int64_t);
    _181.data = jpl_alloc(_183);
    int64_t _184 = 0; // t
    int64_t _185 = 0; // s
    int64_t _186 = 0; // r
    _jump2006:; // Begin body of loop
    int64_t _187 = 0;
    _187 *= _181.d0;
    _187 += _186;
    _187 *= _181.d1;
    _187 += _185;
    _187 *= _181.d2;
    _187 += _184;
    _181.data[_187] = _186;
    _184++;
    if (_184 < _182)
    goto _jump2006;
    _184 = 0;
    _185++;
    if (_185 < d)
    goto _jump2006;
    _185 = 0;
    _186++;
    if (_186 < d)
    goto _jump2006;
    // End body of loop
    _180 = _181;
    goto _jump2007;
    _jump2002:;
    _a3_int64_t _188;
    // Computing bound for r
    _188.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump2008;
    fail_assertion("non-positive loop bound");
    _jump2008:;
    // Computing bound for s
    _188.d1 = d;
    if (d > 0) 
    goto _jump2009;
    fail_assertion("non-positive loop bound");
    _jump2009:;
    // Computing bound for t
    _188.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump2010;
    fail_assertion("non-positive loop bound");
    _jump2010:;
    // Computing total size of heap memory to allocate
    int64_t _189 = 1;
    _189 *= _0.d1;
    _189 *= d;
    _189 *= _0.d1;
    _189 *= sizeof(int64_t);
    _188.data = jpl_alloc(_189);
    int64_t _190 = 0; // t
    int64_t _191 = 0; // s
    int64_t _192 = 0; // r
    _jump2011:; // Begin body of loop
    int64_t _193 = 0;
    _193 *= _188.d0;
    _193 += _192;
    _193 *= _188.d1;
    _193 += _191;
    _193 *= _188.d2;
    _193 += _190;
    _188.data[_193] = _0.d1;
    _190++;
    if (_190 < _0.d1)
    goto _jump2011;
    _190 = 0;
    _191++;
    if (_191 < d)
    goto _jump2011;
    _191 = 0;
    _192++;
    if (_192 < _0.d1)
    goto _jump2011;
    // End body of loop
    _180 = _188;
    _jump2007:;
    int64_t _194 = j(k, l, _0.d0);
    _a2_int64_t _195;
    // Computing bound for r
    int64_t _196 = 382;
    _195.d0 = _196;
    if (_196 > 0) 
    goto _jump2012;
    fail_assertion("non-positive loop bound");
    _jump2012:;
    // Computing bound for s
    _195.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump2013;
    fail_assertion("non-positive loop bound");
    _jump2013:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= _196;
    _197 *= _0.d1;
    _197 *= sizeof(int64_t);
    _195.data = jpl_alloc(_197);
    int64_t _198 = 0; // s
    int64_t _199 = 0; // r
    _jump2014:; // Begin body of loop
    int64_t _200 = 0;
    _200 *= _195.d0;
    _200 += _199;
    _200 *= _195.d1;
    _200 += _198;
    _195.data[_200] = d;
    _198++;
    if (_198 < _0.d1)
    goto _jump2014;
    _198 = 0;
    _199++;
    if (_199 < _196)
    goto _jump2014;
    // End body of loop
    int64_t _201 = -m;
    int64_t _202;
    // Computing bound for r
    if (c > 0) 
    goto _jump2015;
    fail_assertion("non-positive loop bound");
    _jump2015:;
    _202 = 0;
    int64_t _203 = 0; // r
    _jump2016:; // Begin body of loop
    int64_t _204 = 93;
    _202 += _204;
    _203++;
    if (_203 < c)
    goto _jump2016;
    // End body of loop
    if (_201 >= 0)
    goto _jump2017;
    fail_assertion("negative array index");
    _jump2017:;
    if (_201 < _195.d0)
    goto _jump2018;
    fail_assertion("index too large");
    _jump2018:;
    if (_202 >= 0)
    goto _jump2019;
    fail_assertion("negative array index");
    _jump2019:;
    if (_202 < _195.d1)
    goto _jump2020;
    fail_assertion("index too large");
    _jump2020:;
    int64_t _205 = 0;
    _205 *= _195.d0;
    _205 += _201;
    _205 *= _195.d1;
    _205 += _202;
    int64_t _206 = _195.data[_205];
    if (_194 >= 0)
    goto _jump2021;
    fail_assertion("negative array index");
    _jump2021:;
    if (_194 < _180.d0)
    goto _jump2022;
    fail_assertion("index too large");
    _jump2022:;
    if (_206 >= 0)
    goto _jump2023;
    fail_assertion("negative array index");
    _jump2023:;
    if (_206 < _180.d1)
    goto _jump2024;
    fail_assertion("index too large");
    _jump2024:;
    if (_0.d1 >= 0)
    goto _jump2025;
    fail_assertion("negative array index");
    _jump2025:;
    if (_0.d1 < _180.d2)
    goto _jump2026;
    fail_assertion("index too large");
    _jump2026:;
    int64_t _207 = 0;
    _207 *= _180.d0;
    _207 += _194;
    _207 *= _180.d1;
    _207 += _206;
    _207 *= _180.d2;
    _207 += _0.d1;
    int64_t _208 = _180.data[_207];
    if (_178 >= 0)
    goto _jump2027;
    fail_assertion("negative array index");
    _jump2027:;
    if (_178 < f.d0)
    goto _jump2028;
    fail_assertion("index too large");
    _jump2028:;
    if (_208 >= 0)
    goto _jump2029;
    fail_assertion("negative array index");
    _jump2029:;
    if (_208 < f.d1)
    goto _jump2030;
    fail_assertion("index too large");
    _jump2030:;
    int64_t _209 = 0;
    _209 *= f.d0;
    _209 += _178;
    _209 *= f.d1;
    _209 += _208;
    int64_t _210 = f.data[_209];
    int64_t _211 = -_210;
    _154 = _211;
    goto _jump2031;
    _jump1976:;
    _154 = m;
    _jump2031:;
    bool _212 = i(_154);
    return m;
}

rgba k() {
    _a1__a2__a2_int64_t _0;
    // Computing bound for l
    int64_t _1 = -c;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump2032;
    fail_assertion("non-positive loop bound");
    _jump2032:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= _1;
    _2 *= sizeof(_a2__a2_int64_t);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // l
    _jump2033:; // Begin body of loop
    _a2__a2_int64_t _4;
    // Computing bound for m
    int64_t _5 = -_3;
    _4.d0 = _5;
    if (_5 > 0) 
    goto _jump2034;
    fail_assertion("non-positive loop bound");
    _jump2034:;
    // Computing bound for n
    int64_t _6;
    // Computing bound for m
    if (d > 0) 
    goto _jump2035;
    fail_assertion("non-positive loop bound");
    _jump2035:;
    _6 = 0;
    int64_t _7 = 0; // m
    _jump2036:; // Begin body of loop
    _6 += d;
    _7++;
    if (_7 < d)
    goto _jump2036;
    // End body of loop
    _4.d1 = _6;
    if (_6 > 0) 
    goto _jump2037;
    fail_assertion("non-positive loop bound");
    _jump2037:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= _5;
    _8 *= _6;
    _8 *= sizeof(_a2_int64_t);
    _4.data = jpl_alloc(_8);
    int64_t _9 = 0; // n
    int64_t _10 = 0; // m
    _jump2038:; // Begin body of loop
    bool _11 = _10 <= _3;
    _a1__a2_int64_t _12;
    if (!_11)
    goto _jump2039;
    _a1__a2_int64_t _13;
    // Computing bound for o
    _13.d0 = _10;
    if (_10 > 0) 
    goto _jump2040;
    fail_assertion("non-positive loop bound");
    _jump2040:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _10;
    _14 *= sizeof(_a2_int64_t);
    _13.data = jpl_alloc(_14);
    int64_t _15 = 0; // o
    _jump2041:; // Begin body of loop
    int64_t _16 = 0;
    _16 *= _13.d0;
    _16 += _15;
    _13.data[_16] = f;
    _15++;
    if (_15 < _10)
    goto _jump2041;
    // End body of loop
    _12 = _13;
    goto _jump2042;
    _jump2039:;
    _a1__a2_int64_t _17;
    _17.d0 = 1;
    _17.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _17.data[0] = b;
    _12 = _17;
    _jump2042:;
    int64_t _18 = 546;
    if (_18 >= 0)
    goto _jump2043;
    fail_assertion("negative array index");
    _jump2043:;
    if (_18 < _12.d0)
    goto _jump2044;
    fail_assertion("index too large");
    _jump2044:;
    int64_t _19 = 0;
    _19 *= _12.d0;
    _19 += _18;
    _a2_int64_t _20 = _12.data[_19];
    int64_t _21 = 0;
    _21 *= _4.d0;
    _21 += _10;
    _21 *= _4.d1;
    _21 += _9;
    _4.data[_21] = _20;
    _9++;
    if (_9 < _6)
    goto _jump2038;
    _9 = 0;
    _10++;
    if (_10 < _5)
    goto _jump2038;
    // End body of loop
    int64_t _22 = 0;
    _22 *= _0.d0;
    _22 += _3;
    _0.data[_22] = _4;
    _3++;
    if (_3 < _1)
    goto _jump2033;
    // End body of loop
    int64_t _23 = 696;
    if (_23 >= 0)
    goto _jump2045;
    fail_assertion("negative array index");
    _jump2045:;
    if (_23 < _0.d0)
    goto _jump2046;
    fail_assertion("index too large");
    _jump2046:;
    int64_t _24 = 0;
    _24 *= _0.d0;
    _24 += _23;
    _a2__a2_int64_t _25 = _0.data[_24];
    int64_t _26 = 641;
    bool _27 = i(d);
    bool _28 = !_27;
    bool _29 = !_28;
    bool _30;
    if (!_29)
    goto _jump2047;
    bool _31 = d != d;
    bool _32 = false;
    bool _33 = _31 == _32;
    bool _34 = !_33;
    _30 = _34;
    goto _jump2048;
    _jump2047:;
    int64_t _36 = -c;
    bool _37 = i(_36);
    bool _35 = _37;
    if (0 == _37)
    goto _jump2049;
    double _38 = 91.0;
    bool _39 = _38 != g;
    _35 = _39;
    _jump2049:;
    _30 = _35;
    _jump2048:;
    int64_t _40;
    if (!_30)
    goto _jump2050;
    bool _41 = false;
    bool _42;
    if (!_41)
    goto _jump2051;
    bool _43 = false;
    _42 = _43;
    goto _jump2052;
    _jump2051:;
    bool _44 = true;
    _42 = _44;
    _jump2052:;
    _a2_int64_t _45;
    if (!_42)
    goto _jump2053;
    _45 = b;
    goto _jump2054;
    _jump2053:;
    _a2_int64_t _46;
    // Computing bound for l
    int64_t _47 = 237;
    _46.d0 = _47;
    if (_47 > 0) 
    goto _jump2055;
    fail_assertion("non-positive loop bound");
    _jump2055:;
    // Computing bound for m
    _46.d1 = c;
    if (c > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= _47;
    _48 *= c;
    _48 *= sizeof(int64_t);
    _46.data = jpl_alloc(_48);
    int64_t _49 = 0; // m
    int64_t _50 = 0; // l
    _jump2057:; // Begin body of loop
    int64_t _51 = 0;
    _51 *= _46.d0;
    _51 += _50;
    _51 *= _46.d1;
    _51 += _49;
    _46.data[_51] = c;
    _49++;
    if (_49 < c)
    goto _jump2057;
    _49 = 0;
    _50++;
    if (_50 < _47)
    goto _jump2057;
    // End body of loop
    _45 = _46;
    _jump2054:;
    int64_t _52 = 567;
    int64_t _53 = -_52;
    int64_t _54;
    // Computing bound for l
    if (c > 0) 
    goto _jump2058;
    fail_assertion("non-positive loop bound");
    _jump2058:;
    // Computing bound for m
    int64_t _55 = 804;
    if (_55 > 0) 
    goto _jump2059;
    fail_assertion("non-positive loop bound");
    _jump2059:;
    _54 = 0;
    int64_t _56 = 0; // m
    int64_t _57 = 0; // l
    _jump2060:; // Begin body of loop
    _54 += _57;
    _56++;
    if (_56 < _55)
    goto _jump2060;
    _56 = 0;
    _57++;
    if (_57 < c)
    goto _jump2060;
    // End body of loop
    int64_t _58 = -_54;
    if (_53 >= 0)
    goto _jump2061;
    fail_assertion("negative array index");
    _jump2061:;
    if (_53 < _45.d0)
    goto _jump2062;
    fail_assertion("index too large");
    _jump2062:;
    if (_58 >= 0)
    goto _jump2063;
    fail_assertion("negative array index");
    _jump2063:;
    if (_58 < _45.d1)
    goto _jump2064;
    fail_assertion("index too large");
    _jump2064:;
    int64_t _59 = 0;
    _59 *= _45.d0;
    _59 += _53;
    _59 *= _45.d1;
    _59 += _58;
    int64_t _60 = _45.data[_59];
    int64_t _61 = -_60;
    _40 = _61;
    goto _jump2065;
    _jump2050:;
    int64_t _62;
    // Computing bound for l
    if (c > 0) 
    goto _jump2066;
    fail_assertion("non-positive loop bound");
    _jump2066:;
    // Computing bound for m
    if (c > 0) 
    goto _jump2067;
    fail_assertion("non-positive loop bound");
    _jump2067:;
    _62 = 0;
    int64_t _63 = 0; // m
    int64_t _64 = 0; // l
    _jump2068:; // Begin body of loop
    _62 += _64;
    _63++;
    if (_63 < c)
    goto _jump2068;
    _63 = 0;
    _64++;
    if (_64 < c)
    goto _jump2068;
    // End body of loop
    if (_62 >= 0)
    goto _jump2069;
    fail_assertion("negative array index");
    _jump2069:;
    if (_62 < f.d0)
    goto _jump2070;
    fail_assertion("index too large");
    _jump2070:;
    if (d >= 0)
    goto _jump2071;
    fail_assertion("negative array index");
    _jump2071:;
    if (d < f.d1)
    goto _jump2072;
    fail_assertion("index too large");
    _jump2072:;
    int64_t _65 = 0;
    _65 *= f.d0;
    _65 += _62;
    _65 *= f.d1;
    _65 += d;
    int64_t _66 = f.data[_65];
    int64_t _67 = -_66;
    _40 = _67;
    _jump2065:;
    int64_t _68;
    // Computing bound for l
    if (d > 0) 
    goto _jump2073;
    fail_assertion("non-positive loop bound");
    _jump2073:;
    _68 = 0;
    int64_t _69 = 0; // l
    _jump2074:; // Begin body of loop
    _a3_int64_t _70;
    // Computing bound for m
    _70.d0 = d;
    if (d > 0) 
    goto _jump2075;
    fail_assertion("non-positive loop bound");
    _jump2075:;
    // Computing bound for n
    int64_t _71;
    // Computing bound for m
    int64_t _72 = d + d;
    if (_72 > 0) 
    goto _jump2076;
    fail_assertion("non-positive loop bound");
    _jump2076:;
    // Computing bound for n
    if (_69 > 0) 
    goto _jump2077;
    fail_assertion("non-positive loop bound");
    _jump2077:;
    // Computing bound for o
    int64_t _73 = -c;
    if (_73 > 0) 
    goto _jump2078;
    fail_assertion("non-positive loop bound");
    _jump2078:;
    _71 = 0;
    int64_t _74 = 0; // o
    int64_t _75 = 0; // n
    int64_t _76 = 0; // m
    _jump2079:; // Begin body of loop
    int64_t _77 = 715;
    int64_t _78 = _74 / _77;
    _71 += _78;
    _74++;
    if (_74 < _73)
    goto _jump2079;
    _74 = 0;
    _75++;
    if (_75 < _69)
    goto _jump2079;
    _75 = 0;
    _76++;
    if (_76 < _72)
    goto _jump2079;
    // End body of loop
    _70.d1 = _71;
    if (_71 > 0) 
    goto _jump2080;
    fail_assertion("non-positive loop bound");
    _jump2080:;
    // Computing bound for o
    _70.d2 = c;
    if (c > 0) 
    goto _jump2081;
    fail_assertion("non-positive loop bound");
    _jump2081:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= d;
    _79 *= _71;
    _79 *= c;
    _79 *= sizeof(int64_t);
    _70.data = jpl_alloc(_79);
    int64_t _80 = 0; // o
    int64_t _81 = 0; // n
    int64_t _82 = 0; // m
    _jump2082:; // Begin body of loop
    int64_t _83 = 0;
    _83 *= _70.d0;
    _83 += _82;
    _83 *= _70.d1;
    _83 += _81;
    _83 *= _70.d2;
    _83 += _80;
    _70.data[_83] = _82;
    _80++;
    if (_80 < c)
    goto _jump2082;
    _80 = 0;
    _81++;
    if (_81 < _71)
    goto _jump2082;
    _81 = 0;
    _82++;
    if (_82 < d)
    goto _jump2082;
    // End body of loop
    _a3_int64_t _84;
    // Computing bound for m
    _84.d0 = _69;
    if (_69 > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing bound for n
    _84.d1 = c;
    if (c > 0) 
    goto _jump2084;
    fail_assertion("non-positive loop bound");
    _jump2084:;
    // Computing bound for o
    _84.d2 = d;
    if (d > 0) 
    goto _jump2085;
    fail_assertion("non-positive loop bound");
    _jump2085:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= _69;
    _85 *= c;
    _85 *= d;
    _85 *= sizeof(int64_t);
    _84.data = jpl_alloc(_85);
    int64_t _86 = 0; // o
    int64_t _87 = 0; // n
    int64_t _88 = 0; // m
    _jump2086:; // Begin body of loop
    int64_t _89 = 0;
    _89 *= _84.d0;
    _89 += _88;
    _89 *= _84.d1;
    _89 += _87;
    _89 *= _84.d2;
    _89 += _86;
    _84.data[_89] = _86;
    _86++;
    if (_86 < d)
    goto _jump2086;
    _86 = 0;
    _87++;
    if (_87 < c)
    goto _jump2086;
    _87 = 0;
    _88++;
    if (_88 < _69)
    goto _jump2086;
    // End body of loop
    int64_t _90 = -c;
    int64_t _91;
    // Computing bound for m
    if (d > 0) 
    goto _jump2087;
    fail_assertion("non-positive loop bound");
    _jump2087:;
    // Computing bound for n
    if (c > 0) 
    goto _jump2088;
    fail_assertion("non-positive loop bound");
    _jump2088:;
    // Computing bound for o
    if (_69 > 0) 
    goto _jump2089;
    fail_assertion("non-positive loop bound");
    _jump2089:;
    _91 = 0;
    int64_t _92 = 0; // o
    int64_t _93 = 0; // n
    int64_t _94 = 0; // m
    _jump2090:; // Begin body of loop
    _91 += _93;
    _92++;
    if (_92 < _69)
    goto _jump2090;
    _92 = 0;
    _93++;
    if (_93 < c)
    goto _jump2090;
    _93 = 0;
    _94++;
    if (_94 < d)
    goto _jump2090;
    // End body of loop
    if (c >= 0)
    goto _jump2091;
    fail_assertion("negative array index");
    _jump2091:;
    if (c < _84.d0)
    goto _jump2092;
    fail_assertion("index too large");
    _jump2092:;
    if (_90 >= 0)
    goto _jump2093;
    fail_assertion("negative array index");
    _jump2093:;
    if (_90 < _84.d1)
    goto _jump2094;
    fail_assertion("index too large");
    _jump2094:;
    if (_91 >= 0)
    goto _jump2095;
    fail_assertion("negative array index");
    _jump2095:;
    if (_91 < _84.d2)
    goto _jump2096;
    fail_assertion("index too large");
    _jump2096:;
    int64_t _95 = 0;
    _95 *= _84.d0;
    _95 += c;
    _95 *= _84.d1;
    _95 += _90;
    _95 *= _84.d2;
    _95 += _91;
    int64_t _96 = _84.data[_95];
    int64_t _97 = -_96;
    int64_t _98;
    // Computing bound for m
    if (d > 0) 
    goto _jump2097;
    fail_assertion("non-positive loop bound");
    _jump2097:;
    // Computing bound for n
    if (_69 > 0) 
    goto _jump2098;
    fail_assertion("non-positive loop bound");
    _jump2098:;
    // Computing bound for o
    int64_t _99 = 15;
    if (_99 > 0) 
    goto _jump2099;
    fail_assertion("non-positive loop bound");
    _jump2099:;
    _98 = 0;
    int64_t _100 = 0; // o
    int64_t _101 = 0; // n
    int64_t _102 = 0; // m
    _jump2100:; // Begin body of loop
    int64_t _103 = c / _101;
    _98 += _103;
    _100++;
    if (_100 < _99)
    goto _jump2100;
    _100 = 0;
    _101++;
    if (_101 < _69)
    goto _jump2100;
    _101 = 0;
    _102++;
    if (_102 < d)
    goto _jump2100;
    // End body of loop
    int64_t _104 = _98 / _69;
    int64_t _105 = -d;
    if (_97 >= 0)
    goto _jump2101;
    fail_assertion("negative array index");
    _jump2101:;
    if (_97 < _70.d0)
    goto _jump2102;
    fail_assertion("index too large");
    _jump2102:;
    if (_104 >= 0)
    goto _jump2103;
    fail_assertion("negative array index");
    _jump2103:;
    if (_104 < _70.d1)
    goto _jump2104;
    fail_assertion("index too large");
    _jump2104:;
    if (_105 >= 0)
    goto _jump2105;
    fail_assertion("negative array index");
    _jump2105:;
    if (_105 < _70.d2)
    goto _jump2106;
    fail_assertion("index too large");
    _jump2106:;
    int64_t _106 = 0;
    _106 *= _70.d0;
    _106 += _97;
    _106 *= _70.d1;
    _106 += _104;
    _106 *= _70.d2;
    _106 += _105;
    int64_t _107 = _70.data[_106];
    _68 += _107;
    _69++;
    if (_69 < d)
    goto _jump2074;
    // End body of loop
    int64_t _108 = _40 - _68;
    if (_26 >= 0)
    goto _jump2107;
    fail_assertion("negative array index");
    _jump2107:;
    if (_26 < _25.d0)
    goto _jump2108;
    fail_assertion("index too large");
    _jump2108:;
    if (_108 >= 0)
    goto _jump2109;
    fail_assertion("negative array index");
    _jump2109:;
    if (_108 < _25.d1)
    goto _jump2110;
    fail_assertion("index too large");
    _jump2110:;
    int64_t _109 = 0;
    _109 *= _25.d0;
    _109 += _26;
    _109 *= _25.d1;
    _109 += _108;
    _a2_int64_t _110 = _25.data[_109];
    double _111 = 6.0;
    double _112 = -_111;
    bool _113 = _112 < _111;
    bool _114 = !_113;
    double _115;
    if (!_114)
    goto _jump2111;
    bool _116 = true;
    bool _117 = !_116;
    double _118;
    if (!_117)
    goto _jump2112;
    double _119 = 29.0;
    double _120 = -_119;
    _118 = _120;
    goto _jump2113;
    _jump2112:;
    _118 = _111;
    _jump2113:;
    double _121 = g * _118;
    _115 = _121;
    goto _jump2114;
    _jump2111:;
    _115 = g;
    _jump2114:;
    bool _122 = _115 >= g;
    _a1__a1_int64_t _123;
    if (!_122)
    goto _jump2115;
    double _124;
    // Computing bound for q
    int64_t _125 = 565;
    if (_125 > 0) 
    goto _jump2116;
    fail_assertion("non-positive loop bound");
    _jump2116:;
    // Computing bound for r
    if (_110.d0 > 0) 
    goto _jump2117;
    fail_assertion("non-positive loop bound");
    _jump2117:;
    // Computing bound for s
    if (_110.d0 > 0) 
    goto _jump2118;
    fail_assertion("non-positive loop bound");
    _jump2118:;
    _124 = 0;
    int64_t _126 = 0; // s
    int64_t _127 = 0; // r
    int64_t _128 = 0; // q
    _jump2119:; // Begin body of loop
    _124 += _111;
    _126++;
    if (_126 < _110.d0)
    goto _jump2119;
    _126 = 0;
    _127++;
    if (_127 < _110.d0)
    goto _jump2119;
    _127 = 0;
    _128++;
    if (_128 < _125)
    goto _jump2119;
    // End body of loop
    double _129 = _111 + _111;
    bool _130 = _124 <= _129;
    _a1_int64_t _131;
    if (!_130)
    goto _jump2120;
    _a1__a1_int64_t _132;
    // Computing bound for q
    _132.d0 = c;
    if (c > 0) 
    goto _jump2121;
    fail_assertion("non-positive loop bound");
    _jump2121:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= c;
    _133 *= sizeof(_a1_int64_t);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // q
    _jump2122:; // Begin body of loop
    _a1_int64_t _135;
    // Computing bound for r
    _135.d0 = c;
    if (c > 0) 
    goto _jump2123;
    fail_assertion("non-positive loop bound");
    _jump2123:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= c;
    _136 *= sizeof(int64_t);
    _135.data = jpl_alloc(_136);
    int64_t _137 = 0; // r
    _jump2124:; // Begin body of loop
    int64_t _138 = 0;
    _138 *= _135.d0;
    _138 += _137;
    _135.data[_138] = _110.d1;
    _137++;
    if (_137 < c)
    goto _jump2124;
    // End body of loop
    int64_t _139 = 0;
    _139 *= _132.d0;
    _139 += _134;
    _132.data[_139] = _135;
    _134++;
    if (_134 < c)
    goto _jump2122;
    // End body of loop
    int64_t _140;
    // Computing bound for q
    if (d > 0) 
    goto _jump2125;
    fail_assertion("non-positive loop bound");
    _jump2125:;
    // Computing bound for r
    if (_110.d0 > 0) 
    goto _jump2126;
    fail_assertion("non-positive loop bound");
    _jump2126:;
    _140 = 0;
    int64_t _141 = 0; // r
    int64_t _142 = 0; // q
    _jump2127:; // Begin body of loop
    _140 += _110.d1;
    _141++;
    if (_141 < _110.d0)
    goto _jump2127;
    _141 = 0;
    _142++;
    if (_142 < d)
    goto _jump2127;
    // End body of loop
    if (_140 >= 0)
    goto _jump2128;
    fail_assertion("negative array index");
    _jump2128:;
    if (_140 < _132.d0)
    goto _jump2129;
    fail_assertion("index too large");
    _jump2129:;
    int64_t _143 = 0;
    _143 *= _132.d0;
    _143 += _140;
    _a1_int64_t _144 = _132.data[_143];
    _131 = _144;
    goto _jump2130;
    _jump2120:;
    bool _145 = i(_110.d0);
    _a1_int64_t _146;
    if (!_145)
    goto _jump2131;
    _a1_int64_t _147;
    // Computing bound for q
    int64_t _148 = 435;
    _147.d0 = _148;
    if (_148 > 0) 
    goto _jump2132;
    fail_assertion("non-positive loop bound");
    _jump2132:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _148;
    _149 *= sizeof(int64_t);
    _147.data = jpl_alloc(_149);
    int64_t _150 = 0; // q
    _jump2133:; // Begin body of loop
    int64_t _151 = 971;
    int64_t _152 = 0;
    _152 *= _147.d0;
    _152 += _150;
    _147.data[_152] = _151;
    _150++;
    if (_150 < _148)
    goto _jump2133;
    // End body of loop
    _146 = _147;
    goto _jump2134;
    _jump2131:;
    int64_t _153 = 436;
    int64_t _154 = -_153;
    _a1_int64_t _155;
    _155.d0 = 2;
    _155.data = jpl_alloc(sizeof(int64_t) * 2);
    _155.data[0] = _154;
    _155.data[1] = _110.d0;
    _146 = _155;
    _jump2134:;
    _131 = _146;
    _jump2130:;
    _a1_int64_t _156;
    _156.d0 = 1;
    _156.data = jpl_alloc(sizeof(int64_t) * 1);
    _156.data[0] = _110.d0;
    _a1__a1_int64_t _157;
    _157.d0 = 2;
    _157.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _157.data[0] = _131;
    _157.data[1] = _156;
    _123 = _157;
    goto _jump2135;
    _jump2115:;
    bool _158 = false;
    _a1__a1_int64_t _159;
    if (!_158)
    goto _jump2136;
    _a3_bool _161;
    // Computing bound for q
    _161.d0 = d;
    if (d > 0) 
    goto _jump2137;
    fail_assertion("non-positive loop bound");
    _jump2137:;
    // Computing bound for r
    _161.d1 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2138;
    fail_assertion("non-positive loop bound");
    _jump2138:;
    // Computing bound for s
    int64_t _162 = 750;
    _161.d2 = _162;
    if (_162 > 0) 
    goto _jump2139;
    fail_assertion("non-positive loop bound");
    _jump2139:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= d;
    _163 *= _110.d1;
    _163 *= _162;
    _163 *= sizeof(bool);
    _161.data = jpl_alloc(_163);
    int64_t _164 = 0; // s
    int64_t _165 = 0; // r
    int64_t _166 = 0; // q
    _jump2140:; // Begin body of loop
    bool _167 = false;
    int64_t _168 = 0;
    _168 *= _161.d0;
    _168 += _166;
    _168 *= _161.d1;
    _168 += _165;
    _168 *= _161.d2;
    _168 += _164;
    _161.data[_168] = _167;
    _164++;
    if (_164 < _162)
    goto _jump2140;
    _164 = 0;
    _165++;
    if (_165 < _110.d1)
    goto _jump2140;
    _165 = 0;
    _166++;
    if (_166 < d)
    goto _jump2140;
    // End body of loop
    int64_t _169 = 129;
    int64_t _170 = d * _110.d0;
    if (c >= 0)
    goto _jump2141;
    fail_assertion("negative array index");
    _jump2141:;
    if (c < _161.d0)
    goto _jump2142;
    fail_assertion("index too large");
    _jump2142:;
    if (_169 >= 0)
    goto _jump2143;
    fail_assertion("negative array index");
    _jump2143:;
    if (_169 < _161.d1)
    goto _jump2144;
    fail_assertion("index too large");
    _jump2144:;
    if (_170 >= 0)
    goto _jump2145;
    fail_assertion("negative array index");
    _jump2145:;
    if (_170 < _161.d2)
    goto _jump2146;
    fail_assertion("index too large");
    _jump2146:;
    int64_t _171 = 0;
    _171 *= _161.d0;
    _171 += c;
    _171 *= _161.d1;
    _171 += _169;
    _171 *= _161.d2;
    _171 += _170;
    bool _172 = _161.data[_171];
    bool _160 = _172;
    if (0 != _172)
    goto _jump2147;
    bool _173 = false;
    _160 = _173;
    _jump2147:;
    _a1__a1_int64_t _174;
    if (!_160)
    goto _jump2148;
    double _176 = 12.0;
    double _177 = 6.0;
    bool _178 = _176 == _177;
    bool _175 = _178;
    if (0 == _178)
    goto _jump2149;
    int64_t _179 = 532;
    bool _180 = i(_179);
    _175 = _180;
    _jump2149:;
    _a1__a1_int64_t _181;
    if (!_175)
    goto _jump2150;
    _a1__a1_int64_t _182;
    // Computing bound for q
    int64_t _183 = -d;
    _182.d0 = _183;
    if (_183 > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= _183;
    _184 *= sizeof(_a1_int64_t);
    _182.data = jpl_alloc(_184);
    int64_t _185 = 0; // q
    _jump2152:; // Begin body of loop
    _a1_int64_t _186;
    // Computing bound for r
    _186.d0 = d;
    if (d > 0) 
    goto _jump2153;
    fail_assertion("non-positive loop bound");
    _jump2153:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= d;
    _187 *= sizeof(int64_t);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // r
    _jump2154:; // Begin body of loop
    int64_t _189 = 0;
    _189 *= _186.d0;
    _189 += _188;
    _186.data[_189] = d;
    _188++;
    if (_188 < d)
    goto _jump2154;
    // End body of loop
    int64_t _190 = 0;
    _190 *= _182.d0;
    _190 += _185;
    _182.data[_190] = _186;
    _185++;
    if (_185 < _183)
    goto _jump2152;
    // End body of loop
    _181 = _182;
    goto _jump2155;
    _jump2150:;
    _a1__a1_int64_t _191;
    // Computing bound for q
    _191.d0 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2156;
    fail_assertion("non-positive loop bound");
    _jump2156:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= _110.d1;
    _192 *= sizeof(_a1_int64_t);
    _191.data = jpl_alloc(_192);
    int64_t _193 = 0; // q
    _jump2157:; // Begin body of loop
    int64_t _194 = 206;
    int64_t _195 = 653;
    _a1_int64_t _196;
    _196.d0 = 3;
    _196.data = jpl_alloc(sizeof(int64_t) * 3);
    _196.data[0] = _110.d1;
    _196.data[1] = _194;
    _196.data[2] = _195;
    int64_t _197 = 0;
    _197 *= _191.d0;
    _197 += _193;
    _191.data[_197] = _196;
    _193++;
    if (_193 < _110.d1)
    goto _jump2157;
    // End body of loop
    _181 = _191;
    _jump2155:;
    _174 = _181;
    goto _jump2158;
    _jump2148:;
    _a1__a1_int64_t _198;
    // Computing bound for q
    int64_t _199 = 418;
    _198.d0 = _199;
    if (_199 > 0) 
    goto _jump2159;
    fail_assertion("non-positive loop bound");
    _jump2159:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= _199;
    _200 *= sizeof(_a1_int64_t);
    _198.data = jpl_alloc(_200);
    int64_t _201 = 0; // q
    _jump2160:; // Begin body of loop
    int64_t _202;
    // Computing bound for r
    if (d > 0) 
    goto _jump2161;
    fail_assertion("non-positive loop bound");
    _jump2161:;
    // Computing bound for s
    int64_t _203 = 903;
    if (_203 > 0) 
    goto _jump2162;
    fail_assertion("non-positive loop bound");
    _jump2162:;
    _202 = 0;
    int64_t _204 = 0; // s
    int64_t _205 = 0; // r
    _jump2163:; // Begin body of loop
    _202 += _201;
    _204++;
    if (_204 < _203)
    goto _jump2163;
    _204 = 0;
    _205++;
    if (_205 < d)
    goto _jump2163;
    // End body of loop
    _a1_int64_t _206;
    _206.d0 = 1;
    _206.data = jpl_alloc(sizeof(int64_t) * 1);
    _206.data[0] = _202;
    int64_t _207 = 0;
    _207 *= _198.d0;
    _207 += _201;
    _198.data[_207] = _206;
    _201++;
    if (_201 < _199)
    goto _jump2160;
    // End body of loop
    _174 = _198;
    _jump2158:;
    _159 = _174;
    goto _jump2164;
    _jump2136:;
    _a2__a1__a1_int64_t _208;
    // Computing bound for q
    int64_t _209 = 917;
    _208.d0 = _209;
    if (_209 > 0) 
    goto _jump2165;
    fail_assertion("non-positive loop bound");
    _jump2165:;
    // Computing bound for r
    int64_t _210 = -_110.d1;
    if (_110.d0 >= 0)
    goto _jump2166;
    fail_assertion("negative array index");
    _jump2166:;
    if (_110.d0 < f.d0)
    goto _jump2167;
    fail_assertion("index too large");
    _jump2167:;
    if (_210 >= 0)
    goto _jump2168;
    fail_assertion("negative array index");
    _jump2168:;
    if (_210 < f.d1)
    goto _jump2169;
    fail_assertion("index too large");
    _jump2169:;
    int64_t _211 = 0;
    _211 *= f.d0;
    _211 += _110.d0;
    _211 *= f.d1;
    _211 += _210;
    int64_t _212 = f.data[_211];
    _208.d1 = _212;
    if (_212 > 0) 
    goto _jump2170;
    fail_assertion("non-positive loop bound");
    _jump2170:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= _209;
    _213 *= _212;
    _213 *= sizeof(_a1__a1_int64_t);
    _208.data = jpl_alloc(_213);
    int64_t _214 = 0; // r
    int64_t _215 = 0; // q
    _jump2171:; // Begin body of loop
    _a1_int64_t _216;
    // Computing bound for s
    _216.d0 = _110.d0;
    if (_110.d0 > 0) 
    goto _jump2172;
    fail_assertion("non-positive loop bound");
    _jump2172:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= _110.d0;
    _217 *= sizeof(int64_t);
    _216.data = jpl_alloc(_217);
    int64_t _218 = 0; // s
    _jump2173:; // Begin body of loop
    int64_t _219 = 0;
    _219 *= _216.d0;
    _219 += _218;
    _216.data[_219] = _110.d1;
    _218++;
    if (_218 < _110.d0)
    goto _jump2173;
    // End body of loop
    _a1_int64_t _220;
    // Computing bound for s
    _220.d0 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2174;
    fail_assertion("non-positive loop bound");
    _jump2174:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _110.d1;
    _221 *= sizeof(int64_t);
    _220.data = jpl_alloc(_221);
    int64_t _222 = 0; // s
    _jump2175:; // Begin body of loop
    int64_t _223 = 0;
    _223 *= _220.d0;
    _223 += _222;
    _220.data[_223] = _222;
    _222++;
    if (_222 < _110.d1)
    goto _jump2175;
    // End body of loop
    _a1__a1_int64_t _224;
    _224.d0 = 2;
    _224.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _224.data[0] = _216;
    _224.data[1] = _220;
    int64_t _225 = 0;
    _225 *= _208.d0;
    _225 += _215;
    _225 *= _208.d1;
    _225 += _214;
    _208.data[_225] = _224;
    _214++;
    if (_214 < _212)
    goto _jump2171;
    _214 = 0;
    _215++;
    if (_215 < _209)
    goto _jump2171;
    // End body of loop
    int64_t _226;
    // Computing bound for q
    if (c > 0) 
    goto _jump2176;
    fail_assertion("non-positive loop bound");
    _jump2176:;
    _226 = 0;
    int64_t _227 = 0; // q
    _jump2177:; // Begin body of loop
    _226 += d;
    _227++;
    if (_227 < c)
    goto _jump2177;
    // End body of loop
    int64_t _228 = -_226;
    int64_t _229;
    // Computing bound for q
    int64_t _230 = 868;
    if (_230 > 0) 
    goto _jump2178;
    fail_assertion("non-positive loop bound");
    _jump2178:;
    // Computing bound for r
    int64_t _231;
    // Computing bound for q
    if (_110.d1 > 0) 
    goto _jump2179;
    fail_assertion("non-positive loop bound");
    _jump2179:;
    _231 = 0;
    int64_t _232 = 0; // q
    _jump2180:; // Begin body of loop
    int64_t _233 = c - _110.d1;
    _231 += _233;
    _232++;
    if (_232 < _110.d1)
    goto _jump2180;
    // End body of loop
    if (_231 > 0) 
    goto _jump2181;
    fail_assertion("non-positive loop bound");
    _jump2181:;
    // Computing bound for s
    int64_t _234 = 408;
    int64_t _235 = -_234;
    int64_t _236 = _110.d0 % _235;
    if (_236 > 0) 
    goto _jump2182;
    fail_assertion("non-positive loop bound");
    _jump2182:;
    _229 = 0;
    int64_t _237 = 0; // s
    int64_t _238 = 0; // r
    int64_t _239 = 0; // q
    _jump2183:; // Begin body of loop
    _229 += _110.d1;
    _237++;
    if (_237 < _236)
    goto _jump2183;
    _237 = 0;
    _238++;
    if (_238 < _231)
    goto _jump2183;
    _238 = 0;
    _239++;
    if (_239 < _230)
    goto _jump2183;
    // End body of loop
    if (_228 >= 0)
    goto _jump2184;
    fail_assertion("negative array index");
    _jump2184:;
    if (_228 < _208.d0)
    goto _jump2185;
    fail_assertion("index too large");
    _jump2185:;
    if (_229 >= 0)
    goto _jump2186;
    fail_assertion("negative array index");
    _jump2186:;
    if (_229 < _208.d1)
    goto _jump2187;
    fail_assertion("index too large");
    _jump2187:;
    int64_t _240 = 0;
    _240 *= _208.d0;
    _240 += _228;
    _240 *= _208.d1;
    _240 += _229;
    _a1__a1_int64_t _241 = _208.data[_240];
    _159 = _241;
    _jump2164:;
    _123 = _159;
    _jump2135:;
    if (_110.d1 >= 0)
    goto _jump2188;
    fail_assertion("negative array index");
    _jump2188:;
    if (_110.d1 < _123.d0)
    goto _jump2189;
    fail_assertion("index too large");
    _jump2189:;
    int64_t _242 = 0;
    _242 *= _123.d0;
    _242 += _110.d1;
    _a1_int64_t _243 = _123.data[_242];
    int64_t _245 = -_110.d1;
    int64_t _246 = _110.d0 / _245;
    bool _247 = _246 != _243.d0;
    bool _248;
    if (!_247)
    goto _jump2190;
    double _249 = 73.0;
    double _250 = -_111;
    bool _251 = _249 != _250;
    int64_t _252 = -d;
    int64_t _253 = 839;
    bool _254 = _252 < _253;
    bool _255 = _251 != _254;
    _248 = _255;
    goto _jump2191;
    _jump2190:;
    int64_t _256;
    // Computing bound for s
    if (c > 0) 
    goto _jump2192;
    fail_assertion("non-positive loop bound");
    _jump2192:;
    _256 = 0;
    int64_t _257 = 0; // s
    _jump2193:; // Begin body of loop
    _256 += _257;
    _257++;
    if (_257 < c)
    goto _jump2193;
    // End body of loop
    bool _258 = _110.d0 != _256;
    _248 = _258;
    _jump2191:;
    bool _244 = _248;
    if (0 != _248)
    goto _jump2194;
    _a2_int64_t _259;
    // Computing bound for s
    int64_t _260 = -_243.d0;
    _259.d0 = _260;
    if (_260 > 0) 
    goto _jump2195;
    fail_assertion("non-positive loop bound");
    _jump2195:;
    // Computing bound for t
    _259.d1 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2196;
    fail_assertion("non-positive loop bound");
    _jump2196:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _260;
    _261 *= _110.d1;
    _261 *= sizeof(int64_t);
    _259.data = jpl_alloc(_261);
    int64_t _262 = 0; // t
    int64_t _263 = 0; // s
    _jump2197:; // Begin body of loop
    int64_t _264 = 247;
    int64_t _265 = 0;
    _265 *= _259.d0;
    _265 += _263;
    _265 *= _259.d1;
    _265 += _262;
    _259.data[_265] = _264;
    _262++;
    if (_262 < _110.d1)
    goto _jump2197;
    _262 = 0;
    _263++;
    if (_263 < _260)
    goto _jump2197;
    // End body of loop
    int64_t _266 = 101;
    if (_266 >= 0)
    goto _jump2198;
    fail_assertion("negative array index");
    _jump2198:;
    if (_266 < _259.d0)
    goto _jump2199;
    fail_assertion("index too large");
    _jump2199:;
    if (_110.d0 >= 0)
    goto _jump2200;
    fail_assertion("negative array index");
    _jump2200:;
    if (_110.d0 < _259.d1)
    goto _jump2201;
    fail_assertion("index too large");
    _jump2201:;
    int64_t _267 = 0;
    _267 *= _259.d0;
    _267 += _266;
    _267 *= _259.d1;
    _267 += _110.d0;
    int64_t _268 = _259.data[_267];
    bool _269 = i(_268);
    _244 = _269;
    _jump2194:;
    _a2__a1_bool _270;
    if (!_244)
    goto _jump2202;
    _a2__a1_bool _271;
    // Computing bound for s
    _271.d0 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2203;
    fail_assertion("non-positive loop bound");
    _jump2203:;
    // Computing bound for t
    bool _274 = _110.d1 >= _110.d0;
    bool _273 = _274;
    if (0 != _274)
    goto _jump2204;
    bool _275 = i(d);
    _273 = _275;
    _jump2204:;
    bool _272 = _273;
    if (0 == _273)
    goto _jump2205;
    bool _276 = true;
    bool _277 = !_276;
    bool _278;
    if (!_277)
    goto _jump2206;
    bool _279 = false;
    _278 = _279;
    goto _jump2207;
    _jump2206:;
    bool _280 = true;
    _278 = _280;
    _jump2207:;
    _272 = _278;
    _jump2205:;
    int64_t _281;
    if (!_272)
    goto _jump2208;
    _281 = _110.d0;
    goto _jump2209;
    _jump2208:;
    _281 = _110.d0;
    _jump2209:;
    _271.d1 = _281;
    if (_281 > 0) 
    goto _jump2210;
    fail_assertion("non-positive loop bound");
    _jump2210:;
    // Computing total size of heap memory to allocate
    int64_t _282 = 1;
    _282 *= _110.d1;
    _282 *= _281;
    _282 *= sizeof(_a1_bool);
    _271.data = jpl_alloc(_282);
    int64_t _283 = 0; // t
    int64_t _284 = 0; // s
    _jump2211:; // Begin body of loop
    _a1_bool _285;
    // Computing bound for u
    _285.d0 = _243.d0;
    if (_243.d0 > 0) 
    goto _jump2212;
    fail_assertion("non-positive loop bound");
    _jump2212:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= _243.d0;
    _286 *= sizeof(bool);
    _285.data = jpl_alloc(_286);
    int64_t _287 = 0; // u
    _jump2213:; // Begin body of loop
    bool _289 = i(_110.d0);
    bool _288 = _289;
    if (0 != _289)
    goto _jump2214;
    int64_t _290;
    // Computing bound for v
    if (_283 > 0) 
    goto _jump2215;
    fail_assertion("non-positive loop bound");
    _jump2215:;
    // Computing bound for w
    if (c > 0) 
    goto _jump2216;
    fail_assertion("non-positive loop bound");
    _jump2216:;
    _290 = 0;
    int64_t _291 = 0; // w
    int64_t _292 = 0; // v
    _jump2217:; // Begin body of loop
    _290 += _291;
    _291++;
    if (_291 < c)
    goto _jump2217;
    _291 = 0;
    _292++;
    if (_292 < _283)
    goto _jump2217;
    // End body of loop
    bool _293 = d > _290;
    _288 = _293;
    _jump2214:;
    int64_t _294 = 0;
    _294 *= _285.d0;
    _294 += _287;
    _285.data[_294] = _288;
    _287++;
    if (_287 < _243.d0)
    goto _jump2213;
    // End body of loop
    int64_t _295 = 0;
    _295 *= _271.d0;
    _295 += _284;
    _295 *= _271.d1;
    _295 += _283;
    _271.data[_295] = _285;
    _283++;
    if (_283 < _281)
    goto _jump2211;
    _283 = 0;
    _284++;
    if (_284 < _110.d1)
    goto _jump2211;
    // End body of loop
    _270 = _271;
    goto _jump2218;
    _jump2202:;
    _a2__a1_bool _296;
    // Computing bound for s
    bool _297 = false;
    int64_t _298;
    if (!_297)
    goto _jump2219;
    _298 = c;
    goto _jump2220;
    _jump2219:;
    _298 = _110.d1;
    _jump2220:;
    bool _299 = i(_298);
    _a2_int64_t _300;
    if (!_299)
    goto _jump2221;
    _a3__a2_int64_t _301;
    // Computing bound for s
    _301.d0 = _110.d0;
    if (_110.d0 > 0) 
    goto _jump2222;
    fail_assertion("non-positive loop bound");
    _jump2222:;
    // Computing bound for t
    _301.d1 = _110.d0;
    if (_110.d0 > 0) 
    goto _jump2223;
    fail_assertion("non-positive loop bound");
    _jump2223:;
    // Computing bound for u
    _301.d2 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2224;
    fail_assertion("non-positive loop bound");
    _jump2224:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _110.d0;
    _302 *= _110.d0;
    _302 *= _110.d1;
    _302 *= sizeof(_a2_int64_t);
    _301.data = jpl_alloc(_302);
    int64_t _303 = 0; // u
    int64_t _304 = 0; // t
    int64_t _305 = 0; // s
    _jump2225:; // Begin body of loop
    int64_t _306 = 0;
    _306 *= _301.d0;
    _306 += _305;
    _306 *= _301.d1;
    _306 += _304;
    _306 *= _301.d2;
    _306 += _303;
    _301.data[_306] = _110;
    _303++;
    if (_303 < _110.d1)
    goto _jump2225;
    _303 = 0;
    _304++;
    if (_304 < _110.d0)
    goto _jump2225;
    _304 = 0;
    _305++;
    if (_305 < _110.d0)
    goto _jump2225;
    // End body of loop
    int64_t _307;
    // Computing bound for s
    if (_243.d0 > 0) 
    goto _jump2226;
    fail_assertion("non-positive loop bound");
    _jump2226:;
    // Computing bound for t
    if (_110.d1 > 0) 
    goto _jump2227;
    fail_assertion("non-positive loop bound");
    _jump2227:;
    _307 = 0;
    int64_t _308 = 0; // t
    int64_t _309 = 0; // s
    _jump2228:; // Begin body of loop
    int64_t _310 = 739;
    _307 += _310;
    _308++;
    if (_308 < _110.d1)
    goto _jump2228;
    _308 = 0;
    _309++;
    if (_309 < _243.d0)
    goto _jump2228;
    // End body of loop
    int64_t _311 = -_110.d0;
    if (c >= 0)
    goto _jump2229;
    fail_assertion("negative array index");
    _jump2229:;
    if (c < _301.d0)
    goto _jump2230;
    fail_assertion("index too large");
    _jump2230:;
    if (_307 >= 0)
    goto _jump2231;
    fail_assertion("negative array index");
    _jump2231:;
    if (_307 < _301.d1)
    goto _jump2232;
    fail_assertion("index too large");
    _jump2232:;
    if (_311 >= 0)
    goto _jump2233;
    fail_assertion("negative array index");
    _jump2233:;
    if (_311 < _301.d2)
    goto _jump2234;
    fail_assertion("index too large");
    _jump2234:;
    int64_t _312 = 0;
    _312 *= _301.d0;
    _312 += c;
    _312 *= _301.d1;
    _312 += _307;
    _312 *= _301.d2;
    _312 += _311;
    _a2_int64_t _313 = _301.data[_312];
    _300 = _313;
    goto _jump2235;
    _jump2221:;
    _300 = b;
    _jump2235:;
    int64_t _314 = 427;
    int64_t _315 = -_314;
    if (_315 >= 0)
    goto _jump2236;
    fail_assertion("negative array index");
    _jump2236:;
    if (_315 < _300.d0)
    goto _jump2237;
    fail_assertion("index too large");
    _jump2237:;
    if (_243.d0 >= 0)
    goto _jump2238;
    fail_assertion("negative array index");
    _jump2238:;
    if (_243.d0 < _300.d1)
    goto _jump2239;
    fail_assertion("index too large");
    _jump2239:;
    int64_t _316 = 0;
    _316 *= _300.d0;
    _316 += _315;
    _316 *= _300.d1;
    _316 += _243.d0;
    int64_t _317 = _300.data[_316];
    _296.d0 = _317;
    if (_317 > 0) 
    goto _jump2240;
    fail_assertion("non-positive loop bound");
    _jump2240:;
    // Computing bound for t
    int64_t _318 = 945;
    int64_t _319;
    // Computing bound for s
    if (d > 0) 
    goto _jump2241;
    fail_assertion("non-positive loop bound");
    _jump2241:;
    _319 = 0;
    int64_t _320 = 0; // s
    _jump2242:; // Begin body of loop
    int64_t _321 = 705;
    _319 += _321;
    _320++;
    if (_320 < d)
    goto _jump2242;
    // End body of loop
    int64_t _322 = _318 - _319;
    int64_t _323;
    // Computing bound for s
    if (_110.d0 > 0) 
    goto _jump2243;
    fail_assertion("non-positive loop bound");
    _jump2243:;
    // Computing bound for t
    bool _324 = i(_243.d0);
    int64_t _325;
    if (!_324)
    goto _jump2244;
    _325 = _243.d0;
    goto _jump2245;
    _jump2244:;
    int64_t _326 = 796;
    _325 = _326;
    _jump2245:;
    if (_325 > 0) 
    goto _jump2246;
    fail_assertion("non-positive loop bound");
    _jump2246:;
    // Computing bound for u
    int64_t _327 = -d;
    int64_t _328 = _327 % c;
    if (_328 > 0) 
    goto _jump2247;
    fail_assertion("non-positive loop bound");
    _jump2247:;
    _323 = 0;
    int64_t _329 = 0; // u
    int64_t _330 = 0; // t
    int64_t _331 = 0; // s
    _jump2248:; // Begin body of loop
    _323 += _331;
    _329++;
    if (_329 < _328)
    goto _jump2248;
    _329 = 0;
    _330++;
    if (_330 < _325)
    goto _jump2248;
    _330 = 0;
    _331++;
    if (_331 < _110.d0)
    goto _jump2248;
    // End body of loop
    int64_t _332 = _322 - _323;
    _296.d1 = _332;
    if (_332 > 0) 
    goto _jump2249;
    fail_assertion("non-positive loop bound");
    _jump2249:;
    // Computing total size of heap memory to allocate
    int64_t _333 = 1;
    _333 *= _317;
    _333 *= _332;
    _333 *= sizeof(_a1_bool);
    _296.data = jpl_alloc(_333);
    int64_t _334 = 0; // t
    int64_t _335 = 0; // s
    _jump2250:; // Begin body of loop
    _a1_bool _336;
    // Computing bound for u
    _336.d0 = _335;
    if (_335 > 0) 
    goto _jump2251;
    fail_assertion("non-positive loop bound");
    _jump2251:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= _335;
    _337 *= sizeof(bool);
    _336.data = jpl_alloc(_337);
    int64_t _338 = 0; // u
    _jump2252:; // Begin body of loop
    bool _340 = i(_110.d0);
    bool _339 = _340;
    if (0 != _340)
    goto _jump2253;
    double _341 = 54.0;
    bool _342 = _341 == g;
    _339 = _342;
    _jump2253:;
    int64_t _343 = 0;
    _343 *= _336.d0;
    _343 += _338;
    _336.data[_343] = _339;
    _338++;
    if (_338 < _335)
    goto _jump2252;
    // End body of loop
    int64_t _344 = 0;
    _344 *= _296.d0;
    _344 += _335;
    _344 *= _296.d1;
    _344 += _334;
    _296.data[_344] = _336;
    _334++;
    if (_334 < _332)
    goto _jump2250;
    _334 = 0;
    _335++;
    if (_335 < _317)
    goto _jump2250;
    // End body of loop
    _270 = _296;
    _jump2218:;
    _a3_bool _345;
    // Computing bound for s
    int64_t _346;
    // Computing bound for s
    if (_110.d1 > 0) 
    goto _jump2254;
    fail_assertion("non-positive loop bound");
    _jump2254:;
    // Computing bound for t
    int64_t _347 = -_110.d0;
    if (_347 > 0) 
    goto _jump2255;
    fail_assertion("non-positive loop bound");
    _jump2255:;
    _346 = 0;
    int64_t _348 = 0; // t
    int64_t _349 = 0; // s
    _jump2256:; // Begin body of loop
    _346 += _348;
    _348++;
    if (_348 < _347)
    goto _jump2256;
    _348 = 0;
    _349++;
    if (_349 < _110.d1)
    goto _jump2256;
    // End body of loop
    _345.d0 = _346;
    if (_346 > 0) 
    goto _jump2257;
    fail_assertion("non-positive loop bound");
    _jump2257:;
    // Computing bound for t
    int64_t _350 = 257;
    int64_t _351 = -_350;
    int64_t _352 = _243.d0 / _351;
    _345.d1 = _352;
    if (_352 > 0) 
    goto _jump2258;
    fail_assertion("non-positive loop bound");
    _jump2258:;
    // Computing bound for u
    int64_t _353 = 788;
    _345.d2 = _353;
    if (_353 > 0) 
    goto _jump2259;
    fail_assertion("non-positive loop bound");
    _jump2259:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= _346;
    _354 *= _352;
    _354 *= _353;
    _354 *= sizeof(bool);
    _345.data = jpl_alloc(_354);
    int64_t _355 = 0; // u
    int64_t _356 = 0; // t
    int64_t _357 = 0; // s
    _jump2260:; // Begin body of loop
    bool _358 = false;
    bool _359 = i(_243.d0);
    _a1_bool _360;
    _360.d0 = 2;
    _360.data = jpl_alloc(sizeof(bool) * 2);
    _360.data[0] = _358;
    _360.data[1] = _359;
    if (_356 >= 0)
    goto _jump2261;
    fail_assertion("negative array index");
    _jump2261:;
    if (_356 < _360.d0)
    goto _jump2262;
    fail_assertion("index too large");
    _jump2262:;
    int64_t _361 = 0;
    _361 *= _360.d0;
    _361 += _356;
    bool _362 = _360.data[_361];
    int64_t _363 = 0;
    _363 *= _345.d0;
    _363 += _357;
    _363 *= _345.d1;
    _363 += _356;
    _363 *= _345.d2;
    _363 += _355;
    _345.data[_363] = _362;
    _355++;
    if (_355 < _353)
    goto _jump2260;
    _355 = 0;
    _356++;
    if (_356 < _352)
    goto _jump2260;
    _356 = 0;
    _357++;
    if (_357 < _346)
    goto _jump2260;
    // End body of loop
    rgba _364 = h(_270, _345);
    bool _365 = false;
    bool _366 = !_365;
    bool _367 = !_366;
    bool _368 = !_367;
    bool _369;
    if (!_368)
    goto _jump2263;
    int64_t _370 = _110.d0 + _110.d1;
    int64_t _371 = d / d;
    bool _372 = _370 <= _371;
    _369 = _372;
    goto _jump2264;
    _jump2263:;
    _a3__a2_bool _373;
    // Computing bound for t
    bool _374 = false;
    int64_t _375;
    if (!_374)
    goto _jump2265;
    _375 = d;
    goto _jump2266;
    _jump2265:;
    _375 = d;
    _jump2266:;
    _373.d0 = _375;
    if (_375 > 0) 
    goto _jump2267;
    fail_assertion("non-positive loop bound");
    _jump2267:;
    // Computing bound for u
    _373.d1 = d;
    if (d > 0) 
    goto _jump2268;
    fail_assertion("non-positive loop bound");
    _jump2268:;
    // Computing bound for v
    int64_t _376;
    // Computing bound for t
    int64_t _377 = 9;
    if (_377 > 0) 
    goto _jump2269;
    fail_assertion("non-positive loop bound");
    _jump2269:;
    _376 = 0;
    int64_t _378 = 0; // t
    _jump2270:; // Begin body of loop
    _376 += c;
    _378++;
    if (_378 < _377)
    goto _jump2270;
    // End body of loop
    _373.d2 = _376;
    if (_376 > 0) 
    goto _jump2271;
    fail_assertion("non-positive loop bound");
    _jump2271:;
    // Computing total size of heap memory to allocate
    int64_t _379 = 1;
    _379 *= _375;
    _379 *= d;
    _379 *= _376;
    _379 *= sizeof(_a2_bool);
    _373.data = jpl_alloc(_379);
    int64_t _380 = 0; // v
    int64_t _381 = 0; // u
    int64_t _382 = 0; // t
    _jump2272:; // Begin body of loop
    _a2_bool _383;
    // Computing bound for w
    _383.d0 = _110.d0;
    if (_110.d0 > 0) 
    goto _jump2273;
    fail_assertion("non-positive loop bound");
    _jump2273:;
    // Computing bound for x
    _383.d1 = _110.d0;
    if (_110.d0 > 0) 
    goto _jump2274;
    fail_assertion("non-positive loop bound");
    _jump2274:;
    // Computing total size of heap memory to allocate
    int64_t _384 = 1;
    _384 *= _110.d0;
    _384 *= _110.d0;
    _384 *= sizeof(bool);
    _383.data = jpl_alloc(_384);
    int64_t _385 = 0; // x
    int64_t _386 = 0; // w
    _jump2275:; // Begin body of loop
    bool _387 = true;
    int64_t _388 = 0;
    _388 *= _383.d0;
    _388 += _386;
    _388 *= _383.d1;
    _388 += _385;
    _383.data[_388] = _387;
    _385++;
    if (_385 < _110.d0)
    goto _jump2275;
    _385 = 0;
    _386++;
    if (_386 < _110.d0)
    goto _jump2275;
    // End body of loop
    int64_t _389 = 0;
    _389 *= _373.d0;
    _389 += _382;
    _389 *= _373.d1;
    _389 += _381;
    _389 *= _373.d2;
    _389 += _380;
    _373.data[_389] = _383;
    _380++;
    if (_380 < _376)
    goto _jump2272;
    _380 = 0;
    _381++;
    if (_381 < d)
    goto _jump2272;
    _381 = 0;
    _382++;
    if (_382 < _375)
    goto _jump2272;
    // End body of loop
    double _390 = 27.0;
    bool _391 = _111 == _390;
    int64_t _392;
    if (!_391)
    goto _jump2276;
    _392 = _110.d0;
    goto _jump2277;
    _jump2276:;
    _392 = _110.d0;
    _jump2277:;
    int64_t _393 = 976;
    if (_392 >= 0)
    goto _jump2278;
    fail_assertion("negative array index");
    _jump2278:;
    if (_392 < _373.d0)
    goto _jump2279;
    fail_assertion("index too large");
    _jump2279:;
    if (_393 >= 0)
    goto _jump2280;
    fail_assertion("negative array index");
    _jump2280:;
    if (_393 < _373.d1)
    goto _jump2281;
    fail_assertion("index too large");
    _jump2281:;
    if (_110.d1 >= 0)
    goto _jump2282;
    fail_assertion("negative array index");
    _jump2282:;
    if (_110.d1 < _373.d2)
    goto _jump2283;
    fail_assertion("index too large");
    _jump2283:;
    int64_t _394 = 0;
    _394 *= _373.d0;
    _394 += _392;
    _394 *= _373.d1;
    _394 += _393;
    _394 *= _373.d2;
    _394 += _110.d1;
    _a2_bool _395 = _373.data[_394];
    int64_t _396;
    // Computing bound for t
    if (_243.d0 > 0) 
    goto _jump2284;
    fail_assertion("non-positive loop bound");
    _jump2284:;
    _396 = 0;
    int64_t _397 = 0; // t
    _jump2285:; // Begin body of loop
    _396 += _397;
    _397++;
    if (_397 < _243.d0)
    goto _jump2285;
    // End body of loop
    if (_396 >= 0)
    goto _jump2286;
    fail_assertion("negative array index");
    _jump2286:;
    if (_396 < _395.d0)
    goto _jump2287;
    fail_assertion("index too large");
    _jump2287:;
    if (_243.d0 >= 0)
    goto _jump2288;
    fail_assertion("negative array index");
    _jump2288:;
    if (_243.d0 < _395.d1)
    goto _jump2289;
    fail_assertion("index too large");
    _jump2289:;
    int64_t _398 = 0;
    _398 *= _395.d0;
    _398 += _396;
    _398 *= _395.d1;
    _398 += _243.d0;
    bool _399 = _395.data[_398];
    _369 = _399;
    _jump2264:;
    bool _400;
    if (!_369)
    goto _jump2290;
    bool _401 = false;
    int64_t _402;
    if (!_401)
    goto _jump2291;
    bool _403 = i(c);
    int64_t _404;
    if (!_403)
    goto _jump2292;
    _404 = _243.d0;
    goto _jump2293;
    _jump2292:;
    int64_t _405 = -_110.d0;
    _404 = _405;
    _jump2293:;
    _402 = _404;
    goto _jump2294;
    _jump2291:;
    if (d >= 0)
    goto _jump2295;
    fail_assertion("negative array index");
    _jump2295:;
    if (d < _243.d0)
    goto _jump2296;
    fail_assertion("index too large");
    _jump2296:;
    int64_t _406 = 0;
    _406 *= _243.d0;
    _406 += d;
    int64_t _407 = _243.data[_406];
    int64_t _408 = _110.d1 / _407;
    _402 = _408;
    _jump2294:;
    int64_t _409 = -_402;
    bool _410 = i(_409);
    _400 = _410;
    goto _jump2297;
    _jump2290:;
    bool _411 = true;
    bool _412;
    if (!_411)
    goto _jump2298;
    bool _413 = true;
    bool _414;
    if (!_413)
    goto _jump2299;
    bool _415 = i(_243.d0);
    bool _416 = i(c);
    bool _417 = _415 != _416;
    _414 = _417;
    goto _jump2300;
    _jump2299:;
    int64_t _418 = 641;
    bool _419 = i(_418);
    bool _420 = !_419;
    _414 = _420;
    _jump2300:;
    _412 = _414;
    goto _jump2301;
    _jump2298:;
    int64_t _421 = 594;
    int64_t _422 = -_421;
    bool _423 = i(_422);
    bool _425 = true;
    bool _426 = !_425;
    bool _424 = _426;
    if (0 != _426)
    goto _jump2302;
    bool _427 = true;
    _424 = _427;
    _jump2302:;
    bool _428 = _423 == _424;
    _412 = _428;
    _jump2301:;
    bool _429 = !_412;
    _400 = _429;
    _jump2297:;
    _a1_double _430;
    if (!_400)
    goto _jump2303;
    _a1_double _431;
    _431.d0 = 1;
    _431.data = jpl_alloc(sizeof(double) * 1);
    _431.data[0] = _111;
    _430 = _431;
    goto _jump2304;
    _jump2303:;
    _a1_double _432;
    // Computing bound for t
    int64_t _433 = 383;
    _432.d0 = _433;
    if (_433 > 0) 
    goto _jump2305;
    fail_assertion("non-positive loop bound");
    _jump2305:;
    // Computing total size of heap memory to allocate
    int64_t _434 = 1;
    _434 *= _433;
    _434 *= sizeof(double);
    _432.data = jpl_alloc(_434);
    int64_t _435 = 0; // t
    _jump2306:; // Begin body of loop
    bool _436 = false;
    double _437;
    if (!_436)
    goto _jump2307;
    double _438;
    // Computing bound for u
    int64_t _439;
    // Computing bound for u
    int64_t _440 = 297;
    if (_440 > 0) 
    goto _jump2308;
    fail_assertion("non-positive loop bound");
    _jump2308:;
    // Computing bound for v
    if (_435 > 0) 
    goto _jump2309;
    fail_assertion("non-positive loop bound");
    _jump2309:;
    _439 = 0;
    int64_t _441 = 0; // v
    int64_t _442 = 0; // u
    _jump2310:; // Begin body of loop
    _439 += _110.d1;
    _441++;
    if (_441 < _435)
    goto _jump2310;
    _441 = 0;
    _442++;
    if (_442 < _440)
    goto _jump2310;
    // End body of loop
    int64_t _443 = d + _439;
    if (_443 > 0) 
    goto _jump2311;
    fail_assertion("non-positive loop bound");
    _jump2311:;
    // Computing bound for v
    if (d > 0) 
    goto _jump2312;
    fail_assertion("non-positive loop bound");
    _jump2312:;
    // Computing bound for w
    int64_t _444 = -_243.d0;
    if (_444 > 0) 
    goto _jump2313;
    fail_assertion("non-positive loop bound");
    _jump2313:;
    _438 = 0;
    int64_t _445 = 0; // w
    int64_t _446 = 0; // v
    int64_t _447 = 0; // u
    _jump2314:; // Begin body of loop
    rgba _448 = a();
    double _449 = _448.a;
    _438 += _449;
    _445++;
    if (_445 < _444)
    goto _jump2314;
    _445 = 0;
    _446++;
    if (_446 < d)
    goto _jump2314;
    _446 = 0;
    _447++;
    if (_447 < _443)
    goto _jump2314;
    // End body of loop
    double _450 = -_438;
    _437 = _450;
    goto _jump2315;
    _jump2307:;
    _a2_double _451;
    // Computing bound for u
    int64_t _452 = 427;
    int64_t _453 = -_452;
    _451.d0 = _453;
    if (_453 > 0) 
    goto _jump2316;
    fail_assertion("non-positive loop bound");
    _jump2316:;
    // Computing bound for v
    _451.d1 = c;
    if (c > 0) 
    goto _jump2317;
    fail_assertion("non-positive loop bound");
    _jump2317:;
    // Computing total size of heap memory to allocate
    int64_t _454 = 1;
    _454 *= _453;
    _454 *= c;
    _454 *= sizeof(double);
    _451.data = jpl_alloc(_454);
    int64_t _455 = 0; // v
    int64_t _456 = 0; // u
    _jump2318:; // Begin body of loop
    rgba _457 = a();
    double _458 = _457.r;
    int64_t _459 = 0;
    _459 *= _451.d0;
    _459 += _456;
    _459 *= _451.d1;
    _459 += _455;
    _451.data[_459] = _458;
    _455++;
    if (_455 < c)
    goto _jump2318;
    _455 = 0;
    _456++;
    if (_456 < _453)
    goto _jump2318;
    // End body of loop
    int64_t _460;
    // Computing bound for u
    _a1_int64_t _461;
    // Computing bound for u
    _461.d0 = _435;
    if (_435 > 0) 
    goto _jump2319;
    fail_assertion("non-positive loop bound");
    _jump2319:;
    // Computing total size of heap memory to allocate
    int64_t _462 = 1;
    _462 *= _435;
    _462 *= sizeof(int64_t);
    _461.data = jpl_alloc(_462);
    int64_t _463 = 0; // u
    _jump2320:; // Begin body of loop
    int64_t _464 = 0;
    _464 *= _461.d0;
    _464 += _463;
    _461.data[_464] = c;
    _463++;
    if (_463 < _435)
    goto _jump2320;
    // End body of loop
    if (_110.d0 >= 0)
    goto _jump2321;
    fail_assertion("negative array index");
    _jump2321:;
    if (_110.d0 < _461.d0)
    goto _jump2322;
    fail_assertion("index too large");
    _jump2322:;
    int64_t _465 = 0;
    _465 *= _461.d0;
    _465 += _110.d0;
    int64_t _466 = _461.data[_465];
    if (_466 > 0) 
    goto _jump2323;
    fail_assertion("non-positive loop bound");
    _jump2323:;
    // Computing bound for v
    if (_435 > 0) 
    goto _jump2324;
    fail_assertion("non-positive loop bound");
    _jump2324:;
    // Computing bound for w
    if (_110.d0 > 0) 
    goto _jump2325;
    fail_assertion("non-positive loop bound");
    _jump2325:;
    _460 = 0;
    int64_t _467 = 0; // w
    int64_t _468 = 0; // v
    int64_t _469 = 0; // u
    _jump2326:; // Begin body of loop
    _460 += _469;
    _467++;
    if (_467 < _110.d0)
    goto _jump2326;
    _467 = 0;
    _468++;
    if (_468 < _435)
    goto _jump2326;
    _468 = 0;
    _469++;
    if (_469 < _466)
    goto _jump2326;
    // End body of loop
    int64_t _470;
    // Computing bound for u
    if (_110.d1 > 0) 
    goto _jump2327;
    fail_assertion("non-positive loop bound");
    _jump2327:;
    // Computing bound for v
    if (_243.d0 > 0) 
    goto _jump2328;
    fail_assertion("non-positive loop bound");
    _jump2328:;
    _470 = 0;
    int64_t _471 = 0; // v
    int64_t _472 = 0; // u
    _jump2329:; // Begin body of loop
    _470 += _472;
    _471++;
    if (_471 < _243.d0)
    goto _jump2329;
    _471 = 0;
    _472++;
    if (_472 < _110.d1)
    goto _jump2329;
    // End body of loop
    bool _473 = _110.d1 == _470;
    int64_t _474;
    if (!_473)
    goto _jump2330;
    int64_t _475;
    // Computing bound for u
    bool _476 = false;
    int64_t _477;
    if (!_476)
    goto _jump2331;
    int64_t _478 = 326;
    _477 = _478;
    goto _jump2332;
    _jump2331:;
    _477 = _243.d0;
    _jump2332:;
    if (_477 > 0) 
    goto _jump2333;
    fail_assertion("non-positive loop bound");
    _jump2333:;
    // Computing bound for v
    if (_243.d0 > 0) 
    goto _jump2334;
    fail_assertion("non-positive loop bound");
    _jump2334:;
    _475 = 0;
    int64_t _479 = 0; // v
    int64_t _480 = 0; // u
    _jump2335:; // Begin body of loop
    _475 += _435;
    _479++;
    if (_479 < _243.d0)
    goto _jump2335;
    _479 = 0;
    _480++;
    if (_480 < _477)
    goto _jump2335;
    // End body of loop
    _474 = _475;
    goto _jump2336;
    _jump2330:;
    bool _481 = false;
    int64_t _482;
    if (!_481)
    goto _jump2337;
    _482 = _110.d1;
    goto _jump2338;
    _jump2337:;
    _482 = c;
    _jump2338:;
    int64_t _483 = -_482;
    _474 = _483;
    _jump2336:;
    if (_460 >= 0)
    goto _jump2339;
    fail_assertion("negative array index");
    _jump2339:;
    if (_460 < _451.d0)
    goto _jump2340;
    fail_assertion("index too large");
    _jump2340:;
    if (_474 >= 0)
    goto _jump2341;
    fail_assertion("negative array index");
    _jump2341:;
    if (_474 < _451.d1)
    goto _jump2342;
    fail_assertion("index too large");
    _jump2342:;
    int64_t _484 = 0;
    _484 *= _451.d0;
    _484 += _460;
    _484 *= _451.d1;
    _484 += _474;
    double _485 = _451.data[_484];
    _437 = _485;
    _jump2315:;
    int64_t _486 = 0;
    _486 *= _432.d0;
    _486 += _435;
    _432.data[_486] = _437;
    _435++;
    if (_435 < _433)
    goto _jump2306;
    // End body of loop
    _430 = _432;
    _jump2304:;
    _a3__a2__a1_bool _487;
    // Computing bound for v
    int64_t _488;
    // Computing bound for v
    _a1_int64_t _489;
    // Computing bound for v
    _489.d0 = _243.d0;
    if (_243.d0 > 0) 
    goto _jump2343;
    fail_assertion("non-positive loop bound");
    _jump2343:;
    // Computing total size of heap memory to allocate
    int64_t _490 = 1;
    _490 *= _243.d0;
    _490 *= sizeof(int64_t);
    _489.data = jpl_alloc(_490);
    int64_t _491 = 0; // v
    _jump2344:; // Begin body of loop
    int64_t _492 = 0;
    _492 *= _489.d0;
    _492 += _491;
    _489.data[_492] = d;
    _491++;
    if (_491 < _243.d0)
    goto _jump2344;
    // End body of loop
    if (_430.d0 >= 0)
    goto _jump2345;
    fail_assertion("negative array index");
    _jump2345:;
    if (_430.d0 < _489.d0)
    goto _jump2346;
    fail_assertion("index too large");
    _jump2346:;
    int64_t _493 = 0;
    _493 *= _489.d0;
    _493 += _430.d0;
    int64_t _494 = _489.data[_493];
    int64_t _495 = 117;
    int64_t _496 = -_495;
    int64_t _497 = _494 + _496;
    if (_497 > 0) 
    goto _jump2347;
    fail_assertion("non-positive loop bound");
    _jump2347:;
    // Computing bound for w
    if (c > 0) 
    goto _jump2348;
    fail_assertion("non-positive loop bound");
    _jump2348:;
    // Computing bound for x
    if (_430.d0 > 0) 
    goto _jump2349;
    fail_assertion("non-positive loop bound");
    _jump2349:;
    _488 = 0;
    int64_t _498 = 0; // x
    int64_t _499 = 0; // w
    int64_t _500 = 0; // v
    _jump2350:; // Begin body of loop
    _488 += _498;
    _498++;
    if (_498 < _430.d0)
    goto _jump2350;
    _498 = 0;
    _499++;
    if (_499 < c)
    goto _jump2350;
    _499 = 0;
    _500++;
    if (_500 < _497)
    goto _jump2350;
    // End body of loop
    _487.d0 = _488;
    if (_488 > 0) 
    goto _jump2351;
    fail_assertion("non-positive loop bound");
    _jump2351:;
    // Computing bound for w
    _487.d1 = c;
    if (c > 0) 
    goto _jump2352;
    fail_assertion("non-positive loop bound");
    _jump2352:;
    // Computing bound for x
    _487.d2 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump2353;
    fail_assertion("non-positive loop bound");
    _jump2353:;
    // Computing total size of heap memory to allocate
    int64_t _501 = 1;
    _501 *= _488;
    _501 *= c;
    _501 *= _430.d0;
    _501 *= sizeof(_a2__a1_bool);
    _487.data = jpl_alloc(_501);
    int64_t _502 = 0; // x
    int64_t _503 = 0; // w
    int64_t _504 = 0; // v
    _jump2354:; // Begin body of loop
    _a2_bool _505;
    // Computing bound for y
    int64_t _506 = 980;
    int64_t _507 = -_506;
    _505.d0 = _507;
    if (_507 > 0) 
    goto _jump2355;
    fail_assertion("non-positive loop bound");
    _jump2355:;
    // Computing bound for z
    _505.d1 = _504;
    if (_504 > 0) 
    goto _jump2356;
    fail_assertion("non-positive loop bound");
    _jump2356:;
    // Computing total size of heap memory to allocate
    int64_t _508 = 1;
    _508 *= _507;
    _508 *= _504;
    _508 *= sizeof(bool);
    _505.data = jpl_alloc(_508);
    int64_t _509 = 0; // z
    int64_t _510 = 0; // y
    _jump2357:; // Begin body of loop
    bool _511 = i(_110.d0);
    int64_t _512 = 0;
    _512 *= _505.d0;
    _512 += _510;
    _512 *= _505.d1;
    _512 += _509;
    _505.data[_512] = _511;
    _509++;
    if (_509 < _504)
    goto _jump2357;
    _509 = 0;
    _510++;
    if (_510 < _507)
    goto _jump2357;
    // End body of loop
    if (_504 >= 0)
    goto _jump2358;
    fail_assertion("negative array index");
    _jump2358:;
    if (_504 < _110.d0)
    goto _jump2359;
    fail_assertion("index too large");
    _jump2359:;
    if (_503 >= 0)
    goto _jump2360;
    fail_assertion("negative array index");
    _jump2360:;
    if (_503 < _110.d1)
    goto _jump2361;
    fail_assertion("index too large");
    _jump2361:;
    int64_t _513 = 0;
    _513 *= _110.d0;
    _513 += _504;
    _513 *= _110.d1;
    _513 += _503;
    int64_t _514 = _110.data[_513];
    if (_514 >= 0)
    goto _jump2362;
    fail_assertion("negative array index");
    _jump2362:;
    if (_514 < _110.d0)
    goto _jump2363;
    fail_assertion("index too large");
    _jump2363:;
    if (_110.d0 >= 0)
    goto _jump2364;
    fail_assertion("negative array index");
    _jump2364:;
    if (_110.d0 < _110.d1)
    goto _jump2365;
    fail_assertion("index too large");
    _jump2365:;
    int64_t _515 = 0;
    _515 *= _110.d0;
    _515 += _514;
    _515 *= _110.d1;
    _515 += _110.d0;
    int64_t _516 = _110.data[_515];
    if (_516 >= 0)
    goto _jump2366;
    fail_assertion("negative array index");
    _jump2366:;
    if (_516 < _505.d0)
    goto _jump2367;
    fail_assertion("index too large");
    _jump2367:;
    if (d >= 0)
    goto _jump2368;
    fail_assertion("negative array index");
    _jump2368:;
    if (d < _505.d1)
    goto _jump2369;
    fail_assertion("index too large");
    _jump2369:;
    int64_t _517 = 0;
    _517 *= _505.d0;
    _517 += _516;
    _517 *= _505.d1;
    _517 += d;
    bool _518 = _505.data[_517];
    _a2__a1_bool _519;
    if (!_518)
    goto _jump2370;
    _a2__a1_bool _520;
    // Computing bound for y
    int64_t _521;
    // Computing bound for y
    if (_430.d0 > 0) 
    goto _jump2371;
    fail_assertion("non-positive loop bound");
    _jump2371:;
    // Computing bound for z
    if (_110.d1 > 0) 
    goto _jump2372;
    fail_assertion("non-positive loop bound");
    _jump2372:;
    // Computing bound for A
    int64_t _522;
    // Computing bound for y
    int64_t _523 = 397;
    if (_523 > 0) 
    goto _jump2373;
    fail_assertion("non-positive loop bound");
    _jump2373:;
    _522 = 0;
    int64_t _524 = 0; // y
    _jump2374:; // Begin body of loop
    _522 += _243.d0;
    _524++;
    if (_524 < _523)
    goto _jump2374;
    // End body of loop
    if (_522 > 0) 
    goto _jump2375;
    fail_assertion("non-positive loop bound");
    _jump2375:;
    _521 = 0;
    int64_t _525 = 0; // A
    int64_t _526 = 0; // z
    int64_t _527 = 0; // y
    _jump2376:; // Begin body of loop
    _521 += _502;
    _525++;
    if (_525 < _522)
    goto _jump2376;
    _525 = 0;
    _526++;
    if (_526 < _110.d1)
    goto _jump2376;
    _526 = 0;
    _527++;
    if (_527 < _430.d0)
    goto _jump2376;
    // End body of loop
    _520.d0 = _521;
    if (_521 > 0) 
    goto _jump2377;
    fail_assertion("non-positive loop bound");
    _jump2377:;
    // Computing bound for z
    int64_t _528 = 1;
    _520.d1 = _528;
    if (_528 > 0) 
    goto _jump2378;
    fail_assertion("non-positive loop bound");
    _jump2378:;
    // Computing total size of heap memory to allocate
    int64_t _529 = 1;
    _529 *= _521;
    _529 *= _528;
    _529 *= sizeof(_a1_bool);
    _520.data = jpl_alloc(_529);
    int64_t _530 = 0; // z
    int64_t _531 = 0; // y
    _jump2379:; // Begin body of loop
    bool _533 = true;
    bool _532 = _533;
    if (0 == _533)
    goto _jump2380;
    bool _534 = true;
    _532 = _534;
    _jump2380:;
    bool _535 = true;
    bool _536 = !_535;
    bool _537 = d >= _110.d0;
    _a1_bool _538;
    _538.d0 = 3;
    _538.data = jpl_alloc(sizeof(bool) * 3);
    _538.data[0] = _532;
    _538.data[1] = _536;
    _538.data[2] = _537;
    int64_t _539 = 0;
    _539 *= _520.d0;
    _539 += _531;
    _539 *= _520.d1;
    _539 += _530;
    _520.data[_539] = _538;
    _530++;
    if (_530 < _528)
    goto _jump2379;
    _530 = 0;
    _531++;
    if (_531 < _521)
    goto _jump2379;
    // End body of loop
    _519 = _520;
    goto _jump2381;
    _jump2370:;
    _a2__a1_bool _540;
    // Computing bound for y
    _540.d0 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump2382;
    fail_assertion("non-positive loop bound");
    _jump2382:;
    // Computing bound for z
    _540.d1 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2383;
    fail_assertion("non-positive loop bound");
    _jump2383:;
    // Computing total size of heap memory to allocate
    int64_t _541 = 1;
    _541 *= _430.d0;
    _541 *= _110.d1;
    _541 *= sizeof(_a1_bool);
    _540.data = jpl_alloc(_541);
    int64_t _542 = 0; // z
    int64_t _543 = 0; // y
    _jump2384:; // Begin body of loop
    bool _544 = _110.d1 >= _504;
    bool _545 = _542 == _243.d0;
    _a1_bool _546;
    _546.d0 = 2;
    _546.data = jpl_alloc(sizeof(bool) * 2);
    _546.data[0] = _544;
    _546.data[1] = _545;
    int64_t _547 = 0;
    _547 *= _540.d0;
    _547 += _543;
    _547 *= _540.d1;
    _547 += _542;
    _540.data[_547] = _546;
    _542++;
    if (_542 < _110.d1)
    goto _jump2384;
    _542 = 0;
    _543++;
    if (_543 < _430.d0)
    goto _jump2384;
    // End body of loop
    _519 = _540;
    _jump2381:;
    int64_t _548 = 0;
    _548 *= _487.d0;
    _548 += _504;
    _548 *= _487.d1;
    _548 += _503;
    _548 *= _487.d2;
    _548 += _502;
    _487.data[_548] = _519;
    _502++;
    if (_502 < _430.d0)
    goto _jump2354;
    _502 = 0;
    _503++;
    if (_503 < c)
    goto _jump2354;
    _503 = 0;
    _504++;
    if (_504 < _488)
    goto _jump2354;
    // End body of loop
    _a3__a3_int64_t _549;
    // Computing bound for v
    _549.d0 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump2385;
    fail_assertion("non-positive loop bound");
    _jump2385:;
    // Computing bound for w
    _549.d1 = _243.d0;
    if (_243.d0 > 0) 
    goto _jump2386;
    fail_assertion("non-positive loop bound");
    _jump2386:;
    // Computing bound for x
    _549.d2 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump2387;
    fail_assertion("non-positive loop bound");
    _jump2387:;
    // Computing total size of heap memory to allocate
    int64_t _550 = 1;
    _550 *= _430.d0;
    _550 *= _243.d0;
    _550 *= _430.d0;
    _550 *= sizeof(_a3_int64_t);
    _549.data = jpl_alloc(_550);
    int64_t _551 = 0; // x
    int64_t _552 = 0; // w
    int64_t _553 = 0; // v
    _jump2388:; // Begin body of loop
    _a3_int64_t _554;
    // Computing bound for y
    _554.d0 = d;
    if (d > 0) 
    goto _jump2389;
    fail_assertion("non-positive loop bound");
    _jump2389:;
    // Computing bound for z
    _554.d1 = _243.d0;
    if (_243.d0 > 0) 
    goto _jump2390;
    fail_assertion("non-positive loop bound");
    _jump2390:;
    // Computing bound for A
    _554.d2 = _553;
    if (_553 > 0) 
    goto _jump2391;
    fail_assertion("non-positive loop bound");
    _jump2391:;
    // Computing total size of heap memory to allocate
    int64_t _555 = 1;
    _555 *= d;
    _555 *= _243.d0;
    _555 *= _553;
    _555 *= sizeof(int64_t);
    _554.data = jpl_alloc(_555);
    int64_t _556 = 0; // A
    int64_t _557 = 0; // z
    int64_t _558 = 0; // y
    _jump2392:; // Begin body of loop
    int64_t _559 = 864;
    int64_t _560 = 0;
    _560 *= _554.d0;
    _560 += _558;
    _560 *= _554.d1;
    _560 += _557;
    _560 *= _554.d2;
    _560 += _556;
    _554.data[_560] = _559;
    _556++;
    if (_556 < _553)
    goto _jump2392;
    _556 = 0;
    _557++;
    if (_557 < _243.d0)
    goto _jump2392;
    _557 = 0;
    _558++;
    if (_558 < d)
    goto _jump2392;
    // End body of loop
    int64_t _561 = 0;
    _561 *= _549.d0;
    _561 += _553;
    _561 *= _549.d1;
    _561 += _552;
    _561 *= _549.d2;
    _561 += _551;
    _549.data[_561] = _554;
    _551++;
    if (_551 < _430.d0)
    goto _jump2388;
    _551 = 0;
    _552++;
    if (_552 < _243.d0)
    goto _jump2388;
    _552 = 0;
    _553++;
    if (_553 < _430.d0)
    goto _jump2388;
    // End body of loop
    if (_110.d1 >= 0)
    goto _jump2393;
    fail_assertion("negative array index");
    _jump2393:;
    if (_110.d1 < _549.d0)
    goto _jump2394;
    fail_assertion("index too large");
    _jump2394:;
    if (_243.d0 >= 0)
    goto _jump2395;
    fail_assertion("negative array index");
    _jump2395:;
    if (_243.d0 < _549.d1)
    goto _jump2396;
    fail_assertion("index too large");
    _jump2396:;
    if (_243.d0 >= 0)
    goto _jump2397;
    fail_assertion("negative array index");
    _jump2397:;
    if (_243.d0 < _549.d2)
    goto _jump2398;
    fail_assertion("index too large");
    _jump2398:;
    int64_t _562 = 0;
    _562 *= _549.d0;
    _562 += _110.d1;
    _562 *= _549.d1;
    _562 += _243.d0;
    _562 *= _549.d2;
    _562 += _243.d0;
    _a3_int64_t _563 = _549.data[_562];
    int64_t _564 = -_110.d1;
    if (_110.d0 >= 0)
    goto _jump2399;
    fail_assertion("negative array index");
    _jump2399:;
    if (_110.d0 < _563.d0)
    goto _jump2400;
    fail_assertion("index too large");
    _jump2400:;
    if (c >= 0)
    goto _jump2401;
    fail_assertion("negative array index");
    _jump2401:;
    if (c < _563.d1)
    goto _jump2402;
    fail_assertion("index too large");
    _jump2402:;
    if (_564 >= 0)
    goto _jump2403;
    fail_assertion("negative array index");
    _jump2403:;
    if (_564 < _563.d2)
    goto _jump2404;
    fail_assertion("index too large");
    _jump2404:;
    int64_t _565 = 0;
    _565 *= _563.d0;
    _565 += _110.d0;
    _565 *= _563.d1;
    _565 += c;
    _565 *= _563.d2;
    _565 += _564;
    int64_t _566 = _563.data[_565];
    if (_566 >= 0)
    goto _jump2405;
    fail_assertion("negative array index");
    _jump2405:;
    if (_566 < _487.d0)
    goto _jump2406;
    fail_assertion("index too large");
    _jump2406:;
    if (_243.d0 >= 0)
    goto _jump2407;
    fail_assertion("negative array index");
    _jump2407:;
    if (_243.d0 < _487.d1)
    goto _jump2408;
    fail_assertion("index too large");
    _jump2408:;
    if (_243.d0 >= 0)
    goto _jump2409;
    fail_assertion("negative array index");
    _jump2409:;
    if (_243.d0 < _487.d2)
    goto _jump2410;
    fail_assertion("index too large");
    _jump2410:;
    int64_t _567 = 0;
    _567 *= _487.d0;
    _567 += _566;
    _567 *= _487.d1;
    _567 += _243.d0;
    _567 *= _487.d2;
    _567 += _243.d0;
    _a2__a1_bool _568 = _487.data[_567];
    _a3_bool _569;
    // Computing bound for v
    _569.d0 = _110.d1;
    if (_110.d1 > 0) 
    goto _jump2411;
    fail_assertion("non-positive loop bound");
    _jump2411:;
    // Computing bound for w
    _569.d1 = c;
    if (c > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    // Computing bound for x
    _569.d2 = _110.d0;
    if (_110.d0 > 0) 
    goto _jump2413;
    fail_assertion("non-positive loop bound");
    _jump2413:;
    // Computing total size of heap memory to allocate
    int64_t _570 = 1;
    _570 *= _110.d1;
    _570 *= c;
    _570 *= _110.d0;
    _570 *= sizeof(bool);
    _569.data = jpl_alloc(_570);
    int64_t _571 = 0; // x
    int64_t _572 = 0; // w
    int64_t _573 = 0; // v
    _jump2414:; // Begin body of loop
    bool _574 = true;
    int64_t _575 = 0;
    _575 *= _569.d0;
    _575 += _573;
    _575 *= _569.d1;
    _575 += _572;
    _575 *= _569.d2;
    _575 += _571;
    _569.data[_575] = _574;
    _571++;
    if (_571 < _110.d0)
    goto _jump2414;
    _571 = 0;
    _572++;
    if (_572 < c)
    goto _jump2414;
    _572 = 0;
    _573++;
    if (_573 < _110.d1)
    goto _jump2414;
    // End body of loop
    rgba _576 = h(_568, _569);
    return _576;
}

rgba m() {
    rgba _0 = m();
    bool _1 = true;
    rgba _2 = m();
    double _3 = _2.a;
    bool _4 = true;
    bool _5;
    if (!_4)
    goto _jump2415;
    _5 = _1;
    goto _jump2416;
    _jump2415:;
    int64_t _6 = 924;
    int64_t _7 = -_6;
    int64_t _8 = -_7;
    double _9 = 83.0;
    bool _10 = _9 >= g;
    int64_t _11;
    if (!_10)
    goto _jump2417;
    int64_t _12 = -c;
    _11 = _12;
    goto _jump2418;
    _jump2417:;
    int64_t _13;
    // Computing bound for q
    int64_t _14 = 315;
    if (_14 > 0) 
    goto _jump2419;
    fail_assertion("non-positive loop bound");
    _jump2419:;
    // Computing bound for r
    if (d > 0) 
    goto _jump2420;
    fail_assertion("non-positive loop bound");
    _jump2420:;
    _13 = 0;
    int64_t _15 = 0; // r
    int64_t _16 = 0; // q
    _jump2421:; // Begin body of loop
    _13 += c;
    _15++;
    if (_15 < d)
    goto _jump2421;
    _15 = 0;
    _16++;
    if (_16 < _14)
    goto _jump2421;
    // End body of loop
    _11 = _13;
    _jump2418:;
    bool _17 = _8 >= _11;
    _5 = _17;
    _jump2416:;
    int64_t _18;
    if (!_5)
    goto _jump2422;
    int64_t _19 = 810;
    _18 = _19;
    goto _jump2423;
    _jump2422:;
    bool _20 = i(d);
    bool _21 = i(d);
    bool _22 = _20 == _21;
    _a2_int64_t _23;
    if (!_22)
    goto _jump2424;
    _23 = b;
    goto _jump2425;
    _jump2424:;
    _23 = b;
    _jump2425:;
    if (d >= 0)
    goto _jump2426;
    fail_assertion("negative array index");
    _jump2426:;
    if (d < _23.d0)
    goto _jump2427;
    fail_assertion("index too large");
    _jump2427:;
    if (d >= 0)
    goto _jump2428;
    fail_assertion("negative array index");
    _jump2428:;
    if (d < _23.d1)
    goto _jump2429;
    fail_assertion("index too large");
    _jump2429:;
    int64_t _24 = 0;
    _24 *= _23.d0;
    _24 += d;
    _24 *= _23.d1;
    _24 += d;
    int64_t _25 = _23.data[_24];
    _18 = _25;
    _jump2423:;
    int64_t _26;
    // Computing bound for q
    int64_t _27 = 684;
    int64_t _28 = d / _27;
    if (_28 > 0) 
    goto _jump2430;
    fail_assertion("non-positive loop bound");
    _jump2430:;
    // Computing bound for r
    int64_t _29;
    // Computing bound for q
    int64_t _30 = -c;
    if (_30 > 0) 
    goto _jump2431;
    fail_assertion("non-positive loop bound");
    _jump2431:;
    // Computing bound for r
    int64_t _31 = 18;
    int64_t _32 = 216;
    int64_t _33 = _31 + _32;
    int64_t _34;
    // Computing bound for q
    int64_t _35 = 466;
    if (_35 > 0) 
    goto _jump2432;
    fail_assertion("non-positive loop bound");
    _jump2432:;
    // Computing bound for r
    if (d > 0) 
    goto _jump2433;
    fail_assertion("non-positive loop bound");
    _jump2433:;
    _34 = 0;
    int64_t _36 = 0; // r
    int64_t _37 = 0; // q
    _jump2434:; // Begin body of loop
    _34 += c;
    _36++;
    if (_36 < d)
    goto _jump2434;
    _36 = 0;
    _37++;
    if (_37 < _35)
    goto _jump2434;
    // End body of loop
    int64_t _38 = -_34;
    int64_t _39 = _33 + _38;
    if (_39 > 0) 
    goto _jump2435;
    fail_assertion("non-positive loop bound");
    _jump2435:;
    _29 = 0;
    int64_t _40 = 0; // r
    int64_t _41 = 0; // q
    _jump2436:; // Begin body of loop
    int64_t _42 = -d;
    _29 += _42;
    _40++;
    if (_40 < _39)
    goto _jump2436;
    _40 = 0;
    _41++;
    if (_41 < _30)
    goto _jump2436;
    // End body of loop
    if (_29 > 0) 
    goto _jump2437;
    fail_assertion("non-positive loop bound");
    _jump2437:;
    _26 = 0;
    int64_t _43 = 0; // r
    int64_t _44 = 0; // q
    _jump2438:; // Begin body of loop
    double _46 = 51.0;
    bool _47 = _46 < _3;
    bool _45 = _47;
    if (0 == _47)
    goto _jump2439;
    bool _48 = _3 == g;
    _45 = _48;
    _jump2439:;
    _a1_int64_t _49;
    if (!_45)
    goto _jump2440;
    int64_t _50 = _44 + d;
    _a1_int64_t _51;
    _51.d0 = 2;
    _51.data = jpl_alloc(sizeof(int64_t) * 2);
    _51.data[0] = _50;
    _51.data[1] = _43;
    _49 = _51;
    goto _jump2441;
    _jump2440:;
    _a1_int64_t _52;
    _52.d0 = 1;
    _52.data = jpl_alloc(sizeof(int64_t) * 1);
    _52.data[0] = d;
    _49 = _52;
    _jump2441:;
    int64_t _53 = 632;
    if (_53 >= 0)
    goto _jump2442;
    fail_assertion("negative array index");
    _jump2442:;
    if (_53 < _49.d0)
    goto _jump2443;
    fail_assertion("index too large");
    _jump2443:;
    int64_t _54 = 0;
    _54 *= _49.d0;
    _54 += _53;
    int64_t _55 = _49.data[_54];
    _26 += _55;
    _43++;
    if (_43 < _29)
    goto _jump2438;
    _43 = 0;
    _44++;
    if (_44 < _28)
    goto _jump2438;
    // End body of loop
    int64_t _56 = _18 / _26;
    bool _57 = i(_56);
    if (0 != _57)
    goto _jump2444;
    fail_assertion("q");
    _jump2444:;
    _a3_int64_t _58;
    // Computing bound for q
    _58.d0 = d;
    if (d > 0) 
    goto _jump2445;
    fail_assertion("non-positive loop bound");
    _jump2445:;
    // Computing bound for r
    int64_t _59 = -d;
    _58.d1 = _59;
    if (_59 > 0) 
    goto _jump2446;
    fail_assertion("non-positive loop bound");
    _jump2446:;
    // Computing bound for s
    int64_t _60;
    // Computing bound for q
    int64_t _61 = 592;
    if (_61 > 0) 
    goto _jump2447;
    fail_assertion("non-positive loop bound");
    _jump2447:;
    // Computing bound for r
    int64_t _62 = 78;
    if (_62 > 0) 
    goto _jump2448;
    fail_assertion("non-positive loop bound");
    _jump2448:;
    // Computing bound for s
    if (c > 0) 
    goto _jump2449;
    fail_assertion("non-positive loop bound");
    _jump2449:;
    _60 = 0;
    int64_t _63 = 0; // s
    int64_t _64 = 0; // r
    int64_t _65 = 0; // q
    _jump2450:; // Begin body of loop
    _60 += c;
    _63++;
    if (_63 < c)
    goto _jump2450;
    _63 = 0;
    _64++;
    if (_64 < _62)
    goto _jump2450;
    _64 = 0;
    _65++;
    if (_65 < _61)
    goto _jump2450;
    // End body of loop
    _58.d2 = _60;
    if (_60 > 0) 
    goto _jump2451;
    fail_assertion("non-positive loop bound");
    _jump2451:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= d;
    _66 *= _59;
    _66 *= _60;
    _66 *= sizeof(int64_t);
    _58.data = jpl_alloc(_66);
    int64_t _67 = 0; // s
    int64_t _68 = 0; // r
    int64_t _69 = 0; // q
    _jump2452:; // Begin body of loop
    int64_t _70 = -_67;
    int64_t _71 = 0;
    _71 *= _58.d0;
    _71 += _69;
    _71 *= _58.d1;
    _71 += _68;
    _71 *= _58.d2;
    _71 += _67;
    _58.data[_71] = _70;
    _67++;
    if (_67 < _60)
    goto _jump2452;
    _67 = 0;
    _68++;
    if (_68 < _59)
    goto _jump2452;
    _68 = 0;
    _69++;
    if (_69 < d)
    goto _jump2452;
    // End body of loop
    bool _72 = true;
    int64_t _73;
    if (!_72)
    goto _jump2453;
    int64_t _74 = -c;
    _73 = _74;
    goto _jump2454;
    _jump2453:;
    int64_t _75 = 365;
    _73 = _75;
    _jump2454:;
    int64_t _76 = 407;
    int64_t _77;
    // Computing bound for q
    if (d > 0) 
    goto _jump2455;
    fail_assertion("non-positive loop bound");
    _jump2455:;
    // Computing bound for r
    int64_t _78 = 187;
    if (_78 > 0) 
    goto _jump2456;
    fail_assertion("non-positive loop bound");
    _jump2456:;
    _77 = 0;
    int64_t _79 = 0; // r
    int64_t _80 = 0; // q
    _jump2457:; // Begin body of loop
    _77 += c;
    _79++;
    if (_79 < _78)
    goto _jump2457;
    _79 = 0;
    _80++;
    if (_80 < d)
    goto _jump2457;
    // End body of loop
    if (_73 >= 0)
    goto _jump2458;
    fail_assertion("negative array index");
    _jump2458:;
    if (_73 < _58.d0)
    goto _jump2459;
    fail_assertion("index too large");
    _jump2459:;
    if (_76 >= 0)
    goto _jump2460;
    fail_assertion("negative array index");
    _jump2460:;
    if (_76 < _58.d1)
    goto _jump2461;
    fail_assertion("index too large");
    _jump2461:;
    if (_77 >= 0)
    goto _jump2462;
    fail_assertion("negative array index");
    _jump2462:;
    if (_77 < _58.d2)
    goto _jump2463;
    fail_assertion("index too large");
    _jump2463:;
    int64_t _81 = 0;
    _81 *= _58.d0;
    _81 += _73;
    _81 *= _58.d1;
    _81 += _76;
    _81 *= _58.d2;
    _81 += _77;
    int64_t _82 = _58.data[_81];
    bool _83 = i(_82);
    bool _84;
    if (!_83)
    goto _jump2464;
    double _85 = 59.0;
    double _86;
    // Computing bound for q
    int64_t _87 = 660;
    if (_87 > 0) 
    goto _jump2465;
    fail_assertion("non-positive loop bound");
    _jump2465:;
    // Computing bound for r
    if (c > 0) 
    goto _jump2466;
    fail_assertion("non-positive loop bound");
    _jump2466:;
    _86 = 0;
    int64_t _88 = 0; // r
    int64_t _89 = 0; // q
    _jump2467:; // Begin body of loop
    double _90 = 53.0;
    _86 += _90;
    _88++;
    if (_88 < c)
    goto _jump2467;
    _88 = 0;
    _89++;
    if (_89 < _87)
    goto _jump2467;
    // End body of loop
    bool _91 = _85 < _86;
    _a2_bool _92;
    if (!_91)
    goto _jump2468;
    _a2_bool _93;
    // Computing bound for q
    _93.d0 = c;
    if (c > 0) 
    goto _jump2469;
    fail_assertion("non-positive loop bound");
    _jump2469:;
    // Computing bound for r
    int64_t _94 = 9;
    _93.d1 = _94;
    if (_94 > 0) 
    goto _jump2470;
    fail_assertion("non-positive loop bound");
    _jump2470:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= c;
    _95 *= _94;
    _95 *= sizeof(bool);
    _93.data = jpl_alloc(_95);
    int64_t _96 = 0; // r
    int64_t _97 = 0; // q
    _jump2471:; // Begin body of loop
    bool _98 = _3 >= g;
    int64_t _99 = 0;
    _99 *= _93.d0;
    _99 += _97;
    _99 *= _93.d1;
    _99 += _96;
    _93.data[_99] = _98;
    _96++;
    if (_96 < _94)
    goto _jump2471;
    _96 = 0;
    _97++;
    if (_97 < c)
    goto _jump2471;
    // End body of loop
    _92 = _93;
    goto _jump2472;
    _jump2468:;
    _a2_bool _100;
    // Computing bound for q
    _100.d0 = d;
    if (d > 0) 
    goto _jump2473;
    fail_assertion("non-positive loop bound");
    _jump2473:;
    // Computing bound for r
    int64_t _101 = c % d;
    _100.d1 = _101;
    if (_101 > 0) 
    goto _jump2474;
    fail_assertion("non-positive loop bound");
    _jump2474:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= d;
    _102 *= _101;
    _102 *= sizeof(bool);
    _100.data = jpl_alloc(_102);
    int64_t _103 = 0; // r
    int64_t _104 = 0; // q
    _jump2475:; // Begin body of loop
    bool _105 = false;
    bool _106 = !_105;
    int64_t _107 = 0;
    _107 *= _100.d0;
    _107 += _104;
    _107 *= _100.d1;
    _107 += _103;
    _100.data[_107] = _106;
    _103++;
    if (_103 < _101)
    goto _jump2475;
    _103 = 0;
    _104++;
    if (_104 < d)
    goto _jump2475;
    // End body of loop
    _92 = _100;
    _jump2472:;
    int64_t _108;
    if (!_1)
    goto _jump2476;
    int64_t _109 = 698;
    _108 = _109;
    goto _jump2477;
    _jump2476:;
    int64_t _110 = 535;
    _108 = _110;
    _jump2477:;
    int64_t _111 = -_108;
    int64_t _112 = 328;
    if (_112 >= 0)
    goto _jump2478;
    fail_assertion("negative array index");
    _jump2478:;
    if (_112 < f.d0)
    goto _jump2479;
    fail_assertion("index too large");
    _jump2479:;
    if (c >= 0)
    goto _jump2480;
    fail_assertion("negative array index");
    _jump2480:;
    if (c < f.d1)
    goto _jump2481;
    fail_assertion("index too large");
    _jump2481:;
    int64_t _113 = 0;
    _113 *= f.d0;
    _113 += _112;
    _113 *= f.d1;
    _113 += c;
    int64_t _114 = f.data[_113];
    if (_111 >= 0)
    goto _jump2482;
    fail_assertion("negative array index");
    _jump2482:;
    if (_111 < _92.d0)
    goto _jump2483;
    fail_assertion("index too large");
    _jump2483:;
    if (_114 >= 0)
    goto _jump2484;
    fail_assertion("negative array index");
    _jump2484:;
    if (_114 < _92.d1)
    goto _jump2485;
    fail_assertion("index too large");
    _jump2485:;
    int64_t _115 = 0;
    _115 *= _92.d0;
    _115 += _111;
    _115 *= _92.d1;
    _115 += _114;
    bool _116 = _92.data[_115];
    _84 = _116;
    goto _jump2486;
    _jump2464:;
    int64_t _117 = d + d;
    bool _118 = d <= _117;
    _a3_bool _119;
    // Computing bound for q
    _119.d0 = d;
    if (d > 0) 
    goto _jump2487;
    fail_assertion("non-positive loop bound");
    _jump2487:;
    // Computing bound for r
    int64_t _120;
    // Computing bound for q
    if (d > 0) 
    goto _jump2488;
    fail_assertion("non-positive loop bound");
    _jump2488:;
    _120 = 0;
    int64_t _121 = 0; // q
    _jump2489:; // Begin body of loop
    _120 += _121;
    _121++;
    if (_121 < d)
    goto _jump2489;
    // End body of loop
    _119.d1 = _120;
    if (_120 > 0) 
    goto _jump2490;
    fail_assertion("non-positive loop bound");
    _jump2490:;
    // Computing bound for s
    int64_t _122 = c + c;
    _119.d2 = _122;
    if (_122 > 0) 
    goto _jump2491;
    fail_assertion("non-positive loop bound");
    _jump2491:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= d;
    _123 *= _120;
    _123 *= _122;
    _123 *= sizeof(bool);
    _119.data = jpl_alloc(_123);
    int64_t _124 = 0; // s
    int64_t _125 = 0; // r
    int64_t _126 = 0; // q
    _jump2492:; // Begin body of loop
    bool _127 = true;
    bool _128 = !_127;
    int64_t _129 = 0;
    _129 *= _119.d0;
    _129 += _126;
    _129 *= _119.d1;
    _129 += _125;
    _129 *= _119.d2;
    _129 += _124;
    _119.data[_129] = _128;
    _124++;
    if (_124 < _122)
    goto _jump2492;
    _124 = 0;
    _125++;
    if (_125 < _120)
    goto _jump2492;
    _125 = 0;
    _126++;
    if (_126 < d)
    goto _jump2492;
    // End body of loop
    rgba _130;
    if (!_1)
    goto _jump2493;
    rgba _131 = k();
    _130 = _131;
    goto _jump2494;
    _jump2493:;
    rgba _132 = a();
    _130 = _132;
    _jump2494:;
    l _133 = { _118, _119, _130 };
    bool _134 = _133.a;
    _84 = _134;
    _jump2486:;
    bool _135;
    if (!_84)
    goto _jump2495;
    double _136;
    // Computing bound for q
    if (c > 0) 
    goto _jump2496;
    fail_assertion("non-positive loop bound");
    _jump2496:;
    _136 = 0;
    int64_t _137 = 0; // q
    _jump2497:; // Begin body of loop
    _136 += g;
    _137++;
    if (_137 < c)
    goto _jump2497;
    // End body of loop
    double _138 = -_136;
    rgba _139 = a();
    double _140 = _139.b;
    bool _141 = _138 != _140;
    _a2_bool _142;
    if (!_141)
    goto _jump2498;
    _a2_bool _143;
    // Computing bound for q
    _143.d0 = c;
    if (c > 0) 
    goto _jump2499;
    fail_assertion("non-positive loop bound");
    _jump2499:;
    // Computing bound for r
    int64_t _144 = 53;
    _143.d1 = _144;
    if (_144 > 0) 
    goto _jump2500;
    fail_assertion("non-positive loop bound");
    _jump2500:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= c;
    _145 *= _144;
    _145 *= sizeof(bool);
    _143.data = jpl_alloc(_145);
    int64_t _146 = 0; // r
    int64_t _147 = 0; // q
    _jump2501:; // Begin body of loop
    int64_t _148 = -_146;
    bool _149 = _148 != d;
    int64_t _150 = 0;
    _150 *= _143.d0;
    _150 += _147;
    _150 *= _143.d1;
    _150 += _146;
    _143.data[_150] = _149;
    _146++;
    if (_146 < _144)
    goto _jump2501;
    _146 = 0;
    _147++;
    if (_147 < c)
    goto _jump2501;
    // End body of loop
    _142 = _143;
    goto _jump2502;
    _jump2498:;
    _a2_bool _151;
    // Computing bound for q
    int64_t _152 = d + d;
    _151.d0 = _152;
    if (_152 > 0) 
    goto _jump2503;
    fail_assertion("non-positive loop bound");
    _jump2503:;
    // Computing bound for r
    _151.d1 = c;
    if (c > 0) 
    goto _jump2504;
    fail_assertion("non-positive loop bound");
    _jump2504:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _152;
    _153 *= c;
    _153 *= sizeof(bool);
    _151.data = jpl_alloc(_153);
    int64_t _154 = 0; // r
    int64_t _155 = 0; // q
    _jump2505:; // Begin body of loop
    int64_t _156 = c / c;
    int64_t _157 = -c;
    bool _158 = _156 <= _157;
    int64_t _159 = 0;
    _159 *= _151.d0;
    _159 += _155;
    _159 *= _151.d1;
    _159 += _154;
    _151.data[_159] = _158;
    _154++;
    if (_154 < c)
    goto _jump2505;
    _154 = 0;
    _155++;
    if (_155 < _152)
    goto _jump2505;
    // End body of loop
    _142 = _151;
    _jump2502:;
    _a3_int64_t _160;
    // Computing bound for q
    _160.d0 = d;
    if (d > 0) 
    goto _jump2506;
    fail_assertion("non-positive loop bound");
    _jump2506:;
    // Computing bound for r
    _160.d1 = c;
    if (c > 0) 
    goto _jump2507;
    fail_assertion("non-positive loop bound");
    _jump2507:;
    // Computing bound for s
    int64_t _161 = 402;
    int64_t _162 = -_161;
    int64_t _163 = -_162;
    _160.d2 = _163;
    if (_163 > 0) 
    goto _jump2508;
    fail_assertion("non-positive loop bound");
    _jump2508:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= d;
    _164 *= c;
    _164 *= _163;
    _164 *= sizeof(int64_t);
    _160.data = jpl_alloc(_164);
    int64_t _165 = 0; // s
    int64_t _166 = 0; // r
    int64_t _167 = 0; // q
    _jump2509:; // Begin body of loop
    int64_t _168;
    // Computing bound for t
    if (c > 0) 
    goto _jump2510;
    fail_assertion("non-positive loop bound");
    _jump2510:;
    _168 = 0;
    int64_t _169 = 0; // t
    _jump2511:; // Begin body of loop
    _168 += _167;
    _169++;
    if (_169 < c)
    goto _jump2511;
    // End body of loop
    int64_t _170 = 0;
    _170 *= _160.d0;
    _170 += _167;
    _170 *= _160.d1;
    _170 += _166;
    _170 *= _160.d2;
    _170 += _165;
    _160.data[_170] = _168;
    _165++;
    if (_165 < _163)
    goto _jump2509;
    _165 = 0;
    _166++;
    if (_166 < c)
    goto _jump2509;
    _166 = 0;
    _167++;
    if (_167 < d)
    goto _jump2509;
    // End body of loop
    int64_t _171 = 335;
    int64_t _172 = -_171;
    int64_t _173 = _172 - d;
    bool _174 = i(c);
    int64_t _175;
    if (!_174)
    goto _jump2512;
    _175 = c;
    goto _jump2513;
    _jump2512:;
    int64_t _176 = 77;
    _175 = _176;
    _jump2513:;
    int64_t _177 = -_175;
    if (d >= 0)
    goto _jump2514;
    fail_assertion("negative array index");
    _jump2514:;
    if (d < _160.d0)
    goto _jump2515;
    fail_assertion("index too large");
    _jump2515:;
    if (_173 >= 0)
    goto _jump2516;
    fail_assertion("negative array index");
    _jump2516:;
    if (_173 < _160.d1)
    goto _jump2517;
    fail_assertion("index too large");
    _jump2517:;
    if (_177 >= 0)
    goto _jump2518;
    fail_assertion("negative array index");
    _jump2518:;
    if (_177 < _160.d2)
    goto _jump2519;
    fail_assertion("index too large");
    _jump2519:;
    int64_t _178 = 0;
    _178 *= _160.d0;
    _178 += d;
    _178 *= _160.d1;
    _178 += _173;
    _178 *= _160.d2;
    _178 += _177;
    int64_t _179 = _160.data[_178];
    if (_179 >= 0)
    goto _jump2520;
    fail_assertion("negative array index");
    _jump2520:;
    if (_179 < _142.d0)
    goto _jump2521;
    fail_assertion("index too large");
    _jump2521:;
    if (c >= 0)
    goto _jump2522;
    fail_assertion("negative array index");
    _jump2522:;
    if (c < _142.d1)
    goto _jump2523;
    fail_assertion("index too large");
    _jump2523:;
    int64_t _180 = 0;
    _180 *= _142.d0;
    _180 += _179;
    _180 *= _142.d1;
    _180 += c;
    bool _181 = _142.data[_180];
    _135 = _181;
    goto _jump2524;
    _jump2495:;
    _a3_double _183;
    // Computing bound for q
    _183.d0 = c;
    if (c > 0) 
    goto _jump2525;
    fail_assertion("non-positive loop bound");
    _jump2525:;
    // Computing bound for r
    int64_t _184 = -d;
    _183.d1 = _184;
    if (_184 > 0) 
    goto _jump2526;
    fail_assertion("non-positive loop bound");
    _jump2526:;
    // Computing bound for s
    _183.d2 = c;
    if (c > 0) 
    goto _jump2527;
    fail_assertion("non-positive loop bound");
    _jump2527:;
    // Computing total size of heap memory to allocate
    int64_t _185 = 1;
    _185 *= c;
    _185 *= _184;
    _185 *= c;
    _185 *= sizeof(double);
    _183.data = jpl_alloc(_185);
    int64_t _186 = 0; // s
    int64_t _187 = 0; // r
    int64_t _188 = 0; // q
    _jump2528:; // Begin body of loop
    int64_t _189 = 0;
    _189 *= _183.d0;
    _189 += _188;
    _189 *= _183.d1;
    _189 += _187;
    _189 *= _183.d2;
    _189 += _186;
    _183.data[_189] = _3;
    _186++;
    if (_186 < c)
    goto _jump2528;
    _186 = 0;
    _187++;
    if (_187 < _184)
    goto _jump2528;
    _187 = 0;
    _188++;
    if (_188 < c)
    goto _jump2528;
    // End body of loop
    double _190 = 32.0;
    bool _191 = _190 == _3;
    int64_t _192;
    if (!_191)
    goto _jump2529;
    int64_t _193 = c / c;
    _192 = _193;
    goto _jump2530;
    _jump2529:;
    int64_t _194 = c / d;
    _192 = _194;
    _jump2530:;
    bool _195 = false;
    int64_t _196;
    if (!_195)
    goto _jump2531;
    int64_t _197 = 219;
    if (c >= 0)
    goto _jump2532;
    fail_assertion("negative array index");
    _jump2532:;
    if (c < b.d0)
    goto _jump2533;
    fail_assertion("index too large");
    _jump2533:;
    if (_197 >= 0)
    goto _jump2534;
    fail_assertion("negative array index");
    _jump2534:;
    if (_197 < b.d1)
    goto _jump2535;
    fail_assertion("index too large");
    _jump2535:;
    int64_t _198 = 0;
    _198 *= b.d0;
    _198 += c;
    _198 *= b.d1;
    _198 += _197;
    int64_t _199 = b.data[_198];
    _196 = _199;
    goto _jump2536;
    _jump2531:;
    bool _200 = false;
    int64_t _201;
    if (!_200)
    goto _jump2537;
    _201 = d;
    goto _jump2538;
    _jump2537:;
    _201 = c;
    _jump2538:;
    _196 = _201;
    _jump2536:;
    if (_192 >= 0)
    goto _jump2539;
    fail_assertion("negative array index");
    _jump2539:;
    if (_192 < _183.d0)
    goto _jump2540;
    fail_assertion("index too large");
    _jump2540:;
    if (_196 >= 0)
    goto _jump2541;
    fail_assertion("negative array index");
    _jump2541:;
    if (_196 < _183.d1)
    goto _jump2542;
    fail_assertion("index too large");
    _jump2542:;
    if (d >= 0)
    goto _jump2543;
    fail_assertion("negative array index");
    _jump2543:;
    if (d < _183.d2)
    goto _jump2544;
    fail_assertion("index too large");
    _jump2544:;
    int64_t _202 = 0;
    _202 *= _183.d0;
    _202 += _192;
    _202 *= _183.d1;
    _202 += _196;
    _202 *= _183.d2;
    _202 += d;
    double _203 = _183.data[_202];
    bool _204 = false;
    double _205;
    if (!_204)
    goto _jump2545;
    double _206 = 84.0;
    _205 = _206;
    goto _jump2546;
    _jump2545:;
    rgba _207 = a();
    double _208 = _207.g;
    _205 = _208;
    _jump2546:;
    bool _209 = _203 >= _205;
    bool _182 = _209;
    if (0 != _209)
    goto _jump2547;
    _a2_bool _210;
    // Computing bound for q
    _210.d0 = d;
    if (d > 0) 
    goto _jump2548;
    fail_assertion("non-positive loop bound");
    _jump2548:;
    // Computing bound for r
    int64_t _211 = 215;
    _210.d1 = _211;
    if (_211 > 0) 
    goto _jump2549;
    fail_assertion("non-positive loop bound");
    _jump2549:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= d;
    _212 *= _211;
    _212 *= sizeof(bool);
    _210.data = jpl_alloc(_212);
    int64_t _213 = 0; // r
    int64_t _214 = 0; // q
    _jump2550:; // Begin body of loop
    bool _215 = true;
    int64_t _216 = 0;
    _216 *= _210.d0;
    _216 += _214;
    _216 *= _210.d1;
    _216 += _213;
    _210.data[_216] = _215;
    _213++;
    if (_213 < _211)
    goto _jump2550;
    _213 = 0;
    _214++;
    if (_214 < d)
    goto _jump2550;
    // End body of loop
    int64_t _217 = 546;
    if (_217 >= 0)
    goto _jump2551;
    fail_assertion("negative array index");
    _jump2551:;
    if (_217 < _210.d0)
    goto _jump2552;
    fail_assertion("index too large");
    _jump2552:;
    if (c >= 0)
    goto _jump2553;
    fail_assertion("negative array index");
    _jump2553:;
    if (c < _210.d1)
    goto _jump2554;
    fail_assertion("index too large");
    _jump2554:;
    int64_t _218 = 0;
    _218 *= _210.d0;
    _218 += _217;
    _218 *= _210.d1;
    _218 += c;
    bool _219 = _210.data[_218];
    _182 = _219;
    _jump2547:;
    _135 = _182;
    _jump2524:;
    _a3_bool _220;
    if (!_135)
    goto _jump2555;
    _a3__a3_bool _221;
    // Computing bound for q
    _221.d0 = d;
    if (d > 0) 
    goto _jump2556;
    fail_assertion("non-positive loop bound");
    _jump2556:;
    // Computing bound for r
    _221.d1 = d;
    if (d > 0) 
    goto _jump2557;
    fail_assertion("non-positive loop bound");
    _jump2557:;
    // Computing bound for s
    int64_t _222 = 423;
    _221.d2 = _222;
    if (_222 > 0) 
    goto _jump2558;
    fail_assertion("non-positive loop bound");
    _jump2558:;
    // Computing total size of heap memory to allocate
    int64_t _223 = 1;
    _223 *= d;
    _223 *= d;
    _223 *= _222;
    _223 *= sizeof(_a3_bool);
    _221.data = jpl_alloc(_223);
    int64_t _224 = 0; // s
    int64_t _225 = 0; // r
    int64_t _226 = 0; // q
    _jump2559:; // Begin body of loop
    _a3_bool _227;
    // Computing bound for t
    _227.d0 = d;
    if (d > 0) 
    goto _jump2560;
    fail_assertion("non-positive loop bound");
    _jump2560:;
    // Computing bound for u
    _227.d1 = _224;
    if (_224 > 0) 
    goto _jump2561;
    fail_assertion("non-positive loop bound");
    _jump2561:;
    // Computing bound for v
    _227.d2 = d;
    if (d > 0) 
    goto _jump2562;
    fail_assertion("non-positive loop bound");
    _jump2562:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= d;
    _228 *= _224;
    _228 *= d;
    _228 *= sizeof(bool);
    _227.data = jpl_alloc(_228);
    int64_t _229 = 0; // v
    int64_t _230 = 0; // u
    int64_t _231 = 0; // t
    _jump2563:; // Begin body of loop
    bool _232 = i(_230);
    int64_t _233 = 0;
    _233 *= _227.d0;
    _233 += _231;
    _233 *= _227.d1;
    _233 += _230;
    _233 *= _227.d2;
    _233 += _229;
    _227.data[_233] = _232;
    _229++;
    if (_229 < d)
    goto _jump2563;
    _229 = 0;
    _230++;
    if (_230 < _224)
    goto _jump2563;
    _230 = 0;
    _231++;
    if (_231 < d)
    goto _jump2563;
    // End body of loop
    _a3_bool _234;
    // Computing bound for t
    _234.d0 = _224;
    if (_224 > 0) 
    goto _jump2564;
    fail_assertion("non-positive loop bound");
    _jump2564:;
    // Computing bound for u
    int64_t _235 = -c;
    _234.d1 = _235;
    if (_235 > 0) 
    goto _jump2565;
    fail_assertion("non-positive loop bound");
    _jump2565:;
    // Computing bound for v
    int64_t _236 = 349;
    _234.d2 = _236;
    if (_236 > 0) 
    goto _jump2566;
    fail_assertion("non-positive loop bound");
    _jump2566:;
    // Computing total size of heap memory to allocate
    int64_t _237 = 1;
    _237 *= _224;
    _237 *= _235;
    _237 *= _236;
    _237 *= sizeof(bool);
    _234.data = jpl_alloc(_237);
    int64_t _238 = 0; // v
    int64_t _239 = 0; // u
    int64_t _240 = 0; // t
    _jump2567:; // Begin body of loop
    bool _241 = false;
    bool _242 = !_241;
    int64_t _243 = 0;
    _243 *= _234.d0;
    _243 += _240;
    _243 *= _234.d1;
    _243 += _239;
    _243 *= _234.d2;
    _243 += _238;
    _234.data[_243] = _242;
    _238++;
    if (_238 < _236)
    goto _jump2567;
    _238 = 0;
    _239++;
    if (_239 < _235)
    goto _jump2567;
    _239 = 0;
    _240++;
    if (_240 < _224)
    goto _jump2567;
    // End body of loop
    _a1__a3_bool _244;
    _244.d0 = 2;
    _244.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _244.data[0] = _227;
    _244.data[1] = _234;
    int64_t _245;
    // Computing bound for t
    int64_t _246 = _225 + _224;
    if (_246 > 0) 
    goto _jump2568;
    fail_assertion("non-positive loop bound");
    _jump2568:;
    _245 = 0;
    int64_t _247 = 0; // t
    _jump2569:; // Begin body of loop
    _245 += c;
    _247++;
    if (_247 < _246)
    goto _jump2569;
    // End body of loop
    if (_245 >= 0)
    goto _jump2570;
    fail_assertion("negative array index");
    _jump2570:;
    if (_245 < _244.d0)
    goto _jump2571;
    fail_assertion("index too large");
    _jump2571:;
    int64_t _248 = 0;
    _248 *= _244.d0;
    _248 += _245;
    _a3_bool _249 = _244.data[_248];
    int64_t _250 = 0;
    _250 *= _221.d0;
    _250 += _226;
    _250 *= _221.d1;
    _250 += _225;
    _250 *= _221.d2;
    _250 += _224;
    _221.data[_250] = _249;
    _224++;
    if (_224 < _222)
    goto _jump2559;
    _224 = 0;
    _225++;
    if (_225 < d)
    goto _jump2559;
    _225 = 0;
    _226++;
    if (_226 < d)
    goto _jump2559;
    // End body of loop
    int64_t _251;
    // Computing bound for q
    int64_t _252 = 660;
    if (_252 > 0) 
    goto _jump2572;
    fail_assertion("non-positive loop bound");
    _jump2572:;
    // Computing bound for r
    int64_t _253 = 613;
    int64_t _254 = -_253;
    if (_254 > 0) 
    goto _jump2573;
    fail_assertion("non-positive loop bound");
    _jump2573:;
    // Computing bound for s
    if (c > 0) 
    goto _jump2574;
    fail_assertion("non-positive loop bound");
    _jump2574:;
    _251 = 0;
    int64_t _255 = 0; // s
    int64_t _256 = 0; // r
    int64_t _257 = 0; // q
    _jump2575:; // Begin body of loop
    int64_t _258;
    // Computing bound for t
    if (_257 > 0) 
    goto _jump2576;
    fail_assertion("non-positive loop bound");
    _jump2576:;
    // Computing bound for u
    if (d > 0) 
    goto _jump2577;
    fail_assertion("non-positive loop bound");
    _jump2577:;
    _258 = 0;
    int64_t _259 = 0; // u
    int64_t _260 = 0; // t
    _jump2578:; // Begin body of loop
    _258 += _257;
    _259++;
    if (_259 < d)
    goto _jump2578;
    _259 = 0;
    _260++;
    if (_260 < _257)
    goto _jump2578;
    // End body of loop
    _251 += _258;
    _255++;
    if (_255 < c)
    goto _jump2575;
    _255 = 0;
    _256++;
    if (_256 < _254)
    goto _jump2575;
    _256 = 0;
    _257++;
    if (_257 < _252)
    goto _jump2575;
    // End body of loop
    int64_t _261;
    if (!_1)
    goto _jump2579;
    _261 = c;
    goto _jump2580;
    _jump2579:;
    int64_t _262 = 383;
    if (c >= 0)
    goto _jump2581;
    fail_assertion("negative array index");
    _jump2581:;
    if (c < b.d0)
    goto _jump2582;
    fail_assertion("index too large");
    _jump2582:;
    if (_262 >= 0)
    goto _jump2583;
    fail_assertion("negative array index");
    _jump2583:;
    if (_262 < b.d1)
    goto _jump2584;
    fail_assertion("index too large");
    _jump2584:;
    int64_t _263 = 0;
    _263 *= b.d0;
    _263 += c;
    _263 *= b.d1;
    _263 += _262;
    int64_t _264 = b.data[_263];
    _261 = _264;
    _jump2580:;
    int64_t _265 = 394;
    _a1_int64_t _266;
    _266.d0 = 3;
    _266.data = jpl_alloc(sizeof(int64_t) * 3);
    _266.data[0] = _251;
    _266.data[1] = _261;
    _266.data[2] = _265;
    int64_t _267 = 339;
    bool _268 = true;
    bool _269;
    if (!_268)
    goto _jump2585;
    bool _270 = true;
    _269 = _270;
    goto _jump2586;
    _jump2585:;
    _269 = _1;
    _jump2586:;
    int64_t _271;
    if (!_269)
    goto _jump2587;
    int64_t _272 = 717;
    int64_t _273 = c / _272;
    _271 = _273;
    goto _jump2588;
    _jump2587:;
    int64_t _274 = 488;
    int64_t _275 = -_274;
    _271 = _275;
    _jump2588:;
    if (_267 >= 0)
    goto _jump2589;
    fail_assertion("negative array index");
    _jump2589:;
    if (_267 < b.d0)
    goto _jump2590;
    fail_assertion("index too large");
    _jump2590:;
    if (_271 >= 0)
    goto _jump2591;
    fail_assertion("negative array index");
    _jump2591:;
    if (_271 < b.d1)
    goto _jump2592;
    fail_assertion("index too large");
    _jump2592:;
    int64_t _276 = 0;
    _276 *= b.d0;
    _276 += _267;
    _276 *= b.d1;
    _276 += _271;
    int64_t _277 = b.data[_276];
    if (_277 >= 0)
    goto _jump2593;
    fail_assertion("negative array index");
    _jump2593:;
    if (_277 < _266.d0)
    goto _jump2594;
    fail_assertion("index too large");
    _jump2594:;
    int64_t _278 = 0;
    _278 *= _266.d0;
    _278 += _277;
    int64_t _279 = _266.data[_278];
    int64_t _280 = -_279;
    int64_t _281 = c * c;
    int64_t _282 = -_281;
    int64_t _283 = -_282;
    int64_t _284 = 232;
    if (_280 >= 0)
    goto _jump2595;
    fail_assertion("negative array index");
    _jump2595:;
    if (_280 < _221.d0)
    goto _jump2596;
    fail_assertion("index too large");
    _jump2596:;
    if (_283 >= 0)
    goto _jump2597;
    fail_assertion("negative array index");
    _jump2597:;
    if (_283 < _221.d1)
    goto _jump2598;
    fail_assertion("index too large");
    _jump2598:;
    if (_284 >= 0)
    goto _jump2599;
    fail_assertion("negative array index");
    _jump2599:;
    if (_284 < _221.d2)
    goto _jump2600;
    fail_assertion("index too large");
    _jump2600:;
    int64_t _285 = 0;
    _285 *= _221.d0;
    _285 += _280;
    _285 *= _221.d1;
    _285 += _283;
    _285 *= _221.d2;
    _285 += _284;
    _a3_bool _286 = _221.data[_285];
    _220 = _286;
    goto _jump2601;
    _jump2555:;
    _a3_bool _287;
    // Computing bound for q
    int64_t _288 = d % c;
    int64_t _289 = -_288;
    int64_t _290 = 609;
    bool _291 = _289 != _290;
    int64_t _292;
    if (!_291)
    goto _jump2602;
    _292 = d;
    goto _jump2603;
    _jump2602:;
    int64_t _293;
    // Computing bound for q
    int64_t _294;
    // Computing bound for q
    int64_t _295 = 465;
    if (_295 > 0) 
    goto _jump2604;
    fail_assertion("non-positive loop bound");
    _jump2604:;
    // Computing bound for r
    int64_t _296 = 246;
    if (_296 > 0) 
    goto _jump2605;
    fail_assertion("non-positive loop bound");
    _jump2605:;
    // Computing bound for s
    if (d > 0) 
    goto _jump2606;
    fail_assertion("non-positive loop bound");
    _jump2606:;
    _294 = 0;
    int64_t _297 = 0; // s
    int64_t _298 = 0; // r
    int64_t _299 = 0; // q
    _jump2607:; // Begin body of loop
    _294 += _297;
    _297++;
    if (_297 < d)
    goto _jump2607;
    _297 = 0;
    _298++;
    if (_298 < _296)
    goto _jump2607;
    _298 = 0;
    _299++;
    if (_299 < _295)
    goto _jump2607;
    // End body of loop
    int64_t _300 = c - _294;
    if (_300 > 0) 
    goto _jump2608;
    fail_assertion("non-positive loop bound");
    _jump2608:;
    _293 = 0;
    int64_t _301 = 0; // q
    _jump2609:; // Begin body of loop
    int64_t _302 = 888;
    _293 += _302;
    _301++;
    if (_301 < _300)
    goto _jump2609;
    // End body of loop
    int64_t _303 = _293 / d;
    _292 = _303;
    _jump2603:;
    _287.d0 = _292;
    if (_292 > 0) 
    goto _jump2610;
    fail_assertion("non-positive loop bound");
    _jump2610:;
    // Computing bound for r
    int64_t _304 = -c;
    _287.d1 = _304;
    if (_304 > 0) 
    goto _jump2611;
    fail_assertion("non-positive loop bound");
    _jump2611:;
    // Computing bound for s
    int64_t _305;
    // Computing bound for q
    if (d > 0) 
    goto _jump2612;
    fail_assertion("non-positive loop bound");
    _jump2612:;
    _305 = 0;
    int64_t _306 = 0; // q
    _jump2613:; // Begin body of loop
    int64_t _307 = 289;
    int64_t _308;
    // Computing bound for r
    if (_306 > 0) 
    goto _jump2614;
    fail_assertion("non-positive loop bound");
    _jump2614:;
    _308 = 0;
    int64_t _309 = 0; // r
    _jump2615:; // Begin body of loop
    int64_t _310;
    // Computing bound for s
    if (c > 0) 
    goto _jump2616;
    fail_assertion("non-positive loop bound");
    _jump2616:;
    // Computing bound for t
    int64_t _311 = -d;
    if (_311 > 0) 
    goto _jump2617;
    fail_assertion("non-positive loop bound");
    _jump2617:;
    _310 = 0;
    int64_t _312 = 0; // t
    int64_t _313 = 0; // s
    _jump2618:; // Begin body of loop
    _310 += d;
    _312++;
    if (_312 < _311)
    goto _jump2618;
    _312 = 0;
    _313++;
    if (_313 < c)
    goto _jump2618;
    // End body of loop
    _308 += _310;
    _309++;
    if (_309 < _306)
    goto _jump2615;
    // End body of loop
    if (_307 >= 0)
    goto _jump2619;
    fail_assertion("negative array index");
    _jump2619:;
    if (_307 < f.d0)
    goto _jump2620;
    fail_assertion("index too large");
    _jump2620:;
    if (_308 >= 0)
    goto _jump2621;
    fail_assertion("negative array index");
    _jump2621:;
    if (_308 < f.d1)
    goto _jump2622;
    fail_assertion("index too large");
    _jump2622:;
    int64_t _314 = 0;
    _314 *= f.d0;
    _314 += _307;
    _314 *= f.d1;
    _314 += _308;
    int64_t _315 = f.data[_314];
    _305 += _315;
    _306++;
    if (_306 < d)
    goto _jump2613;
    // End body of loop
    _287.d2 = _305;
    if (_305 > 0) 
    goto _jump2623;
    fail_assertion("non-positive loop bound");
    _jump2623:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= _292;
    _316 *= _304;
    _316 *= _305;
    _316 *= sizeof(bool);
    _287.data = jpl_alloc(_316);
    int64_t _317 = 0; // s
    int64_t _318 = 0; // r
    int64_t _319 = 0; // q
    _jump2624:; // Begin body of loop
    bool _320 = i(d);
    int64_t _321 = 0;
    _321 *= _287.d0;
    _321 += _319;
    _321 *= _287.d1;
    _321 += _318;
    _321 *= _287.d2;
    _321 += _317;
    _287.data[_321] = _320;
    _317++;
    if (_317 < _305)
    goto _jump2624;
    _317 = 0;
    _318++;
    if (_318 < _304)
    goto _jump2624;
    _318 = 0;
    _319++;
    if (_319 < _292)
    goto _jump2624;
    // End body of loop
    _220 = _287;
    _jump2601:;
    bool _322 = _1;
    if (0 != _1)
    goto _jump2625;
    int64_t _323;
    // Computing bound for u
    if (_220.d1 > 0) 
    goto _jump2626;
    fail_assertion("non-positive loop bound");
    _jump2626:;
    _323 = 0;
    int64_t _324 = 0; // u
    _jump2627:; // Begin body of loop
    _323 += _220.d1;
    _324++;
    if (_324 < _220.d1)
    goto _jump2627;
    // End body of loop
    bool _325 = _323 < d;
    _a1_bool _326;
    _326.d0 = 1;
    _326.data = jpl_alloc(sizeof(bool) * 1);
    _326.data[0] = _325;
    int64_t _327 = -_220.d0;
    if (_327 >= 0)
    goto _jump2628;
    fail_assertion("negative array index");
    _jump2628:;
    if (_327 < _326.d0)
    goto _jump2629;
    fail_assertion("index too large");
    _jump2629:;
    int64_t _328 = 0;
    _328 *= _326.d0;
    _328 += _327;
    bool _329 = _326.data[_328];
    _322 = _329;
    _jump2625:;
    bool _330 = !_322;
    _a3_bool _331;
    if (!_330)
    goto _jump2630;
    rgba _332 = k();
    double _333 = _332.r;
    rgba _334 = m();
    double _335 = _334.r;
    double _336 = _333 - _335;
    double _337 = -_336;
    bool _338 = false;
    bool _339;
    if (!_338)
    goto _jump2631;
    bool _340 = true;
    _339 = _340;
    goto _jump2632;
    _jump2631:;
    bool _341 = _220.d1 >= _220.d1;
    _339 = _341;
    _jump2632:;
    double _342;
    if (!_339)
    goto _jump2633;
    double _343;
    // Computing bound for u
    int64_t _344 = -_220.d0;
    if (_344 > 0) 
    goto _jump2634;
    fail_assertion("non-positive loop bound");
    _jump2634:;
    // Computing bound for v
    if (d > 0) 
    goto _jump2635;
    fail_assertion("non-positive loop bound");
    _jump2635:;
    _343 = 0;
    int64_t _345 = 0; // v
    int64_t _346 = 0; // u
    _jump2636:; // Begin body of loop
    _343 += _3;
    _345++;
    if (_345 < d)
    goto _jump2636;
    _345 = 0;
    _346++;
    if (_346 < _344)
    goto _jump2636;
    // End body of loop
    _342 = _343;
    goto _jump2637;
    _jump2633:;
    rgba _347 = a();
    double _348 = _347.a;
    double _349 = -_348;
    _342 = _349;
    _jump2637:;
    double _350 = _337 / _342;
    double _351 = 23.0;
    bool _352 = g == _3;
    _a2_double _353;
    if (!_352)
    goto _jump2638;
    _a2_double _354;
    // Computing bound for u
    int64_t _355 = 466;
    _354.d0 = _355;
    if (_355 > 0) 
    goto _jump2639;
    fail_assertion("non-positive loop bound");
    _jump2639:;
    // Computing bound for v
    _354.d1 = _220.d1;
    if (_220.d1 > 0) 
    goto _jump2640;
    fail_assertion("non-positive loop bound");
    _jump2640:;
    // Computing total size of heap memory to allocate
    int64_t _356 = 1;
    _356 *= _355;
    _356 *= _220.d1;
    _356 *= sizeof(double);
    _354.data = jpl_alloc(_356);
    int64_t _357 = 0; // v
    int64_t _358 = 0; // u
    _jump2641:; // Begin body of loop
    int64_t _359 = 0;
    _359 *= _354.d0;
    _359 += _358;
    _359 *= _354.d1;
    _359 += _357;
    _354.data[_359] = _3;
    _357++;
    if (_357 < _220.d1)
    goto _jump2641;
    _357 = 0;
    _358++;
    if (_358 < _355)
    goto _jump2641;
    // End body of loop
    _353 = _354;
    goto _jump2642;
    _jump2638:;
    _a2_double _360;
    // Computing bound for u
    int64_t _361 = 860;
    _360.d0 = _361;
    if (_361 > 0) 
    goto _jump2643;
    fail_assertion("non-positive loop bound");
    _jump2643:;
    // Computing bound for v
    _360.d1 = d;
    if (d > 0) 
    goto _jump2644;
    fail_assertion("non-positive loop bound");
    _jump2644:;
    // Computing total size of heap memory to allocate
    int64_t _362 = 1;
    _362 *= _361;
    _362 *= d;
    _362 *= sizeof(double);
    _360.data = jpl_alloc(_362);
    int64_t _363 = 0; // v
    int64_t _364 = 0; // u
    _jump2645:; // Begin body of loop
    double _365 = 86.0;
    int64_t _366 = 0;
    _366 *= _360.d0;
    _366 += _364;
    _366 *= _360.d1;
    _366 += _363;
    _360.data[_366] = _365;
    _363++;
    if (_363 < d)
    goto _jump2645;
    _363 = 0;
    _364++;
    if (_364 < _361)
    goto _jump2645;
    // End body of loop
    _353 = _360;
    _jump2642:;
    int64_t _367 = 29;
    int64_t _368 = _367 + _220.d0;
    if (c >= 0)
    goto _jump2646;
    fail_assertion("negative array index");
    _jump2646:;
    if (c < _353.d0)
    goto _jump2647;
    fail_assertion("index too large");
    _jump2647:;
    if (_368 >= 0)
    goto _jump2648;
    fail_assertion("negative array index");
    _jump2648:;
    if (_368 < _353.d1)
    goto _jump2649;
    fail_assertion("index too large");
    _jump2649:;
    int64_t _369 = 0;
    _369 *= _353.d0;
    _369 += c;
    _369 *= _353.d1;
    _369 += _368;
    double _370 = _353.data[_369];
    double _371 = fmod(_351, _370);
    bool _372 = _350 > _371;
    _a3_bool _373;
    if (!_372)
    goto _jump2650;
    _a3_bool _374;
    // Computing bound for u
    int64_t _375 = -_220.d2;
    _374.d0 = _375;
    if (_375 > 0) 
    goto _jump2651;
    fail_assertion("non-positive loop bound");
    _jump2651:;
    // Computing bound for v
    _374.d1 = _220.d0;
    if (_220.d0 > 0) 
    goto _jump2652;
    fail_assertion("non-positive loop bound");
    _jump2652:;
    // Computing bound for w
    _374.d2 = c;
    if (c > 0) 
    goto _jump2653;
    fail_assertion("non-positive loop bound");
    _jump2653:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= _375;
    _376 *= _220.d0;
    _376 *= c;
    _376 *= sizeof(bool);
    _374.data = jpl_alloc(_376);
    int64_t _377 = 0; // w
    int64_t _378 = 0; // v
    int64_t _379 = 0; // u
    _jump2654:; // Begin body of loop
    bool _380 = _220.d0 == d;
    int64_t _381 = 0;
    _381 *= _374.d0;
    _381 += _379;
    _381 *= _374.d1;
    _381 += _378;
    _381 *= _374.d2;
    _381 += _377;
    _374.data[_381] = _380;
    _377++;
    if (_377 < c)
    goto _jump2654;
    _377 = 0;
    _378++;
    if (_378 < _220.d0)
    goto _jump2654;
    _378 = 0;
    _379++;
    if (_379 < _375)
    goto _jump2654;
    // End body of loop
    _373 = _374;
    goto _jump2655;
    _jump2650:;
    _a1__a3_bool _382;
    // Computing bound for u
    _382.d0 = _220.d2;
    if (_220.d2 > 0) 
    goto _jump2656;
    fail_assertion("non-positive loop bound");
    _jump2656:;
    // Computing total size of heap memory to allocate
    int64_t _383 = 1;
    _383 *= _220.d2;
    _383 *= sizeof(_a3_bool);
    _382.data = jpl_alloc(_383);
    int64_t _384 = 0; // u
    _jump2657:; // Begin body of loop
    _a3_bool _385;
    // Computing bound for v
    _385.d0 = c;
    if (c > 0) 
    goto _jump2658;
    fail_assertion("non-positive loop bound");
    _jump2658:;
    // Computing bound for w
    _385.d1 = _384;
    if (_384 > 0) 
    goto _jump2659;
    fail_assertion("non-positive loop bound");
    _jump2659:;
    // Computing bound for x
    int64_t _386;
    // Computing bound for v
    int64_t _387 = 905;
    if (_387 > 0) 
    goto _jump2660;
    fail_assertion("non-positive loop bound");
    _jump2660:;
    // Computing bound for w
    if (c > 0) 
    goto _jump2661;
    fail_assertion("non-positive loop bound");
    _jump2661:;
    _386 = 0;
    int64_t _388 = 0; // w
    int64_t _389 = 0; // v
    _jump2662:; // Begin body of loop
    bool _390 = false;
    int64_t _391;
    if (!_390)
    goto _jump2663;
    _391 = c;
    goto _jump2664;
    _jump2663:;
    _391 = d;
    _jump2664:;
    _386 += _391;
    _388++;
    if (_388 < c)
    goto _jump2662;
    _388 = 0;
    _389++;
    if (_389 < _387)
    goto _jump2662;
    // End body of loop
    _385.d2 = _386;
    if (_386 > 0) 
    goto _jump2665;
    fail_assertion("non-positive loop bound");
    _jump2665:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= c;
    _392 *= _384;
    _392 *= _386;
    _392 *= sizeof(bool);
    _385.data = jpl_alloc(_392);
    int64_t _393 = 0; // x
    int64_t _394 = 0; // w
    int64_t _395 = 0; // v
    _jump2666:; // Begin body of loop
    bool _396 = i(_395);
    bool _397 = !_396;
    int64_t _398 = 0;
    _398 *= _385.d0;
    _398 += _395;
    _398 *= _385.d1;
    _398 += _394;
    _398 *= _385.d2;
    _398 += _393;
    _385.data[_398] = _397;
    _393++;
    if (_393 < _386)
    goto _jump2666;
    _393 = 0;
    _394++;
    if (_394 < _384)
    goto _jump2666;
    _394 = 0;
    _395++;
    if (_395 < c)
    goto _jump2666;
    // End body of loop
    int64_t _399 = 0;
    _399 *= _382.d0;
    _399 += _384;
    _382.data[_399] = _385;
    _384++;
    if (_384 < _220.d2)
    goto _jump2657;
    // End body of loop
    if (c >= 0)
    goto _jump2667;
    fail_assertion("negative array index");
    _jump2667:;
    if (c < _382.d0)
    goto _jump2668;
    fail_assertion("index too large");
    _jump2668:;
    int64_t _400 = 0;
    _400 *= _382.d0;
    _400 += c;
    _a3_bool _401 = _382.data[_400];
    _373 = _401;
    _jump2655:;
    _331 = _373;
    goto _jump2669;
    _jump2630:;
    int64_t _402 = 127;
    bool _403 = i(_402);
    bool _404 = !_403;
    bool _405 = !_404;
    bool _406 = !_405;
    l _407;
    if (!_1)
    goto _jump2670;
    bool _408 = d > d;
    l _409 = { _408, _220, _0 };
    _407 = _409;
    goto _jump2671;
    _jump2670:;
    bool _410 = i(c);
    _a3_bool _411;
    // Computing bound for u
    _411.d0 = _220.d2;
    if (_220.d2 > 0) 
    goto _jump2672;
    fail_assertion("non-positive loop bound");
    _jump2672:;
    // Computing bound for v
    _411.d1 = _220.d2;
    if (_220.d2 > 0) 
    goto _jump2673;
    fail_assertion("non-positive loop bound");
    _jump2673:;
    // Computing bound for w
    int64_t _412 = 729;
    _411.d2 = _412;
    if (_412 > 0) 
    goto _jump2674;
    fail_assertion("non-positive loop bound");
    _jump2674:;
    // Computing total size of heap memory to allocate
    int64_t _413 = 1;
    _413 *= _220.d2;
    _413 *= _220.d2;
    _413 *= _412;
    _413 *= sizeof(bool);
    _411.data = jpl_alloc(_413);
    int64_t _414 = 0; // w
    int64_t _415 = 0; // v
    int64_t _416 = 0; // u
    _jump2675:; // Begin body of loop
    bool _417 = true;
    int64_t _418 = 0;
    _418 *= _411.d0;
    _418 += _416;
    _418 *= _411.d1;
    _418 += _415;
    _418 *= _411.d2;
    _418 += _414;
    _411.data[_418] = _417;
    _414++;
    if (_414 < _412)
    goto _jump2675;
    _414 = 0;
    _415++;
    if (_415 < _220.d2)
    goto _jump2675;
    _415 = 0;
    _416++;
    if (_416 < _220.d2)
    goto _jump2675;
    // End body of loop
    rgba _419 = m();
    l _420 = { _410, _411, _419 };
    _407 = _420;
    _jump2671:;
    _a3_bool _421 = _407.b;
    rgba _422 = a();
    l _423 = { _406, _421, _422 };
    _a3_bool _424 = _423.b;
    _331 = _424;
    _jump2669:;
    _a2_rgba _425;
    // Computing bound for y
    _425.d0 = _220.d2;
    if (_220.d2 > 0) 
    goto _jump2676;
    fail_assertion("non-positive loop bound");
    _jump2676:;
    // Computing bound for z
    _425.d1 = _331.d0;
    if (_331.d0 > 0) 
    goto _jump2677;
    fail_assertion("non-positive loop bound");
    _jump2677:;
    // Computing total size of heap memory to allocate
    int64_t _426 = 1;
    _426 *= _220.d2;
    _426 *= _331.d0;
    _426 *= sizeof(rgba);
    _425.data = jpl_alloc(_426);
    int64_t _427 = 0; // z
    int64_t _428 = 0; // y
    _jump2678:; // Begin body of loop
    _a3__a2__a1_bool _429;
    // Computing bound for A
    bool _430 = true;
    int64_t _431;
    if (!_430)
    goto _jump2679;
    _431 = _220.d0;
    goto _jump2680;
    _jump2679:;
    int64_t _432 = _220.d2 - d;
    _431 = _432;
    _jump2680:;
    _429.d0 = _431;
    if (_431 > 0) 
    goto _jump2681;
    fail_assertion("non-positive loop bound");
    _jump2681:;
    // Computing bound for B
    _429.d1 = _428;
    if (_428 > 0) 
    goto _jump2682;
    fail_assertion("non-positive loop bound");
    _jump2682:;
    // Computing bound for C
    int64_t _433 = 434;
    _429.d2 = _433;
    if (_433 > 0) 
    goto _jump2683;
    fail_assertion("non-positive loop bound");
    _jump2683:;
    // Computing total size of heap memory to allocate
    int64_t _434 = 1;
    _434 *= _431;
    _434 *= _428;
    _434 *= _433;
    _434 *= sizeof(_a2__a1_bool);
    _429.data = jpl_alloc(_434);
    int64_t _435 = 0; // C
    int64_t _436 = 0; // B
    int64_t _437 = 0; // A
    _jump2684:; // Begin body of loop
    _a2__a1_bool _438;
    // Computing bound for D
    _438.d0 = _331.d0;
    if (_331.d0 > 0) 
    goto _jump2685;
    fail_assertion("non-positive loop bound");
    _jump2685:;
    // Computing bound for E
    _438.d1 = _220.d1;
    if (_220.d1 > 0) 
    goto _jump2686;
    fail_assertion("non-positive loop bound");
    _jump2686:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= _331.d0;
    _439 *= _220.d1;
    _439 *= sizeof(_a1_bool);
    _438.data = jpl_alloc(_439);
    int64_t _440 = 0; // E
    int64_t _441 = 0; // D
    _jump2687:; // Begin body of loop
    _a1_bool _442;
    // Computing bound for F
    _442.d0 = _220.d0;
    if (_220.d0 > 0) 
    goto _jump2688;
    fail_assertion("non-positive loop bound");
    _jump2688:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= _220.d0;
    _443 *= sizeof(bool);
    _442.data = jpl_alloc(_443);
    int64_t _444 = 0; // F
    _jump2689:; // Begin body of loop
    int64_t _445 = 0;
    _445 *= _442.d0;
    _445 += _444;
    _442.data[_445] = _1;
    _444++;
    if (_444 < _220.d0)
    goto _jump2689;
    // End body of loop
    int64_t _446 = 0;
    _446 *= _438.d0;
    _446 += _441;
    _446 *= _438.d1;
    _446 += _440;
    _438.data[_446] = _442;
    _440++;
    if (_440 < _220.d1)
    goto _jump2687;
    _440 = 0;
    _441++;
    if (_441 < _331.d0)
    goto _jump2687;
    // End body of loop
    int64_t _447 = 0;
    _447 *= _429.d0;
    _447 += _437;
    _447 *= _429.d1;
    _447 += _436;
    _447 *= _429.d2;
    _447 += _435;
    _429.data[_447] = _438;
    _435++;
    if (_435 < _433)
    goto _jump2684;
    _435 = 0;
    _436++;
    if (_436 < _428)
    goto _jump2684;
    _436 = 0;
    _437++;
    if (_437 < _431)
    goto _jump2684;
    // End body of loop
    if (_331.d1 >= 0)
    goto _jump2690;
    fail_assertion("negative array index");
    _jump2690:;
    if (_331.d1 < _429.d0)
    goto _jump2691;
    fail_assertion("index too large");
    _jump2691:;
    if (_428 >= 0)
    goto _jump2692;
    fail_assertion("negative array index");
    _jump2692:;
    if (_428 < _429.d1)
    goto _jump2693;
    fail_assertion("index too large");
    _jump2693:;
    if (d >= 0)
    goto _jump2694;
    fail_assertion("negative array index");
    _jump2694:;
    if (d < _429.d2)
    goto _jump2695;
    fail_assertion("index too large");
    _jump2695:;
    int64_t _448 = 0;
    _448 *= _429.d0;
    _448 += _331.d1;
    _448 *= _429.d1;
    _448 += _428;
    _448 *= _429.d2;
    _448 += d;
    _a2__a1_bool _449 = _429.data[_448];
    _a3_bool _450;
    // Computing bound for A
    int64_t _451 = 538;
    _450.d0 = _451;
    if (_451 > 0) 
    goto _jump2696;
    fail_assertion("non-positive loop bound");
    _jump2696:;
    // Computing bound for B
    _450.d1 = _220.d0;
    if (_220.d0 > 0) 
    goto _jump2697;
    fail_assertion("non-positive loop bound");
    _jump2697:;
    // Computing bound for C
    double _452;
    if (!_1)
    goto _jump2698;
    double _453 = 6.0;
    _452 = _453;
    goto _jump2699;
    _jump2698:;
    _452 = _3;
    _jump2699:;
    double _454;
    // Computing bound for A
    if (_331.d2 > 0) 
    goto _jump2700;
    fail_assertion("non-positive loop bound");
    _jump2700:;
    _454 = 0;
    int64_t _455 = 0; // A
    _jump2701:; // Begin body of loop
    double _456 = 27.0;
    _454 += _456;
    _455++;
    if (_455 < _331.d2)
    goto _jump2701;
    // End body of loop
    bool _457 = _452 <= _454;
    int64_t _458;
    if (!_457)
    goto _jump2702;
    _458 = _220.d1;
    goto _jump2703;
    _jump2702:;
    _458 = c;
    _jump2703:;
    _450.d2 = _458;
    if (_458 > 0) 
    goto _jump2704;
    fail_assertion("non-positive loop bound");
    _jump2704:;
    // Computing total size of heap memory to allocate
    int64_t _459 = 1;
    _459 *= _451;
    _459 *= _220.d0;
    _459 *= _458;
    _459 *= sizeof(bool);
    _450.data = jpl_alloc(_459);
    int64_t _460 = 0; // C
    int64_t _461 = 0; // B
    int64_t _462 = 0; // A
    _jump2705:; // Begin body of loop
    bool _463 = true;
    bool _465 = false;
    bool _464 = _465;
    if (0 == _465)
    goto _jump2706;
    bool _466 = true;
    _464 = _466;
    _jump2706:;
    bool _467 = _463 == _464;
    int64_t _468 = 0;
    _468 *= _450.d0;
    _468 += _462;
    _468 *= _450.d1;
    _468 += _461;
    _468 *= _450.d2;
    _468 += _460;
    _450.data[_468] = _467;
    _460++;
    if (_460 < _458)
    goto _jump2705;
    _460 = 0;
    _461++;
    if (_461 < _220.d0)
    goto _jump2705;
    _461 = 0;
    _462++;
    if (_462 < _451)
    goto _jump2705;
    // End body of loop
    rgba _469 = h(_449, _450);
    int64_t _470 = 0;
    _470 *= _425.d0;
    _470 += _428;
    _470 *= _425.d1;
    _470 += _427;
    _425.data[_470] = _469;
    _427++;
    if (_427 < _331.d0)
    goto _jump2678;
    _427 = 0;
    _428++;
    if (_428 < _220.d2)
    goto _jump2678;
    // End body of loop
    if (d >= 0)
    goto _jump2707;
    fail_assertion("negative array index");
    _jump2707:;
    if (d < _425.d0)
    goto _jump2708;
    fail_assertion("index too large");
    _jump2708:;
    if (_220.d1 >= 0)
    goto _jump2709;
    fail_assertion("negative array index");
    _jump2709:;
    if (_220.d1 < _425.d1)
    goto _jump2710;
    fail_assertion("index too large");
    _jump2710:;
    int64_t _471 = 0;
    _471 *= _425.d0;
    _471 += d;
    _471 *= _425.d1;
    _471 += _220.d1;
    rgba _472 = _425.data[_471];
    return _472;
}

o r() {
    int64_t _0;
    // Computing bound for s
    int64_t _1;
    // Computing bound for s
    int64_t _2 = d % d;
    bool _3 = true;
    int64_t _4;
    if (!_3)
    goto _jump2869;
    int64_t _5 = 285;
    int64_t _6 = _5 + c;
    _4 = _6;
    goto _jump2870;
    _jump2869:;
    _4 = d;
    _jump2870:;
    _a1_int64_t _7;
    _7.d0 = 3;
    _7.data = jpl_alloc(sizeof(int64_t) * 3);
    _7.data[0] = q;
    _7.data[1] = _2;
    _7.data[2] = _4;
    int64_t _8 = 408;
    if (_8 >= 0)
    goto _jump2871;
    fail_assertion("negative array index");
    _jump2871:;
    if (_8 < _7.d0)
    goto _jump2872;
    fail_assertion("index too large");
    _jump2872:;
    int64_t _9 = 0;
    _9 *= _7.d0;
    _9 += _8;
    int64_t _10 = _7.data[_9];
    if (_10 > 0) 
    goto _jump2873;
    fail_assertion("non-positive loop bound");
    _jump2873:;
    _1 = 0;
    int64_t _11 = 0; // s
    _jump2874:; // Begin body of loop
    _1 += c;
    _11++;
    if (_11 < _10)
    goto _jump2874;
    // End body of loop
    if (_1 > 0) 
    goto _jump2875;
    fail_assertion("non-positive loop bound");
    _jump2875:;
    // Computing bound for t
    int64_t _12 = -c;
    if (_12 > 0) 
    goto _jump2876;
    fail_assertion("non-positive loop bound");
    _jump2876:;
    _0 = 0;
    int64_t _13 = 0; // t
    int64_t _14 = 0; // s
    _jump2877:; // Begin body of loop
    _0 += q;
    _13++;
    if (_13 < _12)
    goto _jump2877;
    _13 = 0;
    _14++;
    if (_14 < _1)
    goto _jump2877;
    // End body of loop
    int64_t _15 = -_0;
    int64_t _16;
    // Computing bound for t
    if (c > 0) 
    goto _jump2878;
    fail_assertion("non-positive loop bound");
    _jump2878:;
    // Computing bound for u
    if (d > 0) 
    goto _jump2879;
    fail_assertion("non-positive loop bound");
    _jump2879:;
    _16 = 0;
    int64_t _17 = 0; // u
    int64_t _18 = 0; // t
    _jump2880:; // Begin body of loop
    _16 += _15;
    _17++;
    if (_17 < d)
    goto _jump2880;
    _17 = 0;
    _18++;
    if (_18 < c)
    goto _jump2880;
    // End body of loop
    int64_t _19 = d * _16;
    int64_t _20 = -_19;
    bool _21 = i(_20);
    double _22 = 74.0;
    double _23;
    // Computing bound for t
    int64_t _24 = -c;
    if (_24 > 0) 
    goto _jump2881;
    fail_assertion("non-positive loop bound");
    _jump2881:;
    _23 = 0;
    int64_t _25 = 0; // t
    _jump2882:; // Begin body of loop
    bool _26 = false;
    double _27;
    if (!_26)
    goto _jump2883;
    _27 = g;
    goto _jump2884;
    _jump2883:;
    double _28 = 1.0;
    _27 = _28;
    _jump2884:;
    double _29 = _27 + g;
    double _30 = 62.0;
    double _31 = -_30;
    double _32 = _29 - _31;
    _23 += _32;
    _25++;
    if (_25 < _24)
    goto _jump2882;
    // End body of loop
    bool _33 = _22 != _23;
    _a3_bool _34;
    if (!_33)
    goto _jump2885;
    bool _35 = false;
    o _36;
    if (!_35)
    goto _jump2886;
    o _37 = r();
    _36 = _37;
    goto _jump2887;
    _jump2886:;
    o _38 = r();
    _36 = _38;
    _jump2887:;
    l _39 = _36.a;
    _a3_bool _40 = _39.b;
    _34 = _40;
    goto _jump2888;
    _jump2885:;
    bool _41 = true;
    bool _42 = d < q;
    _a3_bool _43;
    // Computing bound for t
    _43.d0 = _15;
    if (_15 > 0) 
    goto _jump2889;
    fail_assertion("non-positive loop bound");
    _jump2889:;
    // Computing bound for u
    _43.d1 = c;
    if (c > 0) 
    goto _jump2890;
    fail_assertion("non-positive loop bound");
    _jump2890:;
    // Computing bound for v
    _43.d2 = c;
    if (c > 0) 
    goto _jump2891;
    fail_assertion("non-positive loop bound");
    _jump2891:;
    // Computing total size of heap memory to allocate
    int64_t _44 = 1;
    _44 *= _15;
    _44 *= c;
    _44 *= c;
    _44 *= sizeof(bool);
    _43.data = jpl_alloc(_44);
    int64_t _45 = 0; // v
    int64_t _46 = 0; // u
    int64_t _47 = 0; // t
    _jump2892:; // Begin body of loop
    bool _48 = true;
    int64_t _49 = 0;
    _49 *= _43.d0;
    _49 += _47;
    _49 *= _43.d1;
    _49 += _46;
    _49 *= _43.d2;
    _49 += _45;
    _43.data[_49] = _48;
    _45++;
    if (_45 < c)
    goto _jump2892;
    _45 = 0;
    _46++;
    if (_46 < c)
    goto _jump2892;
    _46 = 0;
    _47++;
    if (_47 < _15)
    goto _jump2892;
    // End body of loop
    rgba _50 = m();
    l _51 = { _42, _43, _50 };
    _a3_bool _52 = _51.b;
    bool _54 = !n;
    bool _53 = _54;
    if (0 == _54)
    goto _jump2893;
    o _55 = r();
    bool _56 = _55.c;
    _53 = _56;
    _jump2893:;
    rgba _57;
    if (!_53)
    goto _jump2894;
    o _58;
    if (!n)
    goto _jump2895;
    o _59 = r();
    _58 = _59;
    goto _jump2896;
    _jump2895:;
    o _60 = r();
    _58 = _60;
    _jump2896:;
    rgba _61 = _58.b;
    _57 = _61;
    goto _jump2897;
    _jump2894:;
    o _62 = r();
    l _63 = _62.a;
    rgba _64 = _63.c;
    _57 = _64;
    _jump2897:;
    l _65 = { _41, _52, _57 };
    _a3_bool _66 = _65.b;
    _34 = _66;
    _jump2888:;
    rgba _67 = a();
    l _68 = { _21, _34, _67 };
    _a3_bool _69;
    // Computing bound for u
    _69.d0 = d;
    if (d > 0) 
    goto _jump2898;
    fail_assertion("non-positive loop bound");
    _jump2898:;
    // Computing bound for v
    int64_t _70;
    if (!n)
    goto _jump2899;
    bool _71 = _68.a;
    double _72;
    if (!_71)
    goto _jump2900;
    _72 = g;
    goto _jump2901;
    _jump2900:;
    _72 = g;
    _jump2901:;
    double _73;
    // Computing bound for u
    int64_t _74 = 35;
    if (_74 > 0) 
    goto _jump2902;
    fail_assertion("non-positive loop bound");
    _jump2902:;
    // Computing bound for v
    if (_15 > 0) 
    goto _jump2903;
    fail_assertion("non-positive loop bound");
    _jump2903:;
    _73 = 0;
    int64_t _75 = 0; // v
    int64_t _76 = 0; // u
    _jump2904:; // Begin body of loop
    _73 += g;
    _75++;
    if (_75 < _15)
    goto _jump2904;
    _75 = 0;
    _76++;
    if (_76 < _74)
    goto _jump2904;
    // End body of loop
    bool _77 = _72 == _73;
    int64_t _78;
    if (!_77)
    goto _jump2905;
    bool _79 = false;
    int64_t _80;
    if (!_79)
    goto _jump2906;
    int64_t _81;
    // Computing bound for u
    int64_t _82 = -q;
    if (_82 > 0) 
    goto _jump2907;
    fail_assertion("non-positive loop bound");
    _jump2907:;
    // Computing bound for v
    int64_t _83 = 376;
    int64_t _84 = _83 / d;
    int64_t _85 = -_84;
    if (_85 > 0) 
    goto _jump2908;
    fail_assertion("non-positive loop bound");
    _jump2908:;
    // Computing bound for w
    if (d > 0) 
    goto _jump2909;
    fail_assertion("non-positive loop bound");
    _jump2909:;
    _81 = 0;
    int64_t _86 = 0; // w
    int64_t _87 = 0; // v
    int64_t _88 = 0; // u
    _jump2910:; // Begin body of loop
    _81 += _87;
    _86++;
    if (_86 < d)
    goto _jump2910;
    _86 = 0;
    _87++;
    if (_87 < _85)
    goto _jump2910;
    _87 = 0;
    _88++;
    if (_88 < _82)
    goto _jump2910;
    // End body of loop
    _80 = _81;
    goto _jump2911;
    _jump2906:;
    _80 = d;
    _jump2911:;
    _78 = _80;
    goto _jump2912;
    _jump2905:;
    int64_t _89 = 341;
    bool _90 = false;
    int64_t _91;
    if (!_90)
    goto _jump2913;
    _91 = _15;
    goto _jump2914;
    _jump2913:;
    _91 = _15;
    _jump2914:;
    bool _92 = _89 == _91;
    int64_t _93;
    if (!_92)
    goto _jump2915;
    _93 = d;
    goto _jump2916;
    _jump2915:;
    int64_t _94;
    // Computing bound for u
    if (_15 > 0) 
    goto _jump2917;
    fail_assertion("non-positive loop bound");
    _jump2917:;
    // Computing bound for v
    if (_15 > 0) 
    goto _jump2918;
    fail_assertion("non-positive loop bound");
    _jump2918:;
    // Computing bound for w
    if (_15 > 0) 
    goto _jump2919;
    fail_assertion("non-positive loop bound");
    _jump2919:;
    _94 = 0;
    int64_t _95 = 0; // w
    int64_t _96 = 0; // v
    int64_t _97 = 0; // u
    _jump2920:; // Begin body of loop
    _94 += q;
    _95++;
    if (_95 < _15)
    goto _jump2920;
    _95 = 0;
    _96++;
    if (_96 < _15)
    goto _jump2920;
    _96 = 0;
    _97++;
    if (_97 < _15)
    goto _jump2920;
    // End body of loop
    _93 = _94;
    _jump2916:;
    int64_t _98 = -_93;
    _78 = _98;
    _jump2912:;
    _70 = _78;
    goto _jump2921;
    _jump2899:;
    int64_t _99 = 190;
    _70 = _99;
    _jump2921:;
    _69.d1 = _70;
    if (_70 > 0) 
    goto _jump2922;
    fail_assertion("non-positive loop bound");
    _jump2922:;
    // Computing bound for w
    _a2__a2_int64_t _100;
    // Computing bound for u
    int64_t _101 = 185;
    _100.d0 = _101;
    if (_101 > 0) 
    goto _jump2923;
    fail_assertion("non-positive loop bound");
    _jump2923:;
    // Computing bound for v
    int64_t _102 = 279;
    _100.d1 = _102;
    if (_102 > 0) 
    goto _jump2924;
    fail_assertion("non-positive loop bound");
    _jump2924:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= _101;
    _103 *= _102;
    _103 *= sizeof(_a2_int64_t);
    _100.data = jpl_alloc(_103);
    int64_t _104 = 0; // v
    int64_t _105 = 0; // u
    _jump2925:; // Begin body of loop
    _a2__a2_int64_t _106;
    // Computing bound for w
    _106.d0 = _104;
    if (_104 > 0) 
    goto _jump2926;
    fail_assertion("non-positive loop bound");
    _jump2926:;
    // Computing bound for x
    _106.d1 = _105;
    if (_105 > 0) 
    goto _jump2927;
    fail_assertion("non-positive loop bound");
    _jump2927:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= _104;
    _107 *= _105;
    _107 *= sizeof(_a2_int64_t);
    _106.data = jpl_alloc(_107);
    int64_t _108 = 0; // x
    int64_t _109 = 0; // w
    _jump2928:; // Begin body of loop
    int64_t _110 = 0;
    _110 *= _106.d0;
    _110 += _109;
    _110 *= _106.d1;
    _110 += _108;
    _106.data[_110] = f;
    _108++;
    if (_108 < _105)
    goto _jump2928;
    _108 = 0;
    _109++;
    if (_109 < _104)
    goto _jump2928;
    // End body of loop
    int64_t _111 = 355;
    if (q >= 0)
    goto _jump2929;
    fail_assertion("negative array index");
    _jump2929:;
    if (q < _106.d0)
    goto _jump2930;
    fail_assertion("index too large");
    _jump2930:;
    if (_111 >= 0)
    goto _jump2931;
    fail_assertion("negative array index");
    _jump2931:;
    if (_111 < _106.d1)
    goto _jump2932;
    fail_assertion("index too large");
    _jump2932:;
    int64_t _112 = 0;
    _112 *= _106.d0;
    _112 += q;
    _112 *= _106.d1;
    _112 += _111;
    _a2_int64_t _113 = _106.data[_112];
    int64_t _114 = 0;
    _114 *= _100.d0;
    _114 += _105;
    _114 *= _100.d1;
    _114 += _104;
    _100.data[_114] = _113;
    _104++;
    if (_104 < _102)
    goto _jump2925;
    _104 = 0;
    _105++;
    if (_105 < _101)
    goto _jump2925;
    // End body of loop
    int64_t _115;
    if (!n)
    goto _jump2933;
    _115 = d;
    goto _jump2934;
    _jump2933:;
    int64_t _116 = 757;
    _115 = _116;
    _jump2934:;
    int64_t _117;
    // Computing bound for u
    int64_t _118 = -c;
    if (_118 > 0) 
    goto _jump2935;
    fail_assertion("non-positive loop bound");
    _jump2935:;
    // Computing bound for v
    if (c > 0) 
    goto _jump2936;
    fail_assertion("non-positive loop bound");
    _jump2936:;
    // Computing bound for w
    int64_t _119 = _15 - q;
    if (_119 > 0) 
    goto _jump2937;
    fail_assertion("non-positive loop bound");
    _jump2937:;
    _117 = 0;
    int64_t _120 = 0; // w
    int64_t _121 = 0; // v
    int64_t _122 = 0; // u
    _jump2938:; // Begin body of loop
    _117 += _15;
    _120++;
    if (_120 < _119)
    goto _jump2938;
    _120 = 0;
    _121++;
    if (_121 < c)
    goto _jump2938;
    _121 = 0;
    _122++;
    if (_122 < _118)
    goto _jump2938;
    // End body of loop
    if (_115 >= 0)
    goto _jump2939;
    fail_assertion("negative array index");
    _jump2939:;
    if (_115 < _100.d0)
    goto _jump2940;
    fail_assertion("index too large");
    _jump2940:;
    if (_117 >= 0)
    goto _jump2941;
    fail_assertion("negative array index");
    _jump2941:;
    if (_117 < _100.d1)
    goto _jump2942;
    fail_assertion("index too large");
    _jump2942:;
    int64_t _123 = 0;
    _123 *= _100.d0;
    _123 += _115;
    _123 *= _100.d1;
    _123 += _117;
    _a2_int64_t _124 = _100.data[_123];
    int64_t _125 = -q;
    if (c >= 0)
    goto _jump2943;
    fail_assertion("negative array index");
    _jump2943:;
    if (c < _124.d0)
    goto _jump2944;
    fail_assertion("index too large");
    _jump2944:;
    if (_125 >= 0)
    goto _jump2945;
    fail_assertion("negative array index");
    _jump2945:;
    if (_125 < _124.d1)
    goto _jump2946;
    fail_assertion("index too large");
    _jump2946:;
    int64_t _126 = 0;
    _126 *= _124.d0;
    _126 += c;
    _126 *= _124.d1;
    _126 += _125;
    int64_t _127 = _124.data[_126];
    int64_t _128 = 735;
    if (_127 >= 0)
    goto _jump2947;
    fail_assertion("negative array index");
    _jump2947:;
    if (_127 < f.d0)
    goto _jump2948;
    fail_assertion("index too large");
    _jump2948:;
    if (_128 >= 0)
    goto _jump2949;
    fail_assertion("negative array index");
    _jump2949:;
    if (_128 < f.d1)
    goto _jump2950;
    fail_assertion("index too large");
    _jump2950:;
    int64_t _129 = 0;
    _129 *= f.d0;
    _129 += _127;
    _129 *= f.d1;
    _129 += _128;
    int64_t _130 = f.data[_129];
    _69.d2 = _130;
    if (_130 > 0) 
    goto _jump2951;
    fail_assertion("non-positive loop bound");
    _jump2951:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= d;
    _131 *= _70;
    _131 *= _130;
    _131 *= sizeof(bool);
    _69.data = jpl_alloc(_131);
    int64_t _132 = 0; // w
    int64_t _133 = 0; // v
    int64_t _134 = 0; // u
    _jump2952:; // Begin body of loop
    bool _136 = true;
    bool _135 = _136;
    if (0 == _136)
    goto _jump2953;
    _a3_bool _137;
    // Computing bound for x
    _137.d0 = _133;
    if (_133 > 0) 
    goto _jump2954;
    fail_assertion("non-positive loop bound");
    _jump2954:;
    // Computing bound for y
    int64_t _138;
    // Computing bound for x
    if (_132 > 0) 
    goto _jump2955;
    fail_assertion("non-positive loop bound");
    _jump2955:;
    // Computing bound for y
    if (c > 0) 
    goto _jump2956;
    fail_assertion("non-positive loop bound");
    _jump2956:;
    _138 = 0;
    int64_t _139 = 0; // y
    int64_t _140 = 0; // x
    _jump2957:; // Begin body of loop
    bool _141 = !n;
    int64_t _142;
    if (!_141)
    goto _jump2958;
    _142 = _132;
    goto _jump2959;
    _jump2958:;
    int64_t _143 = 462;
    int64_t _144 = _143 * _139;
    _142 = _144;
    _jump2959:;
    _138 += _142;
    _139++;
    if (_139 < c)
    goto _jump2957;
    _139 = 0;
    _140++;
    if (_140 < _132)
    goto _jump2957;
    // End body of loop
    _137.d1 = _138;
    if (_138 > 0) 
    goto _jump2960;
    fail_assertion("non-positive loop bound");
    _jump2960:;
    // Computing bound for z
    _137.d2 = _134;
    if (_134 > 0) 
    goto _jump2961;
    fail_assertion("non-positive loop bound");
    _jump2961:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= _133;
    _145 *= _138;
    _145 *= _134;
    _145 *= sizeof(bool);
    _137.data = jpl_alloc(_145);
    int64_t _146 = 0; // z
    int64_t _147 = 0; // y
    int64_t _148 = 0; // x
    _jump2962:; // Begin body of loop
    int64_t _149 = 0;
    _149 *= _137.d0;
    _149 += _148;
    _149 *= _137.d1;
    _149 += _147;
    _149 *= _137.d2;
    _149 += _146;
    _137.data[_149] = n;
    _146++;
    if (_146 < _134)
    goto _jump2962;
    _146 = 0;
    _147++;
    if (_147 < _138)
    goto _jump2962;
    _147 = 0;
    _148++;
    if (_148 < _133)
    goto _jump2962;
    // End body of loop
    if (_132 >= 0)
    goto _jump2963;
    fail_assertion("negative array index");
    _jump2963:;
    if (_132 < _137.d0)
    goto _jump2964;
    fail_assertion("index too large");
    _jump2964:;
    if (_15 >= 0)
    goto _jump2965;
    fail_assertion("negative array index");
    _jump2965:;
    if (_15 < _137.d1)
    goto _jump2966;
    fail_assertion("index too large");
    _jump2966:;
    if (_133 >= 0)
    goto _jump2967;
    fail_assertion("negative array index");
    _jump2967:;
    if (_133 < _137.d2)
    goto _jump2968;
    fail_assertion("index too large");
    _jump2968:;
    int64_t _150 = 0;
    _150 *= _137.d0;
    _150 += _132;
    _150 *= _137.d1;
    _150 += _15;
    _150 *= _137.d2;
    _150 += _133;
    bool _151 = _137.data[_150];
    _135 = _151;
    _jump2953:;
    int64_t _152 = 0;
    _152 *= _69.d0;
    _152 += _134;
    _152 *= _69.d1;
    _152 += _133;
    _152 *= _69.d2;
    _152 += _132;
    _69.data[_152] = _135;
    _132++;
    if (_132 < _130)
    goto _jump2952;
    _132 = 0;
    _133++;
    if (_133 < _70)
    goto _jump2952;
    _133 = 0;
    _134++;
    if (_134 < d)
    goto _jump2952;
    // End body of loop
    double _153;
    if (!n)
    goto _jump2969;
    double _154 = 53.0;
    _153 = _154;
    goto _jump2970;
    _jump2969:;
    double _155;
    // Computing bound for w
    int64_t _156 = 275;
    if (_156 > 0) 
    goto _jump2971;
    fail_assertion("non-positive loop bound");
    _jump2971:;
    _155 = 0;
    int64_t _157 = 0; // w
    _jump2972:; // Begin body of loop
    _155 += g;
    _157++;
    if (_157 < _156)
    goto _jump2972;
    // End body of loop
    _153 = _155;
    _jump2970:;
    double _158 = 0.0;
    _a1_double _159;
    _159.d0 = 2;
    _159.data = jpl_alloc(sizeof(double) * 2);
    _159.data[0] = _153;
    _159.data[1] = _158;
    o _160 = r();
    l _161 = _160.a;
    bool _162 = _161.a;
    o _163;
    if (!_162)
    goto _jump2973;
    o _164 = r();
    _163 = _164;
    goto _jump2974;
    _jump2973:;
    bool _165 = g >= g;
    bool _166 = n;
    if (0 != n)
    goto _jump2975;
    _166 = n;
    _jump2975:;
    _a3_bool _167;
    if (!_166)
    goto _jump2976;
    _a3_bool _168 = _68.b;
    _167 = _168;
    goto _jump2977;
    _jump2976:;
    _167 = _69;
    _jump2977:;
    rgba _169 = k();
    double _170 = _169.a;
    double _171 = 1.0;
    rgba _172 = { g, _170, g, _171 };
    l _173 = { _165, _167, _172 };
    o _174 = r();
    rgba _175 = _174.b;
    o _176 = { _173, _175, n };
    _163 = _176;
    _jump2974:;
    l _177 = _163.a;
    rgba _178 = a();
    int64_t _179 = c + d;
    bool _180 = i(_179);
    o _181 = { _177, _178, _180 };
    return _181;
    _a2_o _182;
    if (!n)
    goto _jump2978;
    bool _183 = i(_15);
    bool _184 = !_183;
    bool _185;
    if (!_184)
    goto _jump2979;
    bool _186 = true;
    _185 = _186;
    goto _jump2980;
    _jump2979:;
    bool _187 = true;
    _185 = _187;
    _jump2980:;
    _a2_o _188;
    if (!_185)
    goto _jump2981;
    _a2_o _189;
    // Computing bound for y
    _189.d0 = d;
    if (d > 0) 
    goto _jump2982;
    fail_assertion("non-positive loop bound");
    _jump2982:;
    // Computing bound for z
    int64_t _190;
    // Computing bound for y
    if (d > 0) 
    goto _jump2983;
    fail_assertion("non-positive loop bound");
    _jump2983:;
    // Computing bound for z
    int64_t _191;
    // Computing bound for y
    int64_t _192 = 27;
    if (_192 > 0) 
    goto _jump2984;
    fail_assertion("non-positive loop bound");
    _jump2984:;
    _191 = 0;
    int64_t _193 = 0; // y
    _jump2985:; // Begin body of loop
    int64_t _194 = 830;
    _191 += _194;
    _193++;
    if (_193 < _192)
    goto _jump2985;
    // End body of loop
    int64_t _195 = q / _191;
    if (_195 > 0) 
    goto _jump2986;
    fail_assertion("non-positive loop bound");
    _jump2986:;
    _190 = 0;
    int64_t _196 = 0; // z
    int64_t _197 = 0; // y
    _jump2987:; // Begin body of loop
    int64_t _198;
    if (!n)
    goto _jump2988;
    _198 = _15;
    goto _jump2989;
    _jump2988:;
    _198 = _159.d0;
    _jump2989:;
    int64_t _199 = -_198;
    _190 += _199;
    _196++;
    if (_196 < _195)
    goto _jump2987;
    _196 = 0;
    _197++;
    if (_197 < d)
    goto _jump2987;
    // End body of loop
    _189.d1 = _190;
    if (_190 > 0) 
    goto _jump2990;
    fail_assertion("non-positive loop bound");
    _jump2990:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= d;
    _200 *= _190;
    _200 *= sizeof(o);
    _189.data = jpl_alloc(_200);
    int64_t _201 = 0; // z
    int64_t _202 = 0; // y
    _jump2991:; // Begin body of loop
    _a1_o _203;
    // Computing bound for A
    int64_t _204 = 797;
    _203.d0 = _204;
    if (_204 > 0) 
    goto _jump2992;
    fail_assertion("non-positive loop bound");
    _jump2992:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _204;
    _205 *= sizeof(o);
    _203.data = jpl_alloc(_205);
    int64_t _206 = 0; // A
    _jump2993:; // Begin body of loop
    o _207 = r();
    int64_t _208 = 0;
    _208 *= _203.d0;
    _208 += _206;
    _203.data[_208] = _207;
    _206++;
    if (_206 < _204)
    goto _jump2993;
    // End body of loop
    bool _209 = false;
    bool _210;
    if (!_209)
    goto _jump2994;
    _210 = n;
    goto _jump2995;
    _jump2994:;
    bool _211 = true;
    _210 = _211;
    _jump2995:;
    int64_t _212;
    if (!_210)
    goto _jump2996;
    int64_t _213 = 689;
    _212 = _213;
    goto _jump2997;
    _jump2996:;
    _212 = _201;
    _jump2997:;
    if (_212 >= 0)
    goto _jump2998;
    fail_assertion("negative array index");
    _jump2998:;
    if (_212 < _203.d0)
    goto _jump2999;
    fail_assertion("index too large");
    _jump2999:;
    int64_t _214 = 0;
    _214 *= _203.d0;
    _214 += _212;
    o _215 = _203.data[_214];
    int64_t _216 = 0;
    _216 *= _189.d0;
    _216 += _202;
    _216 *= _189.d1;
    _216 += _201;
    _189.data[_216] = _215;
    _201++;
    if (_201 < _190)
    goto _jump2991;
    _201 = 0;
    _202++;
    if (_202 < d)
    goto _jump2991;
    // End body of loop
    _188 = _189;
    goto _jump3000;
    _jump2981:;
    _a2_o _217;
    // Computing bound for y
    int64_t _218;
    // Computing bound for y
    if (q > 0) 
    goto _jump3001;
    fail_assertion("non-positive loop bound");
    _jump3001:;
    _218 = 0;
    int64_t _219 = 0; // y
    _jump3002:; // Begin body of loop
    _218 += d;
    _219++;
    if (_219 < q)
    goto _jump3002;
    // End body of loop
    _217.d0 = _218;
    if (_218 > 0) 
    goto _jump3003;
    fail_assertion("non-positive loop bound");
    _jump3003:;
    // Computing bound for z
    int64_t _220 = -c;
    _217.d1 = _220;
    if (_220 > 0) 
    goto _jump3004;
    fail_assertion("non-positive loop bound");
    _jump3004:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _218;
    _221 *= _220;
    _221 *= sizeof(o);
    _217.data = jpl_alloc(_221);
    int64_t _222 = 0; // z
    int64_t _223 = 0; // y
    _jump3005:; // Begin body of loop
    o _224 = r();
    int64_t _225 = 0;
    _225 *= _217.d0;
    _225 += _223;
    _225 *= _217.d1;
    _225 += _222;
    _217.data[_225] = _224;
    _222++;
    if (_222 < _220)
    goto _jump3005;
    _222 = 0;
    _223++;
    if (_223 < _218)
    goto _jump3005;
    // End body of loop
    _a2_o _226;
    // Computing bound for y
    _226.d0 = c;
    if (c > 0) 
    goto _jump3006;
    fail_assertion("non-positive loop bound");
    _jump3006:;
    // Computing bound for z
    int64_t _227 = 589;
    _226.d1 = _227;
    if (_227 > 0) 
    goto _jump3007;
    fail_assertion("non-positive loop bound");
    _jump3007:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= c;
    _228 *= _227;
    _228 *= sizeof(o);
    _226.data = jpl_alloc(_228);
    int64_t _229 = 0; // z
    int64_t _230 = 0; // y
    _jump3008:; // Begin body of loop
    o _231 = r();
    int64_t _232 = 0;
    _232 *= _226.d0;
    _232 += _230;
    _232 *= _226.d1;
    _232 += _229;
    _226.data[_232] = _231;
    _229++;
    if (_229 < _227)
    goto _jump3008;
    _229 = 0;
    _230++;
    if (_230 < c)
    goto _jump3008;
    // End body of loop
    _a1__a2_o _233;
    _233.d0 = 2;
    _233.data = jpl_alloc(sizeof(_a2_o) * 2);
    _233.data[0] = _217;
    _233.data[1] = _226;
    int64_t _234;
    // Computing bound for y
    int64_t _235 = 647;
    if (d >= 0)
    goto _jump3009;
    fail_assertion("negative array index");
    _jump3009:;
    if (d < f.d0)
    goto _jump3010;
    fail_assertion("index too large");
    _jump3010:;
    if (_235 >= 0)
    goto _jump3011;
    fail_assertion("negative array index");
    _jump3011:;
    if (_235 < f.d1)
    goto _jump3012;
    fail_assertion("index too large");
    _jump3012:;
    int64_t _236 = 0;
    _236 *= f.d0;
    _236 += d;
    _236 *= f.d1;
    _236 += _235;
    int64_t _237 = f.data[_236];
    int64_t _238;
    // Computing bound for y
    int64_t _239 = 92;
    if (_239 > 0) 
    goto _jump3013;
    fail_assertion("non-positive loop bound");
    _jump3013:;
    // Computing bound for z
    if (c > 0) 
    goto _jump3014;
    fail_assertion("non-positive loop bound");
    _jump3014:;
    _238 = 0;
    int64_t _240 = 0; // z
    int64_t _241 = 0; // y
    _jump3015:; // Begin body of loop
    _238 += q;
    _240++;
    if (_240 < c)
    goto _jump3015;
    _240 = 0;
    _241++;
    if (_241 < _239)
    goto _jump3015;
    // End body of loop
    int64_t _242 = _237 - _238;
    if (_242 > 0) 
    goto _jump3016;
    fail_assertion("non-positive loop bound");
    _jump3016:;
    // Computing bound for z
    if (d > 0) 
    goto _jump3017;
    fail_assertion("non-positive loop bound");
    _jump3017:;
    _234 = 0;
    int64_t _243 = 0; // z
    int64_t _244 = 0; // y
    _jump3018:; // Begin body of loop
    _234 += _15;
    _243++;
    if (_243 < d)
    goto _jump3018;
    _243 = 0;
    _244++;
    if (_244 < _242)
    goto _jump3018;
    // End body of loop
    if (_234 >= 0)
    goto _jump3019;
    fail_assertion("negative array index");
    _jump3019:;
    if (_234 < _233.d0)
    goto _jump3020;
    fail_assertion("index too large");
    _jump3020:;
    int64_t _245 = 0;
    _245 *= _233.d0;
    _245 += _234;
    _a2_o _246 = _233.data[_245];
    _188 = _246;
    _jump3000:;
    _182 = _188;
    goto _jump3021;
    _jump2978:;
    double _247;
    if (!n)
    goto _jump3022;
    _247 = g;
    goto _jump3023;
    _jump3022:;
    double _248;
    // Computing bound for y
    if (d > 0) 
    goto _jump3024;
    fail_assertion("non-positive loop bound");
    _jump3024:;
    // Computing bound for z
    if (q > 0) 
    goto _jump3025;
    fail_assertion("non-positive loop bound");
    _jump3025:;
    _248 = 0;
    int64_t _249 = 0; // z
    int64_t _250 = 0; // y
    _jump3026:; // Begin body of loop
    double _251 = 39.0;
    _248 += _251;
    _249++;
    if (_249 < q)
    goto _jump3026;
    _249 = 0;
    _250++;
    if (_250 < d)
    goto _jump3026;
    // End body of loop
    _247 = _248;
    _jump3023:;
    double _252;
    // Computing bound for y
    if (c > 0) 
    goto _jump3027;
    fail_assertion("non-positive loop bound");
    _jump3027:;
    _252 = 0;
    int64_t _253 = 0; // y
    _jump3028:; // Begin body of loop
    _252 += g;
    _253++;
    if (_253 < c)
    goto _jump3028;
    // End body of loop
    bool _254 = _247 != _252;
    _a1__a2_o _255;
    if (!_254)
    goto _jump3029;
    _a1__a2_o _256;
    // Computing bound for y
    int64_t _257 = q % d;
    if (d >= 0)
    goto _jump3030;
    fail_assertion("negative array index");
    _jump3030:;
    if (d < b.d0)
    goto _jump3031;
    fail_assertion("index too large");
    _jump3031:;
    if (c >= 0)
    goto _jump3032;
    fail_assertion("negative array index");
    _jump3032:;
    if (c < b.d1)
    goto _jump3033;
    fail_assertion("index too large");
    _jump3033:;
    int64_t _258 = 0;
    _258 *= b.d0;
    _258 += d;
    _258 *= b.d1;
    _258 += c;
    int64_t _259 = b.data[_258];
    int64_t _260 = _257 - _259;
    _256.d0 = _260;
    if (_260 > 0) 
    goto _jump3034;
    fail_assertion("non-positive loop bound");
    _jump3034:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _260;
    _261 *= sizeof(_a2_o);
    _256.data = jpl_alloc(_261);
    int64_t _262 = 0; // y
    _jump3035:; // Begin body of loop
    o _263 = r();
    bool _264 = _263.c;
    _a2_o _265;
    if (!_264)
    goto _jump3036;
    _a2_o _266;
    // Computing bound for z
    _266.d0 = _262;
    if (_262 > 0) 
    goto _jump3037;
    fail_assertion("non-positive loop bound");
    _jump3037:;
    // Computing bound for A
    _266.d1 = d;
    if (d > 0) 
    goto _jump3038;
    fail_assertion("non-positive loop bound");
    _jump3038:;
    // Computing total size of heap memory to allocate
    int64_t _267 = 1;
    _267 *= _262;
    _267 *= d;
    _267 *= sizeof(o);
    _266.data = jpl_alloc(_267);
    int64_t _268 = 0; // A
    int64_t _269 = 0; // z
    _jump3039:; // Begin body of loop
    o _270 = r();
    int64_t _271 = 0;
    _271 *= _266.d0;
    _271 += _269;
    _271 *= _266.d1;
    _271 += _268;
    _266.data[_271] = _270;
    _268++;
    if (_268 < d)
    goto _jump3039;
    _268 = 0;
    _269++;
    if (_269 < _262)
    goto _jump3039;
    // End body of loop
    _265 = _266;
    goto _jump3040;
    _jump3036:;
    _a2_o _272;
    // Computing bound for z
    _272.d0 = _159.d0;
    if (_159.d0 > 0) 
    goto _jump3041;
    fail_assertion("non-positive loop bound");
    _jump3041:;
    // Computing bound for A
    _272.d1 = _15;
    if (_15 > 0) 
    goto _jump3042;
    fail_assertion("non-positive loop bound");
    _jump3042:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= _159.d0;
    _273 *= _15;
    _273 *= sizeof(o);
    _272.data = jpl_alloc(_273);
    int64_t _274 = 0; // A
    int64_t _275 = 0; // z
    _jump3043:; // Begin body of loop
    o _276 = r();
    int64_t _277 = 0;
    _277 *= _272.d0;
    _277 += _275;
    _277 *= _272.d1;
    _277 += _274;
    _272.data[_277] = _276;
    _274++;
    if (_274 < _15)
    goto _jump3043;
    _274 = 0;
    _275++;
    if (_275 < _159.d0)
    goto _jump3043;
    // End body of loop
    _265 = _272;
    _jump3040:;
    int64_t _278 = 0;
    _278 *= _256.d0;
    _278 += _262;
    _256.data[_278] = _265;
    _262++;
    if (_262 < _260)
    goto _jump3035;
    // End body of loop
    _255 = _256;
    goto _jump3044;
    _jump3029:;
    _a1__a2_o _279;
    // Computing bound for y
    _a3_int64_t _280;
    // Computing bound for y
    int64_t _281 = 214;
    _280.d0 = _281;
    if (_281 > 0) 
    goto _jump3045;
    fail_assertion("non-positive loop bound");
    _jump3045:;
    // Computing bound for z
    _280.d1 = _159.d0;
    if (_159.d0 > 0) 
    goto _jump3046;
    fail_assertion("non-positive loop bound");
    _jump3046:;
    // Computing bound for A
    _280.d2 = q;
    if (q > 0) 
    goto _jump3047;
    fail_assertion("non-positive loop bound");
    _jump3047:;
    // Computing total size of heap memory to allocate
    int64_t _282 = 1;
    _282 *= _281;
    _282 *= _159.d0;
    _282 *= q;
    _282 *= sizeof(int64_t);
    _280.data = jpl_alloc(_282);
    int64_t _283 = 0; // A
    int64_t _284 = 0; // z
    int64_t _285 = 0; // y
    _jump3048:; // Begin body of loop
    int64_t _286 = 0;
    _286 *= _280.d0;
    _286 += _285;
    _286 *= _280.d1;
    _286 += _284;
    _286 *= _280.d2;
    _286 += _283;
    _280.data[_286] = d;
    _283++;
    if (_283 < q)
    goto _jump3048;
    _283 = 0;
    _284++;
    if (_284 < _159.d0)
    goto _jump3048;
    _284 = 0;
    _285++;
    if (_285 < _281)
    goto _jump3048;
    // End body of loop
    int64_t _287 = -d;
    int64_t _288 = -c;
    if (_287 >= 0)
    goto _jump3049;
    fail_assertion("negative array index");
    _jump3049:;
    if (_287 < _280.d0)
    goto _jump3050;
    fail_assertion("index too large");
    _jump3050:;
    if (_288 >= 0)
    goto _jump3051;
    fail_assertion("negative array index");
    _jump3051:;
    if (_288 < _280.d1)
    goto _jump3052;
    fail_assertion("index too large");
    _jump3052:;
    if (d >= 0)
    goto _jump3053;
    fail_assertion("negative array index");
    _jump3053:;
    if (d < _280.d2)
    goto _jump3054;
    fail_assertion("index too large");
    _jump3054:;
    int64_t _289 = 0;
    _289 *= _280.d0;
    _289 += _287;
    _289 *= _280.d1;
    _289 += _288;
    _289 *= _280.d2;
    _289 += d;
    int64_t _290 = _280.data[_289];
    _279.d0 = _290;
    if (_290 > 0) 
    goto _jump3055;
    fail_assertion("non-positive loop bound");
    _jump3055:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= _290;
    _291 *= sizeof(_a2_o);
    _279.data = jpl_alloc(_291);
    int64_t _292 = 0; // y
    _jump3056:; // Begin body of loop
    _a2_o _293;
    // Computing bound for z
    _293.d0 = q;
    if (q > 0) 
    goto _jump3057;
    fail_assertion("non-positive loop bound");
    _jump3057:;
    // Computing bound for A
    int64_t _294 = 448;
    _293.d1 = _294;
    if (_294 > 0) 
    goto _jump3058;
    fail_assertion("non-positive loop bound");
    _jump3058:;
    // Computing total size of heap memory to allocate
    int64_t _295 = 1;
    _295 *= q;
    _295 *= _294;
    _295 *= sizeof(o);
    _293.data = jpl_alloc(_295);
    int64_t _296 = 0; // A
    int64_t _297 = 0; // z
    _jump3059:; // Begin body of loop
    o _298 = r();
    int64_t _299 = 0;
    _299 *= _293.d0;
    _299 += _297;
    _299 *= _293.d1;
    _299 += _296;
    _293.data[_299] = _298;
    _296++;
    if (_296 < _294)
    goto _jump3059;
    _296 = 0;
    _297++;
    if (_297 < q)
    goto _jump3059;
    // End body of loop
    int64_t _300 = 0;
    _300 *= _279.d0;
    _300 += _292;
    _279.data[_300] = _293;
    _292++;
    if (_292 < _290)
    goto _jump3056;
    // End body of loop
    _255 = _279;
    _jump3044:;
    if (c >= 0)
    goto _jump3060;
    fail_assertion("negative array index");
    _jump3060:;
    if (c < _255.d0)
    goto _jump3061;
    fail_assertion("index too large");
    _jump3061:;
    int64_t _301 = 0;
    _301 *= _255.d0;
    _301 += c;
    _a2_o _302 = _255.data[_301];
    _182 = _302;
    _jump3021:;
    int64_t _303;
    // Computing bound for y
    _a2__a3_int64_t _304;
    // Computing bound for y
    _304.d0 = q;
    if (q > 0) 
    goto _jump3062;
    fail_assertion("non-positive loop bound");
    _jump3062:;
    // Computing bound for z
    _304.d1 = d;
    if (d > 0) 
    goto _jump3063;
    fail_assertion("non-positive loop bound");
    _jump3063:;
    // Computing total size of heap memory to allocate
    int64_t _305 = 1;
    _305 *= q;
    _305 *= d;
    _305 *= sizeof(_a3_int64_t);
    _304.data = jpl_alloc(_305);
    int64_t _306 = 0; // z
    int64_t _307 = 0; // y
    _jump3064:; // Begin body of loop
    _a3_int64_t _308;
    // Computing bound for A
    _308.d0 = _159.d0;
    if (_159.d0 > 0) 
    goto _jump3065;
    fail_assertion("non-positive loop bound");
    _jump3065:;
    // Computing bound for B
    int64_t _309 = 753;
    _308.d1 = _309;
    if (_309 > 0) 
    goto _jump3066;
    fail_assertion("non-positive loop bound");
    _jump3066:;
    // Computing bound for C
    _308.d2 = _307;
    if (_307 > 0) 
    goto _jump3067;
    fail_assertion("non-positive loop bound");
    _jump3067:;
    // Computing total size of heap memory to allocate
    int64_t _310 = 1;
    _310 *= _159.d0;
    _310 *= _309;
    _310 *= _307;
    _310 *= sizeof(int64_t);
    _308.data = jpl_alloc(_310);
    int64_t _311 = 0; // C
    int64_t _312 = 0; // B
    int64_t _313 = 0; // A
    _jump3068:; // Begin body of loop
    int64_t _314 = 0;
    _314 *= _308.d0;
    _314 += _313;
    _314 *= _308.d1;
    _314 += _312;
    _314 *= _308.d2;
    _314 += _311;
    _308.data[_314] = _313;
    _311++;
    if (_311 < _307)
    goto _jump3068;
    _311 = 0;
    _312++;
    if (_312 < _309)
    goto _jump3068;
    _312 = 0;
    _313++;
    if (_313 < _159.d0)
    goto _jump3068;
    // End body of loop
    int64_t _315 = 0;
    _315 *= _304.d0;
    _315 += _307;
    _315 *= _304.d1;
    _315 += _306;
    _304.data[_315] = _308;
    _306++;
    if (_306 < d)
    goto _jump3064;
    _306 = 0;
    _307++;
    if (_307 < q)
    goto _jump3064;
    // End body of loop
    int64_t _316 = -d;
    int64_t _317 = -_316;
    int64_t _318 = d - c;
    if (_317 >= 0)
    goto _jump3069;
    fail_assertion("negative array index");
    _jump3069:;
    if (_317 < _304.d0)
    goto _jump3070;
    fail_assertion("index too large");
    _jump3070:;
    if (_318 >= 0)
    goto _jump3071;
    fail_assertion("negative array index");
    _jump3071:;
    if (_318 < _304.d1)
    goto _jump3072;
    fail_assertion("index too large");
    _jump3072:;
    int64_t _319 = 0;
    _319 *= _304.d0;
    _319 += _317;
    _319 *= _304.d1;
    _319 += _318;
    _a3_int64_t _320 = _304.data[_319];
    int64_t _321;
    // Computing bound for y
    int64_t _322 = 230;
    if (_322 > 0) 
    goto _jump3073;
    fail_assertion("non-positive loop bound");
    _jump3073:;
    _321 = 0;
    int64_t _323 = 0; // y
    _jump3074:; // Begin body of loop
    int64_t _324;
    // Computing bound for z
    if (_15 > 0) 
    goto _jump3075;
    fail_assertion("non-positive loop bound");
    _jump3075:;
    // Computing bound for A
    int64_t _325 = d - _323;
    if (_325 > 0) 
    goto _jump3076;
    fail_assertion("non-positive loop bound");
    _jump3076:;
    // Computing bound for B
    if (c > 0) 
    goto _jump3077;
    fail_assertion("non-positive loop bound");
    _jump3077:;
    _324 = 0;
    int64_t _326 = 0; // B
    int64_t _327 = 0; // A
    int64_t _328 = 0; // z
    _jump3078:; // Begin body of loop
    _324 += d;
    _326++;
    if (_326 < c)
    goto _jump3078;
    _326 = 0;
    _327++;
    if (_327 < _325)
    goto _jump3078;
    _327 = 0;
    _328++;
    if (_328 < _15)
    goto _jump3078;
    // End body of loop
    _321 += _324;
    _323++;
    if (_323 < _322)
    goto _jump3074;
    // End body of loop
    _a1_int64_t _329;
    _329.d0 = 2;
    _329.data = jpl_alloc(sizeof(int64_t) * 2);
    _329.data[0] = c;
    _329.data[1] = _15;
    if (_159.d0 >= 0)
    goto _jump3079;
    fail_assertion("negative array index");
    _jump3079:;
    if (_159.d0 < _329.d0)
    goto _jump3080;
    fail_assertion("index too large");
    _jump3080:;
    int64_t _330 = 0;
    _330 *= _329.d0;
    _330 += _159.d0;
    int64_t _331 = _329.data[_330];
    o _332 = r();
    bool _333 = _332.c;
    int64_t _334;
    if (!_333)
    goto _jump3081;
    int64_t _335 = d - q;
    _334 = _335;
    goto _jump3082;
    _jump3081:;
    int64_t _336;
    // Computing bound for y
    if (_15 > 0) 
    goto _jump3083;
    fail_assertion("non-positive loop bound");
    _jump3083:;
    _336 = 0;
    int64_t _337 = 0; // y
    _jump3084:; // Begin body of loop
    _336 += d;
    _337++;
    if (_337 < _15)
    goto _jump3084;
    // End body of loop
    _334 = _336;
    _jump3082:;
    int64_t _338 = _331 / _334;
    if (c >= 0)
    goto _jump3085;
    fail_assertion("negative array index");
    _jump3085:;
    if (c < _320.d0)
    goto _jump3086;
    fail_assertion("index too large");
    _jump3086:;
    if (_321 >= 0)
    goto _jump3087;
    fail_assertion("negative array index");
    _jump3087:;
    if (_321 < _320.d1)
    goto _jump3088;
    fail_assertion("index too large");
    _jump3088:;
    if (_338 >= 0)
    goto _jump3089;
    fail_assertion("negative array index");
    _jump3089:;
    if (_338 < _320.d2)
    goto _jump3090;
    fail_assertion("index too large");
    _jump3090:;
    int64_t _339 = 0;
    _339 *= _320.d0;
    _339 += c;
    _339 *= _320.d1;
    _339 += _321;
    _339 *= _320.d2;
    _339 += _338;
    int64_t _340 = _320.data[_339];
    int64_t _341 = c % _340;
    if (_341 > 0) 
    goto _jump3091;
    fail_assertion("non-positive loop bound");
    _jump3091:;
    // Computing bound for z
    if (q > 0) 
    goto _jump3092;
    fail_assertion("non-positive loop bound");
    _jump3092:;
    // Computing bound for A
    int64_t _342;
    // Computing bound for y
    int64_t _343;
    // Computing bound for y
    _a1_int64_t _344;
    // Computing bound for y
    _344.d0 = d;
    if (d > 0) 
    goto _jump3093;
    fail_assertion("non-positive loop bound");
    _jump3093:;
    // Computing total size of heap memory to allocate
    int64_t _345 = 1;
    _345 *= d;
    _345 *= sizeof(int64_t);
    _344.data = jpl_alloc(_345);
    int64_t _346 = 0; // y
    _jump3094:; // Begin body of loop
    int64_t _347 = 0;
    _347 *= _344.d0;
    _347 += _346;
    _344.data[_347] = _159.d0;
    _346++;
    if (_346 < d)
    goto _jump3094;
    // End body of loop
    if (d >= 0)
    goto _jump3095;
    fail_assertion("negative array index");
    _jump3095:;
    if (d < _344.d0)
    goto _jump3096;
    fail_assertion("index too large");
    _jump3096:;
    int64_t _348 = 0;
    _348 *= _344.d0;
    _348 += d;
    int64_t _349 = _344.data[_348];
    if (_349 > 0) 
    goto _jump3097;
    fail_assertion("non-positive loop bound");
    _jump3097:;
    // Computing bound for z
    int64_t _350 = 789;
    int64_t _351 = _350 + d;
    if (_351 > 0) 
    goto _jump3098;
    fail_assertion("non-positive loop bound");
    _jump3098:;
    _343 = 0;
    int64_t _352 = 0; // z
    int64_t _353 = 0; // y
    _jump3099:; // Begin body of loop
    _343 += c;
    _352++;
    if (_352 < _351)
    goto _jump3099;
    _352 = 0;
    _353++;
    if (_353 < _349)
    goto _jump3099;
    // End body of loop
    if (_343 > 0) 
    goto _jump3100;
    fail_assertion("non-positive loop bound");
    _jump3100:;
    _342 = 0;
    int64_t _354 = 0; // y
    _jump3101:; // Begin body of loop
    _342 += c;
    _354++;
    if (_354 < _343)
    goto _jump3101;
    // End body of loop
    int64_t _355 = _342 % c;
    if (_355 > 0) 
    goto _jump3102;
    fail_assertion("non-positive loop bound");
    _jump3102:;
    _303 = 0;
    int64_t _356 = 0; // A
    int64_t _357 = 0; // z
    int64_t _358 = 0; // y
    _jump3103:; // Begin body of loop
    _303 += _15;
    _356++;
    if (_356 < _355)
    goto _jump3103;
    _356 = 0;
    _357++;
    if (_357 < q)
    goto _jump3103;
    _357 = 0;
    _358++;
    if (_358 < _341)
    goto _jump3103;
    // End body of loop
    if (q >= 0)
    goto _jump3104;
    fail_assertion("negative array index");
    _jump3104:;
    if (q < _182.d0)
    goto _jump3105;
    fail_assertion("index too large");
    _jump3105:;
    if (_303 >= 0)
    goto _jump3106;
    fail_assertion("negative array index");
    _jump3106:;
    if (_303 < _182.d1)
    goto _jump3107;
    fail_assertion("index too large");
    _jump3107:;
    int64_t _359 = 0;
    _359 *= _182.d0;
    _359 += q;
    _359 *= _182.d1;
    _359 += _303;
    o _360 = _182.data[_359];
    return _360;
}

void_t s(_a3_double t, rgba x) {
    bool _0 = i(c);
    o _1;
    if (!_0)
    goto _jump3108;
    o _2 = r();
    _1 = _2;
    goto _jump3109;
    _jump3108:;
    o _3 = r();
    _1 = _3;
    _jump3109:;
    rgba _4 = _1.b;
    double _5 = _4.a;
    bool _6 = _5 != g;
    l _7;
    if (!_6)
    goto _jump3110;
    o _8 = r();
    l _9 = _8.a;
    double _10 = 32.0;
    double _11 = g / _10;
    if (d >= 0)
    goto _jump3111;
    fail_assertion("negative array index");
    _jump3111:;
    if (d < t.d0)
    goto _jump3112;
    fail_assertion("index too large");
    _jump3112:;
    if (d >= 0)
    goto _jump3113;
    fail_assertion("negative array index");
    _jump3113:;
    if (d < t.d1)
    goto _jump3114;
    fail_assertion("index too large");
    _jump3114:;
    if (c >= 0)
    goto _jump3115;
    fail_assertion("negative array index");
    _jump3115:;
    if (c < t.d2)
    goto _jump3116;
    fail_assertion("index too large");
    _jump3116:;
    int64_t _12 = 0;
    _12 *= t.d0;
    _12 += d;
    _12 *= t.d1;
    _12 += d;
    _12 *= t.d2;
    _12 += c;
    double _13 = t.data[_12];
    double _14 = 38.0;
    double _15 = g * _14;
    rgba _16 = { g, _11, _13, _15 };
    bool _17 = false;
    o _18 = { _9, _16, _17 };
    l _19 = _18.a;
    _7 = _19;
    goto _jump3117;
    _jump3110:;
    bool _20 = true;
    _a1__a3_bool _21;
    // Computing bound for z
    _21.d0 = q;
    if (q > 0) 
    goto _jump3118;
    fail_assertion("non-positive loop bound");
    _jump3118:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= q;
    _22 *= sizeof(_a3_bool);
    _21.data = jpl_alloc(_22);
    int64_t _23 = 0; // z
    _jump3119:; // Begin body of loop
    _a3_bool _24;
    // Computing bound for A
    _24.d0 = t.d1;
    if (t.d1 > 0) 
    goto _jump3120;
    fail_assertion("non-positive loop bound");
    _jump3120:;
    // Computing bound for B
    int64_t _25 = -t.d0;
    _24.d1 = _25;
    if (_25 > 0) 
    goto _jump3121;
    fail_assertion("non-positive loop bound");
    _jump3121:;
    // Computing bound for C
    int64_t _26;
    // Computing bound for A
    if (t.d0 > 0) 
    goto _jump3122;
    fail_assertion("non-positive loop bound");
    _jump3122:;
    // Computing bound for B
    if (t.d1 > 0) 
    goto _jump3123;
    fail_assertion("non-positive loop bound");
    _jump3123:;
    _26 = 0;
    int64_t _27 = 0; // B
    int64_t _28 = 0; // A
    _jump3124:; // Begin body of loop
    _26 += _28;
    _27++;
    if (_27 < t.d1)
    goto _jump3124;
    _27 = 0;
    _28++;
    if (_28 < t.d0)
    goto _jump3124;
    // End body of loop
    _24.d2 = _26;
    if (_26 > 0) 
    goto _jump3125;
    fail_assertion("non-positive loop bound");
    _jump3125:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= t.d1;
    _29 *= _25;
    _29 *= _26;
    _29 *= sizeof(bool);
    _24.data = jpl_alloc(_29);
    int64_t _30 = 0; // C
    int64_t _31 = 0; // B
    int64_t _32 = 0; // A
    _jump3126:; // Begin body of loop
    bool _33 = i(c);
    int64_t _34 = 0;
    _34 *= _24.d0;
    _34 += _32;
    _34 *= _24.d1;
    _34 += _31;
    _34 *= _24.d2;
    _34 += _30;
    _24.data[_34] = _33;
    _30++;
    if (_30 < _26)
    goto _jump3126;
    _30 = 0;
    _31++;
    if (_31 < _25)
    goto _jump3126;
    _31 = 0;
    _32++;
    if (_32 < t.d1)
    goto _jump3126;
    // End body of loop
    int64_t _35 = 0;
    _35 *= _21.d0;
    _35 += _23;
    _21.data[_35] = _24;
    _23++;
    if (_23 < q)
    goto _jump3119;
    // End body of loop
    int64_t _36 = 276;
    if (_36 >= 0)
    goto _jump3127;
    fail_assertion("negative array index");
    _jump3127:;
    if (_36 < _21.d0)
    goto _jump3128;
    fail_assertion("index too large");
    _jump3128:;
    int64_t _37 = 0;
    _37 *= _21.d0;
    _37 += _36;
    _a3_bool _38 = _21.data[_37];
    rgba _39 = m();
    l _40 = { _20, _38, _39 };
    _7 = _40;
    _jump3117:;
    bool _41 = _7.a;
    if (0 != _41)
    goto _jump3129;
    fail_assertion("z");
    _jump3129:;
    _a2_l _42;
    // Computing bound for A
    _42.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump3130;
    fail_assertion("non-positive loop bound");
    _jump3130:;
    // Computing bound for B
    int64_t _43 = 170;
    rgba _44 = a();
    void_t _45 = s(t, _44);
    int64_t _46 = j(_45, t, t.d0);
    int64_t _47 = t.d2 / _46;
    int64_t _48 = _43 % _47;
    _42.d1 = _48;
    if (_48 > 0) 
    goto _jump3131;
    fail_assertion("non-positive loop bound");
    _jump3131:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= t.d0;
    _49 *= _48;
    _49 *= sizeof(l);
    _42.data = jpl_alloc(_49);
    int64_t _50 = 0; // B
    int64_t _51 = 0; // A
    _jump3132:; // Begin body of loop
    _a2_o _52;
    // Computing bound for C
    _52.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump3133;
    fail_assertion("non-positive loop bound");
    _jump3133:;
    // Computing bound for D
    int64_t _53 = 473;
    _52.d1 = _53;
    if (_53 > 0) 
    goto _jump3134;
    fail_assertion("non-positive loop bound");
    _jump3134:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= t.d0;
    _54 *= _53;
    _54 *= sizeof(o);
    _52.data = jpl_alloc(_54);
    int64_t _55 = 0; // D
    int64_t _56 = 0; // C
    _jump3135:; // Begin body of loop
    if (t.d2 >= 0)
    goto _jump3136;
    fail_assertion("negative array index");
    _jump3136:;
    if (t.d2 < p.d0)
    goto _jump3137;
    fail_assertion("index too large");
    _jump3137:;
    int64_t _57 = 0;
    _57 *= p.d0;
    _57 += t.d2;
    o _58 = p.data[_57];
    int64_t _59 = 0;
    _59 *= _52.d0;
    _59 += _56;
    _59 *= _52.d1;
    _59 += _55;
    _52.data[_59] = _58;
    _55++;
    if (_55 < _53)
    goto _jump3135;
    _55 = 0;
    _56++;
    if (_56 < t.d0)
    goto _jump3135;
    // End body of loop
    int64_t _60 = 203;
    int64_t _61;
    // Computing bound for C
    int64_t _62 = 78;
    if (_62 > 0) 
    goto _jump3138;
    fail_assertion("non-positive loop bound");
    _jump3138:;
    // Computing bound for D
    if (_51 > 0) 
    goto _jump3139;
    fail_assertion("non-positive loop bound");
    _jump3139:;
    // Computing bound for E
    if (q > 0) 
    goto _jump3140;
    fail_assertion("non-positive loop bound");
    _jump3140:;
    _61 = 0;
    int64_t _63 = 0; // E
    int64_t _64 = 0; // D
    int64_t _65 = 0; // C
    _jump3141:; // Begin body of loop
    _61 += _64;
    _63++;
    if (_63 < q)
    goto _jump3141;
    _63 = 0;
    _64++;
    if (_64 < _51)
    goto _jump3141;
    _64 = 0;
    _65++;
    if (_65 < _62)
    goto _jump3141;
    // End body of loop
    int64_t _66 = _60 % _61;
    if (_66 >= 0)
    goto _jump3142;
    fail_assertion("negative array index");
    _jump3142:;
    if (_66 < _52.d0)
    goto _jump3143;
    fail_assertion("index too large");
    _jump3143:;
    if (t.d1 >= 0)
    goto _jump3144;
    fail_assertion("negative array index");
    _jump3144:;
    if (t.d1 < _52.d1)
    goto _jump3145;
    fail_assertion("index too large");
    _jump3145:;
    int64_t _67 = 0;
    _67 *= _52.d0;
    _67 += _66;
    _67 *= _52.d1;
    _67 += t.d1;
    o _68 = _52.data[_67];
    l _69 = _68.a;
    int64_t _70 = 0;
    _70 *= _42.d0;
    _70 += _51;
    _70 *= _42.d1;
    _70 += _50;
    _42.data[_70] = _69;
    _50++;
    if (_50 < _48)
    goto _jump3132;
    _50 = 0;
    _51++;
    if (_51 < t.d0)
    goto _jump3132;
    // End body of loop
    int64_t _71 = -t.d2;
    bool _73 = i(c);
    bool _72 = _73;
    if (0 == _73)
    goto _jump3146;
    _72 = n;
    _jump3146:;
    _a3__a3_int64_t _74;
    if (!_72)
    goto _jump3147;
    _a3__a3_int64_t _75;
    // Computing bound for A
    int64_t _76 = t.d1 % t.d1;
    _75.d0 = _76;
    if (_76 > 0) 
    goto _jump3148;
    fail_assertion("non-positive loop bound");
    _jump3148:;
    // Computing bound for B
    int64_t _77;
    // Computing bound for A
    if (d > 0) 
    goto _jump3149;
    fail_assertion("non-positive loop bound");
    _jump3149:;
    _77 = 0;
    int64_t _78 = 0; // A
    _jump3150:; // Begin body of loop
    _77 += t.d2;
    _78++;
    if (_78 < d)
    goto _jump3150;
    // End body of loop
    _75.d1 = _77;
    if (_77 > 0) 
    goto _jump3151;
    fail_assertion("non-positive loop bound");
    _jump3151:;
    // Computing bound for C
    int64_t _79 = -t.d0;
    _75.d2 = _79;
    if (_79 > 0) 
    goto _jump3152;
    fail_assertion("non-positive loop bound");
    _jump3152:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= _76;
    _80 *= _77;
    _80 *= _79;
    _80 *= sizeof(_a3_int64_t);
    _75.data = jpl_alloc(_80);
    int64_t _81 = 0; // C
    int64_t _82 = 0; // B
    int64_t _83 = 0; // A
    _jump3153:; // Begin body of loop
    _a3_int64_t _84;
    // Computing bound for D
    _84.d0 = _81;
    if (_81 > 0) 
    goto _jump3154;
    fail_assertion("non-positive loop bound");
    _jump3154:;
    // Computing bound for E
    _84.d1 = c;
    if (c > 0) 
    goto _jump3155;
    fail_assertion("non-positive loop bound");
    _jump3155:;
    // Computing bound for F
    _84.d2 = _82;
    if (_82 > 0) 
    goto _jump3156;
    fail_assertion("non-positive loop bound");
    _jump3156:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= _81;
    _85 *= c;
    _85 *= _82;
    _85 *= sizeof(int64_t);
    _84.data = jpl_alloc(_85);
    int64_t _86 = 0; // F
    int64_t _87 = 0; // E
    int64_t _88 = 0; // D
    _jump3157:; // Begin body of loop
    int64_t _89 = 0;
    _89 *= _84.d0;
    _89 += _88;
    _89 *= _84.d1;
    _89 += _87;
    _89 *= _84.d2;
    _89 += _86;
    _84.data[_89] = t.d0;
    _86++;
    if (_86 < _82)
    goto _jump3157;
    _86 = 0;
    _87++;
    if (_87 < c)
    goto _jump3157;
    _87 = 0;
    _88++;
    if (_88 < _81)
    goto _jump3157;
    // End body of loop
    int64_t _90 = 0;
    _90 *= _75.d0;
    _90 += _83;
    _90 *= _75.d1;
    _90 += _82;
    _90 *= _75.d2;
    _90 += _81;
    _75.data[_90] = _84;
    _81++;
    if (_81 < _79)
    goto _jump3153;
    _81 = 0;
    _82++;
    if (_82 < _77)
    goto _jump3153;
    _82 = 0;
    _83++;
    if (_83 < _76)
    goto _jump3153;
    // End body of loop
    _74 = _75;
    goto _jump3158;
    _jump3147:;
    _a3__a3_int64_t _91;
    // Computing bound for A
    int64_t _92 = -d;
    _91.d0 = _92;
    if (_92 > 0) 
    goto _jump3159;
    fail_assertion("non-positive loop bound");
    _jump3159:;
    // Computing bound for B
    _91.d1 = t.d1;
    if (t.d1 > 0) 
    goto _jump3160;
    fail_assertion("non-positive loop bound");
    _jump3160:;
    // Computing bound for C
    bool _93 = true;
    int64_t _94;
    if (!_93)
    goto _jump3161;
    _94 = t.d1;
    goto _jump3162;
    _jump3161:;
    _94 = t.d1;
    _jump3162:;
    _91.d2 = _94;
    if (_94 > 0) 
    goto _jump3163;
    fail_assertion("non-positive loop bound");
    _jump3163:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= _92;
    _95 *= t.d1;
    _95 *= _94;
    _95 *= sizeof(_a3_int64_t);
    _91.data = jpl_alloc(_95);
    int64_t _96 = 0; // C
    int64_t _97 = 0; // B
    int64_t _98 = 0; // A
    _jump3164:; // Begin body of loop
    _a3_int64_t _99;
    // Computing bound for D
    _99.d0 = t.d1;
    if (t.d1 > 0) 
    goto _jump3165;
    fail_assertion("non-positive loop bound");
    _jump3165:;
    // Computing bound for E
    _99.d1 = d;
    if (d > 0) 
    goto _jump3166;
    fail_assertion("non-positive loop bound");
    _jump3166:;
    // Computing bound for F
    _99.d2 = _98;
    if (_98 > 0) 
    goto _jump3167;
    fail_assertion("non-positive loop bound");
    _jump3167:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= t.d1;
    _100 *= d;
    _100 *= _98;
    _100 *= sizeof(int64_t);
    _99.data = jpl_alloc(_100);
    int64_t _101 = 0; // F
    int64_t _102 = 0; // E
    int64_t _103 = 0; // D
    _jump3168:; // Begin body of loop
    int64_t _104 = 0;
    _104 *= _99.d0;
    _104 += _103;
    _104 *= _99.d1;
    _104 += _102;
    _104 *= _99.d2;
    _104 += _101;
    _99.data[_104] = c;
    _101++;
    if (_101 < _98)
    goto _jump3168;
    _101 = 0;
    _102++;
    if (_102 < d)
    goto _jump3168;
    _102 = 0;
    _103++;
    if (_103 < t.d1)
    goto _jump3168;
    // End body of loop
    int64_t _105 = 0;
    _105 *= _91.d0;
    _105 += _98;
    _105 *= _91.d1;
    _105 += _97;
    _105 *= _91.d2;
    _105 += _96;
    _91.data[_105] = _99;
    _96++;
    if (_96 < _94)
    goto _jump3164;
    _96 = 0;
    _97++;
    if (_97 < t.d1)
    goto _jump3164;
    _97 = 0;
    _98++;
    if (_98 < _92)
    goto _jump3164;
    // End body of loop
    _74 = _91;
    _jump3158:;
    _a3_double _106;
    // Computing bound for A
    _106.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump3169;
    fail_assertion("non-positive loop bound");
    _jump3169:;
    // Computing bound for B
    _106.d1 = t.d0;
    if (t.d0 > 0) 
    goto _jump3170;
    fail_assertion("non-positive loop bound");
    _jump3170:;
    // Computing bound for C
    _106.d2 = t.d0;
    if (t.d0 > 0) 
    goto _jump3171;
    fail_assertion("non-positive loop bound");
    _jump3171:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= t.d0;
    _107 *= t.d0;
    _107 *= t.d0;
    _107 *= sizeof(double);
    _106.data = jpl_alloc(_107);
    int64_t _108 = 0; // C
    int64_t _109 = 0; // B
    int64_t _110 = 0; // A
    _jump3172:; // Begin body of loop
    int64_t _111 = 0;
    _111 *= _106.d0;
    _111 += _110;
    _111 *= _106.d1;
    _111 += _109;
    _111 *= _106.d2;
    _111 += _108;
    _106.data[_111] = g;
    _108++;
    if (_108 < t.d0)
    goto _jump3172;
    _108 = 0;
    _109++;
    if (_109 < t.d0)
    goto _jump3172;
    _109 = 0;
    _110++;
    if (_110 < t.d0)
    goto _jump3172;
    // End body of loop
    rgba _112 = m();
    void_t _113 = s(_106, _112);
    bool _114 = true;
    _a3_double _115;
    if (!_114)
    goto _jump3173;
    bool _116 = false;
    _a3_double _117;
    if (!_116)
    goto _jump3174;
    _117 = t;
    goto _jump3175;
    _jump3174:;
    _117 = t;
    _jump3175:;
    _115 = _117;
    goto _jump3176;
    _jump3173:;
    _a3_double _118;
    // Computing bound for A
    _118.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump3177;
    fail_assertion("non-positive loop bound");
    _jump3177:;
    // Computing bound for B
    _118.d1 = t.d0;
    if (t.d0 > 0) 
    goto _jump3178;
    fail_assertion("non-positive loop bound");
    _jump3178:;
    // Computing bound for C
    _118.d2 = c;
    if (c > 0) 
    goto _jump3179;
    fail_assertion("non-positive loop bound");
    _jump3179:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= t.d0;
    _119 *= t.d0;
    _119 *= c;
    _119 *= sizeof(double);
    _118.data = jpl_alloc(_119);
    int64_t _120 = 0; // C
    int64_t _121 = 0; // B
    int64_t _122 = 0; // A
    _jump3180:; // Begin body of loop
    int64_t _123 = 0;
    _123 *= _118.d0;
    _123 += _122;
    _123 *= _118.d1;
    _123 += _121;
    _123 *= _118.d2;
    _123 += _120;
    _118.data[_123] = g;
    _120++;
    if (_120 < c)
    goto _jump3180;
    _120 = 0;
    _121++;
    if (_121 < t.d0)
    goto _jump3180;
    _121 = 0;
    _122++;
    if (_122 < t.d0)
    goto _jump3180;
    // End body of loop
    _115 = _118;
    _jump3176:;
    int64_t _124 = j(_113, _115, q);
    bool _126 = false;
    bool _125 = _126;
    if (0 != _126)
    goto _jump3181;
    bool _127 = true;
    _125 = _127;
    _jump3181:;
    void_t _128;
    if (!_125)
    goto _jump3182;
    rgba _129 = m();
    void_t _130 = s(t, _129);
    _128 = _130;
    goto _jump3183;
    _jump3182:;
    rgba _131 = a();
    void_t _132 = s(t, _131);
    _128 = _132;
    _jump3183:;
    int64_t _133 = j(_128, t, t.d0);
    if (_124 >= 0)
    goto _jump3184;
    fail_assertion("negative array index");
    _jump3184:;
    if (_124 < _74.d0)
    goto _jump3185;
    fail_assertion("index too large");
    _jump3185:;
    if (q >= 0)
    goto _jump3186;
    fail_assertion("negative array index");
    _jump3186:;
    if (q < _74.d1)
    goto _jump3187;
    fail_assertion("index too large");
    _jump3187:;
    if (_133 >= 0)
    goto _jump3188;
    fail_assertion("negative array index");
    _jump3188:;
    if (_133 < _74.d2)
    goto _jump3189;
    fail_assertion("index too large");
    _jump3189:;
    int64_t _134 = 0;
    _134 *= _74.d0;
    _134 += _124;
    _134 *= _74.d1;
    _134 += q;
    _134 *= _74.d2;
    _134 += _133;
    _a3_int64_t _135 = _74.data[_134];
    _a3_double _136;
    // Computing bound for A
    _136.d0 = t.d2;
    if (t.d2 > 0) 
    goto _jump3190;
    fail_assertion("non-positive loop bound");
    _jump3190:;
    // Computing bound for B
    int64_t _137 = 221;
    if (d >= 0)
    goto _jump3191;
    fail_assertion("negative array index");
    _jump3191:;
    if (d < b.d0)
    goto _jump3192;
    fail_assertion("index too large");
    _jump3192:;
    if (_137 >= 0)
    goto _jump3193;
    fail_assertion("negative array index");
    _jump3193:;
    if (_137 < b.d1)
    goto _jump3194;
    fail_assertion("index too large");
    _jump3194:;
    int64_t _138 = 0;
    _138 *= b.d0;
    _138 += d;
    _138 *= b.d1;
    _138 += _137;
    int64_t _139 = b.data[_138];
    _136.d1 = _139;
    if (_139 > 0) 
    goto _jump3195;
    fail_assertion("non-positive loop bound");
    _jump3195:;
    // Computing bound for C
    int64_t _140 = 279;
    int64_t _141 = 519;
    int64_t _142 = _140 * _141;
    _136.d2 = _142;
    if (_142 > 0) 
    goto _jump3196;
    fail_assertion("non-positive loop bound");
    _jump3196:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= t.d2;
    _143 *= _139;
    _143 *= _142;
    _143 *= sizeof(double);
    _136.data = jpl_alloc(_143);
    int64_t _144 = 0; // C
    int64_t _145 = 0; // B
    int64_t _146 = 0; // A
    _jump3197:; // Begin body of loop
    int64_t _147 = 0;
    _147 *= _136.d0;
    _147 += _146;
    _147 *= _136.d1;
    _147 += _145;
    _147 *= _136.d2;
    _147 += _144;
    _136.data[_147] = g;
    _144++;
    if (_144 < _142)
    goto _jump3197;
    _144 = 0;
    _145++;
    if (_145 < _139)
    goto _jump3197;
    _145 = 0;
    _146++;
    if (_146 < t.d2)
    goto _jump3197;
    // End body of loop
    void_t _148 = s(_136, x);
    _a3_double _149;
    // Computing bound for A
    _149.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump3198;
    fail_assertion("non-positive loop bound");
    _jump3198:;
    // Computing bound for B
    _149.d1 = t.d1;
    if (t.d1 > 0) 
    goto _jump3199;
    fail_assertion("non-positive loop bound");
    _jump3199:;
    // Computing bound for C
    _149.d2 = t.d0;
    if (t.d0 > 0) 
    goto _jump3200;
    fail_assertion("non-positive loop bound");
    _jump3200:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= t.d0;
    _150 *= t.d1;
    _150 *= t.d0;
    _150 *= sizeof(double);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // C
    int64_t _152 = 0; // B
    int64_t _153 = 0; // A
    _jump3201:; // Begin body of loop
    int64_t _154 = 0;
    _154 *= _149.d0;
    _154 += _153;
    _154 *= _149.d1;
    _154 += _152;
    _154 *= _149.d2;
    _154 += _151;
    _149.data[_154] = g;
    _151++;
    if (_151 < t.d0)
    goto _jump3201;
    _151 = 0;
    _152++;
    if (_152 < t.d1)
    goto _jump3201;
    _152 = 0;
    _153++;
    if (_153 < t.d0)
    goto _jump3201;
    // End body of loop
    void_t _155 = s(_149, x);
    bool _157 = true;
    bool _156 = _157;
    if (0 != _157)
    goto _jump3202;
    _156 = n;
    _jump3202:;
    _a3_double _158;
    if (!_156)
    goto _jump3203;
    _158 = t;
    goto _jump3204;
    _jump3203:;
    _158 = t;
    _jump3204:;
    bool _159 = t.d1 != t.d0;
    int64_t _160;
    if (!_159)
    goto _jump3205;
    _160 = t.d0;
    goto _jump3206;
    _jump3205:;
    int64_t _161 = 494;
    _160 = _161;
    _jump3206:;
    int64_t _162 = j(_155, _158, _160);
    int64_t _163 = j(_148, t, _162);
    if (_163 >= 0)
    goto _jump3207;
    fail_assertion("negative array index");
    _jump3207:;
    if (_163 < _135.d0)
    goto _jump3208;
    fail_assertion("index too large");
    _jump3208:;
    if (t.d1 >= 0)
    goto _jump3209;
    fail_assertion("negative array index");
    _jump3209:;
    if (t.d1 < _135.d1)
    goto _jump3210;
    fail_assertion("index too large");
    _jump3210:;
    if (t.d2 >= 0)
    goto _jump3211;
    fail_assertion("negative array index");
    _jump3211:;
    if (t.d2 < _135.d2)
    goto _jump3212;
    fail_assertion("index too large");
    _jump3212:;
    int64_t _164 = 0;
    _164 *= _135.d0;
    _164 += _163;
    _164 *= _135.d1;
    _164 += t.d1;
    _164 *= _135.d2;
    _164 += t.d2;
    int64_t _165 = _135.data[_164];
    if (_71 >= 0)
    goto _jump3213;
    fail_assertion("negative array index");
    _jump3213:;
    if (_71 < _42.d0)
    goto _jump3214;
    fail_assertion("index too large");
    _jump3214:;
    if (_165 >= 0)
    goto _jump3215;
    fail_assertion("negative array index");
    _jump3215:;
    if (_165 < _42.d1)
    goto _jump3216;
    fail_assertion("index too large");
    _jump3216:;
    int64_t _166 = 0;
    _166 *= _42.d0;
    _166 += _71;
    _166 *= _42.d1;
    _166 += _165;
    l _167 = _42.data[_166];
    _a3_bool _168 = _167.b;
    bool _170 = true;
    bool _171 = !_170;
    bool _169 = _171;
    if (0 != _171)
    goto _jump3217;
    bool _172 = true;
    bool _173 = !_172;
    _169 = _173;
    _jump3217:;
    _a1__a2_int64_t _174;
    if (!_169)
    goto _jump3218;
    _a3__a1__a2_int64_t _175;
    // Computing bound for E
    int64_t _176 = _168.d0 / t.d0;
    _175.d0 = _176;
    if (_176 > 0) 
    goto _jump3219;
    fail_assertion("non-positive loop bound");
    _jump3219:;
    // Computing bound for F
    _175.d1 = _168.d1;
    if (_168.d1 > 0) 
    goto _jump3220;
    fail_assertion("non-positive loop bound");
    _jump3220:;
    // Computing bound for G
    _175.d2 = _168.d1;
    if (_168.d1 > 0) 
    goto _jump3221;
    fail_assertion("non-positive loop bound");
    _jump3221:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _176;
    _177 *= _168.d1;
    _177 *= _168.d1;
    _177 *= sizeof(_a1__a2_int64_t);
    _175.data = jpl_alloc(_177);
    int64_t _178 = 0; // G
    int64_t _179 = 0; // F
    int64_t _180 = 0; // E
    _jump3222:; // Begin body of loop
    _a1__a2_int64_t _181;
    // Computing bound for H
    _181.d0 = t.d2;
    if (t.d2 > 0) 
    goto _jump3223;
    fail_assertion("non-positive loop bound");
    _jump3223:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= t.d2;
    _182 *= sizeof(_a2_int64_t);
    _181.data = jpl_alloc(_182);
    int64_t _183 = 0; // H
    _jump3224:; // Begin body of loop
    int64_t _184 = 0;
    _184 *= _181.d0;
    _184 += _183;
    _181.data[_184] = b;
    _183++;
    if (_183 < t.d2)
    goto _jump3224;
    // End body of loop
    int64_t _185 = 0;
    _185 *= _175.d0;
    _185 += _180;
    _185 *= _175.d1;
    _185 += _179;
    _185 *= _175.d2;
    _185 += _178;
    _175.data[_185] = _181;
    _178++;
    if (_178 < _168.d1)
    goto _jump3222;
    _178 = 0;
    _179++;
    if (_179 < _168.d1)
    goto _jump3222;
    _179 = 0;
    _180++;
    if (_180 < _176)
    goto _jump3222;
    // End body of loop
    int64_t _186;
    // Computing bound for E
    if (c > 0) 
    goto _jump3225;
    fail_assertion("non-positive loop bound");
    _jump3225:;
    // Computing bound for F
    if (t.d0 > 0) 
    goto _jump3226;
    fail_assertion("non-positive loop bound");
    _jump3226:;
    // Computing bound for G
    if (_168.d1 > 0) 
    goto _jump3227;
    fail_assertion("non-positive loop bound");
    _jump3227:;
    _186 = 0;
    int64_t _187 = 0; // G
    int64_t _188 = 0; // F
    int64_t _189 = 0; // E
    _jump3228:; // Begin body of loop
    int64_t _190 = -_188;
    _186 += _190;
    _187++;
    if (_187 < _168.d1)
    goto _jump3228;
    _187 = 0;
    _188++;
    if (_188 < t.d0)
    goto _jump3228;
    _188 = 0;
    _189++;
    if (_189 < c)
    goto _jump3228;
    // End body of loop
    int64_t _191 = -_186;
    if (_191 >= 0)
    goto _jump3229;
    fail_assertion("negative array index");
    _jump3229:;
    if (_191 < _175.d0)
    goto _jump3230;
    fail_assertion("index too large");
    _jump3230:;
    if (t.d1 >= 0)
    goto _jump3231;
    fail_assertion("negative array index");
    _jump3231:;
    if (t.d1 < _175.d1)
    goto _jump3232;
    fail_assertion("index too large");
    _jump3232:;
    if (c >= 0)
    goto _jump3233;
    fail_assertion("negative array index");
    _jump3233:;
    if (c < _175.d2)
    goto _jump3234;
    fail_assertion("index too large");
    _jump3234:;
    int64_t _192 = 0;
    _192 *= _175.d0;
    _192 += _191;
    _192 *= _175.d1;
    _192 += t.d1;
    _192 *= _175.d2;
    _192 += c;
    _a1__a2_int64_t _193 = _175.data[_192];
    _174 = _193;
    goto _jump3235;
    _jump3218:;
    bool _194 = false;
    _a1__a2_int64_t _195;
    if (!_194)
    goto _jump3236;
    _a1__a2_int64_t _196;
    // Computing bound for E
    _196.d0 = q;
    if (q > 0) 
    goto _jump3237;
    fail_assertion("non-positive loop bound");
    _jump3237:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= q;
    _197 *= sizeof(_a2_int64_t);
    _196.data = jpl_alloc(_197);
    int64_t _198 = 0; // E
    _jump3238:; // Begin body of loop
    int64_t _199 = 0;
    _199 *= _196.d0;
    _199 += _198;
    _196.data[_199] = f;
    _198++;
    if (_198 < q)
    goto _jump3238;
    // End body of loop
    _195 = _196;
    goto _jump3239;
    _jump3236:;
    _a1__a2_int64_t _200;
    // Computing bound for E
    _a1_int64_t _201;
    // Computing bound for E
    _201.d0 = d;
    if (d > 0) 
    goto _jump3240;
    fail_assertion("non-positive loop bound");
    _jump3240:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= d;
    _202 *= sizeof(int64_t);
    _201.data = jpl_alloc(_202);
    int64_t _203 = 0; // E
    _jump3241:; // Begin body of loop
    int64_t _204 = 0;
    _204 *= _201.d0;
    _204 += _203;
    _201.data[_204] = _168.d1;
    _203++;
    if (_203 < d)
    goto _jump3241;
    // End body of loop
    if (_168.d0 >= 0)
    goto _jump3242;
    fail_assertion("negative array index");
    _jump3242:;
    if (_168.d0 < _201.d0)
    goto _jump3243;
    fail_assertion("index too large");
    _jump3243:;
    int64_t _205 = 0;
    _205 *= _201.d0;
    _205 += _168.d0;
    int64_t _206 = _201.data[_205];
    _200.d0 = _206;
    if (_206 > 0) 
    goto _jump3244;
    fail_assertion("non-positive loop bound");
    _jump3244:;
    // Computing total size of heap memory to allocate
    int64_t _207 = 1;
    _207 *= _206;
    _207 *= sizeof(_a2_int64_t);
    _200.data = jpl_alloc(_207);
    int64_t _208 = 0; // E
    _jump3245:; // Begin body of loop
    int64_t _209 = 0;
    _209 *= _200.d0;
    _209 += _208;
    _200.data[_209] = f;
    _208++;
    if (_208 < _206)
    goto _jump3245;
    // End body of loop
    _195 = _200;
    _jump3239:;
    _174 = _195;
    _jump3235:;
    if (_168.d2 >= 0)
    goto _jump3246;
    fail_assertion("negative array index");
    _jump3246:;
    if (_168.d2 < _174.d0)
    goto _jump3247;
    fail_assertion("index too large");
    _jump3247:;
    int64_t _210 = 0;
    _210 *= _174.d0;
    _210 += _168.d2;
    _a2_int64_t _211 = _174.data[_210];
    int64_t _212;
    // Computing bound for E
    if (_168.d0 > 0) 
    goto _jump3248;
    fail_assertion("non-positive loop bound");
    _jump3248:;
    _212 = 0;
    int64_t _213 = 0; // E
    _jump3249:; // Begin body of loop
    int64_t _214 = 850;
    _212 += _214;
    _213++;
    if (_213 < _168.d0)
    goto _jump3249;
    // End body of loop
    if (_168.d1 >= 0)
    goto _jump3250;
    fail_assertion("negative array index");
    _jump3250:;
    if (_168.d1 < _211.d0)
    goto _jump3251;
    fail_assertion("index too large");
    _jump3251:;
    if (_212 >= 0)
    goto _jump3252;
    fail_assertion("negative array index");
    _jump3252:;
    if (_212 < _211.d1)
    goto _jump3253;
    fail_assertion("index too large");
    _jump3253:;
    int64_t _215 = 0;
    _215 *= _211.d0;
    _215 += _168.d1;
    _215 *= _211.d1;
    _215 += _212;
    int64_t _216 = _211.data[_215];
    double _217;
    // Computing bound for F
    int64_t _218 = -t.d1;
    if (_218 > 0) 
    goto _jump3254;
    fail_assertion("non-positive loop bound");
    _jump3254:;
    // Computing bound for G
    if (_168.d0 > 0) 
    goto _jump3255;
    fail_assertion("non-positive loop bound");
    _jump3255:;
    _217 = 0;
    int64_t _219 = 0; // G
    int64_t _220 = 0; // F
    _jump3256:; // Begin body of loop
    double _221 = 42.0;
    bool _222 = false;
    bool _223 = !_222;
    _a3_double _224;
    if (!_223)
    goto _jump3257;
    _224 = t;
    goto _jump3258;
    _jump3257:;
    _224 = t;
    _jump3258:;
    _a1_int64_t _225;
    _225.d0 = 3;
    _225.data = jpl_alloc(sizeof(int64_t) * 3);
    _225.data[0] = _168.d0;
    _225.data[1] = t.d2;
    _225.data[2] = t.d0;
    int64_t _226 = 773;
    int64_t _227 = -_226;
    if (_227 >= 0)
    goto _jump3259;
    fail_assertion("negative array index");
    _jump3259:;
    if (_227 < _225.d0)
    goto _jump3260;
    fail_assertion("index too large");
    _jump3260:;
    int64_t _228 = 0;
    _228 *= _225.d0;
    _228 += _227;
    int64_t _229 = _225.data[_228];
    if (c >= 0)
    goto _jump3261;
    fail_assertion("negative array index");
    _jump3261:;
    if (c < _224.d0)
    goto _jump3262;
    fail_assertion("index too large");
    _jump3262:;
    if (_229 >= 0)
    goto _jump3263;
    fail_assertion("negative array index");
    _jump3263:;
    if (_229 < _224.d1)
    goto _jump3264;
    fail_assertion("index too large");
    _jump3264:;
    if (t.d0 >= 0)
    goto _jump3265;
    fail_assertion("negative array index");
    _jump3265:;
    if (t.d0 < _224.d2)
    goto _jump3266;
    fail_assertion("index too large");
    _jump3266:;
    int64_t _230 = 0;
    _230 *= _224.d0;
    _230 += c;
    _230 *= _224.d1;
    _230 += _229;
    _230 *= _224.d2;
    _230 += t.d0;
    double _231 = _224.data[_230];
    double _232 = 73.0;
    double _233;
    if (!n)
    goto _jump3267;
    _233 = g;
    goto _jump3268;
    _jump3267:;
    double _234 = 5.0;
    _233 = _234;
    _jump3268:;
    bool _235 = _233 <= g;
    double _236;
    if (!_235)
    goto _jump3269;
    if (q >= 0)
    goto _jump3270;
    fail_assertion("negative array index");
    _jump3270:;
    if (q < t.d0)
    goto _jump3271;
    fail_assertion("index too large");
    _jump3271:;
    if (t.d0 >= 0)
    goto _jump3272;
    fail_assertion("negative array index");
    _jump3272:;
    if (t.d0 < t.d1)
    goto _jump3273;
    fail_assertion("index too large");
    _jump3273:;
    if (q >= 0)
    goto _jump3274;
    fail_assertion("negative array index");
    _jump3274:;
    if (q < t.d2)
    goto _jump3275;
    fail_assertion("index too large");
    _jump3275:;
    int64_t _237 = 0;
    _237 *= t.d0;
    _237 += q;
    _237 *= t.d1;
    _237 += t.d0;
    _237 *= t.d2;
    _237 += q;
    double _238 = t.data[_237];
    double _239 = -g;
    double _240 = fmod(_238, _239);
    _236 = _240;
    goto _jump3276;
    _jump3269:;
    double _241;
    // Computing bound for H
    if (d > 0) 
    goto _jump3277;
    fail_assertion("non-positive loop bound");
    _jump3277:;
    // Computing bound for I
    if (_168.d0 > 0) 
    goto _jump3278;
    fail_assertion("non-positive loop bound");
    _jump3278:;
    // Computing bound for J
    if (_168.d0 > 0) 
    goto _jump3279;
    fail_assertion("non-positive loop bound");
    _jump3279:;
    _241 = 0;
    int64_t _242 = 0; // J
    int64_t _243 = 0; // I
    int64_t _244 = 0; // H
    _jump3280:; // Begin body of loop
    _241 += g;
    _242++;
    if (_242 < _168.d0)
    goto _jump3280;
    _242 = 0;
    _243++;
    if (_243 < _168.d0)
    goto _jump3280;
    _243 = 0;
    _244++;
    if (_244 < d)
    goto _jump3280;
    // End body of loop
    double _245 = -_241;
    _236 = _245;
    _jump3276:;
    rgba _246 = { _221, _231, _232, _236 };
    double _247 = _246.b;
    _217 += _247;
    _219++;
    if (_219 < _168.d0)
    goto _jump3256;
    _219 = 0;
    _220++;
    if (_220 < _218)
    goto _jump3256;
    // End body of loop
    bool _248 = g <= _217;
    if (0 != _248)
    goto _jump3281;
    fail_assertion("F");
    _jump3281:;
    void_t _249 = {};
    return _249;
}

rgba t() {
    _a3__a3__a1_bool _0;
    // Computing bound for u
    bool _1 = i(d);
    int64_t _2;
    if (!_1)
    goto _jump3282;
    int64_t _3 = d % q;
    _2 = _3;
    goto _jump3283;
    _jump3282:;
    int64_t _4 = 501;
    _2 = _4;
    _jump3283:;
    _0.d0 = _2;
    if (_2 > 0) 
    goto _jump3284;
    fail_assertion("non-positive loop bound");
    _jump3284:;
    // Computing bound for v
    _0.d1 = c;
    if (c > 0) 
    goto _jump3285;
    fail_assertion("non-positive loop bound");
    _jump3285:;
    // Computing bound for w
    _0.d2 = c;
    if (c > 0) 
    goto _jump3286;
    fail_assertion("non-positive loop bound");
    _jump3286:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _2;
    _5 *= c;
    _5 *= c;
    _5 *= sizeof(_a3__a1_bool);
    _0.data = jpl_alloc(_5);
    int64_t _6 = 0; // w
    int64_t _7 = 0; // v
    int64_t _8 = 0; // u
    _jump3287:; // Begin body of loop
    _a3__a1_bool _9;
    // Computing bound for x
    int64_t _10 = 711;
    _9.d0 = _10;
    if (_10 > 0) 
    goto _jump3288;
    fail_assertion("non-positive loop bound");
    _jump3288:;
    // Computing bound for y
    _9.d1 = _6;
    if (_6 > 0) 
    goto _jump3289;
    fail_assertion("non-positive loop bound");
    _jump3289:;
    // Computing bound for z
    int64_t _11;
    // Computing bound for x
    if (d > 0) 
    goto _jump3290;
    fail_assertion("non-positive loop bound");
    _jump3290:;
    // Computing bound for y
    if (c > 0) 
    goto _jump3291;
    fail_assertion("non-positive loop bound");
    _jump3291:;
    _11 = 0;
    int64_t _12 = 0; // y
    int64_t _13 = 0; // x
    _jump3292:; // Begin body of loop
    _11 += _13;
    _12++;
    if (_12 < c)
    goto _jump3292;
    _12 = 0;
    _13++;
    if (_13 < d)
    goto _jump3292;
    // End body of loop
    _9.d2 = _11;
    if (_11 > 0) 
    goto _jump3293;
    fail_assertion("non-positive loop bound");
    _jump3293:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _10;
    _14 *= _6;
    _14 *= _11;
    _14 *= sizeof(_a1_bool);
    _9.data = jpl_alloc(_14);
    int64_t _15 = 0; // z
    int64_t _16 = 0; // y
    int64_t _17 = 0; // x
    _jump3294:; // Begin body of loop
    _a1_bool _18;
    // Computing bound for A
    int64_t _19 = 870;
    _18.d0 = _19;
    if (_19 > 0) 
    goto _jump3295;
    fail_assertion("non-positive loop bound");
    _jump3295:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _19;
    _20 *= sizeof(bool);
    _18.data = jpl_alloc(_20);
    int64_t _21 = 0; // A
    _jump3296:; // Begin body of loop
    bool _22 = true;
    int64_t _23 = 0;
    _23 *= _18.d0;
    _23 += _21;
    _18.data[_23] = _22;
    _21++;
    if (_21 < _19)
    goto _jump3296;
    // End body of loop
    int64_t _24 = 0;
    _24 *= _9.d0;
    _24 += _17;
    _24 *= _9.d1;
    _24 += _16;
    _24 *= _9.d2;
    _24 += _15;
    _9.data[_24] = _18;
    _15++;
    if (_15 < _11)
    goto _jump3294;
    _15 = 0;
    _16++;
    if (_16 < _6)
    goto _jump3294;
    _16 = 0;
    _17++;
    if (_17 < _10)
    goto _jump3294;
    // End body of loop
    int64_t _25 = 0;
    _25 *= _0.d0;
    _25 += _8;
    _25 *= _0.d1;
    _25 += _7;
    _25 *= _0.d2;
    _25 += _6;
    _0.data[_25] = _9;
    _6++;
    if (_6 < c)
    goto _jump3287;
    _6 = 0;
    _7++;
    if (_7 < c)
    goto _jump3287;
    _7 = 0;
    _8++;
    if (_8 < _2)
    goto _jump3287;
    // End body of loop
    int64_t _26;
    // Computing bound for u
    _a3_int64_t _27;
    // Computing bound for u
    _27.d0 = d;
    if (d > 0) 
    goto _jump3297;
    fail_assertion("non-positive loop bound");
    _jump3297:;
    // Computing bound for v
    _27.d1 = c;
    if (c > 0) 
    goto _jump3298;
    fail_assertion("non-positive loop bound");
    _jump3298:;
    // Computing bound for w
    _27.d2 = d;
    if (d > 0) 
    goto _jump3299;
    fail_assertion("non-positive loop bound");
    _jump3299:;
    // Computing total size of heap memory to allocate
    int64_t _28 = 1;
    _28 *= d;
    _28 *= c;
    _28 *= d;
    _28 *= sizeof(int64_t);
    _27.data = jpl_alloc(_28);
    int64_t _29 = 0; // w
    int64_t _30 = 0; // v
    int64_t _31 = 0; // u
    _jump3300:; // Begin body of loop
    int64_t _32 = 0;
    _32 *= _27.d0;
    _32 += _31;
    _32 *= _27.d1;
    _32 += _30;
    _32 *= _27.d2;
    _32 += _29;
    _27.data[_32] = q;
    _29++;
    if (_29 < d)
    goto _jump3300;
    _29 = 0;
    _30++;
    if (_30 < c)
    goto _jump3300;
    _30 = 0;
    _31++;
    if (_31 < d)
    goto _jump3300;
    // End body of loop
    int64_t _33;
    if (!n)
    goto _jump3301;
    _33 = d;
    goto _jump3302;
    _jump3301:;
    _33 = d;
    _jump3302:;
    int64_t _34 = q - d;
    if (_33 >= 0)
    goto _jump3303;
    fail_assertion("negative array index");
    _jump3303:;
    if (_33 < _27.d0)
    goto _jump3304;
    fail_assertion("index too large");
    _jump3304:;
    if (_34 >= 0)
    goto _jump3305;
    fail_assertion("negative array index");
    _jump3305:;
    if (_34 < _27.d1)
    goto _jump3306;
    fail_assertion("index too large");
    _jump3306:;
    if (c >= 0)
    goto _jump3307;
    fail_assertion("negative array index");
    _jump3307:;
    if (c < _27.d2)
    goto _jump3308;
    fail_assertion("index too large");
    _jump3308:;
    int64_t _35 = 0;
    _35 *= _27.d0;
    _35 += _33;
    _35 *= _27.d1;
    _35 += _34;
    _35 *= _27.d2;
    _35 += c;
    int64_t _36 = _27.data[_35];
    if (_36 > 0) 
    goto _jump3309;
    fail_assertion("non-positive loop bound");
    _jump3309:;
    _26 = 0;
    int64_t _37 = 0; // u
    _jump3310:; // Begin body of loop
    int64_t _38 = -_37;
    int64_t _39 = -_38;
    _26 += _39;
    _37++;
    if (_37 < _36)
    goto _jump3310;
    // End body of loop
    int64_t _40;
    // Computing bound for u
    int64_t _41 = -d;
    int64_t _42 = -_41;
    if (_42 > 0) 
    goto _jump3311;
    fail_assertion("non-positive loop bound");
    _jump3311:;
    // Computing bound for v
    int64_t _43 = d - q;
    int64_t _44 = 311;
    int64_t _45 = _43 % _44;
    if (_45 > 0) 
    goto _jump3312;
    fail_assertion("non-positive loop bound");
    _jump3312:;
    _40 = 0;
    int64_t _46 = 0; // v
    int64_t _47 = 0; // u
    _jump3313:; // Begin body of loop
    int64_t _48 = _47 - q;
    _40 += _48;
    _46++;
    if (_46 < _45)
    goto _jump3313;
    _46 = 0;
    _47++;
    if (_47 < _42)
    goto _jump3313;
    // End body of loop
    if (_26 >= 0)
    goto _jump3314;
    fail_assertion("negative array index");
    _jump3314:;
    if (_26 < _0.d0)
    goto _jump3315;
    fail_assertion("index too large");
    _jump3315:;
    if (_40 >= 0)
    goto _jump3316;
    fail_assertion("negative array index");
    _jump3316:;
    if (_40 < _0.d1)
    goto _jump3317;
    fail_assertion("index too large");
    _jump3317:;
    if (d >= 0)
    goto _jump3318;
    fail_assertion("negative array index");
    _jump3318:;
    if (d < _0.d2)
    goto _jump3319;
    fail_assertion("index too large");
    _jump3319:;
    int64_t _49 = 0;
    _49 *= _0.d0;
    _49 += _26;
    _49 *= _0.d1;
    _49 += _40;
    _49 *= _0.d2;
    _49 += d;
    _a3__a1_bool _50 = _0.data[_49];
    int64_t _51 = 877;
    int64_t _52 = _51 % q;
    if (q >= 0)
    goto _jump3320;
    fail_assertion("negative array index");
    _jump3320:;
    if (q < _50.d0)
    goto _jump3321;
    fail_assertion("index too large");
    _jump3321:;
    if (d >= 0)
    goto _jump3322;
    fail_assertion("negative array index");
    _jump3322:;
    if (d < _50.d1)
    goto _jump3323;
    fail_assertion("index too large");
    _jump3323:;
    if (_52 >= 0)
    goto _jump3324;
    fail_assertion("negative array index");
    _jump3324:;
    if (_52 < _50.d2)
    goto _jump3325;
    fail_assertion("index too large");
    _jump3325:;
    int64_t _53 = 0;
    _53 *= _50.d0;
    _53 += q;
    _53 *= _50.d1;
    _53 += d;
    _53 *= _50.d2;
    _53 += _52;
    _a1_bool _54 = _50.data[_53];
    _a3_int64_t _55;
    // Computing bound for u
    int64_t _56;
    // Computing bound for u
    int64_t _57;
    // Computing bound for u
    int64_t _58 = 533;
    if (_58 > 0) 
    goto _jump3326;
    fail_assertion("non-positive loop bound");
    _jump3326:;
    _57 = 0;
    int64_t _59 = 0; // u
    _jump3327:; // Begin body of loop
    _57 += _59;
    _59++;
    if (_59 < _58)
    goto _jump3327;
    // End body of loop
    int64_t _60 = _57 + d;
    if (_60 > 0) 
    goto _jump3328;
    fail_assertion("non-positive loop bound");
    _jump3328:;
    // Computing bound for v
    int64_t _61 = -d;
    if (_61 > 0) 
    goto _jump3329;
    fail_assertion("non-positive loop bound");
    _jump3329:;
    // Computing bound for w
    if (c > 0) 
    goto _jump3330;
    fail_assertion("non-positive loop bound");
    _jump3330:;
    _56 = 0;
    int64_t _62 = 0; // w
    int64_t _63 = 0; // v
    int64_t _64 = 0; // u
    _jump3331:; // Begin body of loop
    int64_t _65 = 2;
    _56 += _65;
    _62++;
    if (_62 < c)
    goto _jump3331;
    _62 = 0;
    _63++;
    if (_63 < _61)
    goto _jump3331;
    _63 = 0;
    _64++;
    if (_64 < _60)
    goto _jump3331;
    // End body of loop
    _55.d0 = _56;
    if (_56 > 0) 
    goto _jump3332;
    fail_assertion("non-positive loop bound");
    _jump3332:;
    // Computing bound for v
    int64_t _66;
    // Computing bound for u
    _a1_int64_t _67;
    // Computing bound for u
    _67.d0 = d;
    if (d > 0) 
    goto _jump3333;
    fail_assertion("non-positive loop bound");
    _jump3333:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= d;
    _68 *= sizeof(int64_t);
    _67.data = jpl_alloc(_68);
    int64_t _69 = 0; // u
    _jump3334:; // Begin body of loop
    int64_t _70 = 265;
    int64_t _71 = 0;
    _71 *= _67.d0;
    _71 += _69;
    _67.data[_71] = _70;
    _69++;
    if (_69 < d)
    goto _jump3334;
    // End body of loop
    int64_t _72 = 523;
    int64_t _73 = _72 + c;
    if (_73 >= 0)
    goto _jump3335;
    fail_assertion("negative array index");
    _jump3335:;
    if (_73 < _67.d0)
    goto _jump3336;
    fail_assertion("index too large");
    _jump3336:;
    int64_t _74 = 0;
    _74 *= _67.d0;
    _74 += _73;
    int64_t _75 = _67.data[_74];
    if (_75 > 0) 
    goto _jump3337;
    fail_assertion("non-positive loop bound");
    _jump3337:;
    _66 = 0;
    int64_t _76 = 0; // u
    _jump3338:; // Begin body of loop
    _66 += _76;
    _76++;
    if (_76 < _75)
    goto _jump3338;
    // End body of loop
    _55.d1 = _66;
    if (_66 > 0) 
    goto _jump3339;
    fail_assertion("non-positive loop bound");
    _jump3339:;
    // Computing bound for w
    _55.d2 = c;
    if (c > 0) 
    goto _jump3340;
    fail_assertion("non-positive loop bound");
    _jump3340:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _56;
    _77 *= _66;
    _77 *= c;
    _77 *= sizeof(int64_t);
    _55.data = jpl_alloc(_77);
    int64_t _78 = 0; // w
    int64_t _79 = 0; // v
    int64_t _80 = 0; // u
    _jump3341:; // Begin body of loop
    int64_t _81 = 0;
    _81 *= _55.d0;
    _81 += _80;
    _81 *= _55.d1;
    _81 += _79;
    _81 *= _55.d2;
    _81 += _78;
    _55.data[_81] = _78;
    _78++;
    if (_78 < c)
    goto _jump3341;
    _78 = 0;
    _79++;
    if (_79 < _66)
    goto _jump3341;
    _79 = 0;
    _80++;
    if (_80 < _56)
    goto _jump3341;
    // End body of loop
    bool _82 = true;
    int64_t _83;
    if (!_82)
    goto _jump3342;
    _83 = d;
    goto _jump3343;
    _jump3342:;
    int64_t _84;
    // Computing bound for u
    int64_t _85;
    // Computing bound for u
    int64_t _86 = -c;
    if (_86 > 0) 
    goto _jump3344;
    fail_assertion("non-positive loop bound");
    _jump3344:;
    // Computing bound for v
    int64_t _87 = 996;
    int64_t _88 = -_87;
    if (_88 > 0) 
    goto _jump3345;
    fail_assertion("non-positive loop bound");
    _jump3345:;
    _85 = 0;
    int64_t _89 = 0; // v
    int64_t _90 = 0; // u
    _jump3346:; // Begin body of loop
    int64_t _91 = 603;
    _85 += _91;
    _89++;
    if (_89 < _88)
    goto _jump3346;
    _89 = 0;
    _90++;
    if (_90 < _86)
    goto _jump3346;
    // End body of loop
    if (_85 > 0) 
    goto _jump3347;
    fail_assertion("non-positive loop bound");
    _jump3347:;
    // Computing bound for v
    int64_t _92 = d % q;
    int64_t _93 = -_92;
    if (_93 > 0) 
    goto _jump3348;
    fail_assertion("non-positive loop bound");
    _jump3348:;
    _84 = 0;
    int64_t _94 = 0; // v
    int64_t _95 = 0; // u
    _jump3349:; // Begin body of loop
    _84 += c;
    _94++;
    if (_94 < _93)
    goto _jump3349;
    _94 = 0;
    _95++;
    if (_95 < _85)
    goto _jump3349;
    // End body of loop
    _83 = _84;
    _jump3343:;
    int64_t _96 = -q;
    int64_t _97 = 926;
    int64_t _98 = -c;
    int64_t _99 = _97 % _98;
    int64_t _100 = -_99;
    bool _101 = g > g;
    _a2_int64_t _102;
    if (!_101)
    goto _jump3350;
    _102 = f;
    goto _jump3351;
    _jump3350:;
    _102 = f;
    _jump3351:;
    _a1_int64_t _103;
    // Computing bound for u
    int64_t _104 = 695;
    _103.d0 = _104;
    if (_104 > 0) 
    goto _jump3352;
    fail_assertion("non-positive loop bound");
    _jump3352:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _104;
    _105 *= sizeof(int64_t);
    _103.data = jpl_alloc(_105);
    int64_t _106 = 0; // u
    _jump3353:; // Begin body of loop
    int64_t _107 = 0;
    _107 *= _103.d0;
    _107 += _106;
    _103.data[_107] = q;
    _106++;
    if (_106 < _104)
    goto _jump3353;
    // End body of loop
    int64_t _108;
    // Computing bound for u
    if (c > 0) 
    goto _jump3354;
    fail_assertion("non-positive loop bound");
    _jump3354:;
    // Computing bound for v
    if (d > 0) 
    goto _jump3355;
    fail_assertion("non-positive loop bound");
    _jump3355:;
    // Computing bound for w
    if (q > 0) 
    goto _jump3356;
    fail_assertion("non-positive loop bound");
    _jump3356:;
    _108 = 0;
    int64_t _109 = 0; // w
    int64_t _110 = 0; // v
    int64_t _111 = 0; // u
    _jump3357:; // Begin body of loop
    _108 += _110;
    _109++;
    if (_109 < q)
    goto _jump3357;
    _109 = 0;
    _110++;
    if (_110 < d)
    goto _jump3357;
    _110 = 0;
    _111++;
    if (_111 < c)
    goto _jump3357;
    // End body of loop
    if (_108 >= 0)
    goto _jump3358;
    fail_assertion("negative array index");
    _jump3358:;
    if (_108 < _103.d0)
    goto _jump3359;
    fail_assertion("index too large");
    _jump3359:;
    int64_t _112 = 0;
    _112 *= _103.d0;
    _112 += _108;
    int64_t _113 = _103.data[_112];
    if (_113 >= 0)
    goto _jump3360;
    fail_assertion("negative array index");
    _jump3360:;
    if (_113 < _102.d0)
    goto _jump3361;
    fail_assertion("index too large");
    _jump3361:;
    if (q >= 0)
    goto _jump3362;
    fail_assertion("negative array index");
    _jump3362:;
    if (q < _102.d1)
    goto _jump3363;
    fail_assertion("index too large");
    _jump3363:;
    int64_t _114 = 0;
    _114 *= _102.d0;
    _114 += _113;
    _114 *= _102.d1;
    _114 += q;
    int64_t _115 = _102.data[_114];
    int64_t _116 = _100 - _115;
    if (_83 >= 0)
    goto _jump3364;
    fail_assertion("negative array index");
    _jump3364:;
    if (_83 < _55.d0)
    goto _jump3365;
    fail_assertion("index too large");
    _jump3365:;
    if (_96 >= 0)
    goto _jump3366;
    fail_assertion("negative array index");
    _jump3366:;
    if (_96 < _55.d1)
    goto _jump3367;
    fail_assertion("index too large");
    _jump3367:;
    if (_116 >= 0)
    goto _jump3368;
    fail_assertion("negative array index");
    _jump3368:;
    if (_116 < _55.d2)
    goto _jump3369;
    fail_assertion("index too large");
    _jump3369:;
    int64_t _117 = 0;
    _117 *= _55.d0;
    _117 += _83;
    _117 *= _55.d1;
    _117 += _96;
    _117 *= _55.d2;
    _117 += _116;
    int64_t _118 = _55.data[_117];
    if (_118 >= 0)
    goto _jump3370;
    fail_assertion("negative array index");
    _jump3370:;
    if (_118 < _54.d0)
    goto _jump3371;
    fail_assertion("index too large");
    _jump3371:;
    int64_t _119 = 0;
    _119 *= _54.d0;
    _119 += _118;
    bool _120 = _54.data[_119];
    _a3_bool _121;
    // Computing bound for u
    _121.d0 = c;
    if (c > 0) 
    goto _jump3372;
    fail_assertion("non-positive loop bound");
    _jump3372:;
    // Computing bound for v
    o _122 = r();
    bool _123 = _122.c;
    int64_t _124;
    if (!_123)
    goto _jump3373;
    _a3_int64_t _125;
    // Computing bound for u
    double _126 = 65.0;
    bool _127 = _126 != g;
    int64_t _128;
    if (!_127)
    goto _jump3374;
    _128 = d;
    goto _jump3375;
    _jump3374:;
    _128 = d;
    _jump3375:;
    _125.d0 = _128;
    if (_128 > 0) 
    goto _jump3376;
    fail_assertion("non-positive loop bound");
    _jump3376:;
    // Computing bound for v
    int64_t _129;
    // Computing bound for u
    int64_t _130 = -d;
    if (_130 > 0) 
    goto _jump3377;
    fail_assertion("non-positive loop bound");
    _jump3377:;
    _129 = 0;
    int64_t _131 = 0; // u
    _jump3378:; // Begin body of loop
    int64_t _132;
    // Computing bound for v
    if (_131 > 0) 
    goto _jump3379;
    fail_assertion("non-positive loop bound");
    _jump3379:;
    // Computing bound for w
    if (d > 0) 
    goto _jump3380;
    fail_assertion("non-positive loop bound");
    _jump3380:;
    _132 = 0;
    int64_t _133 = 0; // w
    int64_t _134 = 0; // v
    _jump3381:; // Begin body of loop
    _132 += _133;
    _133++;
    if (_133 < d)
    goto _jump3381;
    _133 = 0;
    _134++;
    if (_134 < _131)
    goto _jump3381;
    // End body of loop
    _129 += _132;
    _131++;
    if (_131 < _130)
    goto _jump3378;
    // End body of loop
    _125.d1 = _129;
    if (_129 > 0) 
    goto _jump3382;
    fail_assertion("non-positive loop bound");
    _jump3382:;
    // Computing bound for w
    int64_t _135 = 47;
    _125.d2 = _135;
    if (_135 > 0) 
    goto _jump3383;
    fail_assertion("non-positive loop bound");
    _jump3383:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _128;
    _136 *= _129;
    _136 *= _135;
    _136 *= sizeof(int64_t);
    _125.data = jpl_alloc(_136);
    int64_t _137 = 0; // w
    int64_t _138 = 0; // v
    int64_t _139 = 0; // u
    _jump3384:; // Begin body of loop
    int64_t _140 = 834;
    int64_t _141 = _138 % _140;
    int64_t _142 = 0;
    _142 *= _125.d0;
    _142 += _139;
    _142 *= _125.d1;
    _142 += _138;
    _142 *= _125.d2;
    _142 += _137;
    _125.data[_142] = _141;
    _137++;
    if (_137 < _135)
    goto _jump3384;
    _137 = 0;
    _138++;
    if (_138 < _129)
    goto _jump3384;
    _138 = 0;
    _139++;
    if (_139 < _128)
    goto _jump3384;
    // End body of loop
    int64_t _143 = 139;
    int64_t _144 = 654;
    int64_t _145 = -c;
    int64_t _146 = -_145;
    int64_t _147 = 401;
    int64_t _148 = _146 - _147;
    if (_143 >= 0)
    goto _jump3385;
    fail_assertion("negative array index");
    _jump3385:;
    if (_143 < _125.d0)
    goto _jump3386;
    fail_assertion("index too large");
    _jump3386:;
    if (_144 >= 0)
    goto _jump3387;
    fail_assertion("negative array index");
    _jump3387:;
    if (_144 < _125.d1)
    goto _jump3388;
    fail_assertion("index too large");
    _jump3388:;
    if (_148 >= 0)
    goto _jump3389;
    fail_assertion("negative array index");
    _jump3389:;
    if (_148 < _125.d2)
    goto _jump3390;
    fail_assertion("index too large");
    _jump3390:;
    int64_t _149 = 0;
    _149 *= _125.d0;
    _149 += _143;
    _149 *= _125.d1;
    _149 += _144;
    _149 *= _125.d2;
    _149 += _148;
    int64_t _150 = _125.data[_149];
    _124 = _150;
    goto _jump3391;
    _jump3373:;
    _124 = q;
    _jump3391:;
    _121.d1 = _124;
    if (_124 > 0) 
    goto _jump3392;
    fail_assertion("non-positive loop bound");
    _jump3392:;
    // Computing bound for w
    int64_t _151 = 813;
    if (_151 >= 0)
    goto _jump3393;
    fail_assertion("negative array index");
    _jump3393:;
    if (_151 < p.d0)
    goto _jump3394;
    fail_assertion("index too large");
    _jump3394:;
    int64_t _152 = 0;
    _152 *= p.d0;
    _152 += _151;
    o _153 = p.data[_152];
    l _154 = _153.a;
    bool _155 = _154.a;
    int64_t _156;
    if (!_155)
    goto _jump3395;
    _156 = c;
    goto _jump3396;
    _jump3395:;
    int64_t _157 = -d;
    bool _158 = false;
    int64_t _159;
    if (!_158)
    goto _jump3397;
    _159 = q;
    goto _jump3398;
    _jump3397:;
    _159 = c;
    _jump3398:;
    _a1_int64_t _160;
    _160.d0 = 3;
    _160.data = jpl_alloc(sizeof(int64_t) * 3);
    _160.data[0] = _157;
    _160.data[1] = _159;
    _160.data[2] = q;
    int64_t _161;
    // Computing bound for u
    int64_t _162 = c - q;
    if (_162 > 0) 
    goto _jump3399;
    fail_assertion("non-positive loop bound");
    _jump3399:;
    // Computing bound for v
    if (c > 0) 
    goto _jump3400;
    fail_assertion("non-positive loop bound");
    _jump3400:;
    // Computing bound for w
    int64_t _163 = 651;
    int64_t _164 = -_163;
    if (_164 > 0) 
    goto _jump3401;
    fail_assertion("non-positive loop bound");
    _jump3401:;
    _161 = 0;
    int64_t _165 = 0; // w
    int64_t _166 = 0; // v
    int64_t _167 = 0; // u
    _jump3402:; // Begin body of loop
    _161 += _165;
    _165++;
    if (_165 < _164)
    goto _jump3402;
    _165 = 0;
    _166++;
    if (_166 < c)
    goto _jump3402;
    _166 = 0;
    _167++;
    if (_167 < _162)
    goto _jump3402;
    // End body of loop
    if (_161 >= 0)
    goto _jump3403;
    fail_assertion("negative array index");
    _jump3403:;
    if (_161 < _160.d0)
    goto _jump3404;
    fail_assertion("index too large");
    _jump3404:;
    int64_t _168 = 0;
    _168 *= _160.d0;
    _168 += _161;
    int64_t _169 = _160.data[_168];
    _156 = _169;
    _jump3396:;
    int64_t _170 = -_156;
    _121.d2 = _170;
    if (_170 > 0) 
    goto _jump3405;
    fail_assertion("non-positive loop bound");
    _jump3405:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= c;
    _171 *= _124;
    _171 *= _170;
    _171 *= sizeof(bool);
    _121.data = jpl_alloc(_171);
    int64_t _172 = 0; // w
    int64_t _173 = 0; // v
    int64_t _174 = 0; // u
    _jump3406:; // Begin body of loop
    double _175;
    // Computing bound for x
    int64_t _176;
    // Computing bound for x
    int64_t _177;
    // Computing bound for x
    int64_t _178 = 79;
    if (_178 > 0) 
    goto _jump3407;
    fail_assertion("non-positive loop bound");
    _jump3407:;
    _177 = 0;
    int64_t _179 = 0; // x
    _jump3408:; // Begin body of loop
    int64_t _180 = 641;
    int64_t _181 = _180 * d;
    _177 += _181;
    _179++;
    if (_179 < _178)
    goto _jump3408;
    // End body of loop
    if (_177 > 0) 
    goto _jump3409;
    fail_assertion("non-positive loop bound");
    _jump3409:;
    _176 = 0;
    int64_t _182 = 0; // x
    _jump3410:; // Begin body of loop
    int64_t _183;
    // Computing bound for y
    if (c > 0) 
    goto _jump3411;
    fail_assertion("non-positive loop bound");
    _jump3411:;
    // Computing bound for z
    if (d > 0) 
    goto _jump3412;
    fail_assertion("non-positive loop bound");
    _jump3412:;
    // Computing bound for A
    if (d > 0) 
    goto _jump3413;
    fail_assertion("non-positive loop bound");
    _jump3413:;
    _183 = 0;
    int64_t _184 = 0; // A
    int64_t _185 = 0; // z
    int64_t _186 = 0; // y
    _jump3414:; // Begin body of loop
    _183 += _185;
    _184++;
    if (_184 < d)
    goto _jump3414;
    _184 = 0;
    _185++;
    if (_185 < d)
    goto _jump3414;
    _185 = 0;
    _186++;
    if (_186 < c)
    goto _jump3414;
    // End body of loop
    _176 += _183;
    _182++;
    if (_182 < _177)
    goto _jump3410;
    // End body of loop
    if (_176 > 0) 
    goto _jump3415;
    fail_assertion("non-positive loop bound");
    _jump3415:;
    // Computing bound for y
    if (d > 0) 
    goto _jump3416;
    fail_assertion("non-positive loop bound");
    _jump3416:;
    // Computing bound for z
    bool _187 = true;
    int64_t _188;
    if (!_187)
    goto _jump3417;
    _188 = _174;
    goto _jump3418;
    _jump3417:;
    _188 = _172;
    _jump3418:;
    if (_188 > 0) 
    goto _jump3419;
    fail_assertion("non-positive loop bound");
    _jump3419:;
    _175 = 0;
    int64_t _189 = 0; // z
    int64_t _190 = 0; // y
    int64_t _191 = 0; // x
    _jump3420:; // Begin body of loop
    double _192;
    // Computing bound for A
    if (c > 0) 
    goto _jump3421;
    fail_assertion("non-positive loop bound");
    _jump3421:;
    // Computing bound for B
    int64_t _193 = -_173;
    int64_t _194 = _172 * _193;
    if (_194 > 0) 
    goto _jump3422;
    fail_assertion("non-positive loop bound");
    _jump3422:;
    _192 = 0;
    int64_t _195 = 0; // B
    int64_t _196 = 0; // A
    _jump3423:; // Begin body of loop
    double _197 = -g;
    _192 += _197;
    _195++;
    if (_195 < _194)
    goto _jump3423;
    _195 = 0;
    _196++;
    if (_196 < c)
    goto _jump3423;
    // End body of loop
    _175 += _192;
    _189++;
    if (_189 < _188)
    goto _jump3420;
    _189 = 0;
    _190++;
    if (_190 < d)
    goto _jump3420;
    _190 = 0;
    _191++;
    if (_191 < _176)
    goto _jump3420;
    // End body of loop
    double _198;
    // Computing bound for x
    int64_t _199;
    // Computing bound for x
    int64_t _200 = 54;
    if (_200 > 0) 
    goto _jump3424;
    fail_assertion("non-positive loop bound");
    _jump3424:;
    _199 = 0;
    int64_t _201 = 0; // x
    _jump3425:; // Begin body of loop
    int64_t _202;
    // Computing bound for y
    if (d > 0) 
    goto _jump3426;
    fail_assertion("non-positive loop bound");
    _jump3426:;
    // Computing bound for z
    int64_t _203 = 20;
    if (_203 > 0) 
    goto _jump3427;
    fail_assertion("non-positive loop bound");
    _jump3427:;
    // Computing bound for A
    int64_t _204;
    // Computing bound for y
    if (_172 > 0) 
    goto _jump3428;
    fail_assertion("non-positive loop bound");
    _jump3428:;
    // Computing bound for z
    if (c > 0) 
    goto _jump3429;
    fail_assertion("non-positive loop bound");
    _jump3429:;
    _204 = 0;
    int64_t _205 = 0; // z
    int64_t _206 = 0; // y
    _jump3430:; // Begin body of loop
    _204 += _206;
    _205++;
    if (_205 < c)
    goto _jump3430;
    _205 = 0;
    _206++;
    if (_206 < _172)
    goto _jump3430;
    // End body of loop
    if (_204 > 0) 
    goto _jump3431;
    fail_assertion("non-positive loop bound");
    _jump3431:;
    _202 = 0;
    int64_t _207 = 0; // A
    int64_t _208 = 0; // z
    int64_t _209 = 0; // y
    _jump3432:; // Begin body of loop
    _202 += _174;
    _207++;
    if (_207 < _204)
    goto _jump3432;
    _207 = 0;
    _208++;
    if (_208 < _203)
    goto _jump3432;
    _208 = 0;
    _209++;
    if (_209 < d)
    goto _jump3432;
    // End body of loop
    _199 += _202;
    _201++;
    if (_201 < _200)
    goto _jump3425;
    // End body of loop
    if (_199 > 0) 
    goto _jump3433;
    fail_assertion("non-positive loop bound");
    _jump3433:;
    _198 = 0;
    int64_t _210 = 0; // x
    _jump3434:; // Begin body of loop
    _198 += g;
    _210++;
    if (_210 < _199)
    goto _jump3434;
    // End body of loop
    bool _211 = _175 == _198;
    int64_t _212 = 0;
    _212 *= _121.d0;
    _212 += _174;
    _212 *= _121.d1;
    _212 += _173;
    _212 *= _121.d2;
    _212 += _172;
    _121.data[_212] = _211;
    _172++;
    if (_172 < _170)
    goto _jump3406;
    _172 = 0;
    _173++;
    if (_173 < _124)
    goto _jump3406;
    _173 = 0;
    _174++;
    if (_174 < c)
    goto _jump3406;
    // End body of loop
    _a1__a2_l _213;
    // Computing bound for u
    _213.d0 = q;
    if (q > 0) 
    goto _jump3435;
    fail_assertion("non-positive loop bound");
    _jump3435:;
    // Computing total size of heap memory to allocate
    int64_t _214 = 1;
    _214 *= q;
    _214 *= sizeof(_a2_l);
    _213.data = jpl_alloc(_214);
    int64_t _215 = 0; // u
    _jump3436:; // Begin body of loop
    _a2_l _216;
    // Computing bound for v
    int64_t _217 = 415;
    int64_t _218 = _215 * _217;
    _216.d0 = _218;
    if (_218 > 0) 
    goto _jump3437;
    fail_assertion("non-positive loop bound");
    _jump3437:;
    // Computing bound for w
    int64_t _219 = 323;
    _216.d1 = _219;
    if (_219 > 0) 
    goto _jump3438;
    fail_assertion("non-positive loop bound");
    _jump3438:;
    // Computing total size of heap memory to allocate
    int64_t _220 = 1;
    _220 *= _218;
    _220 *= _219;
    _220 *= sizeof(l);
    _216.data = jpl_alloc(_220);
    int64_t _221 = 0; // w
    int64_t _222 = 0; // v
    _jump3439:; // Begin body of loop
    o _223 = r();
    l _224 = _223.a;
    int64_t _225 = 0;
    _225 *= _216.d0;
    _225 += _222;
    _225 *= _216.d1;
    _225 += _221;
    _216.data[_225] = _224;
    _221++;
    if (_221 < _219)
    goto _jump3439;
    _221 = 0;
    _222++;
    if (_222 < _218)
    goto _jump3439;
    // End body of loop
    int64_t _226 = 0;
    _226 *= _213.d0;
    _226 += _215;
    _213.data[_226] = _216;
    _215++;
    if (_215 < q)
    goto _jump3436;
    // End body of loop
    int64_t _227;
    // Computing bound for u
    int64_t _228 = -q;
    if (_228 > 0) 
    goto _jump3440;
    fail_assertion("non-positive loop bound");
    _jump3440:;
    _227 = 0;
    int64_t _229 = 0; // u
    _jump3441:; // Begin body of loop
    int64_t _230 = 304;
    _227 += _230;
    _229++;
    if (_229 < _228)
    goto _jump3441;
    // End body of loop
    if (_227 >= 0)
    goto _jump3442;
    fail_assertion("negative array index");
    _jump3442:;
    if (_227 < _213.d0)
    goto _jump3443;
    fail_assertion("index too large");
    _jump3443:;
    int64_t _231 = 0;
    _231 *= _213.d0;
    _231 += _227;
    _a2_l _232 = _213.data[_231];
    int64_t _233 = -c;
    int64_t _234 = -_233;
    if (_234 >= 0)
    goto _jump3444;
    fail_assertion("negative array index");
    _jump3444:;
    if (_234 < _232.d0)
    goto _jump3445;
    fail_assertion("index too large");
    _jump3445:;
    if (q >= 0)
    goto _jump3446;
    fail_assertion("negative array index");
    _jump3446:;
    if (q < _232.d1)
    goto _jump3447;
    fail_assertion("index too large");
    _jump3447:;
    int64_t _235 = 0;
    _235 *= _232.d0;
    _235 += _234;
    _235 *= _232.d1;
    _235 += q;
    l _236 = _232.data[_235];
    rgba _237 = _236.c;
    l _238 = { _120, _121, _237 };
    _a3_double _239;
    if (!n)
    goto _jump3448;
    _a3_double _240;
    // Computing bound for v
    int64_t _241 = 559;
    _240.d0 = _241;
    if (_241 > 0) 
    goto _jump3449;
    fail_assertion("non-positive loop bound");
    _jump3449:;
    // Computing bound for w
    _240.d1 = c;
    if (c > 0) 
    goto _jump3450;
    fail_assertion("non-positive loop bound");
    _jump3450:;
    // Computing bound for x
    _240.d2 = q;
    if (q > 0) 
    goto _jump3451;
    fail_assertion("non-positive loop bound");
    _jump3451:;
    // Computing total size of heap memory to allocate
    int64_t _242 = 1;
    _242 *= _241;
    _242 *= c;
    _242 *= q;
    _242 *= sizeof(double);
    _240.data = jpl_alloc(_242);
    int64_t _243 = 0; // x
    int64_t _244 = 0; // w
    int64_t _245 = 0; // v
    _jump3452:; // Begin body of loop
    double _246 = 87.0;
    double _247 = 73.0;
    _a1_double _248;
    _248.d0 = 2;
    _248.data = jpl_alloc(sizeof(double) * 2);
    _248.data[0] = _246;
    _248.data[1] = _247;
    if (_245 >= 0)
    goto _jump3453;
    fail_assertion("negative array index");
    _jump3453:;
    if (_245 < _248.d0)
    goto _jump3454;
    fail_assertion("index too large");
    _jump3454:;
    int64_t _249 = 0;
    _249 *= _248.d0;
    _249 += _245;
    double _250 = _248.data[_249];
    int64_t _251 = 0;
    _251 *= _240.d0;
    _251 += _245;
    _251 *= _240.d1;
    _251 += _244;
    _251 *= _240.d2;
    _251 += _243;
    _240.data[_251] = _250;
    _243++;
    if (_243 < q)
    goto _jump3452;
    _243 = 0;
    _244++;
    if (_244 < c)
    goto _jump3452;
    _244 = 0;
    _245++;
    if (_245 < _241)
    goto _jump3452;
    // End body of loop
    _239 = _240;
    goto _jump3455;
    _jump3448:;
    _a3_double _252;
    // Computing bound for v
    _252.d0 = c;
    if (c > 0) 
    goto _jump3456;
    fail_assertion("non-positive loop bound");
    _jump3456:;
    // Computing bound for w
    int64_t _253 = 603;
    _252.d1 = _253;
    if (_253 > 0) 
    goto _jump3457;
    fail_assertion("non-positive loop bound");
    _jump3457:;
    // Computing bound for x
    bool _254 = false;
    int64_t _255;
    if (!_254)
    goto _jump3458;
    _255 = c;
    goto _jump3459;
    _jump3458:;
    _255 = d;
    _jump3459:;
    _252.d2 = _255;
    if (_255 > 0) 
    goto _jump3460;
    fail_assertion("non-positive loop bound");
    _jump3460:;
    // Computing total size of heap memory to allocate
    int64_t _256 = 1;
    _256 *= c;
    _256 *= _253;
    _256 *= _255;
    _256 *= sizeof(double);
    _252.data = jpl_alloc(_256);
    int64_t _257 = 0; // x
    int64_t _258 = 0; // w
    int64_t _259 = 0; // v
    _jump3461:; // Begin body of loop
    double _260;
    // Computing bound for y
    if (_257 > 0) 
    goto _jump3462;
    fail_assertion("non-positive loop bound");
    _jump3462:;
    // Computing bound for z
    if (c > 0) 
    goto _jump3463;
    fail_assertion("non-positive loop bound");
    _jump3463:;
    // Computing bound for A
    if (c > 0) 
    goto _jump3464;
    fail_assertion("non-positive loop bound");
    _jump3464:;
    _260 = 0;
    int64_t _261 = 0; // A
    int64_t _262 = 0; // z
    int64_t _263 = 0; // y
    _jump3465:; // Begin body of loop
    _260 += g;
    _261++;
    if (_261 < c)
    goto _jump3465;
    _261 = 0;
    _262++;
    if (_262 < c)
    goto _jump3465;
    _262 = 0;
    _263++;
    if (_263 < _257)
    goto _jump3465;
    // End body of loop
    double _264 = -_260;
    int64_t _265 = 0;
    _265 *= _252.d0;
    _265 += _259;
    _265 *= _252.d1;
    _265 += _258;
    _265 *= _252.d2;
    _265 += _257;
    _252.data[_265] = _264;
    _257++;
    if (_257 < _255)
    goto _jump3461;
    _257 = 0;
    _258++;
    if (_258 < _253)
    goto _jump3461;
    _258 = 0;
    _259++;
    if (_259 < c)
    goto _jump3461;
    // End body of loop
    _239 = _252;
    _jump3455:;
    rgba _266 = m();
    double _267 = _266.a;
    o _268 = r();
    rgba _269 = _268.b;
    double _270 = _269.b;
    double _271;
    // Computing bound for v
    if (q > 0) 
    goto _jump3466;
    fail_assertion("non-positive loop bound");
    _jump3466:;
    // Computing bound for w
    int64_t _272 = 306;
    if (_272 > 0) 
    goto _jump3467;
    fail_assertion("non-positive loop bound");
    _jump3467:;
    // Computing bound for x
    if (q > 0) 
    goto _jump3468;
    fail_assertion("non-positive loop bound");
    _jump3468:;
    _271 = 0;
    int64_t _273 = 0; // x
    int64_t _274 = 0; // w
    int64_t _275 = 0; // v
    _jump3469:; // Begin body of loop
    rgba _276 = k();
    double _277 = _276.r;
    double _278 = fmod(g, _277);
    _271 += _278;
    _273++;
    if (_273 < q)
    goto _jump3469;
    _273 = 0;
    _274++;
    if (_274 < _272)
    goto _jump3469;
    _274 = 0;
    _275++;
    if (_275 < q)
    goto _jump3469;
    // End body of loop
    double _279;
    // Computing bound for v
    int64_t _280 = -q;
    if (_280 > 0) 
    goto _jump3470;
    fail_assertion("non-positive loop bound");
    _jump3470:;
    // Computing bound for w
    if (q > 0) 
    goto _jump3471;
    fail_assertion("non-positive loop bound");
    _jump3471:;
    _279 = 0;
    int64_t _281 = 0; // w
    int64_t _282 = 0; // v
    _jump3472:; // Begin body of loop
    double _283 = -g;
    _279 += _283;
    _281++;
    if (_281 < q)
    goto _jump3472;
    _281 = 0;
    _282++;
    if (_282 < _280)
    goto _jump3472;
    // End body of loop
    double _284 = -_279;
    rgba _285 = { _267, _270, _271, _284 };
    void_t _286 = s(_239, _285);
    _a3__a3_double _287;
    // Computing bound for v
    int64_t _288 = -d;
    _287.d0 = _288;
    if (_288 > 0) 
    goto _jump3473;
    fail_assertion("non-positive loop bound");
    _jump3473:;
    // Computing bound for w
    _287.d1 = c;
    if (c > 0) 
    goto _jump3474;
    fail_assertion("non-positive loop bound");
    _jump3474:;
    // Computing bound for x
    _287.d2 = d;
    if (d > 0) 
    goto _jump3475;
    fail_assertion("non-positive loop bound");
    _jump3475:;
    // Computing total size of heap memory to allocate
    int64_t _289 = 1;
    _289 *= _288;
    _289 *= c;
    _289 *= d;
    _289 *= sizeof(_a3_double);
    _287.data = jpl_alloc(_289);
    int64_t _290 = 0; // x
    int64_t _291 = 0; // w
    int64_t _292 = 0; // v
    _jump3476:; // Begin body of loop
    _a3_double _293;
    // Computing bound for y
    _293.d0 = _292;
    if (_292 > 0) 
    goto _jump3477;
    fail_assertion("non-positive loop bound");
    _jump3477:;
    // Computing bound for z
    _293.d1 = c;
    if (c > 0) 
    goto _jump3478;
    fail_assertion("non-positive loop bound");
    _jump3478:;
    // Computing bound for A
    _293.d2 = _291;
    if (_291 > 0) 
    goto _jump3479;
    fail_assertion("non-positive loop bound");
    _jump3479:;
    // Computing total size of heap memory to allocate
    int64_t _294 = 1;
    _294 *= _292;
    _294 *= c;
    _294 *= _291;
    _294 *= sizeof(double);
    _293.data = jpl_alloc(_294);
    int64_t _295 = 0; // A
    int64_t _296 = 0; // z
    int64_t _297 = 0; // y
    _jump3480:; // Begin body of loop
    double _298 = 32.0;
    int64_t _299 = 0;
    _299 *= _293.d0;
    _299 += _297;
    _299 *= _293.d1;
    _299 += _296;
    _299 *= _293.d2;
    _299 += _295;
    _293.data[_299] = _298;
    _295++;
    if (_295 < _291)
    goto _jump3480;
    _295 = 0;
    _296++;
    if (_296 < c)
    goto _jump3480;
    _296 = 0;
    _297++;
    if (_297 < _292)
    goto _jump3480;
    // End body of loop
    int64_t _300 = 0;
    _300 *= _287.d0;
    _300 += _292;
    _300 *= _287.d1;
    _300 += _291;
    _300 *= _287.d2;
    _300 += _290;
    _287.data[_300] = _293;
    _290++;
    if (_290 < d)
    goto _jump3476;
    _290 = 0;
    _291++;
    if (_291 < c)
    goto _jump3476;
    _291 = 0;
    _292++;
    if (_292 < _288)
    goto _jump3476;
    // End body of loop
    int64_t _301 = 402;
    if (d >= 0)
    goto _jump3481;
    fail_assertion("negative array index");
    _jump3481:;
    if (d < _287.d0)
    goto _jump3482;
    fail_assertion("index too large");
    _jump3482:;
    if (c >= 0)
    goto _jump3483;
    fail_assertion("negative array index");
    _jump3483:;
    if (c < _287.d1)
    goto _jump3484;
    fail_assertion("index too large");
    _jump3484:;
    if (_301 >= 0)
    goto _jump3485;
    fail_assertion("negative array index");
    _jump3485:;
    if (_301 < _287.d2)
    goto _jump3486;
    fail_assertion("index too large");
    _jump3486:;
    int64_t _302 = 0;
    _302 *= _287.d0;
    _302 += d;
    _302 *= _287.d1;
    _302 += c;
    _302 *= _287.d2;
    _302 += _301;
    _a3_double _303 = _287.data[_302];
    int64_t _304 = 989;
    bool _305 = _304 >= d;
    _a3_double _306;
    if (!_305)
    goto _jump3487;
    _a3_double _307;
    // Computing bound for v
    _307.d0 = q;
    if (q > 0) 
    goto _jump3488;
    fail_assertion("non-positive loop bound");
    _jump3488:;
    // Computing bound for w
    _307.d1 = d;
    if (d > 0) 
    goto _jump3489;
    fail_assertion("non-positive loop bound");
    _jump3489:;
    // Computing bound for x
    _307.d2 = c;
    if (c > 0) 
    goto _jump3490;
    fail_assertion("non-positive loop bound");
    _jump3490:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= q;
    _308 *= d;
    _308 *= c;
    _308 *= sizeof(double);
    _307.data = jpl_alloc(_308);
    int64_t _309 = 0; // x
    int64_t _310 = 0; // w
    int64_t _311 = 0; // v
    _jump3491:; // Begin body of loop
    int64_t _312 = 0;
    _312 *= _307.d0;
    _312 += _311;
    _312 *= _307.d1;
    _312 += _310;
    _312 *= _307.d2;
    _312 += _309;
    _307.data[_312] = g;
    _309++;
    if (_309 < c)
    goto _jump3491;
    _309 = 0;
    _310++;
    if (_310 < d)
    goto _jump3491;
    _310 = 0;
    _311++;
    if (_311 < q)
    goto _jump3491;
    // End body of loop
    _306 = _307;
    goto _jump3492;
    _jump3487:;
    _a3_double _313;
    if (!n)
    goto _jump3493;
    _a3_double _314;
    // Computing bound for v
    int64_t _315 = 959;
    _314.d0 = _315;
    if (_315 > 0) 
    goto _jump3494;
    fail_assertion("non-positive loop bound");
    _jump3494:;
    // Computing bound for w
    _314.d1 = d;
    if (d > 0) 
    goto _jump3495;
    fail_assertion("non-positive loop bound");
    _jump3495:;
    // Computing bound for x
    _314.d2 = c;
    if (c > 0) 
    goto _jump3496;
    fail_assertion("non-positive loop bound");
    _jump3496:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= _315;
    _316 *= d;
    _316 *= c;
    _316 *= sizeof(double);
    _314.data = jpl_alloc(_316);
    int64_t _317 = 0; // x
    int64_t _318 = 0; // w
    int64_t _319 = 0; // v
    _jump3497:; // Begin body of loop
    int64_t _320 = 0;
    _320 *= _314.d0;
    _320 += _319;
    _320 *= _314.d1;
    _320 += _318;
    _320 *= _314.d2;
    _320 += _317;
    _314.data[_320] = g;
    _317++;
    if (_317 < c)
    goto _jump3497;
    _317 = 0;
    _318++;
    if (_318 < d)
    goto _jump3497;
    _318 = 0;
    _319++;
    if (_319 < _315)
    goto _jump3497;
    // End body of loop
    _313 = _314;
    goto _jump3498;
    _jump3493:;
    _a3_double _321;
    // Computing bound for v
    _321.d0 = d;
    if (d > 0) 
    goto _jump3499;
    fail_assertion("non-positive loop bound");
    _jump3499:;
    // Computing bound for w
    _321.d1 = q;
    if (q > 0) 
    goto _jump3500;
    fail_assertion("non-positive loop bound");
    _jump3500:;
    // Computing bound for x
    _321.d2 = c;
    if (c > 0) 
    goto _jump3501;
    fail_assertion("non-positive loop bound");
    _jump3501:;
    // Computing total size of heap memory to allocate
    int64_t _322 = 1;
    _322 *= d;
    _322 *= q;
    _322 *= c;
    _322 *= sizeof(double);
    _321.data = jpl_alloc(_322);
    int64_t _323 = 0; // x
    int64_t _324 = 0; // w
    int64_t _325 = 0; // v
    _jump3502:; // Begin body of loop
    double _326 = 12.0;
    int64_t _327 = 0;
    _327 *= _321.d0;
    _327 += _325;
    _327 *= _321.d1;
    _327 += _324;
    _327 *= _321.d2;
    _327 += _323;
    _321.data[_327] = _326;
    _323++;
    if (_323 < c)
    goto _jump3502;
    _323 = 0;
    _324++;
    if (_324 < q)
    goto _jump3502;
    _324 = 0;
    _325++;
    if (_325 < d)
    goto _jump3502;
    // End body of loop
    _313 = _321;
    _jump3498:;
    _306 = _313;
    _jump3492:;
    _a3_double _328;
    // Computing bound for v
    _328.d0 = q;
    if (q > 0) 
    goto _jump3503;
    fail_assertion("non-positive loop bound");
    _jump3503:;
    // Computing bound for w
    _328.d1 = c;
    if (c > 0) 
    goto _jump3504;
    fail_assertion("non-positive loop bound");
    _jump3504:;
    // Computing bound for x
    int64_t _329 = 725;
    _328.d2 = _329;
    if (_329 > 0) 
    goto _jump3505;
    fail_assertion("non-positive loop bound");
    _jump3505:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= q;
    _330 *= c;
    _330 *= _329;
    _330 *= sizeof(double);
    _328.data = jpl_alloc(_330);
    int64_t _331 = 0; // x
    int64_t _332 = 0; // w
    int64_t _333 = 0; // v
    _jump3506:; // Begin body of loop
    double _334;
    // Computing bound for y
    if (d > 0) 
    goto _jump3507;
    fail_assertion("non-positive loop bound");
    _jump3507:;
    _334 = 0;
    int64_t _335 = 0; // y
    _jump3508:; // Begin body of loop
    rgba _336 = a();
    double _337 = _336.a;
    _334 += _337;
    _335++;
    if (_335 < d)
    goto _jump3508;
    // End body of loop
    int64_t _338 = 0;
    _338 *= _328.d0;
    _338 += _333;
    _338 *= _328.d1;
    _338 += _332;
    _338 *= _328.d2;
    _338 += _331;
    _328.data[_338] = _334;
    _331++;
    if (_331 < _329)
    goto _jump3506;
    _331 = 0;
    _332++;
    if (_332 < c)
    goto _jump3506;
    _332 = 0;
    _333++;
    if (_333 < q)
    goto _jump3506;
    // End body of loop
    _a1__a3_double _339;
    _339.d0 = 3;
    _339.data = jpl_alloc(sizeof(_a3_double) * 3);
    _339.data[0] = _303;
    _339.data[1] = _306;
    _339.data[2] = _328;
    if (q >= 0)
    goto _jump3509;
    fail_assertion("negative array index");
    _jump3509:;
    if (q < _339.d0)
    goto _jump3510;
    fail_assertion("index too large");
    _jump3510:;
    int64_t _340 = 0;
    _340 *= _339.d0;
    _340 += q;
    _a3_double _341 = _339.data[_340];
    int64_t _342 = 936;
    int64_t _343 = j(_286, _341, _342);
    bool _344 = !n;
    bool _345 = true;
    _a1_bool _346;
    _346.d0 = 2;
    _346.data = jpl_alloc(sizeof(bool) * 2);
    _346.data[0] = _344;
    _346.data[1] = _345;
    int64_t _347 = q % q;
    if (_347 >= 0)
    goto _jump3511;
    fail_assertion("negative array index");
    _jump3511:;
    if (_347 < _346.d0)
    goto _jump3512;
    fail_assertion("index too large");
    _jump3512:;
    int64_t _348 = 0;
    _348 *= _346.d0;
    _348 += _347;
    bool _349 = _346.data[_348];
    _a2_void_t _350;
    if (!_349)
    goto _jump3513;
    o _351 = r();
    l _352 = _351.a;
    bool _353 = _352.a;
    _a2_void_t _354;
    if (!_353)
    goto _jump3514;
    _a2_void_t _355;
    // Computing bound for v
    int64_t _356;
    // Computing bound for v
    int64_t _357 = 262;
    if (_357 > 0) 
    goto _jump3515;
    fail_assertion("non-positive loop bound");
    _jump3515:;
    // Computing bound for w
    if (d > 0) 
    goto _jump3516;
    fail_assertion("non-positive loop bound");
    _jump3516:;
    _356 = 0;
    int64_t _358 = 0; // w
    int64_t _359 = 0; // v
    _jump3517:; // Begin body of loop
    _356 += _358;
    _358++;
    if (_358 < d)
    goto _jump3517;
    _358 = 0;
    _359++;
    if (_359 < _357)
    goto _jump3517;
    // End body of loop
    _a1_int64_t _360;
    _360.d0 = 2;
    _360.data = jpl_alloc(sizeof(int64_t) * 2);
    _360.data[0] = q;
    _360.data[1] = _356;
    int64_t _361 = c + d;
    if (_361 >= 0)
    goto _jump3518;
    fail_assertion("negative array index");
    _jump3518:;
    if (_361 < _360.d0)
    goto _jump3519;
    fail_assertion("index too large");
    _jump3519:;
    int64_t _362 = 0;
    _362 *= _360.d0;
    _362 += _361;
    int64_t _363 = _360.data[_362];
    _355.d0 = _363;
    if (_363 > 0) 
    goto _jump3520;
    fail_assertion("non-positive loop bound");
    _jump3520:;
    // Computing bound for w
    _a3_int64_t _364;
    // Computing bound for v
    _364.d0 = c;
    if (c > 0) 
    goto _jump3521;
    fail_assertion("non-positive loop bound");
    _jump3521:;
    // Computing bound for w
    bool _365 = false;
    int64_t _366;
    if (!_365)
    goto _jump3522;
    _366 = q;
    goto _jump3523;
    _jump3522:;
    _366 = q;
    _jump3523:;
    _364.d1 = _366;
    if (_366 > 0) 
    goto _jump3524;
    fail_assertion("non-positive loop bound");
    _jump3524:;
    // Computing bound for x
    int64_t _367 = 604;
    int64_t _368 = -_367;
    _364.d2 = _368;
    if (_368 > 0) 
    goto _jump3525;
    fail_assertion("non-positive loop bound");
    _jump3525:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= c;
    _369 *= _366;
    _369 *= _368;
    _369 *= sizeof(int64_t);
    _364.data = jpl_alloc(_369);
    int64_t _370 = 0; // x
    int64_t _371 = 0; // w
    int64_t _372 = 0; // v
    _jump3526:; // Begin body of loop
    int64_t _373 = 648;
    int64_t _374 = 0;
    _374 *= _364.d0;
    _374 += _372;
    _374 *= _364.d1;
    _374 += _371;
    _374 *= _364.d2;
    _374 += _370;
    _364.data[_374] = _373;
    _370++;
    if (_370 < _368)
    goto _jump3526;
    _370 = 0;
    _371++;
    if (_371 < _366)
    goto _jump3526;
    _371 = 0;
    _372++;
    if (_372 < c)
    goto _jump3526;
    // End body of loop
    int64_t _375;
    // Computing bound for v
    int64_t _376 = -d;
    if (_376 > 0) 
    goto _jump3527;
    fail_assertion("non-positive loop bound");
    _jump3527:;
    // Computing bound for w
    bool _377 = false;
    int64_t _378;
    if (!_377)
    goto _jump3528;
    _378 = c;
    goto _jump3529;
    _jump3528:;
    _378 = c;
    _jump3529:;
    if (_378 > 0) 
    goto _jump3530;
    fail_assertion("non-positive loop bound");
    _jump3530:;
    _375 = 0;
    int64_t _379 = 0; // w
    int64_t _380 = 0; // v
    _jump3531:; // Begin body of loop
    int64_t _381 = d * q;
    _375 += _381;
    _379++;
    if (_379 < _378)
    goto _jump3531;
    _379 = 0;
    _380++;
    if (_380 < _376)
    goto _jump3531;
    // End body of loop
    _a1_int64_t _382;
    // Computing bound for v
    int64_t _383 = 321;
    _382.d0 = _383;
    if (_383 > 0) 
    goto _jump3532;
    fail_assertion("non-positive loop bound");
    _jump3532:;
    // Computing total size of heap memory to allocate
    int64_t _384 = 1;
    _384 *= _383;
    _384 *= sizeof(int64_t);
    _382.data = jpl_alloc(_384);
    int64_t _385 = 0; // v
    _jump3533:; // Begin body of loop
    int64_t _386 = 0;
    _386 *= _382.d0;
    _386 += _385;
    _382.data[_386] = q;
    _385++;
    if (_385 < _383)
    goto _jump3533;
    // End body of loop
    int64_t _387 = 768;
    if (_387 >= 0)
    goto _jump3534;
    fail_assertion("negative array index");
    _jump3534:;
    if (_387 < _382.d0)
    goto _jump3535;
    fail_assertion("index too large");
    _jump3535:;
    int64_t _388 = 0;
    _388 *= _382.d0;
    _388 += _387;
    int64_t _389 = _382.data[_388];
    if (q >= 0)
    goto _jump3536;
    fail_assertion("negative array index");
    _jump3536:;
    if (q < _364.d0)
    goto _jump3537;
    fail_assertion("index too large");
    _jump3537:;
    if (_375 >= 0)
    goto _jump3538;
    fail_assertion("negative array index");
    _jump3538:;
    if (_375 < _364.d1)
    goto _jump3539;
    fail_assertion("index too large");
    _jump3539:;
    if (_389 >= 0)
    goto _jump3540;
    fail_assertion("negative array index");
    _jump3540:;
    if (_389 < _364.d2)
    goto _jump3541;
    fail_assertion("index too large");
    _jump3541:;
    int64_t _390 = 0;
    _390 *= _364.d0;
    _390 += q;
    _390 *= _364.d1;
    _390 += _375;
    _390 *= _364.d2;
    _390 += _389;
    int64_t _391 = _364.data[_390];
    _355.d1 = _391;
    if (_391 > 0) 
    goto _jump3542;
    fail_assertion("non-positive loop bound");
    _jump3542:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= _363;
    _392 *= _391;
    _392 *= sizeof(void_t);
    _355.data = jpl_alloc(_392);
    int64_t _393 = 0; // w
    int64_t _394 = 0; // v
    _jump3543:; // Begin body of loop
    _a3_double _395;
    // Computing bound for x
    _395.d0 = q;
    if (q > 0) 
    goto _jump3544;
    fail_assertion("non-positive loop bound");
    _jump3544:;
    // Computing bound for y
    _395.d1 = _394;
    if (_394 > 0) 
    goto _jump3545;
    fail_assertion("non-positive loop bound");
    _jump3545:;
    // Computing bound for z
    _395.d2 = d;
    if (d > 0) 
    goto _jump3546;
    fail_assertion("non-positive loop bound");
    _jump3546:;
    // Computing total size of heap memory to allocate
    int64_t _396 = 1;
    _396 *= q;
    _396 *= _394;
    _396 *= d;
    _396 *= sizeof(double);
    _395.data = jpl_alloc(_396);
    int64_t _397 = 0; // z
    int64_t _398 = 0; // y
    int64_t _399 = 0; // x
    _jump3547:; // Begin body of loop
    double _400 = g + g;
    int64_t _401 = 0;
    _401 *= _395.d0;
    _401 += _399;
    _401 *= _395.d1;
    _401 += _398;
    _401 *= _395.d2;
    _401 += _397;
    _395.data[_401] = _400;
    _397++;
    if (_397 < d)
    goto _jump3547;
    _397 = 0;
    _398++;
    if (_398 < _394)
    goto _jump3547;
    _398 = 0;
    _399++;
    if (_399 < q)
    goto _jump3547;
    // End body of loop
    rgba _402 = t();
    void_t _403 = s(_395, _402);
    int64_t _404 = 0;
    _404 *= _355.d0;
    _404 += _394;
    _404 *= _355.d1;
    _404 += _393;
    _355.data[_404] = _403;
    _393++;
    if (_393 < _391)
    goto _jump3543;
    _393 = 0;
    _394++;
    if (_394 < _363)
    goto _jump3543;
    // End body of loop
    _354 = _355;
    goto _jump3548;
    _jump3514:;
    _a2_void_t _405;
    // Computing bound for v
    int64_t _406 = -q;
    int64_t _407 = q / _406;
    _405.d0 = _407;
    if (_407 > 0) 
    goto _jump3549;
    fail_assertion("non-positive loop bound");
    _jump3549:;
    // Computing bound for w
    int64_t _408 = 918;
    _405.d1 = _408;
    if (_408 > 0) 
    goto _jump3550;
    fail_assertion("non-positive loop bound");
    _jump3550:;
    // Computing total size of heap memory to allocate
    int64_t _409 = 1;
    _409 *= _407;
    _409 *= _408;
    _409 *= sizeof(void_t);
    _405.data = jpl_alloc(_409);
    int64_t _410 = 0; // w
    int64_t _411 = 0; // v
    _jump3551:; // Begin body of loop
    _a3_double _412;
    // Computing bound for x
    _412.d0 = _411;
    if (_411 > 0) 
    goto _jump3552;
    fail_assertion("non-positive loop bound");
    _jump3552:;
    // Computing bound for y
    _412.d1 = d;
    if (d > 0) 
    goto _jump3553;
    fail_assertion("non-positive loop bound");
    _jump3553:;
    // Computing bound for z
    bool _413 = true;
    int64_t _414;
    if (!_413)
    goto _jump3554;
    _414 = _410;
    goto _jump3555;
    _jump3554:;
    _414 = _411;
    _jump3555:;
    _412.d2 = _414;
    if (_414 > 0) 
    goto _jump3556;
    fail_assertion("non-positive loop bound");
    _jump3556:;
    // Computing total size of heap memory to allocate
    int64_t _415 = 1;
    _415 *= _411;
    _415 *= d;
    _415 *= _414;
    _415 *= sizeof(double);
    _412.data = jpl_alloc(_415);
    int64_t _416 = 0; // z
    int64_t _417 = 0; // y
    int64_t _418 = 0; // x
    _jump3557:; // Begin body of loop
    double _419 = 66.0;
    int64_t _420 = 0;
    _420 *= _412.d0;
    _420 += _418;
    _420 *= _412.d1;
    _420 += _417;
    _420 *= _412.d2;
    _420 += _416;
    _412.data[_420] = _419;
    _416++;
    if (_416 < _414)
    goto _jump3557;
    _416 = 0;
    _417++;
    if (_417 < d)
    goto _jump3557;
    _417 = 0;
    _418++;
    if (_418 < _411)
    goto _jump3557;
    // End body of loop
    rgba _421 = _238.c;
    void_t _422 = s(_412, _421);
    int64_t _423 = 0;
    _423 *= _405.d0;
    _423 += _411;
    _423 *= _405.d1;
    _423 += _410;
    _405.data[_423] = _422;
    _410++;
    if (_410 < _408)
    goto _jump3551;
    _410 = 0;
    _411++;
    if (_411 < _407)
    goto _jump3551;
    // End body of loop
    _354 = _405;
    _jump3548:;
    _350 = _354;
    goto _jump3558;
    _jump3513:;
    _a2_void_t _424;
    // Computing bound for v
    bool _426 = false;
    bool _427 = !_426;
    bool _425 = _427;
    if (0 != _427)
    goto _jump3559;
    int64_t _428 = -c;
    bool _429 = _428 >= c;
    _425 = _429;
    _jump3559:;
    int64_t _430;
    if (!_425)
    goto _jump3560;
    o _432 = r();
    bool _433 = _432.c;
    bool _431 = _433;
    if (0 != _433)
    goto _jump3561;
    bool _434 = n == n;
    _431 = _434;
    _jump3561:;
    int64_t _435;
    if (!_431)
    goto _jump3562;
    bool _436 = _238.a;
    int64_t _437;
    if (!_436)
    goto _jump3563;
    _437 = c;
    goto _jump3564;
    _jump3563:;
    _437 = c;
    _jump3564:;
    _435 = _437;
    goto _jump3565;
    _jump3562:;
    _435 = d;
    _jump3565:;
    _430 = _435;
    goto _jump3566;
    _jump3560:;
    _430 = q;
    _jump3566:;
    _424.d0 = _430;
    if (_430 > 0) 
    goto _jump3567;
    fail_assertion("non-positive loop bound");
    _jump3567:;
    // Computing bound for w
    _424.d1 = q;
    if (q > 0) 
    goto _jump3568;
    fail_assertion("non-positive loop bound");
    _jump3568:;
    // Computing total size of heap memory to allocate
    int64_t _438 = 1;
    _438 *= _430;
    _438 *= q;
    _438 *= sizeof(void_t);
    _424.data = jpl_alloc(_438);
    int64_t _439 = 0; // w
    int64_t _440 = 0; // v
    _jump3569:; // Begin body of loop
    _a3_l _441;
    // Computing bound for x
    _441.d0 = d;
    if (d > 0) 
    goto _jump3570;
    fail_assertion("non-positive loop bound");
    _jump3570:;
    // Computing bound for y
    _441.d1 = c;
    if (c > 0) 
    goto _jump3571;
    fail_assertion("non-positive loop bound");
    _jump3571:;
    // Computing bound for z
    _441.d2 = c;
    if (c > 0) 
    goto _jump3572;
    fail_assertion("non-positive loop bound");
    _jump3572:;
    // Computing total size of heap memory to allocate
    int64_t _442 = 1;
    _442 *= d;
    _442 *= c;
    _442 *= c;
    _442 *= sizeof(l);
    _441.data = jpl_alloc(_442);
    int64_t _443 = 0; // z
    int64_t _444 = 0; // y
    int64_t _445 = 0; // x
    _jump3573:; // Begin body of loop
    int64_t _446 = 0;
    _446 *= _441.d0;
    _446 += _445;
    _446 *= _441.d1;
    _446 += _444;
    _446 *= _441.d2;
    _446 += _443;
    _441.data[_446] = _238;
    _443++;
    if (_443 < c)
    goto _jump3573;
    _443 = 0;
    _444++;
    if (_444 < c)
    goto _jump3573;
    _444 = 0;
    _445++;
    if (_445 < d)
    goto _jump3573;
    // End body of loop
    int64_t _447 = -q;
    if (d >= 0)
    goto _jump3574;
    fail_assertion("negative array index");
    _jump3574:;
    if (d < _441.d0)
    goto _jump3575;
    fail_assertion("index too large");
    _jump3575:;
    if (q >= 0)
    goto _jump3576;
    fail_assertion("negative array index");
    _jump3576:;
    if (q < _441.d1)
    goto _jump3577;
    fail_assertion("index too large");
    _jump3577:;
    if (_447 >= 0)
    goto _jump3578;
    fail_assertion("negative array index");
    _jump3578:;
    if (_447 < _441.d2)
    goto _jump3579;
    fail_assertion("index too large");
    _jump3579:;
    int64_t _448 = 0;
    _448 *= _441.d0;
    _448 += d;
    _448 *= _441.d1;
    _448 += q;
    _448 *= _441.d2;
    _448 += _447;
    l _449 = _441.data[_448];
    bool _450 = _449.a;
    void_t _451;
    if (!_450)
    goto _jump3580;
    _a3_double _452;
    // Computing bound for x
    int64_t _453 = -q;
    _452.d0 = _453;
    if (_453 > 0) 
    goto _jump3581;
    fail_assertion("non-positive loop bound");
    _jump3581:;
    // Computing bound for y
    int64_t _454 = 385;
    _452.d1 = _454;
    if (_454 > 0) 
    goto _jump3582;
    fail_assertion("non-positive loop bound");
    _jump3582:;
    // Computing bound for z
    _452.d2 = _440;
    if (_440 > 0) 
    goto _jump3583;
    fail_assertion("non-positive loop bound");
    _jump3583:;
    // Computing total size of heap memory to allocate
    int64_t _455 = 1;
    _455 *= _453;
    _455 *= _454;
    _455 *= _440;
    _455 *= sizeof(double);
    _452.data = jpl_alloc(_455);
    int64_t _456 = 0; // z
    int64_t _457 = 0; // y
    int64_t _458 = 0; // x
    _jump3584:; // Begin body of loop
    int64_t _459 = 0;
    _459 *= _452.d0;
    _459 += _458;
    _459 *= _452.d1;
    _459 += _457;
    _459 *= _452.d2;
    _459 += _456;
    _452.data[_459] = g;
    _456++;
    if (_456 < _440)
    goto _jump3584;
    _456 = 0;
    _457++;
    if (_457 < _454)
    goto _jump3584;
    _457 = 0;
    _458++;
    if (_458 < _453)
    goto _jump3584;
    // End body of loop
    o _460 = r();
    bool _461 = _460.c;
    rgba _462;
    if (!_461)
    goto _jump3585;
    rgba _463 = m();
    _462 = _463;
    goto _jump3586;
    _jump3585:;
    rgba _464 = _238.c;
    _462 = _464;
    _jump3586:;
    void_t _465 = s(_452, _462);
    _451 = _465;
    goto _jump3587;
    _jump3580:;
    _a3_double _466;
    // Computing bound for x
    int64_t _467;
    // Computing bound for x
    int64_t _468 = 928;
    if (_468 > 0) 
    goto _jump3588;
    fail_assertion("non-positive loop bound");
    _jump3588:;
    // Computing bound for y
    if (_439 > 0) 
    goto _jump3589;
    fail_assertion("non-positive loop bound");
    _jump3589:;
    // Computing bound for z
    if (q > 0) 
    goto _jump3590;
    fail_assertion("non-positive loop bound");
    _jump3590:;
    _467 = 0;
    int64_t _469 = 0; // z
    int64_t _470 = 0; // y
    int64_t _471 = 0; // x
    _jump3591:; // Begin body of loop
    _467 += _440;
    _469++;
    if (_469 < q)
    goto _jump3591;
    _469 = 0;
    _470++;
    if (_470 < _439)
    goto _jump3591;
    _470 = 0;
    _471++;
    if (_471 < _468)
    goto _jump3591;
    // End body of loop
    _466.d0 = _467;
    if (_467 > 0) 
    goto _jump3592;
    fail_assertion("non-positive loop bound");
    _jump3592:;
    // Computing bound for y
    _466.d1 = d;
    if (d > 0) 
    goto _jump3593;
    fail_assertion("non-positive loop bound");
    _jump3593:;
    // Computing bound for z
    _466.d2 = _439;
    if (_439 > 0) 
    goto _jump3594;
    fail_assertion("non-positive loop bound");
    _jump3594:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _467;
    _472 *= d;
    _472 *= _439;
    _472 *= sizeof(double);
    _466.data = jpl_alloc(_472);
    int64_t _473 = 0; // z
    int64_t _474 = 0; // y
    int64_t _475 = 0; // x
    _jump3595:; // Begin body of loop
    double _476 = 84.0;
    int64_t _477 = 0;
    _477 *= _466.d0;
    _477 += _475;
    _477 *= _466.d1;
    _477 += _474;
    _477 *= _466.d2;
    _477 += _473;
    _466.data[_477] = _476;
    _473++;
    if (_473 < _439)
    goto _jump3595;
    _473 = 0;
    _474++;
    if (_474 < d)
    goto _jump3595;
    _474 = 0;
    _475++;
    if (_475 < _467)
    goto _jump3595;
    // End body of loop
    _a1_rgba _478;
    // Computing bound for x
    _478.d0 = d;
    if (d > 0) 
    goto _jump3596;
    fail_assertion("non-positive loop bound");
    _jump3596:;
    // Computing total size of heap memory to allocate
    int64_t _479 = 1;
    _479 *= d;
    _479 *= sizeof(rgba);
    _478.data = jpl_alloc(_479);
    int64_t _480 = 0; // x
    _jump3597:; // Begin body of loop
    rgba _481 = k();
    int64_t _482 = 0;
    _482 *= _478.d0;
    _482 += _480;
    _478.data[_482] = _481;
    _480++;
    if (_480 < d)
    goto _jump3597;
    // End body of loop
    int64_t _483 = c + q;
    if (_483 >= 0)
    goto _jump3598;
    fail_assertion("negative array index");
    _jump3598:;
    if (_483 < _478.d0)
    goto _jump3599;
    fail_assertion("index too large");
    _jump3599:;
    int64_t _484 = 0;
    _484 *= _478.d0;
    _484 += _483;
    rgba _485 = _478.data[_484];
    void_t _486 = s(_466, _485);
    _451 = _486;
    _jump3587:;
    int64_t _487 = 0;
    _487 *= _424.d0;
    _487 += _440;
    _487 *= _424.d1;
    _487 += _439;
    _424.data[_487] = _451;
    _439++;
    if (_439 < q)
    goto _jump3569;
    _439 = 0;
    _440++;
    if (_440 < _430)
    goto _jump3569;
    // End body of loop
    _350 = _424;
    _jump3558:;
    _a2__a3_rgba _488;
    // Computing bound for v
    int64_t _489;
    // Computing bound for v
    bool _490 = n;
    if (0 == n)
    goto _jump3600;
    _490 = n;
    _jump3600:;
    int64_t _491;
    if (!_490)
    goto _jump3601;
    int64_t _492 = -c;
    _491 = _492;
    goto _jump3602;
    _jump3601:;
    int64_t _493;
    // Computing bound for v
    if (c > 0) 
    goto _jump3603;
    fail_assertion("non-positive loop bound");
    _jump3603:;
    // Computing bound for w
    int64_t _494 = 674;
    if (_494 > 0) 
    goto _jump3604;
    fail_assertion("non-positive loop bound");
    _jump3604:;
    // Computing bound for x
    if (q > 0) 
    goto _jump3605;
    fail_assertion("non-positive loop bound");
    _jump3605:;
    _493 = 0;
    int64_t _495 = 0; // x
    int64_t _496 = 0; // w
    int64_t _497 = 0; // v
    _jump3606:; // Begin body of loop
    _493 += _496;
    _495++;
    if (_495 < q)
    goto _jump3606;
    _495 = 0;
    _496++;
    if (_496 < _494)
    goto _jump3606;
    _496 = 0;
    _497++;
    if (_497 < c)
    goto _jump3606;
    // End body of loop
    _491 = _493;
    _jump3602:;
    int64_t _498 = -_491;
    bool _499 = _238.a;
    int64_t _500;
    if (!_499)
    goto _jump3607;
    _500 = q;
    goto _jump3608;
    _jump3607:;
    _500 = c;
    _jump3608:;
    int64_t _501 = d % _500;
    int64_t _502 = _498 + _501;
    if (_502 > 0) 
    goto _jump3609;
    fail_assertion("non-positive loop bound");
    _jump3609:;
    // Computing bound for w
    bool _503 = n;
    if (0 == n)
    goto _jump3610;
    bool _504 = false;
    o _505;
    if (!_504)
    goto _jump3611;
    o _506 = r();
    _505 = _506;
    goto _jump3612;
    _jump3611:;
    o _507 = r();
    _505 = _507;
    _jump3612:;
    bool _508 = _505.c;
    _503 = _508;
    _jump3610:;
    int64_t _509;
    if (!_503)
    goto _jump3613;
    int64_t _510 = 17;
    int64_t _511 = 87;
    int64_t _512 = -_511;
    int64_t _513 = _510 + _512;
    _509 = _513;
    goto _jump3614;
    _jump3613:;
    _509 = d;
    _jump3614:;
    if (_509 > 0) 
    goto _jump3615;
    fail_assertion("non-positive loop bound");
    _jump3615:;
    // Computing bound for x
    double _514;
    if (!n)
    goto _jump3616;
    _514 = g;
    goto _jump3617;
    _jump3616:;
    double _515 = 84.0;
    _514 = _515;
    _jump3617:;
    bool _516 = _514 > g;
    bool _517 = !_516;
    int64_t _518;
    if (!_517)
    goto _jump3618;
    _518 = q;
    goto _jump3619;
    _jump3618:;
    _518 = d;
    _jump3619:;
    if (_518 > 0) 
    goto _jump3620;
    fail_assertion("non-positive loop bound");
    _jump3620:;
    _489 = 0;
    int64_t _519 = 0; // x
    int64_t _520 = 0; // w
    int64_t _521 = 0; // v
    _jump3621:; // Begin body of loop
    int64_t _522;
    // Computing bound for y
    int64_t _523 = -_520;
    if (_523 > 0) 
    goto _jump3622;
    fail_assertion("non-positive loop bound");
    _jump3622:;
    // Computing bound for z
    if (_521 > 0) 
    goto _jump3623;
    fail_assertion("non-positive loop bound");
    _jump3623:;
    _522 = 0;
    int64_t _524 = 0; // z
    int64_t _525 = 0; // y
    _jump3624:; // Begin body of loop
    _522 += c;
    _524++;
    if (_524 < _521)
    goto _jump3624;
    _524 = 0;
    _525++;
    if (_525 < _523)
    goto _jump3624;
    // End body of loop
    _489 += _522;
    _519++;
    if (_519 < _518)
    goto _jump3621;
    _519 = 0;
    _520++;
    if (_520 < _509)
    goto _jump3621;
    _520 = 0;
    _521++;
    if (_521 < _502)
    goto _jump3621;
    // End body of loop
    _488.d0 = _489;
    if (_489 > 0) 
    goto _jump3625;
    fail_assertion("non-positive loop bound");
    _jump3625:;
    // Computing bound for w
    int64_t _526 = -c;
    _488.d1 = _526;
    if (_526 > 0) 
    goto _jump3626;
    fail_assertion("non-positive loop bound");
    _jump3626:;
    // Computing total size of heap memory to allocate
    int64_t _527 = 1;
    _527 *= _489;
    _527 *= _526;
    _527 *= sizeof(_a3_rgba);
    _488.data = jpl_alloc(_527);
    int64_t _528 = 0; // w
    int64_t _529 = 0; // v
    _jump3627:; // Begin body of loop
    bool _530 = _528 > _528;
    bool _531 = !_530;
    _a3_rgba _532;
    if (!_531)
    goto _jump3628;
    _a3_rgba _533;
    // Computing bound for x
    _533.d0 = _529;
    if (_529 > 0) 
    goto _jump3629;
    fail_assertion("non-positive loop bound");
    _jump3629:;
    // Computing bound for y
    _a3_int64_t _534;
    // Computing bound for x
    int64_t _535;
    // Computing bound for x
    if (c > 0) 
    goto _jump3630;
    fail_assertion("non-positive loop bound");
    _jump3630:;
    // Computing bound for y
    if (q > 0) 
    goto _jump3631;
    fail_assertion("non-positive loop bound");
    _jump3631:;
    // Computing bound for z
    if (_529 > 0) 
    goto _jump3632;
    fail_assertion("non-positive loop bound");
    _jump3632:;
    _535 = 0;
    int64_t _536 = 0; // z
    int64_t _537 = 0; // y
    int64_t _538 = 0; // x
    _jump3633:; // Begin body of loop
    _535 += _538;
    _536++;
    if (_536 < _529)
    goto _jump3633;
    _536 = 0;
    _537++;
    if (_537 < q)
    goto _jump3633;
    _537 = 0;
    _538++;
    if (_538 < c)
    goto _jump3633;
    // End body of loop
    _534.d0 = _535;
    if (_535 > 0) 
    goto _jump3634;
    fail_assertion("non-positive loop bound");
    _jump3634:;
    // Computing bound for y
    int64_t _539 = 762;
    if (_539 >= 0)
    goto _jump3635;
    fail_assertion("negative array index");
    _jump3635:;
    if (_539 < b.d0)
    goto _jump3636;
    fail_assertion("index too large");
    _jump3636:;
    if (_528 >= 0)
    goto _jump3637;
    fail_assertion("negative array index");
    _jump3637:;
    if (_528 < b.d1)
    goto _jump3638;
    fail_assertion("index too large");
    _jump3638:;
    int64_t _540 = 0;
    _540 *= b.d0;
    _540 += _539;
    _540 *= b.d1;
    _540 += _528;
    int64_t _541 = b.data[_540];
    _534.d1 = _541;
    if (_541 > 0) 
    goto _jump3639;
    fail_assertion("non-positive loop bound");
    _jump3639:;
    // Computing bound for z
    int64_t _542 = 188;
    _534.d2 = _542;
    if (_542 > 0) 
    goto _jump3640;
    fail_assertion("non-positive loop bound");
    _jump3640:;
    // Computing total size of heap memory to allocate
    int64_t _543 = 1;
    _543 *= _535;
    _543 *= _541;
    _543 *= _542;
    _543 *= sizeof(int64_t);
    _534.data = jpl_alloc(_543);
    int64_t _544 = 0; // z
    int64_t _545 = 0; // y
    int64_t _546 = 0; // x
    _jump3641:; // Begin body of loop
    int64_t _547 = 0;
    _547 *= _534.d0;
    _547 += _546;
    _547 *= _534.d1;
    _547 += _545;
    _547 *= _534.d2;
    _547 += _544;
    _534.data[_547] = c;
    _544++;
    if (_544 < _542)
    goto _jump3641;
    _544 = 0;
    _545++;
    if (_545 < _541)
    goto _jump3641;
    _545 = 0;
    _546++;
    if (_546 < _535)
    goto _jump3641;
    // End body of loop
    int64_t _548 = q / d;
    if (_548 >= 0)
    goto _jump3642;
    fail_assertion("negative array index");
    _jump3642:;
    if (_548 < b.d0)
    goto _jump3643;
    fail_assertion("index too large");
    _jump3643:;
    if (c >= 0)
    goto _jump3644;
    fail_assertion("negative array index");
    _jump3644:;
    if (c < b.d1)
    goto _jump3645;
    fail_assertion("index too large");
    _jump3645:;
    int64_t _549 = 0;
    _549 *= b.d0;
    _549 += _548;
    _549 *= b.d1;
    _549 += c;
    int64_t _550 = b.data[_549];
    int64_t _551 = 954;
    if (_550 >= 0)
    goto _jump3646;
    fail_assertion("negative array index");
    _jump3646:;
    if (_550 < _534.d0)
    goto _jump3647;
    fail_assertion("index too large");
    _jump3647:;
    if (q >= 0)
    goto _jump3648;
    fail_assertion("negative array index");
    _jump3648:;
    if (q < _534.d1)
    goto _jump3649;
    fail_assertion("index too large");
    _jump3649:;
    if (_551 >= 0)
    goto _jump3650;
    fail_assertion("negative array index");
    _jump3650:;
    if (_551 < _534.d2)
    goto _jump3651;
    fail_assertion("index too large");
    _jump3651:;
    int64_t _552 = 0;
    _552 *= _534.d0;
    _552 += _550;
    _552 *= _534.d1;
    _552 += q;
    _552 *= _534.d2;
    _552 += _551;
    int64_t _553 = _534.data[_552];
    _533.d1 = _553;
    if (_553 > 0) 
    goto _jump3652;
    fail_assertion("non-positive loop bound");
    _jump3652:;
    // Computing bound for z
    _533.d2 = q;
    if (q > 0) 
    goto _jump3653;
    fail_assertion("non-positive loop bound");
    _jump3653:;
    // Computing total size of heap memory to allocate
    int64_t _554 = 1;
    _554 *= _529;
    _554 *= _553;
    _554 *= q;
    _554 *= sizeof(rgba);
    _533.data = jpl_alloc(_554);
    int64_t _555 = 0; // z
    int64_t _556 = 0; // y
    int64_t _557 = 0; // x
    _jump3654:; // Begin body of loop
    rgba _558 = _238.c;
    int64_t _559 = 0;
    _559 *= _533.d0;
    _559 += _557;
    _559 *= _533.d1;
    _559 += _556;
    _559 *= _533.d2;
    _559 += _555;
    _533.data[_559] = _558;
    _555++;
    if (_555 < q)
    goto _jump3654;
    _555 = 0;
    _556++;
    if (_556 < _553)
    goto _jump3654;
    _556 = 0;
    _557++;
    if (_557 < _529)
    goto _jump3654;
    // End body of loop
    _532 = _533;
    goto _jump3655;
    _jump3628:;
    _a3_rgba _560;
    // Computing bound for x
    _560.d0 = c;
    if (c > 0) 
    goto _jump3656;
    fail_assertion("non-positive loop bound");
    _jump3656:;
    // Computing bound for y
    _560.d1 = c;
    if (c > 0) 
    goto _jump3657;
    fail_assertion("non-positive loop bound");
    _jump3657:;
    // Computing bound for z
    bool _561 = _238.a;
    int64_t _562;
    if (!_561)
    goto _jump3658;
    _562 = _528;
    goto _jump3659;
    _jump3658:;
    int64_t _563 = 173;
    int64_t _564 = _563 / d;
    _562 = _564;
    _jump3659:;
    _560.d2 = _562;
    if (_562 > 0) 
    goto _jump3660;
    fail_assertion("non-positive loop bound");
    _jump3660:;
    // Computing total size of heap memory to allocate
    int64_t _565 = 1;
    _565 *= c;
    _565 *= c;
    _565 *= _562;
    _565 *= sizeof(rgba);
    _560.data = jpl_alloc(_565);
    int64_t _566 = 0; // z
    int64_t _567 = 0; // y
    int64_t _568 = 0; // x
    _jump3661:; // Begin body of loop
    rgba _569 = m();
    int64_t _570 = 0;
    _570 *= _560.d0;
    _570 += _568;
    _570 *= _560.d1;
    _570 += _567;
    _570 *= _560.d2;
    _570 += _566;
    _560.data[_570] = _569;
    _566++;
    if (_566 < _562)
    goto _jump3661;
    _566 = 0;
    _567++;
    if (_567 < c)
    goto _jump3661;
    _567 = 0;
    _568++;
    if (_568 < c)
    goto _jump3661;
    // End body of loop
    _532 = _560;
    _jump3655:;
    int64_t _571 = 0;
    _571 *= _488.d0;
    _571 += _529;
    _571 *= _488.d1;
    _571 += _528;
    _488.data[_571] = _532;
    _528++;
    if (_528 < _526)
    goto _jump3627;
    _528 = 0;
    _529++;
    if (_529 < _489)
    goto _jump3627;
    // End body of loop
    _a3_rgba _572 = e(_343, _350, _488);
    _a1__a3__a3_bool _573;
    // Computing bound for z
    int64_t _574;
    // Computing bound for z
    if (_572.d1 >= 0)
    goto _jump3662;
    fail_assertion("negative array index");
    _jump3662:;
    if (_572.d1 < f.d0)
    goto _jump3663;
    fail_assertion("index too large");
    _jump3663:;
    if (q >= 0)
    goto _jump3664;
    fail_assertion("negative array index");
    _jump3664:;
    if (q < f.d1)
    goto _jump3665;
    fail_assertion("index too large");
    _jump3665:;
    int64_t _575 = 0;
    _575 *= f.d0;
    _575 += _572.d1;
    _575 *= f.d1;
    _575 += q;
    int64_t _576 = f.data[_575];
    if (_576 > 0) 
    goto _jump3666;
    fail_assertion("non-positive loop bound");
    _jump3666:;
    // Computing bound for A
    int64_t _577 = 81;
    if (_577 > 0) 
    goto _jump3667;
    fail_assertion("non-positive loop bound");
    _jump3667:;
    _574 = 0;
    int64_t _578 = 0; // A
    int64_t _579 = 0; // z
    _jump3668:; // Begin body of loop
    int64_t _580 = 266;
    _574 += _580;
    _578++;
    if (_578 < _577)
    goto _jump3668;
    _578 = 0;
    _579++;
    if (_579 < _576)
    goto _jump3668;
    // End body of loop
    _573.d0 = _574;
    if (_574 > 0) 
    goto _jump3669;
    fail_assertion("non-positive loop bound");
    _jump3669:;
    // Computing total size of heap memory to allocate
    int64_t _581 = 1;
    _581 *= _574;
    _581 *= sizeof(_a3__a3_bool);
    _573.data = jpl_alloc(_581);
    int64_t _582 = 0; // z
    _jump3670:; // Begin body of loop
    _a3__a3_bool _583;
    // Computing bound for A
    _583.d0 = q;
    if (q > 0) 
    goto _jump3671;
    fail_assertion("non-positive loop bound");
    _jump3671:;
    // Computing bound for B
    int64_t _584 = -c;
    _583.d1 = _584;
    if (_584 > 0) 
    goto _jump3672;
    fail_assertion("non-positive loop bound");
    _jump3672:;
    // Computing bound for C
    _583.d2 = q;
    if (q > 0) 
    goto _jump3673;
    fail_assertion("non-positive loop bound");
    _jump3673:;
    // Computing total size of heap memory to allocate
    int64_t _585 = 1;
    _585 *= q;
    _585 *= _584;
    _585 *= q;
    _585 *= sizeof(_a3_bool);
    _583.data = jpl_alloc(_585);
    int64_t _586 = 0; // C
    int64_t _587 = 0; // B
    int64_t _588 = 0; // A
    _jump3674:; // Begin body of loop
    _a3_bool _589;
    // Computing bound for D
    _589.d0 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3675;
    fail_assertion("non-positive loop bound");
    _jump3675:;
    // Computing bound for E
    _589.d1 = _586;
    if (_586 > 0) 
    goto _jump3676;
    fail_assertion("non-positive loop bound");
    _jump3676:;
    // Computing bound for F
    _589.d2 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3677;
    fail_assertion("non-positive loop bound");
    _jump3677:;
    // Computing total size of heap memory to allocate
    int64_t _590 = 1;
    _590 *= _572.d0;
    _590 *= _586;
    _590 *= _572.d2;
    _590 *= sizeof(bool);
    _589.data = jpl_alloc(_590);
    int64_t _591 = 0; // F
    int64_t _592 = 0; // E
    int64_t _593 = 0; // D
    _jump3678:; // Begin body of loop
    int64_t _594 = 0;
    _594 *= _589.d0;
    _594 += _593;
    _594 *= _589.d1;
    _594 += _592;
    _594 *= _589.d2;
    _594 += _591;
    _589.data[_594] = n;
    _591++;
    if (_591 < _572.d2)
    goto _jump3678;
    _591 = 0;
    _592++;
    if (_592 < _586)
    goto _jump3678;
    _592 = 0;
    _593++;
    if (_593 < _572.d0)
    goto _jump3678;
    // End body of loop
    int64_t _595 = 0;
    _595 *= _583.d0;
    _595 += _588;
    _595 *= _583.d1;
    _595 += _587;
    _595 *= _583.d2;
    _595 += _586;
    _583.data[_595] = _589;
    _586++;
    if (_586 < q)
    goto _jump3674;
    _586 = 0;
    _587++;
    if (_587 < _584)
    goto _jump3674;
    _587 = 0;
    _588++;
    if (_588 < q)
    goto _jump3674;
    // End body of loop
    int64_t _596 = 0;
    _596 *= _573.d0;
    _596 += _582;
    _573.data[_596] = _583;
    _582++;
    if (_582 < _574)
    goto _jump3670;
    // End body of loop
    if (_572.d0 >= 0)
    goto _jump3679;
    fail_assertion("negative array index");
    _jump3679:;
    if (_572.d0 < _573.d0)
    goto _jump3680;
    fail_assertion("index too large");
    _jump3680:;
    int64_t _597 = 0;
    _597 *= _573.d0;
    _597 += _572.d0;
    _a3__a3_bool _598 = _573.data[_597];
    _a3_bool _599 = _238.b;
    int64_t _600;
    // Computing bound for z
    if (q > 0) 
    goto _jump3681;
    fail_assertion("non-positive loop bound");
    _jump3681:;
    _600 = 0;
    int64_t _601 = 0; // z
    _jump3682:; // Begin body of loop
    _600 += q;
    _601++;
    if (_601 < q)
    goto _jump3682;
    // End body of loop
    int64_t _602 = -_572.d0;
    if (c >= 0)
    goto _jump3683;
    fail_assertion("negative array index");
    _jump3683:;
    if (c < _599.d0)
    goto _jump3684;
    fail_assertion("index too large");
    _jump3684:;
    if (_600 >= 0)
    goto _jump3685;
    fail_assertion("negative array index");
    _jump3685:;
    if (_600 < _599.d1)
    goto _jump3686;
    fail_assertion("index too large");
    _jump3686:;
    if (_602 >= 0)
    goto _jump3687;
    fail_assertion("negative array index");
    _jump3687:;
    if (_602 < _599.d2)
    goto _jump3688;
    fail_assertion("index too large");
    _jump3688:;
    int64_t _603 = 0;
    _603 *= _599.d0;
    _603 += c;
    _603 *= _599.d1;
    _603 += _600;
    _603 *= _599.d2;
    _603 += _602;
    bool _604 = _599.data[_603];
    _a1_int64_t _605;
    if (!_604)
    goto _jump3689;
    bool _606 = i(_572.d0);
    _a1_int64_t _607;
    if (!_606)
    goto _jump3690;
    _a1_int64_t _608;
    // Computing bound for z
    int64_t _609 = 931;
    _608.d0 = _609;
    if (_609 > 0) 
    goto _jump3691;
    fail_assertion("non-positive loop bound");
    _jump3691:;
    // Computing total size of heap memory to allocate
    int64_t _610 = 1;
    _610 *= _609;
    _610 *= sizeof(int64_t);
    _608.data = jpl_alloc(_610);
    int64_t _611 = 0; // z
    _jump3692:; // Begin body of loop
    int64_t _612 = 0;
    _612 *= _608.d0;
    _612 += _611;
    _608.data[_612] = _572.d0;
    _611++;
    if (_611 < _609)
    goto _jump3692;
    // End body of loop
    _607 = _608;
    goto _jump3693;
    _jump3690:;
    _a1_int64_t _613;
    _613.d0 = 1;
    _613.data = jpl_alloc(sizeof(int64_t) * 1);
    _613.data[0] = q;
    _607 = _613;
    _jump3693:;
    _605 = _607;
    goto _jump3694;
    _jump3689:;
    _a1_int64_t _614;
    _614.d0 = 2;
    _614.data = jpl_alloc(sizeof(int64_t) * 2);
    _614.data[0] = _572.d1;
    _614.data[1] = _572.d1;
    _605 = _614;
    _jump3694:;
    int64_t _615;
    // Computing bound for z
    if (q > 0) 
    goto _jump3695;
    fail_assertion("non-positive loop bound");
    _jump3695:;
    _615 = 0;
    int64_t _616 = 0; // z
    _jump3696:; // Begin body of loop
    _615 += _616;
    _616++;
    if (_616 < q)
    goto _jump3696;
    // End body of loop
    int64_t _617 = 798;
    int64_t _618 = _615 * _617;
    if (_618 >= 0)
    goto _jump3697;
    fail_assertion("negative array index");
    _jump3697:;
    if (_618 < _605.d0)
    goto _jump3698;
    fail_assertion("index too large");
    _jump3698:;
    int64_t _619 = 0;
    _619 *= _605.d0;
    _619 += _618;
    int64_t _620 = _605.data[_619];
    o _621 = r();
    bool _622 = _621.c;
    bool _623;
    if (!_622)
    goto _jump3699;
    bool _624 = i(d);
    bool _625;
    if (!_624)
    goto _jump3700;
    o _626 = r();
    bool _627 = _626.c;
    _625 = _627;
    goto _jump3701;
    _jump3700:;
    bool _628 = true;
    bool _629 = !_628;
    _625 = _629;
    _jump3701:;
    _623 = _625;
    goto _jump3702;
    _jump3699:;
    rgba _630 = m();
    o _631 = { _238, _630, n };
    bool _632 = _631.c;
    _623 = _632;
    _jump3702:;
    int64_t _633;
    if (!_623)
    goto _jump3703;
    int64_t _634 = 444;
    _633 = _634;
    goto _jump3704;
    _jump3703:;
    int64_t _635;
    // Computing bound for z
    _a1_int64_t _636;
    _636.d0 = 1;
    _636.data = jpl_alloc(sizeof(int64_t) * 1);
    _636.data[0] = _572.d0;
    if (c >= 0)
    goto _jump3705;
    fail_assertion("negative array index");
    _jump3705:;
    if (c < _636.d0)
    goto _jump3706;
    fail_assertion("index too large");
    _jump3706:;
    int64_t _637 = 0;
    _637 *= _636.d0;
    _637 += c;
    int64_t _638 = _636.data[_637];
    if (_638 > 0) 
    goto _jump3707;
    fail_assertion("non-positive loop bound");
    _jump3707:;
    _635 = 0;
    int64_t _639 = 0; // z
    _jump3708:; // Begin body of loop
    _635 += c;
    _639++;
    if (_639 < _638)
    goto _jump3708;
    // End body of loop
    _633 = _635;
    _jump3704:;
    if (_620 >= 0)
    goto _jump3709;
    fail_assertion("negative array index");
    _jump3709:;
    if (_620 < _598.d0)
    goto _jump3710;
    fail_assertion("index too large");
    _jump3710:;
    if (_572.d0 >= 0)
    goto _jump3711;
    fail_assertion("negative array index");
    _jump3711:;
    if (_572.d0 < _598.d1)
    goto _jump3712;
    fail_assertion("index too large");
    _jump3712:;
    if (_633 >= 0)
    goto _jump3713;
    fail_assertion("negative array index");
    _jump3713:;
    if (_633 < _598.d2)
    goto _jump3714;
    fail_assertion("index too large");
    _jump3714:;
    int64_t _640 = 0;
    _640 *= _598.d0;
    _640 += _620;
    _640 *= _598.d1;
    _640 += _572.d0;
    _640 *= _598.d2;
    _640 += _633;
    _a3_bool _641 = _598.data[_640];
    int64_t _642;
    // Computing bound for z
    if (_572.d1 > 0) 
    goto _jump3715;
    fail_assertion("non-positive loop bound");
    _jump3715:;
    // Computing bound for A
    int64_t _643;
    // Computing bound for z
    if (q > 0) 
    goto _jump3716;
    fail_assertion("non-positive loop bound");
    _jump3716:;
    // Computing bound for A
    if (_572.d1 > 0) 
    goto _jump3717;
    fail_assertion("non-positive loop bound");
    _jump3717:;
    _643 = 0;
    int64_t _644 = 0; // A
    int64_t _645 = 0; // z
    _jump3718:; // Begin body of loop
    bool _646 = n;
    if (0 != n)
    goto _jump3719;
    bool _647 = i(_572.d0);
    _646 = _647;
    _jump3719:;
    int64_t _648;
    if (!_646)
    goto _jump3720;
    _648 = _572.d1;
    goto _jump3721;
    _jump3720:;
    _648 = _572.d1;
    _jump3721:;
    _643 += _648;
    _644++;
    if (_644 < _572.d1)
    goto _jump3718;
    _644 = 0;
    _645++;
    if (_645 < q)
    goto _jump3718;
    // End body of loop
    if (_643 > 0) 
    goto _jump3722;
    fail_assertion("non-positive loop bound");
    _jump3722:;
    // Computing bound for B
    if (_572.d2 > 0) 
    goto _jump3723;
    fail_assertion("non-positive loop bound");
    _jump3723:;
    _642 = 0;
    int64_t _649 = 0; // B
    int64_t _650 = 0; // A
    int64_t _651 = 0; // z
    _jump3724:; // Begin body of loop
    _a3_int64_t _652;
    // Computing bound for C
    int64_t _653 = -q;
    _652.d0 = _653;
    if (_653 > 0) 
    goto _jump3725;
    fail_assertion("non-positive loop bound");
    _jump3725:;
    // Computing bound for D
    _652.d1 = _651;
    if (_651 > 0) 
    goto _jump3726;
    fail_assertion("non-positive loop bound");
    _jump3726:;
    // Computing bound for E
    int64_t _654 = -_650;
    int64_t _655 = _654 + _651;
    _652.d2 = _655;
    if (_655 > 0) 
    goto _jump3727;
    fail_assertion("non-positive loop bound");
    _jump3727:;
    // Computing total size of heap memory to allocate
    int64_t _656 = 1;
    _656 *= _653;
    _656 *= _651;
    _656 *= _655;
    _656 *= sizeof(int64_t);
    _652.data = jpl_alloc(_656);
    int64_t _657 = 0; // E
    int64_t _658 = 0; // D
    int64_t _659 = 0; // C
    _jump3728:; // Begin body of loop
    int64_t _660;
    // Computing bound for F
    if (_649 > 0) 
    goto _jump3729;
    fail_assertion("non-positive loop bound");
    _jump3729:;
    // Computing bound for G
    if (_659 > 0) 
    goto _jump3730;
    fail_assertion("non-positive loop bound");
    _jump3730:;
    _660 = 0;
    int64_t _661 = 0; // G
    int64_t _662 = 0; // F
    _jump3731:; // Begin body of loop
    _660 += _651;
    _661++;
    if (_661 < _659)
    goto _jump3731;
    _661 = 0;
    _662++;
    if (_662 < _649)
    goto _jump3731;
    // End body of loop
    int64_t _663 = _660 * c;
    int64_t _664 = 0;
    _664 *= _652.d0;
    _664 += _659;
    _664 *= _652.d1;
    _664 += _658;
    _664 *= _652.d2;
    _664 += _657;
    _652.data[_664] = _663;
    _657++;
    if (_657 < _655)
    goto _jump3728;
    _657 = 0;
    _658++;
    if (_658 < _651)
    goto _jump3728;
    _658 = 0;
    _659++;
    if (_659 < _653)
    goto _jump3728;
    // End body of loop
    int64_t _665 = 464;
    if (_649 >= 0)
    goto _jump3732;
    fail_assertion("negative array index");
    _jump3732:;
    if (_649 < _652.d0)
    goto _jump3733;
    fail_assertion("index too large");
    _jump3733:;
    if (d >= 0)
    goto _jump3734;
    fail_assertion("negative array index");
    _jump3734:;
    if (d < _652.d1)
    goto _jump3735;
    fail_assertion("index too large");
    _jump3735:;
    if (_665 >= 0)
    goto _jump3736;
    fail_assertion("negative array index");
    _jump3736:;
    if (_665 < _652.d2)
    goto _jump3737;
    fail_assertion("index too large");
    _jump3737:;
    int64_t _666 = 0;
    _666 *= _652.d0;
    _666 += _649;
    _666 *= _652.d1;
    _666 += d;
    _666 *= _652.d2;
    _666 += _665;
    int64_t _667 = _652.data[_666];
    _642 += _667;
    _649++;
    if (_649 < _572.d2)
    goto _jump3724;
    _649 = 0;
    _650++;
    if (_650 < _643)
    goto _jump3724;
    _650 = 0;
    _651++;
    if (_651 < _572.d1)
    goto _jump3724;
    // End body of loop
    if (_572.d1 >= 0)
    goto _jump3738;
    fail_assertion("negative array index");
    _jump3738:;
    if (_572.d1 < _641.d0)
    goto _jump3739;
    fail_assertion("index too large");
    _jump3739:;
    if (_642 >= 0)
    goto _jump3740;
    fail_assertion("negative array index");
    _jump3740:;
    if (_642 < _641.d1)
    goto _jump3741;
    fail_assertion("index too large");
    _jump3741:;
    if (_572.d1 >= 0)
    goto _jump3742;
    fail_assertion("negative array index");
    _jump3742:;
    if (_572.d1 < _641.d2)
    goto _jump3743;
    fail_assertion("index too large");
    _jump3743:;
    int64_t _668 = 0;
    _668 *= _641.d0;
    _668 += _572.d1;
    _668 *= _641.d1;
    _668 += _642;
    _668 *= _641.d2;
    _668 += _572.d1;
    bool _669 = _641.data[_668];
    bool _670 = !_669;
    bool _671 = false;
    o _672;
    if (!_671)
    goto _jump3744;
    bool _673 = i(q);
    o _674;
    if (!_673)
    goto _jump3745;
    if (c >= 0)
    goto _jump3746;
    fail_assertion("negative array index");
    _jump3746:;
    if (c < p.d0)
    goto _jump3747;
    fail_assertion("index too large");
    _jump3747:;
    int64_t _675 = 0;
    _675 *= p.d0;
    _675 += c;
    o _676 = p.data[_675];
    _674 = _676;
    goto _jump3748;
    _jump3745:;
    bool _677 = false;
    o _678;
    if (!_677)
    goto _jump3749;
    o _679 = r();
    _678 = _679;
    goto _jump3750;
    _jump3749:;
    o _680 = r();
    _678 = _680;
    _jump3750:;
    _674 = _678;
    _jump3748:;
    _672 = _674;
    goto _jump3751;
    _jump3744:;
    o _681 = r();
    _672 = _681;
    _jump3751:;
    bool _682 = _672.c;
    _a3_int64_t _683;
    if (!_682)
    goto _jump3752;
    _a2__a3_int64_t _684;
    // Computing bound for A
    _684.d0 = q;
    if (q > 0) 
    goto _jump3753;
    fail_assertion("non-positive loop bound");
    _jump3753:;
    // Computing bound for B
    _684.d1 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3754;
    fail_assertion("non-positive loop bound");
    _jump3754:;
    // Computing total size of heap memory to allocate
    int64_t _685 = 1;
    _685 *= q;
    _685 *= _572.d2;
    _685 *= sizeof(_a3_int64_t);
    _684.data = jpl_alloc(_685);
    int64_t _686 = 0; // B
    int64_t _687 = 0; // A
    _jump3755:; // Begin body of loop
    _a3_int64_t _688;
    // Computing bound for C
    _688.d0 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3756;
    fail_assertion("non-positive loop bound");
    _jump3756:;
    // Computing bound for D
    _688.d1 = _687;
    if (_687 > 0) 
    goto _jump3757;
    fail_assertion("non-positive loop bound");
    _jump3757:;
    // Computing bound for E
    _688.d2 = _686;
    if (_686 > 0) 
    goto _jump3758;
    fail_assertion("non-positive loop bound");
    _jump3758:;
    // Computing total size of heap memory to allocate
    int64_t _689 = 1;
    _689 *= _572.d2;
    _689 *= _687;
    _689 *= _686;
    _689 *= sizeof(int64_t);
    _688.data = jpl_alloc(_689);
    int64_t _690 = 0; // E
    int64_t _691 = 0; // D
    int64_t _692 = 0; // C
    _jump3759:; // Begin body of loop
    int64_t _693 = 0;
    _693 *= _688.d0;
    _693 += _692;
    _693 *= _688.d1;
    _693 += _691;
    _693 *= _688.d2;
    _693 += _690;
    _688.data[_693] = _572.d1;
    _690++;
    if (_690 < _686)
    goto _jump3759;
    _690 = 0;
    _691++;
    if (_691 < _687)
    goto _jump3759;
    _691 = 0;
    _692++;
    if (_692 < _572.d2)
    goto _jump3759;
    // End body of loop
    int64_t _694 = 0;
    _694 *= _684.d0;
    _694 += _687;
    _694 *= _684.d1;
    _694 += _686;
    _684.data[_694] = _688;
    _686++;
    if (_686 < _572.d2)
    goto _jump3755;
    _686 = 0;
    _687++;
    if (_687 < q)
    goto _jump3755;
    // End body of loop
    if (c >= 0)
    goto _jump3760;
    fail_assertion("negative array index");
    _jump3760:;
    if (c < _684.d0)
    goto _jump3761;
    fail_assertion("index too large");
    _jump3761:;
    if (_572.d0 >= 0)
    goto _jump3762;
    fail_assertion("negative array index");
    _jump3762:;
    if (_572.d0 < _684.d1)
    goto _jump3763;
    fail_assertion("index too large");
    _jump3763:;
    int64_t _695 = 0;
    _695 *= _684.d0;
    _695 += c;
    _695 *= _684.d1;
    _695 += _572.d0;
    _a3_int64_t _696 = _684.data[_695];
    _683 = _696;
    goto _jump3764;
    _jump3752:;
    _a3_int64_t _697;
    // Computing bound for A
    int64_t _698;
    // Computing bound for A
    if (q > 0) 
    goto _jump3765;
    fail_assertion("non-positive loop bound");
    _jump3765:;
    // Computing bound for B
    int64_t _699;
    // Computing bound for A
    if (_572.d1 > 0) 
    goto _jump3766;
    fail_assertion("non-positive loop bound");
    _jump3766:;
    // Computing bound for B
    if (_572.d1 > 0) 
    goto _jump3767;
    fail_assertion("non-positive loop bound");
    _jump3767:;
    // Computing bound for C
    if (_572.d0 > 0) 
    goto _jump3768;
    fail_assertion("non-positive loop bound");
    _jump3768:;
    _699 = 0;
    int64_t _700 = 0; // C
    int64_t _701 = 0; // B
    int64_t _702 = 0; // A
    _jump3769:; // Begin body of loop
    _699 += _572.d2;
    _700++;
    if (_700 < _572.d0)
    goto _jump3769;
    _700 = 0;
    _701++;
    if (_701 < _572.d1)
    goto _jump3769;
    _701 = 0;
    _702++;
    if (_702 < _572.d1)
    goto _jump3769;
    // End body of loop
    int64_t _703;
    // Computing bound for A
    if (q > 0) 
    goto _jump3770;
    fail_assertion("non-positive loop bound");
    _jump3770:;
    // Computing bound for B
    if (q > 0) 
    goto _jump3771;
    fail_assertion("non-positive loop bound");
    _jump3771:;
    _703 = 0;
    int64_t _704 = 0; // B
    int64_t _705 = 0; // A
    _jump3772:; // Begin body of loop
    _703 += _572.d0;
    _704++;
    if (_704 < q)
    goto _jump3772;
    _704 = 0;
    _705++;
    if (_705 < q)
    goto _jump3772;
    // End body of loop
    int64_t _706 = _699 * _703;
    if (_706 > 0) 
    goto _jump3773;
    fail_assertion("non-positive loop bound");
    _jump3773:;
    // Computing bound for C
    int64_t _707;
    // Computing bound for A
    if (_572.d1 > 0) 
    goto _jump3774;
    fail_assertion("non-positive loop bound");
    _jump3774:;
    // Computing bound for B
    if (_572.d1 > 0) 
    goto _jump3775;
    fail_assertion("non-positive loop bound");
    _jump3775:;
    _707 = 0;
    int64_t _708 = 0; // B
    int64_t _709 = 0; // A
    _jump3776:; // Begin body of loop
    _707 += q;
    _708++;
    if (_708 < _572.d1)
    goto _jump3776;
    _708 = 0;
    _709++;
    if (_709 < _572.d1)
    goto _jump3776;
    // End body of loop
    if (_707 > 0) 
    goto _jump3777;
    fail_assertion("non-positive loop bound");
    _jump3777:;
    _698 = 0;
    int64_t _710 = 0; // C
    int64_t _711 = 0; // B
    int64_t _712 = 0; // A
    _jump3778:; // Begin body of loop
    _698 += _572.d2;
    _710++;
    if (_710 < _707)
    goto _jump3778;
    _710 = 0;
    _711++;
    if (_711 < _706)
    goto _jump3778;
    _711 = 0;
    _712++;
    if (_712 < q)
    goto _jump3778;
    // End body of loop
    _697.d0 = _698;
    if (_698 > 0) 
    goto _jump3779;
    fail_assertion("non-positive loop bound");
    _jump3779:;
    // Computing bound for B
    int64_t _713;
    // Computing bound for A
    int64_t _714 = 680;
    _a1_int64_t _715;
    _715.d0 = 1;
    _715.data = jpl_alloc(sizeof(int64_t) * 1);
    _715.data[0] = _714;
    if (_572.d1 >= 0)
    goto _jump3780;
    fail_assertion("negative array index");
    _jump3780:;
    if (_572.d1 < _715.d0)
    goto _jump3781;
    fail_assertion("index too large");
    _jump3781:;
    int64_t _716 = 0;
    _716 *= _715.d0;
    _716 += _572.d1;
    int64_t _717 = _715.data[_716];
    if (_717 > 0) 
    goto _jump3782;
    fail_assertion("non-positive loop bound");
    _jump3782:;
    _713 = 0;
    int64_t _718 = 0; // A
    _jump3783:; // Begin body of loop
    _713 += q;
    _718++;
    if (_718 < _717)
    goto _jump3783;
    // End body of loop
    _697.d1 = _713;
    if (_713 > 0) 
    goto _jump3784;
    fail_assertion("non-positive loop bound");
    _jump3784:;
    // Computing bound for C
    bool _719 = _238.a;
    _a3_int64_t _720;
    if (!_719)
    goto _jump3785;
    _a3_int64_t _721;
    // Computing bound for A
    _721.d0 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3786;
    fail_assertion("non-positive loop bound");
    _jump3786:;
    // Computing bound for B
    _721.d1 = c;
    if (c > 0) 
    goto _jump3787;
    fail_assertion("non-positive loop bound");
    _jump3787:;
    // Computing bound for C
    _721.d2 = _572.d1;
    if (_572.d1 > 0) 
    goto _jump3788;
    fail_assertion("non-positive loop bound");
    _jump3788:;
    // Computing total size of heap memory to allocate
    int64_t _722 = 1;
    _722 *= _572.d2;
    _722 *= c;
    _722 *= _572.d1;
    _722 *= sizeof(int64_t);
    _721.data = jpl_alloc(_722);
    int64_t _723 = 0; // C
    int64_t _724 = 0; // B
    int64_t _725 = 0; // A
    _jump3789:; // Begin body of loop
    int64_t _726 = 0;
    _726 *= _721.d0;
    _726 += _725;
    _726 *= _721.d1;
    _726 += _724;
    _726 *= _721.d2;
    _726 += _723;
    _721.data[_726] = _572.d2;
    _723++;
    if (_723 < _572.d1)
    goto _jump3789;
    _723 = 0;
    _724++;
    if (_724 < c)
    goto _jump3789;
    _724 = 0;
    _725++;
    if (_725 < _572.d2)
    goto _jump3789;
    // End body of loop
    _720 = _721;
    goto _jump3790;
    _jump3785:;
    _a3_int64_t _727;
    // Computing bound for A
    _727.d0 = _572.d1;
    if (_572.d1 > 0) 
    goto _jump3791;
    fail_assertion("non-positive loop bound");
    _jump3791:;
    // Computing bound for B
    _727.d1 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3792;
    fail_assertion("non-positive loop bound");
    _jump3792:;
    // Computing bound for C
    int64_t _728 = 765;
    _727.d2 = _728;
    if (_728 > 0) 
    goto _jump3793;
    fail_assertion("non-positive loop bound");
    _jump3793:;
    // Computing total size of heap memory to allocate
    int64_t _729 = 1;
    _729 *= _572.d1;
    _729 *= _572.d0;
    _729 *= _728;
    _729 *= sizeof(int64_t);
    _727.data = jpl_alloc(_729);
    int64_t _730 = 0; // C
    int64_t _731 = 0; // B
    int64_t _732 = 0; // A
    _jump3794:; // Begin body of loop
    int64_t _733 = 69;
    int64_t _734 = 0;
    _734 *= _727.d0;
    _734 += _732;
    _734 *= _727.d1;
    _734 += _731;
    _734 *= _727.d2;
    _734 += _730;
    _727.data[_734] = _733;
    _730++;
    if (_730 < _728)
    goto _jump3794;
    _730 = 0;
    _731++;
    if (_731 < _572.d0)
    goto _jump3794;
    _731 = 0;
    _732++;
    if (_732 < _572.d1)
    goto _jump3794;
    // End body of loop
    _720 = _727;
    _jump3790:;
    int64_t _735 = _572.d0 + _572.d0;
    int64_t _736 = -d;
    int64_t _737 = -_572.d0;
    int64_t _738 = _736 + _737;
    if (_735 >= 0)
    goto _jump3795;
    fail_assertion("negative array index");
    _jump3795:;
    if (_735 < _720.d0)
    goto _jump3796;
    fail_assertion("index too large");
    _jump3796:;
    if (_738 >= 0)
    goto _jump3797;
    fail_assertion("negative array index");
    _jump3797:;
    if (_738 < _720.d1)
    goto _jump3798;
    fail_assertion("index too large");
    _jump3798:;
    if (_572.d2 >= 0)
    goto _jump3799;
    fail_assertion("negative array index");
    _jump3799:;
    if (_572.d2 < _720.d2)
    goto _jump3800;
    fail_assertion("index too large");
    _jump3800:;
    int64_t _739 = 0;
    _739 *= _720.d0;
    _739 += _735;
    _739 *= _720.d1;
    _739 += _738;
    _739 *= _720.d2;
    _739 += _572.d2;
    int64_t _740 = _720.data[_739];
    _697.d2 = _740;
    if (_740 > 0) 
    goto _jump3801;
    fail_assertion("non-positive loop bound");
    _jump3801:;
    // Computing total size of heap memory to allocate
    int64_t _741 = 1;
    _741 *= _698;
    _741 *= _713;
    _741 *= _740;
    _741 *= sizeof(int64_t);
    _697.data = jpl_alloc(_741);
    int64_t _742 = 0; // C
    int64_t _743 = 0; // B
    int64_t _744 = 0; // A
    _jump3802:; // Begin body of loop
    _a3_int64_t _745;
    // Computing bound for D
    _745.d0 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3803;
    fail_assertion("non-positive loop bound");
    _jump3803:;
    // Computing bound for E
    _745.d1 = _742;
    if (_742 > 0) 
    goto _jump3804;
    fail_assertion("non-positive loop bound");
    _jump3804:;
    // Computing bound for F
    int64_t _746 = _742 * _744;
    _745.d2 = _746;
    if (_746 > 0) 
    goto _jump3805;
    fail_assertion("non-positive loop bound");
    _jump3805:;
    // Computing total size of heap memory to allocate
    int64_t _747 = 1;
    _747 *= _572.d2;
    _747 *= _742;
    _747 *= _746;
    _747 *= sizeof(int64_t);
    _745.data = jpl_alloc(_747);
    int64_t _748 = 0; // F
    int64_t _749 = 0; // E
    int64_t _750 = 0; // D
    _jump3806:; // Begin body of loop
    int64_t _751 = _749 - _742;
    int64_t _752 = 0;
    _752 *= _745.d0;
    _752 += _750;
    _752 *= _745.d1;
    _752 += _749;
    _752 *= _745.d2;
    _752 += _748;
    _745.data[_752] = _751;
    _748++;
    if (_748 < _746)
    goto _jump3806;
    _748 = 0;
    _749++;
    if (_749 < _742)
    goto _jump3806;
    _749 = 0;
    _750++;
    if (_750 < _572.d2)
    goto _jump3806;
    // End body of loop
    int64_t _753;
    // Computing bound for D
    if (_744 > 0) 
    goto _jump3807;
    fail_assertion("non-positive loop bound");
    _jump3807:;
    _753 = 0;
    int64_t _754 = 0; // D
    _jump3808:; // Begin body of loop
    _753 += d;
    _754++;
    if (_754 < _744)
    goto _jump3808;
    // End body of loop
    int64_t _755 = 803;
    if (_572.d2 >= 0)
    goto _jump3809;
    fail_assertion("negative array index");
    _jump3809:;
    if (_572.d2 < f.d0)
    goto _jump3810;
    fail_assertion("index too large");
    _jump3810:;
    if (_743 >= 0)
    goto _jump3811;
    fail_assertion("negative array index");
    _jump3811:;
    if (_743 < f.d1)
    goto _jump3812;
    fail_assertion("index too large");
    _jump3812:;
    int64_t _756 = 0;
    _756 *= f.d0;
    _756 += _572.d2;
    _756 *= f.d1;
    _756 += _743;
    int64_t _757 = f.data[_756];
    if (_753 >= 0)
    goto _jump3813;
    fail_assertion("negative array index");
    _jump3813:;
    if (_753 < _745.d0)
    goto _jump3814;
    fail_assertion("index too large");
    _jump3814:;
    if (_755 >= 0)
    goto _jump3815;
    fail_assertion("negative array index");
    _jump3815:;
    if (_755 < _745.d1)
    goto _jump3816;
    fail_assertion("index too large");
    _jump3816:;
    if (_757 >= 0)
    goto _jump3817;
    fail_assertion("negative array index");
    _jump3817:;
    if (_757 < _745.d2)
    goto _jump3818;
    fail_assertion("index too large");
    _jump3818:;
    int64_t _758 = 0;
    _758 *= _745.d0;
    _758 += _753;
    _758 *= _745.d1;
    _758 += _755;
    _758 *= _745.d2;
    _758 += _757;
    int64_t _759 = _745.data[_758];
    int64_t _760 = 0;
    _760 *= _697.d0;
    _760 += _744;
    _760 *= _697.d1;
    _760 += _743;
    _760 *= _697.d2;
    _760 += _742;
    _697.data[_760] = _759;
    _742++;
    if (_742 < _740)
    goto _jump3802;
    _742 = 0;
    _743++;
    if (_743 < _713)
    goto _jump3802;
    _743 = 0;
    _744++;
    if (_744 < _698)
    goto _jump3802;
    // End body of loop
    _683 = _697;
    _jump3764:;
    if (_572.d0 >= 0)
    goto _jump3819;
    fail_assertion("negative array index");
    _jump3819:;
    if (_572.d0 < f.d0)
    goto _jump3820;
    fail_assertion("index too large");
    _jump3820:;
    if (q >= 0)
    goto _jump3821;
    fail_assertion("negative array index");
    _jump3821:;
    if (q < f.d1)
    goto _jump3822;
    fail_assertion("index too large");
    _jump3822:;
    int64_t _761 = 0;
    _761 *= f.d0;
    _761 += _572.d0;
    _761 *= f.d1;
    _761 += q;
    int64_t _762 = f.data[_761];
    int64_t _763;
    // Computing bound for A
    if (_572.d2 > 0) 
    goto _jump3823;
    fail_assertion("non-positive loop bound");
    _jump3823:;
    _763 = 0;
    int64_t _764 = 0; // A
    _jump3824:; // Begin body of loop
    _763 += _572.d1;
    _764++;
    if (_764 < _572.d2)
    goto _jump3824;
    // End body of loop
    if (_762 >= 0)
    goto _jump3825;
    fail_assertion("negative array index");
    _jump3825:;
    if (_762 < f.d0)
    goto _jump3826;
    fail_assertion("index too large");
    _jump3826:;
    if (_763 >= 0)
    goto _jump3827;
    fail_assertion("negative array index");
    _jump3827:;
    if (_763 < f.d1)
    goto _jump3828;
    fail_assertion("index too large");
    _jump3828:;
    int64_t _765 = 0;
    _765 *= f.d0;
    _765 += _762;
    _765 *= f.d1;
    _765 += _763;
    int64_t _766 = f.data[_765];
    int64_t _767 = -_766;
    int64_t _768 = c - _767;
    _a3_int64_t _769;
    // Computing bound for A
    _769.d0 = c;
    if (c > 0) 
    goto _jump3829;
    fail_assertion("non-positive loop bound");
    _jump3829:;
    // Computing bound for B
    int64_t _770 = d * c;
    _769.d1 = _770;
    if (_770 > 0) 
    goto _jump3830;
    fail_assertion("non-positive loop bound");
    _jump3830:;
    // Computing bound for C
    _769.d2 = d;
    if (d > 0) 
    goto _jump3831;
    fail_assertion("non-positive loop bound");
    _jump3831:;
    // Computing total size of heap memory to allocate
    int64_t _771 = 1;
    _771 *= c;
    _771 *= _770;
    _771 *= d;
    _771 *= sizeof(int64_t);
    _769.data = jpl_alloc(_771);
    int64_t _772 = 0; // C
    int64_t _773 = 0; // B
    int64_t _774 = 0; // A
    _jump3832:; // Begin body of loop
    _a3_int64_t _775;
    // Computing bound for D
    int64_t _776 = 507;
    int64_t _777 = _776 / d;
    _775.d0 = _777;
    if (_777 > 0) 
    goto _jump3833;
    fail_assertion("non-positive loop bound");
    _jump3833:;
    // Computing bound for E
    _775.d1 = _572.d1;
    if (_572.d1 > 0) 
    goto _jump3834;
    fail_assertion("non-positive loop bound");
    _jump3834:;
    // Computing bound for F
    _775.d2 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3835;
    fail_assertion("non-positive loop bound");
    _jump3835:;
    // Computing total size of heap memory to allocate
    int64_t _778 = 1;
    _778 *= _777;
    _778 *= _572.d1;
    _778 *= _572.d0;
    _778 *= sizeof(int64_t);
    _775.data = jpl_alloc(_778);
    int64_t _779 = 0; // F
    int64_t _780 = 0; // E
    int64_t _781 = 0; // D
    _jump3836:; // Begin body of loop
    int64_t _782 = 0;
    _782 *= _775.d0;
    _782 += _781;
    _782 *= _775.d1;
    _782 += _780;
    _782 *= _775.d2;
    _782 += _779;
    _775.data[_782] = _772;
    _779++;
    if (_779 < _572.d0)
    goto _jump3836;
    _779 = 0;
    _780++;
    if (_780 < _572.d1)
    goto _jump3836;
    _780 = 0;
    _781++;
    if (_781 < _777)
    goto _jump3836;
    // End body of loop
    if (_773 >= 0)
    goto _jump3837;
    fail_assertion("negative array index");
    _jump3837:;
    if (_773 < _775.d0)
    goto _jump3838;
    fail_assertion("index too large");
    _jump3838:;
    if (c >= 0)
    goto _jump3839;
    fail_assertion("negative array index");
    _jump3839:;
    if (c < _775.d1)
    goto _jump3840;
    fail_assertion("index too large");
    _jump3840:;
    if (_773 >= 0)
    goto _jump3841;
    fail_assertion("negative array index");
    _jump3841:;
    if (_773 < _775.d2)
    goto _jump3842;
    fail_assertion("index too large");
    _jump3842:;
    int64_t _783 = 0;
    _783 *= _775.d0;
    _783 += _773;
    _783 *= _775.d1;
    _783 += c;
    _783 *= _775.d2;
    _783 += _773;
    int64_t _784 = _775.data[_783];
    int64_t _785 = 0;
    _785 *= _769.d0;
    _785 += _774;
    _785 *= _769.d1;
    _785 += _773;
    _785 *= _769.d2;
    _785 += _772;
    _769.data[_785] = _784;
    _772++;
    if (_772 < d)
    goto _jump3832;
    _772 = 0;
    _773++;
    if (_773 < _770)
    goto _jump3832;
    _773 = 0;
    _774++;
    if (_774 < c)
    goto _jump3832;
    // End body of loop
    int64_t _786 = 209;
    int64_t _787 = -_572.d1;
    if (_786 >= 0)
    goto _jump3843;
    fail_assertion("negative array index");
    _jump3843:;
    if (_786 < _769.d0)
    goto _jump3844;
    fail_assertion("index too large");
    _jump3844:;
    if (q >= 0)
    goto _jump3845;
    fail_assertion("negative array index");
    _jump3845:;
    if (q < _769.d1)
    goto _jump3846;
    fail_assertion("index too large");
    _jump3846:;
    if (_787 >= 0)
    goto _jump3847;
    fail_assertion("negative array index");
    _jump3847:;
    if (_787 < _769.d2)
    goto _jump3848;
    fail_assertion("index too large");
    _jump3848:;
    int64_t _788 = 0;
    _788 *= _769.d0;
    _788 += _786;
    _788 *= _769.d1;
    _788 += q;
    _788 *= _769.d2;
    _788 += _787;
    int64_t _789 = _769.data[_788];
    if (_768 >= 0)
    goto _jump3849;
    fail_assertion("negative array index");
    _jump3849:;
    if (_768 < _683.d0)
    goto _jump3850;
    fail_assertion("index too large");
    _jump3850:;
    if (q >= 0)
    goto _jump3851;
    fail_assertion("negative array index");
    _jump3851:;
    if (q < _683.d1)
    goto _jump3852;
    fail_assertion("index too large");
    _jump3852:;
    if (_789 >= 0)
    goto _jump3853;
    fail_assertion("negative array index");
    _jump3853:;
    if (_789 < _683.d2)
    goto _jump3854;
    fail_assertion("index too large");
    _jump3854:;
    int64_t _790 = 0;
    _790 *= _683.d0;
    _790 += _768;
    _790 *= _683.d1;
    _790 += q;
    _790 *= _683.d2;
    _790 += _789;
    int64_t _791 = _683.data[_790];
    _a2_void_t _792;
    // Computing bound for A
    _792.d0 = q;
    if (q > 0) 
    goto _jump3855;
    fail_assertion("non-positive loop bound");
    _jump3855:;
    // Computing bound for B
    _792.d1 = c;
    if (c > 0) 
    goto _jump3856;
    fail_assertion("non-positive loop bound");
    _jump3856:;
    // Computing total size of heap memory to allocate
    int64_t _793 = 1;
    _793 *= q;
    _793 *= c;
    _793 *= sizeof(void_t);
    _792.data = jpl_alloc(_793);
    int64_t _794 = 0; // B
    int64_t _795 = 0; // A
    _jump3857:; // Begin body of loop
    _a1_void_t _796;
    // Computing bound for C
    _796.d0 = q;
    if (q > 0) 
    goto _jump3858;
    fail_assertion("non-positive loop bound");
    _jump3858:;
    // Computing total size of heap memory to allocate
    int64_t _797 = 1;
    _797 *= q;
    _797 *= sizeof(void_t);
    _796.data = jpl_alloc(_797);
    int64_t _798 = 0; // C
    _jump3859:; // Begin body of loop
    o _799 = r();
    bool _800 = _799.c;
    void_t _801;
    if (!_800)
    goto _jump3860;
    _a3_double _802;
    // Computing bound for D
    _802.d0 = _798;
    if (_798 > 0) 
    goto _jump3861;
    fail_assertion("non-positive loop bound");
    _jump3861:;
    // Computing bound for E
    _802.d1 = c;
    if (c > 0) 
    goto _jump3862;
    fail_assertion("non-positive loop bound");
    _jump3862:;
    // Computing bound for F
    _802.d2 = _794;
    if (_794 > 0) 
    goto _jump3863;
    fail_assertion("non-positive loop bound");
    _jump3863:;
    // Computing total size of heap memory to allocate
    int64_t _803 = 1;
    _803 *= _798;
    _803 *= c;
    _803 *= _794;
    _803 *= sizeof(double);
    _802.data = jpl_alloc(_803);
    int64_t _804 = 0; // F
    int64_t _805 = 0; // E
    int64_t _806 = 0; // D
    _jump3864:; // Begin body of loop
    int64_t _807 = 0;
    _807 *= _802.d0;
    _807 += _806;
    _807 *= _802.d1;
    _807 += _805;
    _807 *= _802.d2;
    _807 += _804;
    _802.data[_807] = g;
    _804++;
    if (_804 < _794)
    goto _jump3864;
    _804 = 0;
    _805++;
    if (_805 < c)
    goto _jump3864;
    _805 = 0;
    _806++;
    if (_806 < _798)
    goto _jump3864;
    // End body of loop
    rgba _808 = t();
    void_t _809 = s(_802, _808);
    _801 = _809;
    goto _jump3865;
    _jump3860:;
    _a3_double _810;
    // Computing bound for D
    _810.d0 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3866;
    fail_assertion("non-positive loop bound");
    _jump3866:;
    // Computing bound for E
    _810.d1 = _572.d1;
    if (_572.d1 > 0) 
    goto _jump3867;
    fail_assertion("non-positive loop bound");
    _jump3867:;
    // Computing bound for F
    _810.d2 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3868;
    fail_assertion("non-positive loop bound");
    _jump3868:;
    // Computing total size of heap memory to allocate
    int64_t _811 = 1;
    _811 *= _572.d2;
    _811 *= _572.d1;
    _811 *= _572.d0;
    _811 *= sizeof(double);
    _810.data = jpl_alloc(_811);
    int64_t _812 = 0; // F
    int64_t _813 = 0; // E
    int64_t _814 = 0; // D
    _jump3869:; // Begin body of loop
    int64_t _815 = 0;
    _815 *= _810.d0;
    _815 += _814;
    _815 *= _810.d1;
    _815 += _813;
    _815 *= _810.d2;
    _815 += _812;
    _810.data[_815] = g;
    _812++;
    if (_812 < _572.d0)
    goto _jump3869;
    _812 = 0;
    _813++;
    if (_813 < _572.d1)
    goto _jump3869;
    _813 = 0;
    _814++;
    if (_814 < _572.d2)
    goto _jump3869;
    // End body of loop
    rgba _816 = _238.c;
    void_t _817 = s(_810, _816);
    _801 = _817;
    _jump3865:;
    int64_t _818 = 0;
    _818 *= _796.d0;
    _818 += _798;
    _796.data[_818] = _801;
    _798++;
    if (_798 < q)
    goto _jump3859;
    // End body of loop
    int64_t _819 = 450;
    bool _820 = _819 != _572.d1;
    _a3_int64_t _821;
    if (!_820)
    goto _jump3870;
    _a3_int64_t _822;
    // Computing bound for C
    _822.d0 = d;
    if (d > 0) 
    goto _jump3871;
    fail_assertion("non-positive loop bound");
    _jump3871:;
    // Computing bound for D
    _822.d1 = _794;
    if (_794 > 0) 
    goto _jump3872;
    fail_assertion("non-positive loop bound");
    _jump3872:;
    // Computing bound for E
    int64_t _823 = 879;
    _822.d2 = _823;
    if (_823 > 0) 
    goto _jump3873;
    fail_assertion("non-positive loop bound");
    _jump3873:;
    // Computing total size of heap memory to allocate
    int64_t _824 = 1;
    _824 *= d;
    _824 *= _794;
    _824 *= _823;
    _824 *= sizeof(int64_t);
    _822.data = jpl_alloc(_824);
    int64_t _825 = 0; // E
    int64_t _826 = 0; // D
    int64_t _827 = 0; // C
    _jump3874:; // Begin body of loop
    int64_t _828 = 0;
    _828 *= _822.d0;
    _828 += _827;
    _828 *= _822.d1;
    _828 += _826;
    _828 *= _822.d2;
    _828 += _825;
    _822.data[_828] = _825;
    _825++;
    if (_825 < _823)
    goto _jump3874;
    _825 = 0;
    _826++;
    if (_826 < _794)
    goto _jump3874;
    _826 = 0;
    _827++;
    if (_827 < d)
    goto _jump3874;
    // End body of loop
    _821 = _822;
    goto _jump3875;
    _jump3870:;
    _a3_int64_t _829;
    // Computing bound for C
    _829.d0 = _794;
    if (_794 > 0) 
    goto _jump3876;
    fail_assertion("non-positive loop bound");
    _jump3876:;
    // Computing bound for D
    _829.d1 = _795;
    if (_795 > 0) 
    goto _jump3877;
    fail_assertion("non-positive loop bound");
    _jump3877:;
    // Computing bound for E
    _829.d2 = q;
    if (q > 0) 
    goto _jump3878;
    fail_assertion("non-positive loop bound");
    _jump3878:;
    // Computing total size of heap memory to allocate
    int64_t _830 = 1;
    _830 *= _794;
    _830 *= _795;
    _830 *= q;
    _830 *= sizeof(int64_t);
    _829.data = jpl_alloc(_830);
    int64_t _831 = 0; // E
    int64_t _832 = 0; // D
    int64_t _833 = 0; // C
    _jump3879:; // Begin body of loop
    int64_t _834 = 0;
    _834 *= _829.d0;
    _834 += _833;
    _834 *= _829.d1;
    _834 += _832;
    _834 *= _829.d2;
    _834 += _831;
    _829.data[_834] = _572.d0;
    _831++;
    if (_831 < q)
    goto _jump3879;
    _831 = 0;
    _832++;
    if (_832 < _795)
    goto _jump3879;
    _832 = 0;
    _833++;
    if (_833 < _794)
    goto _jump3879;
    // End body of loop
    _821 = _829;
    _jump3875:;
    int64_t _835 = 671;
    int64_t _836 = 511;
    int64_t _837 = 114;
    if (_835 >= 0)
    goto _jump3880;
    fail_assertion("negative array index");
    _jump3880:;
    if (_835 < _821.d0)
    goto _jump3881;
    fail_assertion("index too large");
    _jump3881:;
    if (_836 >= 0)
    goto _jump3882;
    fail_assertion("negative array index");
    _jump3882:;
    if (_836 < _821.d1)
    goto _jump3883;
    fail_assertion("index too large");
    _jump3883:;
    if (_837 >= 0)
    goto _jump3884;
    fail_assertion("negative array index");
    _jump3884:;
    if (_837 < _821.d2)
    goto _jump3885;
    fail_assertion("index too large");
    _jump3885:;
    int64_t _838 = 0;
    _838 *= _821.d0;
    _838 += _835;
    _838 *= _821.d1;
    _838 += _836;
    _838 *= _821.d2;
    _838 += _837;
    int64_t _839 = _821.data[_838];
    int64_t _840 = _839 + q;
    if (_840 >= 0)
    goto _jump3886;
    fail_assertion("negative array index");
    _jump3886:;
    if (_840 < _796.d0)
    goto _jump3887;
    fail_assertion("index too large");
    _jump3887:;
    int64_t _841 = 0;
    _841 *= _796.d0;
    _841 += _840;
    void_t _842 = _796.data[_841];
    int64_t _843 = 0;
    _843 *= _792.d0;
    _843 += _795;
    _843 *= _792.d1;
    _843 += _794;
    _792.data[_843] = _842;
    _794++;
    if (_794 < c)
    goto _jump3857;
    _794 = 0;
    _795++;
    if (_795 < q)
    goto _jump3857;
    // End body of loop
    _a2__a3_rgba _844;
    if (!_670)
    goto _jump3888;
    _a2__a3_rgba _845;
    // Computing bound for A
    _845.d0 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3889;
    fail_assertion("non-positive loop bound");
    _jump3889:;
    // Computing bound for B
    _a3_int64_t _846;
    // Computing bound for A
    _846.d0 = d;
    if (d > 0) 
    goto _jump3890;
    fail_assertion("non-positive loop bound");
    _jump3890:;
    // Computing bound for B
    _846.d1 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3891;
    fail_assertion("non-positive loop bound");
    _jump3891:;
    // Computing bound for C
    int64_t _847 = -_572.d2;
    int64_t _848 = _572.d0 * _847;
    _846.d2 = _848;
    if (_848 > 0) 
    goto _jump3892;
    fail_assertion("non-positive loop bound");
    _jump3892:;
    // Computing total size of heap memory to allocate
    int64_t _849 = 1;
    _849 *= d;
    _849 *= _572.d0;
    _849 *= _848;
    _849 *= sizeof(int64_t);
    _846.data = jpl_alloc(_849);
    int64_t _850 = 0; // C
    int64_t _851 = 0; // B
    int64_t _852 = 0; // A
    _jump3893:; // Begin body of loop
    int64_t _853 = 0;
    _853 *= _846.d0;
    _853 += _852;
    _853 *= _846.d1;
    _853 += _851;
    _853 *= _846.d2;
    _853 += _850;
    _846.data[_853] = q;
    _850++;
    if (_850 < _848)
    goto _jump3893;
    _850 = 0;
    _851++;
    if (_851 < _572.d0)
    goto _jump3893;
    _851 = 0;
    _852++;
    if (_852 < d)
    goto _jump3893;
    // End body of loop
    int64_t _854 = 733;
    if (_854 >= 0)
    goto _jump3894;
    fail_assertion("negative array index");
    _jump3894:;
    if (_854 < _846.d0)
    goto _jump3895;
    fail_assertion("index too large");
    _jump3895:;
    if (_572.d1 >= 0)
    goto _jump3896;
    fail_assertion("negative array index");
    _jump3896:;
    if (_572.d1 < _846.d1)
    goto _jump3897;
    fail_assertion("index too large");
    _jump3897:;
    if (_572.d0 >= 0)
    goto _jump3898;
    fail_assertion("negative array index");
    _jump3898:;
    if (_572.d0 < _846.d2)
    goto _jump3899;
    fail_assertion("index too large");
    _jump3899:;
    int64_t _855 = 0;
    _855 *= _846.d0;
    _855 += _854;
    _855 *= _846.d1;
    _855 += _572.d1;
    _855 *= _846.d2;
    _855 += _572.d0;
    int64_t _856 = _846.data[_855];
    _845.d1 = _856;
    if (_856 > 0) 
    goto _jump3900;
    fail_assertion("non-positive loop bound");
    _jump3900:;
    // Computing total size of heap memory to allocate
    int64_t _857 = 1;
    _857 *= _572.d0;
    _857 *= _856;
    _857 *= sizeof(_a3_rgba);
    _845.data = jpl_alloc(_857);
    int64_t _858 = 0; // B
    int64_t _859 = 0; // A
    _jump3901:; // Begin body of loop
    _a3__a3_rgba _860;
    // Computing bound for C
    int64_t _861 = 313;
    _860.d0 = _861;
    if (_861 > 0) 
    goto _jump3902;
    fail_assertion("non-positive loop bound");
    _jump3902:;
    // Computing bound for D
    _860.d1 = _859;
    if (_859 > 0) 
    goto _jump3903;
    fail_assertion("non-positive loop bound");
    _jump3903:;
    // Computing bound for E
    _860.d2 = _859;
    if (_859 > 0) 
    goto _jump3904;
    fail_assertion("non-positive loop bound");
    _jump3904:;
    // Computing total size of heap memory to allocate
    int64_t _862 = 1;
    _862 *= _861;
    _862 *= _859;
    _862 *= _859;
    _862 *= sizeof(_a3_rgba);
    _860.data = jpl_alloc(_862);
    int64_t _863 = 0; // E
    int64_t _864 = 0; // D
    int64_t _865 = 0; // C
    _jump3905:; // Begin body of loop
    int64_t _866 = 0;
    _866 *= _860.d0;
    _866 += _865;
    _866 *= _860.d1;
    _866 += _864;
    _866 *= _860.d2;
    _866 += _863;
    _860.data[_866] = _572;
    _863++;
    if (_863 < _859)
    goto _jump3905;
    _863 = 0;
    _864++;
    if (_864 < _859)
    goto _jump3905;
    _864 = 0;
    _865++;
    if (_865 < _861)
    goto _jump3905;
    // End body of loop
    int64_t _867;
    // Computing bound for C
    if (c > 0) 
    goto _jump3906;
    fail_assertion("non-positive loop bound");
    _jump3906:;
    // Computing bound for D
    if (_572.d0 > 0) 
    goto _jump3907;
    fail_assertion("non-positive loop bound");
    _jump3907:;
    _867 = 0;
    int64_t _868 = 0; // D
    int64_t _869 = 0; // C
    _jump3908:; // Begin body of loop
    _867 += _869;
    _868++;
    if (_868 < _572.d0)
    goto _jump3908;
    _868 = 0;
    _869++;
    if (_869 < c)
    goto _jump3908;
    // End body of loop
    bool _870 = true;
    int64_t _871;
    if (!_870)
    goto _jump3909;
    int64_t _872 = 550;
    _871 = _872;
    goto _jump3910;
    _jump3909:;
    _871 = c;
    _jump3910:;
    int64_t _873 = 950;
    int64_t _874 = 534;
    int64_t _875 = _873 - _874;
    if (_867 >= 0)
    goto _jump3911;
    fail_assertion("negative array index");
    _jump3911:;
    if (_867 < _860.d0)
    goto _jump3912;
    fail_assertion("index too large");
    _jump3912:;
    if (_871 >= 0)
    goto _jump3913;
    fail_assertion("negative array index");
    _jump3913:;
    if (_871 < _860.d1)
    goto _jump3914;
    fail_assertion("index too large");
    _jump3914:;
    if (_875 >= 0)
    goto _jump3915;
    fail_assertion("negative array index");
    _jump3915:;
    if (_875 < _860.d2)
    goto _jump3916;
    fail_assertion("index too large");
    _jump3916:;
    int64_t _876 = 0;
    _876 *= _860.d0;
    _876 += _867;
    _876 *= _860.d1;
    _876 += _871;
    _876 *= _860.d2;
    _876 += _875;
    _a3_rgba _877 = _860.data[_876];
    _a1__a3_rgba _878;
    _878.d0 = 1;
    _878.data = jpl_alloc(sizeof(_a3_rgba) * 1);
    _878.data[0] = _877;
    int64_t _879 = -q;
    if (_879 >= 0)
    goto _jump3917;
    fail_assertion("negative array index");
    _jump3917:;
    if (_879 < _878.d0)
    goto _jump3918;
    fail_assertion("index too large");
    _jump3918:;
    int64_t _880 = 0;
    _880 *= _878.d0;
    _880 += _879;
    _a3_rgba _881 = _878.data[_880];
    int64_t _882 = 0;
    _882 *= _845.d0;
    _882 += _859;
    _882 *= _845.d1;
    _882 += _858;
    _845.data[_882] = _881;
    _858++;
    if (_858 < _856)
    goto _jump3901;
    _858 = 0;
    _859++;
    if (_859 < _572.d0)
    goto _jump3901;
    // End body of loop
    _844 = _845;
    goto _jump3919;
    _jump3888:;
    _a2__a3_rgba _883;
    // Computing bound for A
    _883.d0 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3920;
    fail_assertion("non-positive loop bound");
    _jump3920:;
    // Computing bound for B
    int64_t _884 = 646;
    _883.d1 = _884;
    if (_884 > 0) 
    goto _jump3921;
    fail_assertion("non-positive loop bound");
    _jump3921:;
    // Computing total size of heap memory to allocate
    int64_t _885 = 1;
    _885 *= _572.d0;
    _885 *= _884;
    _885 *= sizeof(_a3_rgba);
    _883.data = jpl_alloc(_885);
    int64_t _886 = 0; // B
    int64_t _887 = 0; // A
    _jump3922:; // Begin body of loop
    int64_t _888 = 61;
    _a2_void_t _889;
    // Computing bound for C
    int64_t _890;
    // Computing bound for C
    int64_t _891;
    // Computing bound for C
    if (d > 0) 
    goto _jump3923;
    fail_assertion("non-positive loop bound");
    _jump3923:;
    _891 = 0;
    int64_t _892 = 0; // C
    _jump3924:; // Begin body of loop
    int64_t _893 = 160;
    _891 += _893;
    _892++;
    if (_892 < d)
    goto _jump3924;
    // End body of loop
    if (_891 > 0) 
    goto _jump3925;
    fail_assertion("non-positive loop bound");
    _jump3925:;
    // Computing bound for D
    if (_572.d1 > 0) 
    goto _jump3926;
    fail_assertion("non-positive loop bound");
    _jump3926:;
    // Computing bound for E
    if (_886 > 0) 
    goto _jump3927;
    fail_assertion("non-positive loop bound");
    _jump3927:;
    _890 = 0;
    int64_t _894 = 0; // E
    int64_t _895 = 0; // D
    int64_t _896 = 0; // C
    _jump3928:; // Begin body of loop
    _890 += _896;
    _894++;
    if (_894 < _886)
    goto _jump3928;
    _894 = 0;
    _895++;
    if (_895 < _572.d1)
    goto _jump3928;
    _895 = 0;
    _896++;
    if (_896 < _891)
    goto _jump3928;
    // End body of loop
    _889.d0 = _890;
    if (_890 > 0) 
    goto _jump3929;
    fail_assertion("non-positive loop bound");
    _jump3929:;
    // Computing bound for D
    int64_t _897 = 308;
    if (_897 >= 0)
    goto _jump3930;
    fail_assertion("negative array index");
    _jump3930:;
    if (_897 < f.d0)
    goto _jump3931;
    fail_assertion("index too large");
    _jump3931:;
    if (c >= 0)
    goto _jump3932;
    fail_assertion("negative array index");
    _jump3932:;
    if (c < f.d1)
    goto _jump3933;
    fail_assertion("index too large");
    _jump3933:;
    int64_t _898 = 0;
    _898 *= f.d0;
    _898 += _897;
    _898 *= f.d1;
    _898 += c;
    int64_t _899 = f.data[_898];
    _889.d1 = _899;
    if (_899 > 0) 
    goto _jump3934;
    fail_assertion("non-positive loop bound");
    _jump3934:;
    // Computing total size of heap memory to allocate
    int64_t _900 = 1;
    _900 *= _890;
    _900 *= _899;
    _900 *= sizeof(void_t);
    _889.data = jpl_alloc(_900);
    int64_t _901 = 0; // D
    int64_t _902 = 0; // C
    _jump3935:; // Begin body of loop
    _a3_double _903;
    // Computing bound for E
    _903.d0 = q;
    if (q > 0) 
    goto _jump3936;
    fail_assertion("non-positive loop bound");
    _jump3936:;
    // Computing bound for F
    _903.d1 = _887;
    if (_887 > 0) 
    goto _jump3937;
    fail_assertion("non-positive loop bound");
    _jump3937:;
    // Computing bound for G
    _903.d2 = c;
    if (c > 0) 
    goto _jump3938;
    fail_assertion("non-positive loop bound");
    _jump3938:;
    // Computing total size of heap memory to allocate
    int64_t _904 = 1;
    _904 *= q;
    _904 *= _887;
    _904 *= c;
    _904 *= sizeof(double);
    _903.data = jpl_alloc(_904);
    int64_t _905 = 0; // G
    int64_t _906 = 0; // F
    int64_t _907 = 0; // E
    _jump3939:; // Begin body of loop
    double _908 = 28.0;
    int64_t _909 = 0;
    _909 *= _903.d0;
    _909 += _907;
    _909 *= _903.d1;
    _909 += _906;
    _909 *= _903.d2;
    _909 += _905;
    _903.data[_909] = _908;
    _905++;
    if (_905 < c)
    goto _jump3939;
    _905 = 0;
    _906++;
    if (_906 < _887)
    goto _jump3939;
    _906 = 0;
    _907++;
    if (_907 < q)
    goto _jump3939;
    // End body of loop
    rgba _910 = a();
    void_t _911 = s(_903, _910);
    int64_t _912 = 0;
    _912 *= _889.d0;
    _912 += _902;
    _912 *= _889.d1;
    _912 += _901;
    _889.data[_912] = _911;
    _901++;
    if (_901 < _899)
    goto _jump3935;
    _901 = 0;
    _902++;
    if (_902 < _890)
    goto _jump3935;
    // End body of loop
    _a2__a3_rgba _913;
    // Computing bound for C
    _913.d0 = q;
    if (q > 0) 
    goto _jump3940;
    fail_assertion("non-positive loop bound");
    _jump3940:;
    // Computing bound for D
    int64_t _914 = 220;
    _913.d1 = _914;
    if (_914 > 0) 
    goto _jump3941;
    fail_assertion("non-positive loop bound");
    _jump3941:;
    // Computing total size of heap memory to allocate
    int64_t _915 = 1;
    _915 *= q;
    _915 *= _914;
    _915 *= sizeof(_a3_rgba);
    _913.data = jpl_alloc(_915);
    int64_t _916 = 0; // D
    int64_t _917 = 0; // C
    _jump3942:; // Begin body of loop
    _a3_rgba _918;
    // Computing bound for E
    _918.d0 = _886;
    if (_886 > 0) 
    goto _jump3943;
    fail_assertion("non-positive loop bound");
    _jump3943:;
    // Computing bound for F
    _918.d1 = c;
    if (c > 0) 
    goto _jump3944;
    fail_assertion("non-positive loop bound");
    _jump3944:;
    // Computing bound for G
    int64_t _919;
    // Computing bound for E
    if (_886 > 0) 
    goto _jump3945;
    fail_assertion("non-positive loop bound");
    _jump3945:;
    // Computing bound for F
    int64_t _920 = 715;
    if (_920 > 0) 
    goto _jump3946;
    fail_assertion("non-positive loop bound");
    _jump3946:;
    _919 = 0;
    int64_t _921 = 0; // F
    int64_t _922 = 0; // E
    _jump3947:; // Begin body of loop
    _919 += _886;
    _921++;
    if (_921 < _920)
    goto _jump3947;
    _921 = 0;
    _922++;
    if (_922 < _886)
    goto _jump3947;
    // End body of loop
    _918.d2 = _919;
    if (_919 > 0) 
    goto _jump3948;
    fail_assertion("non-positive loop bound");
    _jump3948:;
    // Computing total size of heap memory to allocate
    int64_t _923 = 1;
    _923 *= _886;
    _923 *= c;
    _923 *= _919;
    _923 *= sizeof(rgba);
    _918.data = jpl_alloc(_923);
    int64_t _924 = 0; // G
    int64_t _925 = 0; // F
    int64_t _926 = 0; // E
    _jump3949:; // Begin body of loop
    rgba _927;
    if (!n)
    goto _jump3950;
    rgba _928 = k();
    _927 = _928;
    goto _jump3951;
    _jump3950:;
    rgba _929 = t();
    _927 = _929;
    _jump3951:;
    int64_t _930 = 0;
    _930 *= _918.d0;
    _930 += _926;
    _930 *= _918.d1;
    _930 += _925;
    _930 *= _918.d2;
    _930 += _924;
    _918.data[_930] = _927;
    _924++;
    if (_924 < _919)
    goto _jump3949;
    _924 = 0;
    _925++;
    if (_925 < c)
    goto _jump3949;
    _925 = 0;
    _926++;
    if (_926 < _886)
    goto _jump3949;
    // End body of loop
    int64_t _931 = 0;
    _931 *= _913.d0;
    _931 += _917;
    _931 *= _913.d1;
    _931 += _916;
    _913.data[_931] = _918;
    _916++;
    if (_916 < _914)
    goto _jump3942;
    _916 = 0;
    _917++;
    if (_917 < q)
    goto _jump3942;
    // End body of loop
    _a3_rgba _932 = e(_888, _889, _913);
    int64_t _933 = 0;
    _933 *= _883.d0;
    _933 += _887;
    _933 *= _883.d1;
    _933 += _886;
    _883.data[_933] = _932;
    _886++;
    if (_886 < _884)
    goto _jump3922;
    _886 = 0;
    _887++;
    if (_887 < _572.d0)
    goto _jump3922;
    // End body of loop
    _844 = _883;
    _jump3919:;
    _a3_rgba _934 = e(_791, _792, _844);
    rgba _935 = _238.c;
    int64_t _936 = 872;
    if (_936 >= 0)
    goto _jump3952;
    fail_assertion("negative array index");
    _jump3952:;
    if (_936 < p.d0)
    goto _jump3953;
    fail_assertion("index too large");
    _jump3953:;
    int64_t _937 = 0;
    _937 *= p.d0;
    _937 += _936;
    o _938 = p.data[_937];
    bool _939 = _938.c;
    bool _940 = _939 != _670;
    l _941;
    if (!_940)
    goto _jump3954;
    double _942 = _935.b;
    bool _943 = _942 != g;
    l _944;
    if (!_943)
    goto _jump3955;
    bool _945 = true;
    _a3_bool _946 = _238.b;
    rgba _947 = a();
    l _948 = { _945, _946, _947 };
    _944 = _948;
    goto _jump3956;
    _jump3955:;
    _944 = _238;
    _jump3956:;
    _941 = _944;
    goto _jump3957;
    _jump3954:;
    _941 = _238;
    _jump3957:;
    bool _949 = _941.a;
    l _950;
    if (!_949)
    goto _jump3958;
    bool _951 = true;
    bool _953 = !n;
    bool _952 = _953;
    if (0 == _953)
    goto _jump3959;
    bool _954 = d <= _572.d2;
    _952 = _954;
    _jump3959:;
    bool _955 = n;
    if (0 == n)
    goto _jump3960;
    _955 = n;
    _jump3960:;
    _a3_bool _956;
    if (!_955)
    goto _jump3961;
    _a3_bool _957;
    // Computing bound for F
    _957.d0 = _572.d0;
    if (_572.d0 > 0) 
    goto _jump3962;
    fail_assertion("non-positive loop bound");
    _jump3962:;
    // Computing bound for G
    _957.d1 = c;
    if (c > 0) 
    goto _jump3963;
    fail_assertion("non-positive loop bound");
    _jump3963:;
    // Computing bound for H
    _957.d2 = _572.d1;
    if (_572.d1 > 0) 
    goto _jump3964;
    fail_assertion("non-positive loop bound");
    _jump3964:;
    // Computing total size of heap memory to allocate
    int64_t _958 = 1;
    _958 *= _572.d0;
    _958 *= c;
    _958 *= _572.d1;
    _958 *= sizeof(bool);
    _957.data = jpl_alloc(_958);
    int64_t _959 = 0; // H
    int64_t _960 = 0; // G
    int64_t _961 = 0; // F
    _jump3965:; // Begin body of loop
    bool _962 = true;
    int64_t _963 = 0;
    _963 *= _957.d0;
    _963 += _961;
    _963 *= _957.d1;
    _963 += _960;
    _963 *= _957.d2;
    _963 += _959;
    _957.data[_963] = _962;
    _959++;
    if (_959 < _572.d1)
    goto _jump3965;
    _959 = 0;
    _960++;
    if (_960 < c)
    goto _jump3965;
    _960 = 0;
    _961++;
    if (_961 < _572.d0)
    goto _jump3965;
    // End body of loop
    _956 = _957;
    goto _jump3966;
    _jump3961:;
    _a3_bool _964;
    // Computing bound for F
    _964.d0 = d;
    if (d > 0) 
    goto _jump3967;
    fail_assertion("non-positive loop bound");
    _jump3967:;
    // Computing bound for G
    _964.d1 = _572.d2;
    if (_572.d2 > 0) 
    goto _jump3968;
    fail_assertion("non-positive loop bound");
    _jump3968:;
    // Computing bound for H
    _964.d2 = c;
    if (c > 0) 
    goto _jump3969;
    fail_assertion("non-positive loop bound");
    _jump3969:;
    // Computing total size of heap memory to allocate
    int64_t _965 = 1;
    _965 *= d;
    _965 *= _572.d2;
    _965 *= c;
    _965 *= sizeof(bool);
    _964.data = jpl_alloc(_965);
    int64_t _966 = 0; // H
    int64_t _967 = 0; // G
    int64_t _968 = 0; // F
    _jump3970:; // Begin body of loop
    int64_t _969 = 0;
    _969 *= _964.d0;
    _969 += _968;
    _969 *= _964.d1;
    _969 += _967;
    _969 *= _964.d2;
    _969 += _966;
    _964.data[_969] = _670;
    _966++;
    if (_966 < c)
    goto _jump3970;
    _966 = 0;
    _967++;
    if (_967 < _572.d2)
    goto _jump3970;
    _967 = 0;
    _968++;
    if (_968 < d)
    goto _jump3970;
    // End body of loop
    _956 = _964;
    _jump3966:;
    o _970 = r();
    rgba _971 = _970.b;
    l _972 = { _952, _956, _971 };
    _a3_bool _973 = _972.b;
    if (_572.d1 >= 0)
    goto _jump3971;
    fail_assertion("negative array index");
    _jump3971:;
    if (_572.d1 < _572.d0)
    goto _jump3972;
    fail_assertion("index too large");
    _jump3972:;
    if (_934.d1 >= 0)
    goto _jump3973;
    fail_assertion("negative array index");
    _jump3973:;
    if (_934.d1 < _572.d1)
    goto _jump3974;
    fail_assertion("index too large");
    _jump3974:;
    if (q >= 0)
    goto _jump3975;
    fail_assertion("negative array index");
    _jump3975:;
    if (q < _572.d2)
    goto _jump3976;
    fail_assertion("index too large");
    _jump3976:;
    int64_t _974 = 0;
    _974 *= _572.d0;
    _974 += _572.d1;
    _974 *= _572.d1;
    _974 += _934.d1;
    _974 *= _572.d2;
    _974 += q;
    rgba _975 = _572.data[_974];
    l _976 = { _951, _973, _975 };
    _950 = _976;
    goto _jump3977;
    _jump3958:;
    bool _977 = _670;
    if (0 == _670)
    goto _jump3978;
    bool _978 = i(_572.d1);
    _977 = _978;
    _jump3978:;
    _a3_bool _979 = _238.b;
    rgba _980 = m();
    l _981 = { _977, _979, _980 };
    _950 = _981;
    _jump3977:;
    _a3_bool _982 = _950.b;
    rgba _983 = m();
    return _983;
}

l u(_a3_int64_t v) {
    _a2_l _0;
    // Computing bound for z
    _a2_void_t _1;
    // Computing bound for z
    int64_t _2;
    // Computing bound for z
    int64_t _3 = 583;
    int64_t _4 = v.d0 % _3;
    if (_4 > 0) 
    goto _jump3979;
    fail_assertion("non-positive loop bound");
    _jump3979:;
    // Computing bound for A
    int64_t _5;
    if (!n)
    goto _jump3980;
    _5 = v.d1;
    goto _jump3981;
    _jump3980:;
    _5 = v.d0;
    _jump3981:;
    if (_5 > 0) 
    goto _jump3982;
    fail_assertion("non-positive loop bound");
    _jump3982:;
    // Computing bound for B
    if (q > 0) 
    goto _jump3983;
    fail_assertion("non-positive loop bound");
    _jump3983:;
    _2 = 0;
    int64_t _6 = 0; // B
    int64_t _7 = 0; // A
    int64_t _8 = 0; // z
    _jump3984:; // Begin body of loop
    _2 += c;
    _6++;
    if (_6 < q)
    goto _jump3984;
    _6 = 0;
    _7++;
    if (_7 < _5)
    goto _jump3984;
    _7 = 0;
    _8++;
    if (_8 < _4)
    goto _jump3984;
    // End body of loop
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump3985;
    fail_assertion("non-positive loop bound");
    _jump3985:;
    // Computing bound for A
    int64_t _9;
    // Computing bound for z
    if (v.d2 > 0) 
    goto _jump3986;
    fail_assertion("non-positive loop bound");
    _jump3986:;
    _9 = 0;
    int64_t _10 = 0; // z
    _jump3987:; // Begin body of loop
    _9 += v.d2;
    _10++;
    if (_10 < v.d2)
    goto _jump3987;
    // End body of loop
    _1.d1 = _9;
    if (_9 > 0) 
    goto _jump3988;
    fail_assertion("non-positive loop bound");
    _jump3988:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= _2;
    _11 *= _9;
    _11 *= sizeof(void_t);
    _1.data = jpl_alloc(_11);
    int64_t _12 = 0; // A
    int64_t _13 = 0; // z
    _jump3989:; // Begin body of loop
    _a3_double _14;
    // Computing bound for B
    _14.d0 = q;
    if (q > 0) 
    goto _jump3990;
    fail_assertion("non-positive loop bound");
    _jump3990:;
    // Computing bound for C
    _14.d1 = v.d1;
    if (v.d1 > 0) 
    goto _jump3991;
    fail_assertion("non-positive loop bound");
    _jump3991:;
    // Computing bound for D
    int64_t _15 = 623;
    _14.d2 = _15;
    if (_15 > 0) 
    goto _jump3992;
    fail_assertion("non-positive loop bound");
    _jump3992:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= q;
    _16 *= v.d1;
    _16 *= _15;
    _16 *= sizeof(double);
    _14.data = jpl_alloc(_16);
    int64_t _17 = 0; // D
    int64_t _18 = 0; // C
    int64_t _19 = 0; // B
    _jump3993:; // Begin body of loop
    double _20 = 95.0;
    int64_t _21 = 0;
    _21 *= _14.d0;
    _21 += _19;
    _21 *= _14.d1;
    _21 += _18;
    _21 *= _14.d2;
    _21 += _17;
    _14.data[_21] = _20;
    _17++;
    if (_17 < _15)
    goto _jump3993;
    _17 = 0;
    _18++;
    if (_18 < v.d1)
    goto _jump3993;
    _18 = 0;
    _19++;
    if (_19 < q)
    goto _jump3993;
    // End body of loop
    rgba _22 = m();
    void_t _23 = s(_14, _22);
    int64_t _24 = 0;
    _24 *= _1.d0;
    _24 += _13;
    _24 *= _1.d1;
    _24 += _12;
    _1.data[_24] = _23;
    _12++;
    if (_12 < _9)
    goto _jump3989;
    _12 = 0;
    _13++;
    if (_13 < _2)
    goto _jump3989;
    // End body of loop
    int64_t _25;
    if (!n)
    goto _jump3994;
    _a1_int64_t _26;
    _26.d0 = 3;
    _26.data = jpl_alloc(sizeof(int64_t) * 3);
    _26.data[0] = v.d2;
    _26.data[1] = q;
    _26.data[2] = v.d1;
    bool _27 = false;
    int64_t _28;
    if (!_27)
    goto _jump3995;
    _28 = v.d0;
    goto _jump3996;
    _jump3995:;
    int64_t _29 = 431;
    _28 = _29;
    _jump3996:;
    if (_28 >= 0)
    goto _jump3997;
    fail_assertion("negative array index");
    _jump3997:;
    if (_28 < _26.d0)
    goto _jump3998;
    fail_assertion("index too large");
    _jump3998:;
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += _28;
    int64_t _31 = _26.data[_30];
    _25 = _31;
    goto _jump3999;
    _jump3994:;
    int64_t _32;
    // Computing bound for z
    if (v.d0 > 0) 
    goto _jump4000;
    fail_assertion("non-positive loop bound");
    _jump4000:;
    // Computing bound for A
    if (c > 0) 
    goto _jump4001;
    fail_assertion("non-positive loop bound");
    _jump4001:;
    // Computing bound for B
    int64_t _33 = c * q;
    if (_33 > 0) 
    goto _jump4002;
    fail_assertion("non-positive loop bound");
    _jump4002:;
    _32 = 0;
    int64_t _34 = 0; // B
    int64_t _35 = 0; // A
    int64_t _36 = 0; // z
    _jump4003:; // Begin body of loop
    int64_t _37 = -v.d1;
    _32 += _37;
    _34++;
    if (_34 < _33)
    goto _jump4003;
    _34 = 0;
    _35++;
    if (_35 < c)
    goto _jump4003;
    _35 = 0;
    _36++;
    if (_36 < v.d0)
    goto _jump4003;
    // End body of loop
    _25 = _32;
    _jump3999:;
    int64_t _38 = -q;
    if (_25 >= 0)
    goto _jump4004;
    fail_assertion("negative array index");
    _jump4004:;
    if (_25 < _1.d0)
    goto _jump4005;
    fail_assertion("index too large");
    _jump4005:;
    if (_38 >= 0)
    goto _jump4006;
    fail_assertion("negative array index");
    _jump4006:;
    if (_38 < _1.d1)
    goto _jump4007;
    fail_assertion("index too large");
    _jump4007:;
    int64_t _39 = 0;
    _39 *= _1.d0;
    _39 += _25;
    _39 *= _1.d1;
    _39 += _38;
    void_t _40 = _1.data[_39];
    int64_t _41;
    // Computing bound for z
    if (v.d1 > 0) 
    goto _jump4008;
    fail_assertion("non-positive loop bound");
    _jump4008:;
    _41 = 0;
    int64_t _42 = 0; // z
    _jump4009:; // Begin body of loop
    _41 += c;
    _42++;
    if (_42 < v.d1)
    goto _jump4009;
    // End body of loop
    int64_t _43 = -_41;
    bool _44 = _43 < d;
    _a3_double _45;
    if (!_44)
    goto _jump4010;
    _a2__a3_double _46;
    // Computing bound for z
    int64_t _47 = v.d0 + q;
    _46.d0 = _47;
    if (_47 > 0) 
    goto _jump4011;
    fail_assertion("non-positive loop bound");
    _jump4011:;
    // Computing bound for A
    int64_t _48 = -v.d2;
    _46.d1 = _48;
    if (_48 > 0) 
    goto _jump4012;
    fail_assertion("non-positive loop bound");
    _jump4012:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= _47;
    _49 *= _48;
    _49 *= sizeof(_a3_double);
    _46.data = jpl_alloc(_49);
    int64_t _50 = 0; // A
    int64_t _51 = 0; // z
    _jump4013:; // Begin body of loop
    _a3_double _52;
    // Computing bound for B
    _52.d0 = v.d0;
    if (v.d0 > 0) 
    goto _jump4014;
    fail_assertion("non-positive loop bound");
    _jump4014:;
    // Computing bound for C
    _52.d1 = q;
    if (q > 0) 
    goto _jump4015;
    fail_assertion("non-positive loop bound");
    _jump4015:;
    // Computing bound for D
    _52.d2 = v.d1;
    if (v.d1 > 0) 
    goto _jump4016;
    fail_assertion("non-positive loop bound");
    _jump4016:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= v.d0;
    _53 *= q;
    _53 *= v.d1;
    _53 *= sizeof(double);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // D
    int64_t _55 = 0; // C
    int64_t _56 = 0; // B
    _jump4017:; // Begin body of loop
    int64_t _57 = 0;
    _57 *= _52.d0;
    _57 += _56;
    _57 *= _52.d1;
    _57 += _55;
    _57 *= _52.d2;
    _57 += _54;
    _52.data[_57] = g;
    _54++;
    if (_54 < v.d1)
    goto _jump4017;
    _54 = 0;
    _55++;
    if (_55 < q)
    goto _jump4017;
    _55 = 0;
    _56++;
    if (_56 < v.d0)
    goto _jump4017;
    // End body of loop
    int64_t _58 = 0;
    _58 *= _46.d0;
    _58 += _51;
    _58 *= _46.d1;
    _58 += _50;
    _46.data[_58] = _52;
    _50++;
    if (_50 < _48)
    goto _jump4013;
    _50 = 0;
    _51++;
    if (_51 < _47)
    goto _jump4013;
    // End body of loop
    int64_t _59 = -v.d0;
    int64_t _60 = _59 * v.d0;
    if (_60 >= 0)
    goto _jump4018;
    fail_assertion("negative array index");
    _jump4018:;
    if (_60 < _46.d0)
    goto _jump4019;
    fail_assertion("index too large");
    _jump4019:;
    if (c >= 0)
    goto _jump4020;
    fail_assertion("negative array index");
    _jump4020:;
    if (c < _46.d1)
    goto _jump4021;
    fail_assertion("index too large");
    _jump4021:;
    int64_t _61 = 0;
    _61 *= _46.d0;
    _61 += _60;
    _61 *= _46.d1;
    _61 += c;
    _a3_double _62 = _46.data[_61];
    _45 = _62;
    goto _jump4022;
    _jump4010:;
    bool _63 = true;
    _a3_double _64;
    if (!_63)
    goto _jump4023;
    _a3_double _65;
    // Computing bound for z
    _65.d0 = c;
    if (c > 0) 
    goto _jump4024;
    fail_assertion("non-positive loop bound");
    _jump4024:;
    // Computing bound for A
    _65.d1 = v.d1;
    if (v.d1 > 0) 
    goto _jump4025;
    fail_assertion("non-positive loop bound");
    _jump4025:;
    // Computing bound for B
    _65.d2 = q;
    if (q > 0) 
    goto _jump4026;
    fail_assertion("non-positive loop bound");
    _jump4026:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= c;
    _66 *= v.d1;
    _66 *= q;
    _66 *= sizeof(double);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // B
    int64_t _68 = 0; // A
    int64_t _69 = 0; // z
    _jump4027:; // Begin body of loop
    double _70 = -g;
    int64_t _71 = 0;
    _71 *= _65.d0;
    _71 += _69;
    _71 *= _65.d1;
    _71 += _68;
    _71 *= _65.d2;
    _71 += _67;
    _65.data[_71] = _70;
    _67++;
    if (_67 < q)
    goto _jump4027;
    _67 = 0;
    _68++;
    if (_68 < v.d1)
    goto _jump4027;
    _68 = 0;
    _69++;
    if (_69 < c)
    goto _jump4027;
    // End body of loop
    _64 = _65;
    goto _jump4028;
    _jump4023:;
    _a3_double _72;
    // Computing bound for z
    _72.d0 = v.d1;
    if (v.d1 > 0) 
    goto _jump4029;
    fail_assertion("non-positive loop bound");
    _jump4029:;
    // Computing bound for A
    _72.d1 = v.d0;
    if (v.d0 > 0) 
    goto _jump4030;
    fail_assertion("non-positive loop bound");
    _jump4030:;
    // Computing bound for B
    bool _73 = false;
    int64_t _74;
    if (!_73)
    goto _jump4031;
    int64_t _75 = 55;
    _74 = _75;
    goto _jump4032;
    _jump4031:;
    _74 = q;
    _jump4032:;
    _72.d2 = _74;
    if (_74 > 0) 
    goto _jump4033;
    fail_assertion("non-positive loop bound");
    _jump4033:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= v.d1;
    _76 *= v.d0;
    _76 *= _74;
    _76 *= sizeof(double);
    _72.data = jpl_alloc(_76);
    int64_t _77 = 0; // B
    int64_t _78 = 0; // A
    int64_t _79 = 0; // z
    _jump4034:; // Begin body of loop
    double _80 = 94.0;
    int64_t _81 = 0;
    _81 *= _72.d0;
    _81 += _79;
    _81 *= _72.d1;
    _81 += _78;
    _81 *= _72.d2;
    _81 += _77;
    _72.data[_81] = _80;
    _77++;
    if (_77 < _74)
    goto _jump4034;
    _77 = 0;
    _78++;
    if (_78 < v.d0)
    goto _jump4034;
    _78 = 0;
    _79++;
    if (_79 < v.d1)
    goto _jump4034;
    // End body of loop
    _64 = _72;
    _jump4028:;
    _45 = _64;
    _jump4022:;
    int64_t _82 = j(_40, _45, q);
    _0.d0 = _82;
    if (_82 > 0) 
    goto _jump4035;
    fail_assertion("non-positive loop bound");
    _jump4035:;
    // Computing bound for A
    o _83 = r();
    bool _84 = _83.c;
    _a3_double _85;
    if (!_84)
    goto _jump4036;
    _a3_double _86;
    // Computing bound for z
    _86.d0 = v.d0;
    if (v.d0 > 0) 
    goto _jump4037;
    fail_assertion("non-positive loop bound");
    _jump4037:;
    // Computing bound for A
    _86.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4038;
    fail_assertion("non-positive loop bound");
    _jump4038:;
    // Computing bound for B
    _86.d2 = c;
    if (c > 0) 
    goto _jump4039;
    fail_assertion("non-positive loop bound");
    _jump4039:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= v.d0;
    _87 *= v.d2;
    _87 *= c;
    _87 *= sizeof(double);
    _86.data = jpl_alloc(_87);
    int64_t _88 = 0; // B
    int64_t _89 = 0; // A
    int64_t _90 = 0; // z
    _jump4040:; // Begin body of loop
    double _91 = 11.0;
    int64_t _92 = 0;
    _92 *= _86.d0;
    _92 += _90;
    _92 *= _86.d1;
    _92 += _89;
    _92 *= _86.d2;
    _92 += _88;
    _86.data[_92] = _91;
    _88++;
    if (_88 < c)
    goto _jump4040;
    _88 = 0;
    _89++;
    if (_89 < v.d2)
    goto _jump4040;
    _89 = 0;
    _90++;
    if (_90 < v.d0)
    goto _jump4040;
    // End body of loop
    _85 = _86;
    goto _jump4041;
    _jump4036:;
    _a3_double _93;
    // Computing bound for z
    _93.d0 = c;
    if (c > 0) 
    goto _jump4042;
    fail_assertion("non-positive loop bound");
    _jump4042:;
    // Computing bound for A
    _93.d1 = v.d0;
    if (v.d0 > 0) 
    goto _jump4043;
    fail_assertion("non-positive loop bound");
    _jump4043:;
    // Computing bound for B
    int64_t _94 = -v.d1;
    _93.d2 = _94;
    if (_94 > 0) 
    goto _jump4044;
    fail_assertion("non-positive loop bound");
    _jump4044:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= c;
    _95 *= v.d0;
    _95 *= _94;
    _95 *= sizeof(double);
    _93.data = jpl_alloc(_95);
    int64_t _96 = 0; // B
    int64_t _97 = 0; // A
    int64_t _98 = 0; // z
    _jump4045:; // Begin body of loop
    double _99 = 10.0;
    double _100 = -_99;
    int64_t _101 = 0;
    _101 *= _93.d0;
    _101 += _98;
    _101 *= _93.d1;
    _101 += _97;
    _101 *= _93.d2;
    _101 += _96;
    _93.data[_101] = _100;
    _96++;
    if (_96 < _94)
    goto _jump4045;
    _96 = 0;
    _97++;
    if (_97 < v.d0)
    goto _jump4045;
    _97 = 0;
    _98++;
    if (_98 < c)
    goto _jump4045;
    // End body of loop
    _85 = _93;
    _jump4041:;
    rgba _102 = a();
    void_t _103 = s(_85, _102);
    _a3_int64_t _104;
    // Computing bound for z
    _104.d0 = q;
    if (q > 0) 
    goto _jump4046;
    fail_assertion("non-positive loop bound");
    _jump4046:;
    // Computing bound for A
    _104.d1 = c;
    if (c > 0) 
    goto _jump4047;
    fail_assertion("non-positive loop bound");
    _jump4047:;
    // Computing bound for B
    _104.d2 = c;
    if (c > 0) 
    goto _jump4048;
    fail_assertion("non-positive loop bound");
    _jump4048:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= q;
    _105 *= c;
    _105 *= c;
    _105 *= sizeof(int64_t);
    _104.data = jpl_alloc(_105);
    int64_t _106 = 0; // B
    int64_t _107 = 0; // A
    int64_t _108 = 0; // z
    _jump4049:; // Begin body of loop
    int64_t _109 = 0;
    _109 *= _104.d0;
    _109 += _108;
    _109 *= _104.d1;
    _109 += _107;
    _109 *= _104.d2;
    _109 += _106;
    _104.data[_109] = _106;
    _106++;
    if (_106 < c)
    goto _jump4049;
    _106 = 0;
    _107++;
    if (_107 < c)
    goto _jump4049;
    _107 = 0;
    _108++;
    if (_108 < q)
    goto _jump4049;
    // End body of loop
    l _110 = u(_104);
    bool _111 = _110.a;
    _a3_double _112;
    if (!_111)
    goto _jump4050;
    _a3_double _113;
    // Computing bound for z
    _113.d0 = v.d0;
    if (v.d0 > 0) 
    goto _jump4051;
    fail_assertion("non-positive loop bound");
    _jump4051:;
    // Computing bound for A
    _113.d1 = c;
    if (c > 0) 
    goto _jump4052;
    fail_assertion("non-positive loop bound");
    _jump4052:;
    // Computing bound for B
    int64_t _114 = 686;
    _113.d2 = _114;
    if (_114 > 0) 
    goto _jump4053;
    fail_assertion("non-positive loop bound");
    _jump4053:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= v.d0;
    _115 *= c;
    _115 *= _114;
    _115 *= sizeof(double);
    _113.data = jpl_alloc(_115);
    int64_t _116 = 0; // B
    int64_t _117 = 0; // A
    int64_t _118 = 0; // z
    _jump4054:; // Begin body of loop
    double _119;
    if (!n)
    goto _jump4055;
    _119 = g;
    goto _jump4056;
    _jump4055:;
    _119 = g;
    _jump4056:;
    int64_t _120 = 0;
    _120 *= _113.d0;
    _120 += _118;
    _120 *= _113.d1;
    _120 += _117;
    _120 *= _113.d2;
    _120 += _116;
    _113.data[_120] = _119;
    _116++;
    if (_116 < _114)
    goto _jump4054;
    _116 = 0;
    _117++;
    if (_117 < c)
    goto _jump4054;
    _117 = 0;
    _118++;
    if (_118 < v.d0)
    goto _jump4054;
    // End body of loop
    _112 = _113;
    goto _jump4057;
    _jump4050:;
    _a3_double _121;
    // Computing bound for z
    int64_t _122;
    // Computing bound for z
    int64_t _123 = -v.d1;
    if (_123 > 0) 
    goto _jump4058;
    fail_assertion("non-positive loop bound");
    _jump4058:;
    _122 = 0;
    int64_t _124 = 0; // z
    _jump4059:; // Begin body of loop
    _122 += d;
    _124++;
    if (_124 < _123)
    goto _jump4059;
    // End body of loop
    _121.d0 = _122;
    if (_122 > 0) 
    goto _jump4060;
    fail_assertion("non-positive loop bound");
    _jump4060:;
    // Computing bound for A
    _121.d1 = q;
    if (q > 0) 
    goto _jump4061;
    fail_assertion("non-positive loop bound");
    _jump4061:;
    // Computing bound for B
    _a3_int64_t _125;
    if (!n)
    goto _jump4062;
    _125 = v;
    goto _jump4063;
    _jump4062:;
    _125 = v;
    _jump4063:;
    if (v.d1 >= 0)
    goto _jump4064;
    fail_assertion("negative array index");
    _jump4064:;
    if (v.d1 < _125.d0)
    goto _jump4065;
    fail_assertion("index too large");
    _jump4065:;
    if (q >= 0)
    goto _jump4066;
    fail_assertion("negative array index");
    _jump4066:;
    if (q < _125.d1)
    goto _jump4067;
    fail_assertion("index too large");
    _jump4067:;
    if (v.d0 >= 0)
    goto _jump4068;
    fail_assertion("negative array index");
    _jump4068:;
    if (v.d0 < _125.d2)
    goto _jump4069;
    fail_assertion("index too large");
    _jump4069:;
    int64_t _126 = 0;
    _126 *= _125.d0;
    _126 += v.d1;
    _126 *= _125.d1;
    _126 += q;
    _126 *= _125.d2;
    _126 += v.d0;
    int64_t _127 = _125.data[_126];
    _121.d2 = _127;
    if (_127 > 0) 
    goto _jump4070;
    fail_assertion("non-positive loop bound");
    _jump4070:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _122;
    _128 *= q;
    _128 *= _127;
    _128 *= sizeof(double);
    _121.data = jpl_alloc(_128);
    int64_t _129 = 0; // B
    int64_t _130 = 0; // A
    int64_t _131 = 0; // z
    _jump4071:; // Begin body of loop
    int64_t _132 = 0;
    _132 *= _121.d0;
    _132 += _131;
    _132 *= _121.d1;
    _132 += _130;
    _132 *= _121.d2;
    _132 += _129;
    _121.data[_132] = g;
    _129++;
    if (_129 < _127)
    goto _jump4071;
    _129 = 0;
    _130++;
    if (_130 < q)
    goto _jump4071;
    _130 = 0;
    _131++;
    if (_131 < _122)
    goto _jump4071;
    // End body of loop
    _112 = _121;
    _jump4057:;
    int64_t _133 = j(_103, _112, d);
    _0.d1 = _133;
    if (_133 > 0) 
    goto _jump4072;
    fail_assertion("non-positive loop bound");
    _jump4072:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= _82;
    _134 *= _133;
    _134 *= sizeof(l);
    _0.data = jpl_alloc(_134);
    int64_t _135 = 0; // A
    int64_t _136 = 0; // z
    _jump4073:; // Begin body of loop
    _a3__a2_o _137;
    // Computing bound for B
    _137.d0 = _135;
    if (_135 > 0) 
    goto _jump4074;
    fail_assertion("non-positive loop bound");
    _jump4074:;
    // Computing bound for C
    _137.d1 = c;
    if (c > 0) 
    goto _jump4075;
    fail_assertion("non-positive loop bound");
    _jump4075:;
    // Computing bound for D
    _137.d2 = v.d2;
    if (v.d2 > 0) 
    goto _jump4076;
    fail_assertion("non-positive loop bound");
    _jump4076:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= _135;
    _138 *= c;
    _138 *= v.d2;
    _138 *= sizeof(_a2_o);
    _137.data = jpl_alloc(_138);
    int64_t _139 = 0; // D
    int64_t _140 = 0; // C
    int64_t _141 = 0; // B
    _jump4077:; // Begin body of loop
    _a2_o _142;
    // Computing bound for E
    _142.d0 = v.d1;
    if (v.d1 > 0) 
    goto _jump4078;
    fail_assertion("non-positive loop bound");
    _jump4078:;
    // Computing bound for F
    _142.d1 = d;
    if (d > 0) 
    goto _jump4079;
    fail_assertion("non-positive loop bound");
    _jump4079:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= v.d1;
    _143 *= d;
    _143 *= sizeof(o);
    _142.data = jpl_alloc(_143);
    int64_t _144 = 0; // F
    int64_t _145 = 0; // E
    _jump4080:; // Begin body of loop
    o _146 = r();
    int64_t _147 = 0;
    _147 *= _142.d0;
    _147 += _145;
    _147 *= _142.d1;
    _147 += _144;
    _142.data[_147] = _146;
    _144++;
    if (_144 < d)
    goto _jump4080;
    _144 = 0;
    _145++;
    if (_145 < v.d1)
    goto _jump4080;
    // End body of loop
    int64_t _148 = 0;
    _148 *= _137.d0;
    _148 += _141;
    _148 *= _137.d1;
    _148 += _140;
    _148 *= _137.d2;
    _148 += _139;
    _137.data[_148] = _142;
    _139++;
    if (_139 < v.d2)
    goto _jump4077;
    _139 = 0;
    _140++;
    if (_140 < c)
    goto _jump4077;
    _140 = 0;
    _141++;
    if (_141 < _135)
    goto _jump4077;
    // End body of loop
    int64_t _149;
    if (!n)
    goto _jump4081;
    int64_t _150 = _135 % _136;
    _149 = _150;
    goto _jump4082;
    _jump4081:;
    int64_t _151 = 442;
    _149 = _151;
    _jump4082:;
    if (_149 >= 0)
    goto _jump4083;
    fail_assertion("negative array index");
    _jump4083:;
    if (_149 < _137.d0)
    goto _jump4084;
    fail_assertion("index too large");
    _jump4084:;
    if (q >= 0)
    goto _jump4085;
    fail_assertion("negative array index");
    _jump4085:;
    if (q < _137.d1)
    goto _jump4086;
    fail_assertion("index too large");
    _jump4086:;
    if (v.d0 >= 0)
    goto _jump4087;
    fail_assertion("negative array index");
    _jump4087:;
    if (v.d0 < _137.d2)
    goto _jump4088;
    fail_assertion("index too large");
    _jump4088:;
    int64_t _152 = 0;
    _152 *= _137.d0;
    _152 += _149;
    _152 *= _137.d1;
    _152 += q;
    _152 *= _137.d2;
    _152 += v.d0;
    _a2_o _153 = _137.data[_152];
    int64_t _154 = 462;
    if (v.d0 >= 0)
    goto _jump4089;
    fail_assertion("negative array index");
    _jump4089:;
    if (v.d0 < _153.d0)
    goto _jump4090;
    fail_assertion("index too large");
    _jump4090:;
    if (_154 >= 0)
    goto _jump4091;
    fail_assertion("negative array index");
    _jump4091:;
    if (_154 < _153.d1)
    goto _jump4092;
    fail_assertion("index too large");
    _jump4092:;
    int64_t _155 = 0;
    _155 *= _153.d0;
    _155 += v.d0;
    _155 *= _153.d1;
    _155 += _154;
    o _156 = _153.data[_155];
    l _157 = _156.a;
    int64_t _158 = 0;
    _158 *= _0.d0;
    _158 += _136;
    _158 *= _0.d1;
    _158 += _135;
    _0.data[_158] = _157;
    _135++;
    if (_135 < _133)
    goto _jump4073;
    _135 = 0;
    _136++;
    if (_136 < _82)
    goto _jump4073;
    // End body of loop
    if (d >= 0)
    goto _jump4093;
    fail_assertion("negative array index");
    _jump4093:;
    if (d < _0.d0)
    goto _jump4094;
    fail_assertion("index too large");
    _jump4094:;
    if (v.d1 >= 0)
    goto _jump4095;
    fail_assertion("negative array index");
    _jump4095:;
    if (v.d1 < _0.d1)
    goto _jump4096;
    fail_assertion("index too large");
    _jump4096:;
    int64_t _159 = 0;
    _159 *= _0.d0;
    _159 += d;
    _159 *= _0.d1;
    _159 += v.d1;
    l _160 = _0.data[_159];
    return _160;
    o _161 = r();
    bool _162 = _161.c;
    bool _163 = true;
    bool _164 = _162 != _163;
    _a3_bool _165;
    // Computing bound for A
    _165.d0 = v.d1;
    if (v.d1 > 0) 
    goto _jump4097;
    fail_assertion("non-positive loop bound");
    _jump4097:;
    // Computing bound for B
    _165.d1 = v.d1;
    if (v.d1 > 0) 
    goto _jump4098;
    fail_assertion("non-positive loop bound");
    _jump4098:;
    // Computing bound for C
    _165.d2 = v.d2;
    if (v.d2 > 0) 
    goto _jump4099;
    fail_assertion("non-positive loop bound");
    _jump4099:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= v.d1;
    _166 *= v.d1;
    _166 *= v.d2;
    _166 *= sizeof(bool);
    _165.data = jpl_alloc(_166);
    int64_t _167 = 0; // C
    int64_t _168 = 0; // B
    int64_t _169 = 0; // A
    _jump4100:; // Begin body of loop
    bool _170 = i(q);
    bool _171 = !_170;
    int64_t _172 = 0;
    _172 *= _165.d0;
    _172 += _169;
    _172 *= _165.d1;
    _172 += _168;
    _172 *= _165.d2;
    _172 += _167;
    _165.data[_172] = _171;
    _167++;
    if (_167 < v.d2)
    goto _jump4100;
    _167 = 0;
    _168++;
    if (_168 < v.d1)
    goto _jump4100;
    _168 = 0;
    _169++;
    if (_169 < v.d1)
    goto _jump4100;
    // End body of loop
    int64_t _173;
    if (!_164)
    goto _jump4101;
    _173 = d;
    goto _jump4102;
    _jump4101:;
    int64_t _174;
    if (!n)
    goto _jump4103;
    int64_t _175 = 76;
    int64_t _176 = c % _175;
    _174 = _176;
    goto _jump4104;
    _jump4103:;
    int64_t _177 = 178;
    _174 = _177;
    _jump4104:;
    _173 = _174;
    _jump4102:;
    if (q >= 0)
    goto _jump4105;
    fail_assertion("negative array index");
    _jump4105:;
    if (q < _165.d0)
    goto _jump4106;
    fail_assertion("index too large");
    _jump4106:;
    if (v.d0 >= 0)
    goto _jump4107;
    fail_assertion("negative array index");
    _jump4107:;
    if (v.d0 < _165.d1)
    goto _jump4108;
    fail_assertion("index too large");
    _jump4108:;
    if (_173 >= 0)
    goto _jump4109;
    fail_assertion("negative array index");
    _jump4109:;
    if (_173 < _165.d2)
    goto _jump4110;
    fail_assertion("index too large");
    _jump4110:;
    int64_t _178 = 0;
    _178 *= _165.d0;
    _178 += q;
    _178 *= _165.d1;
    _178 += v.d0;
    _178 *= _165.d2;
    _178 += _173;
    bool _179 = _165.data[_178];
    bool _180 = !_179;
    l _181;
    if (!_180)
    goto _jump4111;
    double _182 = 90.0;
    rgba _183 = a();
    double _184 = _183.g;
    bool _185 = _182 != _184;
    double _186;
    if (!_185)
    goto _jump4112;
    rgba _187 = m();
    double _188 = _187.b;
    _186 = _188;
    goto _jump4113;
    _jump4112:;
    _a1_double _189;
    // Computing bound for A
    _189.d0 = c;
    if (c > 0) 
    goto _jump4114;
    fail_assertion("non-positive loop bound");
    _jump4114:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= c;
    _190 *= sizeof(double);
    _189.data = jpl_alloc(_190);
    int64_t _191 = 0; // A
    _jump4115:; // Begin body of loop
    double _192 = 43.0;
    int64_t _193 = 0;
    _193 *= _189.d0;
    _193 += _191;
    _189.data[_193] = _192;
    _191++;
    if (_191 < c)
    goto _jump4115;
    // End body of loop
    int64_t _194;
    // Computing bound for A
    if (d > 0) 
    goto _jump4116;
    fail_assertion("non-positive loop bound");
    _jump4116:;
    _194 = 0;
    int64_t _195 = 0; // A
    _jump4117:; // Begin body of loop
    _194 += c;
    _195++;
    if (_195 < d)
    goto _jump4117;
    // End body of loop
    if (_194 >= 0)
    goto _jump4118;
    fail_assertion("negative array index");
    _jump4118:;
    if (_194 < _189.d0)
    goto _jump4119;
    fail_assertion("index too large");
    _jump4119:;
    int64_t _196 = 0;
    _196 *= _189.d0;
    _196 += _194;
    double _197 = _189.data[_196];
    _186 = _197;
    _jump4113:;
    bool _198 = _186 < g;
    bool _199;
    if (!_198)
    goto _jump4120;
    _a3_int64_t _200;
    // Computing bound for A
    int64_t _201 = 163;
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump4121;
    fail_assertion("non-positive loop bound");
    _jump4121:;
    // Computing bound for B
    _200.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4122;
    fail_assertion("non-positive loop bound");
    _jump4122:;
    // Computing bound for C
    _200.d2 = c;
    if (c > 0) 
    goto _jump4123;
    fail_assertion("non-positive loop bound");
    _jump4123:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _201;
    _202 *= v.d2;
    _202 *= c;
    _202 *= sizeof(int64_t);
    _200.data = jpl_alloc(_202);
    int64_t _203 = 0; // C
    int64_t _204 = 0; // B
    int64_t _205 = 0; // A
    _jump4124:; // Begin body of loop
    int64_t _206 = 346;
    int64_t _207 = 0;
    _207 *= _200.d0;
    _207 += _205;
    _207 *= _200.d1;
    _207 += _204;
    _207 *= _200.d2;
    _207 += _203;
    _200.data[_207] = _206;
    _203++;
    if (_203 < c)
    goto _jump4124;
    _203 = 0;
    _204++;
    if (_204 < v.d2)
    goto _jump4124;
    _204 = 0;
    _205++;
    if (_205 < _201)
    goto _jump4124;
    // End body of loop
    l _208 = u(_200);
    rgba _209 = m();
    o _210 = { _208, _209, _164 };
    bool _211 = _210.c;
    _199 = _211;
    goto _jump4125;
    _jump4120:;
    double _212 = 48.0;
    bool _213 = false;
    rgba _214;
    if (!_213)
    goto _jump4126;
    rgba _215 = k();
    _214 = _215;
    goto _jump4127;
    _jump4126:;
    rgba _216 = m();
    _214 = _216;
    _jump4127:;
    double _217 = _214.a;
    bool _218 = _212 == _217;
    _199 = _218;
    _jump4125:;
    _a2_bool _219;
    // Computing bound for A
    int64_t _220;
    if (!n)
    goto _jump4128;
    _220 = v.d2;
    goto _jump4129;
    _jump4128:;
    _220 = v.d0;
    _jump4129:;
    _219.d0 = _220;
    if (_220 > 0) 
    goto _jump4130;
    fail_assertion("non-positive loop bound");
    _jump4130:;
    // Computing bound for B
    _219.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4131;
    fail_assertion("non-positive loop bound");
    _jump4131:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _220;
    _221 *= v.d2;
    _221 *= sizeof(bool);
    _219.data = jpl_alloc(_221);
    int64_t _222 = 0; // B
    int64_t _223 = 0; // A
    _jump4132:; // Begin body of loop
    bool _224 = d < q;
    int64_t _225 = 0;
    _225 *= _219.d0;
    _225 += _223;
    _225 *= _219.d1;
    _225 += _222;
    _219.data[_225] = _224;
    _222++;
    if (_222 < v.d2)
    goto _jump4132;
    _222 = 0;
    _223++;
    if (_223 < _220)
    goto _jump4132;
    // End body of loop
    int64_t _226;
    // Computing bound for A
    if (c >= 0)
    goto _jump4133;
    fail_assertion("negative array index");
    _jump4133:;
    if (c < v.d0)
    goto _jump4134;
    fail_assertion("index too large");
    _jump4134:;
    if (q >= 0)
    goto _jump4135;
    fail_assertion("negative array index");
    _jump4135:;
    if (q < v.d1)
    goto _jump4136;
    fail_assertion("index too large");
    _jump4136:;
    if (v.d0 >= 0)
    goto _jump4137;
    fail_assertion("negative array index");
    _jump4137:;
    if (v.d0 < v.d2)
    goto _jump4138;
    fail_assertion("index too large");
    _jump4138:;
    int64_t _227 = 0;
    _227 *= v.d0;
    _227 += c;
    _227 *= v.d1;
    _227 += q;
    _227 *= v.d2;
    _227 += v.d0;
    int64_t _228 = v.data[_227];
    if (_228 > 0) 
    goto _jump4139;
    fail_assertion("non-positive loop bound");
    _jump4139:;
    // Computing bound for B
    int64_t _229;
    if (!_164)
    goto _jump4140;
    _229 = v.d1;
    goto _jump4141;
    _jump4140:;
    _229 = d;
    _jump4141:;
    if (_229 > 0) 
    goto _jump4142;
    fail_assertion("non-positive loop bound");
    _jump4142:;
    _226 = 0;
    int64_t _230 = 0; // B
    int64_t _231 = 0; // A
    _jump4143:; // Begin body of loop
    int64_t _232 = d + _231;
    _226 += _232;
    _230++;
    if (_230 < _229)
    goto _jump4143;
    _230 = 0;
    _231++;
    if (_231 < _228)
    goto _jump4143;
    // End body of loop
    int64_t _233 = 940;
    int64_t _234 = _233 / v.d0;
    int64_t _235 = -_234;
    if (_226 >= 0)
    goto _jump4144;
    fail_assertion("negative array index");
    _jump4144:;
    if (_226 < _219.d0)
    goto _jump4145;
    fail_assertion("index too large");
    _jump4145:;
    if (_235 >= 0)
    goto _jump4146;
    fail_assertion("negative array index");
    _jump4146:;
    if (_235 < _219.d1)
    goto _jump4147;
    fail_assertion("index too large");
    _jump4147:;
    int64_t _236 = 0;
    _236 *= _219.d0;
    _236 += _226;
    _236 *= _219.d1;
    _236 += _235;
    bool _237 = _219.data[_236];
    bool _238 = !_237;
    _a3_bool _239;
    if (!_238)
    goto _jump4148;
    _a3_bool _240;
    // Computing bound for A
    bool _241 = !n;
    int64_t _242;
    if (!_241)
    goto _jump4149;
    int64_t _243;
    // Computing bound for A
    int64_t _244 = 501;
    if (_244 > 0) 
    goto _jump4150;
    fail_assertion("non-positive loop bound");
    _jump4150:;
    _243 = 0;
    int64_t _245 = 0; // A
    _jump4151:; // Begin body of loop
    int64_t _246 = q * v.d1;
    _243 += _246;
    _245++;
    if (_245 < _244)
    goto _jump4151;
    // End body of loop
    _242 = _243;
    goto _jump4152;
    _jump4149:;
    int64_t _247 = -v.d1;
    if (_247 >= 0)
    goto _jump4153;
    fail_assertion("negative array index");
    _jump4153:;
    if (_247 < f.d0)
    goto _jump4154;
    fail_assertion("index too large");
    _jump4154:;
    if (d >= 0)
    goto _jump4155;
    fail_assertion("negative array index");
    _jump4155:;
    if (d < f.d1)
    goto _jump4156;
    fail_assertion("index too large");
    _jump4156:;
    int64_t _248 = 0;
    _248 *= f.d0;
    _248 += _247;
    _248 *= f.d1;
    _248 += d;
    int64_t _249 = f.data[_248];
    _242 = _249;
    _jump4152:;
    _240.d0 = _242;
    if (_242 > 0) 
    goto _jump4157;
    fail_assertion("non-positive loop bound");
    _jump4157:;
    // Computing bound for B
    int64_t _250;
    // Computing bound for A
    if (q > 0) 
    goto _jump4158;
    fail_assertion("non-positive loop bound");
    _jump4158:;
    // Computing bound for B
    if (v.d1 >= 0)
    goto _jump4159;
    fail_assertion("negative array index");
    _jump4159:;
    if (v.d1 < b.d0)
    goto _jump4160;
    fail_assertion("index too large");
    _jump4160:;
    if (v.d0 >= 0)
    goto _jump4161;
    fail_assertion("negative array index");
    _jump4161:;
    if (v.d0 < b.d1)
    goto _jump4162;
    fail_assertion("index too large");
    _jump4162:;
    int64_t _251 = 0;
    _251 *= b.d0;
    _251 += v.d1;
    _251 *= b.d1;
    _251 += v.d0;
    int64_t _252 = b.data[_251];
    if (_252 > 0) 
    goto _jump4163;
    fail_assertion("non-positive loop bound");
    _jump4163:;
    _250 = 0;
    int64_t _253 = 0; // B
    int64_t _254 = 0; // A
    _jump4164:; // Begin body of loop
    int64_t _255 = 612;
    int64_t _256 = -_255;
    _250 += _256;
    _253++;
    if (_253 < _252)
    goto _jump4164;
    _253 = 0;
    _254++;
    if (_254 < q)
    goto _jump4164;
    // End body of loop
    _240.d1 = _250;
    if (_250 > 0) 
    goto _jump4165;
    fail_assertion("non-positive loop bound");
    _jump4165:;
    // Computing bound for C
    int64_t _257;
    // Computing bound for A
    if (d > 0) 
    goto _jump4166;
    fail_assertion("non-positive loop bound");
    _jump4166:;
    // Computing bound for B
    int64_t _258 = 875;
    if (_258 > 0) 
    goto _jump4167;
    fail_assertion("non-positive loop bound");
    _jump4167:;
    // Computing bound for C
    if (v.d1 > 0) 
    goto _jump4168;
    fail_assertion("non-positive loop bound");
    _jump4168:;
    _257 = 0;
    int64_t _259 = 0; // C
    int64_t _260 = 0; // B
    int64_t _261 = 0; // A
    _jump4169:; // Begin body of loop
    int64_t _262;
    if (!n)
    goto _jump4170;
    _262 = _261;
    goto _jump4171;
    _jump4170:;
    int64_t _263 = 954;
    _262 = _263;
    _jump4171:;
    _257 += _262;
    _259++;
    if (_259 < v.d1)
    goto _jump4169;
    _259 = 0;
    _260++;
    if (_260 < _258)
    goto _jump4169;
    _260 = 0;
    _261++;
    if (_261 < d)
    goto _jump4169;
    // End body of loop
    _240.d2 = _257;
    if (_257 > 0) 
    goto _jump4172;
    fail_assertion("non-positive loop bound");
    _jump4172:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= _242;
    _264 *= _250;
    _264 *= _257;
    _264 *= sizeof(bool);
    _240.data = jpl_alloc(_264);
    int64_t _265 = 0; // C
    int64_t _266 = 0; // B
    int64_t _267 = 0; // A
    _jump4173:; // Begin body of loop
    bool _269 = false;
    bool _268 = _269;
    if (0 == _269)
    goto _jump4174;
    o _270 = r();
    bool _271 = _270.c;
    _268 = _271;
    _jump4174:;
    int64_t _272 = 0;
    _272 *= _240.d0;
    _272 += _267;
    _272 *= _240.d1;
    _272 += _266;
    _272 *= _240.d2;
    _272 += _265;
    _240.data[_272] = _268;
    _265++;
    if (_265 < _257)
    goto _jump4173;
    _265 = 0;
    _266++;
    if (_266 < _250)
    goto _jump4173;
    _266 = 0;
    _267++;
    if (_267 < _242)
    goto _jump4173;
    // End body of loop
    _239 = _240;
    goto _jump4175;
    _jump4148:;
    bool _273 = true;
    _a3_bool _274;
    // Computing bound for A
    _274.d0 = q;
    if (q > 0) 
    goto _jump4176;
    fail_assertion("non-positive loop bound");
    _jump4176:;
    // Computing bound for B
    _274.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4177;
    fail_assertion("non-positive loop bound");
    _jump4177:;
    // Computing bound for C
    _274.d2 = q;
    if (q > 0) 
    goto _jump4178;
    fail_assertion("non-positive loop bound");
    _jump4178:;
    // Computing total size of heap memory to allocate
    int64_t _275 = 1;
    _275 *= q;
    _275 *= v.d2;
    _275 *= q;
    _275 *= sizeof(bool);
    _274.data = jpl_alloc(_275);
    int64_t _276 = 0; // C
    int64_t _277 = 0; // B
    int64_t _278 = 0; // A
    _jump4179:; // Begin body of loop
    bool _279 = false;
    int64_t _280 = 0;
    _280 *= _274.d0;
    _280 += _278;
    _280 *= _274.d1;
    _280 += _277;
    _280 *= _274.d2;
    _280 += _276;
    _274.data[_280] = _279;
    _276++;
    if (_276 < q)
    goto _jump4179;
    _276 = 0;
    _277++;
    if (_277 < v.d2)
    goto _jump4179;
    _277 = 0;
    _278++;
    if (_278 < q)
    goto _jump4179;
    // End body of loop
    _a1_rgba _281;
    // Computing bound for A
    _281.d0 = d;
    if (d > 0) 
    goto _jump4180;
    fail_assertion("non-positive loop bound");
    _jump4180:;
    // Computing total size of heap memory to allocate
    int64_t _282 = 1;
    _282 *= d;
    _282 *= sizeof(rgba);
    _281.data = jpl_alloc(_282);
    int64_t _283 = 0; // A
    _jump4181:; // Begin body of loop
    rgba _284 = t();
    int64_t _285 = 0;
    _285 *= _281.d0;
    _285 += _283;
    _281.data[_285] = _284;
    _283++;
    if (_283 < d)
    goto _jump4181;
    // End body of loop
    int64_t _286 = 556;
    if (_286 >= 0)
    goto _jump4182;
    fail_assertion("negative array index");
    _jump4182:;
    if (_286 < _281.d0)
    goto _jump4183;
    fail_assertion("index too large");
    _jump4183:;
    int64_t _287 = 0;
    _287 *= _281.d0;
    _287 += _286;
    rgba _288 = _281.data[_287];
    l _289 = { _273, _274, _288 };
    _a3_bool _290 = _289.b;
    _239 = _290;
    _jump4175:;
    double _291 = 63.0;
    double _292 = -_291;
    double _293 = 68.0;
    _a1_double _294;
    _294.d0 = 3;
    _294.data = jpl_alloc(sizeof(double) * 3);
    _294.data[0] = _292;
    _294.data[1] = g;
    _294.data[2] = _293;
    bool _295 = i(c);
    int64_t _296;
    if (!_295)
    goto _jump4184;
    _296 = d;
    goto _jump4185;
    _jump4184:;
    _296 = v.d2;
    _jump4185:;
    if (_296 >= 0)
    goto _jump4186;
    fail_assertion("negative array index");
    _jump4186:;
    if (_296 < _294.d0)
    goto _jump4187;
    fail_assertion("index too large");
    _jump4187:;
    int64_t _297 = 0;
    _297 *= _294.d0;
    _297 += _296;
    double _298 = _294.data[_297];
    double _299 = -_298;
    double _300 = -g;
    bool _301 = n;
    if (0 != n)
    goto _jump4188;
    bool _302 = true;
    _301 = _302;
    _jump4188:;
    double _303;
    if (!_301)
    goto _jump4189;
    _303 = g;
    goto _jump4190;
    _jump4189:;
    double _304 = 2.0;
    _303 = _304;
    _jump4190:;
    double _305 = -_303;
    double _306 = -_305;
    double _307 = 36.0;
    rgba _308 = { _299, _300, _306, _307 };
    l _309 = { _199, _239, _308 };
    _181 = _309;
    goto _jump4191;
    _jump4111:;
    _a3_o _310;
    if (!_164)
    goto _jump4192;
    _a3_o _311;
    if (!_164)
    goto _jump4193;
    _a3_o _312;
    // Computing bound for A
    if (c >= 0)
    goto _jump4194;
    fail_assertion("negative array index");
    _jump4194:;
    if (c < f.d0)
    goto _jump4195;
    fail_assertion("index too large");
    _jump4195:;
    if (d >= 0)
    goto _jump4196;
    fail_assertion("negative array index");
    _jump4196:;
    if (d < f.d1)
    goto _jump4197;
    fail_assertion("index too large");
    _jump4197:;
    int64_t _313 = 0;
    _313 *= f.d0;
    _313 += c;
    _313 *= f.d1;
    _313 += d;
    int64_t _314 = f.data[_313];
    _312.d0 = _314;
    if (_314 > 0) 
    goto _jump4198;
    fail_assertion("non-positive loop bound");
    _jump4198:;
    // Computing bound for B
    int64_t _315 = -v.d2;
    _312.d1 = _315;
    if (_315 > 0) 
    goto _jump4199;
    fail_assertion("non-positive loop bound");
    _jump4199:;
    // Computing bound for C
    _312.d2 = v.d0;
    if (v.d0 > 0) 
    goto _jump4200;
    fail_assertion("non-positive loop bound");
    _jump4200:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= _314;
    _316 *= _315;
    _316 *= v.d0;
    _316 *= sizeof(o);
    _312.data = jpl_alloc(_316);
    int64_t _317 = 0; // C
    int64_t _318 = 0; // B
    int64_t _319 = 0; // A
    _jump4201:; // Begin body of loop
    o _320 = r();
    int64_t _321 = 0;
    _321 *= _312.d0;
    _321 += _319;
    _321 *= _312.d1;
    _321 += _318;
    _321 *= _312.d2;
    _321 += _317;
    _312.data[_321] = _320;
    _317++;
    if (_317 < v.d0)
    goto _jump4201;
    _317 = 0;
    _318++;
    if (_318 < _315)
    goto _jump4201;
    _318 = 0;
    _319++;
    if (_319 < _314)
    goto _jump4201;
    // End body of loop
    _311 = _312;
    goto _jump4202;
    _jump4193:;
    _a3_o _322;
    // Computing bound for A
    _322.d0 = c;
    if (c > 0) 
    goto _jump4203;
    fail_assertion("non-positive loop bound");
    _jump4203:;
    // Computing bound for B
    int64_t _323 = 286;
    _322.d1 = _323;
    if (_323 > 0) 
    goto _jump4204;
    fail_assertion("non-positive loop bound");
    _jump4204:;
    // Computing bound for C
    _322.d2 = c;
    if (c > 0) 
    goto _jump4205;
    fail_assertion("non-positive loop bound");
    _jump4205:;
    // Computing total size of heap memory to allocate
    int64_t _324 = 1;
    _324 *= c;
    _324 *= _323;
    _324 *= c;
    _324 *= sizeof(o);
    _322.data = jpl_alloc(_324);
    int64_t _325 = 0; // C
    int64_t _326 = 0; // B
    int64_t _327 = 0; // A
    _jump4206:; // Begin body of loop
    o _328 = r();
    int64_t _329 = 0;
    _329 *= _322.d0;
    _329 += _327;
    _329 *= _322.d1;
    _329 += _326;
    _329 *= _322.d2;
    _329 += _325;
    _322.data[_329] = _328;
    _325++;
    if (_325 < c)
    goto _jump4206;
    _325 = 0;
    _326++;
    if (_326 < _323)
    goto _jump4206;
    _326 = 0;
    _327++;
    if (_327 < c)
    goto _jump4206;
    // End body of loop
    _311 = _322;
    _jump4202:;
    _310 = _311;
    goto _jump4207;
    _jump4192:;
    o _330 = r();
    bool _331 = _330.c;
    bool _332 = !_331;
    _a3_o _333;
    if (!_332)
    goto _jump4208;
    _a3_o _334;
    // Computing bound for A
    int64_t _335 = 650;
    _334.d0 = _335;
    if (_335 > 0) 
    goto _jump4209;
    fail_assertion("non-positive loop bound");
    _jump4209:;
    // Computing bound for B
    _334.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4210;
    fail_assertion("non-positive loop bound");
    _jump4210:;
    // Computing bound for C
    int64_t _336 = v.d0 % v.d2;
    _334.d2 = _336;
    if (_336 > 0) 
    goto _jump4211;
    fail_assertion("non-positive loop bound");
    _jump4211:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= _335;
    _337 *= v.d2;
    _337 *= _336;
    _337 *= sizeof(o);
    _334.data = jpl_alloc(_337);
    int64_t _338 = 0; // C
    int64_t _339 = 0; // B
    int64_t _340 = 0; // A
    _jump4212:; // Begin body of loop
    if (d >= 0)
    goto _jump4213;
    fail_assertion("negative array index");
    _jump4213:;
    if (d < p.d0)
    goto _jump4214;
    fail_assertion("index too large");
    _jump4214:;
    int64_t _341 = 0;
    _341 *= p.d0;
    _341 += d;
    o _342 = p.data[_341];
    int64_t _343 = 0;
    _343 *= _334.d0;
    _343 += _340;
    _343 *= _334.d1;
    _343 += _339;
    _343 *= _334.d2;
    _343 += _338;
    _334.data[_343] = _342;
    _338++;
    if (_338 < _336)
    goto _jump4212;
    _338 = 0;
    _339++;
    if (_339 < v.d2)
    goto _jump4212;
    _339 = 0;
    _340++;
    if (_340 < _335)
    goto _jump4212;
    // End body of loop
    _333 = _334;
    goto _jump4215;
    _jump4208:;
    _a3_o _344;
    // Computing bound for A
    int64_t _345 = -d;
    _344.d0 = _345;
    if (_345 > 0) 
    goto _jump4216;
    fail_assertion("non-positive loop bound");
    _jump4216:;
    // Computing bound for B
    _344.d1 = c;
    if (c > 0) 
    goto _jump4217;
    fail_assertion("non-positive loop bound");
    _jump4217:;
    // Computing bound for C
    _344.d2 = v.d2;
    if (v.d2 > 0) 
    goto _jump4218;
    fail_assertion("non-positive loop bound");
    _jump4218:;
    // Computing total size of heap memory to allocate
    int64_t _346 = 1;
    _346 *= _345;
    _346 *= c;
    _346 *= v.d2;
    _346 *= sizeof(o);
    _344.data = jpl_alloc(_346);
    int64_t _347 = 0; // C
    int64_t _348 = 0; // B
    int64_t _349 = 0; // A
    _jump4219:; // Begin body of loop
    o _350 = r();
    int64_t _351 = 0;
    _351 *= _344.d0;
    _351 += _349;
    _351 *= _344.d1;
    _351 += _348;
    _351 *= _344.d2;
    _351 += _347;
    _344.data[_351] = _350;
    _347++;
    if (_347 < v.d2)
    goto _jump4219;
    _347 = 0;
    _348++;
    if (_348 < c)
    goto _jump4219;
    _348 = 0;
    _349++;
    if (_349 < _345)
    goto _jump4219;
    // End body of loop
    _333 = _344;
    _jump4215:;
    _310 = _333;
    _jump4207:;
    int64_t _352;
    // Computing bound for A
    _a1_int64_t _353;
    // Computing bound for A
    _353.d0 = v.d0;
    if (v.d0 > 0) 
    goto _jump4220;
    fail_assertion("non-positive loop bound");
    _jump4220:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= v.d0;
    _354 *= sizeof(int64_t);
    _353.data = jpl_alloc(_354);
    int64_t _355 = 0; // A
    _jump4221:; // Begin body of loop
    int64_t _356 = 0;
    _356 *= _353.d0;
    _356 += _355;
    _353.data[_356] = v.d0;
    _355++;
    if (_355 < v.d0)
    goto _jump4221;
    // End body of loop
    if (v.d0 >= 0)
    goto _jump4222;
    fail_assertion("negative array index");
    _jump4222:;
    if (v.d0 < _353.d0)
    goto _jump4223;
    fail_assertion("index too large");
    _jump4223:;
    int64_t _357 = 0;
    _357 *= _353.d0;
    _357 += v.d0;
    int64_t _358 = _353.data[_357];
    if (_358 > 0) 
    goto _jump4224;
    fail_assertion("non-positive loop bound");
    _jump4224:;
    // Computing bound for B
    if (v.d1 > 0) 
    goto _jump4225;
    fail_assertion("non-positive loop bound");
    _jump4225:;
    // Computing bound for C
    int64_t _359 = 816;
    if (_359 > 0) 
    goto _jump4226;
    fail_assertion("non-positive loop bound");
    _jump4226:;
    _352 = 0;
    int64_t _360 = 0; // C
    int64_t _361 = 0; // B
    int64_t _362 = 0; // A
    _jump4227:; // Begin body of loop
    _352 += _362;
    _360++;
    if (_360 < _359)
    goto _jump4227;
    _360 = 0;
    _361++;
    if (_361 < v.d1)
    goto _jump4227;
    _361 = 0;
    _362++;
    if (_362 < _358)
    goto _jump4227;
    // End body of loop
    if (_352 >= 0)
    goto _jump4228;
    fail_assertion("negative array index");
    _jump4228:;
    if (_352 < b.d0)
    goto _jump4229;
    fail_assertion("index too large");
    _jump4229:;
    if (q >= 0)
    goto _jump4230;
    fail_assertion("negative array index");
    _jump4230:;
    if (q < b.d1)
    goto _jump4231;
    fail_assertion("index too large");
    _jump4231:;
    int64_t _363 = 0;
    _363 *= b.d0;
    _363 += _352;
    _363 *= b.d1;
    _363 += q;
    int64_t _364 = b.data[_363];
    int64_t _365;
    // Computing bound for A
    if (v.d2 > 0) 
    goto _jump4232;
    fail_assertion("non-positive loop bound");
    _jump4232:;
    // Computing bound for B
    int64_t _366;
    // Computing bound for A
    int64_t _367 = 147;
    int64_t _368 = -_367;
    if (_368 > 0) 
    goto _jump4233;
    fail_assertion("non-positive loop bound");
    _jump4233:;
    // Computing bound for B
    if (q > 0) 
    goto _jump4234;
    fail_assertion("non-positive loop bound");
    _jump4234:;
    // Computing bound for C
    int64_t _369 = 65;
    int64_t _370 = _369 % v.d0;
    int64_t _371 = _370 * c;
    if (_371 > 0) 
    goto _jump4235;
    fail_assertion("non-positive loop bound");
    _jump4235:;
    _366 = 0;
    int64_t _372 = 0; // C
    int64_t _373 = 0; // B
    int64_t _374 = 0; // A
    _jump4236:; // Begin body of loop
    int64_t _375;
    if (!n)
    goto _jump4237;
    _375 = v.d1;
    goto _jump4238;
    _jump4237:;
    _375 = _374;
    _jump4238:;
    int64_t _376 = q % _375;
    _366 += _376;
    _372++;
    if (_372 < _371)
    goto _jump4236;
    _372 = 0;
    _373++;
    if (_373 < q)
    goto _jump4236;
    _373 = 0;
    _374++;
    if (_374 < _368)
    goto _jump4236;
    // End body of loop
    if (_366 > 0) 
    goto _jump4239;
    fail_assertion("non-positive loop bound");
    _jump4239:;
    // Computing bound for C
    _a1_int64_t _377;
    // Computing bound for A
    _377.d0 = v.d1;
    if (v.d1 > 0) 
    goto _jump4240;
    fail_assertion("non-positive loop bound");
    _jump4240:;
    // Computing total size of heap memory to allocate
    int64_t _378 = 1;
    _378 *= v.d1;
    _378 *= sizeof(int64_t);
    _377.data = jpl_alloc(_378);
    int64_t _379 = 0; // A
    _jump4241:; // Begin body of loop
    int64_t _380 = 90;
    int64_t _381 = 0;
    _381 *= _377.d0;
    _381 += _379;
    _377.data[_381] = _380;
    _379++;
    if (_379 < v.d1)
    goto _jump4241;
    // End body of loop
    int64_t _382 = 366;
    if (_382 >= 0)
    goto _jump4242;
    fail_assertion("negative array index");
    _jump4242:;
    if (_382 < _377.d0)
    goto _jump4243;
    fail_assertion("index too large");
    _jump4243:;
    int64_t _383 = 0;
    _383 *= _377.d0;
    _383 += _382;
    int64_t _384 = _377.data[_383];
    if (d >= 0)
    goto _jump4244;
    fail_assertion("negative array index");
    _jump4244:;
    if (d < b.d0)
    goto _jump4245;
    fail_assertion("index too large");
    _jump4245:;
    if (_384 >= 0)
    goto _jump4246;
    fail_assertion("negative array index");
    _jump4246:;
    if (_384 < b.d1)
    goto _jump4247;
    fail_assertion("index too large");
    _jump4247:;
    int64_t _385 = 0;
    _385 *= b.d0;
    _385 += d;
    _385 *= b.d1;
    _385 += _384;
    int64_t _386 = b.data[_385];
    if (_386 > 0) 
    goto _jump4248;
    fail_assertion("non-positive loop bound");
    _jump4248:;
    _365 = 0;
    int64_t _387 = 0; // C
    int64_t _388 = 0; // B
    int64_t _389 = 0; // A
    _jump4249:; // Begin body of loop
    _a1_int64_t _390;
    _390.d0 = 3;
    _390.data = jpl_alloc(sizeof(int64_t) * 3);
    _390.data[0] = v.d1;
    _390.data[1] = v.d2;
    _390.data[2] = _389;
    if (d >= 0)
    goto _jump4250;
    fail_assertion("negative array index");
    _jump4250:;
    if (d < _390.d0)
    goto _jump4251;
    fail_assertion("index too large");
    _jump4251:;
    int64_t _391 = 0;
    _391 *= _390.d0;
    _391 += d;
    int64_t _392 = _390.data[_391];
    _365 += _392;
    _387++;
    if (_387 < _386)
    goto _jump4249;
    _387 = 0;
    _388++;
    if (_388 < _366)
    goto _jump4249;
    _388 = 0;
    _389++;
    if (_389 < v.d2)
    goto _jump4249;
    // End body of loop
    if (v.d0 >= 0)
    goto _jump4252;
    fail_assertion("negative array index");
    _jump4252:;
    if (v.d0 < _310.d0)
    goto _jump4253;
    fail_assertion("index too large");
    _jump4253:;
    if (_364 >= 0)
    goto _jump4254;
    fail_assertion("negative array index");
    _jump4254:;
    if (_364 < _310.d1)
    goto _jump4255;
    fail_assertion("index too large");
    _jump4255:;
    if (_365 >= 0)
    goto _jump4256;
    fail_assertion("negative array index");
    _jump4256:;
    if (_365 < _310.d2)
    goto _jump4257;
    fail_assertion("index too large");
    _jump4257:;
    int64_t _393 = 0;
    _393 *= _310.d0;
    _393 += v.d0;
    _393 *= _310.d1;
    _393 += _364;
    _393 *= _310.d2;
    _393 += _365;
    o _394 = _310.data[_393];
    l _395 = _394.a;
    _181 = _395;
    _jump4191:;
    return _181;
    int64_t _396;
    if (!n)
    goto _jump4258;
    int64_t _397 = 944;
    _396 = _397;
    goto _jump4259;
    _jump4258:;
    _396 = d;
    _jump4259:;
    bool _398 = true;
    int64_t _399;
    if (!_398)
    goto _jump4260;
    int64_t _400 = -q;
    int64_t _401;
    // Computing bound for A
    if (q > 0) 
    goto _jump4261;
    fail_assertion("non-positive loop bound");
    _jump4261:;
    _401 = 0;
    int64_t _402 = 0; // A
    _jump4262:; // Begin body of loop
    _401 += v.d2;
    _402++;
    if (_402 < q)
    goto _jump4262;
    // End body of loop
    int64_t _403 = _400 + _401;
    _399 = _403;
    goto _jump4263;
    _jump4260:;
    int64_t _404;
    // Computing bound for A
    int64_t _405 = -v.d1;
    if (_405 > 0) 
    goto _jump4264;
    fail_assertion("non-positive loop bound");
    _jump4264:;
    _404 = 0;
    int64_t _406 = 0; // A
    _jump4265:; // Begin body of loop
    _404 += c;
    _406++;
    if (_406 < _405)
    goto _jump4265;
    // End body of loop
    int64_t _407;
    // Computing bound for A
    _a2_int64_t _408;
    // Computing bound for A
    _408.d0 = v.d1;
    if (v.d1 > 0) 
    goto _jump4266;
    fail_assertion("non-positive loop bound");
    _jump4266:;
    // Computing bound for B
    _408.d1 = q;
    if (q > 0) 
    goto _jump4267;
    fail_assertion("non-positive loop bound");
    _jump4267:;
    // Computing total size of heap memory to allocate
    int64_t _409 = 1;
    _409 *= v.d1;
    _409 *= q;
    _409 *= sizeof(int64_t);
    _408.data = jpl_alloc(_409);
    int64_t _410 = 0; // B
    int64_t _411 = 0; // A
    _jump4268:; // Begin body of loop
    int64_t _412 = 0;
    _412 *= _408.d0;
    _412 += _411;
    _412 *= _408.d1;
    _412 += _410;
    _408.data[_412] = v.d1;
    _410++;
    if (_410 < q)
    goto _jump4268;
    _410 = 0;
    _411++;
    if (_411 < v.d1)
    goto _jump4268;
    // End body of loop
    _a1_int64_t _413;
    _413.d0 = 1;
    _413.data = jpl_alloc(sizeof(int64_t) * 1);
    _413.data[0] = v.d2;
    if (v.d0 >= 0)
    goto _jump4269;
    fail_assertion("negative array index");
    _jump4269:;
    if (v.d0 < _413.d0)
    goto _jump4270;
    fail_assertion("index too large");
    _jump4270:;
    int64_t _414 = 0;
    _414 *= _413.d0;
    _414 += v.d0;
    int64_t _415 = _413.data[_414];
    int64_t _416;
    // Computing bound for A
    int64_t _417 = 917;
    if (_417 > 0) 
    goto _jump4271;
    fail_assertion("non-positive loop bound");
    _jump4271:;
    // Computing bound for B
    bool _418 = true;
    int64_t _419;
    if (!_418)
    goto _jump4272;
    _419 = q;
    goto _jump4273;
    _jump4272:;
    _419 = d;
    _jump4273:;
    if (_419 > 0) 
    goto _jump4274;
    fail_assertion("non-positive loop bound");
    _jump4274:;
    // Computing bound for C
    if (d > 0) 
    goto _jump4275;
    fail_assertion("non-positive loop bound");
    _jump4275:;
    _416 = 0;
    int64_t _420 = 0; // C
    int64_t _421 = 0; // B
    int64_t _422 = 0; // A
    _jump4276:; // Begin body of loop
    _416 += v.d2;
    _420++;
    if (_420 < d)
    goto _jump4276;
    _420 = 0;
    _421++;
    if (_421 < _419)
    goto _jump4276;
    _421 = 0;
    _422++;
    if (_422 < _417)
    goto _jump4276;
    // End body of loop
    if (_415 >= 0)
    goto _jump4277;
    fail_assertion("negative array index");
    _jump4277:;
    if (_415 < _408.d0)
    goto _jump4278;
    fail_assertion("index too large");
    _jump4278:;
    if (_416 >= 0)
    goto _jump4279;
    fail_assertion("negative array index");
    _jump4279:;
    if (_416 < _408.d1)
    goto _jump4280;
    fail_assertion("index too large");
    _jump4280:;
    int64_t _423 = 0;
    _423 *= _408.d0;
    _423 += _415;
    _423 *= _408.d1;
    _423 += _416;
    int64_t _424 = _408.data[_423];
    if (_424 > 0) 
    goto _jump4281;
    fail_assertion("non-positive loop bound");
    _jump4281:;
    // Computing bound for B
    if (d >= 0)
    goto _jump4282;
    fail_assertion("negative array index");
    _jump4282:;
    if (d < v.d0)
    goto _jump4283;
    fail_assertion("index too large");
    _jump4283:;
    if (v.d0 >= 0)
    goto _jump4284;
    fail_assertion("negative array index");
    _jump4284:;
    if (v.d0 < v.d1)
    goto _jump4285;
    fail_assertion("index too large");
    _jump4285:;
    if (c >= 0)
    goto _jump4286;
    fail_assertion("negative array index");
    _jump4286:;
    if (c < v.d2)
    goto _jump4287;
    fail_assertion("index too large");
    _jump4287:;
    int64_t _425 = 0;
    _425 *= v.d0;
    _425 += d;
    _425 *= v.d1;
    _425 += v.d0;
    _425 *= v.d2;
    _425 += c;
    int64_t _426 = v.data[_425];
    if (_426 > 0) 
    goto _jump4288;
    fail_assertion("non-positive loop bound");
    _jump4288:;
    _407 = 0;
    int64_t _427 = 0; // B
    int64_t _428 = 0; // A
    _jump4289:; // Begin body of loop
    _407 += q;
    _427++;
    if (_427 < _426)
    goto _jump4289;
    _427 = 0;
    _428++;
    if (_428 < _424)
    goto _jump4289;
    // End body of loop
    int64_t _429 = _404 % _407;
    _399 = _429;
    _jump4263:;
    bool _430 = _396 > _399;
    if (0 != _430)
    goto _jump4290;
    fail_assertion("A");
    _jump4290:;
    int64_t _431;
    // Computing bound for A
    int64_t _432 = 782;
    if (_432 > 0) 
    goto _jump4291;
    fail_assertion("non-positive loop bound");
    _jump4291:;
    // Computing bound for B
    int64_t _433 = q / v.d0;
    int64_t _434 = -_433;
    if (_434 > 0) 
    goto _jump4292;
    fail_assertion("non-positive loop bound");
    _jump4292:;
    _431 = 0;
    int64_t _435 = 0; // B
    int64_t _436 = 0; // A
    _jump4293:; // Begin body of loop
    _431 += v.d1;
    _435++;
    if (_435 < _434)
    goto _jump4293;
    _435 = 0;
    _436++;
    if (_436 < _432)
    goto _jump4293;
    // End body of loop
    int64_t _437 = d * _431;
    _a1_int64_t _438;
    _438.d0 = 1;
    _438.data = jpl_alloc(sizeof(int64_t) * 1);
    _438.data[0] = _437;
    if (d >= 0)
    goto _jump4294;
    fail_assertion("negative array index");
    _jump4294:;
    if (d < _438.d0)
    goto _jump4295;
    fail_assertion("index too large");
    _jump4295:;
    int64_t _439 = 0;
    _439 *= _438.d0;
    _439 += d;
    int64_t _440 = _438.data[_439];
    _a2_int64_t _441;
    // Computing bound for A
    _441.d0 = v.d2;
    if (v.d2 > 0) 
    goto _jump4296;
    fail_assertion("non-positive loop bound");
    _jump4296:;
    // Computing bound for B
    _441.d1 = v.d0;
    if (v.d0 > 0) 
    goto _jump4297;
    fail_assertion("non-positive loop bound");
    _jump4297:;
    // Computing total size of heap memory to allocate
    int64_t _442 = 1;
    _442 *= v.d2;
    _442 *= v.d0;
    _442 *= sizeof(int64_t);
    _441.data = jpl_alloc(_442);
    int64_t _443 = 0; // B
    int64_t _444 = 0; // A
    _jump4298:; // Begin body of loop
    int64_t _445 = 0;
    _445 *= _441.d0;
    _445 += _444;
    _445 *= _441.d1;
    _445 += _443;
    _441.data[_445] = d;
    _443++;
    if (_443 < v.d0)
    goto _jump4298;
    _443 = 0;
    _444++;
    if (_444 < v.d2)
    goto _jump4298;
    // End body of loop
    if (q >= 0)
    goto _jump4299;
    fail_assertion("negative array index");
    _jump4299:;
    if (q < _441.d0)
    goto _jump4300;
    fail_assertion("index too large");
    _jump4300:;
    if (v.d2 >= 0)
    goto _jump4301;
    fail_assertion("negative array index");
    _jump4301:;
    if (v.d2 < _441.d1)
    goto _jump4302;
    fail_assertion("index too large");
    _jump4302:;
    int64_t _446 = 0;
    _446 *= _441.d0;
    _446 += q;
    _446 *= _441.d1;
    _446 += v.d2;
    int64_t _447 = _441.data[_446];
    bool _448 = _440 != _447;
    if (0 != _448)
    goto _jump4303;
    fail_assertion("A");
    _jump4303:;
    _a1__a2_int64_t _450;
    // Computing bound for A
    _450.d0 = q;
    if (q > 0) 
    goto _jump4304;
    fail_assertion("non-positive loop bound");
    _jump4304:;
    // Computing total size of heap memory to allocate
    int64_t _451 = 1;
    _451 *= q;
    _451 *= sizeof(_a2_int64_t);
    _450.data = jpl_alloc(_451);
    int64_t _452 = 0; // A
    _jump4305:; // Begin body of loop
    int64_t _453 = 0;
    _453 *= _450.d0;
    _453 += _452;
    _450.data[_453] = f;
    _452++;
    if (_452 < q)
    goto _jump4305;
    // End body of loop
    if (v.d2 >= 0)
    goto _jump4306;
    fail_assertion("negative array index");
    _jump4306:;
    if (v.d2 < _450.d0)
    goto _jump4307;
    fail_assertion("index too large");
    _jump4307:;
    int64_t _454 = 0;
    _454 *= _450.d0;
    _454 += v.d2;
    _a2_int64_t _455 = _450.data[_454];
    int64_t _456 = 332;
    int64_t _457 = -d;
    if (_457 >= 0)
    goto _jump4308;
    fail_assertion("negative array index");
    _jump4308:;
    if (_457 < f.d0)
    goto _jump4309;
    fail_assertion("index too large");
    _jump4309:;
    if (v.d2 >= 0)
    goto _jump4310;
    fail_assertion("negative array index");
    _jump4310:;
    if (v.d2 < f.d1)
    goto _jump4311;
    fail_assertion("index too large");
    _jump4311:;
    int64_t _458 = 0;
    _458 *= f.d0;
    _458 += _457;
    _458 *= f.d1;
    _458 += v.d2;
    int64_t _459 = f.data[_458];
    if (_456 >= 0)
    goto _jump4312;
    fail_assertion("negative array index");
    _jump4312:;
    if (_456 < _455.d0)
    goto _jump4313;
    fail_assertion("index too large");
    _jump4313:;
    if (_459 >= 0)
    goto _jump4314;
    fail_assertion("negative array index");
    _jump4314:;
    if (_459 < _455.d1)
    goto _jump4315;
    fail_assertion("index too large");
    _jump4315:;
    int64_t _460 = 0;
    _460 *= _455.d0;
    _460 += _456;
    _460 *= _455.d1;
    _460 += _459;
    int64_t _461 = _455.data[_460];
    bool _462 = i(_461);
    bool _449 = _462;
    if (0 != _462)
    goto _jump4316;
    _449 = _164;
    _jump4316:;
    _a2__a1_l _463;
    // Computing bound for A
    _463.d0 = c;
    if (c > 0) 
    goto _jump4317;
    fail_assertion("non-positive loop bound");
    _jump4317:;
    // Computing bound for B
    _463.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4318;
    fail_assertion("non-positive loop bound");
    _jump4318:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= c;
    _464 *= v.d2;
    _464 *= sizeof(_a1_l);
    _463.data = jpl_alloc(_464);
    int64_t _465 = 0; // B
    int64_t _466 = 0; // A
    _jump4319:; // Begin body of loop
    l _467 = u(v);
    _a1_l _468;
    _468.d0 = 1;
    _468.data = jpl_alloc(sizeof(l) * 1);
    _468.data[0] = _467;
    int64_t _469 = 0;
    _469 *= _463.d0;
    _469 += _466;
    _469 *= _463.d1;
    _469 += _465;
    _463.data[_469] = _468;
    _465++;
    if (_465 < v.d2)
    goto _jump4319;
    _465 = 0;
    _466++;
    if (_466 < c)
    goto _jump4319;
    // End body of loop
    if (q >= 0)
    goto _jump4320;
    fail_assertion("negative array index");
    _jump4320:;
    if (q < _463.d0)
    goto _jump4321;
    fail_assertion("index too large");
    _jump4321:;
    if (v.d0 >= 0)
    goto _jump4322;
    fail_assertion("negative array index");
    _jump4322:;
    if (v.d0 < _463.d1)
    goto _jump4323;
    fail_assertion("index too large");
    _jump4323:;
    int64_t _470 = 0;
    _470 *= _463.d0;
    _470 += q;
    _470 *= _463.d1;
    _470 += v.d0;
    _a1_l _471 = _463.data[_470];
    if (c >= 0)
    goto _jump4324;
    fail_assertion("negative array index");
    _jump4324:;
    if (c < _471.d0)
    goto _jump4325;
    fail_assertion("index too large");
    _jump4325:;
    int64_t _472 = 0;
    _472 *= _471.d0;
    _472 += c;
    l _473 = _471.data[_472];
    _a3_bool _474 = _473.b;
    rgba _475 = a();
    l _476 = { _449, _474, _475 };
    return _476;
    bool _477 = i(v.d2);
    _a3__a3_bool _478;
    // Computing bound for A
    int64_t _479 = -c;
    _478.d0 = _479;
    if (_479 > 0) 
    goto _jump4326;
    fail_assertion("non-positive loop bound");
    _jump4326:;
    // Computing bound for B
    bool _480 = !n;
    int64_t _481;
    if (!_480)
    goto _jump4327;
    _481 = v.d1;
    goto _jump4328;
    _jump4327:;
    bool _482 = n;
    if (0 == n)
    goto _jump4329;
    bool _483 = true;
    _482 = _483;
    _jump4329:;
    int64_t _484;
    if (!_482)
    goto _jump4330;
    _484 = d;
    goto _jump4331;
    _jump4330:;
    _484 = c;
    _jump4331:;
    _481 = _484;
    _jump4328:;
    int64_t _485 = -_481;
    _478.d1 = _485;
    if (_485 > 0) 
    goto _jump4332;
    fail_assertion("non-positive loop bound");
    _jump4332:;
    // Computing bound for C
    _478.d2 = v.d1;
    if (v.d1 > 0) 
    goto _jump4333;
    fail_assertion("non-positive loop bound");
    _jump4333:;
    // Computing total size of heap memory to allocate
    int64_t _486 = 1;
    _486 *= _479;
    _486 *= _485;
    _486 *= v.d1;
    _486 *= sizeof(_a3_bool);
    _478.data = jpl_alloc(_486);
    int64_t _487 = 0; // C
    int64_t _488 = 0; // B
    int64_t _489 = 0; // A
    _jump4334:; // Begin body of loop
    int64_t _490;
    if (!_164)
    goto _jump4335;
    _490 = v.d1;
    goto _jump4336;
    _jump4335:;
    int64_t _491;
    // Computing bound for D
    int64_t _492 = 499;
    if (_492 > 0) 
    goto _jump4337;
    fail_assertion("non-positive loop bound");
    _jump4337:;
    // Computing bound for E
    if (c > 0) 
    goto _jump4338;
    fail_assertion("non-positive loop bound");
    _jump4338:;
    // Computing bound for F
    if (q > 0) 
    goto _jump4339;
    fail_assertion("non-positive loop bound");
    _jump4339:;
    _491 = 0;
    int64_t _493 = 0; // F
    int64_t _494 = 0; // E
    int64_t _495 = 0; // D
    _jump4340:; // Begin body of loop
    _491 += _488;
    _493++;
    if (_493 < q)
    goto _jump4340;
    _493 = 0;
    _494++;
    if (_494 < c)
    goto _jump4340;
    _494 = 0;
    _495++;
    if (_495 < _492)
    goto _jump4340;
    // End body of loop
    _490 = _491;
    _jump4336:;
    bool _496 = i(_490);
    _a3_bool _497;
    if (!_496)
    goto _jump4341;
    _a3_bool _498;
    // Computing bound for D
    int64_t _499 = v.d2 - d;
    _498.d0 = _499;
    if (_499 > 0) 
    goto _jump4342;
    fail_assertion("non-positive loop bound");
    _jump4342:;
    // Computing bound for E
    _498.d1 = v.d2;
    if (v.d2 > 0) 
    goto _jump4343;
    fail_assertion("non-positive loop bound");
    _jump4343:;
    // Computing bound for F
    int64_t _500 = 545;
    _498.d2 = _500;
    if (_500 > 0) 
    goto _jump4344;
    fail_assertion("non-positive loop bound");
    _jump4344:;
    // Computing total size of heap memory to allocate
    int64_t _501 = 1;
    _501 *= _499;
    _501 *= v.d2;
    _501 *= _500;
    _501 *= sizeof(bool);
    _498.data = jpl_alloc(_501);
    int64_t _502 = 0; // F
    int64_t _503 = 0; // E
    int64_t _504 = 0; // D
    _jump4345:; // Begin body of loop
    o _505 = r();
    bool _506 = _505.c;
    bool _507 = !_506;
    int64_t _508 = 0;
    _508 *= _498.d0;
    _508 += _504;
    _508 *= _498.d1;
    _508 += _503;
    _508 *= _498.d2;
    _508 += _502;
    _498.data[_508] = _507;
    _502++;
    if (_502 < _500)
    goto _jump4345;
    _502 = 0;
    _503++;
    if (_503 < v.d2)
    goto _jump4345;
    _503 = 0;
    _504++;
    if (_504 < _499)
    goto _jump4345;
    // End body of loop
    _497 = _498;
    goto _jump4346;
    _jump4341:;
    _a3_bool _509;
    // Computing bound for D
    _509.d0 = v.d2;
    if (v.d2 > 0) 
    goto _jump4347;
    fail_assertion("non-positive loop bound");
    _jump4347:;
    // Computing bound for E
    int64_t _510 = 597;
    _509.d1 = _510;
    if (_510 > 0) 
    goto _jump4348;
    fail_assertion("non-positive loop bound");
    _jump4348:;
    // Computing bound for F
    _509.d2 = v.d0;
    if (v.d0 > 0) 
    goto _jump4349;
    fail_assertion("non-positive loop bound");
    _jump4349:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= v.d2;
    _511 *= _510;
    _511 *= v.d0;
    _511 *= sizeof(bool);
    _509.data = jpl_alloc(_511);
    int64_t _512 = 0; // F
    int64_t _513 = 0; // E
    int64_t _514 = 0; // D
    _jump4350:; // Begin body of loop
    int64_t _515 = 0;
    _515 *= _509.d0;
    _515 += _514;
    _515 *= _509.d1;
    _515 += _513;
    _515 *= _509.d2;
    _515 += _512;
    _509.data[_515] = n;
    _512++;
    if (_512 < v.d0)
    goto _jump4350;
    _512 = 0;
    _513++;
    if (_513 < _510)
    goto _jump4350;
    _513 = 0;
    _514++;
    if (_514 < v.d2)
    goto _jump4350;
    // End body of loop
    _a1__a3_bool _516;
    _516.d0 = 1;
    _516.data = jpl_alloc(sizeof(_a3_bool) * 1);
    _516.data[0] = _509;
    if (v.d1 >= 0)
    goto _jump4351;
    fail_assertion("negative array index");
    _jump4351:;
    if (v.d1 < _516.d0)
    goto _jump4352;
    fail_assertion("index too large");
    _jump4352:;
    int64_t _517 = 0;
    _517 *= _516.d0;
    _517 += v.d1;
    _a3_bool _518 = _516.data[_517];
    _497 = _518;
    _jump4346:;
    int64_t _519 = 0;
    _519 *= _478.d0;
    _519 += _489;
    _519 *= _478.d1;
    _519 += _488;
    _519 *= _478.d2;
    _519 += _487;
    _478.data[_519] = _497;
    _487++;
    if (_487 < v.d1)
    goto _jump4334;
    _487 = 0;
    _488++;
    if (_488 < _485)
    goto _jump4334;
    _488 = 0;
    _489++;
    if (_489 < _479)
    goto _jump4334;
    // End body of loop
    int64_t _520 = 793;
    int64_t _521 = -_520;
    int64_t _522 = _521 - d;
    o _523 = r();
    l _524 = _523.a;
    rgba _525 = t();
    rgba _526 = a();
    rgba _527 = m();
    _a1_rgba _528;
    _528.d0 = 3;
    _528.data = jpl_alloc(sizeof(rgba) * 3);
    _528.data[0] = _525;
    _528.data[1] = _526;
    _528.data[2] = _527;
    if (v.d1 >= 0)
    goto _jump4353;
    fail_assertion("negative array index");
    _jump4353:;
    if (v.d1 < _528.d0)
    goto _jump4354;
    fail_assertion("index too large");
    _jump4354:;
    int64_t _529 = 0;
    _529 *= _528.d0;
    _529 += v.d1;
    rgba _530 = _528.data[_529];
    int64_t _531 = 811;
    int64_t _532;
    if (!_164)
    goto _jump4355;
    _532 = v.d0;
    goto _jump4356;
    _jump4355:;
    int64_t _533 = 792;
    _532 = _533;
    _jump4356:;
    bool _534 = _531 != _532;
    o _535 = { _524, _530, _534 };
    bool _536 = _535.c;
    int64_t _537;
    if (!_536)
    goto _jump4357;
    _537 = v.d2;
    goto _jump4358;
    _jump4357:;
    _537 = v.d1;
    _jump4358:;
    int64_t _538 = 586;
    if (_522 >= 0)
    goto _jump4359;
    fail_assertion("negative array index");
    _jump4359:;
    if (_522 < _478.d0)
    goto _jump4360;
    fail_assertion("index too large");
    _jump4360:;
    if (_537 >= 0)
    goto _jump4361;
    fail_assertion("negative array index");
    _jump4361:;
    if (_537 < _478.d1)
    goto _jump4362;
    fail_assertion("index too large");
    _jump4362:;
    if (_538 >= 0)
    goto _jump4363;
    fail_assertion("negative array index");
    _jump4363:;
    if (_538 < _478.d2)
    goto _jump4364;
    fail_assertion("index too large");
    _jump4364:;
    int64_t _539 = 0;
    _539 *= _478.d0;
    _539 += _522;
    _539 *= _478.d1;
    _539 += _537;
    _539 *= _478.d2;
    _539 += _538;
    _a3_bool _540 = _478.data[_539];
    bool _542 = !n;
    bool _541 = _542;
    if (0 == _542)
    goto _jump4365;
    bool _543 = i(c);
    _541 = _543;
    _jump4365:;
    o _544;
    if (!_541)
    goto _jump4366;
    o _545 = r();
    _544 = _545;
    goto _jump4367;
    _jump4366:;
    o _546 = r();
    _544 = _546;
    _jump4367:;
    _a1_o _547;
    _547.d0 = 1;
    _547.data = jpl_alloc(sizeof(o) * 1);
    _547.data[0] = _544;
    if (q >= 0)
    goto _jump4368;
    fail_assertion("negative array index");
    _jump4368:;
    if (q < _547.d0)
    goto _jump4369;
    fail_assertion("index too large");
    _jump4369:;
    int64_t _548 = 0;
    _548 *= _547.d0;
    _548 += q;
    o _549 = _547.data[_548];
    rgba _550 = _549.b;
    l _551 = { _477, _540, _550 };
    return _551;
}

void jpl_main(struct args args) {
    bool _0 = true;
    double _1;
    if (!_0)
    goto _jump1;
    double _2 = 52.0;
    double _3 = -_2;
    _1 = _3;
    goto _jump2;
    _jump1:;
    double _4 = 85.0;
    _1 = _4;
    _jump2:;
    double _5 = -_1;
    double _6 = 56.0;
    double _7 = -_6;
    double _8 = 36.0;
    double _9 = -_8;
    double _10 = 29.0;
    rgba _11 = { _5, _7, _9, _10 };
    double _12 = _11.a;
    bool _13 = false;
    double _14;
    if (!_13)
    goto _jump3;
    double _15 = 99.0;
    double _16 = -_15;
    double _17 = -_16;
    _14 = _17;
    goto _jump4;
    _jump3:;
    double _18;
    // Computing bound for a
    int64_t _19 = 884;
    int64_t _20 = -_19;
    if (_20 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing bound for b
    int64_t _21 = 752;
    int64_t _22 = 83;
    int64_t _23 = _21 % _22;
    if (_23 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    _18 = 0;
    int64_t _24 = 0; // b
    int64_t _25 = 0; // a
    _jump7:; // Begin body of loop
    double _26 = 15.0;
    _18 += _26;
    _24++;
    if (_24 < _23)
    goto _jump7;
    _24 = 0;
    _25++;
    if (_25 < _20)
    goto _jump7;
    // End body of loop
    double _27 = -_18;
    _14 = _27;
    _jump4:;
    double _28;
    // Computing bound for a
    int64_t _29 = 537;
    int64_t _30 = 740;
    int64_t _31 = 637;
    int64_t _32 = _30 / _31;
    bool _33 = _29 <= _32;
    int64_t _34;
    if (!_33)
    goto _jump8;
    int64_t _35 = 888;
    bool _36 = true;
    int64_t _37;
    if (!_36)
    goto _jump9;
    int64_t _38 = 815;
    _37 = _38;
    goto _jump10;
    _jump9:;
    int64_t _39 = 710;
    _37 = _39;
    _jump10:;
    int64_t _40 = _35 / _37;
    _34 = _40;
    goto _jump11;
    _jump8:;
    bool _41 = false;
    bool _42 = !_41;
    int64_t _43;
    if (!_42)
    goto _jump12;
    int64_t _44 = 933;
    _43 = _44;
    goto _jump13;
    _jump12:;
    int64_t _45 = 952;
    _43 = _45;
    _jump13:;
    _34 = _43;
    _jump11:;
    if (_34 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    _28 = 0;
    int64_t _46 = 0; // a
    _jump15:; // Begin body of loop
    int64_t _47 = 612;
    int64_t _48 = _47 * _46;
    bool _49 = _48 > _46;
    double _50;
    if (!_49)
    goto _jump16;
    double _51 = 0.0;
    double _52 = -_51;
    _50 = _52;
    goto _jump17;
    _jump16:;
    double _53 = 40.0;
    _50 = _53;
    _jump17:;
    _28 += _50;
    _46++;
    if (_46 < _34)
    goto _jump15;
    // End body of loop
    double _54 = _14 + _28;
    bool _55 = _12 < _54;
    _a2_rgba _56;
    if (!_55)
    goto _jump18;
    _a2_rgba _57;
    // Computing bound for a
    int64_t _58 = 410;
    int64_t _59;
    // Computing bound for a
    int64_t _60 = 726;
    if (_60 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    // Computing bound for b
    int64_t _61 = 333;
    if (_61 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _59 = 0;
    int64_t _62 = 0; // b
    int64_t _63 = 0; // a
    _jump21:; // Begin body of loop
    int64_t _64 = 313;
    _59 += _64;
    _62++;
    if (_62 < _61)
    goto _jump21;
    _62 = 0;
    _63++;
    if (_63 < _60)
    goto _jump21;
    // End body of loop
    int64_t _65 = _58 / _59;
    int64_t _66 = -_65;
    int64_t _67 = -_66;
    int64_t _68 = -_67;
    _57.d0 = _68;
    if (_68 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    // Computing bound for b
    _a1_int64_t _69;
    // Computing bound for a
    int64_t _70;
    // Computing bound for a
    int64_t _71 = 141;
    if (_71 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    // Computing bound for b
    int64_t _72 = 208;
    if (_72 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    // Computing bound for c
    int64_t _73;
    // Computing bound for a
    int64_t _74 = 448;
    if (_74 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    _73 = 0;
    int64_t _75 = 0; // a
    _jump26:; // Begin body of loop
    _73 += _75;
    _75++;
    if (_75 < _74)
    goto _jump26;
    // End body of loop
    if (_73 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _70 = 0;
    int64_t _76 = 0; // c
    int64_t _77 = 0; // b
    int64_t _78 = 0; // a
    _jump28:; // Begin body of loop
    _70 += _78;
    _76++;
    if (_76 < _73)
    goto _jump28;
    _76 = 0;
    _77++;
    if (_77 < _72)
    goto _jump28;
    _77 = 0;
    _78++;
    if (_78 < _71)
    goto _jump28;
    // End body of loop
    int64_t _79 = -_70;
    _69.d0 = _79;
    if (_79 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= _79;
    _80 *= sizeof(int64_t);
    _69.data = jpl_alloc(_80);
    int64_t _81 = 0; // a
    _jump30:; // Begin body of loop
    int64_t _82 = 699;
    bool _83 = true;
    int64_t _84;
    if (!_83)
    goto _jump31;
    _84 = _81;
    goto _jump32;
    _jump31:;
    int64_t _85 = 670;
    _84 = _85;
    _jump32:;
    int64_t _86 = _82 * _84;
    int64_t _87 = 0;
    _87 *= _69.d0;
    _87 += _81;
    _69.data[_87] = _86;
    _81++;
    if (_81 < _79)
    goto _jump30;
    // End body of loop
    _a1_bool _88;
    // Computing bound for a
    int64_t _89 = 733;
    _88.d0 = _89;
    if (_89 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing total size of heap memory to allocate
    int64_t _90 = 1;
    _90 *= _89;
    _90 *= sizeof(bool);
    _88.data = jpl_alloc(_90);
    int64_t _91 = 0; // a
    _jump34:; // Begin body of loop
    bool _92 = true;
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _91;
    _88.data[_93] = _92;
    _91++;
    if (_91 < _89)
    goto _jump34;
    // End body of loop
    int64_t _94 = 349;
    if (_94 >= 0)
    goto _jump35;
    fail_assertion("negative array index");
    _jump35:;
    if (_94 < _88.d0)
    goto _jump36;
    fail_assertion("index too large");
    _jump36:;
    int64_t _95 = 0;
    _95 *= _88.d0;
    _95 += _94;
    bool _96 = _88.data[_95];
    int64_t _97;
    if (!_96)
    goto _jump37;
    int64_t _98 = 720;
    _97 = _98;
    goto _jump38;
    _jump37:;
    int64_t _99 = 492;
    int64_t _100 = 739;
    int64_t _101 = -_100;
    _a1_int64_t _102;
    _102.d0 = 2;
    _102.data = jpl_alloc(sizeof(int64_t) * 2);
    _102.data[0] = _99;
    _102.data[1] = _101;
    int64_t _103;
    // Computing bound for a
    int64_t _104 = 499;
    int64_t _105 = -_104;
    if (_105 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    // Computing bound for b
    int64_t _106 = 750;
    if (_106 > 0) 
    goto _jump40;
    fail_assertion("non-positive loop bound");
    _jump40:;
    // Computing bound for c
    int64_t _107 = 127;
    int64_t _108 = -_107;
    if (_108 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    _103 = 0;
    int64_t _109 = 0; // c
    int64_t _110 = 0; // b
    int64_t _111 = 0; // a
    _jump42:; // Begin body of loop
    _103 += _109;
    _109++;
    if (_109 < _108)
    goto _jump42;
    _109 = 0;
    _110++;
    if (_110 < _106)
    goto _jump42;
    _110 = 0;
    _111++;
    if (_111 < _105)
    goto _jump42;
    // End body of loop
    if (_103 >= 0)
    goto _jump43;
    fail_assertion("negative array index");
    _jump43:;
    if (_103 < _102.d0)
    goto _jump44;
    fail_assertion("index too large");
    _jump44:;
    int64_t _112 = 0;
    _112 *= _102.d0;
    _112 += _103;
    int64_t _113 = _102.data[_112];
    _97 = _113;
    _jump38:;
    if (_97 >= 0)
    goto _jump45;
    fail_assertion("negative array index");
    _jump45:;
    if (_97 < _69.d0)
    goto _jump46;
    fail_assertion("index too large");
    _jump46:;
    int64_t _114 = 0;
    _114 *= _69.d0;
    _114 += _97;
    int64_t _115 = _69.data[_114];
    _57.d1 = _115;
    if (_115 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= _68;
    _116 *= _115;
    _116 *= sizeof(rgba);
    _57.data = jpl_alloc(_116);
    int64_t _117 = 0; // b
    int64_t _118 = 0; // a
    _jump48:; // Begin body of loop
    double _119 = 78.0;
    double _120 = 7.0;
    double _121 = -_120;
    int64_t _123 = 501;
    int64_t _124 = 283;
    bool _125 = _123 < _124;
    bool _122 = _125;
    if (0 == _125)
    goto _jump49;
    int64_t _126 = 344;
    int64_t _127;
    // Computing bound for c
    if (_118 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    // Computing bound for d
    int64_t _128 = 997;
    if (_128 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    // Computing bound for e
    if (_117 > 0) 
    goto _jump52;
    fail_assertion("non-positive loop bound");
    _jump52:;
    _127 = 0;
    int64_t _129 = 0; // e
    int64_t _130 = 0; // d
    int64_t _131 = 0; // c
    _jump53:; // Begin body of loop
    _127 += _117;
    _129++;
    if (_129 < _117)
    goto _jump53;
    _129 = 0;
    _130++;
    if (_130 < _128)
    goto _jump53;
    _130 = 0;
    _131++;
    if (_131 < _118)
    goto _jump53;
    // End body of loop
    bool _132 = _126 == _127;
    _122 = _132;
    _jump49:;
    double _133;
    if (!_122)
    goto _jump54;
    double _134 = 96.0;
    double _135 = -_134;
    double _136 = -_135;
    _133 = _136;
    goto _jump55;
    _jump54:;
    double _137 = 36.0;
    _133 = _137;
    _jump55:;
    double _138 = 78.0;
    double _139;
    // Computing bound for c
    int64_t _140 = 542;
    int64_t _141 = _117 / _140;
    if (_141 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    _139 = 0;
    int64_t _142 = 0; // c
    _jump57:; // Begin body of loop
    double _143;
    // Computing bound for d
    int64_t _144 = 861;
    if (_144 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    _143 = 0;
    int64_t _145 = 0; // d
    _jump59:; // Begin body of loop
    double _146 = 19.0;
    _143 += _146;
    _145++;
    if (_145 < _144)
    goto _jump59;
    // End body of loop
    _139 += _143;
    _142++;
    if (_142 < _141)
    goto _jump57;
    // End body of loop
    double _147 = _138 / _139;
    double _148 = -_147;
    rgba _149 = { _119, _121, _133, _148 };
    int64_t _150 = 0;
    _150 *= _57.d0;
    _150 += _118;
    _150 *= _57.d1;
    _150 += _117;
    _57.data[_150] = _149;
    _117++;
    if (_117 < _115)
    goto _jump48;
    _117 = 0;
    _118++;
    if (_118 < _68)
    goto _jump48;
    // End body of loop
    _56 = _57;
    goto _jump60;
    _jump18:;
    _a2__a2_rgba _151;
    // Computing bound for a
    int64_t _152;
    // Computing bound for a
    int64_t _153 = 121;
    if (_153 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing bound for b
    int64_t _154 = 365;
    if (_154 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    _152 = 0;
    int64_t _155 = 0; // b
    int64_t _156 = 0; // a
    _jump63:; // Begin body of loop
    _152 += _156;
    _155++;
    if (_155 < _154)
    goto _jump63;
    _155 = 0;
    _156++;
    if (_156 < _153)
    goto _jump63;
    // End body of loop
    _151.d0 = _152;
    if (_152 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing bound for b
    _a1_int64_t _157;
    // Computing bound for a
    int64_t _158 = 46;
    _157.d0 = _158;
    if (_158 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _158;
    _159 *= sizeof(int64_t);
    _157.data = jpl_alloc(_159);
    int64_t _160 = 0; // a
    _jump66:; // Begin body of loop
    int64_t _161 = 149;
    int64_t _162 = -_161;
    int64_t _163 = 0;
    _163 *= _157.d0;
    _163 += _160;
    _157.data[_163] = _162;
    _160++;
    if (_160 < _158)
    goto _jump66;
    // End body of loop
    int64_t _164 = 736;
    if (_164 >= 0)
    goto _jump67;
    fail_assertion("negative array index");
    _jump67:;
    if (_164 < _157.d0)
    goto _jump68;
    fail_assertion("index too large");
    _jump68:;
    int64_t _165 = 0;
    _165 *= _157.d0;
    _165 += _164;
    int64_t _166 = _157.data[_165];
    _151.d1 = _166;
    if (_166 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= _152;
    _167 *= _166;
    _167 *= sizeof(_a2_rgba);
    _151.data = jpl_alloc(_167);
    int64_t _168 = 0; // b
    int64_t _169 = 0; // a
    _jump70:; // Begin body of loop
    _a2_rgba _170;
    // Computing bound for c
    int64_t _171 = 751;
    bool _172 = _169 < _171;
    int64_t _173;
    if (!_172)
    goto _jump71;
    int64_t _174 = _168 / _168;
    int64_t _175 = -_174;
    _173 = _175;
    goto _jump72;
    _jump71:;
    _173 = _169;
    _jump72:;
    _170.d0 = _173;
    if (_173 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing bound for d
    bool _176 = _169 >= _168;
    int64_t _177;
    if (!_176)
    goto _jump74;
    int64_t _178;
    // Computing bound for c
    if (_169 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for d
    int64_t _179 = -_169;
    if (_179 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for e
    int64_t _180 = 992;
    if (_180 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    _178 = 0;
    int64_t _181 = 0; // e
    int64_t _182 = 0; // d
    int64_t _183 = 0; // c
    _jump78:; // Begin body of loop
    _178 += _169;
    _181++;
    if (_181 < _180)
    goto _jump78;
    _181 = 0;
    _182++;
    if (_182 < _179)
    goto _jump78;
    _182 = 0;
    _183++;
    if (_183 < _169)
    goto _jump78;
    // End body of loop
    _177 = _178;
    goto _jump79;
    _jump74:;
    int64_t _184 = 668;
    _177 = _184;
    _jump79:;
    _170.d1 = _177;
    if (_177 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    // Computing total size of heap memory to allocate
    int64_t _185 = 1;
    _185 *= _173;
    _185 *= _177;
    _185 *= sizeof(rgba);
    _170.data = jpl_alloc(_185);
    int64_t _186 = 0; // d
    int64_t _187 = 0; // c
    _jump81:; // Begin body of loop
    double _188 = 4.0;
    double _189 = -_188;
    double _190;
    // Computing bound for e
    int64_t _191;
    // Computing bound for e
    if (_186 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing bound for f
    int64_t _192 = 341;
    if (_192 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    // Computing bound for g
    if (_187 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    _191 = 0;
    int64_t _193 = 0; // g
    int64_t _194 = 0; // f
    int64_t _195 = 0; // e
    _jump85:; // Begin body of loop
    _191 += _169;
    _193++;
    if (_193 < _187)
    goto _jump85;
    _193 = 0;
    _194++;
    if (_194 < _192)
    goto _jump85;
    _194 = 0;
    _195++;
    if (_195 < _186)
    goto _jump85;
    // End body of loop
    if (_191 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    // Computing bound for f
    if (_186 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    _190 = 0;
    int64_t _196 = 0; // f
    int64_t _197 = 0; // e
    _jump88:; // Begin body of loop
    double _198 = 61.0;
    double _199 = -_198;
    _190 += _199;
    _196++;
    if (_196 < _186)
    goto _jump88;
    _196 = 0;
    _197++;
    if (_197 < _191)
    goto _jump88;
    // End body of loop
    double _200 = 1.0;
    double _201 = 95.0;
    double _202 = _200 + _201;
    double _203;
    // Computing bound for e
    int64_t _204 = _168 / _169;
    if (_204 > 0) 
    goto _jump89;
    fail_assertion("non-positive loop bound");
    _jump89:;
    // Computing bound for f
    if (_169 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    _203 = 0;
    int64_t _205 = 0; // f
    int64_t _206 = 0; // e
    _jump91:; // Begin body of loop
    double _207 = 79.0;
    _203 += _207;
    _205++;
    if (_205 < _169)
    goto _jump91;
    _205 = 0;
    _206++;
    if (_206 < _204)
    goto _jump91;
    // End body of loop
    rgba _208 = { _189, _190, _202, _203 };
    int64_t _209 = 0;
    _209 *= _170.d0;
    _209 += _187;
    _209 *= _170.d1;
    _209 += _186;
    _170.data[_209] = _208;
    _186++;
    if (_186 < _177)
    goto _jump81;
    _186 = 0;
    _187++;
    if (_187 < _173)
    goto _jump81;
    // End body of loop
    int64_t _210 = 0;
    _210 *= _151.d0;
    _210 += _169;
    _210 *= _151.d1;
    _210 += _168;
    _151.data[_210] = _170;
    _168++;
    if (_168 < _166)
    goto _jump70;
    _168 = 0;
    _169++;
    if (_169 < _152)
    goto _jump70;
    // End body of loop
    int64_t _211 = 78;
    bool _212 = true;
    bool _213 = !_212;
    bool _214;
    if (!_213)
    goto _jump92;
    bool _215 = true;
    _214 = _215;
    goto _jump93;
    _jump92:;
    bool _216 = true;
    _214 = _216;
    _jump93:;
    bool _217 = !_214;
    bool _218 = !_217;
    int64_t _219;
    if (!_218)
    goto _jump94;
    bool _220 = false;
    bool _221;
    if (!_220)
    goto _jump95;
    double _222 = 41.0;
    double _223 = 67.0;
    bool _224 = _222 == _223;
    _221 = _224;
    goto _jump96;
    _jump95:;
    bool _226 = true;
    bool _227 = false;
    bool _228 = _226 != _227;
    bool _225 = _228;
    if (0 != _228)
    goto _jump97;
    bool _229 = false;
    bool _230 = !_229;
    _225 = _230;
    _jump97:;
    _221 = _225;
    _jump96:;
    int64_t _231;
    if (!_221)
    goto _jump98;
    int64_t _232 = 18;
    int64_t _233 = 95;
    int64_t _234 = -_233;
    int64_t _235 = _232 + _234;
    int64_t _236 = 118;
    int64_t _237 = _235 / _236;
    _231 = _237;
    goto _jump99;
    _jump98:;
    int64_t _238 = 229;
    int64_t _239 = 756;
    int64_t _240 = _238 - _239;
    _231 = _240;
    _jump99:;
    _219 = _231;
    goto _jump100;
    _jump94:;
    bool _241 = true;
    bool _242 = true;
    _a1_bool _243;
    _243.d0 = 2;
    _243.data = jpl_alloc(sizeof(bool) * 2);
    _243.data[0] = _241;
    _243.data[1] = _242;
    int64_t _244 = 99;
    int64_t _245 = 880;
    int64_t _246 = _244 + _245;
    if (_246 >= 0)
    goto _jump101;
    fail_assertion("negative array index");
    _jump101:;
    if (_246 < _243.d0)
    goto _jump102;
    fail_assertion("index too large");
    _jump102:;
    int64_t _247 = 0;
    _247 *= _243.d0;
    _247 += _246;
    bool _248 = _243.data[_247];
    int64_t _249;
    if (!_248)
    goto _jump103;
    int64_t _250 = 240;
    int64_t _251 = 651;
    int64_t _252 = _250 * _251;
    _249 = _252;
    goto _jump104;
    _jump103:;
    int64_t _253 = 66;
    int64_t _254 = -_253;
    _249 = _254;
    _jump104:;
    int64_t _255 = -_249;
    _219 = _255;
    _jump100:;
    if (_211 >= 0)
    goto _jump105;
    fail_assertion("negative array index");
    _jump105:;
    if (_211 < _151.d0)
    goto _jump106;
    fail_assertion("index too large");
    _jump106:;
    if (_219 >= 0)
    goto _jump107;
    fail_assertion("negative array index");
    _jump107:;
    if (_219 < _151.d1)
    goto _jump108;
    fail_assertion("index too large");
    _jump108:;
    int64_t _256 = 0;
    _256 *= _151.d0;
    _256 += _211;
    _256 *= _151.d1;
    _256 += _219;
    _a2_rgba _257 = _151.data[_256];
    _56 = _257;
    _jump60:;
    write_image(_56, "a.png");
    _a3_bool _258;
    // Computing bound for b
    int64_t _259 = 788;
    _258.d0 = _259;
    if (_259 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for c
    int64_t _260;
    // Computing bound for b
    int64_t _261;
    // Computing bound for b
    int64_t _262 = 506;
    if (_262 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for c
    int64_t _263 = 741;
    if (_263 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    _261 = 0;
    int64_t _264 = 0; // c
    int64_t _265 = 0; // b
    _jump556:; // Begin body of loop
    int64_t _266 = -_264;
    _261 += _266;
    _264++;
    if (_264 < _263)
    goto _jump556;
    _264 = 0;
    _265++;
    if (_265 < _262)
    goto _jump556;
    // End body of loop
    if (_261 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for c
    int64_t _267 = 193;
    int64_t _268;
    // Computing bound for b
    int64_t _269 = 139;
    if (_269 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing bound for c
    int64_t _270 = 582;
    if (_270 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    _268 = 0;
    int64_t _271 = 0; // c
    int64_t _272 = 0; // b
    _jump560:; // Begin body of loop
    _268 += _272;
    _271++;
    if (_271 < _270)
    goto _jump560;
    _271 = 0;
    _272++;
    if (_272 < _269)
    goto _jump560;
    // End body of loop
    int64_t _273 = _267 % _268;
    if (_273 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for d
    int64_t _274 = 606;
    int64_t _275 = 947;
    int64_t _276 = _274 + _275;
    if (_276 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    _260 = 0;
    int64_t _277 = 0; // d
    int64_t _278 = 0; // c
    int64_t _279 = 0; // b
    _jump563:; // Begin body of loop
    _260 += _279;
    _277++;
    if (_277 < _276)
    goto _jump563;
    _277 = 0;
    _278++;
    if (_278 < _273)
    goto _jump563;
    _278 = 0;
    _279++;
    if (_279 < _261)
    goto _jump563;
    // End body of loop
    _258.d1 = _260;
    if (_260 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing bound for d
    int64_t _280 = 467;
    _258.d2 = _280;
    if (_280 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing total size of heap memory to allocate
    int64_t _281 = 1;
    _281 *= _259;
    _281 *= _260;
    _281 *= _280;
    _281 *= sizeof(bool);
    _258.data = jpl_alloc(_281);
    int64_t _282 = 0; // d
    int64_t _283 = 0; // c
    int64_t _284 = 0; // b
    _jump566:; // Begin body of loop
    bool _285 = true;
    bool _286 = !_285;
    bool _287 = !_286;
    int64_t _288 = 0;
    _288 *= _258.d0;
    _288 += _284;
    _288 *= _258.d1;
    _288 += _283;
    _288 *= _258.d2;
    _288 += _282;
    _258.data[_288] = _287;
    _282++;
    if (_282 < _280)
    goto _jump566;
    _282 = 0;
    _283++;
    if (_283 < _260)
    goto _jump566;
    _283 = 0;
    _284++;
    if (_284 < _259)
    goto _jump566;
    // End body of loop
    int64_t _289 = 355;
    int64_t _290 = -_289;
    int64_t _291 = 314;
    int64_t _292 = -_291;
    int64_t _293 = -_292;
    bool _294 = _290 >= _293;
    int64_t _295;
    if (!_294)
    goto _jump567;
    bool _297 = true;
    bool _298 = !_297;
    bool _296 = _298;
    if (0 == _298)
    goto _jump568;
    bool _299 = false;
    bool _300 = false;
    bool _301 = _299 == _300;
    _296 = _301;
    _jump568:;
    int64_t _302;
    if (!_296)
    goto _jump569;
    int64_t _303 = 874;
    _302 = _303;
    goto _jump570;
    _jump569:;
    int64_t _304 = 506;
    _302 = _304;
    _jump570:;
    _295 = _302;
    goto _jump571;
    _jump567:;
    bool _306 = false;
    bool _305 = _306;
    if (0 != _306)
    goto _jump572;
    bool _308 = true;
    bool _307 = _308;
    if (0 == _308)
    goto _jump573;
    bool _309 = true;
    _307 = _309;
    _jump573:;
    _305 = _307;
    _jump572:;
    int64_t _310;
    if (!_305)
    goto _jump574;
    int64_t _311;
    // Computing bound for b
    int64_t _312;
    // Computing bound for b
    int64_t _313 = 589;
    if (_313 > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    _312 = 0;
    int64_t _314 = 0; // b
    _jump576:; // Begin body of loop
    int64_t _315 = 213;
    _312 += _315;
    _314++;
    if (_314 < _313)
    goto _jump576;
    // End body of loop
    if (_312 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing bound for c
    int64_t _316 = 123;
    if (_316 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing bound for d
    int64_t _317 = 55;
    int64_t _318 = 691;
    int64_t _319 = _317 + _318;
    if (_319 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    _311 = 0;
    int64_t _320 = 0; // d
    int64_t _321 = 0; // c
    int64_t _322 = 0; // b
    _jump580:; // Begin body of loop
    _311 += _320;
    _320++;
    if (_320 < _319)
    goto _jump580;
    _320 = 0;
    _321++;
    if (_321 < _316)
    goto _jump580;
    _321 = 0;
    _322++;
    if (_322 < _312)
    goto _jump580;
    // End body of loop
    _310 = _311;
    goto _jump581;
    _jump574:;
    bool _323 = true;
    bool _324 = !_323;
    int64_t _325;
    if (!_324)
    goto _jump582;
    int64_t _326 = 155;
    _325 = _326;
    goto _jump583;
    _jump582:;
    int64_t _327 = 143;
    int64_t _328 = -_327;
    _325 = _328;
    _jump583:;
    _310 = _325;
    _jump581:;
    _295 = _310;
    _jump571:;
    int64_t _329;
    // Computing bound for b
    int64_t _330 = 693;
    if (_330 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing bound for c
    int64_t _331 = 648;
    if (_331 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing bound for d
    int64_t _332 = 153;
    if (_332 > 0) 
    goto _jump586;
    fail_assertion("non-positive loop bound");
    _jump586:;
    _329 = 0;
    int64_t _333 = 0; // d
    int64_t _334 = 0; // c
    int64_t _335 = 0; // b
    _jump587:; // Begin body of loop
    _329 += _333;
    _333++;
    if (_333 < _332)
    goto _jump587;
    _333 = 0;
    _334++;
    if (_334 < _331)
    goto _jump587;
    _334 = 0;
    _335++;
    if (_335 < _330)
    goto _jump587;
    // End body of loop
    int64_t _336 = -_329;
    int64_t _337;
    // Computing bound for b
    int64_t _338;
    // Computing bound for b
    int64_t _339 = 58;
    int64_t _340 = -_339;
    int64_t _341 = -_340;
    if (_341 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing bound for c
    int64_t _342 = 830;
    if (_342 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    _338 = 0;
    int64_t _343 = 0; // c
    int64_t _344 = 0; // b
    _jump590:; // Begin body of loop
    int64_t _345 = -_344;
    int64_t _346 = -_345;
    _338 += _346;
    _343++;
    if (_343 < _342)
    goto _jump590;
    _343 = 0;
    _344++;
    if (_344 < _341)
    goto _jump590;
    // End body of loop
    if (_338 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for c
    int64_t _347;
    // Computing bound for b
    int64_t _348 = 550;
    if (_348 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    _347 = 0;
    int64_t _349 = 0; // b
    _jump593:; // Begin body of loop
    int64_t _350;
    // Computing bound for c
    if (_349 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for d
    if (_349 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing bound for e
    if (_349 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    _350 = 0;
    int64_t _351 = 0; // e
    int64_t _352 = 0; // d
    int64_t _353 = 0; // c
    _jump597:; // Begin body of loop
    _350 += _353;
    _351++;
    if (_351 < _349)
    goto _jump597;
    _351 = 0;
    _352++;
    if (_352 < _349)
    goto _jump597;
    _352 = 0;
    _353++;
    if (_353 < _349)
    goto _jump597;
    // End body of loop
    int64_t _354 = -_350;
    _347 += _354;
    _349++;
    if (_349 < _348)
    goto _jump593;
    // End body of loop
    if (_347 > 0) 
    goto _jump598;
    fail_assertion("non-positive loop bound");
    _jump598:;
    _337 = 0;
    int64_t _355 = 0; // c
    int64_t _356 = 0; // b
    _jump599:; // Begin body of loop
    int64_t _357;
    // Computing bound for d
    if (_355 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing bound for e
    if (_356 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    _357 = 0;
    int64_t _358 = 0; // e
    int64_t _359 = 0; // d
    _jump602:; // Begin body of loop
    _357 += _359;
    _358++;
    if (_358 < _356)
    goto _jump602;
    _358 = 0;
    _359++;
    if (_359 < _355)
    goto _jump602;
    // End body of loop
    int64_t _360;
    // Computing bound for d
    if (_356 > 0) 
    goto _jump603;
    fail_assertion("non-positive loop bound");
    _jump603:;
    _360 = 0;
    int64_t _361 = 0; // d
    _jump604:; // Begin body of loop
    _360 += _361;
    _361++;
    if (_361 < _356)
    goto _jump604;
    // End body of loop
    int64_t _362 = _357 - _360;
    int64_t _363 = -_362;
    _337 += _363;
    _355++;
    if (_355 < _347)
    goto _jump599;
    _355 = 0;
    _356++;
    if (_356 < _338)
    goto _jump599;
    // End body of loop
    if (_295 >= 0)
    goto _jump605;
    fail_assertion("negative array index");
    _jump605:;
    if (_295 < _258.d0)
    goto _jump606;
    fail_assertion("index too large");
    _jump606:;
    if (_336 >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (_336 < _258.d1)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    if (_337 >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (_337 < _258.d2)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _364 = 0;
    _364 *= _258.d0;
    _364 += _295;
    _364 *= _258.d1;
    _364 += _336;
    _364 *= _258.d2;
    _364 += _337;
    bool _365 = _258.data[_364];
    bool _366;
    if (!_365)
    goto _jump611;
    int64_t _368 = 628;
    int64_t _369 = 362;
    int64_t _370 = -_369;
    bool _371 = _368 > _370;
    bool _372 = !_371;
    bool _373;
    if (!_372)
    goto _jump612;
    bool _374 = true;
    _373 = _374;
    goto _jump613;
    _jump612:;
    bool _375 = false;
    _373 = _375;
    _jump613:;
    bool _367 = _373;
    if (0 == _373)
    goto _jump614;
    rgba _376 = a();
    double _377 = _376.b;
    double _378 = 16.0;
    double _379 = _377 / _378;
    double _380 = 90.0;
    bool _381 = _379 <= _380;
    _367 = _381;
    _jump614:;
    _366 = _367;
    goto _jump615;
    _jump611:;
    bool _382 = true;
    bool _383 = !_382;
    bool _384;
    if (!_383)
    goto _jump616;
    bool _385 = true;
    bool _386;
    if (!_385)
    goto _jump617;
    bool _387 = false;
    _386 = _387;
    goto _jump618;
    _jump617:;
    bool _388 = true;
    bool _389 = !_388;
    _386 = _389;
    _jump618:;
    _384 = _386;
    goto _jump619;
    _jump616:;
    bool _390 = true;
    bool _391;
    if (!_390)
    goto _jump620;
    bool _392 = true;
    _391 = _392;
    goto _jump621;
    _jump620:;
    bool _393 = true;
    _391 = _393;
    _jump621:;
    bool _394 = !_391;
    _384 = _394;
    _jump619:;
    _a2_bool _395;
    if (!_384)
    goto _jump622;
    _a2_bool _396;
    // Computing bound for b
    int64_t _397 = 757;
    int64_t _398 = 102;
    int64_t _399 = _397 - _398;
    int64_t _400 = 887;
    int64_t _401 = 820;
    int64_t _402 = _400 * _401;
    int64_t _403 = _399 / _402;
    _396.d0 = _403;
    if (_403 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    // Computing bound for c
    int64_t _404 = 199;
    int64_t _405 = -_404;
    _396.d1 = _405;
    if (_405 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _403;
    _406 *= _405;
    _406 *= sizeof(bool);
    _396.data = jpl_alloc(_406);
    int64_t _407 = 0; // c
    int64_t _408 = 0; // b
    _jump625:; // Begin body of loop
    rgba _409 = a();
    double _410 = _409.a;
    rgba _411 = a();
    double _412 = _411.b;
    bool _413 = _410 != _412;
    int64_t _414 = 0;
    _414 *= _396.d0;
    _414 += _408;
    _414 *= _396.d1;
    _414 += _407;
    _396.data[_414] = _413;
    _407++;
    if (_407 < _405)
    goto _jump625;
    _407 = 0;
    _408++;
    if (_408 < _403)
    goto _jump625;
    // End body of loop
    _395 = _396;
    goto _jump626;
    _jump622:;
    _a2_bool _415;
    // Computing bound for b
    int64_t _416;
    // Computing bound for b
    int64_t _417 = 487;
    int64_t _418 = 321;
    int64_t _419 = _417 + _418;
    if (_419 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    _416 = 0;
    int64_t _420 = 0; // b
    _jump628:; // Begin body of loop
    _416 += _420;
    _420++;
    if (_420 < _419)
    goto _jump628;
    // End body of loop
    _415.d0 = _416;
    if (_416 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    // Computing bound for c
    int64_t _421 = 300;
    _415.d1 = _421;
    if (_421 > 0) 
    goto _jump630;
    fail_assertion("non-positive loop bound");
    _jump630:;
    // Computing total size of heap memory to allocate
    int64_t _422 = 1;
    _422 *= _416;
    _422 *= _421;
    _422 *= sizeof(bool);
    _415.data = jpl_alloc(_422);
    int64_t _423 = 0; // c
    int64_t _424 = 0; // b
    _jump631:; // Begin body of loop
    bool _425 = true;
    int64_t _426 = 0;
    _426 *= _415.d0;
    _426 += _424;
    _426 *= _415.d1;
    _426 += _423;
    _415.data[_426] = _425;
    _423++;
    if (_423 < _421)
    goto _jump631;
    _423 = 0;
    _424++;
    if (_424 < _416)
    goto _jump631;
    // End body of loop
    _395 = _415;
    _jump626:;
    bool _427 = false;
    bool _428 = !_427;
    bool _429 = !_428;
    int64_t _430;
    if (!_429)
    goto _jump632;
    int64_t _431 = 777;
    _430 = _431;
    goto _jump633;
    _jump632:;
    int64_t _432 = 821;
    int64_t _433 = -_432;
    int64_t _434 = -_433;
    _430 = _434;
    _jump633:;
    int64_t _435 = -_430;
    int64_t _436;
    // Computing bound for b
    int64_t _437 = 523;
    int64_t _438 = -_437;
    int64_t _439 = -_438;
    int64_t _440 = 201;
    int64_t _441 = -_440;
    int64_t _442 = _439 - _441;
    if (_442 > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing bound for c
    int64_t _443;
    // Computing bound for b
    int64_t _444 = 62;
    if (_444 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    _443 = 0;
    int64_t _445 = 0; // b
    _jump636:; // Begin body of loop
    int64_t _446 = 951;
    int64_t _447 = -_446;
    _443 += _447;
    _445++;
    if (_445 < _444)
    goto _jump636;
    // End body of loop
    int64_t _448 = -_443;
    if (_448 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for d
    int64_t _449 = 605;
    if (_449 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    _436 = 0;
    int64_t _450 = 0; // d
    int64_t _451 = 0; // c
    int64_t _452 = 0; // b
    _jump639:; // Begin body of loop
    _436 += _450;
    _450++;
    if (_450 < _449)
    goto _jump639;
    _450 = 0;
    _451++;
    if (_451 < _448)
    goto _jump639;
    _451 = 0;
    _452++;
    if (_452 < _442)
    goto _jump639;
    // End body of loop
    if (_435 >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (_435 < _395.d0)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    if (_436 >= 0)
    goto _jump642;
    fail_assertion("negative array index");
    _jump642:;
    if (_436 < _395.d1)
    goto _jump643;
    fail_assertion("index too large");
    _jump643:;
    int64_t _453 = 0;
    _453 *= _395.d0;
    _453 += _435;
    _453 *= _395.d1;
    _453 += _436;
    bool _454 = _395.data[_453];
    _366 = _454;
    _jump615:;
    _a2_int64_t _455;
    if (!_366)
    goto _jump644;
    _a2__a2_int64_t _456;
    // Computing bound for b
    int64_t _457 = 571;
    _456.d0 = _457;
    if (_457 > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    // Computing bound for c
    bool _458 = true;
    bool _459 = !_458;
    bool _460 = true;
    bool _461 = _459 != _460;
    bool _462 = !_461;
    int64_t _463;
    if (!_462)
    goto _jump646;
    int64_t _464 = 889;
    int64_t _465 = -_464;
    int64_t _466 = -_465;
    _463 = _466;
    goto _jump647;
    _jump646:;
    bool _467 = true;
    bool _468 = !_467;
    bool _469 = !_468;
    int64_t _470;
    if (!_469)
    goto _jump648;
    int64_t _471;
    // Computing bound for b
    int64_t _472 = 489;
    int64_t _473 = -_472;
    if (_473 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    _471 = 0;
    int64_t _474 = 0; // b
    _jump650:; // Begin body of loop
    int64_t _475 = 531;
    _471 += _475;
    _474++;
    if (_474 < _473)
    goto _jump650;
    // End body of loop
    _470 = _471;
    goto _jump651;
    _jump648:;
    int64_t _476 = 880;
    _a1_int64_t _477;
    _477.d0 = 1;
    _477.data = jpl_alloc(sizeof(int64_t) * 1);
    _477.data[0] = _476;
    int64_t _478 = 0;
    int64_t _479 = -_478;
    if (_479 >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (_479 < _477.d0)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    int64_t _480 = 0;
    _480 *= _477.d0;
    _480 += _479;
    int64_t _481 = _477.data[_480];
    _470 = _481;
    _jump651:;
    _463 = _470;
    _jump647:;
    _456.d1 = _463;
    if (_463 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing total size of heap memory to allocate
    int64_t _482 = 1;
    _482 *= _457;
    _482 *= _463;
    _482 *= sizeof(_a2_int64_t);
    _456.data = jpl_alloc(_482);
    int64_t _483 = 0; // c
    int64_t _484 = 0; // b
    _jump655:; // Begin body of loop
    bool _486 = true;
    bool _487;
    if (!_486)
    goto _jump656;
    bool _488 = true;
    bool _489 = !_488;
    _487 = _489;
    goto _jump657;
    _jump656:;
    bool _490 = false;
    bool _491 = false;
    bool _492 = _490 == _491;
    _487 = _492;
    _jump657:;
    bool _485 = _487;
    if (0 == _487)
    goto _jump658;
    bool _493 = false;
    _485 = _493;
    _jump658:;
    _a2_int64_t _494;
    if (!_485)
    goto _jump659;
    _a3__a2_int64_t _495;
    // Computing bound for d
    int64_t _496 = 917;
    _495.d0 = _496;
    if (_496 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for e
    int64_t _497 = 175;
    int64_t _498 = _497 / _484;
    _495.d1 = _498;
    if (_498 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing bound for f
    int64_t _499 = -_483;
    _495.d2 = _499;
    if (_499 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing total size of heap memory to allocate
    int64_t _500 = 1;
    _500 *= _496;
    _500 *= _498;
    _500 *= _499;
    _500 *= sizeof(_a2_int64_t);
    _495.data = jpl_alloc(_500);
    int64_t _501 = 0; // f
    int64_t _502 = 0; // e
    int64_t _503 = 0; // d
    _jump663:; // Begin body of loop
    _a2_int64_t _504;
    // Computing bound for g
    _504.d0 = _501;
    if (_501 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for h
    _504.d1 = _502;
    if (_502 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing total size of heap memory to allocate
    int64_t _505 = 1;
    _505 *= _501;
    _505 *= _502;
    _505 *= sizeof(int64_t);
    _504.data = jpl_alloc(_505);
    int64_t _506 = 0; // h
    int64_t _507 = 0; // g
    _jump666:; // Begin body of loop
    int64_t _508 = 0;
    _508 *= _504.d0;
    _508 += _507;
    _508 *= _504.d1;
    _508 += _506;
    _504.data[_508] = _507;
    _506++;
    if (_506 < _502)
    goto _jump666;
    _506 = 0;
    _507++;
    if (_507 < _501)
    goto _jump666;
    // End body of loop
    int64_t _509 = 0;
    _509 *= _495.d0;
    _509 += _503;
    _509 *= _495.d1;
    _509 += _502;
    _509 *= _495.d2;
    _509 += _501;
    _495.data[_509] = _504;
    _501++;
    if (_501 < _499)
    goto _jump663;
    _501 = 0;
    _502++;
    if (_502 < _498)
    goto _jump663;
    _502 = 0;
    _503++;
    if (_503 < _496)
    goto _jump663;
    // End body of loop
    int64_t _510 = _483 + _484;
    int64_t _511 = _483 + _483;
    int64_t _512 = _511 * _483;
    bool _513 = false;
    int64_t _514;
    if (!_513)
    goto _jump667;
    _514 = _484;
    goto _jump668;
    _jump667:;
    int64_t _515;
    // Computing bound for d
    if (_484 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for e
    if (_484 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    _515 = 0;
    int64_t _516 = 0; // e
    int64_t _517 = 0; // d
    _jump671:; // Begin body of loop
    int64_t _518 = 851;
    _515 += _518;
    _516++;
    if (_516 < _484)
    goto _jump671;
    _516 = 0;
    _517++;
    if (_517 < _484)
    goto _jump671;
    // End body of loop
    _514 = _515;
    _jump668:;
    if (_510 >= 0)
    goto _jump672;
    fail_assertion("negative array index");
    _jump672:;
    if (_510 < _495.d0)
    goto _jump673;
    fail_assertion("index too large");
    _jump673:;
    if (_512 >= 0)
    goto _jump674;
    fail_assertion("negative array index");
    _jump674:;
    if (_512 < _495.d1)
    goto _jump675;
    fail_assertion("index too large");
    _jump675:;
    if (_514 >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (_514 < _495.d2)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    int64_t _519 = 0;
    _519 *= _495.d0;
    _519 += _510;
    _519 *= _495.d1;
    _519 += _512;
    _519 *= _495.d2;
    _519 += _514;
    _a2_int64_t _520 = _495.data[_519];
    _494 = _520;
    goto _jump678;
    _jump659:;
    _a2_int64_t _521;
    // Computing bound for d
    int64_t _522 = 296;
    int64_t _523 = -_522;
    _521.d0 = _523;
    if (_523 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing bound for e
    int64_t _524 = 884;
    int64_t _525 = 260;
    int64_t _526 = -_525;
    int64_t _527 = _524 % _526;
    _521.d1 = _527;
    if (_527 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing total size of heap memory to allocate
    int64_t _528 = 1;
    _528 *= _523;
    _528 *= _527;
    _528 *= sizeof(int64_t);
    _521.data = jpl_alloc(_528);
    int64_t _529 = 0; // e
    int64_t _530 = 0; // d
    _jump681:; // Begin body of loop
    _a1_int64_t _531;
    // Computing bound for f
    _531.d0 = _530;
    if (_530 > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing total size of heap memory to allocate
    int64_t _532 = 1;
    _532 *= _530;
    _532 *= sizeof(int64_t);
    _531.data = jpl_alloc(_532);
    int64_t _533 = 0; // f
    _jump683:; // Begin body of loop
    int64_t _534 = 0;
    _534 *= _531.d0;
    _534 += _533;
    _531.data[_534] = _529;
    _533++;
    if (_533 < _530)
    goto _jump683;
    // End body of loop
    int64_t _535 = -_483;
    if (_535 >= 0)
    goto _jump684;
    fail_assertion("negative array index");
    _jump684:;
    if (_535 < _531.d0)
    goto _jump685;
    fail_assertion("index too large");
    _jump685:;
    int64_t _536 = 0;
    _536 *= _531.d0;
    _536 += _535;
    int64_t _537 = _531.data[_536];
    int64_t _538 = 0;
    _538 *= _521.d0;
    _538 += _530;
    _538 *= _521.d1;
    _538 += _529;
    _521.data[_538] = _537;
    _529++;
    if (_529 < _527)
    goto _jump681;
    _529 = 0;
    _530++;
    if (_530 < _523)
    goto _jump681;
    // End body of loop
    _494 = _521;
    _jump678:;
    int64_t _539 = 0;
    _539 *= _456.d0;
    _539 += _484;
    _539 *= _456.d1;
    _539 += _483;
    _456.data[_539] = _494;
    _483++;
    if (_483 < _463)
    goto _jump655;
    _483 = 0;
    _484++;
    if (_484 < _457)
    goto _jump655;
    // End body of loop
    int64_t _540 = 244;
    int64_t _541 = -_540;
    bool _542 = true;
    int64_t _543;
    if (!_542)
    goto _jump686;
    int64_t _544 = 1000;
    _543 = _544;
    goto _jump687;
    _jump686:;
    int64_t _545 = 231;
    int64_t _546 = 980;
    int64_t _547 = _545 / _546;
    _543 = _547;
    _jump687:;
    int64_t _548 = _541 / _543;
    int64_t _549;
    // Computing bound for b
    int64_t _550 = 680;
    if (_550 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for c
    bool _551 = true;
    int64_t _552;
    if (!_551)
    goto _jump689;
    int64_t _553 = 879;
    int64_t _554 = -_553;
    _552 = _554;
    goto _jump690;
    _jump689:;
    int64_t _555 = 801;
    _552 = _555;
    _jump690:;
    if (_552 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for d
    int64_t _556 = 936;
    int64_t _557 = -_556;
    if (_557 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    _549 = 0;
    int64_t _558 = 0; // d
    int64_t _559 = 0; // c
    int64_t _560 = 0; // b
    _jump693:; // Begin body of loop
    _549 += _559;
    _558++;
    if (_558 < _557)
    goto _jump693;
    _558 = 0;
    _559++;
    if (_559 < _552)
    goto _jump693;
    _559 = 0;
    _560++;
    if (_560 < _550)
    goto _jump693;
    // End body of loop
    bool _561 = false;
    bool _562 = !_561;
    bool _563 = !_562;
    int64_t _564;
    if (!_563)
    goto _jump694;
    int64_t _565;
    // Computing bound for b
    int64_t _566 = 180;
    if (_566 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for c
    int64_t _567 = 966;
    if (_567 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for d
    int64_t _568;
    // Computing bound for b
    int64_t _569 = 662;
    if (_569 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    _568 = 0;
    int64_t _570 = 0; // b
    _jump698:; // Begin body of loop
    int64_t _571 = 157;
    _568 += _571;
    _570++;
    if (_570 < _569)
    goto _jump698;
    // End body of loop
    if (_568 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    _565 = 0;
    int64_t _572 = 0; // d
    int64_t _573 = 0; // c
    int64_t _574 = 0; // b
    _jump700:; // Begin body of loop
    _565 += _572;
    _572++;
    if (_572 < _568)
    goto _jump700;
    _572 = 0;
    _573++;
    if (_573 < _567)
    goto _jump700;
    _573 = 0;
    _574++;
    if (_574 < _566)
    goto _jump700;
    // End body of loop
    _564 = _565;
    goto _jump701;
    _jump694:;
    int64_t _575 = 905;
    int64_t _576 = -_575;
    _564 = _576;
    _jump701:;
    bool _577 = _549 <= _564;
    int64_t _578;
    if (!_577)
    goto _jump702;
    int64_t _579 = 765;
    int64_t _580;
    // Computing bound for b
    int64_t _581 = 876;
    if (_581 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    _580 = 0;
    int64_t _582 = 0; // b
    _jump704:; // Begin body of loop
    bool _583 = true;
    int64_t _584;
    if (!_583)
    goto _jump705;
    int64_t _585 = 728;
    int64_t _586 = _585 + _582;
    _584 = _586;
    goto _jump706;
    _jump705:;
    int64_t _587;
    // Computing bound for c
    int64_t _588 = 872;
    if (_588 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    _587 = 0;
    int64_t _589 = 0; // c
    _jump708:; // Begin body of loop
    _587 += _582;
    _589++;
    if (_589 < _588)
    goto _jump708;
    // End body of loop
    _584 = _587;
    _jump706:;
    _580 += _584;
    _582++;
    if (_582 < _581)
    goto _jump704;
    // End body of loop
    int64_t _590 = _579 - _580;
    _578 = _590;
    goto _jump709;
    _jump702:;
    bool _591 = false;
    _a1_int64_t _592;
    if (!_591)
    goto _jump710;
    _a1_int64_t _593;
    // Computing bound for b
    int64_t _594 = 584;
    _593.d0 = _594;
    if (_594 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    // Computing total size of heap memory to allocate
    int64_t _595 = 1;
    _595 *= _594;
    _595 *= sizeof(int64_t);
    _593.data = jpl_alloc(_595);
    int64_t _596 = 0; // b
    _jump712:; // Begin body of loop
    int64_t _597 = 0;
    _597 *= _593.d0;
    _597 += _596;
    _593.data[_597] = _596;
    _596++;
    if (_596 < _594)
    goto _jump712;
    // End body of loop
    _592 = _593;
    goto _jump713;
    _jump710:;
    _a1_int64_t _598;
    // Computing bound for b
    int64_t _599 = 348;
    _598.d0 = _599;
    if (_599 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing total size of heap memory to allocate
    int64_t _600 = 1;
    _600 *= _599;
    _600 *= sizeof(int64_t);
    _598.data = jpl_alloc(_600);
    int64_t _601 = 0; // b
    _jump715:; // Begin body of loop
    int64_t _602 = 0;
    _602 *= _598.d0;
    _602 += _601;
    _598.data[_602] = _601;
    _601++;
    if (_601 < _599)
    goto _jump715;
    // End body of loop
    _592 = _598;
    _jump713:;
    int64_t _603 = 713;
    int64_t _604 = 721;
    int64_t _605 = _603 % _604;
    int64_t _606 = -_605;
    if (_606 >= 0)
    goto _jump716;
    fail_assertion("negative array index");
    _jump716:;
    if (_606 < _592.d0)
    goto _jump717;
    fail_assertion("index too large");
    _jump717:;
    int64_t _607 = 0;
    _607 *= _592.d0;
    _607 += _606;
    int64_t _608 = _592.data[_607];
    int64_t _609 = -_608;
    _578 = _609;
    _jump709:;
    if (_548 >= 0)
    goto _jump718;
    fail_assertion("negative array index");
    _jump718:;
    if (_548 < _456.d0)
    goto _jump719;
    fail_assertion("index too large");
    _jump719:;
    if (_578 >= 0)
    goto _jump720;
    fail_assertion("negative array index");
    _jump720:;
    if (_578 < _456.d1)
    goto _jump721;
    fail_assertion("index too large");
    _jump721:;
    int64_t _610 = 0;
    _610 *= _456.d0;
    _610 += _548;
    _610 *= _456.d1;
    _610 += _578;
    _a2_int64_t _611 = _456.data[_610];
    _455 = _611;
    goto _jump722;
    _jump644:;
    int64_t _612 = 746;
    bool _613 = false;
    int64_t _614;
    if (!_613)
    goto _jump723;
    int64_t _615 = 442;
    int64_t _616 = -_615;
    int64_t _617 = -_616;
    _614 = _617;
    goto _jump724;
    _jump723:;
    int64_t _618 = 677;
    _614 = _618;
    _jump724:;
    int64_t _619 = 214;
    int64_t _620 = 6;
    int64_t _621 = _619 % _620;
    int64_t _622 = 79;
    int64_t _623 = _621 * _622;
    int64_t _624 = -_623;
    int64_t _625 = _614 + _624;
    bool _626 = _612 <= _625;
    _a2_int64_t _627;
    if (!_626)
    goto _jump725;
    bool _630 = false;
    bool _629 = _630;
    if (0 != _630)
    goto _jump726;
    int64_t _631 = 88;
    int64_t _632 = 73;
    bool _633 = _631 < _632;
    _629 = _633;
    _jump726:;
    bool _634 = !_629;
    bool _628 = _634;
    if (0 == _634)
    goto _jump727;
    bool _635 = false;
    bool _636 = true;
    bool _637;
    if (!_636)
    goto _jump728;
    bool _638 = true;
    _637 = _638;
    goto _jump729;
    _jump728:;
    bool _639 = false;
    _637 = _639;
    _jump729:;
    bool _640 = !_637;
    bool _641 = _635 == _640;
    _628 = _641;
    _jump727:;
    _a2_int64_t _642;
    if (!_628)
    goto _jump730;
    _a1__a2_int64_t _643;
    // Computing bound for b
    int64_t _644 = 398;
    _643.d0 = _644;
    if (_644 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing total size of heap memory to allocate
    int64_t _645 = 1;
    _645 *= _644;
    _645 *= sizeof(_a2_int64_t);
    _643.data = jpl_alloc(_645);
    int64_t _646 = 0; // b
    _jump732:; // Begin body of loop
    _a2_int64_t _647;
    // Computing bound for c
    int64_t _648 = 613;
    _647.d0 = _648;
    if (_648 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for d
    int64_t _649 = 349;
    _647.d1 = _649;
    if (_649 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing total size of heap memory to allocate
    int64_t _650 = 1;
    _650 *= _648;
    _650 *= _649;
    _650 *= sizeof(int64_t);
    _647.data = jpl_alloc(_650);
    int64_t _651 = 0; // d
    int64_t _652 = 0; // c
    _jump735:; // Begin body of loop
    int64_t _653 = 0;
    _653 *= _647.d0;
    _653 += _652;
    _653 *= _647.d1;
    _653 += _651;
    _647.data[_653] = _652;
    _651++;
    if (_651 < _649)
    goto _jump735;
    _651 = 0;
    _652++;
    if (_652 < _648)
    goto _jump735;
    // End body of loop
    int64_t _654 = 0;
    _654 *= _643.d0;
    _654 += _646;
    _643.data[_654] = _647;
    _646++;
    if (_646 < _644)
    goto _jump732;
    // End body of loop
    int64_t _655;
    // Computing bound for b
    int64_t _656 = 981;
    if (_656 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for c
    int64_t _657 = 155;
    int64_t _658 = -_657;
    int64_t _659 = 896;
    int64_t _660 = _658 / _659;
    if (_660 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    _655 = 0;
    int64_t _661 = 0; // c
    int64_t _662 = 0; // b
    _jump738:; // Begin body of loop
    _655 += _662;
    _661++;
    if (_661 < _660)
    goto _jump738;
    _661 = 0;
    _662++;
    if (_662 < _656)
    goto _jump738;
    // End body of loop
    if (_655 >= 0)
    goto _jump739;
    fail_assertion("negative array index");
    _jump739:;
    if (_655 < _643.d0)
    goto _jump740;
    fail_assertion("index too large");
    _jump740:;
    int64_t _663 = 0;
    _663 *= _643.d0;
    _663 += _655;
    _a2_int64_t _664 = _643.data[_663];
    _642 = _664;
    goto _jump741;
    _jump730:;
    _a2_int64_t _665;
    // Computing bound for b
    int64_t _666 = 446;
    int64_t _667 = -_666;
    _665.d0 = _667;
    if (_667 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing bound for c
    int64_t _668;
    // Computing bound for b
    int64_t _669 = 636;
    int64_t _670 = -_669;
    if (_670 > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing bound for c
    int64_t _671;
    // Computing bound for b
    int64_t _672 = 237;
    if (_672 > 0) 
    goto _jump744;
    fail_assertion("non-positive loop bound");
    _jump744:;
    _671 = 0;
    int64_t _673 = 0; // b
    _jump745:; // Begin body of loop
    int64_t _674 = 170;
    int64_t _675 = -_674;
    _671 += _675;
    _673++;
    if (_673 < _672)
    goto _jump745;
    // End body of loop
    if (_671 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing bound for d
    int64_t _676 = 656;
    if (_676 > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    _668 = 0;
    int64_t _677 = 0; // d
    int64_t _678 = 0; // c
    int64_t _679 = 0; // b
    _jump748:; // Begin body of loop
    int64_t _680 = 492;
    int64_t _681 = _679 * _680;
    _668 += _681;
    _677++;
    if (_677 < _676)
    goto _jump748;
    _677 = 0;
    _678++;
    if (_678 < _671)
    goto _jump748;
    _678 = 0;
    _679++;
    if (_679 < _670)
    goto _jump748;
    // End body of loop
    _665.d1 = _668;
    if (_668 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing total size of heap memory to allocate
    int64_t _682 = 1;
    _682 *= _667;
    _682 *= _668;
    _682 *= sizeof(int64_t);
    _665.data = jpl_alloc(_682);
    int64_t _683 = 0; // c
    int64_t _684 = 0; // b
    _jump750:; // Begin body of loop
    int64_t _685 = _684 + _683;
    int64_t _686 = _684 + _685;
    int64_t _687 = _686 + _683;
    int64_t _688 = 0;
    _688 *= _665.d0;
    _688 += _684;
    _688 *= _665.d1;
    _688 += _683;
    _665.data[_688] = _687;
    _683++;
    if (_683 < _668)
    goto _jump750;
    _683 = 0;
    _684++;
    if (_684 < _667)
    goto _jump750;
    // End body of loop
    _642 = _665;
    _jump741:;
    _627 = _642;
    goto _jump751;
    _jump725:;
    _a2__a2_int64_t _689;
    // Computing bound for b
    int64_t _690 = 983;
    _689.d0 = _690;
    if (_690 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for c
    int64_t _691 = 127;
    _689.d1 = _691;
    if (_691 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing total size of heap memory to allocate
    int64_t _692 = 1;
    _692 *= _690;
    _692 *= _691;
    _692 *= sizeof(_a2_int64_t);
    _689.data = jpl_alloc(_692);
    int64_t _693 = 0; // c
    int64_t _694 = 0; // b
    _jump754:; // Begin body of loop
    _a2_int64_t _695;
    // Computing bound for d
    _695.d0 = _693;
    if (_693 > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    // Computing bound for e
    _695.d1 = _694;
    if (_694 > 0) 
    goto _jump756;
    fail_assertion("non-positive loop bound");
    _jump756:;
    // Computing total size of heap memory to allocate
    int64_t _696 = 1;
    _696 *= _693;
    _696 *= _694;
    _696 *= sizeof(int64_t);
    _695.data = jpl_alloc(_696);
    int64_t _697 = 0; // e
    int64_t _698 = 0; // d
    _jump757:; // Begin body of loop
    int64_t _699 = 0;
    _699 *= _695.d0;
    _699 += _698;
    _699 *= _695.d1;
    _699 += _697;
    _695.data[_699] = _693;
    _697++;
    if (_697 < _694)
    goto _jump757;
    _697 = 0;
    _698++;
    if (_698 < _693)
    goto _jump757;
    // End body of loop
    int64_t _700 = 0;
    _700 *= _689.d0;
    _700 += _694;
    _700 *= _689.d1;
    _700 += _693;
    _689.data[_700] = _695;
    _693++;
    if (_693 < _691)
    goto _jump754;
    _693 = 0;
    _694++;
    if (_694 < _690)
    goto _jump754;
    // End body of loop
    int64_t _701 = 785;
    int64_t _702 = -_701;
    int64_t _703 = 710;
    int64_t _704 = -_703;
    int64_t _705 = -_704;
    if (_702 >= 0)
    goto _jump758;
    fail_assertion("negative array index");
    _jump758:;
    if (_702 < _689.d0)
    goto _jump759;
    fail_assertion("index too large");
    _jump759:;
    if (_705 >= 0)
    goto _jump760;
    fail_assertion("negative array index");
    _jump760:;
    if (_705 < _689.d1)
    goto _jump761;
    fail_assertion("index too large");
    _jump761:;
    int64_t _706 = 0;
    _706 *= _689.d0;
    _706 += _702;
    _706 *= _689.d1;
    _706 += _705;
    _a2_int64_t _707 = _689.data[_706];
    _a1__a2_int64_t _708;
    _708.d0 = 1;
    _708.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _708.data[0] = _707;
    int64_t _709 = 936;
    if (_709 >= 0)
    goto _jump762;
    fail_assertion("negative array index");
    _jump762:;
    if (_709 < _708.d0)
    goto _jump763;
    fail_assertion("index too large");
    _jump763:;
    int64_t _710 = 0;
    _710 *= _708.d0;
    _710 += _709;
    _a2_int64_t _711 = _708.data[_710];
    _627 = _711;
    _jump751:;
    _455 = _627;
    _jump722:;
    int64_t _712 = 500;
    bool _713 = _455.d0 < _712;
    _a2_rgba _714;
    if (!_713)
    goto _jump999;
    _a1_int64_t _716;
    // Computing bound for f
    int64_t _717 = 135;
    _716.d0 = _717;
    if (_717 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing total size of heap memory to allocate
    int64_t _718 = 1;
    _718 *= _717;
    _718 *= sizeof(int64_t);
    _716.data = jpl_alloc(_718);
    int64_t _719 = 0; // f
    _jump1001:; // Begin body of loop
    int64_t _720 = 0;
    _720 *= _716.d0;
    _720 += _719;
    _716.data[_720] = _455.d0;
    _719++;
    if (_719 < _717)
    goto _jump1001;
    // End body of loop
    int64_t _721 = -_455.d1;
    if (_721 >= 0)
    goto _jump1002;
    fail_assertion("negative array index");
    _jump1002:;
    if (_721 < _716.d0)
    goto _jump1003;
    fail_assertion("index too large");
    _jump1003:;
    int64_t _722 = 0;
    _722 *= _716.d0;
    _722 += _721;
    int64_t _723 = _716.data[_722];
    int64_t _724 = 666;
    bool _725 = _723 > _724;
    bool _715 = _725;
    if (0 == _725)
    goto _jump1004;
    bool _727 = true;
    bool _726 = _727;
    if (0 == _727)
    goto _jump1005;
    bool _728 = true;
    bool _729 = false;
    bool _730 = _728 == _729;
    _726 = _730;
    _jump1005:;
    bool _731 = !_726;
    _715 = _731;
    _jump1004:;
    _a2_bool _732;
    // Computing bound for f
    int64_t _733 = 873;
    _732.d0 = _733;
    if (_733 > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    // Computing bound for g
    _732.d1 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing total size of heap memory to allocate
    int64_t _734 = 1;
    _734 *= _733;
    _734 *= _455.d1;
    _734 *= sizeof(bool);
    _732.data = jpl_alloc(_734);
    int64_t _735 = 0; // g
    int64_t _736 = 0; // f
    _jump1008:; // Begin body of loop
    int64_t _737 = 236;
    int64_t _738;
    // Computing bound for h
    if (_455.d0 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    _738 = 0;
    int64_t _739 = 0; // h
    _jump1010:; // Begin body of loop
    int64_t _740 = 756;
    _738 += _740;
    _739++;
    if (_739 < _455.d0)
    goto _jump1010;
    // End body of loop
    bool _741 = _737 >= _738;
    int64_t _742 = 0;
    _742 *= _732.d0;
    _742 += _736;
    _742 *= _732.d1;
    _742 += _735;
    _732.data[_742] = _741;
    _735++;
    if (_735 < _455.d1)
    goto _jump1008;
    _735 = 0;
    _736++;
    if (_736 < _733)
    goto _jump1008;
    // End body of loop
    int64_t _743 = 645;
    int64_t _744 = 788;
    if (_743 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (_743 < _732.d0)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    if (_744 >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (_744 < _732.d1)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    int64_t _745 = 0;
    _745 *= _732.d0;
    _745 += _743;
    _745 *= _732.d1;
    _745 += _744;
    bool _746 = _732.data[_745];
    bool _747 = _715 != _746;
    _a2_rgba _748;
    if (!_747)
    goto _jump1015;
    double _749 = 79.0;
    double _750 = 41.0;
    bool _751 = _749 <= _750;
    _a2_rgba _752;
    if (!_751)
    goto _jump1016;
    _a2_rgba _753;
    // Computing bound for f
    _753.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1017;
    fail_assertion("non-positive loop bound");
    _jump1017:;
    // Computing bound for g
    int64_t _754 = -_455.d1;
    bool _755 = _455.d1 != _754;
    int64_t _756;
    if (!_755)
    goto _jump1018;
    int64_t _757;
    // Computing bound for f
    int64_t _758 = 363;
    if (_758 > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing bound for g
    int64_t _759 = 981;
    if (_759 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    _757 = 0;
    int64_t _760 = 0; // g
    int64_t _761 = 0; // f
    _jump1021:; // Begin body of loop
    _757 += _455.d0;
    _760++;
    if (_760 < _759)
    goto _jump1021;
    _760 = 0;
    _761++;
    if (_761 < _758)
    goto _jump1021;
    // End body of loop
    _756 = _757;
    goto _jump1022;
    _jump1018:;
    int64_t _762;
    // Computing bound for f
    int64_t _763 = 408;
    if (_763 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing bound for g
    int64_t _764 = -_455.d0;
    if (_764 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing bound for h
    int64_t _765 = 7;
    if (_765 > 0) 
    goto _jump1025;
    fail_assertion("non-positive loop bound");
    _jump1025:;
    _762 = 0;
    int64_t _766 = 0; // h
    int64_t _767 = 0; // g
    int64_t _768 = 0; // f
    _jump1026:; // Begin body of loop
    int64_t _769 = 923;
    int64_t _770 = _767 * _769;
    _762 += _770;
    _766++;
    if (_766 < _765)
    goto _jump1026;
    _766 = 0;
    _767++;
    if (_767 < _764)
    goto _jump1026;
    _767 = 0;
    _768++;
    if (_768 < _763)
    goto _jump1026;
    // End body of loop
    _756 = _762;
    _jump1022:;
    _753.d1 = _756;
    if (_756 > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    // Computing total size of heap memory to allocate
    int64_t _771 = 1;
    _771 *= _455.d0;
    _771 *= _756;
    _771 *= sizeof(rgba);
    _753.data = jpl_alloc(_771);
    int64_t _772 = 0; // g
    int64_t _773 = 0; // f
    _jump1028:; // Begin body of loop
    rgba _774 = a();
    int64_t _775 = 0;
    _775 *= _753.d0;
    _775 += _773;
    _775 *= _753.d1;
    _775 += _772;
    _753.data[_775] = _774;
    _772++;
    if (_772 < _756)
    goto _jump1028;
    _772 = 0;
    _773++;
    if (_773 < _455.d0)
    goto _jump1028;
    // End body of loop
    _752 = _753;
    goto _jump1029;
    _jump1016:;
    _a2_rgba _776;
    // Computing bound for f
    int64_t _777;
    // Computing bound for f
    int64_t _778 = -_455.d0;
    bool _779 = true;
    int64_t _780;
    if (!_779)
    goto _jump1030;
    _780 = _455.d0;
    goto _jump1031;
    _jump1030:;
    _780 = _455.d0;
    _jump1031:;
    int64_t _781 = _778 % _780;
    if (_781 > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    // Computing bound for g
    int64_t _782 = 125;
    if (_782 > 0) 
    goto _jump1033;
    fail_assertion("non-positive loop bound");
    _jump1033:;
    // Computing bound for h
    int64_t _783;
    // Computing bound for f
    int64_t _784;
    // Computing bound for f
    if (_455.d0 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    _784 = 0;
    int64_t _785 = 0; // f
    _jump1035:; // Begin body of loop
    _784 += _455.d1;
    _785++;
    if (_785 < _455.d0)
    goto _jump1035;
    // End body of loop
    if (_784 > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    // Computing bound for g
    int64_t _786 = _455.d1 * _455.d1;
    if (_786 > 0) 
    goto _jump1037;
    fail_assertion("non-positive loop bound");
    _jump1037:;
    _783 = 0;
    int64_t _787 = 0; // g
    int64_t _788 = 0; // f
    _jump1038:; // Begin body of loop
    int64_t _789 = -_455.d1;
    _783 += _789;
    _787++;
    if (_787 < _786)
    goto _jump1038;
    _787 = 0;
    _788++;
    if (_788 < _784)
    goto _jump1038;
    // End body of loop
    if (_783 > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    _777 = 0;
    int64_t _790 = 0; // h
    int64_t _791 = 0; // g
    int64_t _792 = 0; // f
    _jump1040:; // Begin body of loop
    int64_t _793 = 333;
    int64_t _794 = -_793;
    _777 += _794;
    _790++;
    if (_790 < _783)
    goto _jump1040;
    _790 = 0;
    _791++;
    if (_791 < _782)
    goto _jump1040;
    _791 = 0;
    _792++;
    if (_792 < _781)
    goto _jump1040;
    // End body of loop
    _776.d0 = _777;
    if (_777 > 0) 
    goto _jump1041;
    fail_assertion("non-positive loop bound");
    _jump1041:;
    // Computing bound for g
    _776.d1 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1042;
    fail_assertion("non-positive loop bound");
    _jump1042:;
    // Computing total size of heap memory to allocate
    int64_t _795 = 1;
    _795 *= _777;
    _795 *= _455.d0;
    _795 *= sizeof(rgba);
    _776.data = jpl_alloc(_795);
    int64_t _796 = 0; // g
    int64_t _797 = 0; // f
    _jump1043:; // Begin body of loop
    rgba _798 = a();
    int64_t _799 = 0;
    _799 *= _776.d0;
    _799 += _797;
    _799 *= _776.d1;
    _799 += _796;
    _776.data[_799] = _798;
    _796++;
    if (_796 < _455.d0)
    goto _jump1043;
    _796 = 0;
    _797++;
    if (_797 < _777)
    goto _jump1043;
    // End body of loop
    _752 = _776;
    _jump1029:;
    _748 = _752;
    goto _jump1044;
    _jump1015:;
    bool _801 = true;
    bool _800 = _801;
    if (0 != _801)
    goto _jump1045;
    bool _802 = false;
    _800 = _802;
    _jump1045:;
    bool _803 = !_800;
    _a2__a2_rgba _804;
    if (!_803)
    goto _jump1046;
    _a2__a2_rgba _805;
    // Computing bound for f
    int64_t _806 = 838;
    int64_t _807 = _806 + _455.d0;
    _805.d0 = _807;
    if (_807 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing bound for g
    if (_455.d0 >= 0)
    goto _jump1048;
    fail_assertion("negative array index");
    _jump1048:;
    if (_455.d0 < _455.d0)
    goto _jump1049;
    fail_assertion("index too large");
    _jump1049:;
    if (_455.d0 >= 0)
    goto _jump1050;
    fail_assertion("negative array index");
    _jump1050:;
    if (_455.d0 < _455.d1)
    goto _jump1051;
    fail_assertion("index too large");
    _jump1051:;
    int64_t _808 = 0;
    _808 *= _455.d0;
    _808 += _455.d0;
    _808 *= _455.d1;
    _808 += _455.d0;
    int64_t _809 = _455.data[_808];
    int64_t _810 = -_809;
    _805.d1 = _810;
    if (_810 > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing total size of heap memory to allocate
    int64_t _811 = 1;
    _811 *= _807;
    _811 *= _810;
    _811 *= sizeof(_a2_rgba);
    _805.data = jpl_alloc(_811);
    int64_t _812 = 0; // g
    int64_t _813 = 0; // f
    _jump1053:; // Begin body of loop
    _a2_rgba _814;
    // Computing bound for h
    _814.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing bound for i
    bool _815 = true;
    int64_t _816;
    if (!_815)
    goto _jump1055;
    _816 = _812;
    goto _jump1056;
    _jump1055:;
    _816 = _455.d0;
    _jump1056:;
    _814.d1 = _816;
    if (_816 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing total size of heap memory to allocate
    int64_t _817 = 1;
    _817 *= _455.d0;
    _817 *= _816;
    _817 *= sizeof(rgba);
    _814.data = jpl_alloc(_817);
    int64_t _818 = 0; // i
    int64_t _819 = 0; // h
    _jump1058:; // Begin body of loop
    rgba _820 = a();
    int64_t _821 = 0;
    _821 *= _814.d0;
    _821 += _819;
    _821 *= _814.d1;
    _821 += _818;
    _814.data[_821] = _820;
    _818++;
    if (_818 < _816)
    goto _jump1058;
    _818 = 0;
    _819++;
    if (_819 < _455.d0)
    goto _jump1058;
    // End body of loop
    int64_t _822 = 0;
    _822 *= _805.d0;
    _822 += _813;
    _822 *= _805.d1;
    _822 += _812;
    _805.data[_822] = _814;
    _812++;
    if (_812 < _810)
    goto _jump1053;
    _812 = 0;
    _813++;
    if (_813 < _807)
    goto _jump1053;
    // End body of loop
    _804 = _805;
    goto _jump1059;
    _jump1046:;
    _a2__a2_rgba _823;
    // Computing bound for f
    int64_t _824 = 387;
    int64_t _825 = _824 + _455.d1;
    int64_t _826 = _455.d0 * _825;
    _823.d0 = _826;
    if (_826 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing bound for g
    int64_t _827 = 154;
    _823.d1 = _827;
    if (_827 > 0) 
    goto _jump1061;
    fail_assertion("non-positive loop bound");
    _jump1061:;
    // Computing total size of heap memory to allocate
    int64_t _828 = 1;
    _828 *= _826;
    _828 *= _827;
    _828 *= sizeof(_a2_rgba);
    _823.data = jpl_alloc(_828);
    int64_t _829 = 0; // g
    int64_t _830 = 0; // f
    _jump1062:; // Begin body of loop
    _a2_rgba _831;
    // Computing bound for h
    int64_t _832 = _455.d1 + _455.d1;
    _831.d0 = _832;
    if (_832 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for i
    int64_t _833 = 417;
    _831.d1 = _833;
    if (_833 > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing total size of heap memory to allocate
    int64_t _834 = 1;
    _834 *= _832;
    _834 *= _833;
    _834 *= sizeof(rgba);
    _831.data = jpl_alloc(_834);
    int64_t _835 = 0; // i
    int64_t _836 = 0; // h
    _jump1065:; // Begin body of loop
    rgba _837 = a();
    int64_t _838 = 0;
    _838 *= _831.d0;
    _838 += _836;
    _838 *= _831.d1;
    _838 += _835;
    _831.data[_838] = _837;
    _835++;
    if (_835 < _833)
    goto _jump1065;
    _835 = 0;
    _836++;
    if (_836 < _832)
    goto _jump1065;
    // End body of loop
    int64_t _839 = 0;
    _839 *= _823.d0;
    _839 += _830;
    _839 *= _823.d1;
    _839 += _829;
    _823.data[_839] = _831;
    _829++;
    if (_829 < _827)
    goto _jump1062;
    _829 = 0;
    _830++;
    if (_830 < _826)
    goto _jump1062;
    // End body of loop
    _804 = _823;
    _jump1059:;
    int64_t _840 = 130;
    _a1__a1_int64_t _841;
    // Computing bound for f
    _841.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing total size of heap memory to allocate
    int64_t _842 = 1;
    _842 *= _455.d0;
    _842 *= sizeof(_a1_int64_t);
    _841.data = jpl_alloc(_842);
    int64_t _843 = 0; // f
    _jump1067:; // Begin body of loop
    _a1_int64_t _844;
    // Computing bound for g
    _844.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing total size of heap memory to allocate
    int64_t _845 = 1;
    _845 *= _455.d0;
    _845 *= sizeof(int64_t);
    _844.data = jpl_alloc(_845);
    int64_t _846 = 0; // g
    _jump1069:; // Begin body of loop
    int64_t _847 = 0;
    _847 *= _844.d0;
    _847 += _846;
    _844.data[_847] = _455.d0;
    _846++;
    if (_846 < _455.d0)
    goto _jump1069;
    // End body of loop
    int64_t _848 = 0;
    _848 *= _841.d0;
    _848 += _843;
    _841.data[_848] = _844;
    _843++;
    if (_843 < _455.d0)
    goto _jump1067;
    // End body of loop
    int64_t _849 = 986;
    if (_849 >= 0)
    goto _jump1070;
    fail_assertion("negative array index");
    _jump1070:;
    if (_849 < _841.d0)
    goto _jump1071;
    fail_assertion("index too large");
    _jump1071:;
    int64_t _850 = 0;
    _850 *= _841.d0;
    _850 += _849;
    _a1_int64_t _851 = _841.data[_850];
    if (_455.d0 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (_455.d0 < _851.d0)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    int64_t _852 = 0;
    _852 *= _851.d0;
    _852 += _455.d0;
    int64_t _853 = _851.data[_852];
    if (_840 >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (_840 < _804.d0)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    if (_853 >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (_853 < _804.d1)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    int64_t _854 = 0;
    _854 *= _804.d0;
    _854 += _840;
    _854 *= _804.d1;
    _854 += _853;
    _a2_rgba _855 = _804.data[_854];
    _748 = _855;
    _jump1044:;
    _714 = _748;
    goto _jump1078;
    _jump999:;
    _a2_rgba _856;
    // Computing bound for f
    int64_t _857 = 555;
    bool _858 = false;
    int64_t _859;
    if (!_858)
    goto _jump1079;
    int64_t _860;
    // Computing bound for f
    if (_455.d1 > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    _860 = 0;
    int64_t _861 = 0; // f
    _jump1081:; // Begin body of loop
    _860 += _455.d0;
    _861++;
    if (_861 < _455.d1)
    goto _jump1081;
    // End body of loop
    _859 = _860;
    goto _jump1082;
    _jump1079:;
    int64_t _862;
    // Computing bound for f
    int64_t _863 = 250;
    if (_863 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    _862 = 0;
    int64_t _864 = 0; // f
    _jump1084:; // Begin body of loop
    int64_t _865 = 257;
    _862 += _865;
    _864++;
    if (_864 < _863)
    goto _jump1084;
    // End body of loop
    _859 = _862;
    _jump1082:;
    int64_t _866 = _857 / _859;
    int64_t _867 = _866 % _455.d1;
    int64_t _868 = -_867;
    _856.d0 = _868;
    if (_868 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing bound for g
    int64_t _869 = -_455.d0;
    _a1_int64_t _870;
    _870.d0 = 1;
    _870.data = jpl_alloc(sizeof(int64_t) * 1);
    _870.data[0] = _869;
    if (_455.d1 >= 0)
    goto _jump1086;
    fail_assertion("negative array index");
    _jump1086:;
    if (_455.d1 < _870.d0)
    goto _jump1087;
    fail_assertion("index too large");
    _jump1087:;
    int64_t _871 = 0;
    _871 *= _870.d0;
    _871 += _455.d1;
    int64_t _872 = _870.data[_871];
    _856.d1 = _872;
    if (_872 > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    // Computing total size of heap memory to allocate
    int64_t _873 = 1;
    _873 *= _868;
    _873 *= _872;
    _873 *= sizeof(rgba);
    _856.data = jpl_alloc(_873);
    int64_t _874 = 0; // g
    int64_t _875 = 0; // f
    _jump1089:; // Begin body of loop
    rgba _876 = a();
    int64_t _877 = 0;
    _877 *= _856.d0;
    _877 += _875;
    _877 *= _856.d1;
    _877 += _874;
    _856.data[_877] = _876;
    _874++;
    if (_874 < _872)
    goto _jump1089;
    _874 = 0;
    _875++;
    if (_875 < _868)
    goto _jump1089;
    // End body of loop
    _714 = _856;
    _jump1078:;
    write_image(_714, "f.png");
    int64_t _878;
    // Computing bound for f
    if (_455.d0 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    _878 = 0;
    int64_t _879 = 0; // f
    _jump1091:; // Begin body of loop
    int64_t _880;
    // Computing bound for g
    if (_455.d1 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing bound for h
    int64_t _881 = _455.d0 + _879;
    if (_881 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing bound for i
    int64_t _882 = 696;
    if (_882 > 0) 
    goto _jump1094;
    fail_assertion("non-positive loop bound");
    _jump1094:;
    _880 = 0;
    int64_t _883 = 0; // i
    int64_t _884 = 0; // h
    int64_t _885 = 0; // g
    _jump1095:; // Begin body of loop
    bool _886 = false;
    bool _887 = false;
    bool _888 = _886 != _887;
    int64_t _889;
    if (!_888)
    goto _jump1096;
    _889 = _885;
    goto _jump1097;
    _jump1096:;
    _889 = _885;
    _jump1097:;
    _880 += _889;
    _883++;
    if (_883 < _882)
    goto _jump1095;
    _883 = 0;
    _884++;
    if (_884 < _881)
    goto _jump1095;
    _884 = 0;
    _885++;
    if (_885 < _455.d1)
    goto _jump1095;
    // End body of loop
    int64_t _890 = -_880;
    _878 += _890;
    _879++;
    if (_879 < _455.d0)
    goto _jump1091;
    // End body of loop
    int64_t _891 = -_878;
    bool _892 = _455.d1 <= _891;
    if (0 != _892)
    goto _jump1098;
    fail_assertion("f");
    _jump1098:;
    double _893 = 0.0;
    double _894;
    // Computing bound for j
    bool _895 = true;
    int64_t _896;
    if (!_895)
    goto _jump1741;
    int64_t _897;
    // Computing bound for j
    int64_t _898 = -_455.d0;
    if (_898 > 0) 
    goto _jump1742;
    fail_assertion("non-positive loop bound");
    _jump1742:;
    // Computing bound for k
    if (_455.d1 > 0) 
    goto _jump1743;
    fail_assertion("non-positive loop bound");
    _jump1743:;
    _897 = 0;
    int64_t _899 = 0; // k
    int64_t _900 = 0; // j
    _jump1744:; // Begin body of loop
    _897 += _455.d0;
    _899++;
    if (_899 < _455.d1)
    goto _jump1744;
    _899 = 0;
    _900++;
    if (_900 < _898)
    goto _jump1744;
    // End body of loop
    if (_455.d0 >= 0)
    goto _jump1745;
    fail_assertion("negative array index");
    _jump1745:;
    if (_455.d0 < _455.d0)
    goto _jump1746;
    fail_assertion("index too large");
    _jump1746:;
    if (_455.d0 >= 0)
    goto _jump1747;
    fail_assertion("negative array index");
    _jump1747:;
    if (_455.d0 < _455.d1)
    goto _jump1748;
    fail_assertion("index too large");
    _jump1748:;
    int64_t _901 = 0;
    _901 *= _455.d0;
    _901 += _455.d0;
    _901 *= _455.d1;
    _901 += _455.d0;
    int64_t _902 = _455.data[_901];
    int64_t _903 = -_902;
    int64_t _904 = _897 % _903;
    bool _905 = i(_455.d1);
    bool _906;
    if (!_905)
    goto _jump1749;
    bool _907 = false;
    _906 = _907;
    goto _jump1750;
    _jump1749:;
    bool _908 = i(_455.d1);
    _906 = _908;
    _jump1750:;
    int64_t _909;
    if (!_906)
    goto _jump1751;
    int64_t _910;
    // Computing bound for j
    int64_t _911 = 181;
    if (_911 > 0) 
    goto _jump1752;
    fail_assertion("non-positive loop bound");
    _jump1752:;
    // Computing bound for k
    int64_t _912 = -_455.d1;
    if (_912 > 0) 
    goto _jump1753;
    fail_assertion("non-positive loop bound");
    _jump1753:;
    // Computing bound for l
    int64_t _913 = _455.d0 - _455.d0;
    if (_913 > 0) 
    goto _jump1754;
    fail_assertion("non-positive loop bound");
    _jump1754:;
    _910 = 0;
    int64_t _914 = 0; // l
    int64_t _915 = 0; // k
    int64_t _916 = 0; // j
    _jump1755:; // Begin body of loop
    _910 += _914;
    _914++;
    if (_914 < _913)
    goto _jump1755;
    _914 = 0;
    _915++;
    if (_915 < _912)
    goto _jump1755;
    _915 = 0;
    _916++;
    if (_916 < _911)
    goto _jump1755;
    // End body of loop
    _909 = _910;
    goto _jump1756;
    _jump1751:;
    bool _918 = false;
    bool _917 = _918;
    if (0 != _918)
    goto _jump1757;
    bool _919 = false;
    _917 = _919;
    _jump1757:;
    int64_t _920;
    if (!_917)
    goto _jump1758;
    _920 = _455.d1;
    goto _jump1759;
    _jump1758:;
    _920 = _455.d0;
    _jump1759:;
    _909 = _920;
    _jump1756:;
    int64_t _921 = _904 / _909;
    int64_t _922 = -_921;
    _896 = _922;
    goto _jump1760;
    _jump1741:;
    _a2__a3_int64_t _923;
    // Computing bound for j
    _923.d0 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump1761;
    fail_assertion("non-positive loop bound");
    _jump1761:;
    // Computing bound for k
    bool _924 = _455.d0 == _455.d1;
    int64_t _925;
    if (!_924)
    goto _jump1762;
    _925 = _455.d0;
    goto _jump1763;
    _jump1762:;
    _925 = _455.d1;
    _jump1763:;
    _923.d1 = _925;
    if (_925 > 0) 
    goto _jump1764;
    fail_assertion("non-positive loop bound");
    _jump1764:;
    // Computing total size of heap memory to allocate
    int64_t _926 = 1;
    _926 *= _455.d1;
    _926 *= _925;
    _926 *= sizeof(_a3_int64_t);
    _923.data = jpl_alloc(_926);
    int64_t _927 = 0; // k
    int64_t _928 = 0; // j
    _jump1765:; // Begin body of loop
    _a3_int64_t _929;
    // Computing bound for l
    _929.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1766;
    fail_assertion("non-positive loop bound");
    _jump1766:;
    // Computing bound for m
    int64_t _930 = -_455.d0;
    _929.d1 = _930;
    if (_930 > 0) 
    goto _jump1767;
    fail_assertion("non-positive loop bound");
    _jump1767:;
    // Computing bound for n
    int64_t _931 = 436;
    int64_t _932 = _931 * _928;
    _929.d2 = _932;
    if (_932 > 0) 
    goto _jump1768;
    fail_assertion("non-positive loop bound");
    _jump1768:;
    // Computing total size of heap memory to allocate
    int64_t _933 = 1;
    _933 *= _455.d0;
    _933 *= _930;
    _933 *= _932;
    _933 *= sizeof(int64_t);
    _929.data = jpl_alloc(_933);
    int64_t _934 = 0; // n
    int64_t _935 = 0; // m
    int64_t _936 = 0; // l
    _jump1769:; // Begin body of loop
    int64_t _937 = 436;
    int64_t _938 = 0;
    _938 *= _929.d0;
    _938 += _936;
    _938 *= _929.d1;
    _938 += _935;
    _938 *= _929.d2;
    _938 += _934;
    _929.data[_938] = _937;
    _934++;
    if (_934 < _932)
    goto _jump1769;
    _934 = 0;
    _935++;
    if (_935 < _930)
    goto _jump1769;
    _935 = 0;
    _936++;
    if (_936 < _455.d0)
    goto _jump1769;
    // End body of loop
    int64_t _939 = 0;
    _939 *= _923.d0;
    _939 += _928;
    _939 *= _923.d1;
    _939 += _927;
    _923.data[_939] = _929;
    _927++;
    if (_927 < _925)
    goto _jump1765;
    _927 = 0;
    _928++;
    if (_928 < _455.d1)
    goto _jump1765;
    // End body of loop
    int64_t _940 = 574;
    int64_t _941;
    // Computing bound for j
    int64_t _942;
    // Computing bound for j
    if (_455.d1 > 0) 
    goto _jump1770;
    fail_assertion("non-positive loop bound");
    _jump1770:;
    _942 = 0;
    int64_t _943 = 0; // j
    _jump1771:; // Begin body of loop
    _942 += _455.d1;
    _943++;
    if (_943 < _455.d1)
    goto _jump1771;
    // End body of loop
    int64_t _944;
    // Computing bound for j
    if (_455.d0 > 0) 
    goto _jump1772;
    fail_assertion("non-positive loop bound");
    _jump1772:;
    _944 = 0;
    int64_t _945 = 0; // j
    _jump1773:; // Begin body of loop
    _944 += _455.d0;
    _945++;
    if (_945 < _455.d0)
    goto _jump1773;
    // End body of loop
    int64_t _946 = _942 * _944;
    if (_946 > 0) 
    goto _jump1774;
    fail_assertion("non-positive loop bound");
    _jump1774:;
    // Computing bound for k
    _a1_int64_t _947;
    _947.d0 = 1;
    _947.data = jpl_alloc(sizeof(int64_t) * 1);
    _947.data[0] = _455.d1;
    int64_t _948;
    // Computing bound for j
    if (_455.d0 > 0) 
    goto _jump1775;
    fail_assertion("non-positive loop bound");
    _jump1775:;
    _948 = 0;
    int64_t _949 = 0; // j
    _jump1776:; // Begin body of loop
    int64_t _950 = 265;
    _948 += _950;
    _949++;
    if (_949 < _455.d0)
    goto _jump1776;
    // End body of loop
    if (_948 >= 0)
    goto _jump1777;
    fail_assertion("negative array index");
    _jump1777:;
    if (_948 < _947.d0)
    goto _jump1778;
    fail_assertion("index too large");
    _jump1778:;
    int64_t _951 = 0;
    _951 *= _947.d0;
    _951 += _948;
    int64_t _952 = _947.data[_951];
    if (_952 > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    // Computing bound for l
    int64_t _953 = _455.d1 + _455.d0;
    if (_953 > 0) 
    goto _jump1780;
    fail_assertion("non-positive loop bound");
    _jump1780:;
    _941 = 0;
    int64_t _954 = 0; // l
    int64_t _955 = 0; // k
    int64_t _956 = 0; // j
    _jump1781:; // Begin body of loop
    int64_t _957;
    // Computing bound for m
    int64_t _958 = 827;
    int64_t _959 = _455.d1 - _958;
    if (_959 > 0) 
    goto _jump1782;
    fail_assertion("non-positive loop bound");
    _jump1782:;
    _957 = 0;
    int64_t _960 = 0; // m
    _jump1783:; // Begin body of loop
    int64_t _961 = _455.d1 * _960;
    _957 += _961;
    _960++;
    if (_960 < _959)
    goto _jump1783;
    // End body of loop
    _941 += _957;
    _954++;
    if (_954 < _953)
    goto _jump1781;
    _954 = 0;
    _955++;
    if (_955 < _952)
    goto _jump1781;
    _955 = 0;
    _956++;
    if (_956 < _946)
    goto _jump1781;
    // End body of loop
    if (_940 >= 0)
    goto _jump1784;
    fail_assertion("negative array index");
    _jump1784:;
    if (_940 < _923.d0)
    goto _jump1785;
    fail_assertion("index too large");
    _jump1785:;
    if (_941 >= 0)
    goto _jump1786;
    fail_assertion("negative array index");
    _jump1786:;
    if (_941 < _923.d1)
    goto _jump1787;
    fail_assertion("index too large");
    _jump1787:;
    int64_t _962 = 0;
    _962 *= _923.d0;
    _962 += _940;
    _962 *= _923.d1;
    _962 += _941;
    _a3_int64_t _963 = _923.data[_962];
    int64_t _964;
    // Computing bound for j
    int64_t _965;
    // Computing bound for j
    if (_455.d0 > 0) 
    goto _jump1788;
    fail_assertion("non-positive loop bound");
    _jump1788:;
    // Computing bound for k
    int64_t _966;
    // Computing bound for j
    if (_455.d1 > 0) 
    goto _jump1789;
    fail_assertion("non-positive loop bound");
    _jump1789:;
    // Computing bound for k
    int64_t _967 = 393;
    int64_t _968 = _967 % _455.d0;
    if (_968 > 0) 
    goto _jump1790;
    fail_assertion("non-positive loop bound");
    _jump1790:;
    // Computing bound for l
    int64_t _969 = 310;
    int64_t _970 = -_969;
    if (_970 > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    _966 = 0;
    int64_t _971 = 0; // l
    int64_t _972 = 0; // k
    int64_t _973 = 0; // j
    _jump1792:; // Begin body of loop
    int64_t _974 = 156;
    _966 += _974;
    _971++;
    if (_971 < _970)
    goto _jump1792;
    _971 = 0;
    _972++;
    if (_972 < _968)
    goto _jump1792;
    _972 = 0;
    _973++;
    if (_973 < _455.d1)
    goto _jump1792;
    // End body of loop
    if (_966 > 0) 
    goto _jump1793;
    fail_assertion("non-positive loop bound");
    _jump1793:;
    // Computing bound for l
    bool _975 = false;
    int64_t _976;
    if (!_975)
    goto _jump1794;
    _976 = _455.d1;
    goto _jump1795;
    _jump1794:;
    _976 = _455.d0;
    _jump1795:;
    if (_976 > 0) 
    goto _jump1796;
    fail_assertion("non-positive loop bound");
    _jump1796:;
    _965 = 0;
    int64_t _977 = 0; // l
    int64_t _978 = 0; // k
    int64_t _979 = 0; // j
    _jump1797:; // Begin body of loop
    int64_t _980 = 439;
    _965 += _980;
    _977++;
    if (_977 < _976)
    goto _jump1797;
    _977 = 0;
    _978++;
    if (_978 < _966)
    goto _jump1797;
    _978 = 0;
    _979++;
    if (_979 < _455.d0)
    goto _jump1797;
    // End body of loop
    if (_965 > 0) 
    goto _jump1798;
    fail_assertion("non-positive loop bound");
    _jump1798:;
    // Computing bound for k
    _a3_int64_t _981;
    // Computing bound for j
    _981.d0 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump1799;
    fail_assertion("non-positive loop bound");
    _jump1799:;
    // Computing bound for k
    int64_t _982 = 498;
    _981.d1 = _982;
    if (_982 > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for l
    int64_t _983 = 507;
    _981.d2 = _983;
    if (_983 > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing total size of heap memory to allocate
    int64_t _984 = 1;
    _984 *= _455.d1;
    _984 *= _982;
    _984 *= _983;
    _984 *= sizeof(int64_t);
    _981.data = jpl_alloc(_984);
    int64_t _985 = 0; // l
    int64_t _986 = 0; // k
    int64_t _987 = 0; // j
    _jump1802:; // Begin body of loop
    int64_t _988 = 777;
    int64_t _989 = 695;
    if (_988 >= 0)
    goto _jump1803;
    fail_assertion("negative array index");
    _jump1803:;
    if (_988 < _455.d0)
    goto _jump1804;
    fail_assertion("index too large");
    _jump1804:;
    if (_989 >= 0)
    goto _jump1805;
    fail_assertion("negative array index");
    _jump1805:;
    if (_989 < _455.d1)
    goto _jump1806;
    fail_assertion("index too large");
    _jump1806:;
    int64_t _990 = 0;
    _990 *= _455.d0;
    _990 += _988;
    _990 *= _455.d1;
    _990 += _989;
    int64_t _991 = _455.data[_990];
    int64_t _992 = 0;
    _992 *= _981.d0;
    _992 += _987;
    _992 *= _981.d1;
    _992 += _986;
    _992 *= _981.d2;
    _992 += _985;
    _981.data[_992] = _991;
    _985++;
    if (_985 < _983)
    goto _jump1802;
    _985 = 0;
    _986++;
    if (_986 < _982)
    goto _jump1802;
    _986 = 0;
    _987++;
    if (_987 < _455.d1)
    goto _jump1802;
    // End body of loop
    int64_t _993 = 266;
    int64_t _994 = 202;
    int64_t _995 = _994 * _455.d0;
    int64_t _996 = -_995;
    int64_t _997 = -_455.d1;
    if (_993 >= 0)
    goto _jump1807;
    fail_assertion("negative array index");
    _jump1807:;
    if (_993 < _981.d0)
    goto _jump1808;
    fail_assertion("index too large");
    _jump1808:;
    if (_996 >= 0)
    goto _jump1809;
    fail_assertion("negative array index");
    _jump1809:;
    if (_996 < _981.d1)
    goto _jump1810;
    fail_assertion("index too large");
    _jump1810:;
    if (_997 >= 0)
    goto _jump1811;
    fail_assertion("negative array index");
    _jump1811:;
    if (_997 < _981.d2)
    goto _jump1812;
    fail_assertion("index too large");
    _jump1812:;
    int64_t _998 = 0;
    _998 *= _981.d0;
    _998 += _993;
    _998 *= _981.d1;
    _998 += _996;
    _998 *= _981.d2;
    _998 += _997;
    int64_t _999 = _981.data[_998];
    if (_999 > 0) 
    goto _jump1813;
    fail_assertion("non-positive loop bound");
    _jump1813:;
    // Computing bound for l
    bool _1000 = false;
    int64_t _1001;
    if (!_1000)
    goto _jump1814;
    _1001 = _455.d0;
    goto _jump1815;
    _jump1814:;
    int64_t _1002;
    // Computing bound for j
    if (_455.d1 > 0) 
    goto _jump1816;
    fail_assertion("non-positive loop bound");
    _jump1816:;
    _1002 = 0;
    int64_t _1003 = 0; // j
    _jump1817:; // Begin body of loop
    _1002 += _455.d1;
    _1003++;
    if (_1003 < _455.d1)
    goto _jump1817;
    // End body of loop
    _1001 = _1002;
    _jump1815:;
    if (_1001 > 0) 
    goto _jump1818;
    fail_assertion("non-positive loop bound");
    _jump1818:;
    _964 = 0;
    int64_t _1004 = 0; // l
    int64_t _1005 = 0; // k
    int64_t _1006 = 0; // j
    _jump1819:; // Begin body of loop
    _964 += _1004;
    _1004++;
    if (_1004 < _1001)
    goto _jump1819;
    _1004 = 0;
    _1005++;
    if (_1005 < _999)
    goto _jump1819;
    _1005 = 0;
    _1006++;
    if (_1006 < _965)
    goto _jump1819;
    // End body of loop
    int64_t _1007 = 985;
    int64_t _1008;
    // Computing bound for j
    if (_455.d0 > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing bound for k
    bool _1009 = true;
    int64_t _1010;
    if (!_1009)
    goto _jump1821;
    _1010 = _455.d1;
    goto _jump1822;
    _jump1821:;
    int64_t _1011 = -_455.d0;
    _1010 = _1011;
    _jump1822:;
    if (_1010 > 0) 
    goto _jump1823;
    fail_assertion("non-positive loop bound");
    _jump1823:;
    _1008 = 0;
    int64_t _1012 = 0; // k
    int64_t _1013 = 0; // j
    _jump1824:; // Begin body of loop
    _1008 += _1012;
    _1012++;
    if (_1012 < _1010)
    goto _jump1824;
    _1012 = 0;
    _1013++;
    if (_1013 < _455.d0)
    goto _jump1824;
    // End body of loop
    int64_t _1014 = _1008 % _455.d1;
    if (_964 >= 0)
    goto _jump1825;
    fail_assertion("negative array index");
    _jump1825:;
    if (_964 < _963.d0)
    goto _jump1826;
    fail_assertion("index too large");
    _jump1826:;
    if (_1007 >= 0)
    goto _jump1827;
    fail_assertion("negative array index");
    _jump1827:;
    if (_1007 < _963.d1)
    goto _jump1828;
    fail_assertion("index too large");
    _jump1828:;
    if (_1014 >= 0)
    goto _jump1829;
    fail_assertion("negative array index");
    _jump1829:;
    if (_1014 < _963.d2)
    goto _jump1830;
    fail_assertion("index too large");
    _jump1830:;
    int64_t _1015 = 0;
    _1015 *= _963.d0;
    _1015 += _964;
    _1015 *= _963.d1;
    _1015 += _1007;
    _1015 *= _963.d2;
    _1015 += _1014;
    int64_t _1016 = _963.data[_1015];
    _896 = _1016;
    _jump1760:;
    if (_896 > 0) 
    goto _jump1831;
    fail_assertion("non-positive loop bound");
    _jump1831:;
    _894 = 0;
    int64_t _1017 = 0; // j
    _jump1832:; // Begin body of loop
    double _1018;
    // Computing bound for k
    int64_t _1019 = 596;
    if (_1019 > 0) 
    goto _jump1833;
    fail_assertion("non-positive loop bound");
    _jump1833:;
    // Computing bound for l
    int64_t _1020 = _455.d1 / _455.d0;
    int64_t _1021 = -_1020;
    if (_1021 > 0) 
    goto _jump1834;
    fail_assertion("non-positive loop bound");
    _jump1834:;
    // Computing bound for m
    bool _1022 = true;
    int64_t _1023;
    if (!_1022)
    goto _jump1835;
    bool _1024 = i(_455.d1);
    int64_t _1025;
    if (!_1024)
    goto _jump1836;
    _1025 = _1017;
    goto _jump1837;
    _jump1836:;
    _1025 = _1017;
    _jump1837:;
    int64_t _1026 = _1025 + _455.d0;
    _1023 = _1026;
    goto _jump1838;
    _jump1835:;
    int64_t _1027 = 910;
    _1023 = _1027;
    _jump1838:;
    if (_1023 > 0) 
    goto _jump1839;
    fail_assertion("non-positive loop bound");
    _jump1839:;
    _1018 = 0;
    int64_t _1028 = 0; // m
    int64_t _1029 = 0; // l
    int64_t _1030 = 0; // k
    _jump1840:; // Begin body of loop
    int64_t _1031;
    // Computing bound for n
    if (_1029 > 0) 
    goto _jump1841;
    fail_assertion("non-positive loop bound");
    _jump1841:;
    // Computing bound for o
    int64_t _1032 = 32;
    if (_1032 > 0) 
    goto _jump1842;
    fail_assertion("non-positive loop bound");
    _jump1842:;
    _1031 = 0;
    int64_t _1033 = 0; // o
    int64_t _1034 = 0; // n
    _jump1843:; // Begin body of loop
    _1031 += _1033;
    _1033++;
    if (_1033 < _1032)
    goto _jump1843;
    _1033 = 0;
    _1034++;
    if (_1034 < _1029)
    goto _jump1843;
    // End body of loop
    bool _1035 = i(_1031);
    _a2_double _1036;
    if (!_1035)
    goto _jump1844;
    int64_t _1037 = -_455.d1;
    bool _1038 = _1037 == _1030;
    _a2_double _1039;
    if (!_1038)
    goto _jump1845;
    bool _1040 = true;
    _a2_double _1041;
    if (!_1040)
    goto _jump1846;
    _a2_double _1042;
    // Computing bound for n
    _1042.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1847;
    fail_assertion("non-positive loop bound");
    _jump1847:;
    // Computing bound for o
    _1042.d1 = _1029;
    if (_1029 > 0) 
    goto _jump1848;
    fail_assertion("non-positive loop bound");
    _jump1848:;
    // Computing total size of heap memory to allocate
    int64_t _1043 = 1;
    _1043 *= _455.d0;
    _1043 *= _1029;
    _1043 *= sizeof(double);
    _1042.data = jpl_alloc(_1043);
    int64_t _1044 = 0; // o
    int64_t _1045 = 0; // n
    _jump1849:; // Begin body of loop
    double _1046 = 34.0;
    int64_t _1047 = 0;
    _1047 *= _1042.d0;
    _1047 += _1045;
    _1047 *= _1042.d1;
    _1047 += _1044;
    _1042.data[_1047] = _1046;
    _1044++;
    if (_1044 < _1029)
    goto _jump1849;
    _1044 = 0;
    _1045++;
    if (_1045 < _455.d0)
    goto _jump1849;
    // End body of loop
    _1041 = _1042;
    goto _jump1850;
    _jump1846:;
    _a2_double _1048;
    // Computing bound for n
    _1048.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump1851;
    fail_assertion("non-positive loop bound");
    _jump1851:;
    // Computing bound for o
    _1048.d1 = _1028;
    if (_1028 > 0) 
    goto _jump1852;
    fail_assertion("non-positive loop bound");
    _jump1852:;
    // Computing total size of heap memory to allocate
    int64_t _1049 = 1;
    _1049 *= _455.d0;
    _1049 *= _1028;
    _1049 *= sizeof(double);
    _1048.data = jpl_alloc(_1049);
    int64_t _1050 = 0; // o
    int64_t _1051 = 0; // n
    _jump1853:; // Begin body of loop
    int64_t _1052 = 0;
    _1052 *= _1048.d0;
    _1052 += _1051;
    _1052 *= _1048.d1;
    _1052 += _1050;
    _1048.data[_1052] = _893;
    _1050++;
    if (_1050 < _1028)
    goto _jump1853;
    _1050 = 0;
    _1051++;
    if (_1051 < _455.d0)
    goto _jump1853;
    // End body of loop
    _1041 = _1048;
    _jump1850:;
    _1039 = _1041;
    goto _jump1854;
    _jump1845:;
    _a2_double _1053;
    // Computing bound for n
    int64_t _1054 = _1017 % _1028;
    _1053.d0 = _1054;
    if (_1054 > 0) 
    goto _jump1855;
    fail_assertion("non-positive loop bound");
    _jump1855:;
    // Computing bound for o
    int64_t _1055 = -_455.d1;
    _1053.d1 = _1055;
    if (_1055 > 0) 
    goto _jump1856;
    fail_assertion("non-positive loop bound");
    _jump1856:;
    // Computing total size of heap memory to allocate
    int64_t _1056 = 1;
    _1056 *= _1054;
    _1056 *= _1055;
    _1056 *= sizeof(double);
    _1053.data = jpl_alloc(_1056);
    int64_t _1057 = 0; // o
    int64_t _1058 = 0; // n
    _jump1857:; // Begin body of loop
    double _1059 = 91.0;
    double _1060 = 51.0;
    double _1061 = _1059 * _1060;
    int64_t _1062 = 0;
    _1062 *= _1053.d0;
    _1062 += _1058;
    _1062 *= _1053.d1;
    _1062 += _1057;
    _1053.data[_1062] = _1061;
    _1057++;
    if (_1057 < _1055)
    goto _jump1857;
    _1057 = 0;
    _1058++;
    if (_1058 < _1054)
    goto _jump1857;
    // End body of loop
    _1039 = _1053;
    _jump1854:;
    _1036 = _1039;
    goto _jump1858;
    _jump1844:;
    _a2_double _1063;
    // Computing bound for n
    _1063.d0 = _1029;
    if (_1029 > 0) 
    goto _jump1859;
    fail_assertion("non-positive loop bound");
    _jump1859:;
    // Computing bound for o
    _1063.d1 = _1029;
    if (_1029 > 0) 
    goto _jump1860;
    fail_assertion("non-positive loop bound");
    _jump1860:;
    // Computing total size of heap memory to allocate
    int64_t _1064 = 1;
    _1064 *= _1029;
    _1064 *= _1029;
    _1064 *= sizeof(double);
    _1063.data = jpl_alloc(_1064);
    int64_t _1065 = 0; // o
    int64_t _1066 = 0; // n
    _jump1861:; // Begin body of loop
    _a1_double _1067;
    // Computing bound for p
    _1067.d0 = _1029;
    if (_1029 > 0) 
    goto _jump1862;
    fail_assertion("non-positive loop bound");
    _jump1862:;
    // Computing total size of heap memory to allocate
    int64_t _1068 = 1;
    _1068 *= _1029;
    _1068 *= sizeof(double);
    _1067.data = jpl_alloc(_1068);
    int64_t _1069 = 0; // p
    _jump1863:; // Begin body of loop
    double _1070 = 16.0;
    int64_t _1071 = 0;
    _1071 *= _1067.d0;
    _1071 += _1069;
    _1067.data[_1071] = _1070;
    _1069++;
    if (_1069 < _1029)
    goto _jump1863;
    // End body of loop
    int64_t _1072 = _1030 * _1017;
    if (_1072 >= 0)
    goto _jump1864;
    fail_assertion("negative array index");
    _jump1864:;
    if (_1072 < _1067.d0)
    goto _jump1865;
    fail_assertion("index too large");
    _jump1865:;
    int64_t _1073 = 0;
    _1073 *= _1067.d0;
    _1073 += _1072;
    double _1074 = _1067.data[_1073];
    int64_t _1075 = 0;
    _1075 *= _1063.d0;
    _1075 += _1066;
    _1075 *= _1063.d1;
    _1075 += _1065;
    _1063.data[_1075] = _1074;
    _1065++;
    if (_1065 < _1029)
    goto _jump1861;
    _1065 = 0;
    _1066++;
    if (_1066 < _1029)
    goto _jump1861;
    // End body of loop
    _1036 = _1063;
    _jump1858:;
    int64_t _1076 = 943;
    if (_1076 >= 0)
    goto _jump1866;
    fail_assertion("negative array index");
    _jump1866:;
    if (_1076 < _1036.d0)
    goto _jump1867;
    fail_assertion("index too large");
    _jump1867:;
    if (_455.d0 >= 0)
    goto _jump1868;
    fail_assertion("negative array index");
    _jump1868:;
    if (_455.d0 < _1036.d1)
    goto _jump1869;
    fail_assertion("index too large");
    _jump1869:;
    int64_t _1077 = 0;
    _1077 *= _1036.d0;
    _1077 += _1076;
    _1077 *= _1036.d1;
    _1077 += _455.d0;
    double _1078 = _1036.data[_1077];
    _1018 += _1078;
    _1028++;
    if (_1028 < _1023)
    goto _jump1840;
    _1028 = 0;
    _1029++;
    if (_1029 < _1021)
    goto _jump1840;
    _1029 = 0;
    _1030++;
    if (_1030 < _1019)
    goto _jump1840;
    // End body of loop
    _894 += _1018;
    _1017++;
    if (_1017 < _896)
    goto _jump1832;
    // End body of loop
    show("(FloatType)", &_894);
    int64_t _1079 = 884;
    int64_t _1080 = -_1079;
    show("(IntType)", &_1080);
    bool _1081 = i(_455.d1);
    _a3_int64_t _1082;
    // Computing bound for n
    _1082.d0 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump2711;
    fail_assertion("non-positive loop bound");
    _jump2711:;
    // Computing bound for o
    bool _1083 = false;
    bool _1084 = !_1083;
    int64_t _1085;
    if (!_1084)
    goto _jump2712;
    int64_t _1086 = 351;
    _1085 = _1086;
    goto _jump2713;
    _jump2712:;
    int64_t _1087 = 242;
    int64_t _1088 = -_1087;
    _1085 = _1088;
    _jump2713:;
    _1082.d1 = _1085;
    if (_1085 > 0) 
    goto _jump2714;
    fail_assertion("non-positive loop bound");
    _jump2714:;
    // Computing bound for p
    bool _1089 = true;
    int64_t _1090;
    if (!_1089)
    goto _jump2715;
    int64_t _1091 = 289;
    _1090 = _1091;
    goto _jump2716;
    _jump2715:;
    int64_t _1092 = 272;
    _1090 = _1092;
    _jump2716:;
    _1082.d2 = _1090;
    if (_1090 > 0) 
    goto _jump2717;
    fail_assertion("non-positive loop bound");
    _jump2717:;
    // Computing total size of heap memory to allocate
    int64_t _1093 = 1;
    _1093 *= _455.d1;
    _1093 *= _1085;
    _1093 *= _1090;
    _1093 *= sizeof(int64_t);
    _1082.data = jpl_alloc(_1093);
    int64_t _1094 = 0; // p
    int64_t _1095 = 0; // o
    int64_t _1096 = 0; // n
    _jump2718:; // Begin body of loop
    int64_t _1097 = _455.d0 / _455.d1;
    int64_t _1098 = 0;
    _1098 *= _1082.d0;
    _1098 += _1096;
    _1098 *= _1082.d1;
    _1098 += _1095;
    _1098 *= _1082.d2;
    _1098 += _1094;
    _1082.data[_1098] = _1097;
    _1094++;
    if (_1094 < _1090)
    goto _jump2718;
    _1094 = 0;
    _1095++;
    if (_1095 < _1085)
    goto _jump2718;
    _1095 = 0;
    _1096++;
    if (_1096 < _455.d1)
    goto _jump2718;
    // End body of loop
    int64_t _1099 = _455.d1 - _455.d1;
    int64_t _1100 = 238;
    int64_t _1101 = -_1100;
    int64_t _1102 = _1099 - _1101;
    int64_t _1103 = -_1102;
    int64_t _1104;
    // Computing bound for n
    if (_455.d1 > 0) 
    goto _jump2719;
    fail_assertion("non-positive loop bound");
    _jump2719:;
    // Computing bound for o
    int64_t _1105 = _455.d1 + _455.d0;
    if (_1105 > 0) 
    goto _jump2720;
    fail_assertion("non-positive loop bound");
    _jump2720:;
    // Computing bound for p
    int64_t _1106 = 529;
    if (_1106 > 0) 
    goto _jump2721;
    fail_assertion("non-positive loop bound");
    _jump2721:;
    _1104 = 0;
    int64_t _1107 = 0; // p
    int64_t _1108 = 0; // o
    int64_t _1109 = 0; // n
    _jump2722:; // Begin body of loop
    int64_t _1110;
    // Computing bound for q
    int64_t _1111;
    // Computing bound for q
    if (_455.d1 > 0) 
    goto _jump2723;
    fail_assertion("non-positive loop bound");
    _jump2723:;
    _1111 = 0;
    int64_t _1112 = 0; // q
    _jump2724:; // Begin body of loop
    _1111 += _1107;
    _1112++;
    if (_1112 < _455.d1)
    goto _jump2724;
    // End body of loop
    if (_1111 > 0) 
    goto _jump2725;
    fail_assertion("non-positive loop bound");
    _jump2725:;
    _1110 = 0;
    int64_t _1113 = 0; // q
    _jump2726:; // Begin body of loop
    _1110 += _1109;
    _1113++;
    if (_1113 < _1111)
    goto _jump2726;
    // End body of loop
    _1104 += _1110;
    _1107++;
    if (_1107 < _1106)
    goto _jump2722;
    _1107 = 0;
    _1108++;
    if (_1108 < _1105)
    goto _jump2722;
    _1108 = 0;
    _1109++;
    if (_1109 < _455.d1)
    goto _jump2722;
    // End body of loop
    if (_1103 >= 0)
    goto _jump2727;
    fail_assertion("negative array index");
    _jump2727:;
    if (_1103 < _1082.d0)
    goto _jump2728;
    fail_assertion("index too large");
    _jump2728:;
    if (_455.d0 >= 0)
    goto _jump2729;
    fail_assertion("negative array index");
    _jump2729:;
    if (_455.d0 < _1082.d1)
    goto _jump2730;
    fail_assertion("index too large");
    _jump2730:;
    if (_1104 >= 0)
    goto _jump2731;
    fail_assertion("negative array index");
    _jump2731:;
    if (_1104 < _1082.d2)
    goto _jump2732;
    fail_assertion("index too large");
    _jump2732:;
    int64_t _1114 = 0;
    _1114 *= _1082.d0;
    _1114 += _1103;
    _1114 *= _1082.d1;
    _1114 += _455.d0;
    _1114 *= _1082.d2;
    _1114 += _1104;
    int64_t _1115 = _1082.data[_1114];
    double _1116 = 31.0;
    bool _1117 = _893 == _1116;
    int64_t _1118;
    if (!_1117)
    goto _jump2733;
    int64_t _1119 = 485;
    int64_t _1120 = -_1119;
    _1118 = _1120;
    goto _jump2734;
    _jump2733:;
    _1118 = _455.d0;
    _jump2734:;
    int64_t _1121 = -_1118;
    bool _1122 = true;
    int64_t _1123;
    if (!_1122)
    goto _jump2735;
    _1123 = _455.d1;
    goto _jump2736;
    _jump2735:;
    int64_t _1124 = 368;
    _1123 = _1124;
    _jump2736:;
    int64_t _1125 = _1121 + _1123;
    bool _1126 = _1115 != _1125;
    bool _1127 = _1081 != _1126;
    bool _1128;
    if (!_1127)
    goto _jump2737;
    int64_t _1129 = 70;
    bool _1130 = _455.d0 == _1129;
    _1128 = _1130;
    goto _jump2738;
    _jump2737:;
    bool _1132 = i(_455.d0);
    bool _1131 = _1132;
    if (0 == _1132)
    goto _jump2739;
    bool _1133 = false;
    _1131 = _1133;
    _jump2739:;
    bool _1134 = false;
    bool _1135 = !_1134;
    int64_t _1136;
    if (!_1135)
    goto _jump2740;
    int64_t _1137;
    // Computing bound for n
    int64_t _1138 = 845;
    if (_1138 > 0) 
    goto _jump2741;
    fail_assertion("non-positive loop bound");
    _jump2741:;
    // Computing bound for o
    int64_t _1139 = 567;
    if (_1139 > 0) 
    goto _jump2742;
    fail_assertion("non-positive loop bound");
    _jump2742:;
    _1137 = 0;
    int64_t _1140 = 0; // o
    int64_t _1141 = 0; // n
    _jump2743:; // Begin body of loop
    int64_t _1142 = 629;
    _1137 += _1142;
    _1140++;
    if (_1140 < _1139)
    goto _jump2743;
    _1140 = 0;
    _1141++;
    if (_1141 < _1138)
    goto _jump2743;
    // End body of loop
    _1136 = _1137;
    goto _jump2744;
    _jump2740:;
    _1136 = _455.d0;
    _jump2744:;
    bool _1143 = i(_1136);
    bool _1144 = _1131 == _1143;
    _a1_int64_t _1145;
    // Computing bound for n
    int64_t _1146 = 723;
    _1145.d0 = _1146;
    if (_1146 > 0) 
    goto _jump2745;
    fail_assertion("non-positive loop bound");
    _jump2745:;
    // Computing total size of heap memory to allocate
    int64_t _1147 = 1;
    _1147 *= _1146;
    _1147 *= sizeof(int64_t);
    _1145.data = jpl_alloc(_1147);
    int64_t _1148 = 0; // n
    _jump2746:; // Begin body of loop
    int64_t _1149 = 544;
    int64_t _1150 = 0;
    _1150 *= _1145.d0;
    _1150 += _1148;
    _1145.data[_1150] = _1149;
    _1148++;
    if (_1148 < _1146)
    goto _jump2746;
    // End body of loop
    bool _1151 = true;
    int64_t _1152;
    if (!_1151)
    goto _jump2747;
    int64_t _1153 = 330;
    _1152 = _1153;
    goto _jump2748;
    _jump2747:;
    _1152 = _455.d0;
    _jump2748:;
    if (_1152 >= 0)
    goto _jump2749;
    fail_assertion("negative array index");
    _jump2749:;
    if (_1152 < _1145.d0)
    goto _jump2750;
    fail_assertion("index too large");
    _jump2750:;
    int64_t _1154 = 0;
    _1154 *= _1145.d0;
    _1154 += _1152;
    int64_t _1155 = _1145.data[_1154];
    int64_t _1156 = 450;
    bool _1157 = _1155 >= _1156;
    _a3_bool _1158;
    if (!_1157)
    goto _jump2751;
    _a3_bool _1159;
    // Computing bound for n
    int64_t _1160;
    // Computing bound for n
    if (_455.d1 > 0) 
    goto _jump2752;
    fail_assertion("non-positive loop bound");
    _jump2752:;
    _1160 = 0;
    int64_t _1161 = 0; // n
    _jump2753:; // Begin body of loop
    _1160 += _455.d1;
    _1161++;
    if (_1161 < _455.d1)
    goto _jump2753;
    // End body of loop
    _1159.d0 = _1160;
    if (_1160 > 0) 
    goto _jump2754;
    fail_assertion("non-positive loop bound");
    _jump2754:;
    // Computing bound for o
    int64_t _1162 = 486;
    _1159.d1 = _1162;
    if (_1162 > 0) 
    goto _jump2755;
    fail_assertion("non-positive loop bound");
    _jump2755:;
    // Computing bound for p
    int64_t _1163 = -_455.d1;
    int64_t _1164 = -_455.d1;
    int64_t _1165 = _1163 - _1164;
    _1159.d2 = _1165;
    if (_1165 > 0) 
    goto _jump2756;
    fail_assertion("non-positive loop bound");
    _jump2756:;
    // Computing total size of heap memory to allocate
    int64_t _1166 = 1;
    _1166 *= _1160;
    _1166 *= _1162;
    _1166 *= _1165;
    _1166 *= sizeof(bool);
    _1159.data = jpl_alloc(_1166);
    int64_t _1167 = 0; // p
    int64_t _1168 = 0; // o
    int64_t _1169 = 0; // n
    _jump2757:; // Begin body of loop
    int64_t _1170 = 281;
    bool _1171 = i(_1170);
    int64_t _1172 = 0;
    _1172 *= _1159.d0;
    _1172 += _1169;
    _1172 *= _1159.d1;
    _1172 += _1168;
    _1172 *= _1159.d2;
    _1172 += _1167;
    _1159.data[_1172] = _1171;
    _1167++;
    if (_1167 < _1165)
    goto _jump2757;
    _1167 = 0;
    _1168++;
    if (_1168 < _1162)
    goto _jump2757;
    _1168 = 0;
    _1169++;
    if (_1169 < _1160)
    goto _jump2757;
    // End body of loop
    _1158 = _1159;
    goto _jump2758;
    _jump2751:;
    _a3_bool _1173;
    // Computing bound for n
    _a1_int64_t _1174;
    // Computing bound for n
    _1174.d0 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump2759;
    fail_assertion("non-positive loop bound");
    _jump2759:;
    // Computing total size of heap memory to allocate
    int64_t _1175 = 1;
    _1175 *= _455.d0;
    _1175 *= sizeof(int64_t);
    _1174.data = jpl_alloc(_1175);
    int64_t _1176 = 0; // n
    _jump2760:; // Begin body of loop
    int64_t _1177 = 0;
    _1177 *= _1174.d0;
    _1177 += _1176;
    _1174.data[_1177] = _455.d0;
    _1176++;
    if (_1176 < _455.d0)
    goto _jump2760;
    // End body of loop
    int64_t _1178 = 941;
    if (_1178 >= 0)
    goto _jump2761;
    fail_assertion("negative array index");
    _jump2761:;
    if (_1178 < _1174.d0)
    goto _jump2762;
    fail_assertion("index too large");
    _jump2762:;
    int64_t _1179 = 0;
    _1179 *= _1174.d0;
    _1179 += _1178;
    int64_t _1180 = _1174.data[_1179];
    _1173.d0 = _1180;
    if (_1180 > 0) 
    goto _jump2763;
    fail_assertion("non-positive loop bound");
    _jump2763:;
    // Computing bound for o
    _1173.d1 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump2764;
    fail_assertion("non-positive loop bound");
    _jump2764:;
    // Computing bound for p
    int64_t _1181 = 917;
    int64_t _1182 = -_1181;
    _1173.d2 = _1182;
    if (_1182 > 0) 
    goto _jump2765;
    fail_assertion("non-positive loop bound");
    _jump2765:;
    // Computing total size of heap memory to allocate
    int64_t _1183 = 1;
    _1183 *= _1180;
    _1183 *= _455.d0;
    _1183 *= _1182;
    _1183 *= sizeof(bool);
    _1173.data = jpl_alloc(_1183);
    int64_t _1184 = 0; // p
    int64_t _1185 = 0; // o
    int64_t _1186 = 0; // n
    _jump2766:; // Begin body of loop
    bool _1187 = _455.d0 <= _455.d0;
    bool _1188;
    if (!_1187)
    goto _jump2767;
    bool _1189 = false;
    _1188 = _1189;
    goto _jump2768;
    _jump2767:;
    bool _1190 = _1185 > _1185;
    _1188 = _1190;
    _jump2768:;
    int64_t _1191 = 0;
    _1191 *= _1173.d0;
    _1191 += _1186;
    _1191 *= _1173.d1;
    _1191 += _1185;
    _1191 *= _1173.d2;
    _1191 += _1184;
    _1173.data[_1191] = _1188;
    _1184++;
    if (_1184 < _1182)
    goto _jump2766;
    _1184 = 0;
    _1185++;
    if (_1185 < _455.d0)
    goto _jump2766;
    _1185 = 0;
    _1186++;
    if (_1186 < _1180)
    goto _jump2766;
    // End body of loop
    _1158 = _1173;
    _jump2758:;
    int64_t _1192 = 893;
    bool _1193 = i(_1192);
    double _1194;
    if (!_1193)
    goto _jump2769;
    _1194 = _893;
    goto _jump2770;
    _jump2769:;
    double _1195 = 3.0;
    double _1196 = _1195 - _893;
    double _1197 = _893 * _1196;
    _1194 = _1197;
    _jump2770:;
    double _1198 = 76.0;
    rgba _1199 = { _893, _1194, _893, _1198 };
    l _1200 = { _1144, _1158, _1199 };
    bool _1201 = _1200.a;
    _1128 = _1201;
    _jump2738:;
    _a1_o _1202;
    // Computing bound for p
    rgba _1203 = k();
    double _1204 = _1203.b;
    double _1205;
    // Computing bound for p
    if (_455.d0 > 0) 
    goto _jump2771;
    fail_assertion("non-positive loop bound");
    _jump2771:;
    // Computing bound for q
    if (_455.d0 > 0) 
    goto _jump2772;
    fail_assertion("non-positive loop bound");
    _jump2772:;
    _1205 = 0;
    int64_t _1206 = 0; // q
    int64_t _1207 = 0; // p
    _jump2773:; // Begin body of loop
    double _1208 = -_893;
    double _1209 = fmod(_1208, _893);
    _1205 += _1209;
    _1206++;
    if (_1206 < _455.d0)
    goto _jump2773;
    _1206 = 0;
    _1207++;
    if (_1207 < _455.d0)
    goto _jump2773;
    // End body of loop
    bool _1210 = _1204 == _1205;
    bool _1211 = !_1210;
    int64_t _1212;
    if (!_1211)
    goto _jump2774;
    bool _1213 = !_1128;
    int64_t _1214;
    if (!_1213)
    goto _jump2775;
    int64_t _1215;
    // Computing bound for p
    int64_t _1216;
    if (!_1128)
    goto _jump2776;
    int64_t _1217;
    if (!_1128)
    goto _jump2777;
    _1217 = _455.d0;
    goto _jump2778;
    _jump2777:;
    int64_t _1218 = -_455.d0;
    _1217 = _1218;
    _jump2778:;
    _1216 = _1217;
    goto _jump2779;
    _jump2776:;
    int64_t _1219 = 318;
    int64_t _1220 = -_1219;
    int64_t _1221;
    // Computing bound for p
    int64_t _1222 = 713;
    if (_1222 > 0) 
    goto _jump2780;
    fail_assertion("non-positive loop bound");
    _jump2780:;
    // Computing bound for q
    int64_t _1223 = 610;
    if (_1223 > 0) 
    goto _jump2781;
    fail_assertion("non-positive loop bound");
    _jump2781:;
    _1221 = 0;
    int64_t _1224 = 0; // q
    int64_t _1225 = 0; // p
    _jump2782:; // Begin body of loop
    _1221 += _455.d0;
    _1224++;
    if (_1224 < _1223)
    goto _jump2782;
    _1224 = 0;
    _1225++;
    if (_1225 < _1222)
    goto _jump2782;
    // End body of loop
    int64_t _1226 = _1220 + _1221;
    _1216 = _1226;
    _jump2779:;
    if (_1216 > 0) 
    goto _jump2783;
    fail_assertion("non-positive loop bound");
    _jump2783:;
    // Computing bound for q
    if (_455.d1 > 0) 
    goto _jump2784;
    fail_assertion("non-positive loop bound");
    _jump2784:;
    _1215 = 0;
    int64_t _1227 = 0; // q
    int64_t _1228 = 0; // p
    _jump2785:; // Begin body of loop
    _1215 += _455.d1;
    _1227++;
    if (_1227 < _455.d1)
    goto _jump2785;
    _1227 = 0;
    _1228++;
    if (_1228 < _1216)
    goto _jump2785;
    // End body of loop
    _1214 = _1215;
    goto _jump2786;
    _jump2775:;
    int64_t _1229 = 281;
    int64_t _1230;
    // Computing bound for p
    if (_455.d0 > 0) 
    goto _jump2787;
    fail_assertion("non-positive loop bound");
    _jump2787:;
    _1230 = 0;
    int64_t _1231 = 0; // p
    _jump2788:; // Begin body of loop
    int64_t _1232;
    // Computing bound for q
    if (_455.d1 > 0) 
    goto _jump2789;
    fail_assertion("non-positive loop bound");
    _jump2789:;
    // Computing bound for r
    if (_455.d1 > 0) 
    goto _jump2790;
    fail_assertion("non-positive loop bound");
    _jump2790:;
    _1232 = 0;
    int64_t _1233 = 0; // r
    int64_t _1234 = 0; // q
    _jump2791:; // Begin body of loop
    int64_t _1235 = 776;
    _1232 += _1235;
    _1233++;
    if (_1233 < _455.d1)
    goto _jump2791;
    _1233 = 0;
    _1234++;
    if (_1234 < _455.d1)
    goto _jump2791;
    // End body of loop
    _1230 += _1232;
    _1231++;
    if (_1231 < _455.d0)
    goto _jump2788;
    // End body of loop
    int64_t _1236 = _1229 - _1230;
    int64_t _1237;
    // Computing bound for p
    int64_t _1238;
    // Computing bound for p
    int64_t _1239 = 326;
    if (_1239 > 0) 
    goto _jump2792;
    fail_assertion("non-positive loop bound");
    _jump2792:;
    _1238 = 0;
    int64_t _1240 = 0; // p
    _jump2793:; // Begin body of loop
    _1238 += _455.d1;
    _1240++;
    if (_1240 < _1239)
    goto _jump2793;
    // End body of loop
    if (_1238 > 0) 
    goto _jump2794;
    fail_assertion("non-positive loop bound");
    _jump2794:;
    // Computing bound for q
    int64_t _1241 = 436;
    int64_t _1242 = _455.d0 + _1241;
    int64_t _1243 = -_1242;
    if (_1243 > 0) 
    goto _jump2795;
    fail_assertion("non-positive loop bound");
    _jump2795:;
    // Computing bound for r
    int64_t _1244;
    // Computing bound for p
    int64_t _1245 = 151;
    if (_1245 > 0) 
    goto _jump2796;
    fail_assertion("non-positive loop bound");
    _jump2796:;
    // Computing bound for q
    if (_455.d1 > 0) 
    goto _jump2797;
    fail_assertion("non-positive loop bound");
    _jump2797:;
    // Computing bound for r
    if (_455.d1 > 0) 
    goto _jump2798;
    fail_assertion("non-positive loop bound");
    _jump2798:;
    _1244 = 0;
    int64_t _1246 = 0; // r
    int64_t _1247 = 0; // q
    int64_t _1248 = 0; // p
    _jump2799:; // Begin body of loop
    int64_t _1249 = -_455.d0;
    _1244 += _1249;
    _1246++;
    if (_1246 < _455.d1)
    goto _jump2799;
    _1246 = 0;
    _1247++;
    if (_1247 < _455.d1)
    goto _jump2799;
    _1247 = 0;
    _1248++;
    if (_1248 < _1245)
    goto _jump2799;
    // End body of loop
    if (_1244 > 0) 
    goto _jump2800;
    fail_assertion("non-positive loop bound");
    _jump2800:;
    _1237 = 0;
    int64_t _1250 = 0; // r
    int64_t _1251 = 0; // q
    int64_t _1252 = 0; // p
    _jump2801:; // Begin body of loop
    _1237 += _1251;
    _1250++;
    if (_1250 < _1244)
    goto _jump2801;
    _1250 = 0;
    _1251++;
    if (_1251 < _1243)
    goto _jump2801;
    _1251 = 0;
    _1252++;
    if (_1252 < _1238)
    goto _jump2801;
    // End body of loop
    int64_t _1253 = _1236 % _1237;
    _1214 = _1253;
    _jump2786:;
    _1212 = _1214;
    goto _jump2802;
    _jump2774:;
    int64_t _1254 = 819;
    _1212 = _1254;
    _jump2802:;
    _1202.d0 = _1212;
    if (_1212 > 0) 
    goto _jump2803;
    fail_assertion("non-positive loop bound");
    _jump2803:;
    // Computing total size of heap memory to allocate
    int64_t _1255 = 1;
    _1255 *= _1212;
    _1255 *= sizeof(o);
    _1202.data = jpl_alloc(_1255);
    int64_t _1256 = 0; // p
    _jump2804:; // Begin body of loop
    _a3_bool _1257;
    // Computing bound for q
    int64_t _1258 = 319;
    _a1_int64_t _1259;
    _1259.d0 = 1;
    _1259.data = jpl_alloc(sizeof(int64_t) * 1);
    _1259.data[0] = _1258;
    if (_455.d1 >= 0)
    goto _jump2805;
    fail_assertion("negative array index");
    _jump2805:;
    if (_455.d1 < _1259.d0)
    goto _jump2806;
    fail_assertion("index too large");
    _jump2806:;
    int64_t _1260 = 0;
    _1260 *= _1259.d0;
    _1260 += _455.d1;
    int64_t _1261 = _1259.data[_1260];
    _1257.d0 = _1261;
    if (_1261 > 0) 
    goto _jump2807;
    fail_assertion("non-positive loop bound");
    _jump2807:;
    // Computing bound for r
    _1257.d1 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump2808;
    fail_assertion("non-positive loop bound");
    _jump2808:;
    // Computing bound for s
    int64_t _1262;
    // Computing bound for q
    bool _1263 = false;
    int64_t _1264;
    if (!_1263)
    goto _jump2809;
    int64_t _1265 = 996;
    _1264 = _1265;
    goto _jump2810;
    _jump2809:;
    int64_t _1266 = 749;
    _1264 = _1266;
    _jump2810:;
    if (_1264 > 0) 
    goto _jump2811;
    fail_assertion("non-positive loop bound");
    _jump2811:;
    // Computing bound for r
    int64_t _1267;
    // Computing bound for q
    if (_455.d0 > 0) 
    goto _jump2812;
    fail_assertion("non-positive loop bound");
    _jump2812:;
    // Computing bound for r
    if (_455.d0 > 0) 
    goto _jump2813;
    fail_assertion("non-positive loop bound");
    _jump2813:;
    _1267 = 0;
    int64_t _1268 = 0; // r
    int64_t _1269 = 0; // q
    _jump2814:; // Begin body of loop
    _1267 += _1256;
    _1268++;
    if (_1268 < _455.d0)
    goto _jump2814;
    _1268 = 0;
    _1269++;
    if (_1269 < _455.d0)
    goto _jump2814;
    // End body of loop
    if (_1267 > 0) 
    goto _jump2815;
    fail_assertion("non-positive loop bound");
    _jump2815:;
    _1262 = 0;
    int64_t _1270 = 0; // r
    int64_t _1271 = 0; // q
    _jump2816:; // Begin body of loop
    int64_t _1272 = 667;
    _1262 += _1272;
    _1270++;
    if (_1270 < _1267)
    goto _jump2816;
    _1270 = 0;
    _1271++;
    if (_1271 < _1264)
    goto _jump2816;
    // End body of loop
    _1257.d2 = _1262;
    if (_1262 > 0) 
    goto _jump2817;
    fail_assertion("non-positive loop bound");
    _jump2817:;
    // Computing total size of heap memory to allocate
    int64_t _1273 = 1;
    _1273 *= _1261;
    _1273 *= _455.d0;
    _1273 *= _1262;
    _1273 *= sizeof(bool);
    _1257.data = jpl_alloc(_1273);
    int64_t _1274 = 0; // s
    int64_t _1275 = 0; // r
    int64_t _1276 = 0; // q
    _jump2818:; // Begin body of loop
    bool _1277 = i(_1275);
    int64_t _1278 = 0;
    _1278 *= _1257.d0;
    _1278 += _1276;
    _1278 *= _1257.d1;
    _1278 += _1275;
    _1278 *= _1257.d2;
    _1278 += _1274;
    _1257.data[_1278] = _1277;
    _1274++;
    if (_1274 < _1262)
    goto _jump2818;
    _1274 = 0;
    _1275++;
    if (_1275 < _455.d0)
    goto _jump2818;
    _1275 = 0;
    _1276++;
    if (_1276 < _1261)
    goto _jump2818;
    // End body of loop
    int64_t _1279 = -_1256;
    int64_t _1280 = _1279 / _455.d1;
    int64_t _1281;
    // Computing bound for q
    int64_t _1282 = -_455.d1;
    if (_1282 > 0) 
    goto _jump2819;
    fail_assertion("non-positive loop bound");
    _jump2819:;
    _1281 = 0;
    int64_t _1283 = 0; // q
    _jump2820:; // Begin body of loop
    int64_t _1284 = 856;
    _1281 += _1284;
    _1283++;
    if (_1283 < _1282)
    goto _jump2820;
    // End body of loop
    int64_t _1285 = -_1281;
    if (_1280 >= 0)
    goto _jump2821;
    fail_assertion("negative array index");
    _jump2821:;
    if (_1280 < _1257.d0)
    goto _jump2822;
    fail_assertion("index too large");
    _jump2822:;
    if (_1285 >= 0)
    goto _jump2823;
    fail_assertion("negative array index");
    _jump2823:;
    if (_1285 < _1257.d1)
    goto _jump2824;
    fail_assertion("index too large");
    _jump2824:;
    if (_455.d1 >= 0)
    goto _jump2825;
    fail_assertion("negative array index");
    _jump2825:;
    if (_455.d1 < _1257.d2)
    goto _jump2826;
    fail_assertion("index too large");
    _jump2826:;
    int64_t _1286 = 0;
    _1286 *= _1257.d0;
    _1286 += _1280;
    _1286 *= _1257.d1;
    _1286 += _1285;
    _1286 *= _1257.d2;
    _1286 += _455.d1;
    bool _1287 = _1257.data[_1286];
    double _1288 = 77.0;
    bool _1289 = _1288 != _893;
    bool _1290 = !_1289;
    _a3_bool _1291;
    // Computing bound for q
    _1291.d0 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump2827;
    fail_assertion("non-positive loop bound");
    _jump2827:;
    // Computing bound for r
    _1291.d1 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump2828;
    fail_assertion("non-positive loop bound");
    _jump2828:;
    // Computing bound for s
    int64_t _1292 = _1256 % _1256;
    _1291.d2 = _1292;
    if (_1292 > 0) 
    goto _jump2829;
    fail_assertion("non-positive loop bound");
    _jump2829:;
    // Computing total size of heap memory to allocate
    int64_t _1293 = 1;
    _1293 *= _455.d1;
    _1293 *= _455.d1;
    _1293 *= _1292;
    _1293 *= sizeof(bool);
    _1291.data = jpl_alloc(_1293);
    int64_t _1294 = 0; // s
    int64_t _1295 = 0; // r
    int64_t _1296 = 0; // q
    _jump2830:; // Begin body of loop
    bool _1297 = i(_1296);
    int64_t _1298 = 0;
    _1298 *= _1291.d0;
    _1298 += _1296;
    _1298 *= _1291.d1;
    _1298 += _1295;
    _1298 *= _1291.d2;
    _1298 += _1294;
    _1291.data[_1298] = _1297;
    _1294++;
    if (_1294 < _1292)
    goto _jump2830;
    _1294 = 0;
    _1295++;
    if (_1295 < _455.d1)
    goto _jump2830;
    _1295 = 0;
    _1296++;
    if (_1296 < _455.d1)
    goto _jump2830;
    // End body of loop
    rgba _1299 = a();
    l _1300 = { _1290, _1291, _1299 };
    _a3_bool _1301 = _1300.b;
    rgba _1302 = m();
    l _1303 = { _1287, _1301, _1302 };
    double _1304 = 30.0;
    double _1305;
    // Computing bound for q
    if (_1256 > 0) 
    goto _jump2831;
    fail_assertion("non-positive loop bound");
    _jump2831:;
    _1305 = 0;
    int64_t _1306 = 0; // q
    _jump2832:; // Begin body of loop
    double _1307 = 56.0;
    _1305 += _1307;
    _1306++;
    if (_1306 < _1256)
    goto _jump2832;
    // End body of loop
    rgba _1308 = a();
    double _1309 = _1308.b;
    double _1310 = 2.0;
    rgba _1311 = { _1304, _1305, _1309, _1310 };
    bool _1312 = _1128;
    if (0 == _1128)
    goto _jump2833;
    bool _1313 = true;
    _1312 = _1313;
    _jump2833:;
    bool _1314;
    if (!_1312)
    goto _jump2834;
    bool _1315 = false;
    bool _1316 = !_1315;
    bool _1317 = !_1316;
    _1314 = _1317;
    goto _jump2835;
    _jump2834:;
    bool _1318 = i(_455.d0);
    _1314 = _1318;
    _jump2835:;
    _a2_bool _1319;
    if (!_1314)
    goto _jump2836;
    bool _1320 = i(_455.d1);
    _a2_bool _1321;
    if (!_1320)
    goto _jump2837;
    _a2_bool _1322;
    // Computing bound for q
    int64_t _1323;
    // Computing bound for q
    if (_455.d1 > 0) 
    goto _jump2838;
    fail_assertion("non-positive loop bound");
    _jump2838:;
    _1323 = 0;
    int64_t _1324 = 0; // q
    _jump2839:; // Begin body of loop
    int64_t _1325 = 557;
    _1323 += _1325;
    _1324++;
    if (_1324 < _455.d1)
    goto _jump2839;
    // End body of loop
    _1322.d0 = _1323;
    if (_1323 > 0) 
    goto _jump2840;
    fail_assertion("non-positive loop bound");
    _jump2840:;
    // Computing bound for r
    _1322.d1 = _455.d0;
    if (_455.d0 > 0) 
    goto _jump2841;
    fail_assertion("non-positive loop bound");
    _jump2841:;
    // Computing total size of heap memory to allocate
    int64_t _1326 = 1;
    _1326 *= _1323;
    _1326 *= _455.d0;
    _1326 *= sizeof(bool);
    _1322.data = jpl_alloc(_1326);
    int64_t _1327 = 0; // r
    int64_t _1328 = 0; // q
    _jump2842:; // Begin body of loop
    bool _1329 = _1128;
    if (0 != _1128)
    goto _jump2843;
    bool _1330 = false;
    _1329 = _1330;
    _jump2843:;
    int64_t _1331 = 0;
    _1331 *= _1322.d0;
    _1331 += _1328;
    _1331 *= _1322.d1;
    _1331 += _1327;
    _1322.data[_1331] = _1329;
    _1327++;
    if (_1327 < _455.d0)
    goto _jump2842;
    _1327 = 0;
    _1328++;
    if (_1328 < _1323)
    goto _jump2842;
    // End body of loop
    _1321 = _1322;
    goto _jump2844;
    _jump2837:;
    _a2_bool _1332;
    // Computing bound for q
    int64_t _1333;
    // Computing bound for q
    int64_t _1334 = 202;
    if (_1334 > 0) 
    goto _jump2845;
    fail_assertion("non-positive loop bound");
    _jump2845:;
    // Computing bound for r
    if (_455.d0 > 0) 
    goto _jump2846;
    fail_assertion("non-positive loop bound");
    _jump2846:;
    _1333 = 0;
    int64_t _1335 = 0; // r
    int64_t _1336 = 0; // q
    _jump2847:; // Begin body of loop
    _1333 += _1335;
    _1335++;
    if (_1335 < _455.d0)
    goto _jump2847;
    _1335 = 0;
    _1336++;
    if (_1336 < _1334)
    goto _jump2847;
    // End body of loop
    _1332.d0 = _1333;
    if (_1333 > 0) 
    goto _jump2848;
    fail_assertion("non-positive loop bound");
    _jump2848:;
    // Computing bound for r
    _1332.d1 = _1256;
    if (_1256 > 0) 
    goto _jump2849;
    fail_assertion("non-positive loop bound");
    _jump2849:;
    // Computing total size of heap memory to allocate
    int64_t _1337 = 1;
    _1337 *= _1333;
    _1337 *= _1256;
    _1337 *= sizeof(bool);
    _1332.data = jpl_alloc(_1337);
    int64_t _1338 = 0; // r
    int64_t _1339 = 0; // q
    _jump2850:; // Begin body of loop
    bool _1340 = i(_1338);
    int64_t _1341 = 0;
    _1341 *= _1332.d0;
    _1341 += _1339;
    _1341 *= _1332.d1;
    _1341 += _1338;
    _1332.data[_1341] = _1340;
    _1338++;
    if (_1338 < _1256)
    goto _jump2850;
    _1338 = 0;
    _1339++;
    if (_1339 < _1333)
    goto _jump2850;
    // End body of loop
    _1321 = _1332;
    _jump2844:;
    _1319 = _1321;
    goto _jump2851;
    _jump2836:;
    bool _1342 = false;
    _a2_bool _1343;
    if (!_1342)
    goto _jump2852;
    _a2_bool _1344;
    // Computing bound for q
    bool _1345 = false;
    int64_t _1346;
    if (!_1345)
    goto _jump2853;
    int64_t _1347 = 633;
    _1346 = _1347;
    goto _jump2854;
    _jump2853:;
    _1346 = _455.d1;
    _jump2854:;
    _1344.d0 = _1346;
    if (_1346 > 0) 
    goto _jump2855;
    fail_assertion("non-positive loop bound");
    _jump2855:;
    // Computing bound for r
    _1344.d1 = _1256;
    if (_1256 > 0) 
    goto _jump2856;
    fail_assertion("non-positive loop bound");
    _jump2856:;
    // Computing total size of heap memory to allocate
    int64_t _1348 = 1;
    _1348 *= _1346;
    _1348 *= _1256;
    _1348 *= sizeof(bool);
    _1344.data = jpl_alloc(_1348);
    int64_t _1349 = 0; // r
    int64_t _1350 = 0; // q
    _jump2857:; // Begin body of loop
    double _1351 = 28.0;
    bool _1352 = _893 < _1351;
    int64_t _1353 = 0;
    _1353 *= _1344.d0;
    _1353 += _1350;
    _1353 *= _1344.d1;
    _1353 += _1349;
    _1344.data[_1353] = _1352;
    _1349++;
    if (_1349 < _1256)
    goto _jump2857;
    _1349 = 0;
    _1350++;
    if (_1350 < _1346)
    goto _jump2857;
    // End body of loop
    _1343 = _1344;
    goto _jump2858;
    _jump2852:;
    _a2_bool _1354;
    // Computing bound for q
    _1354.d0 = _455.d1;
    if (_455.d1 > 0) 
    goto _jump2859;
    fail_assertion("non-positive loop bound");
    _jump2859:;
    // Computing bound for r
    int64_t _1355 = 988;
    _1354.d1 = _1355;
    if (_1355 > 0) 
    goto _jump2860;
    fail_assertion("non-positive loop bound");
    _jump2860:;
    // Computing total size of heap memory to allocate
    int64_t _1356 = 1;
    _1356 *= _455.d1;
    _1356 *= _1355;
    _1356 *= sizeof(bool);
    _1354.data = jpl_alloc(_1356);
    int64_t _1357 = 0; // r
    int64_t _1358 = 0; // q
    _jump2861:; // Begin body of loop
    int64_t _1359 = 0;
    _1359 *= _1354.d0;
    _1359 += _1358;
    _1359 *= _1354.d1;
    _1359 += _1357;
    _1354.data[_1359] = _1128;
    _1357++;
    if (_1357 < _1355)
    goto _jump2861;
    _1357 = 0;
    _1358++;
    if (_1358 < _455.d1)
    goto _jump2861;
    // End body of loop
    _1343 = _1354;
    _jump2858:;
    _1319 = _1343;
    _jump2851:;
    int64_t _1360 = 756;
    int64_t _1361;
    // Computing bound for q
    int64_t _1362 = 136;
    if (_1362 > 0) 
    goto _jump2862;
    fail_assertion("non-positive loop bound");
    _jump2862:;
    // Computing bound for r
    int64_t _1363 = _455.d0 / _1256;
    int64_t _1364 = 99;
    int64_t _1365 = _1363 + _1364;
    if (_1365 > 0) 
    goto _jump2863;
    fail_assertion("non-positive loop bound");
    _jump2863:;
    _1361 = 0;
    int64_t _1366 = 0; // r
    int64_t _1367 = 0; // q
    _jump2864:; // Begin body of loop
    int64_t _1368 = -_455.d0;
    _1361 += _1368;
    _1366++;
    if (_1366 < _1365)
    goto _jump2864;
    _1366 = 0;
    _1367++;
    if (_1367 < _1362)
    goto _jump2864;
    // End body of loop
    int64_t _1369 = 374;
    int64_t _1370 = _1361 - _1369;
    if (_1360 >= 0)
    goto _jump2865;
    fail_assertion("negative array index");
    _jump2865:;
    if (_1360 < _1319.d0)
    goto _jump2866;
    fail_assertion("index too large");
    _jump2866:;
    if (_1370 >= 0)
    goto _jump2867;
    fail_assertion("negative array index");
    _jump2867:;
    if (_1370 < _1319.d1)
    goto _jump2868;
    fail_assertion("index too large");
    _jump2868:;
    int64_t _1371 = 0;
    _1371 *= _1319.d0;
    _1371 += _1360;
    _1371 *= _1319.d1;
    _1371 += _1370;
    bool _1372 = _1319.data[_1371];
    o _1373 = { _1303, _1311, _1372 };
    int64_t _1374 = 0;
    _1374 *= _1202.d0;
    _1374 += _1256;
    _1202.data[_1374] = _1373;
    _1256++;
    if (_1256 < _1212)
    goto _jump2804;
    // End body of loop
    show("(FloatType)", &_893);
}

